; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+8
dfp_lmdtable DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	08H
	DD	09H
	DD	08H
	DD	09H
	DD	00H
	DD	00H
CONST	ENDS
PUBLIC	s370_convert_fix32_to_dfp_ext_reg
PUBLIC	s370_convert_fix32_to_dfp_long_reg
PUBLIC	s370_convert_u32_to_dfp_ext_reg
PUBLIC	s370_convert_u32_to_dfp_long_reg
PUBLIC	s370_convert_u64_to_dfp_ext_reg
PUBLIC	s370_convert_u64_to_dfp_long_reg
PUBLIC	s370_convert_dfp_ext_to_fix32_reg
PUBLIC	s370_convert_dfp_long_to_fix32_reg
PUBLIC	s370_convert_dfp_ext_to_u32_reg
PUBLIC	s370_convert_dfp_long_to_u32_reg
PUBLIC	s370_convert_dfp_ext_to_u64_reg
PUBLIC	s370_convert_dfp_long_to_u64_reg
PUBLIC	s370_set_dfp_rounding_mode
PUBLIC	s370_load_fpr_from_gr_long_reg
PUBLIC	s370_load_gr_from_fpr_long_reg
PUBLIC	s370_copy_sign_fpr_long_reg
PUBLIC	s370_load_complement_fpr_long_reg
PUBLIC	s370_load_negative_fpr_long_reg
PUBLIC	s370_load_positive_fpr_long_reg
PUBLIC	s370_load_fpc_and_signal
PUBLIC	s370_set_fpc_and_signal
PUBLIC	s370_add_dfp_ext_reg
PUBLIC	s370_add_dfp_long_reg
PUBLIC	s370_compare_dfp_ext_reg
PUBLIC	s370_compare_dfp_long_reg
PUBLIC	s370_compare_and_signal_dfp_ext_reg
PUBLIC	s370_compare_and_signal_dfp_long_reg
PUBLIC	s370_compare_exponent_dfp_ext_reg
PUBLIC	s370_compare_exponent_dfp_long_reg
PUBLIC	s370_convert_fix64_to_dfp_ext_reg
PUBLIC	s370_convert_fix64_to_dfp_long_reg
PUBLIC	s370_convert_sbcd128_to_dfp_ext_reg
PUBLIC	s370_convert_sbcd64_to_dfp_long_reg
PUBLIC	s370_convert_ubcd128_to_dfp_ext_reg
PUBLIC	s370_convert_ubcd64_to_dfp_long_reg
PUBLIC	s370_convert_dfp_ext_to_fix64_reg
PUBLIC	s370_convert_dfp_long_to_fix64_reg
PUBLIC	s370_convert_dfp_ext_to_sbcd128_reg
PUBLIC	s370_convert_dfp_long_to_sbcd64_reg
PUBLIC	s370_convert_dfp_ext_to_ubcd128_reg
PUBLIC	s370_convert_dfp_long_to_ubcd64_reg
PUBLIC	s370_divide_dfp_ext_reg
PUBLIC	s370_divide_dfp_long_reg
PUBLIC	s370_extract_biased_exponent_dfp_ext_to_fix64_reg
PUBLIC	s370_extract_biased_exponent_dfp_long_to_fix64_reg
PUBLIC	s370_extract_significance_dfp_ext_reg
PUBLIC	s370_extract_significance_dfp_long_reg
PUBLIC	s370_insert_biased_exponent_fix64_to_dfp_ext_reg
PUBLIC	s370_insert_biased_exponent_fix64_to_dfp_long_reg
PUBLIC	s370_load_and_test_dfp_ext_reg
PUBLIC	s370_load_and_test_dfp_long_reg
PUBLIC	s370_load_fp_int_dfp_ext_reg
PUBLIC	s370_load_fp_int_dfp_long_reg
PUBLIC	s370_load_lengthened_dfp_long_to_ext_reg
PUBLIC	s370_load_lengthened_dfp_short_to_long_reg
PUBLIC	s370_load_rounded_dfp_ext_to_long_reg
PUBLIC	s370_load_rounded_dfp_long_to_short_reg
PUBLIC	s370_multiply_dfp_ext_reg
PUBLIC	s370_multiply_dfp_long_reg
PUBLIC	s370_quantize_dfp_ext_reg
PUBLIC	s370_quantize_dfp_long_reg
PUBLIC	s370_reround_dfp_ext_reg
PUBLIC	s370_reround_dfp_long_reg
PUBLIC	s370_shift_coefficient_left_dfp_ext
PUBLIC	s370_shift_coefficient_left_dfp_long
PUBLIC	s370_shift_coefficient_right_dfp_ext
PUBLIC	s370_shift_coefficient_right_dfp_long
PUBLIC	s370_subtract_dfp_ext_reg
PUBLIC	s370_subtract_dfp_long_reg
PUBLIC	s370_test_data_class_dfp_ext
PUBLIC	s370_test_data_class_dfp_long
PUBLIC	s370_test_data_class_dfp_short
PUBLIC	s370_test_data_group_dfp_ext
PUBLIC	s370_test_data_group_dfp_long
PUBLIC	s370_test_data_group_dfp_short
PUBLIC	fetch_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	s370_FPC_check
PUBLIC	s370_maddr_l
PUBLIC	s370_vfetch4_full
PUBLIC	s370_vfetch4
PUBLIC	z900_convert_fix32_to_dfp_ext_reg
PUBLIC	z900_convert_fix32_to_dfp_long_reg
PUBLIC	z900_convert_u32_to_dfp_ext_reg
PUBLIC	z900_convert_u32_to_dfp_long_reg
PUBLIC	z900_convert_u64_to_dfp_ext_reg
PUBLIC	z900_convert_u64_to_dfp_long_reg
PUBLIC	z900_convert_dfp_ext_to_fix32_reg
PUBLIC	z900_convert_dfp_long_to_fix32_reg
PUBLIC	z900_convert_dfp_ext_to_u32_reg
PUBLIC	z900_convert_dfp_long_to_u32_reg
PUBLIC	z900_convert_dfp_ext_to_u64_reg
PUBLIC	z900_convert_dfp_long_to_u64_reg
PUBLIC	z900_set_dfp_rounding_mode
PUBLIC	z900_load_fpr_from_gr_long_reg
PUBLIC	z900_load_gr_from_fpr_long_reg
PUBLIC	z900_copy_sign_fpr_long_reg
PUBLIC	z900_load_complement_fpr_long_reg
PUBLIC	z900_load_negative_fpr_long_reg
PUBLIC	z900_load_positive_fpr_long_reg
PUBLIC	z900_load_fpc_and_signal
PUBLIC	z900_set_fpc_and_signal
PUBLIC	z900_add_dfp_ext_reg
PUBLIC	z900_add_dfp_long_reg
PUBLIC	z900_compare_dfp_ext_reg
PUBLIC	z900_compare_dfp_long_reg
PUBLIC	z900_compare_and_signal_dfp_ext_reg
PUBLIC	z900_compare_and_signal_dfp_long_reg
PUBLIC	z900_compare_exponent_dfp_ext_reg
PUBLIC	z900_compare_exponent_dfp_long_reg
PUBLIC	z900_convert_fix64_to_dfp_ext_reg
PUBLIC	z900_convert_fix64_to_dfp_long_reg
PUBLIC	z900_convert_sbcd128_to_dfp_ext_reg
PUBLIC	z900_convert_sbcd64_to_dfp_long_reg
PUBLIC	z900_convert_ubcd128_to_dfp_ext_reg
PUBLIC	z900_convert_ubcd64_to_dfp_long_reg
PUBLIC	z900_convert_dfp_ext_to_fix64_reg
PUBLIC	z900_convert_dfp_long_to_fix64_reg
PUBLIC	z900_convert_dfp_ext_to_sbcd128_reg
PUBLIC	z900_convert_dfp_long_to_sbcd64_reg
PUBLIC	z900_convert_dfp_ext_to_ubcd128_reg
PUBLIC	z900_convert_dfp_long_to_ubcd64_reg
PUBLIC	z900_divide_dfp_ext_reg
PUBLIC	z900_divide_dfp_long_reg
PUBLIC	z900_extract_biased_exponent_dfp_ext_to_fix64_reg
PUBLIC	z900_extract_biased_exponent_dfp_long_to_fix64_reg
PUBLIC	z900_extract_significance_dfp_ext_reg
PUBLIC	z900_extract_significance_dfp_long_reg
PUBLIC	z900_insert_biased_exponent_fix64_to_dfp_ext_reg
PUBLIC	z900_insert_biased_exponent_fix64_to_dfp_long_reg
PUBLIC	z900_load_and_test_dfp_ext_reg
PUBLIC	z900_load_and_test_dfp_long_reg
PUBLIC	z900_load_fp_int_dfp_ext_reg
PUBLIC	z900_load_fp_int_dfp_long_reg
PUBLIC	z900_load_lengthened_dfp_long_to_ext_reg
PUBLIC	z900_load_lengthened_dfp_short_to_long_reg
PUBLIC	z900_load_rounded_dfp_ext_to_long_reg
PUBLIC	z900_load_rounded_dfp_long_to_short_reg
PUBLIC	z900_multiply_dfp_ext_reg
PUBLIC	z900_multiply_dfp_long_reg
PUBLIC	z900_quantize_dfp_ext_reg
PUBLIC	z900_quantize_dfp_long_reg
PUBLIC	z900_reround_dfp_ext_reg
PUBLIC	z900_reround_dfp_long_reg
PUBLIC	z900_shift_coefficient_left_dfp_ext
PUBLIC	z900_shift_coefficient_left_dfp_long
PUBLIC	z900_shift_coefficient_right_dfp_ext
PUBLIC	z900_shift_coefficient_right_dfp_long
PUBLIC	z900_subtract_dfp_ext_reg
PUBLIC	z900_subtract_dfp_long_reg
PUBLIC	z900_test_data_class_dfp_ext
PUBLIC	z900_test_data_class_dfp_long
PUBLIC	z900_test_data_class_dfp_short
PUBLIC	z900_test_data_group_dfp_ext
PUBLIC	z900_test_data_group_dfp_long
PUBLIC	z900_test_data_group_dfp_short
PUBLIC	z900_convert_zoned_to_dfp_ext
PUBLIC	z900_convert_zoned_to_dfp_long
PUBLIC	z900_convert_dfp_ext_to_zoned
PUBLIC	z900_convert_dfp_long_to_zoned
PUBLIC	z900_convert_packed_to_dfp_ext
PUBLIC	z900_convert_packed_to_dfp_long
PUBLIC	z900_convert_dfp_ext_to_packed
PUBLIC	z900_convert_dfp_long_to_packed
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_xcheck
PUBLIC	z900_FPC_check
PUBLIC	z900_maddr_l
PUBLIC	z900_vfetch4_full
PUBLIC	z900_vstorec
PUBLIC	z900_vfetchc
PUBLIC	z900_vfetch4
EXTRN	__report_rangecheckfailure:PROC
EXTRN	memmove:PROC
EXTRN	strlen:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	longjmp:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	z900_abort_transaction:PROC
EXTRN	s370_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	decContextDefault:PROC
EXTRN	decNumberFromString:PROC
EXTRN	decNumberToString:PROC
EXTRN	decNumberAdd:PROC
EXTRN	decNumberCompare:PROC
EXTRN	decNumberDivide:PROC
EXTRN	decNumberMultiply:PROC
EXTRN	decNumberNormalize:PROC
EXTRN	decNumberPlus:PROC
EXTRN	decNumberQuantize:PROC
EXTRN	decNumberSubtract:PROC
EXTRN	decNumberToIntegralValue:PROC
EXTRN	decNumberCopy:PROC
EXTRN	decimal128FromNumber:PROC
EXTRN	decimal128ToNumber:PROC
EXTRN	decimal64FromNumber:PROC
EXTRN	decimal64ToNumber:PROC
EXTRN	decimal32FromNumber:PROC
EXTRN	decimal32ToNumber:PROC
EXTRN	decPackedFromNumber:PROC
EXTRN	decPackedToNumber:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
?mpflag@?1??dfp_number_to_fix64@@9@9 DB 01H DUP (?)	; `dfp_number_to_fix64'::`2'::mpflag
	ALIGN	4

?mp@?1??dfp_number_to_fix64@@9@9 DB 024H DUP (?)	; `dfp_number_to_fix64'::`2'::mp
?mn@?1??dfp_number_to_fix64@@9@9 DB 024H DUP (?)	; `dfp_number_to_fix64'::`2'::mn
?mp32flag@?1??dfp_number_to_fix32@@9@9 DB 01H DUP (?)	; `dfp_number_to_fix32'::`2'::mp32flag
	ALIGN	4

?mp32dn@?1??dfp_number_to_fix32@@9@9 DB 024H DUP (?)	; `dfp_number_to_fix32'::`2'::mp32dn
?mn32dn@?1??dfp_number_to_fix32@@9@9 DB 024H DUP (?)	; `dfp_number_to_fix32'::`2'::mn32dn
?mu32flag@?1??dfp_number_to_u32@@9@9 DB 01H DUP (?)	; `dfp_number_to_u32'::`2'::mu32flag
	ALIGN	4

?mu32dn@?1??dfp_number_to_u32@@9@9 DB 024H DUP (?)	; `dfp_number_to_u32'::`2'::mu32dn
?mu64flag@?1??dfp_number_to_u64@@9@9 DB 01H DUP (?)	; `dfp_number_to_u64'::`2'::mu64flag
	ALIGN	4

?mu64dn@?1??dfp_number_to_u64@@9@9 DB 024H DUP (?)	; `dfp_number_to_u64'::`2'::mu64dn
_BSS	ENDS
pdata	SEGMENT
$pdata$s370_convert_fix32_to_dfp_ext_reg DD imagerel $LN10
	DD	imagerel $LN10+493
	DD	imagerel $unwind$s370_convert_fix32_to_dfp_ext_reg
$pdata$s370_convert_fix32_to_dfp_long_reg DD imagerel $LN9
	DD	imagerel $LN9+477
	DD	imagerel $unwind$s370_convert_fix32_to_dfp_long_reg
$pdata$s370_convert_u32_to_dfp_ext_reg DD imagerel $LN10
	DD	imagerel $LN10+493
	DD	imagerel $unwind$s370_convert_u32_to_dfp_ext_reg
$pdata$s370_convert_u32_to_dfp_long_reg DD imagerel $LN9
	DD	imagerel $LN9+477
	DD	imagerel $unwind$s370_convert_u32_to_dfp_long_reg
$pdata$s370_convert_u64_to_dfp_ext_reg DD imagerel $LN10
	DD	imagerel $LN10+496
	DD	imagerel $unwind$s370_convert_u64_to_dfp_ext_reg
$pdata$s370_convert_u64_to_dfp_long_reg DD imagerel $LN9
	DD	imagerel $LN9+480
	DD	imagerel $unwind$s370_convert_u64_to_dfp_long_reg
$pdata$s370_convert_dfp_ext_to_fix32_reg DD imagerel $LN17
	DD	imagerel $LN17+696
	DD	imagerel $unwind$s370_convert_dfp_ext_to_fix32_reg
$pdata$s370_convert_dfp_long_to_fix32_reg DD imagerel $LN16
	DD	imagerel $LN16+652
	DD	imagerel $unwind$s370_convert_dfp_long_to_fix32_reg
$pdata$s370_convert_dfp_ext_to_u32_reg DD imagerel $LN17
	DD	imagerel $LN17+696
	DD	imagerel $unwind$s370_convert_dfp_ext_to_u32_reg
$pdata$s370_convert_dfp_long_to_u32_reg DD imagerel $LN16
	DD	imagerel $LN16+652
	DD	imagerel $unwind$s370_convert_dfp_long_to_u32_reg
$pdata$s370_convert_dfp_ext_to_u64_reg DD imagerel $LN17
	DD	imagerel $LN17+699
	DD	imagerel $unwind$s370_convert_dfp_ext_to_u64_reg
$pdata$s370_convert_dfp_long_to_u64_reg DD imagerel $LN16
	DD	imagerel $LN16+664
	DD	imagerel $unwind$s370_convert_dfp_long_to_u64_reg
$pdata$s370_set_dfp_rounding_mode DD imagerel $LN10
	DD	imagerel $LN10+347
	DD	imagerel $unwind$s370_set_dfp_rounding_mode
$pdata$s370_load_fpr_from_gr_long_reg DD imagerel $LN10
	DD	imagerel $LN10+331
	DD	imagerel $unwind$s370_load_fpr_from_gr_long_reg
$pdata$s370_load_gr_from_fpr_long_reg DD imagerel $LN10
	DD	imagerel $LN10+330
	DD	imagerel $unwind$s370_load_gr_from_fpr_long_reg
$pdata$s370_copy_sign_fpr_long_reg DD imagerel $LN14
	DD	imagerel $LN14+616
	DD	imagerel $unwind$s370_copy_sign_fpr_long_reg
$pdata$s370_load_complement_fpr_long_reg DD imagerel $LN11
	DD	imagerel $LN11+358
	DD	imagerel $unwind$s370_load_complement_fpr_long_reg
$pdata$s370_load_negative_fpr_long_reg DD imagerel $LN11
	DD	imagerel $LN11+358
	DD	imagerel $unwind$s370_load_negative_fpr_long_reg
$pdata$s370_load_positive_fpr_long_reg DD imagerel $LN11
	DD	imagerel $LN11+358
	DD	imagerel $unwind$s370_load_positive_fpr_long_reg
$pdata$s370_load_fpc_and_signal DD imagerel $LN13
	DD	imagerel $LN13+488
	DD	imagerel $unwind$s370_load_fpc_and_signal
$pdata$s370_set_fpc_and_signal DD imagerel $LN12
	DD	imagerel $LN12+437
	DD	imagerel $unwind$s370_set_fpc_and_signal
$pdata$s370_add_dfp_ext_reg DD imagerel $LN18
	DD	imagerel $LN18+786
	DD	imagerel $unwind$s370_add_dfp_ext_reg
$pdata$s370_add_dfp_long_reg DD imagerel $LN16
	DD	imagerel $LN16+723
	DD	imagerel $unwind$s370_add_dfp_long_reg
$pdata$s370_compare_dfp_ext_reg DD imagerel $LN18
	DD	imagerel $LN18+691
	DD	imagerel $unwind$s370_compare_dfp_ext_reg
$pdata$s370_compare_dfp_long_reg DD imagerel $LN16
	DD	imagerel $LN16+633
	DD	imagerel $unwind$s370_compare_dfp_long_reg
$pdata$s370_compare_and_signal_dfp_ext_reg DD imagerel $LN19
	DD	imagerel $LN19+719
	DD	imagerel $unwind$s370_compare_and_signal_dfp_ext_reg
$pdata$s370_compare_and_signal_dfp_long_reg DD imagerel $LN17
	DD	imagerel $LN17+664
	DD	imagerel $unwind$s370_compare_and_signal_dfp_long_reg
$pdata$s370_compare_exponent_dfp_ext_reg DD imagerel $LN11
	DD	imagerel $LN11+473
	DD	imagerel $unwind$s370_compare_exponent_dfp_ext_reg
$pdata$s370_compare_exponent_dfp_long_reg DD imagerel $LN9
	DD	imagerel $LN9+424
	DD	imagerel $unwind$s370_compare_exponent_dfp_long_reg
$pdata$s370_convert_fix64_to_dfp_ext_reg DD imagerel $LN10
	DD	imagerel $LN10+467
	DD	imagerel $unwind$s370_convert_fix64_to_dfp_ext_reg
$pdata$s370_convert_fix64_to_dfp_long_reg DD imagerel $LN10
	DD	imagerel $LN10+497
	DD	imagerel $unwind$s370_convert_fix64_to_dfp_long_reg
$pdata$s370_convert_sbcd128_to_dfp_ext_reg DD imagerel $LN12
	DD	imagerel $LN12+611
	DD	imagerel $unwind$s370_convert_sbcd128_to_dfp_ext_reg
$pdata$s370_convert_sbcd64_to_dfp_long_reg DD imagerel $LN10
	DD	imagerel $LN10+490
	DD	imagerel $unwind$s370_convert_sbcd64_to_dfp_long_reg
$pdata$s370_convert_ubcd128_to_dfp_ext_reg DD imagerel $LN17
	DD	imagerel $LN17+767
	DD	imagerel $unwind$s370_convert_ubcd128_to_dfp_ext_reg
$pdata$s370_convert_ubcd64_to_dfp_long_reg DD imagerel $LN15
	DD	imagerel $LN15+646
	DD	imagerel $unwind$s370_convert_ubcd64_to_dfp_long_reg
$pdata$s370_convert_dfp_ext_to_fix64_reg DD imagerel $LN17
	DD	imagerel $LN17+685
	DD	imagerel $unwind$s370_convert_dfp_ext_to_fix64_reg
$pdata$s370_convert_dfp_long_to_fix64_reg DD imagerel $LN16
	DD	imagerel $LN16+641
	DD	imagerel $unwind$s370_convert_dfp_long_to_fix64_reg
$pdata$s370_convert_dfp_ext_to_sbcd128_reg DD imagerel $LN14
	DD	imagerel $LN14+679
	DD	imagerel $unwind$s370_convert_dfp_ext_to_sbcd128_reg
$pdata$s370_convert_dfp_long_to_sbcd64_reg DD imagerel $LN12
	DD	imagerel $LN12+554
	DD	imagerel $unwind$s370_convert_dfp_long_to_sbcd64_reg
$pdata$s370_convert_dfp_ext_to_ubcd128_reg DD imagerel $LN16
	DD	imagerel $LN16+687
	DD	imagerel $unwind$s370_convert_dfp_ext_to_ubcd128_reg
$pdata$s370_convert_dfp_long_to_ubcd64_reg DD imagerel $LN14
	DD	imagerel $LN14+562
	DD	imagerel $unwind$s370_convert_dfp_long_to_ubcd64_reg
$pdata$s370_divide_dfp_ext_reg DD imagerel $LN12
	DD	imagerel $LN12+641
	DD	imagerel $unwind$s370_divide_dfp_ext_reg
$pdata$s370_divide_dfp_long_reg DD imagerel $LN10
	DD	imagerel $LN10+575
	DD	imagerel $unwind$s370_divide_dfp_long_reg
$pdata$s370_extract_biased_exponent_dfp_ext_to_fix64_reg DD imagerel $LN16
	DD	imagerel $LN16+505
	DD	imagerel $unwind$s370_extract_biased_exponent_dfp_ext_to_fix64_reg
$pdata$s370_extract_biased_exponent_dfp_long_to_fix64_reg DD imagerel $LN15
	DD	imagerel $LN15+467
	DD	imagerel $unwind$s370_extract_biased_exponent_dfp_long_to_fix64_reg
$pdata$s370_extract_significance_dfp_ext_reg DD imagerel $LN18
	DD	imagerel $LN18+547
	DD	imagerel $unwind$s370_extract_significance_dfp_ext_reg
$pdata$s370_extract_significance_dfp_long_reg DD imagerel $LN17
	DD	imagerel $LN17+509
	DD	imagerel $unwind$s370_extract_significance_dfp_long_reg
$pdata$s370_insert_biased_exponent_fix64_to_dfp_ext_reg DD imagerel $LN20
	DD	imagerel $LN20+801
	DD	imagerel $unwind$s370_insert_biased_exponent_fix64_to_dfp_ext_reg
$pdata$s370_insert_biased_exponent_fix64_to_dfp_long_reg DD imagerel $LN18
	DD	imagerel $LN18+737
	DD	imagerel $unwind$s370_insert_biased_exponent_fix64_to_dfp_long_reg
$pdata$s370_load_and_test_dfp_ext_reg DD imagerel $LN19
	DD	imagerel $LN19+711
	DD	imagerel $unwind$s370_load_and_test_dfp_ext_reg
$pdata$s370_load_and_test_dfp_long_reg DD imagerel $LN17
	DD	imagerel $LN17+656
	DD	imagerel $unwind$s370_load_and_test_dfp_long_reg
$pdata$s370_load_fp_int_dfp_ext_reg DD imagerel $LN28
	DD	imagerel $LN28+984
	DD	imagerel $unwind$s370_load_fp_int_dfp_ext_reg
$pdata$s370_load_fp_int_dfp_long_reg DD imagerel $LN26
	DD	imagerel $LN26+947
	DD	imagerel $unwind$s370_load_fp_int_dfp_long_reg
$pdata$s370_load_lengthened_dfp_long_to_ext_reg DD imagerel $LN16
	DD	imagerel $LN16+752
	DD	imagerel $unwind$s370_load_lengthened_dfp_long_to_ext_reg
$pdata$s370_load_lengthened_dfp_short_to_long_reg DD imagerel $LN15
	DD	imagerel $LN15+708
	DD	imagerel $unwind$s370_load_lengthened_dfp_short_to_long_reg
$pdata$s370_load_rounded_dfp_ext_to_long_reg DD imagerel $LN21
	DD	imagerel $LN21+882
	DD	imagerel $unwind$s370_load_rounded_dfp_ext_to_long_reg
$pdata$s370_load_rounded_dfp_long_to_short_reg DD imagerel $LN20
	DD	imagerel $LN20+829
	DD	imagerel $unwind$s370_load_rounded_dfp_long_to_short_reg
$pdata$s370_multiply_dfp_ext_reg DD imagerel $LN12
	DD	imagerel $LN12+641
	DD	imagerel $unwind$s370_multiply_dfp_ext_reg
$pdata$s370_multiply_dfp_long_reg DD imagerel $LN10
	DD	imagerel $LN10+575
	DD	imagerel $unwind$s370_multiply_dfp_long_reg
$pdata$s370_quantize_dfp_ext_reg DD imagerel $LN12
	DD	imagerel $LN12+657
	DD	imagerel $unwind$s370_quantize_dfp_ext_reg
$pdata$s370_quantize_dfp_long_reg DD imagerel $LN10
	DD	imagerel $LN10+591
	DD	imagerel $unwind$s370_quantize_dfp_long_reg
$pdata$s370_reround_dfp_ext_reg DD imagerel $LN16
	DD	imagerel $LN16+737
	DD	imagerel $unwind$s370_reround_dfp_ext_reg
$pdata$s370_reround_dfp_long_reg DD imagerel $LN14
	DD	imagerel $LN14+676
	DD	imagerel $unwind$s370_reround_dfp_long_reg
$pdata$s370_shift_coefficient_left_dfp_ext DD imagerel $LN21
	DD	imagerel $LN21+800
	DD	imagerel $unwind$s370_shift_coefficient_left_dfp_ext
$pdata$s370_shift_coefficient_left_dfp_long DD imagerel $LN19
	DD	imagerel $LN19+739
	DD	imagerel $unwind$s370_shift_coefficient_left_dfp_long
$pdata$s370_shift_coefficient_right_dfp_ext DD imagerel $LN21
	DD	imagerel $LN21+804
	DD	imagerel $unwind$s370_shift_coefficient_right_dfp_ext
$pdata$s370_shift_coefficient_right_dfp_long DD imagerel $LN19
	DD	imagerel $LN19+743
	DD	imagerel $unwind$s370_shift_coefficient_right_dfp_long
$pdata$s370_subtract_dfp_ext_reg DD imagerel $LN18
	DD	imagerel $LN18+786
	DD	imagerel $unwind$s370_subtract_dfp_ext_reg
$pdata$s370_subtract_dfp_long_reg DD imagerel $LN16
	DD	imagerel $LN16+723
	DD	imagerel $unwind$s370_subtract_dfp_long_reg
$pdata$s370_test_data_class_dfp_ext DD imagerel $LN12
	DD	imagerel $LN12+560
	DD	imagerel $unwind$s370_test_data_class_dfp_ext
$pdata$s370_test_data_class_dfp_long DD imagerel $LN11
	DD	imagerel $LN11+522
	DD	imagerel $unwind$s370_test_data_class_dfp_long
$pdata$s370_test_data_class_dfp_short DD imagerel $LN11
	DD	imagerel $LN11+522
	DD	imagerel $unwind$s370_test_data_class_dfp_short
$pdata$s370_test_data_group_dfp_ext DD imagerel $LN12
	DD	imagerel $LN12+579
	DD	imagerel $unwind$s370_test_data_group_dfp_ext
$pdata$s370_test_data_group_dfp_long DD imagerel $LN11
	DD	imagerel $LN11+541
	DD	imagerel $unwind$s370_test_data_group_dfp_long
$pdata$s370_test_data_group_dfp_short DD imagerel $LN11
	DD	imagerel $LN11+541
	DD	imagerel $unwind$s370_test_data_group_dfp_short
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_FPC_check DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s370_FPC_check
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+288
	DD	imagerel $unwind$s370_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4 DD imagerel $LN26
	DD	imagerel $LN26+275
	DD	imagerel $unwind$s370_vfetch4
pdata	ENDS
pdata	SEGMENT
$pdata$fpc_signal_check DD imagerel fpc_signal_check
	DD	imagerel fpc_signal_check+247
	DD	imagerel $unwind$fpc_signal_check
$pdata$dfp32_extract_lmd DD imagerel dfp32_extract_lmd
	DD	imagerel dfp32_extract_lmd+45
	DD	imagerel $unwind$dfp32_extract_lmd
$pdata$dfp64_extract_lmd DD imagerel dfp64_extract_lmd
	DD	imagerel dfp64_extract_lmd+46
	DD	imagerel $unwind$dfp64_extract_lmd
$pdata$dfp128_extract_lmd DD imagerel dfp128_extract_lmd
	DD	imagerel dfp128_extract_lmd+46
	DD	imagerel $unwind$dfp128_extract_lmd
$pdata$dfp_compare_exponent DD imagerel dfp_compare_exponent
	DD	imagerel dfp_compare_exponent+271
	DD	imagerel $unwind$dfp_compare_exponent
$pdata$dfp_number_from_fix64 DD imagerel dfp_number_from_fix64
	DD	imagerel dfp_number_from_fix64+310
	DD	imagerel $unwind$dfp_number_from_fix64
$pdata$dfp_number_to_fix64 DD imagerel dfp_number_to_fix64
	DD	imagerel dfp_number_to_fix64+1226
	DD	imagerel $unwind$dfp_number_to_fix64
$pdata$dfp_shift_coeff DD imagerel dfp_shift_coeff
	DD	imagerel dfp_shift_coeff+500
	DD	imagerel $unwind$dfp_shift_coeff
$pdata$dfp_test_data_class DD imagerel dfp_test_data_class
	DD	imagerel dfp_test_data_class+304
	DD	imagerel $unwind$dfp_test_data_class
$pdata$dfp_test_data_group DD imagerel dfp_test_data_group
	DD	imagerel dfp_test_data_group+324
	DD	imagerel $unwind$dfp_test_data_group
$pdata$dfp_number_from_fix32 DD imagerel dfp_number_from_fix32
	DD	imagerel dfp_number_from_fix32+293
	DD	imagerel $unwind$dfp_number_from_fix32
$pdata$dfp_number_from_u32 DD imagerel dfp_number_from_u32
	DD	imagerel dfp_number_from_u32+193
	DD	imagerel $unwind$dfp_number_from_u32
$pdata$dfp_number_from_u64 DD imagerel dfp_number_from_u64
	DD	imagerel dfp_number_from_u64+202
	DD	imagerel $unwind$dfp_number_from_u64
$pdata$dfp_number_to_fix32 DD imagerel dfp_number_to_fix32
	DD	imagerel dfp_number_to_fix32+1183
	DD	imagerel $unwind$dfp_number_to_fix32
$pdata$dfp_number_to_u32 DD imagerel dfp_number_to_u32
	DD	imagerel dfp_number_to_u32+845
	DD	imagerel $unwind$dfp_number_to_u32
$pdata$dfp_number_to_u64 DD imagerel dfp_number_to_u64
	DD	imagerel dfp_number_to_u64+871
	DD	imagerel $unwind$dfp_number_to_u64
$pdata$s370_dfp_rounding_mode DD imagerel s370_dfp_rounding_mode
	DD	imagerel s370_dfp_rounding_mode+252
	DD	imagerel $unwind$s370_dfp_rounding_mode
$pdata$s370_dfp_reg_to_decimal32 DD imagerel s370_dfp_reg_to_decimal32
	DD	imagerel s370_dfp_reg_to_decimal32+65
	DD	imagerel $unwind$s370_dfp_reg_to_decimal32
$pdata$s370_dfp_reg_from_decimal32 DD imagerel s370_dfp_reg_from_decimal32
	DD	imagerel s370_dfp_reg_from_decimal32+65
	DD	imagerel $unwind$s370_dfp_reg_from_decimal32
$pdata$s370_dfp_reg_to_decimal64 DD imagerel s370_dfp_reg_to_decimal64
	DD	imagerel s370_dfp_reg_to_decimal64+92
	DD	imagerel $unwind$s370_dfp_reg_to_decimal64
$pdata$s370_dfp_reg_from_decimal64 DD imagerel s370_dfp_reg_from_decimal64
	DD	imagerel s370_dfp_reg_from_decimal64+92
	DD	imagerel $unwind$s370_dfp_reg_from_decimal64
$pdata$s370_dfp_reg_to_decimal128 DD imagerel s370_dfp_reg_to_decimal128
	DD	imagerel s370_dfp_reg_to_decimal128+155
	DD	imagerel $unwind$s370_dfp_reg_to_decimal128
$pdata$s370_dfp_reg_from_decimal128 DD imagerel s370_dfp_reg_from_decimal128
	DD	imagerel s370_dfp_reg_from_decimal128+155
	DD	imagerel $unwind$s370_dfp_reg_from_decimal128
$pdata$s370_dfp_status_check DD imagerel s370_dfp_status_check
	DD	imagerel s370_dfp_status_check+746
	DD	imagerel $unwind$s370_dfp_status_check
$pdata$z900_convert_fix32_to_dfp_ext_reg DD imagerel $LN15
	DD	imagerel $LN15+649
	DD	imagerel $unwind$z900_convert_fix32_to_dfp_ext_reg
$pdata$z900_convert_fix32_to_dfp_long_reg DD imagerel $LN14
	DD	imagerel $LN14+633
	DD	imagerel $unwind$z900_convert_fix32_to_dfp_long_reg
$pdata$z900_convert_u32_to_dfp_ext_reg DD imagerel $LN15
	DD	imagerel $LN15+649
	DD	imagerel $unwind$z900_convert_u32_to_dfp_ext_reg
$pdata$z900_convert_u32_to_dfp_long_reg DD imagerel $LN14
	DD	imagerel $LN14+633
	DD	imagerel $unwind$z900_convert_u32_to_dfp_long_reg
$pdata$z900_convert_u64_to_dfp_ext_reg DD imagerel $LN15
	DD	imagerel $LN15+652
	DD	imagerel $unwind$z900_convert_u64_to_dfp_ext_reg
$pdata$z900_convert_u64_to_dfp_long_reg DD imagerel $LN14
	DD	imagerel $LN14+636
	DD	imagerel $unwind$z900_convert_u64_to_dfp_long_reg
$pdata$z900_convert_dfp_ext_to_fix32_reg DD imagerel $LN22
	DD	imagerel $LN22+852
	DD	imagerel $unwind$z900_convert_dfp_ext_to_fix32_reg
$pdata$z900_convert_dfp_long_to_fix32_reg DD imagerel $LN21
	DD	imagerel $LN21+808
	DD	imagerel $unwind$z900_convert_dfp_long_to_fix32_reg
$pdata$z900_convert_dfp_ext_to_u32_reg DD imagerel $LN22
	DD	imagerel $LN22+852
	DD	imagerel $unwind$z900_convert_dfp_ext_to_u32_reg
$pdata$z900_convert_dfp_long_to_u32_reg DD imagerel $LN21
	DD	imagerel $LN21+808
	DD	imagerel $unwind$z900_convert_dfp_long_to_u32_reg
$pdata$z900_convert_dfp_ext_to_u64_reg DD imagerel $LN22
	DD	imagerel $LN22+855
	DD	imagerel $unwind$z900_convert_dfp_ext_to_u64_reg
$pdata$z900_convert_dfp_long_to_u64_reg DD imagerel $LN21
	DD	imagerel $LN21+820
	DD	imagerel $unwind$z900_convert_dfp_long_to_u64_reg
$pdata$z900_set_dfp_rounding_mode DD imagerel $LN14
	DD	imagerel $LN14+457
	DD	imagerel $unwind$z900_set_dfp_rounding_mode
$pdata$z900_load_fpr_from_gr_long_reg DD imagerel $LN14
	DD	imagerel $LN14+413
	DD	imagerel $unwind$z900_load_fpr_from_gr_long_reg
$pdata$z900_load_gr_from_fpr_long_reg DD imagerel $LN14
	DD	imagerel $LN14+412
	DD	imagerel $unwind$z900_load_gr_from_fpr_long_reg
$pdata$z900_copy_sign_fpr_long_reg DD imagerel $LN18
	DD	imagerel $LN18+704
	DD	imagerel $unwind$z900_copy_sign_fpr_long_reg
$pdata$z900_load_complement_fpr_long_reg DD imagerel $LN15
	DD	imagerel $LN15+440
	DD	imagerel $unwind$z900_load_complement_fpr_long_reg
$pdata$z900_load_negative_fpr_long_reg DD imagerel $LN15
	DD	imagerel $LN15+440
	DD	imagerel $unwind$z900_load_negative_fpr_long_reg
$pdata$z900_load_positive_fpr_long_reg DD imagerel $LN15
	DD	imagerel $LN15+440
	DD	imagerel $unwind$z900_load_positive_fpr_long_reg
$pdata$z900_load_fpc_and_signal DD imagerel $LN17
	DD	imagerel $LN17+608
	DD	imagerel $unwind$z900_load_fpc_and_signal
$pdata$z900_set_fpc_and_signal DD imagerel $LN16
	DD	imagerel $LN16+519
	DD	imagerel $unwind$z900_set_fpc_and_signal
$pdata$z900_add_dfp_ext_reg DD imagerel $LN23
	DD	imagerel $LN23+942
	DD	imagerel $unwind$z900_add_dfp_ext_reg
$pdata$z900_add_dfp_long_reg DD imagerel $LN21
	DD	imagerel $LN21+879
	DD	imagerel $unwind$z900_add_dfp_long_reg
$pdata$z900_compare_dfp_ext_reg DD imagerel $LN23
	DD	imagerel $LN23+847
	DD	imagerel $unwind$z900_compare_dfp_ext_reg
$pdata$z900_compare_dfp_long_reg DD imagerel $LN21
	DD	imagerel $LN21+789
	DD	imagerel $unwind$z900_compare_dfp_long_reg
$pdata$z900_compare_and_signal_dfp_ext_reg DD imagerel $LN24
	DD	imagerel $LN24+875
	DD	imagerel $unwind$z900_compare_and_signal_dfp_ext_reg
$pdata$z900_compare_and_signal_dfp_long_reg DD imagerel $LN22
	DD	imagerel $LN22+820
	DD	imagerel $unwind$z900_compare_and_signal_dfp_long_reg
$pdata$z900_compare_exponent_dfp_ext_reg DD imagerel $LN16
	DD	imagerel $LN16+629
	DD	imagerel $unwind$z900_compare_exponent_dfp_ext_reg
$pdata$z900_compare_exponent_dfp_long_reg DD imagerel $LN14
	DD	imagerel $LN14+580
	DD	imagerel $unwind$z900_compare_exponent_dfp_long_reg
$pdata$z900_convert_fix64_to_dfp_ext_reg DD imagerel $LN15
	DD	imagerel $LN15+623
	DD	imagerel $unwind$z900_convert_fix64_to_dfp_ext_reg
$pdata$z900_convert_fix64_to_dfp_long_reg DD imagerel $LN15
	DD	imagerel $LN15+653
	DD	imagerel $unwind$z900_convert_fix64_to_dfp_long_reg
$pdata$z900_convert_sbcd128_to_dfp_ext_reg DD imagerel $LN17
	DD	imagerel $LN17+767
	DD	imagerel $unwind$z900_convert_sbcd128_to_dfp_ext_reg
$pdata$z900_convert_sbcd64_to_dfp_long_reg DD imagerel $LN15
	DD	imagerel $LN15+646
	DD	imagerel $unwind$z900_convert_sbcd64_to_dfp_long_reg
$pdata$z900_convert_ubcd128_to_dfp_ext_reg DD imagerel $LN22
	DD	imagerel $LN22+923
	DD	imagerel $unwind$z900_convert_ubcd128_to_dfp_ext_reg
$pdata$z900_convert_ubcd64_to_dfp_long_reg DD imagerel $LN20
	DD	imagerel $LN20+802
	DD	imagerel $unwind$z900_convert_ubcd64_to_dfp_long_reg
$pdata$z900_convert_dfp_ext_to_fix64_reg DD imagerel $LN22
	DD	imagerel $LN22+841
	DD	imagerel $unwind$z900_convert_dfp_ext_to_fix64_reg
$pdata$z900_convert_dfp_long_to_fix64_reg DD imagerel $LN21
	DD	imagerel $LN21+797
	DD	imagerel $unwind$z900_convert_dfp_long_to_fix64_reg
$pdata$z900_convert_dfp_ext_to_sbcd128_reg DD imagerel $LN19
	DD	imagerel $LN19+835
	DD	imagerel $unwind$z900_convert_dfp_ext_to_sbcd128_reg
$pdata$z900_convert_dfp_long_to_sbcd64_reg DD imagerel $LN17
	DD	imagerel $LN17+710
	DD	imagerel $unwind$z900_convert_dfp_long_to_sbcd64_reg
$pdata$z900_convert_dfp_ext_to_ubcd128_reg DD imagerel $LN21
	DD	imagerel $LN21+843
	DD	imagerel $unwind$z900_convert_dfp_ext_to_ubcd128_reg
$pdata$z900_convert_dfp_long_to_ubcd64_reg DD imagerel $LN19
	DD	imagerel $LN19+718
	DD	imagerel $unwind$z900_convert_dfp_long_to_ubcd64_reg
$pdata$z900_divide_dfp_ext_reg DD imagerel $LN17
	DD	imagerel $LN17+797
	DD	imagerel $unwind$z900_divide_dfp_ext_reg
$pdata$z900_divide_dfp_long_reg DD imagerel $LN15
	DD	imagerel $LN15+731
	DD	imagerel $unwind$z900_divide_dfp_long_reg
$pdata$z900_extract_biased_exponent_dfp_ext_to_fix64_reg DD imagerel $LN21
	DD	imagerel $LN21+663
	DD	imagerel $unwind$z900_extract_biased_exponent_dfp_ext_to_fix64_reg
$pdata$z900_extract_biased_exponent_dfp_long_to_fix64_reg DD imagerel $LN20
	DD	imagerel $LN20+625
	DD	imagerel $unwind$z900_extract_biased_exponent_dfp_long_to_fix64_reg
$pdata$z900_extract_significance_dfp_ext_reg DD imagerel $LN23
	DD	imagerel $LN23+705
	DD	imagerel $unwind$z900_extract_significance_dfp_ext_reg
$pdata$z900_extract_significance_dfp_long_reg DD imagerel $LN22
	DD	imagerel $LN22+667
	DD	imagerel $unwind$z900_extract_significance_dfp_long_reg
$pdata$z900_insert_biased_exponent_fix64_to_dfp_ext_reg DD imagerel $LN25
	DD	imagerel $LN25+958
	DD	imagerel $unwind$z900_insert_biased_exponent_fix64_to_dfp_ext_reg
$pdata$z900_insert_biased_exponent_fix64_to_dfp_long_reg DD imagerel $LN23
	DD	imagerel $LN23+894
	DD	imagerel $unwind$z900_insert_biased_exponent_fix64_to_dfp_long_reg
$pdata$z900_load_and_test_dfp_ext_reg DD imagerel $LN24
	DD	imagerel $LN24+867
	DD	imagerel $unwind$z900_load_and_test_dfp_ext_reg
$pdata$z900_load_and_test_dfp_long_reg DD imagerel $LN22
	DD	imagerel $LN22+812
	DD	imagerel $unwind$z900_load_and_test_dfp_long_reg
$pdata$z900_load_fp_int_dfp_ext_reg DD imagerel $LN33
	DD	imagerel $LN33+1140
	DD	imagerel $unwind$z900_load_fp_int_dfp_ext_reg
$pdata$z900_load_fp_int_dfp_long_reg DD imagerel $LN31
	DD	imagerel $LN31+1103
	DD	imagerel $unwind$z900_load_fp_int_dfp_long_reg
$pdata$z900_load_lengthened_dfp_long_to_ext_reg DD imagerel $LN21
	DD	imagerel $LN21+908
	DD	imagerel $unwind$z900_load_lengthened_dfp_long_to_ext_reg
$pdata$z900_load_lengthened_dfp_short_to_long_reg DD imagerel $LN20
	DD	imagerel $LN20+864
	DD	imagerel $unwind$z900_load_lengthened_dfp_short_to_long_reg
$pdata$z900_load_rounded_dfp_ext_to_long_reg DD imagerel $LN26
	DD	imagerel $LN26+1038
	DD	imagerel $unwind$z900_load_rounded_dfp_ext_to_long_reg
$pdata$z900_load_rounded_dfp_long_to_short_reg DD imagerel $LN25
	DD	imagerel $LN25+985
	DD	imagerel $unwind$z900_load_rounded_dfp_long_to_short_reg
$pdata$z900_multiply_dfp_ext_reg DD imagerel $LN17
	DD	imagerel $LN17+797
	DD	imagerel $unwind$z900_multiply_dfp_ext_reg
$pdata$z900_multiply_dfp_long_reg DD imagerel $LN15
	DD	imagerel $LN15+731
	DD	imagerel $unwind$z900_multiply_dfp_long_reg
$pdata$z900_quantize_dfp_ext_reg DD imagerel $LN17
	DD	imagerel $LN17+813
	DD	imagerel $unwind$z900_quantize_dfp_ext_reg
$pdata$z900_quantize_dfp_long_reg DD imagerel $LN15
	DD	imagerel $LN15+747
	DD	imagerel $unwind$z900_quantize_dfp_long_reg
$pdata$z900_reround_dfp_ext_reg DD imagerel $LN21
	DD	imagerel $LN21+893
	DD	imagerel $unwind$z900_reround_dfp_ext_reg
$pdata$z900_reround_dfp_long_reg DD imagerel $LN19
	DD	imagerel $LN19+832
	DD	imagerel $unwind$z900_reround_dfp_long_reg
$pdata$z900_shift_coefficient_left_dfp_ext DD imagerel $LN26
	DD	imagerel $LN26+989
	DD	imagerel $unwind$z900_shift_coefficient_left_dfp_ext
$pdata$z900_shift_coefficient_left_dfp_long DD imagerel $LN24
	DD	imagerel $LN24+940
	DD	imagerel $unwind$z900_shift_coefficient_left_dfp_long
$pdata$z900_shift_coefficient_right_dfp_ext DD imagerel $LN26
	DD	imagerel $LN26+993
	DD	imagerel $unwind$z900_shift_coefficient_right_dfp_ext
$pdata$z900_shift_coefficient_right_dfp_long DD imagerel $LN24
	DD	imagerel $LN24+944
	DD	imagerel $unwind$z900_shift_coefficient_right_dfp_long
$pdata$z900_subtract_dfp_ext_reg DD imagerel $LN23
	DD	imagerel $LN23+942
	DD	imagerel $unwind$z900_subtract_dfp_ext_reg
$pdata$z900_subtract_dfp_long_reg DD imagerel $LN21
	DD	imagerel $LN21+879
	DD	imagerel $unwind$z900_subtract_dfp_long_reg
$pdata$z900_test_data_class_dfp_ext DD imagerel $LN17
	DD	imagerel $LN17+749
	DD	imagerel $unwind$z900_test_data_class_dfp_ext
$pdata$z900_test_data_class_dfp_long DD imagerel $LN16
	DD	imagerel $LN16+711
	DD	imagerel $unwind$z900_test_data_class_dfp_long
$pdata$z900_test_data_class_dfp_short DD imagerel $LN16
	DD	imagerel $LN16+711
	DD	imagerel $unwind$z900_test_data_class_dfp_short
$pdata$z900_test_data_group_dfp_ext DD imagerel $LN17
	DD	imagerel $LN17+768
	DD	imagerel $unwind$z900_test_data_group_dfp_ext
$pdata$z900_test_data_group_dfp_long DD imagerel $LN16
	DD	imagerel $LN16+730
	DD	imagerel $unwind$z900_test_data_group_dfp_long
$pdata$z900_test_data_group_dfp_short DD imagerel $LN16
	DD	imagerel $LN16+730
	DD	imagerel $unwind$z900_test_data_group_dfp_short
$pdata$z900_convert_zoned_to_dfp_ext DD imagerel $LN18
	DD	imagerel $LN18+872
	DD	imagerel $unwind$z900_convert_zoned_to_dfp_ext
$pdata$z900_convert_zoned_to_dfp_long DD imagerel $LN17
	DD	imagerel $LN17+834
	DD	imagerel $unwind$z900_convert_zoned_to_dfp_long
$pdata$z900_convert_dfp_ext_to_zoned DD imagerel $LN19
	DD	imagerel $LN19+903
	DD	imagerel $unwind$z900_convert_dfp_ext_to_zoned
$pdata$z900_convert_dfp_long_to_zoned DD imagerel $LN18
	DD	imagerel $LN18+865
	DD	imagerel $unwind$z900_convert_dfp_long_to_zoned
$pdata$z900_convert_packed_to_dfp_ext DD imagerel $LN24
	DD	imagerel $LN24+970
	DD	imagerel $unwind$z900_convert_packed_to_dfp_ext
$pdata$z900_convert_packed_to_dfp_long DD imagerel $LN23
	DD	imagerel $LN23+932
	DD	imagerel $unwind$z900_convert_packed_to_dfp_long
$pdata$z900_convert_dfp_ext_to_packed DD imagerel $LN19
	DD	imagerel $LN19+903
	DD	imagerel $unwind$z900_convert_dfp_ext_to_packed
$pdata$z900_convert_dfp_long_to_packed DD imagerel $LN18
	DD	imagerel $LN18+865
	DD	imagerel $unwind$z900_convert_dfp_long_to_packed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck DD imagerel $LN6
	DD	imagerel $LN6+108
	DD	imagerel $unwind$z900_per3_zero_xcheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_FPC_check DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900_FPC_check
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+445
	DD	imagerel $unwind$z900_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+195
	DD	imagerel $unwind$z900_vfetch4
pdata	ENDS
pdata	SEGMENT
$pdata$dfp_number_from_zoned DD imagerel dfp_number_from_zoned
	DD	imagerel dfp_number_from_zoned+388
	DD	imagerel $unwind$dfp_number_from_zoned
$pdata$dfp_number_to_zoned DD imagerel dfp_number_to_zoned
	DD	imagerel dfp_number_to_zoned+948
	DD	imagerel $unwind$dfp_number_to_zoned
$pdata$dfp_number_from_packed DD imagerel dfp_number_from_packed
	DD	imagerel dfp_number_from_packed+544
	DD	imagerel $unwind$dfp_number_from_packed
$pdata$dfp_number_to_packed DD imagerel dfp_number_to_packed
	DD	imagerel dfp_number_to_packed+1043
	DD	imagerel $unwind$dfp_number_to_packed
$pdata$z900_dfp_rounding_mode DD imagerel z900_dfp_rounding_mode
	DD	imagerel z900_dfp_rounding_mode+252
	DD	imagerel $unwind$z900_dfp_rounding_mode
$pdata$z900_dfp_reg_to_decimal32 DD imagerel z900_dfp_reg_to_decimal32
	DD	imagerel z900_dfp_reg_to_decimal32+65
	DD	imagerel $unwind$z900_dfp_reg_to_decimal32
$pdata$z900_dfp_reg_from_decimal32 DD imagerel z900_dfp_reg_from_decimal32
	DD	imagerel z900_dfp_reg_from_decimal32+65
	DD	imagerel $unwind$z900_dfp_reg_from_decimal32
$pdata$z900_dfp_reg_to_decimal64 DD imagerel z900_dfp_reg_to_decimal64
	DD	imagerel z900_dfp_reg_to_decimal64+92
	DD	imagerel $unwind$z900_dfp_reg_to_decimal64
$pdata$z900_dfp_reg_from_decimal64 DD imagerel z900_dfp_reg_from_decimal64
	DD	imagerel z900_dfp_reg_from_decimal64+92
	DD	imagerel $unwind$z900_dfp_reg_from_decimal64
$pdata$z900_dfp_reg_to_decimal128 DD imagerel z900_dfp_reg_to_decimal128
	DD	imagerel z900_dfp_reg_to_decimal128+155
	DD	imagerel $unwind$z900_dfp_reg_to_decimal128
$pdata$z900_dfp_reg_from_decimal128 DD imagerel z900_dfp_reg_from_decimal128
	DD	imagerel z900_dfp_reg_from_decimal128+155
	DD	imagerel $unwind$z900_dfp_reg_from_decimal128
$pdata$z900_dfp_status_check DD imagerel z900_dfp_status_check
	DD	imagerel z900_dfp_status_check+746
	DD	imagerel $unwind$z900_dfp_status_check
pdata	ENDS
_DATA	SEGMENT
?maxnegzd@?1??dfp_number_from_fix64@@9@9 DB '-9223372036854775808', 00H ; `dfp_number_from_fix64'::`2'::maxnegzd
	ORG $+3
?maxneg64@?1??dfp_number_from_fix64@@9@9 DQ 8000000000000000H ; `dfp_number_from_fix64'::`2'::maxneg64
?mp64@?1??dfp_number_to_fix64@@9@9 DQ 7fffffffffffffffH	; `dfp_number_to_fix64'::`2'::mp64
?mn64@?1??dfp_number_to_fix64@@9@9 DQ 8000000000000000H	; `dfp_number_to_fix64'::`2'::mn64
?mpzd@?1??dfp_number_to_fix64@@9@9 DB '9223372036854775807', 00H ; `dfp_number_to_fix64'::`2'::mpzd
?maxneg32@?1??dfp_number_from_fix32@@9@9 DD 080000000H	; `dfp_number_from_fix32'::`2'::maxneg32
?mnzd@?1??dfp_number_to_fix64@@9@9 DB '-9223372036854775808', 00H ; `dfp_number_to_fix64'::`2'::mnzd
	ORG $+3
?maxnegzd@?1??dfp_number_from_fix32@@9@9 DB '-2147483648', 00H ; `dfp_number_from_fix32'::`2'::maxnegzd
?mp32@?1??dfp_number_to_fix32@@9@9 DD 07fffffffH	; `dfp_number_to_fix32'::`2'::mp32
?mn32@?1??dfp_number_to_fix32@@9@9 DD 080000000H	; `dfp_number_to_fix32'::`2'::mn32
?mu32@?1??dfp_number_to_u32@@9@9 DD 0ffffffffH		; `dfp_number_to_u32'::`2'::mu32
?mp32zd@?1??dfp_number_to_fix32@@9@9 DB '2147483647', 00H ; `dfp_number_to_fix32'::`2'::mp32zd
	ORG $+5
?mn32zd@?1??dfp_number_to_fix32@@9@9 DB '-2147483648', 00H ; `dfp_number_to_fix32'::`2'::mn32zd
	ORG $+4
?mu32zd@?1??dfp_number_to_u32@@9@9 DB '4294967295', 00H	; `dfp_number_to_u32'::`2'::mu32zd
	ORG $+5
?mu64@?1??dfp_number_to_u64@@9@9 DQ ffffffffffffffffH	; `dfp_number_to_u64'::`2'::mu64
?mu64zd@?1??dfp_number_to_u64@@9@9 DB '18446744073709551615', 00H ; `dfp_number_to_u64'::`2'::mu64zd
	ORG $+3
$SG195237 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:52', 00H
$SG195260 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:75', 00H
$SG195286 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:99', 00H
$SG195312 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:131', 00H
	ORG $+7
$SG195334 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:156', 00H
	ORG $+7
$SG195355 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:178', 00H
	ORG $+7
$SG195376 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:202', 00H
	ORG $+7
$SG195399 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:295', 00H
	ORG $+7
$SG195424 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:339', 00H
	ORG $+7
$SG195720 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:1991', 00H
	ORG $+6
$SG195752 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2041', 00H
	ORG $+6
$SG195780 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2090', 00H
	ORG $+6
$SG195810 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2135', 00H
	ORG $+6
$SG195838 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2179', 00H
	ORG $+6
$SG195869 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2228', 00H
	ORG $+6
$SG195896 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2275', 00H
	ORG $+6
$SG195923 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2306', 00H
	ORG $+6
$SG195950 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2339', 00H
	ORG $+6
$SG195979 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2375', 00H
	ORG $+6
$SG196005 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2412', 00H
	ORG $+6
$SG196033 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2448', 00H
	ORG $+6
$SG196058 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2485', 00H
	ORG $+6
$SG196085 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2520', 00H
	ORG $+6
$SG196112 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2565', 00H
	ORG $+6
$SG196140 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2601', 00H
	ORG $+6
$SG196167 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2639', 00H
	ORG $+6
$SG196197 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2684', 00H
	ORG $+6
$SG196230 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2727', 00H
	ORG $+6
$SG196265 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2779', 00H
	ORG $+6
$SG196295 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2832', 00H
	ORG $+6
$SG196327 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2885', 00H
	ORG $+6
$SG196358 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:2939', 00H
	ORG $+6
$SG196396 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3005', 00H
	ORG $+6
$SG196431 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3069', 00H
	ORG $+6
$SG196460 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3120', 00H
	ORG $+6
$SG196488 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3170', 00H
	ORG $+6
$SG196517 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3221', 00H
	ORG $+6
$SG196544 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3272', 00H
	ORG $+6
$SG196572 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3323', 00H
	ORG $+6
$SG196600 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3374', 00H
	ORG $+6
$SG196629 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3425', 00H
	ORG $+6
$SG196656 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3476', 00H
	ORG $+6
$SG196687 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3525', 00H
	ORG $+6
$SG196719 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3571', 00H
	ORG $+6
$SG196752 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3620', 00H
	ORG $+6
$SG196784 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3670', 00H
	ORG $+6
$SG196818 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3724', 00H
	ORG $+6
$SG196851 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3779', 00H
	ORG $+6
$SG196885 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3833', 00H
	ORG $+6
$SG196917 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3882', 00H
	ORG $+6
$SG196949 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3927', 00H
	ORG $+6
$SG196974 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:3971', 00H
	ORG $+6
$SG197005 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4013', 00H
	ORG $+6
$SG197035 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4054', 00H
	ORG $+6
$SG197068 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4098', 00H
	ORG $+6
$SG197103 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4141', 00H
	ORG $+6
$SG197141 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4212', 00H
	ORG $+6
$SG197175 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4282', 00H
	ORG $+6
$SG197204 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4336', 00H
	ORG $+6
$SG197235 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4389', 00H
	ORG $+6
$SG197273 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4465', 00H
	ORG $+6
$SG197307 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4541', 00H
	ORG $+6
$SG197341 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4610', 00H
	ORG $+6
$SG197377 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4680', 00H
	ORG $+6
$SG197419 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4767', 00H
	ORG $+6
$SG197459 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4850', 00H
	ORG $+6
$SG197491 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4895', 00H
	ORG $+6
$SG197522 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4939', 00H
	ORG $+6
$SG197555 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:4984', 00H
	ORG $+6
$SG197585 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5029', 00H
	ORG $+6
$SG197621 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5086', 00H
	ORG $+6
$SG197657 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5144', 00H
	ORG $+6
$SG197698 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5207', 00H
	ORG $+6
$SG197737 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5269', 00H
	ORG $+6
$SG197778 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5332', 00H
	ORG $+6
$SG197815 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5391', 00H
	ORG $+6
$SG197847 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5441', 00H
	ORG $+6
$SG197876 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5493', 00H
	ORG $+6
$SG197905 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5529', 00H
	ORG $+6
$SG197933 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5564', 00H
	ORG $+6
$SG197962 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5600', 00H
	ORG $+6
$SG197992 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5642', 00H
	ORG $+6
$SG198021 DB	'C:\papa\MyGit\hyperion-zvector\dfp.c:5683', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4_full DD 032319H
	DD	07010a214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_FPC_check DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	010cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_FPC_check DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_number_to_packed
	DD	025H
	DD	03fbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_number_from_packed
	DD	025H
	DD	01f0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_number_to_zoned
	DD	025H
	DD	039cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_number_from_zoned
	DD	022H
	DD	0159H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_long_to_packed
	DD	01bH
	DD	0349H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_ext_to_packed
	DD	01bH
	DD	036fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_packed_to_dfp_long
	DD	01bH
	DD	038cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_packed_to_dfp_ext
	DD	01bH
	DD	03b2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_long_to_zoned
	DD	01bH
	DD	0349H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_ext_to_zoned
	DD	01bH
	DD	036fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_zoned_to_dfp_long
	DD	01bH
	DD	032aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_zoned_to_dfp_ext
	DD	01bH
	DD	0350H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_test_data_group_dfp_short
	DD	01bH
	DD	02c2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_test_data_group_dfp_long
	DD	01bH
	DD	02c2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_test_data_group_dfp_ext
	DD	01bH
	DD	02e8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_test_data_class_dfp_short
	DD	01bH
	DD	02afH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_test_data_class_dfp_long
	DD	01bH
	DD	02afH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_test_data_class_dfp_ext
	DD	01bH
	DD	02d5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_subtract_dfp_long_reg
	DD	01bH
	DD	0357H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_subtract_dfp_ext_reg
	DD	01bH
	DD	0396H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_shift_coefficient_right_dfp_long
	DD	01bH
	DD	0398H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_shift_coefficient_right_dfp_ext
	DD	01bH
	DD	03c9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_shift_coefficient_left_dfp_long
	DD	01bH
	DD	0394H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_shift_coefficient_left_dfp_ext
	DD	01bH
	DD	03c5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_reround_dfp_long_reg
	DD	01bH
	DD	0328H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_reround_dfp_ext_reg
	DD	01bH
	DD	0365H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_quantize_dfp_long_reg
	DD	01bH
	DD	02d3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_quantize_dfp_ext_reg
	DD	01bH
	DD	0315H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_multiply_dfp_long_reg
	DD	01bH
	DD	02c3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_multiply_dfp_ext_reg
	DD	01bH
	DD	0305H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_rounded_dfp_long_to_short_reg
	DD	01bH
	DD	03c1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_rounded_dfp_ext_to_long_reg
	DD	01bH
	DD	03f6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_lengthened_dfp_short_to_long_reg
	DD	01bH
	DD	0348H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_lengthened_dfp_long_to_ext_reg
	DD	01bH
	DD	0374H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_fp_int_dfp_long_reg
	DD	01bH
	DD	0437H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_fp_int_dfp_ext_reg
	DD	01bH
	DD	045cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_and_test_dfp_long_reg
	DD	01bH
	DD	0314H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_and_test_dfp_ext_reg
	DD	01bH
	DD	034bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_insert_biased_exponent_fix64_to_dfp_long_reg
	DD	01bH
	DD	0366H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_insert_biased_exponent_fix64_to_dfp_ext_reg
	DD	01bH
	DD	03a6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_extract_significance_dfp_long_reg
	DD	01bH
	DD	0283H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_extract_significance_dfp_ext_reg
	DD	01bH
	DD	02a9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_extract_biased_exponent_dfp_long_to_fix64_reg
	DD	01bH
	DD	0259H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_extract_biased_exponent_dfp_ext_to_fix64_reg
	DD	01bH
	DD	027fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_divide_dfp_long_reg
	DD	01bH
	DD	02c3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_divide_dfp_ext_reg
	DD	01bH
	DD	0305H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_long_to_ubcd64_reg
	DD	01bH
	DD	02b6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_ext_to_ubcd128_reg
	DD	01bH
	DD	0333H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_long_to_sbcd64_reg
	DD	01bH
	DD	02aeH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_ext_to_sbcd128_reg
	DD	01bH
	DD	032bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_long_to_fix64_reg
	DD	01bH
	DD	0305H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_ext_to_fix64_reg
	DD	01bH
	DD	0331H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_ubcd64_to_dfp_long_reg
	DD	01bH
	DD	030aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_ubcd128_to_dfp_ext_reg
	DD	01bH
	DD	0383H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_sbcd64_to_dfp_long_reg
	DD	01bH
	DD	026eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_sbcd128_to_dfp_ext_reg
	DD	01bH
	DD	02e7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_fix64_to_dfp_long_reg
	DD	01bH
	DD	0275H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_fix64_to_dfp_ext_reg
	DD	01bH
	DD	0257H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_compare_exponent_dfp_long_reg
	DD	01bH
	DD	022cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_compare_exponent_dfp_ext_reg
	DD	01bH
	DD	025dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_compare_and_signal_dfp_long_reg
	DD	01bH
	DD	031cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_compare_and_signal_dfp_ext_reg
	DD	01bH
	DD	0353H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_compare_dfp_long_reg
	DD	01bH
	DD	02fdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_compare_dfp_ext_reg
	DD	01bH
	DD	0337H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_add_dfp_long_reg
	DD	01bH
	DD	0357H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_add_dfp_ext_reg
	DD	01bH
	DD	0396H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_long_to_u64_reg
	DD	01bH
	DD	031cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_ext_to_u64_reg
	DD	01bH
	DD	033fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_long_to_u32_reg
	DD	01bH
	DD	0310H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_ext_to_u32_reg
	DD	01bH
	DD	033cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_long_to_fix32_reg
	DD	01bH
	DD	0310H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_dfp_ext_to_fix32_reg
	DD	01bH
	DD	033cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_u64_to_dfp_long_reg
	DD	01bH
	DD	0264H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_u64_to_dfp_ext_reg
	DD	01bH
	DD	0274H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_u32_to_dfp_long_reg
	DD	01bH
	DD	0261H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_u32_to_dfp_ext_reg
	DD	01bH
	DD	0271H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_fix32_to_dfp_long_reg
	DD	01bH
	DD	0261H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_convert_fix32_to_dfp_ext_reg
	DD	01bH
	DD	0271H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_number_to_u64
	DD	01bH
	DD	034fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_number_to_u32
	DD	01bH
	DD	0335H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_number_to_fix32
	DD	01bH
	DD	0487H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_number_from_u64
	DD	01dH
	DD	0b8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_number_from_u32
	DD	01cH
	DD	0afH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_number_from_fix32
	DD	01cH
	DD	0113H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_test_data_class
	DD	01dH
	DD	011eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_shift_coeff
	DD	021H
	DD	01dbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_number_to_fix64
	DD	01bH
	DD	04b2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dfp_number_from_fix64
	DD	01dH
	DD	0124H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_test_data_group_dfp_short
	DD	01bH
	DD	0205H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_test_data_group_dfp_long
	DD	01bH
	DD	0205H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_test_data_group_dfp_ext
	DD	01bH
	DD	022bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_test_data_class_dfp_short
	DD	01bH
	DD	01f2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_test_data_class_dfp_long
	DD	01bH
	DD	01f2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_test_data_class_dfp_ext
	DD	01bH
	DD	0218H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_subtract_dfp_long_reg
	DD	01bH
	DD	02bbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_subtract_dfp_ext_reg
	DD	01bH
	DD	02faH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_shift_coefficient_right_dfp_long
	DD	01bH
	DD	02cfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_shift_coefficient_right_dfp_ext
	DD	01bH
	DD	030cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_shift_coefficient_left_dfp_long
	DD	01bH
	DD	02cbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_shift_coefficient_left_dfp_ext
	DD	01bH
	DD	0308H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_reround_dfp_long_reg
	DD	01bH
	DD	028cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_reround_dfp_ext_reg
	DD	01bH
	DD	02c9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_quantize_dfp_long_reg
	DD	01bH
	DD	0237H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_quantize_dfp_ext_reg
	DD	01bH
	DD	0279H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_multiply_dfp_long_reg
	DD	01bH
	DD	0227H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_multiply_dfp_ext_reg
	DD	01bH
	DD	0269H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_rounded_dfp_long_to_short_reg
	DD	01bH
	DD	0325H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_rounded_dfp_ext_to_long_reg
	DD	01bH
	DD	035aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_lengthened_dfp_short_to_long_reg
	DD	01bH
	DD	02acH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_lengthened_dfp_long_to_ext_reg
	DD	01bH
	DD	02d8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_fp_int_dfp_long_reg
	DD	01bH
	DD	039bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_fp_int_dfp_ext_reg
	DD	01bH
	DD	03c0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_and_test_dfp_long_reg
	DD	01bH
	DD	0278H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_and_test_dfp_ext_reg
	DD	01bH
	DD	02afH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_insert_biased_exponent_fix64_to_dfp_long_reg
	DD	01bH
	DD	02c9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_insert_biased_exponent_fix64_to_dfp_ext_reg
	DD	01bH
	DD	0309H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_extract_significance_dfp_long_reg
	DD	01bH
	DD	01e5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_extract_significance_dfp_ext_reg
	DD	01bH
	DD	020bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_extract_biased_exponent_dfp_long_to_fix64_reg
	DD	01bH
	DD	01bbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_extract_biased_exponent_dfp_ext_to_fix64_reg
	DD	01bH
	DD	01e1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_divide_dfp_long_reg
	DD	01bH
	DD	0227H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_divide_dfp_ext_reg
	DD	01bH
	DD	0269H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_dfp_long_to_ubcd64_reg
	DD	01bH
	DD	021aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_dfp_ext_to_ubcd128_reg
	DD	01bH
	DD	0297H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_dfp_long_to_sbcd64_reg
	DD	01bH
	DD	0212H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_dfp_ext_to_sbcd128_reg
	DD	01bH
	DD	028fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_dfp_long_to_fix64_reg
	DD	01bH
	DD	0269H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_dfp_ext_to_fix64_reg
	DD	01bH
	DD	0295H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_ubcd64_to_dfp_long_reg
	DD	01bH
	DD	026eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_ubcd128_to_dfp_ext_reg
	DD	01bH
	DD	02e7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_sbcd64_to_dfp_long_reg
	DD	01bH
	DD	01d2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_sbcd128_to_dfp_ext_reg
	DD	01bH
	DD	024bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_fix64_to_dfp_long_reg
	DD	01bH
	DD	01d9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_fix64_to_dfp_ext_reg
	DD	01bH
	DD	01bbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_compare_exponent_dfp_long_reg
	DD	01bH
	DD	0190H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_compare_exponent_dfp_ext_reg
	DD	01bH
	DD	01c1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_compare_and_signal_dfp_long_reg
	DD	01bH
	DD	0280H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_compare_and_signal_dfp_ext_reg
	DD	01bH
	DD	02b7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_compare_dfp_long_reg
	DD	01bH
	DD	0261H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_compare_dfp_ext_reg
	DD	01bH
	DD	029bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_add_dfp_long_reg
	DD	01bH
	DD	02bbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_add_dfp_ext_reg
	DD	01bH
	DD	02faH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_dfp_long_to_u64_reg
	DD	01bH
	DD	0280H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_dfp_ext_to_u64_reg
	DD	01bH
	DD	02a3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_dfp_long_to_u32_reg
	DD	01bH
	DD	0274H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_dfp_ext_to_u32_reg
	DD	01bH
	DD	02a0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_dfp_long_to_fix32_reg
	DD	01bH
	DD	0274H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_dfp_ext_to_fix32_reg
	DD	01bH
	DD	02a0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_u64_to_dfp_long_reg
	DD	01bH
	DD	01c8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_u64_to_dfp_ext_reg
	DD	01bH
	DD	01d8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_u32_to_dfp_long_reg
	DD	01bH
	DD	01c5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_u32_to_dfp_ext_reg
	DD	01bH
	DD	01d5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_fix32_to_dfp_long_reg
	DD	01bH
	DD	01c5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_convert_fix32_to_dfp_ext_reg
	DD	01bH
	DD	01d5H
voltbl	ENDS
xdata	SEGMENT
$unwind$s370_convert_fix32_to_dfp_ext_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s370_convert_fix32_to_dfp_long_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s370_convert_u32_to_dfp_ext_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s370_convert_u32_to_dfp_long_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s370_convert_u64_to_dfp_ext_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$s370_convert_u64_to_dfp_long_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s370_convert_dfp_ext_to_fix32_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s370_convert_dfp_long_to_fix32_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$s370_convert_dfp_ext_to_u32_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s370_convert_dfp_long_to_u32_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$s370_convert_dfp_ext_to_u64_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$s370_convert_dfp_long_to_u64_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s370_set_dfp_rounding_mode DD 010e01H
	DD	0620eH
$unwind$s370_load_fpr_from_gr_long_reg DD 010e01H
	DD	0620eH
$unwind$s370_load_gr_from_fpr_long_reg DD 010e01H
	DD	0620eH
$unwind$s370_copy_sign_fpr_long_reg DD 010e01H
	DD	0820eH
$unwind$s370_load_complement_fpr_long_reg DD 010e01H
	DD	0820eH
$unwind$s370_load_negative_fpr_long_reg DD 010e01H
	DD	0820eH
$unwind$s370_load_positive_fpr_long_reg DD 010e01H
	DD	0820eH
$unwind$s370_load_fpc_and_signal DD 010e01H
	DD	0820eH
$unwind$s370_set_fpc_and_signal DD 010e01H
	DD	0820eH
$unwind$s370_add_dfp_ext_reg DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$s370_add_dfp_long_reg DD 022319H
	DD	0210111H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$s370_compare_dfp_ext_reg DD 022319H
	DD	0210111H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$s370_compare_dfp_long_reg DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$s370_compare_and_signal_dfp_ext_reg DD 022319H
	DD	0210111H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$s370_compare_and_signal_dfp_long_reg DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$s370_compare_exponent_dfp_ext_reg DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s370_compare_exponent_dfp_long_reg DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$s370_convert_fix64_to_dfp_ext_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s370_convert_fix64_to_dfp_long_reg DD 022319H
	DD	0130111H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$s370_convert_sbcd128_to_dfp_ext_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s370_convert_sbcd64_to_dfp_long_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s370_convert_ubcd128_to_dfp_ext_reg DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$s370_convert_ubcd64_to_dfp_long_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$s370_convert_dfp_ext_to_fix64_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s370_convert_dfp_long_to_fix64_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$s370_convert_dfp_ext_to_sbcd128_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$s370_convert_dfp_long_to_sbcd64_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$s370_convert_dfp_ext_to_ubcd128_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$s370_convert_dfp_long_to_ubcd64_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$s370_divide_dfp_ext_reg DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$s370_divide_dfp_long_reg DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$s370_extract_biased_exponent_dfp_ext_to_fix64_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s370_extract_biased_exponent_dfp_long_to_fix64_reg DD 022319H
	DD	0130111H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$s370_extract_significance_dfp_ext_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s370_extract_significance_dfp_long_reg DD 022319H
	DD	0130111H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$s370_insert_biased_exponent_fix64_to_dfp_ext_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$s370_insert_biased_exponent_fix64_to_dfp_long_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$s370_load_and_test_dfp_ext_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$s370_load_and_test_dfp_long_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$s370_load_fp_int_dfp_ext_reg DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$s370_load_fp_int_dfp_long_reg DD 022319H
	DD	0210111H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$s370_load_lengthened_dfp_long_to_ext_reg DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s370_load_lengthened_dfp_short_to_long_reg DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$s370_load_rounded_dfp_ext_to_long_reg DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$s370_load_rounded_dfp_long_to_short_reg DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$s370_multiply_dfp_ext_reg DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$s370_multiply_dfp_long_reg DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$s370_quantize_dfp_ext_reg DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$s370_quantize_dfp_long_reg DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$s370_reround_dfp_ext_reg DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$s370_reround_dfp_long_reg DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s370_shift_coefficient_left_dfp_ext DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$s370_shift_coefficient_left_dfp_long DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s370_shift_coefficient_right_dfp_ext DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$s370_shift_coefficient_right_dfp_long DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$s370_subtract_dfp_ext_reg DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$s370_subtract_dfp_long_reg DD 022319H
	DD	0210111H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$s370_test_data_class_dfp_ext DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s370_test_data_class_dfp_long DD 022319H
	DD	0130111H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$s370_test_data_class_dfp_short DD 022319H
	DD	0130111H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$s370_test_data_group_dfp_ext DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$s370_test_data_group_dfp_long DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s370_test_data_group_dfp_short DD 022319H
	DD	0130111H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$fpc_signal_check DD 010c01H
	DD	0420cH
$unwind$dfp32_extract_lmd DD 010901H
	DD	02209H
$unwind$dfp64_extract_lmd DD 010901H
	DD	02209H
$unwind$dfp128_extract_lmd DD 010901H
	DD	02209H
$unwind$dfp_compare_exponent DD 010e01H
	DD	0220eH
$unwind$dfp_number_from_fix64 DD 012219H
	DD	0c213H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$dfp_number_to_fix64 DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$dfp_shift_coeff DD 032919H
	DD	01c0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$dfp_test_data_class DD 012219H
	DD	0c213H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$dfp_test_data_group DD 011801H
	DD	04218H
$unwind$dfp_number_from_fix32 DD 012119H
	DD	0c212H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$dfp_number_from_u32 DD 012119H
	DD	0c212H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$dfp_number_from_u64 DD 012219H
	DD	0c213H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$dfp_number_to_fix32 DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck
	DD	0d8H
$unwind$dfp_number_to_u32 DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$dfp_number_to_u64 DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck
	DD	0d8H
$unwind$s370_dfp_rounding_mode DD 011201H
	DD	02212H
$unwind$s370_dfp_reg_to_decimal32 DD 011201H
	DD	02212H
$unwind$s370_dfp_reg_from_decimal32 DD 011201H
	DD	02212H
$unwind$s370_dfp_reg_to_decimal64 DD 011201H
	DD	02212H
$unwind$s370_dfp_reg_from_decimal64 DD 011201H
	DD	02212H
$unwind$s370_dfp_reg_to_decimal128 DD 011201H
	DD	02212H
$unwind$s370_dfp_reg_from_decimal128 DD 011201H
	DD	02212H
$unwind$s370_dfp_status_check DD 010e01H
	DD	0820eH
$unwind$z900_convert_fix32_to_dfp_ext_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_convert_fix32_to_dfp_long_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_convert_u32_to_dfp_ext_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_convert_u32_to_dfp_long_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_convert_u64_to_dfp_ext_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_convert_u64_to_dfp_long_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_convert_dfp_ext_to_fix32_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$z900_convert_dfp_long_to_fix32_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_convert_dfp_ext_to_u32_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$z900_convert_dfp_long_to_u32_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_convert_dfp_ext_to_u64_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$z900_convert_dfp_long_to_u64_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$z900_set_dfp_rounding_mode DD 010e01H
	DD	0620eH
$unwind$z900_load_fpr_from_gr_long_reg DD 010e01H
	DD	0620eH
$unwind$z900_load_gr_from_fpr_long_reg DD 010e01H
	DD	0620eH
$unwind$z900_copy_sign_fpr_long_reg DD 010e01H
	DD	0820eH
$unwind$z900_load_complement_fpr_long_reg DD 010e01H
	DD	0820eH
$unwind$z900_load_negative_fpr_long_reg DD 010e01H
	DD	0820eH
$unwind$z900_load_positive_fpr_long_reg DD 010e01H
	DD	0820eH
$unwind$z900_load_fpc_and_signal DD 010e01H
	DD	0820eH
$unwind$z900_set_fpc_and_signal DD 010e01H
	DD	0820eH
$unwind$z900_add_dfp_ext_reg DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$z900_add_dfp_long_reg DD 022319H
	DD	0210111H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$z900_compare_dfp_ext_reg DD 022319H
	DD	0210111H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$z900_compare_dfp_long_reg DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$z900_compare_and_signal_dfp_ext_reg DD 022319H
	DD	0210111H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$z900_compare_and_signal_dfp_long_reg DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$z900_compare_exponent_dfp_ext_reg DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_compare_exponent_dfp_long_reg DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$z900_convert_fix64_to_dfp_ext_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_convert_fix64_to_dfp_long_reg DD 022319H
	DD	0130111H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$z900_convert_sbcd128_to_dfp_ext_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$z900_convert_sbcd64_to_dfp_long_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_convert_ubcd128_to_dfp_ext_reg DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$z900_convert_ubcd64_to_dfp_long_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$z900_convert_dfp_ext_to_fix64_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$z900_convert_dfp_long_to_fix64_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_convert_dfp_ext_to_sbcd128_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$z900_convert_dfp_long_to_sbcd64_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_convert_dfp_ext_to_ubcd128_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$z900_convert_dfp_long_to_ubcd64_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_divide_dfp_ext_reg DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$z900_divide_dfp_long_reg DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$z900_extract_biased_exponent_dfp_ext_to_fix64_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_extract_biased_exponent_dfp_long_to_fix64_reg DD 022319H
	DD	0130111H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$z900_extract_significance_dfp_ext_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_extract_significance_dfp_long_reg DD 022319H
	DD	0130111H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$z900_insert_biased_exponent_fix64_to_dfp_ext_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$z900_insert_biased_exponent_fix64_to_dfp_long_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_load_and_test_dfp_ext_reg DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$z900_load_and_test_dfp_long_reg DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_load_fp_int_dfp_ext_reg DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$z900_load_fp_int_dfp_long_reg DD 022319H
	DD	0210111H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$z900_load_lengthened_dfp_long_to_ext_reg DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_load_lengthened_dfp_short_to_long_reg DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$z900_load_rounded_dfp_ext_to_long_reg DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$z900_load_rounded_dfp_long_to_short_reg DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$z900_multiply_dfp_ext_reg DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$z900_multiply_dfp_long_reg DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$z900_quantize_dfp_ext_reg DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$z900_quantize_dfp_long_reg DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$z900_reround_dfp_ext_reg DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$z900_reround_dfp_long_reg DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_shift_coefficient_left_dfp_ext DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck
	DD	0d8H
$unwind$z900_shift_coefficient_left_dfp_long DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$z900_shift_coefficient_right_dfp_ext DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck
	DD	0d8H
$unwind$z900_shift_coefficient_right_dfp_long DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$z900_subtract_dfp_ext_reg DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$z900_subtract_dfp_long_reg DD 022319H
	DD	0210111H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$z900_test_data_class_dfp_ext DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_test_data_class_dfp_long DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_test_data_class_dfp_short DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_test_data_group_dfp_ext DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$z900_test_data_group_dfp_long DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_test_data_group_dfp_short DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_convert_zoned_to_dfp_ext DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$z900_convert_zoned_to_dfp_long DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$z900_convert_dfp_ext_to_zoned DD 022319H
	DD	0210111H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$z900_convert_dfp_long_to_zoned DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$z900_convert_packed_to_dfp_ext DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_convert_packed_to_dfp_long DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$z900_convert_dfp_ext_to_packed DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$z900_convert_dfp_long_to_packed DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$dfp_number_from_zoned DD 012719H
	DD	0e218H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$dfp_number_to_zoned DD 022d19H
	DD	01d011bH
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$dfp_number_from_packed DD 022a19H
	DD	011011bH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$dfp_number_to_packed DD 022d19H
	DD	01f011bH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$z900_dfp_rounding_mode DD 011201H
	DD	02212H
$unwind$z900_dfp_reg_to_decimal32 DD 011201H
	DD	02212H
$unwind$z900_dfp_reg_from_decimal32 DD 011201H
	DD	02212H
$unwind$z900_dfp_reg_to_decimal64 DD 011201H
	DD	02212H
$unwind$z900_dfp_reg_from_decimal64 DD 011201H
	DD	02212H
$unwind$z900_dfp_reg_to_decimal128 DD 011201H
	DD	02212H
$unwind$z900_dfp_reg_from_decimal128 DD 011201H
	DD	02212H
$unwind$z900_dfp_status_check DD 010e01H
	DD	0820eH
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
suppress$ = 36
tv128 = 40
tv130 = 44
tv153 = 48
tv161 = 52
tv175 = 56
pset$ = 80
regs$ = 88
z900_dfp_status_check PROC

; 1858 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1859 : BYTE    dxc = 0;                        /* Data exception code       */

  0000e	c6 44 24 20 00	 mov	 BYTE PTR dxc$[rsp], 0

; 1860 : int     suppress = 0;                   /* 1=suppress, 0=complete    */

  00013	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR suppress$[rsp], 0

; 1861 : 
; 1862 :     if (pset->status & DEC_IEEE_854_Invalid_operation)

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00020	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00023	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  00028	85 c0		 test	 eax, eax
  0002a	74 42		 je	 SHORT $LN2@z900_dfp_s

; 1863 :     {
; 1864 :         /* An IEEE-invalid-operation condition was recognized */
; 1865 :         if ((regs->fpc & FPC_MASK_IMI) == 0)

  0002c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00031	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00037	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0003c	85 c0		 test	 eax, eax
  0003e	75 1c		 jne	 SHORT $LN4@z900_dfp_s

; 1866 :         {
; 1867 :             regs->fpc |= FPC_FLAG_SFI;

  00040	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00045	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0004b	0f ba e8 17	 bts	 eax, 23
  0004f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1868 :         }

  0005a	eb 0d		 jmp	 SHORT $LN5@z900_dfp_s
$LN4@z900_dfp_s:

; 1869 :         else
; 1870 :         {
; 1871 :             dxc = DXC_IEEE_INVALID_OP;

  0005c	c6 44 24 20 80	 mov	 BYTE PTR dxc$[rsp], 128	; 00000080H

; 1872 :             suppress = 1;

  00061	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR suppress$[rsp], 1
$LN5@z900_dfp_s:

; 1873 :         }
; 1874 :     }

  00069	e9 4c 02 00 00	 jmp	 $LN3@z900_dfp_s
$LN2@z900_dfp_s:

; 1875 :     else if (pset->status & DEC_IEEE_854_Division_by_zero)

  0006e	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00073	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00076	83 e0 02	 and	 eax, 2
  00079	85 c0		 test	 eax, eax
  0007b	74 42		 je	 SHORT $LN6@z900_dfp_s

; 1876 :     {
; 1877 :         /* An IEEE-division-by-zero condition was recognized */
; 1878 :         if ((regs->fpc & FPC_MASK_IMZ) == 0)

  0007d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00082	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00088	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0008d	85 c0		 test	 eax, eax
  0008f	75 1c		 jne	 SHORT $LN8@z900_dfp_s

; 1879 :         {
; 1880 :             /* Division-by-zero mask is zero */
; 1881 :             regs->fpc |= FPC_FLAG_SFZ;

  00091	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00096	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0009c	0f ba e8 16	 bts	 eax, 22
  000a0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1882 :         }

  000ab	eb 0d		 jmp	 SHORT $LN9@z900_dfp_s
$LN8@z900_dfp_s:

; 1883 :         else
; 1884 :         {
; 1885 :             /* Division-by-zero mask is one */
; 1886 :             dxc = DXC_IEEE_DIV_ZERO;

  000ad	c6 44 24 20 40	 mov	 BYTE PTR dxc$[rsp], 64	; 00000040H

; 1887 :             suppress = 1;

  000b2	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR suppress$[rsp], 1
$LN9@z900_dfp_s:

; 1888 :         }
; 1889 :     }

  000ba	e9 fb 01 00 00	 jmp	 $LN7@z900_dfp_s
$LN6@z900_dfp_s:

; 1890 :     else if (pset->status & DEC_IEEE_854_Overflow)

  000bf	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  000c4	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000c7	25 00 02 00 00	 and	 eax, 512		; 00000200H
  000cc	85 c0		 test	 eax, eax
  000ce	0f 84 82 00 00
	00		 je	 $LN10@z900_dfp_s

; 1891 :     {
; 1892 :         /* An IEEE-overflow condition was recognized */
; 1893 :         if ((regs->fpc & FPC_MASK_IMO) == 0)

  000d4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  000df	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  000e4	85 c0		 test	 eax, eax
  000e6	75 1c		 jne	 SHORT $LN12@z900_dfp_s

; 1894 :         {
; 1895 :             /* Overflow mask is zero */
; 1896 :             regs->fpc |= FPC_FLAG_SFO;

  000e8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  000f3	0f ba e8 15	 bts	 eax, 21
  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1897 :         }

  00102	eb 4d		 jmp	 SHORT $LN13@z900_dfp_s
$LN12@z900_dfp_s:

; 1898 :         else
; 1899 :         {
; 1900 :             /* Overflow mask is one */
; 1901 :             dxc = (pset->status & DEC_IEEE_854_Inexact) ?

  00104	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00109	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0010c	83 e0 20	 and	 eax, 32			; 00000020H
  0010f	85 c0		 test	 eax, eax
  00111	74 2d		 je	 SHORT $LN30@z900_dfp_s
  00113	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00118	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0011b	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00120	85 c0		 test	 eax, eax
  00122	74 0a		 je	 SHORT $LN28@z900_dfp_s
  00124	c7 44 24 28 2c
	00 00 00	 mov	 DWORD PTR tv128[rsp], 44 ; 0000002cH
  0012c	eb 08		 jmp	 SHORT $LN29@z900_dfp_s
$LN28@z900_dfp_s:
  0012e	c7 44 24 28 28
	00 00 00	 mov	 DWORD PTR tv128[rsp], 40 ; 00000028H
$LN29@z900_dfp_s:
  00136	8b 44 24 28	 mov	 eax, DWORD PTR tv128[rsp]
  0013a	89 44 24 2c	 mov	 DWORD PTR tv130[rsp], eax
  0013e	eb 08		 jmp	 SHORT $LN31@z900_dfp_s
$LN30@z900_dfp_s:
  00140	c7 44 24 2c 20
	00 00 00	 mov	 DWORD PTR tv130[rsp], 32 ; 00000020H
$LN31@z900_dfp_s:
  00148	0f b6 44 24 2c	 movzx	 eax, BYTE PTR tv130[rsp]
  0014d	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al
$LN13@z900_dfp_s:

; 1902 :                     ((pset->status & DEC_Rounded) ?
; 1903 :                         DXC_IEEE_OF_INEX_INCR :
; 1904 :                         DXC_IEEE_OF_INEX_TRUNC ) :
; 1905 :                         DXC_IEEE_OF_EXACT ;
; 1906 :         }
; 1907 :     }

  00151	e9 64 01 00 00	 jmp	 $LN11@z900_dfp_s
$LN10@z900_dfp_s:

; 1908 :     else if (pset->status & DEC_IEEE_854_Underflow)

  00156	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  0015b	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0015e	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00163	85 c0		 test	 eax, eax
  00165	0f 84 e4 00 00
	00		 je	 $LN14@z900_dfp_s

; 1909 :     {
; 1910 :         /* An IEEE-underflow condition was recognized */
; 1911 :         if ((regs->fpc & FPC_MASK_IMU) == 0)

  0016b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00170	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00176	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0017b	85 c0		 test	 eax, eax
  0017d	0f 85 88 00 00
	00		 jne	 $LN16@z900_dfp_s

; 1912 :         {
; 1913 :             /* Underflow mask is zero */
; 1914 :             if (pset->status & DEC_IEEE_854_Inexact)

  00183	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00188	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0018b	83 e0 20	 and	 eax, 32			; 00000020H
  0018e	85 c0		 test	 eax, eax
  00190	74 77		 je	 SHORT $LN18@z900_dfp_s

; 1915 :             {
; 1916 :                 if ((regs->fpc & FPC_MASK_IMX) == 0)

  00192	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00197	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0019d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001a2	85 c0		 test	 eax, eax
  001a4	75 1d		 jne	 SHORT $LN19@z900_dfp_s

; 1917 :                 {
; 1918 :                     /* Inexact result with inexact mask zero */
; 1919 :                     regs->fpc |= (FPC_FLAG_SFU | FPC_FLAG_SFX);

  001a6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001ab	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001b1	0d 00 00 18 00	 or	 eax, 1572864		; 00180000H
  001b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001bb	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1920 :                 }

  001c1	eb 46		 jmp	 SHORT $LN20@z900_dfp_s
$LN19@z900_dfp_s:

; 1921 :                 else
; 1922 :                 {
; 1923 :                     /* Inexact result with inexact mask one */
; 1924 :                     regs->fpc |= FPC_FLAG_SFU;

  001c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001c8	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ce	0f ba e8 14	 bts	 eax, 20
  001d2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d7	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1925 :                     dxc = (pset->status & DEC_Rounded) ?

  001dd	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  001e2	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001e5	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  001ea	85 c0		 test	 eax, eax
  001ec	74 0a		 je	 SHORT $LN32@z900_dfp_s
  001ee	c7 44 24 30 0c
	00 00 00	 mov	 DWORD PTR tv153[rsp], 12
  001f6	eb 08		 jmp	 SHORT $LN33@z900_dfp_s
$LN32@z900_dfp_s:
  001f8	c7 44 24 30 08
	00 00 00	 mov	 DWORD PTR tv153[rsp], 8
$LN33@z900_dfp_s:
  00200	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv153[rsp]
  00205	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al
$LN20@z900_dfp_s:
$LN18@z900_dfp_s:

; 1926 :                             DXC_IEEE_INEXACT_INCR :
; 1927 :                             DXC_IEEE_INEXACT_TRUNC ;
; 1928 :                 }
; 1929 :             }
; 1930 :         }

  00209	eb 42		 jmp	 SHORT $LN17@z900_dfp_s
$LN16@z900_dfp_s:

; 1931 :         else
; 1932 :         {
; 1933 :             /* Underflow mask is one */
; 1934 :             if (pset->status & DEC_IEEE_854_Inexact)

  0020b	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00210	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00213	83 e0 20	 and	 eax, 32			; 00000020H
  00216	85 c0		 test	 eax, eax
  00218	74 2e		 je	 SHORT $LN21@z900_dfp_s

; 1935 :             {
; 1936 :                 /* Underflow with inexact result */
; 1937 :                 dxc = (pset->status & DEC_Rounded) ?

  0021a	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  0021f	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00222	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00227	85 c0		 test	 eax, eax
  00229	74 0a		 je	 SHORT $LN34@z900_dfp_s
  0022b	c7 44 24 34 1c
	00 00 00	 mov	 DWORD PTR tv161[rsp], 28
  00233	eb 08		 jmp	 SHORT $LN35@z900_dfp_s
$LN34@z900_dfp_s:
  00235	c7 44 24 34 18
	00 00 00	 mov	 DWORD PTR tv161[rsp], 24
$LN35@z900_dfp_s:
  0023d	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv161[rsp]
  00242	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 1938 :                         DXC_IEEE_UF_INEX_INCR :
; 1939 :                         DXC_IEEE_UF_INEX_TRUNC ;
; 1940 :             }

  00246	eb 05		 jmp	 SHORT $LN22@z900_dfp_s
$LN21@z900_dfp_s:

; 1941 :             else
; 1942 :             {
; 1943 :                 /* Underflow with exact result */
; 1944 :                 dxc = DXC_IEEE_UF_EXACT;

  00248	c6 44 24 20 10	 mov	 BYTE PTR dxc$[rsp], 16
$LN22@z900_dfp_s:
$LN17@z900_dfp_s:

; 1945 :             }
; 1946 :         }
; 1947 :     }

  0024d	eb 6b		 jmp	 SHORT $LN15@z900_dfp_s
$LN14@z900_dfp_s:

; 1948 :     else if (pset->status & DEC_IEEE_854_Inexact)

  0024f	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00254	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00257	83 e0 20	 and	 eax, 32			; 00000020H
  0025a	85 c0		 test	 eax, eax
  0025c	74 5c		 je	 SHORT $LN23@z900_dfp_s

; 1949 :     {
; 1950 :         /* An IEEE-inexact condition was recognized */
; 1951 :         if ((regs->fpc & FPC_MASK_IMX) == 0)

  0025e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00263	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00269	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0026e	85 c0		 test	 eax, eax
  00270	75 1c		 jne	 SHORT $LN24@z900_dfp_s

; 1952 :         {
; 1953 :             /* Inexact mask is zero */
; 1954 :             regs->fpc |= FPC_FLAG_SFX;

  00272	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00277	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0027d	0f ba e8 13	 bts	 eax, 19
  00281	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00286	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1955 :         }

  0028c	eb 2c		 jmp	 SHORT $LN25@z900_dfp_s
$LN24@z900_dfp_s:

; 1956 :         else
; 1957 :         {
; 1958 :             /* Inexact mask is one */
; 1959 :             dxc = (pset->status & DEC_Rounded) ?

  0028e	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00293	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00296	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0029b	85 c0		 test	 eax, eax
  0029d	74 0a		 je	 SHORT $LN36@z900_dfp_s
  0029f	c7 44 24 38 0c
	00 00 00	 mov	 DWORD PTR tv175[rsp], 12
  002a7	eb 08		 jmp	 SHORT $LN37@z900_dfp_s
$LN36@z900_dfp_s:
  002a9	c7 44 24 38 08
	00 00 00	 mov	 DWORD PTR tv175[rsp], 8
$LN37@z900_dfp_s:
  002b1	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv175[rsp]
  002b6	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al
$LN25@z900_dfp_s:
$LN23@z900_dfp_s:
$LN15@z900_dfp_s:
$LN11@z900_dfp_s:
$LN7@z900_dfp_s:
$LN3@z900_dfp_s:

; 1960 :                     DXC_IEEE_INEXACT_INCR :
; 1961 :                     DXC_IEEE_INEXACT_TRUNC ;
; 1962 :         }
; 1963 :     }
; 1964 : 
; 1965 :     /* If suppression is indicated, raise a data exception */
; 1966 :     if (suppress)

  002ba	83 7c 24 24 00	 cmp	 DWORD PTR suppress$[rsp], 0
  002bf	74 1f		 je	 SHORT $LN26@z900_dfp_s

; 1967 :     {
; 1968 :         regs->dxc = dxc;

  002c1	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002cb	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 1969 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002d1	ba 07 00 00 00	 mov	 edx, 7
  002d6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002db	e8 00 00 00 00	 call	 z900_program_interrupt
$LN26@z900_dfp_s:

; 1970 :     }
; 1971 : 
; 1972 :     /* Otherwise return to complete the instruction */
; 1973 :     return dxc;

  002e0	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]

; 1974 : 
; 1975 : } /* end function dfp_status_check */

  002e5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002e9	c3		 ret	 0
z900_dfp_status_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 0
j$ = 4
qwp$ = 8
rn$ = 32
xp$ = 40
regs$ = 48
z900_dfp_reg_from_decimal128 PROC

; 1804 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1805 : int     i, j;                           /* FP register subscripts    */
; 1806 : QW      *qwp;                           /* Quadword pointer          */
; 1807 : 
; 1808 :     i = FPR2I(rn);                      /* Left register index       */

  00012	8b 44 24 20	 mov	 eax, DWORD PTR rn$[rsp]
  00016	d1 e0		 shl	 eax, 1
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 1809 :     j = i + FPREX;                      /* Right register index      */

  0001b	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 44 24 04	 mov	 DWORD PTR j$[rsp], eax

; 1810 :     qwp = (QW*)xp;                      /* Convert to QW pointer     */

  00025	48 8b 44 24 28	 mov	 rax, QWORD PTR xp$[rsp]
  0002a	48 89 44 24 08	 mov	 QWORD PTR qwp$[rsp], rax

; 1811 :     regs->fpr[i]   = qwp->F.HH.F;       /* Load FPR bits 0-31        */

  0002f	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00038	48 8b 54 24 08	 mov	 rdx, QWORD PTR qwp$[rsp]
  0003d	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  00040	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1812 :     regs->fpr[i+1] = qwp->F.HL.F;       /* Load FPR bits 32-63       */

  00047	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0004a	ff c0		 inc	 eax
  0004c	48 98		 cdqe
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	48 8b 54 24 08	 mov	 rdx, QWORD PTR qwp$[rsp]
  00058	8b 52 08	 mov	 edx, DWORD PTR [rdx+8]
  0005b	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1813 :     regs->fpr[j]   = qwp->F.LH.F;       /* Load FPR bits 64-95       */

  00062	48 63 44 24 04	 movsxd	 rax, DWORD PTR j$[rsp]
  00067	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 8b 54 24 08	 mov	 rdx, QWORD PTR qwp$[rsp]
  00071	8b 52 04	 mov	 edx, DWORD PTR [rdx+4]
  00074	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1814 :     regs->fpr[j+1] = qwp->F.LL.F;       /* Load FPR bits 96-127      */

  0007b	8b 44 24 04	 mov	 eax, DWORD PTR j$[rsp]
  0007f	ff c0		 inc	 eax
  00081	48 98		 cdqe
  00083	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 8b 54 24 08	 mov	 rdx, QWORD PTR qwp$[rsp]
  0008d	8b 12		 mov	 edx, DWORD PTR [rdx]
  0008f	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1815 : 
; 1816 : } /* end function dfp_reg_from_decimal128 */

  00096	48 83 c4 18	 add	 rsp, 24
  0009a	c3		 ret	 0
z900_dfp_reg_from_decimal128 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 0
j$ = 4
qwp$ = 8
rn$ = 32
xp$ = 40
regs$ = 48
z900_dfp_reg_to_decimal128 PROC

; 1780 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1781 : int     i, j;                           /* FP register subscripts    */
; 1782 : QW      *qwp;                           /* Quadword pointer          */
; 1783 : 
; 1784 :     i = FPR2I(rn);                      /* Left register index       */

  00012	8b 44 24 20	 mov	 eax, DWORD PTR rn$[rsp]
  00016	d1 e0		 shl	 eax, 1
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 1785 :     j = i + FPREX;                      /* Right register index      */

  0001b	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 44 24 04	 mov	 DWORD PTR j$[rsp], eax

; 1786 :     qwp = (QW*)xp;                      /* Convert to QW pointer     */

  00025	48 8b 44 24 28	 mov	 rax, QWORD PTR xp$[rsp]
  0002a	48 89 44 24 08	 mov	 QWORD PTR qwp$[rsp], rax

; 1787 :     qwp->F.HH.F = regs->fpr[i];         /* Copy FPR bits 0-31        */

  0002f	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00033	48 8b 4c 24 08	 mov	 rcx, QWORD PTR qwp$[rsp]
  00038	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  0003d	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  00044	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 1788 :     qwp->F.HL.F = regs->fpr[i+1];       /* Copy FPR bits 32-63       */

  00047	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0004a	ff c0		 inc	 eax
  0004c	48 98		 cdqe
  0004e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR qwp$[rsp]
  00053	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  00058	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  0005f	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1789 :     qwp->F.LH.F = regs->fpr[j];         /* Copy FPR bits 64-95       */

  00062	48 63 44 24 04	 movsxd	 rax, DWORD PTR j$[rsp]
  00067	48 8b 4c 24 08	 mov	 rcx, QWORD PTR qwp$[rsp]
  0006c	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  00071	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  00078	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1790 :     qwp->F.LL.F = regs->fpr[j+1];       /* Copy FPR bits 96-127      */

  0007b	8b 44 24 04	 mov	 eax, DWORD PTR j$[rsp]
  0007f	ff c0		 inc	 eax
  00081	48 98		 cdqe
  00083	48 8b 4c 24 08	 mov	 rcx, QWORD PTR qwp$[rsp]
  00088	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  0008d	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  00094	89 01		 mov	 DWORD PTR [rcx], eax

; 1791 : 
; 1792 : } /* end function dfp_reg_to_decimal128 */

  00096	48 83 c4 18	 add	 rsp, 24
  0009a	c3		 ret	 0
z900_dfp_reg_to_decimal128 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 0
dwp$ = 8
rn$ = 32
xp$ = 40
regs$ = 48
z900_dfp_reg_from_decimal64 PROC

; 1759 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1760 : int     i;                              /* FP register subscript     */
; 1761 : DW      *dwp;                           /* Doubleword pointer        */
; 1762 : 
; 1763 :     i = FPR2I(rn);                      /* Register index            */

  00012	8b 44 24 20	 mov	 eax, DWORD PTR rn$[rsp]
  00016	d1 e0		 shl	 eax, 1
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 1764 :     dwp = (DW*)xp;                      /* Convert to DW pointer     */

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR xp$[rsp]
  00020	48 89 44 24 08	 mov	 QWORD PTR dwp$[rsp], rax

; 1765 :     regs->fpr[i]   = dwp->F.H.F;        /* Load FPR bits 0-31        */

  00025	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0002e	48 8b 54 24 08	 mov	 rdx, QWORD PTR dwp$[rsp]
  00033	8b 52 04	 mov	 edx, DWORD PTR [rdx+4]
  00036	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1766 :     regs->fpr[i+1] = dwp->F.L.F;        /* Load FPR bits 32-63       */

  0003d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00040	ff c0		 inc	 eax
  00042	48 98		 cdqe
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	48 8b 54 24 08	 mov	 rdx, QWORD PTR dwp$[rsp]
  0004e	8b 12		 mov	 edx, DWORD PTR [rdx]
  00050	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1767 : 
; 1768 : } /* end function dfp_reg_from_decimal64 */

  00057	48 83 c4 18	 add	 rsp, 24
  0005b	c3		 ret	 0
z900_dfp_reg_from_decimal64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 0
dwp$ = 8
rn$ = 32
xp$ = 40
regs$ = 48
z900_dfp_reg_to_decimal64 PROC

; 1738 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1739 : int     i;                              /* FP register subscript     */
; 1740 : DW      *dwp;                           /* Doubleword pointer        */
; 1741 : 
; 1742 :     i = FPR2I(rn);                      /* Register index            */

  00012	8b 44 24 20	 mov	 eax, DWORD PTR rn$[rsp]
  00016	d1 e0		 shl	 eax, 1
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 1743 :     dwp = (DW*)xp;                      /* Convert to DW pointer     */

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR xp$[rsp]
  00020	48 89 44 24 08	 mov	 QWORD PTR dwp$[rsp], rax

; 1744 :     dwp->F.H.F = regs->fpr[i];          /* Copy FPR bits 0-31        */

  00025	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00029	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dwp$[rsp]
  0002e	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  00033	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  0003a	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1745 :     dwp->F.L.F = regs->fpr[i+1];        /* Copy FPR bits 32-63       */

  0003d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00040	ff c0		 inc	 eax
  00042	48 98		 cdqe
  00044	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dwp$[rsp]
  00049	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  0004e	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  00055	89 01		 mov	 DWORD PTR [rcx], eax

; 1746 : 
; 1747 : } /* end function dfp_reg_to_decimal64 */

  00057	48 83 c4 18	 add	 rsp, 24
  0005b	c3		 ret	 0
z900_dfp_reg_to_decimal64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 0
fwp$ = 8
rn$ = 32
xp$ = 40
regs$ = 48
z900_dfp_reg_from_decimal32 PROC

; 1718 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1719 : int     i;                              /* FP register subscript     */
; 1720 : FW      *fwp;                           /* Fullword pointer          */
; 1721 : 
; 1722 :     i = FPR2I(rn);                      /* Register index            */

  00012	8b 44 24 20	 mov	 eax, DWORD PTR rn$[rsp]
  00016	d1 e0		 shl	 eax, 1
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 1723 :     fwp = (FW*)xp;                      /* Convert to FW pointer     */

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR xp$[rsp]
  00020	48 89 44 24 08	 mov	 QWORD PTR fwp$[rsp], rax

; 1724 :     regs->fpr[i] = fwp->F;              /* Load FPR bits 0-31        */

  00025	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0002e	48 8b 54 24 08	 mov	 rdx, QWORD PTR fwp$[rsp]
  00033	8b 12		 mov	 edx, DWORD PTR [rdx]
  00035	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1725 : 
; 1726 : } /* end function dfp_reg_from_decimal32 */

  0003c	48 83 c4 18	 add	 rsp, 24
  00040	c3		 ret	 0
z900_dfp_reg_from_decimal32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 0
fwp$ = 8
rn$ = 32
xp$ = 40
regs$ = 48
z900_dfp_reg_to_decimal32 PROC

; 1698 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1699 : int     i;                              /* FP register subscript     */
; 1700 : FW      *fwp;                           /* Fullword pointer          */
; 1701 : 
; 1702 :     i = FPR2I(rn);                      /* Register index            */

  00012	8b 44 24 20	 mov	 eax, DWORD PTR rn$[rsp]
  00016	d1 e0		 shl	 eax, 1
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 1703 :     fwp = (FW*)xp;                      /* Convert to FW pointer     */

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR xp$[rsp]
  00020	48 89 44 24 08	 mov	 QWORD PTR fwp$[rsp], rax

; 1704 :     fwp->F = regs->fpr[i];              /* Copy FPR bits 0-31        */

  00025	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00029	48 8b 4c 24 08	 mov	 rcx, QWORD PTR fwp$[rsp]
  0002e	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  00033	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  0003a	89 01		 mov	 DWORD PTR [rcx], eax

; 1705 : 
; 1706 : } /* end function dfp_reg_to_decimal32 */

  0003c	48 83 c4 18	 add	 rsp, 24
  00040	c3		 ret	 0
z900_dfp_reg_to_decimal32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
drm$ = 0
tv73 = 4
pset$ = 32
mask$ = 40
regs$ = 48
z900_dfp_rounding_mode PROC

; 1661 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1662 : BYTE    drm;                            /* Decimal rounding mode     */
; 1663 : 
; 1664 :     /* Load DRM from mask or from FPC register */
; 1665 :     if (mask & 0x08)

  00012	8b 44 24 28	 mov	 eax, DWORD PTR mask$[rsp]
  00016	83 e0 08	 and	 eax, 8
  00019	85 c0		 test	 eax, eax
  0001b	74 0c		 je	 SHORT $LN4@z900_dfp_r

; 1666 :         drm = mask & 0x07;

  0001d	8b 44 24 28	 mov	 eax, DWORD PTR mask$[rsp]
  00021	83 e0 07	 and	 eax, 7
  00024	88 04 24	 mov	 BYTE PTR drm$[rsp], al
  00027	eb 14		 jmp	 SHORT $LN5@z900_dfp_r
$LN4@z900_dfp_r:

; 1667 :     else
; 1668 :         drm = (regs->fpc & FPC_DRM) >> FPC_DRM_SHIFT;

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00034	83 e0 70	 and	 eax, 112		; 00000070H
  00037	c1 e8 04	 shr	 eax, 4
  0003a	88 04 24	 mov	 BYTE PTR drm$[rsp], al
$LN5@z900_dfp_r:

; 1669 : 
; 1670 :     /* Set rounding mode according to DRM value */
; 1671 :     switch (drm) {

  0003d	0f b6 04 24	 movzx	 eax, BYTE PTR drm$[rsp]
  00041	89 44 24 04	 mov	 DWORD PTR tv73[rsp], eax
  00045	83 7c 24 04 07	 cmp	 DWORD PTR tv73[rsp], 7
  0004a	0f 87 86 00 00
	00		 ja	 $LN2@z900_dfp_r
  00050	48 63 44 24 04	 movsxd	 rax, DWORD PTR tv73[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0005c	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN15@z900_dfp_r[rcx+rax*4]
  00063	48 03 c1	 add	 rax, rcx
  00066	ff e0		 jmp	 rax
$LN6@z900_dfp_r:

; 1672 :     case DRM_RNE:  pset->round = DEC_ROUND_HALF_EVEN; break;

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  0006d	c7 40 0c 03 00
	00 00		 mov	 DWORD PTR [rax+12], 3
  00074	eb 60		 jmp	 SHORT $LN2@z900_dfp_r
$LN7@z900_dfp_r:

; 1673 :     case DRM_RTZ:  pset->round = DEC_ROUND_DOWN; break;

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  0007b	c7 40 0c 05 00
	00 00		 mov	 DWORD PTR [rax+12], 5
  00082	eb 52		 jmp	 SHORT $LN2@z900_dfp_r
$LN8@z900_dfp_r:

; 1674 :     case DRM_RTPI: pset->round = DEC_ROUND_CEILING; break;

  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  00089	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0
  00090	eb 44		 jmp	 SHORT $LN2@z900_dfp_r
$LN9@z900_dfp_r:

; 1675 :     case DRM_RTMI: pset->round = DEC_ROUND_FLOOR; break;

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  00097	c7 40 0c 06 00
	00 00		 mov	 DWORD PTR [rax+12], 6
  0009e	eb 36		 jmp	 SHORT $LN2@z900_dfp_r
$LN10@z900_dfp_r:

; 1676 :     case DRM_RNAZ: pset->round = DEC_ROUND_HALF_UP; break;

  000a0	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  000a5	c7 40 0c 02 00
	00 00		 mov	 DWORD PTR [rax+12], 2
  000ac	eb 28		 jmp	 SHORT $LN2@z900_dfp_r
$LN11@z900_dfp_r:

; 1677 :     case DRM_RNTZ: pset->round = DEC_ROUND_HALF_DOWN; break;

  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  000b3	c7 40 0c 04 00
	00 00		 mov	 DWORD PTR [rax+12], 4
  000ba	eb 1a		 jmp	 SHORT $LN2@z900_dfp_r
$LN12@z900_dfp_r:

; 1678 :     case DRM_RAFZ: pset->round = DEC_ROUND_UP; break;

  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  000c1	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [rax+12], 1
  000c8	eb 0c		 jmp	 SHORT $LN2@z900_dfp_r
$LN13@z900_dfp_r:

; 1679 :     case DRM_RFSP:
; 1680 :     /* Rounding mode DRM_RFSP is not supported by
; 1681 :        the decNumber library, so we arbitrarily
; 1682 :        convert it to another mode instead... */
; 1683 :         pset->round = DEC_ROUND_DOWN; break;

  000ca	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  000cf	c7 40 0c 05 00
	00 00		 mov	 DWORD PTR [rax+12], 5
$LN2@z900_dfp_r:

; 1684 :     } /* end switch(drm) */
; 1685 : 
; 1686 : } /* end function dfp_rounding_mode */

  000d6	48 83 c4 18	 add	 rsp, 24
  000da	c3		 ret	 0
  000db	90		 npad	 1
$LN15@z900_dfp_r:
  000dc	00 00 00 00	 DD	 $LN6@z900_dfp_r
  000e0	00 00 00 00	 DD	 $LN7@z900_dfp_r
  000e4	00 00 00 00	 DD	 $LN8@z900_dfp_r
  000e8	00 00 00 00	 DD	 $LN9@z900_dfp_r
  000ec	00 00 00 00	 DD	 $LN10@z900_dfp_r
  000f0	00 00 00 00	 DD	 $LN11@z900_dfp_r
  000f4	00 00 00 00	 DD	 $LN12@z900_dfp_r
  000f8	00 00 00 00	 DD	 $LN13@z900_dfp_r
z900_dfp_rounding_mode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
pSign$ = 32
pad$ = 36
pwind$ = 40
i$ = 44
pDigits$ = 48
pwlen$ = 52
pSigned$ = 56
cc$ = 60
tv67 = 64
tv88 = 68
tv92 = 72
tv160 = 76
tv161 = 80
tv190 = 84
tv206 = 88
tv189 = 92
tv205 = 96
pwork$ = 112
__$ArrayPad$ = 224
dn$ = 256
dc$ = 264
packed$ = 272
len$ = 280
mask$ = 288
pset$ = 296
dfp_number_to_packed PROC

; 1551 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1552 :     int             i;                      /* Array subscript           */
; 1553 :     int             pad;                    /* Number of padding bytes   */
; 1554 :     int             cc;                     /* Condition code            */
; 1555 :     char            pwork[MAXDECSTRLEN + 64]; /* Decimal string work area  */
; 1556 :     int             pwlen;                  /* Length of pwork string    */
; 1557 :     int             pwind;                  /* Index into pwork string   */
; 1558 :     int             pSigned;                /* packed field is signed    */
; 1559 :     unsigned char   pSign = 0x0C;           /* packed sign               */

  0002d	c6 44 24 20 0c	 mov	 BYTE PTR pSign$[rsp], 12
$LN4@dfp_number:

; 1560 :     int             pDigits;                /* number of packed digits   */
; 1561 : 
; 1562 :     UNREFERENCED(pset);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN4@dfp_number

; 1563 : 
; 1564 :     /* determine whether packed value is signed and the sign field */
; 1565 :     pSigned = (m_S) ? 1 : 0;

  00038	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR mask$[rsp]
  0003f	83 e0 08	 and	 eax, 8
  00042	85 c0		 test	 eax, eax
  00044	74 0a		 je	 SHORT $LN19@dfp_number
  00046	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  0004e	eb 08		 jmp	 SHORT $LN20@dfp_number
$LN19@dfp_number:
  00050	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN20@dfp_number:
  00058	8b 44 24 40	 mov	 eax, DWORD PTR tv67[rsp]
  0005c	89 44 24 38	 mov	 DWORD PTR pSigned$[rsp], eax

; 1566 :     if (pSigned) {

  00060	83 7c 24 38 00	 cmp	 DWORD PTR pSigned$[rsp], 0
  00065	0f 84 b6 00 00
	00		 je	 $LN8@dfp_number

; 1567 :         if (decNumberIsNegative(dn)) {

  0006b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  00073	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00077	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0007c	85 c0		 test	 eax, eax
  0007e	74 78		 je	 SHORT $LN9@dfp_number

; 1568 :             pSign = 0x0D;

  00080	c6 44 24 20 0d	 mov	 BYTE PTR pSign$[rsp], 13

; 1569 :             /* -0 : force positive sign based on plus-sign-control */
; 1570 :             if ( m_F && decNumberIsZero(dn))

  00085	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR mask$[rsp]
  0008c	83 e0 01	 and	 eax, 1
  0008f	85 c0		 test	 eax, eax
  00091	74 63		 je	 SHORT $LN11@dfp_number
  00093	b8 02 00 00 00	 mov	 eax, 2
  00098	48 6b c0 00	 imul	 rax, rax, 0
  0009c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  000a4	0f b7 44 01 0a	 movzx	 eax, WORD PTR [rcx+rax+10]
  000a9	85 c0		 test	 eax, eax
  000ab	75 49		 jne	 SHORT $LN11@dfp_number
  000ad	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  000b5	83 38 01	 cmp	 DWORD PTR [rax], 1
  000b8	75 3c		 jne	 SHORT $LN11@dfp_number
  000ba	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  000c2	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  000c6	83 e0 70	 and	 eax, 112		; 00000070H
  000c9	85 c0		 test	 eax, eax
  000cb	75 29		 jne	 SHORT $LN11@dfp_number

; 1571 :                 pSign =  (m_P) ? 0x0F : 0x0C;      /* 0b1111 : 0b1100 */

  000cd	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR mask$[rsp]
  000d4	83 e0 02	 and	 eax, 2
  000d7	85 c0		 test	 eax, eax
  000d9	74 0a		 je	 SHORT $LN21@dfp_number
  000db	c7 44 24 44 0f
	00 00 00	 mov	 DWORD PTR tv88[rsp], 15
  000e3	eb 08		 jmp	 SHORT $LN22@dfp_number
$LN21@dfp_number:
  000e5	c7 44 24 44 0c
	00 00 00	 mov	 DWORD PTR tv88[rsp], 12
$LN22@dfp_number:
  000ed	0f b6 44 24 44	 movzx	 eax, BYTE PTR tv88[rsp]
  000f2	88 44 24 20	 mov	 BYTE PTR pSign$[rsp], al
$LN11@dfp_number:

; 1572 :         }

  000f6	eb 29		 jmp	 SHORT $LN10@dfp_number
$LN9@dfp_number:

; 1573 :         else {
; 1574 :             /* select plus sign */
; 1575 :             pSign = (m_P) ? 0x0F : 0x0C;            /* 0b1111 : 0b1100 */

  000f8	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR mask$[rsp]
  000ff	83 e0 02	 and	 eax, 2
  00102	85 c0		 test	 eax, eax
  00104	74 0a		 je	 SHORT $LN23@dfp_number
  00106	c7 44 24 48 0f
	00 00 00	 mov	 DWORD PTR tv92[rsp], 15
  0010e	eb 08		 jmp	 SHORT $LN24@dfp_number
$LN23@dfp_number:
  00110	c7 44 24 48 0c
	00 00 00	 mov	 DWORD PTR tv92[rsp], 12
$LN24@dfp_number:
  00118	0f b6 44 24 48	 movzx	 eax, BYTE PTR tv92[rsp]
  0011d	88 44 24 20	 mov	 BYTE PTR pSign$[rsp], al
$LN10@dfp_number:
$LN8@dfp_number:

; 1576 :         }
; 1577 :     }
; 1578 : 
; 1579 :     /* the number of packed digits */
; 1580 :     pDigits = 2 * (len + 1) - pSigned;

  00121	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00128	8d 44 00 02	 lea	 eax, DWORD PTR [rax+rax+2]
  0012c	2b 44 24 38	 sub	 eax, DWORD PTR pSigned$[rsp]
  00130	89 44 24 30	 mov	 DWORD PTR pDigits$[rsp], eax

; 1581 : 
; 1582 :     /* Convert decimal number to string */
; 1583 :     /* only sigificant digits, ignore exponent and sign */
; 1584 :     if (decNumberIsNaN(dn) || (decNumberIsInfinite(dn)))

  00134	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  0013c	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00140	83 e0 30	 and	 eax, 48			; 00000030H
  00143	85 c0		 test	 eax, eax
  00145	75 13		 jne	 SHORT $LN14@dfp_number
  00147	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  0014f	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00153	83 e0 40	 and	 eax, 64			; 00000040H
  00156	85 c0		 test	 eax, eax
  00158	74 49		 je	 SHORT $LN12@dfp_number
$LN14@dfp_number:

; 1585 :     {
; 1586 :         /* For NaN or Inf set cc=3 and use coefficient only */
; 1587 :         cc = 3;

  0015a	c7 44 24 3c 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3

; 1588 :         dc->exponent = 0;

  00162	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR dc$[rsp]
  0016a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 1589 :         dc->bits &= ~(DECNEG);

  00171	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR dc$[rsp]
  00179	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  0017d	0f ba f0 07	 btr	 eax, 7
  00181	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR dc$[rsp]
  00189	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 1590 :         decNumberToString(dc, pwork);

  0018c	48 8d 54 24 70	 lea	 rdx, QWORD PTR pwork$[rsp]
  00191	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR dc$[rsp]
  00199	e8 00 00 00 00	 call	 decNumberToString

; 1591 :     }

  0019e	e9 b7 00 00 00	 jmp	 $LN13@dfp_number
$LN12@dfp_number:

; 1592 :     else {
; 1593 :         /* For finite numbers set cc=0, 1, or 2 and convert digits */
; 1594 :         cc = (decNumberIsZero(dn)) ? 0 :

  001a3	b8 02 00 00 00	 mov	 eax, 2
  001a8	48 6b c0 00	 imul	 rax, rax, 0
  001ac	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  001b4	0f b7 44 01 0a	 movzx	 eax, WORD PTR [rcx+rax+10]
  001b9	85 c0		 test	 eax, eax
  001bb	75 2a		 jne	 SHORT $LN25@dfp_number
  001bd	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  001c5	83 38 01	 cmp	 DWORD PTR [rax], 1
  001c8	75 1d		 jne	 SHORT $LN25@dfp_number
  001ca	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  001d2	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  001d6	83 e0 70	 and	 eax, 112		; 00000070H
  001d9	85 c0		 test	 eax, eax
  001db	75 0a		 jne	 SHORT $LN25@dfp_number
  001dd	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
  001e5	eb 2f		 jmp	 SHORT $LN28@dfp_number
$LN25@dfp_number:
  001e7	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  001ef	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  001f3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001f8	85 c0		 test	 eax, eax
  001fa	74 0a		 je	 SHORT $LN26@dfp_number
  001fc	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv160[rsp], 1
  00204	eb 08		 jmp	 SHORT $LN27@dfp_number
$LN26@dfp_number:
  00206	c7 44 24 4c 02
	00 00 00	 mov	 DWORD PTR tv160[rsp], 2
$LN27@dfp_number:
  0020e	8b 44 24 4c	 mov	 eax, DWORD PTR tv160[rsp]
  00212	89 44 24 50	 mov	 DWORD PTR tv161[rsp], eax
$LN28@dfp_number:
  00216	8b 44 24 50	 mov	 eax, DWORD PTR tv161[rsp]
  0021a	89 44 24 3c	 mov	 DWORD PTR cc$[rsp], eax

; 1595 :             (decNumberIsNegative(dn)) ? 1 : 2;
; 1596 :         dn->exponent = 0;

  0021e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  00226	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 1597 :         dn->bits &= ~(DECNEG);

  0022d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  00235	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00239	0f ba f0 07	 btr	 eax, 7
  0023d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  00245	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 1598 :         decNumberToString(dn, pwork);

  00248	48 8d 54 24 70	 lea	 rdx, QWORD PTR pwork$[rsp]
  0024d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  00255	e8 00 00 00 00	 call	 decNumberToString
$LN13@dfp_number:

; 1599 :     }
; 1600 : 
; 1601 :     /* Calculate the number of padding digits needed, and set
; 1602 :        condition code 3 if significant digits will be lost */
; 1603 :     pwlen = (int)(strlen(pwork));

  0025a	48 8d 4c 24 70	 lea	 rcx, QWORD PTR pwork$[rsp]
  0025f	e8 00 00 00 00	 call	 strlen
  00264	89 44 24 34	 mov	 DWORD PTR pwlen$[rsp], eax

; 1604 :     if (pwlen <= pDigits)

  00268	8b 44 24 30	 mov	 eax, DWORD PTR pDigits$[rsp]
  0026c	39 44 24 34	 cmp	 DWORD PTR pwlen$[rsp], eax
  00270	7f 1a		 jg	 SHORT $LN15@dfp_number

; 1605 :     {
; 1606 :         pwind = 0;

  00272	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR pwind$[rsp], 0

; 1607 :         pad =  pDigits - pwlen;

  0027a	8b 44 24 34	 mov	 eax, DWORD PTR pwlen$[rsp]
  0027e	8b 4c 24 30	 mov	 ecx, DWORD PTR pDigits$[rsp]
  00282	2b c8		 sub	 ecx, eax
  00284	8b c1		 mov	 eax, ecx
  00286	89 44 24 24	 mov	 DWORD PTR pad$[rsp], eax

; 1608 :     }

  0028a	eb 20		 jmp	 SHORT $LN16@dfp_number
$LN15@dfp_number:

; 1609 :     else {
; 1610 :         pwind = pwlen - pDigits ;

  0028c	8b 44 24 30	 mov	 eax, DWORD PTR pDigits$[rsp]
  00290	8b 4c 24 34	 mov	 ecx, DWORD PTR pwlen$[rsp]
  00294	2b c8		 sub	 ecx, eax
  00296	8b c1		 mov	 eax, ecx
  00298	89 44 24 28	 mov	 DWORD PTR pwind$[rsp], eax

; 1611 :         pad = 0;

  0029c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR pad$[rsp], 0

; 1612 :         cc = 3;

  002a4	c7 44 24 3c 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN16@dfp_number:

; 1613 :     }
; 1614 : 
; 1615 :     /* Copy digits to packed decimal result area */
; 1616 :     for (i = 0; i <= len; i++)

  002ac	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002b4	eb 0a		 jmp	 SHORT $LN7@dfp_number
$LN5@dfp_number:
  002b6	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  002ba	ff c0		 inc	 eax
  002bc	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
$LN7@dfp_number:
  002c0	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  002c7	39 44 24 2c	 cmp	 DWORD PTR i$[rsp], eax
  002cb	0f 8f c5 00 00
	00		 jg	 $LN6@dfp_number

; 1617 :     {
; 1618 :         /* Pad with zero or copy digit from work string */
; 1619 :         packed[i]  = (((pad-- > 0) ? 0x00 : pwork[pwind++] - '0') & 0x0F ) << 4 ;

  002d1	8b 44 24 24	 mov	 eax, DWORD PTR pad$[rsp]
  002d5	89 44 24 5c	 mov	 DWORD PTR tv189[rsp], eax
  002d9	8b 44 24 24	 mov	 eax, DWORD PTR pad$[rsp]
  002dd	ff c8		 dec	 eax
  002df	89 44 24 24	 mov	 DWORD PTR pad$[rsp], eax
  002e3	83 7c 24 5c 00	 cmp	 DWORD PTR tv189[rsp], 0
  002e8	7e 0a		 jle	 SHORT $LN29@dfp_number
  002ea	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv190[rsp], 0
  002f2	eb 1b		 jmp	 SHORT $LN30@dfp_number
$LN29@dfp_number:
  002f4	48 63 44 24 28	 movsxd	 rax, DWORD PTR pwind$[rsp]
  002f9	0f be 44 04 70	 movsx	 eax, BYTE PTR pwork$[rsp+rax]
  002fe	83 e8 30	 sub	 eax, 48			; 00000030H
  00301	89 44 24 54	 mov	 DWORD PTR tv190[rsp], eax
  00305	8b 44 24 28	 mov	 eax, DWORD PTR pwind$[rsp]
  00309	ff c0		 inc	 eax
  0030b	89 44 24 28	 mov	 DWORD PTR pwind$[rsp], eax
$LN30@dfp_number:
  0030f	8b 44 24 54	 mov	 eax, DWORD PTR tv190[rsp]
  00313	83 e0 0f	 and	 eax, 15
  00316	c1 e0 04	 shl	 eax, 4
  00319	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR i$[rsp]
  0031e	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR packed$[rsp]
  00326	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1620 :         packed[i] |=  ((pad-- > 0) ? 0x00 : pwork[pwind++] - '0') & 0x0F;

  00329	8b 44 24 24	 mov	 eax, DWORD PTR pad$[rsp]
  0032d	89 44 24 60	 mov	 DWORD PTR tv205[rsp], eax
  00331	8b 44 24 24	 mov	 eax, DWORD PTR pad$[rsp]
  00335	ff c8		 dec	 eax
  00337	89 44 24 24	 mov	 DWORD PTR pad$[rsp], eax
  0033b	83 7c 24 60 00	 cmp	 DWORD PTR tv205[rsp], 0
  00340	7e 0a		 jle	 SHORT $LN31@dfp_number
  00342	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv206[rsp], 0
  0034a	eb 1b		 jmp	 SHORT $LN32@dfp_number
$LN31@dfp_number:
  0034c	48 63 44 24 28	 movsxd	 rax, DWORD PTR pwind$[rsp]
  00351	0f be 44 04 70	 movsx	 eax, BYTE PTR pwork$[rsp+rax]
  00356	83 e8 30	 sub	 eax, 48			; 00000030H
  00359	89 44 24 58	 mov	 DWORD PTR tv206[rsp], eax
  0035d	8b 44 24 28	 mov	 eax, DWORD PTR pwind$[rsp]
  00361	ff c0		 inc	 eax
  00363	89 44 24 28	 mov	 DWORD PTR pwind$[rsp], eax
$LN32@dfp_number:
  00367	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i$[rsp]
  0036c	8b 4c 24 58	 mov	 ecx, DWORD PTR tv206[rsp]
  00370	83 e1 0f	 and	 ecx, 15
  00373	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR packed$[rsp]
  0037b	0f be 04 02	 movsx	 eax, BYTE PTR [rdx+rax]
  0037f	0b c1		 or	 eax, ecx
  00381	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR i$[rsp]
  00386	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR packed$[rsp]
  0038e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1621 :     }

  00391	e9 20 ff ff ff	 jmp	 $LN5@dfp_number
$LN6@dfp_number:

; 1622 : 
; 1623 :     /* if signed, insert sign in final nibble */
; 1624 :     if (pSigned)

  00396	83 7c 24 38 00	 cmp	 DWORD PTR pSigned$[rsp], 0
  0039b	74 5a		 je	 SHORT $LN17@dfp_number

; 1625 :     {
; 1626 :         packed[len] &= 0xF0;

  0039d	48 63 84 24 18
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  003a5	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR packed$[rsp]
  003ad	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  003b1	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  003b6	48 63 8c 24 18
	01 00 00	 movsxd	 rcx, DWORD PTR len$[rsp]
  003be	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR packed$[rsp]
  003c6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1627 :         packed[len] |= pSign;

  003c9	48 63 84 24 18
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  003d1	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR pSign$[rsp]
  003d6	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR packed$[rsp]
  003de	0f be 04 02	 movsx	 eax, BYTE PTR [rdx+rax]
  003e2	0b c1		 or	 eax, ecx
  003e4	48 63 8c 24 18
	01 00 00	 movsxd	 rcx, DWORD PTR len$[rsp]
  003ec	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR packed$[rsp]
  003f4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN17@dfp_number:

; 1628 :     }
; 1629 : 
; 1630 :     /* Return the condition code */
; 1631 :     return cc;

  003f7	8b 44 24 3c	 mov	 eax, DWORD PTR cc$[rsp]

; 1632 : 
; 1633 : } /* end function dfp_number_to_packed */

  003fb	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00403	48 33 cc	 xor	 rcx, rsp
  00406	e8 00 00 00 00	 call	 __security_check_cookie
  0040b	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00412	c3		 ret	 0
dfp_number_to_packed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
c$ = 32
i$ = 36
ppw$ = 40
tv77 = 48
tv66 = 52
tv69 = 56
signflag$ = 60
ignoreflag$ = 64
pwork$ = 72
__$ArrayPad$ = 112
dn$ = 144
packed$ = 152
len$ = 160
mask$ = 168
pset$ = 176
dfp_number_from_packed PROC

; 1471 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1472 :     int             i;                      /* Array subscript           */
; 1473 :     int             signflag;               /* 1=signed decimal operand  */
; 1474 :     int             ignoreflag;             /* 1=ignore sign             */
; 1475 :     char            pwork[1 + (CXPT_MAXLEN*2) + 1]; /* Sign + digits + null      */
; 1476 :     char*           ppw = pwork;            /* Addr next byte in pwork   */

  0002a	48 8d 44 24 48	 lea	 rax, QWORD PTR pwork$[rsp]
  0002f	48 89 44 24 28	 mov	 QWORD PTR ppw$[rsp], rax

; 1477 :     char            c;                      /* Character work area       */
; 1478 : 
; 1479 :     /* Set the signed & ignore flags as indicated by the mask */
; 1480 :     signflag   = m_S ? 1 : 0;

  00034	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR mask$[rsp]
  0003b	83 e0 08	 and	 eax, 8
  0003e	85 c0		 test	 eax, eax
  00040	74 0a		 je	 SHORT $LN20@dfp_number
  00042	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  0004a	eb 08		 jmp	 SHORT $LN21@dfp_number
$LN20@dfp_number:
  0004c	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN21@dfp_number:
  00054	8b 44 24 34	 mov	 eax, DWORD PTR tv66[rsp]
  00058	89 44 24 3c	 mov	 DWORD PTR signflag$[rsp], eax

; 1481 :     ignoreflag = m_I ? 1 : 0;

  0005c	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR mask$[rsp]
  00063	83 e0 01	 and	 eax, 1
  00066	85 c0		 test	 eax, eax
  00068	74 0a		 je	 SHORT $LN22@dfp_number
  0006a	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
  00072	eb 08		 jmp	 SHORT $LN23@dfp_number
$LN22@dfp_number:
  00074	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN23@dfp_number:
  0007c	8b 44 24 38	 mov	 eax, DWORD PTR tv69[rsp]
  00080	89 44 24 40	 mov	 DWORD PTR ignoreflag$[rsp], eax

; 1482 : 
; 1483 :     /* Set the sign according to the operand sign code */
; 1484 :     if (signflag) {

  00084	83 7c 24 3c 00	 cmp	 DWORD PTR signflag$[rsp], 0
  00089	74 6f		 je	 SHORT $LN7@dfp_number

; 1485 :         if (!ignoreflag) {

  0008b	83 7c 24 40 00	 cmp	 DWORD PTR ignoreflag$[rsp], 0
  00090	75 68		 jne	 SHORT $LN8@dfp_number

; 1486 :             switch ((packed[len] & 0x0F)) {

  00092	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  0009a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR packed$[rsp]
  000a2	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000a6	83 e0 0f	 and	 eax, 15
  000a9	89 44 24 30	 mov	 DWORD PTR tv77[rsp], eax
  000ad	8b 44 24 30	 mov	 eax, DWORD PTR tv77[rsp]
  000b1	83 e8 0a	 sub	 eax, 10
  000b4	89 44 24 30	 mov	 DWORD PTR tv77[rsp], eax
  000b8	83 7c 24 30 05	 cmp	 DWORD PTR tv77[rsp], 5
  000bd	77 31		 ja	 SHORT $LN15@dfp_number
  000bf	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv77[rsp]
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000cb	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN24@dfp_number[rcx+rax*4]
  000d2	48 03 c1	 add	 rax, rcx
  000d5	ff e0		 jmp	 rax
$LN9@dfp_number:
$LN10@dfp_number:

; 1487 :             case 0xB: case 0xD:
; 1488 :                 *ppw++ = '-'; break;

  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR ppw$[rsp]
  000dc	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH
  000df	48 8b 44 24 28	 mov	 rax, QWORD PTR ppw$[rsp]
  000e4	48 ff c0	 inc	 rax
  000e7	48 89 44 24 28	 mov	 QWORD PTR ppw$[rsp], rax
  000ec	eb 0c		 jmp	 SHORT $LN2@dfp_number
$LN11@dfp_number:
$LN12@dfp_number:
$LN13@dfp_number:
$LN14@dfp_number:

; 1489 :             case 0xA: case 0xC: case 0xE: case 0xF:
; 1490 :                 break;

  000ee	eb 0a		 jmp	 SHORT $LN2@dfp_number
$LN15@dfp_number:

; 1491 :             default:
; 1492 :                 /* Data exception if invalid sign code */
; 1493 :                 return 1;

  000f0	b8 01 00 00 00	 mov	 eax, 1
  000f5	e9 f6 00 00 00	 jmp	 $LN1@dfp_number
$LN2@dfp_number:
$LN8@dfp_number:
$LN7@dfp_number:

; 1494 :             }
; 1495 :         }
; 1496 :     }
; 1497 : 
; 1498 :     /* Convert packed number to a decimal string */
; 1499 :     for (i = 0; i <= len; i++)

  000fa	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00102	eb 0a		 jmp	 SHORT $LN6@dfp_number
$LN4@dfp_number:
  00104	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00108	ff c0		 inc	 eax
  0010a	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN6@dfp_number:
  0010e	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00115	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00119	0f 8f ad 00 00
	00		 jg	 $LN5@dfp_number

; 1500 :     {
; 1501 :         /* 1st digit of byte */
; 1502 :         c = (packed[i] & 0xF0) >> 4;

  0011f	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00124	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR packed$[rsp]
  0012c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00130	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00135	c1 f8 04	 sar	 eax, 4
  00138	88 44 24 20	 mov	 BYTE PTR c$[rsp], al

; 1503 :         /* Data exception if invalid digit */
; 1504 :         if (c > 0x09) return 1;

  0013c	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00141	83 f8 09	 cmp	 eax, 9
  00144	7e 0a		 jle	 SHORT $LN16@dfp_number
  00146	b8 01 00 00 00	 mov	 eax, 1
  0014b	e9 a0 00 00 00	 jmp	 $LN1@dfp_number
$LN16@dfp_number:

; 1505 :         *ppw++ = c + '0';

  00150	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00155	83 c0 30	 add	 eax, 48			; 00000030H
  00158	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ppw$[rsp]
  0015d	88 01		 mov	 BYTE PTR [rcx], al
  0015f	48 8b 44 24 28	 mov	 rax, QWORD PTR ppw$[rsp]
  00164	48 ff c0	 inc	 rax
  00167	48 89 44 24 28	 mov	 QWORD PTR ppw$[rsp], rax

; 1506 : 
; 1507 :         if (i == len && signflag) break;   /* is last nibble a sign, already done */

  0016c	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00173	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00177	75 09		 jne	 SHORT $LN17@dfp_number
  00179	83 7c 24 3c 00	 cmp	 DWORD PTR signflag$[rsp], 0
  0017e	74 02		 je	 SHORT $LN17@dfp_number
  00180	eb 4a		 jmp	 SHORT $LN5@dfp_number
$LN17@dfp_number:

; 1508 : 
; 1509 :         /* 2nd digit of byte */
; 1510 :         c = packed[i] & 0x0F;

  00182	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00187	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR packed$[rsp]
  0018f	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00193	83 e0 0f	 and	 eax, 15
  00196	88 44 24 20	 mov	 BYTE PTR c$[rsp], al

; 1511 :         /* Data exception if invalid digit */
; 1512 :         if (c > 0x09) return 1;

  0019a	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0019f	83 f8 09	 cmp	 eax, 9
  001a2	7e 07		 jle	 SHORT $LN18@dfp_number
  001a4	b8 01 00 00 00	 mov	 eax, 1
  001a9	eb 45		 jmp	 SHORT $LN1@dfp_number
$LN18@dfp_number:

; 1513 :         *ppw++ = c + '0';

  001ab	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  001b0	83 c0 30	 add	 eax, 48			; 00000030H
  001b3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ppw$[rsp]
  001b8	88 01		 mov	 BYTE PTR [rcx], al
  001ba	48 8b 44 24 28	 mov	 rax, QWORD PTR ppw$[rsp]
  001bf	48 ff c0	 inc	 rax
  001c2	48 89 44 24 28	 mov	 QWORD PTR ppw$[rsp], rax

; 1514 :     }

  001c7	e9 38 ff ff ff	 jmp	 $LN4@dfp_number
$LN5@dfp_number:

; 1515 :     *ppw = '\0';

  001cc	48 8b 44 24 28	 mov	 rax, QWORD PTR ppw$[rsp]
  001d1	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1516 : 
; 1517 :     /* Convert decimal string to decimal number structure */
; 1518 :     decNumberFromString(dn, pwork, pset);

  001d4	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR pset$[rsp]
  001dc	48 8d 54 24 48	 lea	 rdx, QWORD PTR pwork$[rsp]
  001e1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  001e9	e8 00 00 00 00	 call	 decNumberFromString

; 1519 : 
; 1520 :     return 0;

  001ee	33 c0		 xor	 eax, eax
$LN1@dfp_number:

; 1521 : 
; 1522 : } /* end function dfp_number_from_packed */

  001f0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001f5	48 33 cc	 xor	 rcx, rsp
  001f8	e8 00 00 00 00	 call	 __security_check_cookie
  001fd	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00204	c3		 ret	 0
  00205	0f 1f 00	 npad	 3
$LN24@dfp_number:
  00208	00 00 00 00	 DD	 $LN11@dfp_number
  0020c	00 00 00 00	 DD	 $LN9@dfp_number
  00210	00 00 00 00	 DD	 $LN12@dfp_number
  00214	00 00 00 00	 DD	 $LN10@dfp_number
  00218	00 00 00 00	 DD	 $LN13@dfp_number
  0021c	00 00 00 00	 DD	 $LN14@dfp_number
dfp_number_from_packed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
pad$ = 36
zwind$ = 40
zwlen$ = 44
cc$ = 48
tv69 = 52
tv146 = 56
tv147 = 60
tv177 = 64
tv186 = 68
sign$ = 72
tv212 = 76
tv214 = 80
zwork$ = 96
__$ArrayPad$ = 208
dn$ = 240
dc$ = 248
zoned$ = 256
len$ = 264
mask$ = 272
pset$ = 280
dfp_number_to_zoned PROC

; 1364 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@dfp_number:

; 1365 : int             i;                      /* Array subscript           */
; 1366 : int             pad;                    /* Number of padding bytes   */
; 1367 : int             cc;                     /* Condition code            */
; 1368 : int             sign;                   /* 1=negative number         */
; 1369 : char            zwork[MAXDECSTRLEN+64]; /* Decimal string work area  */
; 1370 : int             zwlen;                  /* Length of zwork string    */
; 1371 : int             zwind;                  /* Index into zwork string   */
; 1372 : 
; 1373 :     UNREFERENCED(pset);

  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 fa		 jne	 SHORT $LN4@dfp_number

; 1374 : 
; 1375 :     /* Determine if the number is negative or positive */
; 1376 :     sign = (decNumberIsNegative(dn)) ? 1 : 0;

  00033	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  0003b	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  0003f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00044	85 c0		 test	 eax, eax
  00046	74 0a		 je	 SHORT $LN17@dfp_number
  00048	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
  00050	eb 08		 jmp	 SHORT $LN18@dfp_number
$LN17@dfp_number:
  00052	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN18@dfp_number:
  0005a	8b 44 24 34	 mov	 eax, DWORD PTR tv69[rsp]
  0005e	89 44 24 48	 mov	 DWORD PTR sign$[rsp], eax

; 1377 : 
; 1378 :     /* Force plus zero if mask bit 3 is set */
; 1379 :     if ((mask & 0x1) && decNumberIsZero(dn)) sign = 0;

  00062	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR mask$[rsp]
  00069	83 e0 01	 and	 eax, 1
  0006c	85 c0		 test	 eax, eax
  0006e	74 42		 je	 SHORT $LN8@dfp_number
  00070	b8 02 00 00 00	 mov	 eax, 2
  00075	48 6b c0 00	 imul	 rax, rax, 0
  00079	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  00081	0f b7 44 01 0a	 movzx	 eax, WORD PTR [rcx+rax+10]
  00086	85 c0		 test	 eax, eax
  00088	75 28		 jne	 SHORT $LN8@dfp_number
  0008a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  00092	83 38 01	 cmp	 DWORD PTR [rax], 1
  00095	75 1b		 jne	 SHORT $LN8@dfp_number
  00097	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  0009f	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  000a3	83 e0 70	 and	 eax, 112		; 00000070H
  000a6	85 c0		 test	 eax, eax
  000a8	75 08		 jne	 SHORT $LN8@dfp_number
  000aa	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR sign$[rsp], 0
$LN8@dfp_number:

; 1380 : 
; 1381 :     /* Convert decimal number to string */
; 1382 :     if (decNumberIsNaN(dn) || (decNumberIsInfinite(dn)))

  000b2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  000ba	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  000be	83 e0 30	 and	 eax, 48			; 00000030H
  000c1	85 c0		 test	 eax, eax
  000c3	75 13		 jne	 SHORT $LN11@dfp_number
  000c5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  000cd	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  000d1	83 e0 40	 and	 eax, 64			; 00000040H
  000d4	85 c0		 test	 eax, eax
  000d6	74 49		 je	 SHORT $LN9@dfp_number
$LN11@dfp_number:

; 1383 :     {
; 1384 :         /* For NaN or Inf set cc=3 and use coefficient only */
; 1385 :         cc = 3;

  000d8	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3

; 1386 :         dc->exponent = 0;

  000e0	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR dc$[rsp]
  000e8	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 1387 :         dc->bits &= ~(DECNEG);

  000ef	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR dc$[rsp]
  000f7	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  000fb	0f ba f0 07	 btr	 eax, 7
  000ff	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR dc$[rsp]
  00107	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 1388 :         decNumberToString(dc, zwork);

  0010a	48 8d 54 24 60	 lea	 rdx, QWORD PTR zwork$[rsp]
  0010f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR dc$[rsp]
  00117	e8 00 00 00 00	 call	 decNumberToString

; 1389 :     } else {

  0011c	e9 b7 00 00 00	 jmp	 $LN10@dfp_number
$LN9@dfp_number:

; 1390 :         /* For finite numbers set cc=0, 1, or 2 and convert digits */
; 1391 :         cc = (decNumberIsZero(dn)) ? 0 :

  00121	b8 02 00 00 00	 mov	 eax, 2
  00126	48 6b c0 00	 imul	 rax, rax, 0
  0012a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  00132	0f b7 44 01 0a	 movzx	 eax, WORD PTR [rcx+rax+10]
  00137	85 c0		 test	 eax, eax
  00139	75 2a		 jne	 SHORT $LN19@dfp_number
  0013b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  00143	83 38 01	 cmp	 DWORD PTR [rax], 1
  00146	75 1d		 jne	 SHORT $LN19@dfp_number
  00148	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  00150	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00154	83 e0 70	 and	 eax, 112		; 00000070H
  00157	85 c0		 test	 eax, eax
  00159	75 0a		 jne	 SHORT $LN19@dfp_number
  0015b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
  00163	eb 2f		 jmp	 SHORT $LN22@dfp_number
$LN19@dfp_number:
  00165	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  0016d	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00171	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00176	85 c0		 test	 eax, eax
  00178	74 0a		 je	 SHORT $LN20@dfp_number
  0017a	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv146[rsp], 1
  00182	eb 08		 jmp	 SHORT $LN21@dfp_number
$LN20@dfp_number:
  00184	c7 44 24 38 02
	00 00 00	 mov	 DWORD PTR tv146[rsp], 2
$LN21@dfp_number:
  0018c	8b 44 24 38	 mov	 eax, DWORD PTR tv146[rsp]
  00190	89 44 24 3c	 mov	 DWORD PTR tv147[rsp], eax
$LN22@dfp_number:
  00194	8b 44 24 3c	 mov	 eax, DWORD PTR tv147[rsp]
  00198	89 44 24 30	 mov	 DWORD PTR cc$[rsp], eax

; 1392 :             (decNumberIsNegative(dn)) ? 1 : 2;
; 1393 :         dn->exponent = 0;

  0019c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  001a4	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 1394 :         dn->bits &= ~(DECNEG);

  001ab	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  001b3	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  001b7	0f ba f0 07	 btr	 eax, 7
  001bb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  001c3	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 1395 :         decNumberToString(dn, zwork);

  001c6	48 8d 54 24 60	 lea	 rdx, QWORD PTR zwork$[rsp]
  001cb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  001d3	e8 00 00 00 00	 call	 decNumberToString
$LN10@dfp_number:

; 1396 :     }
; 1397 : 
; 1398 :     /* Calculate the number of padding bytes needed, and set
; 1399 :        condition code 3 if significant digits will be lost */
; 1400 :     zwlen = (int)(strlen(zwork));

  001d8	48 8d 4c 24 60	 lea	 rcx, QWORD PTR zwork$[rsp]
  001dd	e8 00 00 00 00	 call	 strlen
  001e2	89 44 24 2c	 mov	 DWORD PTR zwlen$[rsp], eax

; 1401 :     if (zwlen <= len + 1)

  001e6	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001ed	ff c0		 inc	 eax
  001ef	39 44 24 2c	 cmp	 DWORD PTR zwlen$[rsp], eax
  001f3	7f 1b		 jg	 SHORT $LN12@dfp_number

; 1402 :     {
; 1403 :         zwind = 0;

  001f5	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR zwind$[rsp], 0

; 1404 :         pad = len + 1 - zwlen;

  001fd	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00204	ff c0		 inc	 eax
  00206	2b 44 24 2c	 sub	 eax, DWORD PTR zwlen$[rsp]
  0020a	89 44 24 24	 mov	 DWORD PTR pad$[rsp], eax

; 1405 :     } else {

  0020e	eb 25		 jmp	 SHORT $LN13@dfp_number
$LN12@dfp_number:

; 1406 :         zwind = zwlen - len - 1;

  00210	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00217	8b 4c 24 2c	 mov	 ecx, DWORD PTR zwlen$[rsp]
  0021b	2b c8		 sub	 ecx, eax
  0021d	8b c1		 mov	 eax, ecx
  0021f	ff c8		 dec	 eax
  00221	89 44 24 28	 mov	 DWORD PTR zwind$[rsp], eax

; 1407 :         pad = 0;

  00225	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR pad$[rsp], 0

; 1408 :         cc = 3;

  0022d	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3
$LN13@dfp_number:

; 1409 :     }
; 1410 : 
; 1411 :     /* Copy digits to zoned decimal result area */
; 1412 :     for (i = 0; i <= len; i++)

  00235	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0023d	eb 0a		 jmp	 SHORT $LN7@dfp_number
$LN5@dfp_number:
  0023f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00243	ff c0		 inc	 eax
  00245	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@dfp_number:
  00249	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00250	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00254	0f 8f 9c 00 00
	00		 jg	 $LN6@dfp_number

; 1413 :     {
; 1414 :         /* Pad with zero or copy digit from work string */
; 1415 :         zoned[i] = (pad > 0) ? 0x00 : zwork[zwind++] - '0';

  0025a	83 7c 24 24 00	 cmp	 DWORD PTR pad$[rsp], 0
  0025f	7e 0a		 jle	 SHORT $LN23@dfp_number
  00261	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv177[rsp], 0
  00269	eb 1b		 jmp	 SHORT $LN24@dfp_number
$LN23@dfp_number:
  0026b	48 63 44 24 28	 movsxd	 rax, DWORD PTR zwind$[rsp]
  00270	0f be 44 04 60	 movsx	 eax, BYTE PTR zwork$[rsp+rax]
  00275	83 e8 30	 sub	 eax, 48			; 00000030H
  00278	89 44 24 40	 mov	 DWORD PTR tv177[rsp], eax
  0027c	8b 44 24 28	 mov	 eax, DWORD PTR zwind$[rsp]
  00280	ff c0		 inc	 eax
  00282	89 44 24 28	 mov	 DWORD PTR zwind$[rsp], eax
$LN24@dfp_number:
  00286	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0028b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR zoned$[rsp]
  00293	0f b6 54 24 40	 movzx	 edx, BYTE PTR tv177[rsp]
  00298	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1416 :         if (pad > 0) pad--;

  0029b	83 7c 24 24 00	 cmp	 DWORD PTR pad$[rsp], 0
  002a0	7e 0a		 jle	 SHORT $LN14@dfp_number
  002a2	8b 44 24 24	 mov	 eax, DWORD PTR pad$[rsp]
  002a6	ff c8		 dec	 eax
  002a8	89 44 24 24	 mov	 DWORD PTR pad$[rsp], eax
$LN14@dfp_number:

; 1417 :         /* Set ASCII or EBCDIC zone according to mask bit 1 */
; 1418 :         zoned[i] |= (mask & 0x4) ? 0x30 : 0xF0;

  002ac	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR mask$[rsp]
  002b3	83 e0 04	 and	 eax, 4
  002b6	85 c0		 test	 eax, eax
  002b8	74 0a		 je	 SHORT $LN25@dfp_number
  002ba	c7 44 24 44 30
	00 00 00	 mov	 DWORD PTR tv186[rsp], 48 ; 00000030H
  002c2	eb 08		 jmp	 SHORT $LN26@dfp_number
$LN25@dfp_number:
  002c4	c7 44 24 44 f0
	00 00 00	 mov	 DWORD PTR tv186[rsp], 240 ; 000000f0H
$LN26@dfp_number:
  002cc	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002d1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR zoned$[rsp]
  002d9	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  002dd	0b 44 24 44	 or	 eax, DWORD PTR tv186[rsp]
  002e1	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  002e6	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR zoned$[rsp]
  002ee	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1419 :     }

  002f1	e9 49 ff ff ff	 jmp	 $LN5@dfp_number
$LN6@dfp_number:

; 1420 : 
; 1421 :     /* Replace final zone by EBCDIC sign if mask bit 0 is one */
; 1422 :     if (mask & 0x8)

  002f6	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR mask$[rsp]
  002fd	83 e0 08	 and	 eax, 8
  00300	85 c0		 test	 eax, eax
  00302	0f 84 90 00 00
	00		 je	 $LN15@dfp_number

; 1423 :     {
; 1424 :         /* -ve sign is D, +ve sign is F or C depending on mask bit 2 */
; 1425 :         zoned[i-1] &= 0x0F;

  00308	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0030c	ff c8		 dec	 eax
  0030e	48 98		 cdqe
  00310	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR zoned$[rsp]
  00318	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0031c	83 e0 0f	 and	 eax, 15
  0031f	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00323	ff c9		 dec	 ecx
  00325	48 63 c9	 movsxd	 rcx, ecx
  00328	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR zoned$[rsp]
  00330	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1426 :         zoned[i-1] |= (sign) ? 0xD0 : (mask & 0x2) ? 0xF0 : 0xC0;

  00333	83 7c 24 48 00	 cmp	 DWORD PTR sign$[rsp], 0
  00338	74 0a		 je	 SHORT $LN29@dfp_number
  0033a	c7 44 24 50 d0
	00 00 00	 mov	 DWORD PTR tv214[rsp], 208 ; 000000d0H
  00342	eb 28		 jmp	 SHORT $LN30@dfp_number
$LN29@dfp_number:
  00344	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR mask$[rsp]
  0034b	83 e0 02	 and	 eax, 2
  0034e	85 c0		 test	 eax, eax
  00350	74 0a		 je	 SHORT $LN27@dfp_number
  00352	c7 44 24 4c f0
	00 00 00	 mov	 DWORD PTR tv212[rsp], 240 ; 000000f0H
  0035a	eb 08		 jmp	 SHORT $LN28@dfp_number
$LN27@dfp_number:
  0035c	c7 44 24 4c c0
	00 00 00	 mov	 DWORD PTR tv212[rsp], 192 ; 000000c0H
$LN28@dfp_number:
  00364	8b 44 24 4c	 mov	 eax, DWORD PTR tv212[rsp]
  00368	89 44 24 50	 mov	 DWORD PTR tv214[rsp], eax
$LN30@dfp_number:
  0036c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00370	ff c8		 dec	 eax
  00372	48 98		 cdqe
  00374	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR zoned$[rsp]
  0037c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00380	0b 44 24 50	 or	 eax, DWORD PTR tv214[rsp]
  00384	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00388	ff c9		 dec	 ecx
  0038a	48 63 c9	 movsxd	 rcx, ecx
  0038d	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR zoned$[rsp]
  00395	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN15@dfp_number:

; 1427 :     }
; 1428 : 
; 1429 :     /* Return the condition code */
; 1430 :     return cc;

  00398	8b 44 24 30	 mov	 eax, DWORD PTR cc$[rsp]

; 1431 : 
; 1432 : } /* end function dfp_number_to_zoned */

  0039c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003a4	48 33 cc	 xor	 rcx, rsp
  003a7	e8 00 00 00 00	 call	 __security_check_cookie
  003ac	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  003b3	c3		 ret	 0
dfp_number_to_zoned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
c$ = 32
tv74 = 36
i$ = 40
pzw$ = 48
tv66 = 56
signflag$ = 60
zwork$ = 64
__$ArrayPad$ = 104
dn$ = 128
zoned$ = 136
len$ = 144
mask$ = 152
pset$ = 160
dfp_number_from_zoned PROC

; 1298 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1299 : int             i;                      /* Array subscript           */
; 1300 : int             signflag;               /* 1=signed decimal operand  */
; 1301 : char            zwork[1+CXZT_MAXLEN+1]; /* Sign + digits + null      */
; 1302 : char            *pzw = zwork;           /* Addr next byte in zwork   */

  00027	48 8d 44 24 40	 lea	 rax, QWORD PTR zwork$[rsp]
  0002c	48 89 44 24 30	 mov	 QWORD PTR pzw$[rsp], rax

; 1303 : char            c;                      /* Character work area       */
; 1304 : 
; 1305 :     /* Set the signed flag if indicated by the mask */
; 1306 :     signflag = (mask & 0x8) ? 1 : 0;

  00031	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR mask$[rsp]
  00038	83 e0 08	 and	 eax, 8
  0003b	85 c0		 test	 eax, eax
  0003d	74 0a		 je	 SHORT $LN17@dfp_number
  0003f	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00047	eb 08		 jmp	 SHORT $LN18@dfp_number
$LN17@dfp_number:
  00049	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN18@dfp_number:
  00051	8b 44 24 38	 mov	 eax, DWORD PTR tv66[rsp]
  00055	89 44 24 3c	 mov	 DWORD PTR signflag$[rsp], eax

; 1307 : 
; 1308 :     /* Set the sign according to the operand sign code */
; 1309 :     if (signflag) {

  00059	83 7c 24 3c 00	 cmp	 DWORD PTR signflag$[rsp], 0
  0005e	74 6d		 je	 SHORT $LN7@dfp_number

; 1310 :         switch ((zoned[len] & 0xF0) >> 4) {

  00060	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00068	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR zoned$[rsp]
  00070	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00074	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00079	c1 f8 04	 sar	 eax, 4
  0007c	89 44 24 24	 mov	 DWORD PTR tv74[rsp], eax
  00080	8b 44 24 24	 mov	 eax, DWORD PTR tv74[rsp]
  00084	83 e8 0a	 sub	 eax, 10
  00087	89 44 24 24	 mov	 DWORD PTR tv74[rsp], eax
  0008b	83 7c 24 24 05	 cmp	 DWORD PTR tv74[rsp], 5
  00090	77 31		 ja	 SHORT $LN14@dfp_number
  00092	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv74[rsp]
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0009e	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN19@dfp_number[rcx+rax*4]
  000a5	48 03 c1	 add	 rax, rcx
  000a8	ff e0		 jmp	 rax
$LN8@dfp_number:
$LN9@dfp_number:

; 1311 :         case 0xB: case 0xD:
; 1312 :             *pzw++ = '-'; break;

  000aa	48 8b 44 24 30	 mov	 rax, QWORD PTR pzw$[rsp]
  000af	c6 00 2d	 mov	 BYTE PTR [rax], 45	; 0000002dH
  000b2	48 8b 44 24 30	 mov	 rax, QWORD PTR pzw$[rsp]
  000b7	48 ff c0	 inc	 rax
  000ba	48 89 44 24 30	 mov	 QWORD PTR pzw$[rsp], rax
  000bf	eb 0c		 jmp	 SHORT $LN2@dfp_number
$LN10@dfp_number:
$LN11@dfp_number:
$LN12@dfp_number:
$LN13@dfp_number:

; 1313 :         case 0xA: case 0xC: case 0xE: case 0xF:
; 1314 :             break;

  000c1	eb 0a		 jmp	 SHORT $LN2@dfp_number
$LN14@dfp_number:

; 1315 :         default:
; 1316 :             /* Data exception if invalid sign code */
; 1317 :             return 1;

  000c3	b8 01 00 00 00	 mov	 eax, 1
  000c8	e9 8c 00 00 00	 jmp	 $LN1@dfp_number
$LN2@dfp_number:
$LN7@dfp_number:

; 1318 :         }
; 1319 :     }
; 1320 : 
; 1321 :     /* Convert zoned number to a decimal string */
; 1322 :     for (i=0; i <= len; i++)

  000cd	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000d5	eb 0a		 jmp	 SHORT $LN6@dfp_number
$LN4@dfp_number:
  000d7	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000db	ff c0		 inc	 eax
  000dd	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN6@dfp_number:
  000e1	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  000e8	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  000ec	7f 47		 jg	 SHORT $LN5@dfp_number

; 1323 :     {
; 1324 :         c = zoned[i] & 0x0F;

  000ee	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  000f3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR zoned$[rsp]
  000fb	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000ff	83 e0 0f	 and	 eax, 15
  00102	88 44 24 20	 mov	 BYTE PTR c$[rsp], al

; 1325 :         /* Data exception if invalid digit */
; 1326 :         if (c > 0x09) return 1;

  00106	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0010b	83 f8 09	 cmp	 eax, 9
  0010e	7e 07		 jle	 SHORT $LN15@dfp_number
  00110	b8 01 00 00 00	 mov	 eax, 1
  00115	eb 42		 jmp	 SHORT $LN1@dfp_number
$LN15@dfp_number:

; 1327 :         *pzw++ = c + '0';

  00117	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0011c	83 c0 30	 add	 eax, 48			; 00000030H
  0011f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pzw$[rsp]
  00124	88 01		 mov	 BYTE PTR [rcx], al
  00126	48 8b 44 24 30	 mov	 rax, QWORD PTR pzw$[rsp]
  0012b	48 ff c0	 inc	 rax
  0012e	48 89 44 24 30	 mov	 QWORD PTR pzw$[rsp], rax

; 1328 :     }

  00133	eb a2		 jmp	 SHORT $LN4@dfp_number
$LN5@dfp_number:

; 1329 :     *pzw = '\0';

  00135	48 8b 44 24 30	 mov	 rax, QWORD PTR pzw$[rsp]
  0013a	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1330 : 
; 1331 :     /* Convert decimal string to decimal number structure */
; 1332 :     decNumberFromString(dn, zwork, pset);

  0013d	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR pset$[rsp]
  00145	48 8d 54 24 40	 lea	 rdx, QWORD PTR zwork$[rsp]
  0014a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  00152	e8 00 00 00 00	 call	 decNumberFromString

; 1333 : 
; 1334 :     return 0;

  00157	33 c0		 xor	 eax, eax
$LN1@dfp_number:

; 1335 : 
; 1336 : } /* end function dfp_number_from_zoned */

  00159	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0015e	48 33 cc	 xor	 rcx, rsp
  00161	e8 00 00 00 00	 call	 __security_check_cookie
  00166	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0016a	c3		 ret	 0
  0016b	90		 npad	 1
$LN19@dfp_number:
  0016c	00 00 00 00	 DD	 $LN10@dfp_number
  00170	00 00 00 00	 DD	 $LN8@dfp_number
  00174	00 00 00 00	 DD	 $LN11@dfp_number
  00178	00 00 00 00	 DD	 $LN9@dfp_number
  0017c	00 00 00 00	 DD	 $LN12@dfp_number
  00180	00 00 00 00	 DD	 $LN13@dfp_number
dfp_number_from_zoned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 83 e0 03	 and	 rax, 3
  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0a		 jne	 SHORT $LN5@z900_vfetc
  00020	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN6@z900_vfetc
$LN5@z900_vfetc:
  0002a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@z900_vfetc:
  00032	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00037	74 0a		 je	 SHORT $LN9@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN10@z900_vfetc
$LN9@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00050	75 13		 jne	 SHORT $LN3@z900_vfetc
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00057	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0005d	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00063	77 46		 ja	 SHORT $LN2@z900_vfetc
$LN3@z900_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006e	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00072	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 04 00 00 00	 mov	 edx, 4
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  0009d	e8 00 00 00 00	 call	 fetch_fw_noswap
  000a2	8b c8		 mov	 ecx, eax
  000a4	e8 00 00 00 00	 call	 _byteswap_ulong
  000a9	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000ab	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000b0	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  000b9	e8 00 00 00 00	 call	 z900_vfetch4_full
$LN1@z900_vfetc:

; 705  : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002c	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00031	2b d1		 sub	 edx, ecx
  00033	8b ca		 mov	 ecx, edx
  00035	3b c1		 cmp	 eax, ecx
  00037	7f 0a		 jg	 SHORT $LN7@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN8@z900_vfetc
$LN7@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00050	74 63		 je	 SHORT $LN2@z900_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00052	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 98		 cdqe
  0005b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00098	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	48 98		 cdqe
  000a1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a6	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	f3 a4		 rep movsb

; 640  :     }

  000b0	e9 01 01 00 00	 jmp	 $LN3@z900_vfetc
$LN2@z900_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000bd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000c3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c8	48 2b c8	 sub	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000e3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000ef	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f7	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0010a	e8 00 00 00 00	 call	 z900_maddr_l
  0010f	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00114	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00119	ff c0		 inc	 eax
  0011b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0011f	48 98		 cdqe
  00121	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00126	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  0012e	48 03 d1	 add	 rdx, rcx
  00131	48 8b ca	 mov	 rcx, rdx
  00134	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00143	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0014b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0014f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00153	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0015b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00163	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0016b	48 8b d0	 mov	 rdx, rax
  0016e	e8 00 00 00 00	 call	 z900_maddr_l
  00173	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  00178	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0017d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00182	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  00187	48 8b c8	 mov	 rcx, rax
  0018a	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0018c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00191	ff c0		 inc	 eax
  00193	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00197	48 98		 cdqe
  00199	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0019e	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001a3	48 03 d1	 add	 rdx, rcx
  001a6	48 8b ca	 mov	 rcx, rdx
  001a9	48 8b f9	 mov	 rdi, rcx
  001ac	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	f3 a4		 rep movsb
$LN3@z900_vfetc:

; 649  :     }
; 650  : }

  001b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	c3		 ret	 0
z900_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
z900_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR addr$[rsp]
  00028	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0002e	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00033	48 2b c8	 sub	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003d	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00042	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00052	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00062	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00067	48 8b d0	 mov	 rdx, rax
  0006a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR addr$[rsp]
  0006f	e8 00 00 00 00	 call	 z900_maddr_l
  00074	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00079	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0007e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00083	48 8b f9	 mov	 rdi, rcx
  00086	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  00090	b8 04 00 00 00	 mov	 eax, 4
  00095	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00099	48 98		 cdqe
  0009b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a0	48 8b 54 24 70	 mov	 rdx, QWORD PTR addr$[rsp]
  000a5	48 03 d1	 add	 rdx, rcx
  000a8	48 8b ca	 mov	 rcx, rdx
  000ab	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b3	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000ba	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c6	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ca	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d2	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000da	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000df	48 8b d0	 mov	 rdx, rax
  000e2	e8 00 00 00 00	 call	 z900_maddr_l
  000e7	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000ec	b8 04 00 00 00	 mov	 eax, 4
  000f1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000f5	48 98		 cdqe
  000f7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000fc	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00101	48 8b f9	 mov	 rdi, rcx
  00104	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00109	48 8b c8	 mov	 rcx, rax
  0010c	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  0010e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00113	e8 00 00 00 00	 call	 fetch_fw_noswap
  00118	8b c8		 mov	 ecx, eax
  0011a	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0011f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_FPC_check
_TEXT	SEGMENT
regs$ = 48
fpc$ = 56
z900_FPC_check PROC					; COMDAT

; 788  : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 789  :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0000d	b8 01 00 00 00	 mov	 eax, 1
  00012	48 6b c0 04	 imul	 rax, rax, 4
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00023	83 e0 04	 and	 eax, 4
  00026	85 c0		 test	 eax, eax
  00028	74 4e		 je	 SHORT $LN2@z900_FPC_c

; 790  :     {
; 791  :         if (0
; 792  :             || (fpc & FPC_RESV_FPX)
; 793  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV4
; 794  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV5
; 795  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV6

  0002a	33 c0		 xor	 eax, eax
  0002c	85 c0		 test	 eax, eax
  0002e	75 31		 jne	 SHORT $LN5@z900_FPC_c
  00030	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00034	25 88 00 03 03	 and	 eax, 50528392		; 03030088H
  00039	85 c0		 test	 eax, eax
  0003b	75 24		 jne	 SHORT $LN5@z900_FPC_c
  0003d	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00041	83 e0 07	 and	 eax, 7
  00044	83 f8 04	 cmp	 eax, 4
  00047	74 18		 je	 SHORT $LN5@z900_FPC_c
  00049	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  0004d	83 e0 07	 and	 eax, 7
  00050	83 f8 05	 cmp	 eax, 5
  00053	74 0c		 je	 SHORT $LN5@z900_FPC_c
  00055	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00059	83 e0 07	 and	 eax, 7
  0005c	83 f8 06	 cmp	 eax, 6
  0005f	75 15		 jne	 SHORT $LN4@z900_FPC_c
$LN5@z900_FPC_c:

; 796  :         )
; 797  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00061	ba 06 00 00 00	 mov	 edx, 6
  00066	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00070	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN4@z900_FPC_c:

; 798  :     }

  00076	eb 22		 jmp	 SHORT $LN3@z900_FPC_c
$LN2@z900_FPC_c:

; 799  :     else
; 800  :     {
; 801  :         if (fpc & FPC_RESERVED)

  00078	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  0007c	25 8c 00 07 07	 and	 eax, 117899404		; 0707008cH
  00081	85 c0		 test	 eax, eax
  00083	74 15		 je	 SHORT $LN6@z900_FPC_c

; 802  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00085	ba 06 00 00 00	 mov	 edx, 6
  0008a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00094	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_FPC_c:
$LN3@z900_FPC_c:

; 803  :     }
; 804  : }

  0009a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009e	c3		 ret	 0
z900_FPC_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck
_TEXT	SEGMENT
tv79 = 32
regs$ = 64
b1$ = 72
z900_per3_zero_xcheck PROC				; COMDAT

; 754  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 755  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 756  :     if (b1 && GR_A( b1, regs ) == 0)

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  00012	74 53		 je	 SHORT $LN2@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 19		 je	 SHORT $LN4@z900_per3_
  00026	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00030	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00038	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  0003d	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  0003f	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00050	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN5@z900_per3_:
  00055	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  0005b	75 0a		 jne	 SHORT $LN2@z900_per3_

; 757  :         ARCH_DEP( per3_zero )( regs );

  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 758  : #else
; 759  :     UNREFERENCED( regs );
; 760  :     UNREFERENCED( b1 );
; 761  : #endif
; 762  : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
z900_per3_zero_xcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 48
b2$ = 52
l2$ = 56
effective_addr2$ = 64
r1$ = 72
m3$ = 76
cc$ = 80
x1$ = 88
dwork$ = 96
set$ = 136
dcoeff$ = 168
packed$ = 208
__$ArrayPad$ = 224
inst$ = 256
regs$ = 264
z900_convert_dfp_long_to_packed PROC

; 3819 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3820 :     int             r1, m3;                 /* Values of R and M fields  */
; 3821 :     int             l2;                     /* Operand length minus 1    */
; 3822 :     int             b2;                     /* Base of effective addr    */
; 3823 :     VADR            effective_addr2;        /* Effective address         */
; 3824 :     decimal64       x1;                     /* Long DFP value            */
; 3825 :     decNumber       dwork, dcoeff;          /* Working decimal numbers   */
; 3826 :     decContext      set;                    /* Working context           */
; 3827 :     int             cc;                     /* Condition code            */
; 3828 :     char            packed[CPDT_MAXLEN];    /* Packed decimal result     */
; 3829 : 
; 3830 :     RSL_RM(inst, regs, r1, l2, b2, effective_addr2, m3);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 01	 imul	 rax, rax, 1
  0002c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	48 03 c8	 add	 rcx, rax
  00037	48 8b c1	 mov	 rax, rcx
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00042	8b c8		 mov	 ecx, eax
  00044	e8 00 00 00 00	 call	 _byteswap_ulong
  00049	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 4c	 mov	 DWORD PTR m3$[rsp], eax
  00058	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 04	 shr	 eax, 4
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
  00066	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0006a	c1 e8 08	 shr	 eax, 8
  0006d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00072	8b c0		 mov	 eax, eax
  00074	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00079	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0007d	c1 e8 14	 shr	 eax, 20
  00080	83 e0 0f	 and	 eax, 15
  00083	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00087	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 18	 shr	 eax, 24
  0008e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00093	89 44 24 38	 mov	 DWORD PTR l2$[rsp], eax
  00097	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009c	74 44		 je	 SHORT $LN8@z900_conve
  0009e	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000b8	48 03 c8	 add	 rcx, rax
  000bb	48 8b c1	 mov	 rax, rcx
  000be	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000c3	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d7	48 23 c8	 and	 rcx, rax
  000da	48 8b c1	 mov	 rax, rcx
  000dd	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_conve:
$LN4@z900_conve:
  000e2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ea	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ee	48 83 c0 06	 add	 rax, 6
  000f2	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000fe	33 c0		 xor	 eax, eax
  00100	83 f8 06	 cmp	 eax, 6
  00103	74 0f		 je	 SHORT $LN9@z900_conve
  00105	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010d	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_conve:
  00114	33 c0		 xor	 eax, eax
  00116	85 c0		 test	 eax, eax
  00118	75 c8		 jne	 SHORT $LN4@z900_conve

; 3831 :     PER_ZEROADDR_XCHECK(regs, b2);

  0011a	8b 54 24 34	 mov	 edx, DWORD PTR b2$[rsp]
  0011e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_conve:

; 3832 : 
; 3833 :     TXF_FLOAT_INSTR_CHECK(regs);

  0012b	33 c0		 xor	 eax, eax
  0012d	83 f8 01	 cmp	 eax, 1
  00130	0f 84 81 00 00
	00		 je	 $LN10@z900_conve
  00136	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00145	85 c0		 test	 eax, eax
  00147	74 6e		 je	 SHORT $LN10@z900_conve
  00149	33 c0		 xor	 eax, eax
  0014b	85 c0		 test	 eax, eax
  0014d	75 29		 jne	 SHORT $LN11@z900_conve
  0014f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0015e	85 c0		 test	 eax, eax
  00160	75 16		 jne	 SHORT $LN11@z900_conve
  00162	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00171	83 e0 04	 and	 eax, 4
  00174	85 c0		 test	 eax, eax
  00176	75 3f		 jne	 SHORT $LN10@z900_conve
$LN11@z900_conve:
  00178	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00180	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00186	0f ba e8 0b	 bts	 eax, 11
  0018a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00198	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196885
  0019f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001a5	ba 02 00 00 00	 mov	 edx, 2
  001aa	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_conve:
  001b7	33 c0		 xor	 eax, eax
  001b9	85 c0		 test	 eax, eax
  001bb	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3834 :     DFPINST_CHECK(regs);

  001c1	b8 08 00 00 00	 mov	 eax, 8
  001c6	48 6b c0 01	 imul	 rax, rax, 1
  001ca	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001da	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e0	48 85 c0	 test	 rax, rax
  001e3	74 42		 je	 SHORT $LN13@z900_conve
  001e5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ed	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001f3	d1 e8		 shr	 eax, 1
  001f5	83 e0 01	 and	 eax, 1
  001f8	85 c0		 test	 eax, eax
  001fa	74 58		 je	 SHORT $LN12@z900_conve
  001fc	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00204	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0020b	b9 08 00 00 00	 mov	 ecx, 8
  00210	48 6b c9 01	 imul	 rcx, rcx, 1
  00214	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0021c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00222	48 85 c0	 test	 rax, rax
  00225	75 2d		 jne	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  00227	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00239	ba 07 00 00 00	 mov	 edx, 7
  0023e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_conve:

; 3835 : 
; 3836 :     /* Program check if operand length exceeds 8 */
; 3837 :     if (l2 > CPDT_MAXLEN - 1)

  00254	83 7c 24 38 08	 cmp	 DWORD PTR l2$[rsp], 8
  00259	7e 12		 jle	 SHORT $LN14@z900_conve

; 3838 :     {
; 3839 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0025b	ba 06 00 00 00	 mov	 edx, 6
  00260	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_conve:

; 3840 :     }
; 3841 : 
; 3842 :     /* Initialise the context for long DFP */
; 3843 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0026d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00272	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  0027a	e8 00 00 00 00	 call	 decContextDefault

; 3844 : 
; 3845 :     /* Load DFP long number from FP register r1 */
; 3846 :     ARCH_DEP(dfp_reg_to_decimal64)(r1, &x1, regs);

  0027f	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00287	48 8d 54 24 58	 lea	 rdx, QWORD PTR x1$[rsp]
  0028c	8b 4c 24 48	 mov	 ecx, DWORD PTR r1$[rsp]
  00290	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 3847 :     decimal64ToNumber(&x1, &dwork);

  00295	48 8d 54 24 60	 lea	 rdx, QWORD PTR dwork$[rsp]
  0029a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  0029f	e8 00 00 00 00	 call	 decimal64ToNumber

; 3848 : 
; 3849 :     /* Extract coefficient only for Inf and NaN */
; 3850 :     if (decNumberIsNaN(&dwork) || (decNumberIsInfinite(&dwork)))

  002a4	0f b6 44 24 68	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  002a9	83 e0 30	 and	 eax, 48			; 00000030H
  002ac	85 c0		 test	 eax, eax
  002ae	75 0c		 jne	 SHORT $LN16@z900_conve
  002b0	0f b6 44 24 68	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  002b5	83 e0 40	 and	 eax, 64			; 00000040H
  002b8	85 c0		 test	 eax, eax
  002ba	74 1c		 je	 SHORT $LN15@z900_conve
$LN16@z900_conve:

; 3851 :     {
; 3852 :         dfp64_clear_cf_and_bxcf(&x1);

  002bc	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  002c1	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 3853 :         decimal64ToNumber(&x1, &dcoeff);

  002c6	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR dcoeff$[rsp]
  002ce	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  002d3	e8 00 00 00 00	 call	 decimal64ToNumber
$LN15@z900_conve:

; 3854 :     }
; 3855 : 
; 3856 :     /* Convert number to zoned decimal and set condition code */
; 3857 :     cc = dfp_number_to_packed(&dwork, &dcoeff, packed, l2, m3, &set);

  002d8	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR set$[rsp]
  002e0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002e5	8b 44 24 4c	 mov	 eax, DWORD PTR m3$[rsp]
  002e9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002ed	44 8b 4c 24 38	 mov	 r9d, DWORD PTR l2$[rsp]
  002f2	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR packed$[rsp]
  002fa	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR dcoeff$[rsp]
  00302	48 8d 4c 24 60	 lea	 rcx, QWORD PTR dwork$[rsp]
  00307	e8 00 00 00 00	 call	 dfp_number_to_packed
  0030c	89 44 24 50	 mov	 DWORD PTR cc$[rsp], eax

; 3858 : 
; 3859 :     /* Store the zoned decimal result at the operand location */
; 3860 :     ARCH_DEP(vstorec) (packed, l2, effective_addr2, b2, regs);

  00310	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00318	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0031d	44 8b 4c 24 34	 mov	 r9d, DWORD PTR b2$[rsp]
  00322	4c 8b 44 24 40	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  00327	0f b6 54 24 38	 movzx	 edx, BYTE PTR l2$[rsp]
  0032c	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR packed$[rsp]
  00334	e8 00 00 00 00	 call	 z900_vstorec

; 3861 : 
; 3862 :     /* Set the condition code in the PSW */
; 3863 :     regs->psw.cc = cc;

  00339	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00341	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR cc$[rsp]
  00346	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3864 : 
; 3865 : } /* end DEF_INST(convert_dfp_long_to_zoned) */

  00349	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00351	48 33 cc	 xor	 rcx, rsp
  00354	e8 00 00 00 00	 call	 __security_check_cookie
  00359	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00360	c3		 ret	 0
z900_convert_dfp_long_to_packed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 48
b2$ = 52
l2$ = 56
r1$ = 60
effective_addr2$ = 64
m3$ = 72
cc$ = 76
x1$ = 80
dwork$ = 96
set$ = 136
dcoeff$ = 168
packed$ = 208
__$ArrayPad$ = 232
inst$ = 256
regs$ = 264
z900_convert_dfp_ext_to_packed PROC

; 3765 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3766 :     int             r1, m3;                 /* Values of R and M fields  */
; 3767 :     int             l2;                     /* Operand length minus 1    */
; 3768 :     int             b2;                     /* Base of effective addr    */
; 3769 :     VADR            effective_addr2;        /* Effective address         */
; 3770 :     decimal128      x1;                     /* Extended DFP value        */
; 3771 :     decNumber       dwork, dcoeff;          /* Working decimal numbers   */
; 3772 :     decContext      set;                    /* Working context           */
; 3773 :     int             cc;                     /* Condition code            */
; 3774 :     char            packed[CPXT_MAXLEN];    /* Packed decimal result     */
; 3775 : 
; 3776 :     RSL_RM(inst, regs, r1, l2, b2, effective_addr2, m3);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 01	 imul	 rax, rax, 1
  0002c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	48 03 c8	 add	 rcx, rax
  00037	48 8b c1	 mov	 rax, rcx
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00042	8b c8		 mov	 ecx, eax
  00044	e8 00 00 00 00	 call	 _byteswap_ulong
  00049	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
  00058	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 04	 shr	 eax, 4
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00066	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0006a	c1 e8 08	 shr	 eax, 8
  0006d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00072	8b c0		 mov	 eax, eax
  00074	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00079	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0007d	c1 e8 14	 shr	 eax, 20
  00080	83 e0 0f	 and	 eax, 15
  00083	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00087	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 18	 shr	 eax, 24
  0008e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00093	89 44 24 38	 mov	 DWORD PTR l2$[rsp], eax
  00097	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009c	74 44		 je	 SHORT $LN8@z900_conve
  0009e	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000b8	48 03 c8	 add	 rcx, rax
  000bb	48 8b c1	 mov	 rax, rcx
  000be	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000c3	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d7	48 23 c8	 and	 rcx, rax
  000da	48 8b c1	 mov	 rax, rcx
  000dd	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_conve:
$LN4@z900_conve:
  000e2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ea	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ee	48 83 c0 06	 add	 rax, 6
  000f2	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000fe	33 c0		 xor	 eax, eax
  00100	83 f8 06	 cmp	 eax, 6
  00103	74 0f		 je	 SHORT $LN9@z900_conve
  00105	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010d	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_conve:
  00114	33 c0		 xor	 eax, eax
  00116	85 c0		 test	 eax, eax
  00118	75 c8		 jne	 SHORT $LN4@z900_conve

; 3777 :     PER_ZEROADDR_XCHECK(regs, b2);

  0011a	8b 54 24 34	 mov	 edx, DWORD PTR b2$[rsp]
  0011e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_conve:

; 3778 : 
; 3779 :     TXF_FLOAT_INSTR_CHECK(regs);

  0012b	33 c0		 xor	 eax, eax
  0012d	83 f8 01	 cmp	 eax, 1
  00130	0f 84 81 00 00
	00		 je	 $LN10@z900_conve
  00136	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00145	85 c0		 test	 eax, eax
  00147	74 6e		 je	 SHORT $LN10@z900_conve
  00149	33 c0		 xor	 eax, eax
  0014b	85 c0		 test	 eax, eax
  0014d	75 29		 jne	 SHORT $LN11@z900_conve
  0014f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0015e	85 c0		 test	 eax, eax
  00160	75 16		 jne	 SHORT $LN11@z900_conve
  00162	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00171	83 e0 04	 and	 eax, 4
  00174	85 c0		 test	 eax, eax
  00176	75 3f		 jne	 SHORT $LN10@z900_conve
$LN11@z900_conve:
  00178	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00180	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00186	0f ba e8 0b	 bts	 eax, 11
  0018a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00198	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196851
  0019f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001a5	ba 02 00 00 00	 mov	 edx, 2
  001aa	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_conve:
  001b7	33 c0		 xor	 eax, eax
  001b9	85 c0		 test	 eax, eax
  001bb	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3780 :     DFPINST_CHECK(regs);

  001c1	b8 08 00 00 00	 mov	 eax, 8
  001c6	48 6b c0 01	 imul	 rax, rax, 1
  001ca	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001da	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e0	48 85 c0	 test	 rax, rax
  001e3	74 42		 je	 SHORT $LN13@z900_conve
  001e5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ed	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001f3	d1 e8		 shr	 eax, 1
  001f5	83 e0 01	 and	 eax, 1
  001f8	85 c0		 test	 eax, eax
  001fa	74 58		 je	 SHORT $LN12@z900_conve
  001fc	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00204	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0020b	b9 08 00 00 00	 mov	 ecx, 8
  00210	48 6b c9 01	 imul	 rcx, rcx, 1
  00214	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0021c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00222	48 85 c0	 test	 rax, rax
  00225	75 2d		 jne	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  00227	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00239	ba 07 00 00 00	 mov	 edx, 7
  0023e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_conve:

; 3781 :     DFPREGPAIR_CHECK(r1, regs);

  00254	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00258	83 e0 02	 and	 eax, 2
  0025b	85 c0		 test	 eax, eax
  0025d	74 1b		 je	 SHORT $LN14@z900_conve
  0025f	ba 06 00 00 00	 mov	 edx, 6
  00264	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00274	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_conve:

; 3782 : 
; 3783 :     /* Program check if operand length exceeds 18 */
; 3784 :     if (l2 > CPXT_MAXLEN - 1)

  0027a	83 7c 24 38 11	 cmp	 DWORD PTR l2$[rsp], 17
  0027f	7e 12		 jle	 SHORT $LN15@z900_conve

; 3785 :     {
; 3786 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00281	ba 06 00 00 00	 mov	 edx, 6
  00286	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028e	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_conve:

; 3787 :     }
; 3788 : 
; 3789 :     /* Initialise the context for extended DFP */
; 3790 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00293	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00298	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  002a0	e8 00 00 00 00	 call	 decContextDefault

; 3791 : 
; 3792 :     /* Load DFP extended number from FP register r1 */
; 3793 :     ARCH_DEP(dfp_reg_to_decimal128)(r1, &x1, regs);

  002a5	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002ad	48 8d 54 24 50	 lea	 rdx, QWORD PTR x1$[rsp]
  002b2	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  002b6	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 3794 :     decimal128ToNumber(&x1, &dwork);

  002bb	48 8d 54 24 60	 lea	 rdx, QWORD PTR dwork$[rsp]
  002c0	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  002c5	e8 00 00 00 00	 call	 decimal128ToNumber

; 3795 : 
; 3796 :     /* Extract coefficient only for Inf and NaN */
; 3797 :     if (decNumberIsNaN(&dwork) || (decNumberIsInfinite(&dwork)))

  002ca	0f b6 44 24 68	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  002cf	83 e0 30	 and	 eax, 48			; 00000030H
  002d2	85 c0		 test	 eax, eax
  002d4	75 0c		 jne	 SHORT $LN17@z900_conve
  002d6	0f b6 44 24 68	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  002db	83 e0 40	 and	 eax, 64			; 00000040H
  002de	85 c0		 test	 eax, eax
  002e0	74 1c		 je	 SHORT $LN16@z900_conve
$LN17@z900_conve:

; 3798 :     {
; 3799 :         dfp128_clear_cf_and_bxcf(&x1);

  002e2	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  002e7	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 3800 :         decimal128ToNumber(&x1, &dcoeff);

  002ec	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR dcoeff$[rsp]
  002f4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  002f9	e8 00 00 00 00	 call	 decimal128ToNumber
$LN16@z900_conve:

; 3801 :     }
; 3802 : 
; 3803 :     /* Convert number to packed decimal and set condition code */
; 3804 :     cc = dfp_number_to_packed(&dwork, &dcoeff, packed, l2, m3, &set);

  002fe	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR set$[rsp]
  00306	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0030b	8b 44 24 48	 mov	 eax, DWORD PTR m3$[rsp]
  0030f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00313	44 8b 4c 24 38	 mov	 r9d, DWORD PTR l2$[rsp]
  00318	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR packed$[rsp]
  00320	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR dcoeff$[rsp]
  00328	48 8d 4c 24 60	 lea	 rcx, QWORD PTR dwork$[rsp]
  0032d	e8 00 00 00 00	 call	 dfp_number_to_packed
  00332	89 44 24 4c	 mov	 DWORD PTR cc$[rsp], eax

; 3805 : 
; 3806 :     /* Store the zoned decimal result at the operand location */
; 3807 :     ARCH_DEP(vstorec) (packed, l2, effective_addr2, b2, regs);

  00336	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0033e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00343	44 8b 4c 24 34	 mov	 r9d, DWORD PTR b2$[rsp]
  00348	4c 8b 44 24 40	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  0034d	0f b6 54 24 38	 movzx	 edx, BYTE PTR l2$[rsp]
  00352	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR packed$[rsp]
  0035a	e8 00 00 00 00	 call	 z900_vstorec

; 3808 : 
; 3809 :     /* Set the condition code in the PSW */
; 3810 :     regs->psw.cc = cc;

  0035f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00367	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR cc$[rsp]
  0036c	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3811 : 
; 3812 : } /* end DEF_INST(convert_dfp_ext_to_zoned) */

  0036f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00377	48 33 cc	 xor	 rcx, rsp
  0037a	e8 00 00 00 00	 call	 __security_check_cookie
  0037f	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00386	c3		 ret	 0
z900_convert_dfp_ext_to_packed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 48
rc$ = 52
b2$ = 56
l2$ = 60
m3$ = 64
effective_addr2$ = 72
r1$ = 80
x1$ = 88
set$ = 96
d$ = 128
packed$ = 168
__$ArrayPad$ = 184
inst$ = 208
regs$ = 216
z900_convert_packed_to_dfp_long PROC

; 2991 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2992 :     int             rc;                     /* Return code               */
; 2993 :     int             r1, m3;                 /* Values of R and M fields  */
; 2994 :     int             l2;                     /* Operand length minus 1    */
; 2995 :     int             b2;                     /* Base of effective addr    */
; 2996 :     VADR            effective_addr2;        /* Effective address         */
; 2997 :     decimal64       x1;                     /* Long DFP value            */
; 2998 :     decNumber       d;                      /* Working decimal number    */
; 2999 :     decContext      set;                    /* Working context           */
; 3000 :     char            packed[CDPT_MAXLEN];    /* Packed decimal operand    */
; 3001 : 
; 3002 :     RSL_RM(inst, regs, r1, l2, b2, effective_addr2, m3);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 01	 imul	 rax, rax, 1
  0002c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	48 03 c8	 add	 rcx, rax
  00037	48 8b c1	 mov	 rax, rcx
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00042	8b c8		 mov	 ecx, eax
  00044	e8 00 00 00 00	 call	 _byteswap_ulong
  00049	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 40	 mov	 DWORD PTR m3$[rsp], eax
  00058	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 04	 shr	 eax, 4
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 50	 mov	 DWORD PTR r1$[rsp], eax
  00066	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0006a	c1 e8 08	 shr	 eax, 8
  0006d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00072	8b c0		 mov	 eax, eax
  00074	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00079	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0007d	c1 e8 14	 shr	 eax, 20
  00080	83 e0 0f	 and	 eax, 15
  00083	89 44 24 38	 mov	 DWORD PTR b2$[rsp], eax
  00087	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 18	 shr	 eax, 24
  0008e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00093	89 44 24 3c	 mov	 DWORD PTR l2$[rsp], eax
  00097	83 7c 24 38 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009c	74 44		 je	 SHORT $LN8@z900_conve
  0009e	48 63 44 24 38	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a3	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000b8	48 03 c8	 add	 rcx, rax
  000bb	48 8b c1	 mov	 rax, rcx
  000be	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000c3	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000d2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d7	48 23 c8	 and	 rcx, rax
  000da	48 8b c1	 mov	 rax, rcx
  000dd	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_conve:
$LN4@z900_conve:
  000e2	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ea	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ee	48 83 c0 06	 add	 rax, 6
  000f2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000fe	33 c0		 xor	 eax, eax
  00100	83 f8 06	 cmp	 eax, 6
  00103	74 0f		 je	 SHORT $LN9@z900_conve
  00105	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010d	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_conve:
  00114	33 c0		 xor	 eax, eax
  00116	85 c0		 test	 eax, eax
  00118	75 c8		 jne	 SHORT $LN4@z900_conve

; 3003 :     PER_ZEROADDR_XCHECK(regs, b2);

  0011a	8b 54 24 38	 mov	 edx, DWORD PTR b2$[rsp]
  0011e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_conve:

; 3004 : 
; 3005 :     TXF_FLOAT_INSTR_CHECK(regs);

  0012b	33 c0		 xor	 eax, eax
  0012d	83 f8 01	 cmp	 eax, 1
  00130	0f 84 81 00 00
	00		 je	 $LN10@z900_conve
  00136	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00145	85 c0		 test	 eax, eax
  00147	74 6e		 je	 SHORT $LN10@z900_conve
  00149	33 c0		 xor	 eax, eax
  0014b	85 c0		 test	 eax, eax
  0014d	75 29		 jne	 SHORT $LN11@z900_conve
  0014f	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0015e	85 c0		 test	 eax, eax
  00160	75 16		 jne	 SHORT $LN11@z900_conve
  00162	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00171	83 e0 04	 and	 eax, 4
  00174	85 c0		 test	 eax, eax
  00176	75 3f		 jne	 SHORT $LN10@z900_conve
$LN11@z900_conve:
  00178	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00180	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00186	0f ba e8 0b	 bts	 eax, 11
  0018a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00198	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196396
  0019f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001a5	ba 02 00 00 00	 mov	 edx, 2
  001aa	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_conve:
  001b7	33 c0		 xor	 eax, eax
  001b9	85 c0		 test	 eax, eax
  001bb	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3006 :     DFPINST_CHECK(regs);

  001c1	b8 08 00 00 00	 mov	 eax, 8
  001c6	48 6b c0 01	 imul	 rax, rax, 1
  001ca	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001da	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e0	48 85 c0	 test	 rax, rax
  001e3	74 42		 je	 SHORT $LN13@z900_conve
  001e5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ed	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001f3	d1 e8		 shr	 eax, 1
  001f5	83 e0 01	 and	 eax, 1
  001f8	85 c0		 test	 eax, eax
  001fa	74 58		 je	 SHORT $LN12@z900_conve
  001fc	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00204	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0020b	b9 08 00 00 00	 mov	 ecx, 8
  00210	48 6b c9 01	 imul	 rcx, rcx, 1
  00214	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0021c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00222	48 85 c0	 test	 rax, rax
  00225	75 2d		 jne	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  00227	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00239	ba 07 00 00 00	 mov	 edx, 7
  0023e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_conve:

; 3007 : 
; 3008 :     /* Program check if operand length exceeds maximum */
; 3009 :     if (l2 > CDPT_MAXLEN - 1)

  00254	83 7c 24 3c 08	 cmp	 DWORD PTR l2$[rsp], 8
  00259	7e 12		 jle	 SHORT $LN14@z900_conve

; 3010 :     {
; 3011 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0025b	ba 06 00 00 00	 mov	 edx, 6
  00260	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_conve:

; 3012 :     }
; 3013 : 
; 3014 :     /* Initialise the context for long DFP */
; 3015 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0026d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00272	48 8d 4c 24 60	 lea	 rcx, QWORD PTR set$[rsp]
  00277	e8 00 00 00 00	 call	 decContextDefault

; 3016 : 
; 3017 :     /* Fetch the packed decimal operand into the work area */
; 3018 :     ARCH_DEP(vfetchc) (packed, l2, effective_addr2, b2, regs);

  0027c	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00284	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00289	44 8b 4c 24 38	 mov	 r9d, DWORD PTR b2$[rsp]
  0028e	4c 8b 44 24 48	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  00293	0f b6 54 24 3c	 movzx	 edx, BYTE PTR l2$[rsp]
  00298	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR packed$[rsp]
  002a0	e8 00 00 00 00	 call	 z900_vfetchc

; 3019 : 
; 3020 :     /* when l2 = 8; check that unused digits are 0 */
; 3021 :     rc = 0;

  002a5	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 3022 :     if (l2 == 8) {

  002ad	83 7c 24 3c 08	 cmp	 DWORD PTR l2$[rsp], 8
  002b2	75 4c		 jne	 SHORT $LN15@z900_conve

; 3023 :         if (m3 & 0x8) {

  002b4	8b 44 24 40	 mov	 eax, DWORD PTR m3$[rsp]
  002b8	83 e0 08	 and	 eax, 8
  002bb	85 c0		 test	 eax, eax
  002bd	74 24		 je	 SHORT $LN16@z900_conve

; 3024 :             /* signed - first nibble must be 0 */
; 3025 :             if ( (packed[0] & 0xF0) != 0)  rc = 1;

  002bf	b8 01 00 00 00	 mov	 eax, 1
  002c4	48 6b c0 00	 imul	 rax, rax, 0
  002c8	0f be 84 04 a8
	00 00 00	 movsx	 eax, BYTE PTR packed$[rsp+rax]
  002d0	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  002d5	85 c0		 test	 eax, eax
  002d7	74 08		 je	 SHORT $LN18@z900_conve
  002d9	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
$LN18@z900_conve:

; 3026 :         }

  002e1	eb 1d		 jmp	 SHORT $LN17@z900_conve
$LN16@z900_conve:

; 3027 :         else {
; 3028 :             /* unsigned - first byte must be 0 */
; 3029 :             if (packed[0] != 0)  rc = 1;

  002e3	b8 01 00 00 00	 mov	 eax, 1
  002e8	48 6b c0 00	 imul	 rax, rax, 0
  002ec	0f be 84 04 a8
	00 00 00	 movsx	 eax, BYTE PTR packed$[rsp+rax]
  002f4	85 c0		 test	 eax, eax
  002f6	74 08		 je	 SHORT $LN19@z900_conve
  002f8	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
$LN19@z900_conve:
$LN17@z900_conve:
$LN15@z900_conve:

; 3030 :         }
; 3031 :     }
; 3032 : 
; 3033 :     /* Convert packed decimal to decimal number structure */
; 3034 :     if (rc == 0) rc = dfp_number_from_packed(&d, packed, l2, m3, &set);

  00300	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  00305	75 2d		 jne	 SHORT $LN20@z900_conve
  00307	48 8d 44 24 60	 lea	 rax, QWORD PTR set$[rsp]
  0030c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00311	44 8b 4c 24 40	 mov	 r9d, DWORD PTR m3$[rsp]
  00316	44 8b 44 24 3c	 mov	 r8d, DWORD PTR l2$[rsp]
  0031b	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR packed$[rsp]
  00323	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR d$[rsp]
  0032b	e8 00 00 00 00	 call	 dfp_number_from_packed
  00330	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
$LN20@z900_conve:

; 3035 : 
; 3036 :     /* Program check if data exception is indicated */
; 3037 :     if (rc != 0)

  00334	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  00339	74 24		 je	 SHORT $LN21@z900_conve

; 3038 :     {
; 3039 :         regs->dxc = DXC_DECIMAL;

  0033b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00343	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 3040 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0034d	ba 07 00 00 00	 mov	 edx, 7
  00352	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0035a	e8 00 00 00 00	 call	 z900_program_interrupt
$LN21@z900_conve:

; 3041 :     }
; 3042 : 
; 3043 :     /* Convert decimal number to long DFP format */
; 3044 :     decimal64FromNumber(&x1, &d, &set);

  0035f	4c 8d 44 24 60	 lea	 r8, QWORD PTR set$[rsp]
  00364	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d$[rsp]
  0036c	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  00371	e8 00 00 00 00	 call	 decimal64FromNumber

; 3045 : 
; 3046 :     /* Load result into FP register r1 */
; 3047 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  00376	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0037e	48 8d 54 24 58	 lea	 rdx, QWORD PTR x1$[rsp]
  00383	8b 4c 24 50	 mov	 ecx, DWORD PTR r1$[rsp]
  00387	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 3048 : 
; 3049 : } /* end DEF_INST(convert_packed_to_dfp_long) */

  0038c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00394	48 33 cc	 xor	 rcx, rsp
  00397	e8 00 00 00 00	 call	 __security_check_cookie
  0039c	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  003a3	c3		 ret	 0
z900_convert_packed_to_dfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 48
rc$ = 52
b2$ = 56
l2$ = 60
m3$ = 64
r1$ = 68
effective_addr2$ = 72
x1$ = 80
set$ = 96
d$ = 128
packed$ = 168
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
z900_convert_packed_to_dfp_ext PROC

; 2925 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2926 :     int             rc;                     /* Return code               */
; 2927 :     int             r1, m3;                 /* Values of R and M fields  */
; 2928 :     int             l2;                     /* Operand length minus 1    */
; 2929 :     int             b2;                     /* Base of effective addr    */
; 2930 :     VADR            effective_addr2;        /* Effective address         */
; 2931 :     decimal128      x1;                     /* Extended DFP value        */
; 2932 :     decNumber       d;                      /* Working decimal number    */
; 2933 :     decContext      set;                    /* Working context           */
; 2934 :     char            packed[CXPT_MAXLEN];    /* Packed decimal operand    */
; 2935 : 
; 2936 :     RSL_RM(inst, regs, r1, l2, b2, effective_addr2, m3);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 01	 imul	 rax, rax, 1
  0002c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	48 03 c8	 add	 rcx, rax
  00037	48 8b c1	 mov	 rax, rcx
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00042	8b c8		 mov	 ecx, eax
  00044	e8 00 00 00 00	 call	 _byteswap_ulong
  00049	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 40	 mov	 DWORD PTR m3$[rsp], eax
  00058	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 04	 shr	 eax, 4
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 44	 mov	 DWORD PTR r1$[rsp], eax
  00066	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0006a	c1 e8 08	 shr	 eax, 8
  0006d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00072	8b c0		 mov	 eax, eax
  00074	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00079	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0007d	c1 e8 14	 shr	 eax, 20
  00080	83 e0 0f	 and	 eax, 15
  00083	89 44 24 38	 mov	 DWORD PTR b2$[rsp], eax
  00087	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 18	 shr	 eax, 24
  0008e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00093	89 44 24 3c	 mov	 DWORD PTR l2$[rsp], eax
  00097	83 7c 24 38 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009c	74 44		 je	 SHORT $LN8@z900_conve
  0009e	48 63 44 24 38	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000b8	48 03 c8	 add	 rcx, rax
  000bb	48 8b c1	 mov	 rax, rcx
  000be	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000c3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000d2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d7	48 23 c8	 and	 rcx, rax
  000da	48 8b c1	 mov	 rax, rcx
  000dd	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_conve:
$LN4@z900_conve:
  000e2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ea	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ee	48 83 c0 06	 add	 rax, 6
  000f2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000fe	33 c0		 xor	 eax, eax
  00100	83 f8 06	 cmp	 eax, 6
  00103	74 0f		 je	 SHORT $LN9@z900_conve
  00105	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010d	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_conve:
  00114	33 c0		 xor	 eax, eax
  00116	85 c0		 test	 eax, eax
  00118	75 c8		 jne	 SHORT $LN4@z900_conve

; 2937 :     PER_ZEROADDR_XCHECK(regs, b2);

  0011a	8b 54 24 38	 mov	 edx, DWORD PTR b2$[rsp]
  0011e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_conve:

; 2938 : 
; 2939 :     TXF_FLOAT_INSTR_CHECK(regs);

  0012b	33 c0		 xor	 eax, eax
  0012d	83 f8 01	 cmp	 eax, 1
  00130	0f 84 81 00 00
	00		 je	 $LN10@z900_conve
  00136	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00145	85 c0		 test	 eax, eax
  00147	74 6e		 je	 SHORT $LN10@z900_conve
  00149	33 c0		 xor	 eax, eax
  0014b	85 c0		 test	 eax, eax
  0014d	75 29		 jne	 SHORT $LN11@z900_conve
  0014f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0015e	85 c0		 test	 eax, eax
  00160	75 16		 jne	 SHORT $LN11@z900_conve
  00162	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00171	83 e0 04	 and	 eax, 4
  00174	85 c0		 test	 eax, eax
  00176	75 3f		 jne	 SHORT $LN10@z900_conve
$LN11@z900_conve:
  00178	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00180	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00186	0f ba e8 0b	 bts	 eax, 11
  0018a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00198	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196358
  0019f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001a5	ba 02 00 00 00	 mov	 edx, 2
  001aa	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_conve:
  001b7	33 c0		 xor	 eax, eax
  001b9	85 c0		 test	 eax, eax
  001bb	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2940 :     DFPINST_CHECK(regs);

  001c1	b8 08 00 00 00	 mov	 eax, 8
  001c6	48 6b c0 01	 imul	 rax, rax, 1
  001ca	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001da	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e0	48 85 c0	 test	 rax, rax
  001e3	74 42		 je	 SHORT $LN13@z900_conve
  001e5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ed	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001f3	d1 e8		 shr	 eax, 1
  001f5	83 e0 01	 and	 eax, 1
  001f8	85 c0		 test	 eax, eax
  001fa	74 58		 je	 SHORT $LN12@z900_conve
  001fc	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00204	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0020b	b9 08 00 00 00	 mov	 ecx, 8
  00210	48 6b c9 01	 imul	 rcx, rcx, 1
  00214	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0021c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00222	48 85 c0	 test	 rax, rax
  00225	75 2d		 jne	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  00227	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00239	ba 07 00 00 00	 mov	 edx, 7
  0023e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_conve:

; 2941 :     DFPREGPAIR_CHECK(r1, regs);

  00254	8b 44 24 44	 mov	 eax, DWORD PTR r1$[rsp]
  00258	83 e0 02	 and	 eax, 2
  0025b	85 c0		 test	 eax, eax
  0025d	74 1b		 je	 SHORT $LN14@z900_conve
  0025f	ba 06 00 00 00	 mov	 edx, 6
  00264	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00274	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_conve:

; 2942 : 
; 2943 :     /* Program check if operand length exceeds maximum */
; 2944 :     if (l2 > CXPT_MAXLEN - 1)

  0027a	83 7c 24 3c 11	 cmp	 DWORD PTR l2$[rsp], 17
  0027f	7e 12		 jle	 SHORT $LN15@z900_conve

; 2945 :     {
; 2946 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00281	ba 06 00 00 00	 mov	 edx, 6
  00286	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028e	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_conve:

; 2947 :     }
; 2948 : 
; 2949 :     /* Initialise the context for extended DFP */
; 2950 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00293	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00298	48 8d 4c 24 60	 lea	 rcx, QWORD PTR set$[rsp]
  0029d	e8 00 00 00 00	 call	 decContextDefault

; 2951 : 
; 2952 :     /* Fetch the packed decimal operand into the work area */
; 2953 :     ARCH_DEP(vfetchc) (packed, l2, effective_addr2, b2, regs);

  002a2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002af	44 8b 4c 24 38	 mov	 r9d, DWORD PTR b2$[rsp]
  002b4	4c 8b 44 24 48	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  002b9	0f b6 54 24 3c	 movzx	 edx, BYTE PTR l2$[rsp]
  002be	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR packed$[rsp]
  002c6	e8 00 00 00 00	 call	 z900_vfetchc

; 2954 : 
; 2955 :     /* when l2 = 17; check that unused digits are 0 */
; 2956 :     rc = 0;

  002cb	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 2957 :     if (l2 == 17) {

  002d3	83 7c 24 3c 11	 cmp	 DWORD PTR l2$[rsp], 17
  002d8	75 4c		 jne	 SHORT $LN16@z900_conve

; 2958 :         if (m3 & 0x8) {

  002da	8b 44 24 40	 mov	 eax, DWORD PTR m3$[rsp]
  002de	83 e0 08	 and	 eax, 8
  002e1	85 c0		 test	 eax, eax
  002e3	74 24		 je	 SHORT $LN17@z900_conve

; 2959 :             /* signed - first nibble must be 0 */
; 2960 :             if (packed[0] & 0xF0)  rc = 1;

  002e5	b8 01 00 00 00	 mov	 eax, 1
  002ea	48 6b c0 00	 imul	 rax, rax, 0
  002ee	0f be 84 04 a8
	00 00 00	 movsx	 eax, BYTE PTR packed$[rsp+rax]
  002f6	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  002fb	85 c0		 test	 eax, eax
  002fd	74 08		 je	 SHORT $LN19@z900_conve
  002ff	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
$LN19@z900_conve:

; 2961 :         }

  00307	eb 1d		 jmp	 SHORT $LN18@z900_conve
$LN17@z900_conve:

; 2962 :         else {
; 2963 :             /* unsigned - first byte must be 0 */
; 2964 :             if (packed[0]) rc = 1;

  00309	b8 01 00 00 00	 mov	 eax, 1
  0030e	48 6b c0 00	 imul	 rax, rax, 0
  00312	0f be 84 04 a8
	00 00 00	 movsx	 eax, BYTE PTR packed$[rsp+rax]
  0031a	85 c0		 test	 eax, eax
  0031c	74 08		 je	 SHORT $LN20@z900_conve
  0031e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
$LN20@z900_conve:
$LN18@z900_conve:
$LN16@z900_conve:

; 2965 :         }
; 2966 :     }
; 2967 : 
; 2968 :     /* Convert packed decimal to decimal number structure */
; 2969 :     if (rc == 0)  rc = dfp_number_from_packed(&d, packed, l2, m3, &set);

  00326	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  0032b	75 2d		 jne	 SHORT $LN21@z900_conve
  0032d	48 8d 44 24 60	 lea	 rax, QWORD PTR set$[rsp]
  00332	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00337	44 8b 4c 24 40	 mov	 r9d, DWORD PTR m3$[rsp]
  0033c	44 8b 44 24 3c	 mov	 r8d, DWORD PTR l2$[rsp]
  00341	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR packed$[rsp]
  00349	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR d$[rsp]
  00351	e8 00 00 00 00	 call	 dfp_number_from_packed
  00356	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
$LN21@z900_conve:

; 2970 : 
; 2971 :     /* Program check if data exception is indicated */
; 2972 :     if (rc != 0)

  0035a	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  0035f	74 24		 je	 SHORT $LN22@z900_conve

; 2973 :     {
; 2974 :         regs->dxc = DXC_DECIMAL;

  00361	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00369	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 2975 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00373	ba 07 00 00 00	 mov	 edx, 7
  00378	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00380	e8 00 00 00 00	 call	 z900_program_interrupt
$LN22@z900_conve:

; 2976 :     }
; 2977 : 
; 2978 :     /* Convert decimal number to extended DFP format */
; 2979 :     decimal128FromNumber(&x1, &d, &set);

  00385	4c 8d 44 24 60	 lea	 r8, QWORD PTR set$[rsp]
  0038a	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d$[rsp]
  00392	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  00397	e8 00 00 00 00	 call	 decimal128FromNumber

; 2980 : 
; 2981 :     /* Load result into FP register r1 */
; 2982 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  0039c	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003a4	48 8d 54 24 50	 lea	 rdx, QWORD PTR x1$[rsp]
  003a9	8b 4c 24 44	 mov	 ecx, DWORD PTR r1$[rsp]
  003ad	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 2983 : 
; 2984 : } /* end DEF_INST(convert_packed_to_dfp_ext) */

  003b2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003ba	48 33 cc	 xor	 rcx, rsp
  003bd	e8 00 00 00 00	 call	 __security_check_cookie
  003c2	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  003c9	c3		 ret	 0
z900_convert_packed_to_dfp_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 48
b2$ = 52
l2$ = 56
effective_addr2$ = 64
r1$ = 72
m3$ = 76
cc$ = 80
x1$ = 88
dwork$ = 96
set$ = 136
dcoeff$ = 168
zoned$ = 208
__$ArrayPad$ = 224
inst$ = 256
regs$ = 264
z900_convert_dfp_long_to_zoned PROC

; 3710 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3711 : int             r1, m3;                 /* Values of R and M fields  */
; 3712 : int             l2;                     /* Operand length minus 1    */
; 3713 : int             b2;                     /* Base of effective addr    */
; 3714 : VADR            effective_addr2;        /* Effective address         */
; 3715 : decimal64       x1;                     /* Long DFP value            */
; 3716 : decNumber       dwork, dcoeff;          /* Working decimal numbers   */
; 3717 : decContext      set;                    /* Working context           */
; 3718 : int             cc;                     /* Condition code            */
; 3719 : char            zoned[CZDT_MAXLEN];     /* Zoned decimal result      */
; 3720 : 
; 3721 :     RSL_RM(inst, regs, r1, l2, b2, effective_addr2, m3);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 01	 imul	 rax, rax, 1
  0002c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	48 03 c8	 add	 rcx, rax
  00037	48 8b c1	 mov	 rax, rcx
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00042	8b c8		 mov	 ecx, eax
  00044	e8 00 00 00 00	 call	 _byteswap_ulong
  00049	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 4c	 mov	 DWORD PTR m3$[rsp], eax
  00058	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 04	 shr	 eax, 4
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
  00066	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0006a	c1 e8 08	 shr	 eax, 8
  0006d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00072	8b c0		 mov	 eax, eax
  00074	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00079	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0007d	c1 e8 14	 shr	 eax, 20
  00080	83 e0 0f	 and	 eax, 15
  00083	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00087	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 18	 shr	 eax, 24
  0008e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00093	89 44 24 38	 mov	 DWORD PTR l2$[rsp], eax
  00097	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009c	74 44		 je	 SHORT $LN8@z900_conve
  0009e	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000b8	48 03 c8	 add	 rcx, rax
  000bb	48 8b c1	 mov	 rax, rcx
  000be	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000c3	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d7	48 23 c8	 and	 rcx, rax
  000da	48 8b c1	 mov	 rax, rcx
  000dd	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_conve:
$LN4@z900_conve:
  000e2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ea	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ee	48 83 c0 06	 add	 rax, 6
  000f2	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000fe	33 c0		 xor	 eax, eax
  00100	83 f8 06	 cmp	 eax, 6
  00103	74 0f		 je	 SHORT $LN9@z900_conve
  00105	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010d	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_conve:
  00114	33 c0		 xor	 eax, eax
  00116	85 c0		 test	 eax, eax
  00118	75 c8		 jne	 SHORT $LN4@z900_conve

; 3722 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0011a	8b 54 24 34	 mov	 edx, DWORD PTR b2$[rsp]
  0011e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_conve:

; 3723 : 
; 3724 :     TXF_FLOAT_INSTR_CHECK( regs );

  0012b	33 c0		 xor	 eax, eax
  0012d	83 f8 01	 cmp	 eax, 1
  00130	0f 84 81 00 00
	00		 je	 $LN10@z900_conve
  00136	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00145	85 c0		 test	 eax, eax
  00147	74 6e		 je	 SHORT $LN10@z900_conve
  00149	33 c0		 xor	 eax, eax
  0014b	85 c0		 test	 eax, eax
  0014d	75 29		 jne	 SHORT $LN11@z900_conve
  0014f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0015e	85 c0		 test	 eax, eax
  00160	75 16		 jne	 SHORT $LN11@z900_conve
  00162	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00171	83 e0 04	 and	 eax, 4
  00174	85 c0		 test	 eax, eax
  00176	75 3f		 jne	 SHORT $LN10@z900_conve
$LN11@z900_conve:
  00178	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00180	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00186	0f ba e8 0b	 bts	 eax, 11
  0018a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00198	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196818
  0019f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001a5	ba 02 00 00 00	 mov	 edx, 2
  001aa	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_conve:
  001b7	33 c0		 xor	 eax, eax
  001b9	85 c0		 test	 eax, eax
  001bb	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3725 :     DFPINST_CHECK(regs);

  001c1	b8 08 00 00 00	 mov	 eax, 8
  001c6	48 6b c0 01	 imul	 rax, rax, 1
  001ca	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001da	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e0	48 85 c0	 test	 rax, rax
  001e3	74 42		 je	 SHORT $LN13@z900_conve
  001e5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ed	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001f3	d1 e8		 shr	 eax, 1
  001f5	83 e0 01	 and	 eax, 1
  001f8	85 c0		 test	 eax, eax
  001fa	74 58		 je	 SHORT $LN12@z900_conve
  001fc	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00204	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0020b	b9 08 00 00 00	 mov	 ecx, 8
  00210	48 6b c9 01	 imul	 rcx, rcx, 1
  00214	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0021c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00222	48 85 c0	 test	 rax, rax
  00225	75 2d		 jne	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  00227	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00239	ba 07 00 00 00	 mov	 edx, 7
  0023e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_conve:

; 3726 : 
; 3727 :     /* Program check if operand length exceeds 16 */
; 3728 :     if (l2 > CZDT_MAXLEN-1)

  00254	83 7c 24 38 0f	 cmp	 DWORD PTR l2$[rsp], 15
  00259	7e 12		 jle	 SHORT $LN14@z900_conve

; 3729 :     {
; 3730 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0025b	ba 06 00 00 00	 mov	 edx, 6
  00260	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_conve:

; 3731 :     }
; 3732 : 
; 3733 :     /* Initialise the context for long DFP */
; 3734 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0026d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00272	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  0027a	e8 00 00 00 00	 call	 decContextDefault

; 3735 : 
; 3736 :     /* Load DFP long number from FP register r1 */
; 3737 :     ARCH_DEP(dfp_reg_to_decimal64)(r1, &x1, regs);

  0027f	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00287	48 8d 54 24 58	 lea	 rdx, QWORD PTR x1$[rsp]
  0028c	8b 4c 24 48	 mov	 ecx, DWORD PTR r1$[rsp]
  00290	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 3738 :     decimal64ToNumber(&x1, &dwork);

  00295	48 8d 54 24 60	 lea	 rdx, QWORD PTR dwork$[rsp]
  0029a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  0029f	e8 00 00 00 00	 call	 decimal64ToNumber

; 3739 : 
; 3740 :     /* Extract coefficient only for Inf and NaN */
; 3741 :     if (decNumberIsNaN(&dwork) || (decNumberIsInfinite(&dwork)))

  002a4	0f b6 44 24 68	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  002a9	83 e0 30	 and	 eax, 48			; 00000030H
  002ac	85 c0		 test	 eax, eax
  002ae	75 0c		 jne	 SHORT $LN16@z900_conve
  002b0	0f b6 44 24 68	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  002b5	83 e0 40	 and	 eax, 64			; 00000040H
  002b8	85 c0		 test	 eax, eax
  002ba	74 1c		 je	 SHORT $LN15@z900_conve
$LN16@z900_conve:

; 3742 :     {
; 3743 :         dfp64_clear_cf_and_bxcf(&x1);

  002bc	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  002c1	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 3744 :         decimal64ToNumber(&x1, &dcoeff);

  002c6	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR dcoeff$[rsp]
  002ce	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  002d3	e8 00 00 00 00	 call	 decimal64ToNumber
$LN15@z900_conve:

; 3745 :     }
; 3746 : 
; 3747 :     /* Convert number to zoned decimal and set condition code */
; 3748 :     cc = dfp_number_to_zoned(&dwork, &dcoeff, zoned, l2, m3, &set);

  002d8	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR set$[rsp]
  002e0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002e5	8b 44 24 4c	 mov	 eax, DWORD PTR m3$[rsp]
  002e9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002ed	44 8b 4c 24 38	 mov	 r9d, DWORD PTR l2$[rsp]
  002f2	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR zoned$[rsp]
  002fa	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR dcoeff$[rsp]
  00302	48 8d 4c 24 60	 lea	 rcx, QWORD PTR dwork$[rsp]
  00307	e8 00 00 00 00	 call	 dfp_number_to_zoned
  0030c	89 44 24 50	 mov	 DWORD PTR cc$[rsp], eax

; 3749 : 
; 3750 :     /* Store the zoned decimal result at the operand location */
; 3751 :     ARCH_DEP(vstorec) (zoned, l2, effective_addr2, b2, regs);

  00310	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00318	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0031d	44 8b 4c 24 34	 mov	 r9d, DWORD PTR b2$[rsp]
  00322	4c 8b 44 24 40	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  00327	0f b6 54 24 38	 movzx	 edx, BYTE PTR l2$[rsp]
  0032c	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR zoned$[rsp]
  00334	e8 00 00 00 00	 call	 z900_vstorec

; 3752 : 
; 3753 :     /* Set the condition code in the PSW */
; 3754 :     regs->psw.cc = cc;

  00339	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00341	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR cc$[rsp]
  00346	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3755 : 
; 3756 : } /* end DEF_INST(convert_dfp_long_to_zoned) */

  00349	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00351	48 33 cc	 xor	 rcx, rsp
  00354	e8 00 00 00 00	 call	 __security_check_cookie
  00359	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00360	c3		 ret	 0
z900_convert_dfp_long_to_zoned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 48
b2$ = 52
l2$ = 56
r1$ = 60
effective_addr2$ = 64
m3$ = 72
cc$ = 76
x1$ = 80
dwork$ = 96
set$ = 136
dcoeff$ = 168
zoned$ = 208
__$ArrayPad$ = 248
inst$ = 272
regs$ = 280
z900_convert_dfp_ext_to_zoned PROC

; 3656 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3657 : int             r1, m3;                 /* Values of R and M fields  */
; 3658 : int             l2;                     /* Operand length minus 1    */
; 3659 : int             b2;                     /* Base of effective addr    */
; 3660 : VADR            effective_addr2;        /* Effective address         */
; 3661 : decimal128      x1;                     /* Extended DFP value        */
; 3662 : decNumber       dwork, dcoeff;          /* Working decimal numbers   */
; 3663 : decContext      set;                    /* Working context           */
; 3664 : int             cc;                     /* Condition code            */
; 3665 : char            zoned[CZXT_MAXLEN];     /* Zoned decimal result      */
; 3666 : 
; 3667 :     RSL_RM(inst, regs, r1, l2, b2, effective_addr2, m3);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 01	 imul	 rax, rax, 1
  0002c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	48 03 c8	 add	 rcx, rax
  00037	48 8b c1	 mov	 rax, rcx
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00042	8b c8		 mov	 ecx, eax
  00044	e8 00 00 00 00	 call	 _byteswap_ulong
  00049	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
  00058	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 04	 shr	 eax, 4
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00066	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0006a	c1 e8 08	 shr	 eax, 8
  0006d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00072	8b c0		 mov	 eax, eax
  00074	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00079	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0007d	c1 e8 14	 shr	 eax, 20
  00080	83 e0 0f	 and	 eax, 15
  00083	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00087	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 18	 shr	 eax, 24
  0008e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00093	89 44 24 38	 mov	 DWORD PTR l2$[rsp], eax
  00097	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009c	74 44		 je	 SHORT $LN8@z900_conve
  0009e	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a3	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000b8	48 03 c8	 add	 rcx, rax
  000bb	48 8b c1	 mov	 rax, rcx
  000be	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000c3	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d7	48 23 c8	 and	 rcx, rax
  000da	48 8b c1	 mov	 rax, rcx
  000dd	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_conve:
$LN4@z900_conve:
  000e2	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ea	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ee	48 83 c0 06	 add	 rax, 6
  000f2	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000fe	33 c0		 xor	 eax, eax
  00100	83 f8 06	 cmp	 eax, 6
  00103	74 0f		 je	 SHORT $LN9@z900_conve
  00105	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010d	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_conve:
  00114	33 c0		 xor	 eax, eax
  00116	85 c0		 test	 eax, eax
  00118	75 c8		 jne	 SHORT $LN4@z900_conve

; 3668 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0011a	8b 54 24 34	 mov	 edx, DWORD PTR b2$[rsp]
  0011e	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_conve:

; 3669 : 
; 3670 :     TXF_FLOAT_INSTR_CHECK( regs );

  0012b	33 c0		 xor	 eax, eax
  0012d	83 f8 01	 cmp	 eax, 1
  00130	0f 84 81 00 00
	00		 je	 $LN10@z900_conve
  00136	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00145	85 c0		 test	 eax, eax
  00147	74 6e		 je	 SHORT $LN10@z900_conve
  00149	33 c0		 xor	 eax, eax
  0014b	85 c0		 test	 eax, eax
  0014d	75 29		 jne	 SHORT $LN11@z900_conve
  0014f	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0015e	85 c0		 test	 eax, eax
  00160	75 16		 jne	 SHORT $LN11@z900_conve
  00162	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00171	83 e0 04	 and	 eax, 4
  00174	85 c0		 test	 eax, eax
  00176	75 3f		 jne	 SHORT $LN10@z900_conve
$LN11@z900_conve:
  00178	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00180	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00186	0f ba e8 0b	 bts	 eax, 11
  0018a	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00198	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196784
  0019f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001a5	ba 02 00 00 00	 mov	 edx, 2
  001aa	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_conve:
  001b7	33 c0		 xor	 eax, eax
  001b9	85 c0		 test	 eax, eax
  001bb	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3671 :     DFPINST_CHECK(regs);

  001c1	b8 08 00 00 00	 mov	 eax, 8
  001c6	48 6b c0 01	 imul	 rax, rax, 1
  001ca	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001da	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e0	48 85 c0	 test	 rax, rax
  001e3	74 42		 je	 SHORT $LN13@z900_conve
  001e5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ed	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001f3	d1 e8		 shr	 eax, 1
  001f5	83 e0 01	 and	 eax, 1
  001f8	85 c0		 test	 eax, eax
  001fa	74 58		 je	 SHORT $LN12@z900_conve
  001fc	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00204	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0020b	b9 08 00 00 00	 mov	 ecx, 8
  00210	48 6b c9 01	 imul	 rcx, rcx, 1
  00214	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0021c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00222	48 85 c0	 test	 rax, rax
  00225	75 2d		 jne	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  00227	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00239	ba 07 00 00 00	 mov	 edx, 7
  0023e	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_conve:

; 3672 :     DFPREGPAIR_CHECK(r1, regs);

  00254	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00258	83 e0 02	 and	 eax, 2
  0025b	85 c0		 test	 eax, eax
  0025d	74 1b		 je	 SHORT $LN14@z900_conve
  0025f	ba 06 00 00 00	 mov	 edx, 6
  00264	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00274	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_conve:

; 3673 : 
; 3674 :     /* Program check if operand length exceeds 34 */
; 3675 :     if (l2 > CZXT_MAXLEN-1)

  0027a	83 7c 24 38 21	 cmp	 DWORD PTR l2$[rsp], 33	; 00000021H
  0027f	7e 12		 jle	 SHORT $LN15@z900_conve

; 3676 :     {
; 3677 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00281	ba 06 00 00 00	 mov	 edx, 6
  00286	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028e	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_conve:

; 3678 :     }
; 3679 : 
; 3680 :     /* Initialise the context for extended DFP */
; 3681 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00293	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00298	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  002a0	e8 00 00 00 00	 call	 decContextDefault

; 3682 : 
; 3683 :     /* Load DFP extended number from FP register r1 */
; 3684 :     ARCH_DEP(dfp_reg_to_decimal128)(r1, &x1, regs);

  002a5	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002ad	48 8d 54 24 50	 lea	 rdx, QWORD PTR x1$[rsp]
  002b2	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  002b6	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 3685 :     decimal128ToNumber(&x1, &dwork);

  002bb	48 8d 54 24 60	 lea	 rdx, QWORD PTR dwork$[rsp]
  002c0	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  002c5	e8 00 00 00 00	 call	 decimal128ToNumber

; 3686 : 
; 3687 :     /* Extract coefficient only for Inf and NaN */
; 3688 :     if (decNumberIsNaN(&dwork) || (decNumberIsInfinite(&dwork)))

  002ca	0f b6 44 24 68	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  002cf	83 e0 30	 and	 eax, 48			; 00000030H
  002d2	85 c0		 test	 eax, eax
  002d4	75 0c		 jne	 SHORT $LN17@z900_conve
  002d6	0f b6 44 24 68	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  002db	83 e0 40	 and	 eax, 64			; 00000040H
  002de	85 c0		 test	 eax, eax
  002e0	74 1c		 je	 SHORT $LN16@z900_conve
$LN17@z900_conve:

; 3689 :     {
; 3690 :         dfp128_clear_cf_and_bxcf(&x1);

  002e2	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  002e7	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 3691 :         decimal128ToNumber(&x1, &dcoeff);

  002ec	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR dcoeff$[rsp]
  002f4	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  002f9	e8 00 00 00 00	 call	 decimal128ToNumber
$LN16@z900_conve:

; 3692 :     }
; 3693 : 
; 3694 :     /* Convert number to zoned decimal and set condition code */
; 3695 :     cc = dfp_number_to_zoned(&dwork, &dcoeff, zoned, l2, m3, &set);

  002fe	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR set$[rsp]
  00306	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0030b	8b 44 24 48	 mov	 eax, DWORD PTR m3$[rsp]
  0030f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00313	44 8b 4c 24 38	 mov	 r9d, DWORD PTR l2$[rsp]
  00318	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR zoned$[rsp]
  00320	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR dcoeff$[rsp]
  00328	48 8d 4c 24 60	 lea	 rcx, QWORD PTR dwork$[rsp]
  0032d	e8 00 00 00 00	 call	 dfp_number_to_zoned
  00332	89 44 24 4c	 mov	 DWORD PTR cc$[rsp], eax

; 3696 : 
; 3697 :     /* Store the zoned decimal result at the operand location */
; 3698 :     ARCH_DEP(vstorec) (zoned, l2, effective_addr2, b2, regs);

  00336	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0033e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00343	44 8b 4c 24 34	 mov	 r9d, DWORD PTR b2$[rsp]
  00348	4c 8b 44 24 40	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  0034d	0f b6 54 24 38	 movzx	 edx, BYTE PTR l2$[rsp]
  00352	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR zoned$[rsp]
  0035a	e8 00 00 00 00	 call	 z900_vstorec

; 3699 : 
; 3700 :     /* Set the condition code in the PSW */
; 3701 :     regs->psw.cc = cc;

  0035f	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00367	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR cc$[rsp]
  0036c	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3702 : 
; 3703 : } /* end DEF_INST(convert_dfp_ext_to_zoned) */

  0036f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00377	48 33 cc	 xor	 rcx, rsp
  0037a	e8 00 00 00 00	 call	 __security_check_cookie
  0037f	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  00386	c3		 ret	 0
z900_convert_dfp_ext_to_zoned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 48
b2$ = 52
l2$ = 56
effective_addr2$ = 64
m3$ = 72
rc$ = 76
r1$ = 80
x1$ = 88
set$ = 96
d$ = 128
zoned$ = 168
__$ArrayPad$ = 184
inst$ = 208
regs$ = 216
z900_convert_zoned_to_dfp_long PROC

; 2871 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2872 : int             rc;                     /* Return code               */
; 2873 : int             r1, m3;                 /* Values of R and M fields  */
; 2874 : int             l2;                     /* Operand length minus 1    */
; 2875 : int             b2;                     /* Base of effective addr    */
; 2876 : VADR            effective_addr2;        /* Effective address         */
; 2877 : decimal64       x1;                     /* Long DFP value            */
; 2878 : decNumber       d;                      /* Working decimal number    */
; 2879 : decContext      set;                    /* Working context           */
; 2880 : char            zoned[CDZT_MAXLEN];     /* Zoned decimal operand     */
; 2881 : 
; 2882 :     RSL_RM(inst, regs, r1, l2, b2, effective_addr2, m3);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 01	 imul	 rax, rax, 1
  0002c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	48 03 c8	 add	 rcx, rax
  00037	48 8b c1	 mov	 rax, rcx
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00042	8b c8		 mov	 ecx, eax
  00044	e8 00 00 00 00	 call	 _byteswap_ulong
  00049	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
  00058	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 04	 shr	 eax, 4
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 50	 mov	 DWORD PTR r1$[rsp], eax
  00066	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0006a	c1 e8 08	 shr	 eax, 8
  0006d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00072	8b c0		 mov	 eax, eax
  00074	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00079	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0007d	c1 e8 14	 shr	 eax, 20
  00080	83 e0 0f	 and	 eax, 15
  00083	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00087	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 18	 shr	 eax, 24
  0008e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00093	89 44 24 38	 mov	 DWORD PTR l2$[rsp], eax
  00097	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009c	74 44		 je	 SHORT $LN8@z900_conve
  0009e	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a3	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000b8	48 03 c8	 add	 rcx, rax
  000bb	48 8b c1	 mov	 rax, rcx
  000be	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000c3	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d7	48 23 c8	 and	 rcx, rax
  000da	48 8b c1	 mov	 rax, rcx
  000dd	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_conve:
$LN4@z900_conve:
  000e2	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ea	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ee	48 83 c0 06	 add	 rax, 6
  000f2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000fe	33 c0		 xor	 eax, eax
  00100	83 f8 06	 cmp	 eax, 6
  00103	74 0f		 je	 SHORT $LN9@z900_conve
  00105	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010d	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_conve:
  00114	33 c0		 xor	 eax, eax
  00116	85 c0		 test	 eax, eax
  00118	75 c8		 jne	 SHORT $LN4@z900_conve

; 2883 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0011a	8b 54 24 34	 mov	 edx, DWORD PTR b2$[rsp]
  0011e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_conve:

; 2884 : 
; 2885 :     TXF_FLOAT_INSTR_CHECK( regs );

  0012b	33 c0		 xor	 eax, eax
  0012d	83 f8 01	 cmp	 eax, 1
  00130	0f 84 81 00 00
	00		 je	 $LN10@z900_conve
  00136	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00145	85 c0		 test	 eax, eax
  00147	74 6e		 je	 SHORT $LN10@z900_conve
  00149	33 c0		 xor	 eax, eax
  0014b	85 c0		 test	 eax, eax
  0014d	75 29		 jne	 SHORT $LN11@z900_conve
  0014f	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0015e	85 c0		 test	 eax, eax
  00160	75 16		 jne	 SHORT $LN11@z900_conve
  00162	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00171	83 e0 04	 and	 eax, 4
  00174	85 c0		 test	 eax, eax
  00176	75 3f		 jne	 SHORT $LN10@z900_conve
$LN11@z900_conve:
  00178	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00180	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00186	0f ba e8 0b	 bts	 eax, 11
  0018a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00198	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196327
  0019f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001a5	ba 02 00 00 00	 mov	 edx, 2
  001aa	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_conve:
  001b7	33 c0		 xor	 eax, eax
  001b9	85 c0		 test	 eax, eax
  001bb	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2886 :     DFPINST_CHECK(regs);

  001c1	b8 08 00 00 00	 mov	 eax, 8
  001c6	48 6b c0 01	 imul	 rax, rax, 1
  001ca	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001da	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e0	48 85 c0	 test	 rax, rax
  001e3	74 42		 je	 SHORT $LN13@z900_conve
  001e5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ed	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001f3	d1 e8		 shr	 eax, 1
  001f5	83 e0 01	 and	 eax, 1
  001f8	85 c0		 test	 eax, eax
  001fa	74 58		 je	 SHORT $LN12@z900_conve
  001fc	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00204	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0020b	b9 08 00 00 00	 mov	 ecx, 8
  00210	48 6b c9 01	 imul	 rcx, rcx, 1
  00214	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0021c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00222	48 85 c0	 test	 rax, rax
  00225	75 2d		 jne	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  00227	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00239	ba 07 00 00 00	 mov	 edx, 7
  0023e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_conve:

; 2887 : 
; 2888 :     /* Program check if operand length exceeds maximum */
; 2889 :     if (l2 > CDZT_MAXLEN-1)

  00254	83 7c 24 38 0f	 cmp	 DWORD PTR l2$[rsp], 15
  00259	7e 12		 jle	 SHORT $LN14@z900_conve

; 2890 :     {
; 2891 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0025b	ba 06 00 00 00	 mov	 edx, 6
  00260	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_conve:

; 2892 :     }
; 2893 : 
; 2894 :     /* Initialise the context for long DFP */
; 2895 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0026d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00272	48 8d 4c 24 60	 lea	 rcx, QWORD PTR set$[rsp]
  00277	e8 00 00 00 00	 call	 decContextDefault

; 2896 : 
; 2897 :     /* Fetch the zoned decimal operand into the work area */
; 2898 :     ARCH_DEP(vfetchc) (zoned, l2, effective_addr2, b2, regs);

  0027c	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00284	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00289	44 8b 4c 24 34	 mov	 r9d, DWORD PTR b2$[rsp]
  0028e	4c 8b 44 24 40	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  00293	0f b6 54 24 38	 movzx	 edx, BYTE PTR l2$[rsp]
  00298	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR zoned$[rsp]
  002a0	e8 00 00 00 00	 call	 z900_vfetchc

; 2899 : 
; 2900 :     /* Convert zoned decimal to decimal number structure */
; 2901 :     rc = dfp_number_from_zoned(&d, zoned, l2, m3, &set);

  002a5	48 8d 44 24 60	 lea	 rax, QWORD PTR set$[rsp]
  002aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002af	44 8b 4c 24 48	 mov	 r9d, DWORD PTR m3$[rsp]
  002b4	44 8b 44 24 38	 mov	 r8d, DWORD PTR l2$[rsp]
  002b9	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR zoned$[rsp]
  002c1	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR d$[rsp]
  002c9	e8 00 00 00 00	 call	 dfp_number_from_zoned
  002ce	89 44 24 4c	 mov	 DWORD PTR rc$[rsp], eax

; 2902 : 
; 2903 :     /* Program check if data exception is indicated */
; 2904 :     if (rc != 0)

  002d2	83 7c 24 4c 00	 cmp	 DWORD PTR rc$[rsp], 0
  002d7	74 24		 je	 SHORT $LN15@z900_conve

; 2905 :     {
; 2906 :         regs->dxc = DXC_DECIMAL;

  002d9	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e1	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 2907 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002eb	ba 07 00 00 00	 mov	 edx, 7
  002f0	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f8	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_conve:

; 2908 :     }
; 2909 : 
; 2910 :     /* Convert decimal number to long DFP format */
; 2911 :     decimal64FromNumber(&x1, &d, &set);

  002fd	4c 8d 44 24 60	 lea	 r8, QWORD PTR set$[rsp]
  00302	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d$[rsp]
  0030a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  0030f	e8 00 00 00 00	 call	 decimal64FromNumber

; 2912 : 
; 2913 :     /* Load result into FP register r1 */
; 2914 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  00314	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0031c	48 8d 54 24 58	 lea	 rdx, QWORD PTR x1$[rsp]
  00321	8b 4c 24 50	 mov	 ecx, DWORD PTR r1$[rsp]
  00325	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 2915 : 
; 2916 : } /* end DEF_INST(convert_zoned_to_dfp_long) */

  0032a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00332	48 33 cc	 xor	 rcx, rsp
  00335	e8 00 00 00 00	 call	 __security_check_cookie
  0033a	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00341	c3		 ret	 0
z900_convert_zoned_to_dfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 48
b2$ = 52
l2$ = 56
r1$ = 60
effective_addr2$ = 64
m3$ = 72
rc$ = 76
x1$ = 80
set$ = 96
d$ = 128
zoned$ = 168
__$ArrayPad$ = 208
inst$ = 240
regs$ = 248
z900_convert_zoned_to_dfp_ext PROC

; 2818 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2819 : int             rc;                     /* Return code               */
; 2820 : int             r1, m3;                 /* Values of R and M fields  */
; 2821 : int             l2;                     /* Operand length minus 1    */
; 2822 : int             b2;                     /* Base of effective addr    */
; 2823 : VADR            effective_addr2;        /* Effective address         */
; 2824 : decimal128      x1;                     /* Extended DFP value        */
; 2825 : decNumber       d;                      /* Working decimal number    */
; 2826 : decContext      set;                    /* Working context           */
; 2827 : char            zoned[CXZT_MAXLEN];     /* Zoned decimal operand     */
; 2828 : 
; 2829 :     RSL_RM(inst, regs, r1, l2, b2, effective_addr2, m3);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 01	 imul	 rax, rax, 1
  0002c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	48 03 c8	 add	 rcx, rax
  00037	48 8b c1	 mov	 rax, rcx
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00042	8b c8		 mov	 ecx, eax
  00044	e8 00 00 00 00	 call	 _byteswap_ulong
  00049	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 48	 mov	 DWORD PTR m3$[rsp], eax
  00058	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0005c	c1 e8 04	 shr	 eax, 4
  0005f	83 e0 0f	 and	 eax, 15
  00062	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00066	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0006a	c1 e8 08	 shr	 eax, 8
  0006d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00072	8b c0		 mov	 eax, eax
  00074	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00079	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0007d	c1 e8 14	 shr	 eax, 20
  00080	83 e0 0f	 and	 eax, 15
  00083	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00087	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0008b	c1 e8 18	 shr	 eax, 24
  0008e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00093	89 44 24 38	 mov	 DWORD PTR l2$[rsp], eax
  00097	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009c	74 44		 je	 SHORT $LN8@z900_conve
  0009e	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a3	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000b8	48 03 c8	 add	 rcx, rax
  000bb	48 8b c1	 mov	 rax, rcx
  000be	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000c3	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cb	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d7	48 23 c8	 and	 rcx, rax
  000da	48 8b c1	 mov	 rax, rcx
  000dd	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_conve:
$LN4@z900_conve:
  000e2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ea	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ee	48 83 c0 06	 add	 rax, 6
  000f2	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000fe	33 c0		 xor	 eax, eax
  00100	83 f8 06	 cmp	 eax, 6
  00103	74 0f		 je	 SHORT $LN9@z900_conve
  00105	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010d	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN9@z900_conve:
  00114	33 c0		 xor	 eax, eax
  00116	85 c0		 test	 eax, eax
  00118	75 c8		 jne	 SHORT $LN4@z900_conve

; 2830 :     PER_ZEROADDR_XCHECK( regs, b2 );

  0011a	8b 54 24 34	 mov	 edx, DWORD PTR b2$[rsp]
  0011e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_conve:

; 2831 : 
; 2832 :     TXF_FLOAT_INSTR_CHECK( regs );

  0012b	33 c0		 xor	 eax, eax
  0012d	83 f8 01	 cmp	 eax, 1
  00130	0f 84 81 00 00
	00		 je	 $LN10@z900_conve
  00136	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00145	85 c0		 test	 eax, eax
  00147	74 6e		 je	 SHORT $LN10@z900_conve
  00149	33 c0		 xor	 eax, eax
  0014b	85 c0		 test	 eax, eax
  0014d	75 29		 jne	 SHORT $LN11@z900_conve
  0014f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0015e	85 c0		 test	 eax, eax
  00160	75 16		 jne	 SHORT $LN11@z900_conve
  00162	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00171	83 e0 04	 and	 eax, 4
  00174	85 c0		 test	 eax, eax
  00176	75 3f		 jne	 SHORT $LN10@z900_conve
$LN11@z900_conve:
  00178	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00180	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00186	0f ba e8 0b	 bts	 eax, 11
  0018a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00198	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196295
  0019f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001a5	ba 02 00 00 00	 mov	 edx, 2
  001aa	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_conve:
  001b7	33 c0		 xor	 eax, eax
  001b9	85 c0		 test	 eax, eax
  001bb	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2833 :     DFPINST_CHECK(regs);

  001c1	b8 08 00 00 00	 mov	 eax, 8
  001c6	48 6b c0 01	 imul	 rax, rax, 1
  001ca	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001da	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e0	48 85 c0	 test	 rax, rax
  001e3	74 42		 je	 SHORT $LN13@z900_conve
  001e5	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ed	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001f3	d1 e8		 shr	 eax, 1
  001f5	83 e0 01	 and	 eax, 1
  001f8	85 c0		 test	 eax, eax
  001fa	74 58		 je	 SHORT $LN12@z900_conve
  001fc	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00204	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0020b	b9 08 00 00 00	 mov	 ecx, 8
  00210	48 6b c9 01	 imul	 rcx, rcx, 1
  00214	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0021c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00222	48 85 c0	 test	 rax, rax
  00225	75 2d		 jne	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  00227	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00239	ba 07 00 00 00	 mov	 edx, 7
  0023e	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_conve:

; 2834 :     DFPREGPAIR_CHECK(r1, regs);

  00254	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  00258	83 e0 02	 and	 eax, 2
  0025b	85 c0		 test	 eax, eax
  0025d	74 1b		 je	 SHORT $LN14@z900_conve
  0025f	ba 06 00 00 00	 mov	 edx, 6
  00264	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00274	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_conve:

; 2835 : 
; 2836 :     /* Program check if operand length exceeds maximum */
; 2837 :     if (l2 > CXZT_MAXLEN-1)

  0027a	83 7c 24 38 21	 cmp	 DWORD PTR l2$[rsp], 33	; 00000021H
  0027f	7e 12		 jle	 SHORT $LN15@z900_conve

; 2838 :     {
; 2839 :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00281	ba 06 00 00 00	 mov	 edx, 6
  00286	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028e	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_conve:

; 2840 :     }
; 2841 : 
; 2842 :     /* Initialise the context for extended DFP */
; 2843 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00293	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00298	48 8d 4c 24 60	 lea	 rcx, QWORD PTR set$[rsp]
  0029d	e8 00 00 00 00	 call	 decContextDefault

; 2844 : 
; 2845 :     /* Fetch the zoned decimal operand into the work area */
; 2846 :     ARCH_DEP(vfetchc) (zoned, l2, effective_addr2, b2, regs);

  002a2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002af	44 8b 4c 24 34	 mov	 r9d, DWORD PTR b2$[rsp]
  002b4	4c 8b 44 24 40	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  002b9	0f b6 54 24 38	 movzx	 edx, BYTE PTR l2$[rsp]
  002be	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR zoned$[rsp]
  002c6	e8 00 00 00 00	 call	 z900_vfetchc

; 2847 : 
; 2848 :     /* Convert zoned decimal to decimal number structure */
; 2849 :     rc = dfp_number_from_zoned(&d, zoned, l2, m3, &set);

  002cb	48 8d 44 24 60	 lea	 rax, QWORD PTR set$[rsp]
  002d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002d5	44 8b 4c 24 48	 mov	 r9d, DWORD PTR m3$[rsp]
  002da	44 8b 44 24 38	 mov	 r8d, DWORD PTR l2$[rsp]
  002df	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR zoned$[rsp]
  002e7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR d$[rsp]
  002ef	e8 00 00 00 00	 call	 dfp_number_from_zoned
  002f4	89 44 24 4c	 mov	 DWORD PTR rc$[rsp], eax

; 2850 : 
; 2851 :     /* Program check if data exception is indicated */
; 2852 :     if (rc != 0)

  002f8	83 7c 24 4c 00	 cmp	 DWORD PTR rc$[rsp], 0
  002fd	74 24		 je	 SHORT $LN16@z900_conve

; 2853 :     {
; 2854 :         regs->dxc = DXC_DECIMAL;

  002ff	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00307	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 2855 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00311	ba 07 00 00 00	 mov	 edx, 7
  00316	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031e	e8 00 00 00 00	 call	 z900_program_interrupt
$LN16@z900_conve:

; 2856 :     }
; 2857 : 
; 2858 :     /* Convert decimal number to extended DFP format */
; 2859 :     decimal128FromNumber(&x1, &d, &set);

  00323	4c 8d 44 24 60	 lea	 r8, QWORD PTR set$[rsp]
  00328	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d$[rsp]
  00330	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  00335	e8 00 00 00 00	 call	 decimal128FromNumber

; 2860 : 
; 2861 :     /* Load result into FP register r1 */
; 2862 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  0033a	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00342	48 8d 54 24 50	 lea	 rdx, QWORD PTR x1$[rsp]
  00347	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  0034b	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 2863 : 
; 2864 : } /* end DEF_INST(convert_zoned_to_dfp_ext) */

  00350	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00358	48 33 cc	 xor	 rcx, rsp
  0035b	e8 00 00 00 00	 call	 __security_check_cookie
  00360	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00367	c3		 ret	 0
z900_convert_zoned_to_dfp_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
effective_addr2$ = 40
x2$ = 48
b2$ = 52
x1$ = 56
r1$ = 60
bits$ = 64
lmd$ = 68
set$ = 72
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
z900_test_data_group_dfp_short PROC

; 5670 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5671 : int             r1;                     /* Value of R field          */
; 5672 : int             x2;                     /* Index register            */
; 5673 : int             b2;                     /* Base of effective addr    */
; 5674 : VADR            effective_addr2;        /* Effective address         */
; 5675 : decimal32       x1;                     /* Short DFP value           */
; 5676 : decNumber       d1;                     /* Working decimal number    */
; 5677 : decContext      set;                    /* Working context           */
; 5678 : U32             bits;                   /* Low 12 bits of address    */
; 5679 : int             lmd;                    /* Leftmost digit            */
; 5680 : 
; 5681 :     RXE(inst, regs, r1, x2, b2, effective_addr2);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	8b c0		 mov	 eax, eax
  00046	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004f	c1 e8 10	 shr	 eax, 16
  00052	83 e0 0f	 and	 eax, 15
  00055	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00059	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0005d	c1 e8 14	 shr	 eax, 20
  00060	83 e0 0f	 and	 eax, 15
  00063	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00067	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  0006c	74 25		 je	 SHORT $LN8@z900_test_
  0006e	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00073	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00083	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_test_:
  00093	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00097	c1 e8 0c	 shr	 eax, 12
  0009a	83 e0 0f	 and	 eax, 15
  0009d	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  000a1	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a6	74 25		 je	 SHORT $LN9@z900_test_
  000a8	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000bd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c2	48 03 c8	 add	 rcx, rax
  000c5	48 8b c1	 mov	 rax, rcx
  000c8	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_test_:
  000cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000dc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e1	48 23 c8	 and	 rcx, rax
  000e4	48 8b c1	 mov	 rax, rcx
  000e7	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_test_:
  000ec	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f8	48 83 c0 06	 add	 rax, 6
  000fc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00104	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00108	33 c0		 xor	 eax, eax
  0010a	83 f8 06	 cmp	 eax, 6
  0010d	74 0f		 je	 SHORT $LN10@z900_test_
  0010f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00117	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_test_:
  0011e	33 c0		 xor	 eax, eax
  00120	85 c0		 test	 eax, eax
  00122	75 c8		 jne	 SHORT $LN4@z900_test_
$LN7@z900_test_:

; 5682 : 
; 5683 :     TXF_FLOAT_INSTR_CHECK( regs );

  00124	33 c0		 xor	 eax, eax
  00126	83 f8 01	 cmp	 eax, 1
  00129	0f 84 81 00 00
	00		 je	 $LN11@z900_test_
  0012f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0013e	85 c0		 test	 eax, eax
  00140	74 6e		 je	 SHORT $LN11@z900_test_
  00142	33 c0		 xor	 eax, eax
  00144	85 c0		 test	 eax, eax
  00146	75 29		 jne	 SHORT $LN12@z900_test_
  00148	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00150	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00157	85 c0		 test	 eax, eax
  00159	75 16		 jne	 SHORT $LN12@z900_test_
  0015b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0016a	83 e0 04	 and	 eax, 4
  0016d	85 c0		 test	 eax, eax
  0016f	75 3f		 jne	 SHORT $LN11@z900_test_
$LN12@z900_test_:
  00171	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00179	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0017f	0f ba e8 0b	 bts	 eax, 11
  00183	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00191	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG198021
  00198	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0019e	ba 02 00 00 00	 mov	 edx, 2
  001a3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_test_:
  001b0	33 c0		 xor	 eax, eax
  001b2	85 c0		 test	 eax, eax
  001b4	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_test_

; 5684 :     DFPINST_CHECK(regs);

  001ba	b8 08 00 00 00	 mov	 eax, 8
  001bf	48 6b c0 01	 imul	 rax, rax, 1
  001c3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cb	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001d3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001d9	48 85 c0	 test	 rax, rax
  001dc	74 42		 je	 SHORT $LN14@z900_test_
  001de	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001ec	d1 e8		 shr	 eax, 1
  001ee	83 e0 01	 and	 eax, 1
  001f1	85 c0		 test	 eax, eax
  001f3	74 58		 je	 SHORT $LN13@z900_test_
  001f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00204	b9 08 00 00 00	 mov	 ecx, 8
  00209	48 6b c9 01	 imul	 rcx, rcx, 1
  0020d	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00215	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0021b	48 85 c0	 test	 rax, rax
  0021e	75 2d		 jne	 SHORT $LN13@z900_test_
$LN14@z900_test_:
  00220	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00228	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00232	ba 07 00 00 00	 mov	 edx, 7
  00237	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00247	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_test_:

; 5685 : 
; 5686 :     /* Initialise the context for short DFP */
; 5687 :     decContextDefault(&set, DEC_INIT_DECIMAL32);

  0024d	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00252	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00257	e8 00 00 00 00	 call	 decContextDefault

; 5688 : 
; 5689 :     /* Load DFP short number from FP register r1 */
; 5690 :     ARCH_DEP(dfp_reg_to_decimal32)(r1, &x1, regs);

  0025c	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00264	48 8d 54 24 38	 lea	 rdx, QWORD PTR x1$[rsp]
  00269	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  0026d	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal32

; 5691 : 
; 5692 :     /* Extract the leftmost digit from FP register r1 */
; 5693 :     lmd = dfp32_extract_lmd(&x1);

  00272	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  00277	e8 00 00 00 00	 call	 dfp32_extract_lmd
  0027c	89 44 24 44	 mov	 DWORD PTR lmd$[rsp], eax

; 5694 : 
; 5695 :     /* Convert to internal decimal number format */
; 5696 :     decimal32ToNumber(&x1, &d1);

  00280	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  00285	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  0028a	e8 00 00 00 00	 call	 decimal32ToNumber

; 5697 : 
; 5698 :     /* Isolate rightmost 12 bits of second operand address */
; 5699 :     bits = effective_addr2 & 0xFFF;

  0028f	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00294	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0029a	89 44 24 40	 mov	 DWORD PTR bits$[rsp], eax

; 5700 : 
; 5701 :     /* Test data group and set condition code */
; 5702 :     regs->psw.cc = dfp_test_data_group(&set, &d1, lmd, bits);

  0029e	44 8b 4c 24 40	 mov	 r9d, DWORD PTR bits$[rsp]
  002a3	44 8b 44 24 44	 mov	 r8d, DWORD PTR lmd$[rsp]
  002a8	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  002ad	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  002b2	e8 00 00 00 00	 call	 dfp_test_data_group
  002b7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bf	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 5703 : 
; 5704 : } /* end DEF_INST(test_data_group_dfp_short) */

  002c2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002ca	48 33 cc	 xor	 rcx, rsp
  002cd	e8 00 00 00 00	 call	 __security_check_cookie
  002d2	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002d9	c3		 ret	 0
z900_test_data_group_dfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
effective_addr2$ = 40
x2$ = 48
b2$ = 52
r1$ = 56
bits$ = 60
lmd$ = 64
x1$ = 72
set$ = 80
d1$ = 112
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
z900_test_data_group_dfp_long PROC

; 5629 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5630 : int             r1;                     /* Value of R field          */
; 5631 : int             x2;                     /* Index register            */
; 5632 : int             b2;                     /* Base of effective addr    */
; 5633 : VADR            effective_addr2;        /* Effective address         */
; 5634 : decimal64       x1;                     /* Long DFP value            */
; 5635 : decNumber       d1;                     /* Working decimal number    */
; 5636 : decContext      set;                    /* Working context           */
; 5637 : U32             bits;                   /* Low 12 bits of address    */
; 5638 : int             lmd;                    /* Leftmost digit            */
; 5639 : 
; 5640 :     RXE(inst, regs, r1, x2, b2, effective_addr2);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	8b c0		 mov	 eax, eax
  00046	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004f	c1 e8 10	 shr	 eax, 16
  00052	83 e0 0f	 and	 eax, 15
  00055	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00059	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0005d	c1 e8 14	 shr	 eax, 20
  00060	83 e0 0f	 and	 eax, 15
  00063	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00067	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  0006c	74 25		 je	 SHORT $LN8@z900_test_
  0006e	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00073	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00083	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_test_:
  00093	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00097	c1 e8 0c	 shr	 eax, 12
  0009a	83 e0 0f	 and	 eax, 15
  0009d	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  000a1	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a6	74 25		 je	 SHORT $LN9@z900_test_
  000a8	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000bd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c2	48 03 c8	 add	 rcx, rax
  000c5	48 8b c1	 mov	 rax, rcx
  000c8	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_test_:
  000cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000dc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e1	48 23 c8	 and	 rcx, rax
  000e4	48 8b c1	 mov	 rax, rcx
  000e7	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_test_:
  000ec	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f8	48 83 c0 06	 add	 rax, 6
  000fc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00104	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00108	33 c0		 xor	 eax, eax
  0010a	83 f8 06	 cmp	 eax, 6
  0010d	74 0f		 je	 SHORT $LN10@z900_test_
  0010f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00117	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_test_:
  0011e	33 c0		 xor	 eax, eax
  00120	85 c0		 test	 eax, eax
  00122	75 c8		 jne	 SHORT $LN4@z900_test_
$LN7@z900_test_:

; 5641 : 
; 5642 :     TXF_FLOAT_INSTR_CHECK( regs );

  00124	33 c0		 xor	 eax, eax
  00126	83 f8 01	 cmp	 eax, 1
  00129	0f 84 81 00 00
	00		 je	 $LN11@z900_test_
  0012f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0013e	85 c0		 test	 eax, eax
  00140	74 6e		 je	 SHORT $LN11@z900_test_
  00142	33 c0		 xor	 eax, eax
  00144	85 c0		 test	 eax, eax
  00146	75 29		 jne	 SHORT $LN12@z900_test_
  00148	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00150	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00157	85 c0		 test	 eax, eax
  00159	75 16		 jne	 SHORT $LN12@z900_test_
  0015b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0016a	83 e0 04	 and	 eax, 4
  0016d	85 c0		 test	 eax, eax
  0016f	75 3f		 jne	 SHORT $LN11@z900_test_
$LN12@z900_test_:
  00171	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00179	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0017f	0f ba e8 0b	 bts	 eax, 11
  00183	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00191	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197992
  00198	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0019e	ba 02 00 00 00	 mov	 edx, 2
  001a3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_test_:
  001b0	33 c0		 xor	 eax, eax
  001b2	85 c0		 test	 eax, eax
  001b4	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_test_

; 5643 :     DFPINST_CHECK(regs);

  001ba	b8 08 00 00 00	 mov	 eax, 8
  001bf	48 6b c0 01	 imul	 rax, rax, 1
  001c3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cb	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001d3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001d9	48 85 c0	 test	 rax, rax
  001dc	74 42		 je	 SHORT $LN14@z900_test_
  001de	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001ec	d1 e8		 shr	 eax, 1
  001ee	83 e0 01	 and	 eax, 1
  001f1	85 c0		 test	 eax, eax
  001f3	74 58		 je	 SHORT $LN13@z900_test_
  001f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00204	b9 08 00 00 00	 mov	 ecx, 8
  00209	48 6b c9 01	 imul	 rcx, rcx, 1
  0020d	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00215	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0021b	48 85 c0	 test	 rax, rax
  0021e	75 2d		 jne	 SHORT $LN13@z900_test_
$LN14@z900_test_:
  00220	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00228	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00232	ba 07 00 00 00	 mov	 edx, 7
  00237	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00247	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_test_:

; 5644 : 
; 5645 :     /* Initialise the context for long DFP */
; 5646 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0024d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00252	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00257	e8 00 00 00 00	 call	 decContextDefault

; 5647 : 
; 5648 :     /* Load DFP long number from FP register r1 */
; 5649 :     ARCH_DEP(dfp_reg_to_decimal64)(r1, &x1, regs);

  0025c	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00264	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  00269	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  0026d	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 5650 : 
; 5651 :     /* Extract the leftmost digit from FP register r1 */
; 5652 :     lmd = dfp64_extract_lmd(&x1);

  00272	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00277	e8 00 00 00 00	 call	 dfp64_extract_lmd
  0027c	89 44 24 40	 mov	 DWORD PTR lmd$[rsp], eax

; 5653 : 
; 5654 :     /* Convert to internal decimal number format */
; 5655 :     decimal64ToNumber(&x1, &d1);

  00280	48 8d 54 24 70	 lea	 rdx, QWORD PTR d1$[rsp]
  00285	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  0028a	e8 00 00 00 00	 call	 decimal64ToNumber

; 5656 : 
; 5657 :     /* Isolate rightmost 12 bits of second operand address */
; 5658 :     bits = effective_addr2 & 0xFFF;

  0028f	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00294	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0029a	89 44 24 3c	 mov	 DWORD PTR bits$[rsp], eax

; 5659 : 
; 5660 :     /* Test data group and set condition code */
; 5661 :     regs->psw.cc = dfp_test_data_group(&set, &d1, lmd, bits);

  0029e	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR bits$[rsp]
  002a3	44 8b 44 24 40	 mov	 r8d, DWORD PTR lmd$[rsp]
  002a8	48 8d 54 24 70	 lea	 rdx, QWORD PTR d1$[rsp]
  002ad	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  002b2	e8 00 00 00 00	 call	 dfp_test_data_group
  002b7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bf	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 5662 : 
; 5663 : } /* end DEF_INST(test_data_group_dfp_long) */

  002c2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002ca	48 33 cc	 xor	 rcx, rsp
  002cd	e8 00 00 00 00	 call	 __security_check_cookie
  002d2	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002d9	c3		 ret	 0
z900_test_data_group_dfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
effective_addr2$ = 40
x2$ = 48
b2$ = 52
r1$ = 56
bits$ = 60
lmd$ = 64
x1$ = 72
set$ = 88
d1$ = 120
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
z900_test_data_group_dfp_ext PROC

; 5587 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5588 : int             r1;                     /* Value of R field          */
; 5589 : int             x2;                     /* Index register            */
; 5590 : int             b2;                     /* Base of effective addr    */
; 5591 : VADR            effective_addr2;        /* Effective address         */
; 5592 : decimal128      x1;                     /* Extended DFP value        */
; 5593 : decNumber       d1;                     /* Working decimal number    */
; 5594 : decContext      set;                    /* Working context           */
; 5595 : U32             bits;                   /* Low 12 bits of address    */
; 5596 : int             lmd;                    /* Leftmost digit            */
; 5597 : 
; 5598 :     RXE(inst, regs, r1, x2, b2, effective_addr2);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	8b c0		 mov	 eax, eax
  00046	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004f	c1 e8 10	 shr	 eax, 16
  00052	83 e0 0f	 and	 eax, 15
  00055	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00059	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0005d	c1 e8 14	 shr	 eax, 20
  00060	83 e0 0f	 and	 eax, 15
  00063	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00067	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  0006c	74 25		 je	 SHORT $LN8@z900_test_
  0006e	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00073	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00083	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_test_:
  00093	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00097	c1 e8 0c	 shr	 eax, 12
  0009a	83 e0 0f	 and	 eax, 15
  0009d	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  000a1	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a6	74 25		 je	 SHORT $LN9@z900_test_
  000a8	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ad	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000bd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c2	48 03 c8	 add	 rcx, rax
  000c5	48 8b c1	 mov	 rax, rcx
  000c8	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_test_:
  000cd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000dc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e1	48 23 c8	 and	 rcx, rax
  000e4	48 8b c1	 mov	 rax, rcx
  000e7	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_test_:
  000ec	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f8	48 83 c0 06	 add	 rax, 6
  000fc	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00104	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00108	33 c0		 xor	 eax, eax
  0010a	83 f8 06	 cmp	 eax, 6
  0010d	74 0f		 je	 SHORT $LN10@z900_test_
  0010f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00117	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_test_:
  0011e	33 c0		 xor	 eax, eax
  00120	85 c0		 test	 eax, eax
  00122	75 c8		 jne	 SHORT $LN4@z900_test_
$LN7@z900_test_:

; 5599 : 
; 5600 :     TXF_FLOAT_INSTR_CHECK( regs );

  00124	33 c0		 xor	 eax, eax
  00126	83 f8 01	 cmp	 eax, 1
  00129	0f 84 81 00 00
	00		 je	 $LN11@z900_test_
  0012f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0013e	85 c0		 test	 eax, eax
  00140	74 6e		 je	 SHORT $LN11@z900_test_
  00142	33 c0		 xor	 eax, eax
  00144	85 c0		 test	 eax, eax
  00146	75 29		 jne	 SHORT $LN12@z900_test_
  00148	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00150	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00157	85 c0		 test	 eax, eax
  00159	75 16		 jne	 SHORT $LN12@z900_test_
  0015b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0016a	83 e0 04	 and	 eax, 4
  0016d	85 c0		 test	 eax, eax
  0016f	75 3f		 jne	 SHORT $LN11@z900_test_
$LN12@z900_test_:
  00171	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00179	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0017f	0f ba e8 0b	 bts	 eax, 11
  00183	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00191	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197962
  00198	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0019e	ba 02 00 00 00	 mov	 edx, 2
  001a3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_test_:
  001b0	33 c0		 xor	 eax, eax
  001b2	85 c0		 test	 eax, eax
  001b4	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_test_

; 5601 :     DFPINST_CHECK(regs);

  001ba	b8 08 00 00 00	 mov	 eax, 8
  001bf	48 6b c0 01	 imul	 rax, rax, 1
  001c3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cb	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001d3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001d9	48 85 c0	 test	 rax, rax
  001dc	74 42		 je	 SHORT $LN14@z900_test_
  001de	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001ec	d1 e8		 shr	 eax, 1
  001ee	83 e0 01	 and	 eax, 1
  001f1	85 c0		 test	 eax, eax
  001f3	74 58		 je	 SHORT $LN13@z900_test_
  001f5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00204	b9 08 00 00 00	 mov	 ecx, 8
  00209	48 6b c9 01	 imul	 rcx, rcx, 1
  0020d	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00215	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0021b	48 85 c0	 test	 rax, rax
  0021e	75 2d		 jne	 SHORT $LN13@z900_test_
$LN14@z900_test_:
  00220	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00228	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00232	ba 07 00 00 00	 mov	 edx, 7
  00237	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00247	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_test_:

; 5602 :     DFPREGPAIR_CHECK(r1, regs);

  0024d	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00251	83 e0 02	 and	 eax, 2
  00254	85 c0		 test	 eax, eax
  00256	74 1b		 je	 SHORT $LN15@z900_test_
  00258	ba 06 00 00 00	 mov	 edx, 6
  0025d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00265	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_test_:

; 5603 : 
; 5604 :     /* Initialise the context for extended DFP */
; 5605 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00273	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00278	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  0027d	e8 00 00 00 00	 call	 decContextDefault

; 5606 : 
; 5607 :     /* Load DFP extended number from FP register r1 */
; 5608 :     ARCH_DEP(dfp_reg_to_decimal128)(r1, &x1, regs);

  00282	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0028a	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  0028f	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  00293	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 5609 : 
; 5610 :     /* Extract the leftmost digit from FP register r1 */
; 5611 :     lmd = dfp128_extract_lmd(&x1);

  00298	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  0029d	e8 00 00 00 00	 call	 dfp128_extract_lmd
  002a2	89 44 24 40	 mov	 DWORD PTR lmd$[rsp], eax

; 5612 : 
; 5613 :     /* Convert to internal decimal number format */
; 5614 :     decimal128ToNumber(&x1, &d1);

  002a6	48 8d 54 24 78	 lea	 rdx, QWORD PTR d1$[rsp]
  002ab	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  002b0	e8 00 00 00 00	 call	 decimal128ToNumber

; 5615 : 
; 5616 :     /* Isolate rightmost 12 bits of second operand address */
; 5617 :     bits = effective_addr2 & 0xFFF;

  002b5	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  002ba	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  002c0	89 44 24 3c	 mov	 DWORD PTR bits$[rsp], eax

; 5618 : 
; 5619 :     /* Test data group and set condition code */
; 5620 :     regs->psw.cc = dfp_test_data_group(&set, &d1, lmd, bits);

  002c4	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR bits$[rsp]
  002c9	44 8b 44 24 40	 mov	 r8d, DWORD PTR lmd$[rsp]
  002ce	48 8d 54 24 78	 lea	 rdx, QWORD PTR d1$[rsp]
  002d3	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  002d8	e8 00 00 00 00	 call	 dfp_test_data_group
  002dd	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e5	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 5621 : 
; 5622 : } /* end DEF_INST(test_data_group_dfp_ext) */

  002e8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002f0	48 33 cc	 xor	 rcx, rsp
  002f3	e8 00 00 00 00	 call	 __security_check_cookie
  002f8	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  002ff	c3		 ret	 0
z900_test_data_group_dfp_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
effective_addr2$ = 40
x2$ = 48
b2$ = 52
r1$ = 56
x1$ = 60
bits$ = 64
set$ = 72
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
z900_test_data_class_dfp_short PROC

; 5552 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5553 : int             r1;                     /* Value of R field          */
; 5554 : int             x2;                     /* Index register            */
; 5555 : int             b2;                     /* Base of effective addr    */
; 5556 : VADR            effective_addr2;        /* Effective address         */
; 5557 : decimal32       x1;                     /* Short DFP value           */
; 5558 : decNumber       d1;                     /* Working decimal number    */
; 5559 : decContext      set;                    /* Working context           */
; 5560 : U32             bits;                   /* Low 12 bits of address    */
; 5561 : 
; 5562 :     RXE(inst, regs, r1, x2, b2, effective_addr2);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	8b c0		 mov	 eax, eax
  00046	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004f	c1 e8 10	 shr	 eax, 16
  00052	83 e0 0f	 and	 eax, 15
  00055	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00059	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0005d	c1 e8 14	 shr	 eax, 20
  00060	83 e0 0f	 and	 eax, 15
  00063	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00067	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  0006c	74 25		 je	 SHORT $LN8@z900_test_
  0006e	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00073	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00083	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_test_:
  00093	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00097	c1 e8 0c	 shr	 eax, 12
  0009a	83 e0 0f	 and	 eax, 15
  0009d	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  000a1	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a6	74 25		 je	 SHORT $LN9@z900_test_
  000a8	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000bd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c2	48 03 c8	 add	 rcx, rax
  000c5	48 8b c1	 mov	 rax, rcx
  000c8	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_test_:
  000cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000dc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e1	48 23 c8	 and	 rcx, rax
  000e4	48 8b c1	 mov	 rax, rcx
  000e7	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_test_:
  000ec	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f8	48 83 c0 06	 add	 rax, 6
  000fc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00104	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00108	33 c0		 xor	 eax, eax
  0010a	83 f8 06	 cmp	 eax, 6
  0010d	74 0f		 je	 SHORT $LN10@z900_test_
  0010f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00117	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_test_:
  0011e	33 c0		 xor	 eax, eax
  00120	85 c0		 test	 eax, eax
  00122	75 c8		 jne	 SHORT $LN4@z900_test_
$LN7@z900_test_:

; 5563 : 
; 5564 :     TXF_FLOAT_INSTR_CHECK( regs );

  00124	33 c0		 xor	 eax, eax
  00126	83 f8 01	 cmp	 eax, 1
  00129	0f 84 81 00 00
	00		 je	 $LN11@z900_test_
  0012f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0013e	85 c0		 test	 eax, eax
  00140	74 6e		 je	 SHORT $LN11@z900_test_
  00142	33 c0		 xor	 eax, eax
  00144	85 c0		 test	 eax, eax
  00146	75 29		 jne	 SHORT $LN12@z900_test_
  00148	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00150	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00157	85 c0		 test	 eax, eax
  00159	75 16		 jne	 SHORT $LN12@z900_test_
  0015b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0016a	83 e0 04	 and	 eax, 4
  0016d	85 c0		 test	 eax, eax
  0016f	75 3f		 jne	 SHORT $LN11@z900_test_
$LN12@z900_test_:
  00171	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00179	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0017f	0f ba e8 0b	 bts	 eax, 11
  00183	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00191	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197933
  00198	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0019e	ba 02 00 00 00	 mov	 edx, 2
  001a3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_test_:
  001b0	33 c0		 xor	 eax, eax
  001b2	85 c0		 test	 eax, eax
  001b4	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_test_

; 5565 :     DFPINST_CHECK(regs);

  001ba	b8 08 00 00 00	 mov	 eax, 8
  001bf	48 6b c0 01	 imul	 rax, rax, 1
  001c3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cb	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001d3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001d9	48 85 c0	 test	 rax, rax
  001dc	74 42		 je	 SHORT $LN14@z900_test_
  001de	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001ec	d1 e8		 shr	 eax, 1
  001ee	83 e0 01	 and	 eax, 1
  001f1	85 c0		 test	 eax, eax
  001f3	74 58		 je	 SHORT $LN13@z900_test_
  001f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00204	b9 08 00 00 00	 mov	 ecx, 8
  00209	48 6b c9 01	 imul	 rcx, rcx, 1
  0020d	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00215	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0021b	48 85 c0	 test	 rax, rax
  0021e	75 2d		 jne	 SHORT $LN13@z900_test_
$LN14@z900_test_:
  00220	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00228	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00232	ba 07 00 00 00	 mov	 edx, 7
  00237	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00247	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_test_:

; 5566 : 
; 5567 :     /* Initialise the context for short DFP */
; 5568 :     decContextDefault(&set, DEC_INIT_DECIMAL32);

  0024d	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00252	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00257	e8 00 00 00 00	 call	 decContextDefault

; 5569 : 
; 5570 :     /* Convert FP register r1 to decimal number format */
; 5571 :     ARCH_DEP(dfp_reg_to_decimal32)(r1, &x1, regs);

  0025c	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00264	48 8d 54 24 3c	 lea	 rdx, QWORD PTR x1$[rsp]
  00269	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  0026d	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal32

; 5572 :     decimal32ToNumber(&x1, &d1);

  00272	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  00277	48 8d 4c 24 3c	 lea	 rcx, QWORD PTR x1$[rsp]
  0027c	e8 00 00 00 00	 call	 decimal32ToNumber

; 5573 : 
; 5574 :     /* Isolate rightmost 12 bits of second operand address */
; 5575 :     bits = effective_addr2 & 0xFFF;

  00281	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00286	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0028c	89 44 24 40	 mov	 DWORD PTR bits$[rsp], eax

; 5576 : 
; 5577 :     /* Test data class and set condition code */
; 5578 :     regs->psw.cc = dfp_test_data_class(&set, &d1, bits);

  00290	44 8b 44 24 40	 mov	 r8d, DWORD PTR bits$[rsp]
  00295	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  0029a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  0029f	e8 00 00 00 00	 call	 dfp_test_data_class
  002a4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ac	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 5579 : 
; 5580 : } /* end DEF_INST(test_data_class_dfp_short) */

  002af	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002b7	48 33 cc	 xor	 rcx, rsp
  002ba	e8 00 00 00 00	 call	 __security_check_cookie
  002bf	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002c6	c3		 ret	 0
z900_test_data_class_dfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
effective_addr2$ = 40
x2$ = 48
b2$ = 52
r1$ = 56
bits$ = 60
x1$ = 64
set$ = 72
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
z900_test_data_class_dfp_long PROC

; 5517 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5518 : int             r1;                     /* Value of R field          */
; 5519 : int             x2;                     /* Index register            */
; 5520 : int             b2;                     /* Base of effective addr    */
; 5521 : VADR            effective_addr2;        /* Effective address         */
; 5522 : decimal64       x1;                     /* Long DFP value            */
; 5523 : decNumber       d1;                     /* Working decimal number    */
; 5524 : decContext      set;                    /* Working context           */
; 5525 : U32             bits;                   /* Low 12 bits of address    */
; 5526 : 
; 5527 :     RXE(inst, regs, r1, x2, b2, effective_addr2);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	8b c0		 mov	 eax, eax
  00046	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004f	c1 e8 10	 shr	 eax, 16
  00052	83 e0 0f	 and	 eax, 15
  00055	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00059	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0005d	c1 e8 14	 shr	 eax, 20
  00060	83 e0 0f	 and	 eax, 15
  00063	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00067	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  0006c	74 25		 je	 SHORT $LN8@z900_test_
  0006e	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00073	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00083	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_test_:
  00093	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00097	c1 e8 0c	 shr	 eax, 12
  0009a	83 e0 0f	 and	 eax, 15
  0009d	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  000a1	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a6	74 25		 je	 SHORT $LN9@z900_test_
  000a8	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000bd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c2	48 03 c8	 add	 rcx, rax
  000c5	48 8b c1	 mov	 rax, rcx
  000c8	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_test_:
  000cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000dc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e1	48 23 c8	 and	 rcx, rax
  000e4	48 8b c1	 mov	 rax, rcx
  000e7	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_test_:
  000ec	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f8	48 83 c0 06	 add	 rax, 6
  000fc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00104	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00108	33 c0		 xor	 eax, eax
  0010a	83 f8 06	 cmp	 eax, 6
  0010d	74 0f		 je	 SHORT $LN10@z900_test_
  0010f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00117	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_test_:
  0011e	33 c0		 xor	 eax, eax
  00120	85 c0		 test	 eax, eax
  00122	75 c8		 jne	 SHORT $LN4@z900_test_
$LN7@z900_test_:

; 5528 : 
; 5529 :     TXF_FLOAT_INSTR_CHECK( regs );

  00124	33 c0		 xor	 eax, eax
  00126	83 f8 01	 cmp	 eax, 1
  00129	0f 84 81 00 00
	00		 je	 $LN11@z900_test_
  0012f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0013e	85 c0		 test	 eax, eax
  00140	74 6e		 je	 SHORT $LN11@z900_test_
  00142	33 c0		 xor	 eax, eax
  00144	85 c0		 test	 eax, eax
  00146	75 29		 jne	 SHORT $LN12@z900_test_
  00148	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00150	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00157	85 c0		 test	 eax, eax
  00159	75 16		 jne	 SHORT $LN12@z900_test_
  0015b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0016a	83 e0 04	 and	 eax, 4
  0016d	85 c0		 test	 eax, eax
  0016f	75 3f		 jne	 SHORT $LN11@z900_test_
$LN12@z900_test_:
  00171	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00179	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0017f	0f ba e8 0b	 bts	 eax, 11
  00183	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00191	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197905
  00198	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0019e	ba 02 00 00 00	 mov	 edx, 2
  001a3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_test_:
  001b0	33 c0		 xor	 eax, eax
  001b2	85 c0		 test	 eax, eax
  001b4	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_test_

; 5530 :     DFPINST_CHECK(regs);

  001ba	b8 08 00 00 00	 mov	 eax, 8
  001bf	48 6b c0 01	 imul	 rax, rax, 1
  001c3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cb	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001d3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001d9	48 85 c0	 test	 rax, rax
  001dc	74 42		 je	 SHORT $LN14@z900_test_
  001de	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001ec	d1 e8		 shr	 eax, 1
  001ee	83 e0 01	 and	 eax, 1
  001f1	85 c0		 test	 eax, eax
  001f3	74 58		 je	 SHORT $LN13@z900_test_
  001f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00204	b9 08 00 00 00	 mov	 ecx, 8
  00209	48 6b c9 01	 imul	 rcx, rcx, 1
  0020d	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00215	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0021b	48 85 c0	 test	 rax, rax
  0021e	75 2d		 jne	 SHORT $LN13@z900_test_
$LN14@z900_test_:
  00220	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00228	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00232	ba 07 00 00 00	 mov	 edx, 7
  00237	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00247	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_test_:

; 5531 : 
; 5532 :     /* Initialise the context for long DFP */
; 5533 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0024d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00252	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00257	e8 00 00 00 00	 call	 decContextDefault

; 5534 : 
; 5535 :     /* Convert FP register r1 to decimal number format */
; 5536 :     ARCH_DEP(dfp_reg_to_decimal64)(r1, &x1, regs);

  0025c	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00264	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  00269	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  0026d	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 5537 :     decimal64ToNumber(&x1, &d1);

  00272	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  00277	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  0027c	e8 00 00 00 00	 call	 decimal64ToNumber

; 5538 : 
; 5539 :     /* Isolate rightmost 12 bits of second operand address */
; 5540 :     bits = effective_addr2 & 0xFFF;

  00281	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00286	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0028c	89 44 24 3c	 mov	 DWORD PTR bits$[rsp], eax

; 5541 : 
; 5542 :     /* Test data class and set condition code */
; 5543 :     regs->psw.cc = dfp_test_data_class(&set, &d1, bits);

  00290	44 8b 44 24 3c	 mov	 r8d, DWORD PTR bits$[rsp]
  00295	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  0029a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  0029f	e8 00 00 00 00	 call	 dfp_test_data_class
  002a4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ac	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 5544 : 
; 5545 : } /* end DEF_INST(test_data_class_dfp_long) */

  002af	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002b7	48 33 cc	 xor	 rcx, rsp
  002ba	e8 00 00 00 00	 call	 __security_check_cookie
  002bf	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002c6	c3		 ret	 0
z900_test_data_class_dfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
effective_addr2$ = 40
x2$ = 48
b2$ = 52
r1$ = 56
bits$ = 60
x1$ = 64
set$ = 80
d1$ = 112
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
z900_test_data_class_dfp_ext PROC

; 5481 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5482 : int             r1;                     /* Value of R field          */
; 5483 : int             x2;                     /* Index register            */
; 5484 : int             b2;                     /* Base of effective addr    */
; 5485 : VADR            effective_addr2;        /* Effective address         */
; 5486 : decimal128      x1;                     /* Extended DFP value        */
; 5487 : decNumber       d1;                     /* Working decimal number    */
; 5488 : decContext      set;                    /* Working context           */
; 5489 : U32             bits;                   /* Low 12 bits of address    */
; 5490 : 
; 5491 :     RXE(inst, regs, r1, x2, b2, effective_addr2);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	8b c0		 mov	 eax, eax
  00046	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004f	c1 e8 10	 shr	 eax, 16
  00052	83 e0 0f	 and	 eax, 15
  00055	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00059	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0005d	c1 e8 14	 shr	 eax, 20
  00060	83 e0 0f	 and	 eax, 15
  00063	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00067	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  0006c	74 25		 je	 SHORT $LN8@z900_test_
  0006e	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  00073	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00083	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_test_:
  00093	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00097	c1 e8 0c	 shr	 eax, 12
  0009a	83 e0 0f	 and	 eax, 15
  0009d	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  000a1	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a6	74 25		 je	 SHORT $LN9@z900_test_
  000a8	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000bd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c2	48 03 c8	 add	 rcx, rax
  000c5	48 8b c1	 mov	 rax, rcx
  000c8	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_test_:
  000cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000dc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e1	48 23 c8	 and	 rcx, rax
  000e4	48 8b c1	 mov	 rax, rcx
  000e7	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_test_:
  000ec	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f8	48 83 c0 06	 add	 rax, 6
  000fc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00104	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00108	33 c0		 xor	 eax, eax
  0010a	83 f8 06	 cmp	 eax, 6
  0010d	74 0f		 je	 SHORT $LN10@z900_test_
  0010f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00117	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_test_:
  0011e	33 c0		 xor	 eax, eax
  00120	85 c0		 test	 eax, eax
  00122	75 c8		 jne	 SHORT $LN4@z900_test_
$LN7@z900_test_:

; 5492 : 
; 5493 :     TXF_FLOAT_INSTR_CHECK( regs );

  00124	33 c0		 xor	 eax, eax
  00126	83 f8 01	 cmp	 eax, 1
  00129	0f 84 81 00 00
	00		 je	 $LN11@z900_test_
  0012f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0013e	85 c0		 test	 eax, eax
  00140	74 6e		 je	 SHORT $LN11@z900_test_
  00142	33 c0		 xor	 eax, eax
  00144	85 c0		 test	 eax, eax
  00146	75 29		 jne	 SHORT $LN12@z900_test_
  00148	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00150	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00157	85 c0		 test	 eax, eax
  00159	75 16		 jne	 SHORT $LN12@z900_test_
  0015b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  0016a	83 e0 04	 and	 eax, 4
  0016d	85 c0		 test	 eax, eax
  0016f	75 3f		 jne	 SHORT $LN11@z900_test_
$LN12@z900_test_:
  00171	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00179	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0017f	0f ba e8 0b	 bts	 eax, 11
  00183	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00191	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197876
  00198	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0019e	ba 02 00 00 00	 mov	 edx, 2
  001a3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_test_:
  001b0	33 c0		 xor	 eax, eax
  001b2	85 c0		 test	 eax, eax
  001b4	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_test_

; 5494 :     DFPINST_CHECK(regs);

  001ba	b8 08 00 00 00	 mov	 eax, 8
  001bf	48 6b c0 01	 imul	 rax, rax, 1
  001c3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cb	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001d3	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001d9	48 85 c0	 test	 rax, rax
  001dc	74 42		 je	 SHORT $LN14@z900_test_
  001de	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001ec	d1 e8		 shr	 eax, 1
  001ee	83 e0 01	 and	 eax, 1
  001f1	85 c0		 test	 eax, eax
  001f3	74 58		 je	 SHORT $LN13@z900_test_
  001f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00204	b9 08 00 00 00	 mov	 ecx, 8
  00209	48 6b c9 01	 imul	 rcx, rcx, 1
  0020d	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00215	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0021b	48 85 c0	 test	 rax, rax
  0021e	75 2d		 jne	 SHORT $LN13@z900_test_
$LN14@z900_test_:
  00220	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00228	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00232	ba 07 00 00 00	 mov	 edx, 7
  00237	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00247	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_test_:

; 5495 :     DFPREGPAIR_CHECK(r1, regs);

  0024d	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00251	83 e0 02	 and	 eax, 2
  00254	85 c0		 test	 eax, eax
  00256	74 1b		 je	 SHORT $LN15@z900_test_
  00258	ba 06 00 00 00	 mov	 edx, 6
  0025d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00265	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_test_:

; 5496 : 
; 5497 :     /* Initialise the context for extended DFP */
; 5498 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00273	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00278	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0027d	e8 00 00 00 00	 call	 decContextDefault

; 5499 : 
; 5500 :     /* Convert FP register r1 to decimal number format */
; 5501 :     ARCH_DEP(dfp_reg_to_decimal128)(r1, &x1, regs);

  00282	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0028a	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  0028f	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  00293	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 5502 :     decimal128ToNumber(&x1, &d1);

  00298	48 8d 54 24 70	 lea	 rdx, QWORD PTR d1$[rsp]
  0029d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002a2	e8 00 00 00 00	 call	 decimal128ToNumber

; 5503 : 
; 5504 :     /* Isolate rightmost 12 bits of second operand address */
; 5505 :     bits = effective_addr2 & 0xFFF;

  002a7	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  002ac	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  002b2	89 44 24 3c	 mov	 DWORD PTR bits$[rsp], eax

; 5506 : 
; 5507 :     /* Test data class and set condition code */
; 5508 :     regs->psw.cc = dfp_test_data_class(&set, &d1, bits);

  002b6	44 8b 44 24 3c	 mov	 r8d, DWORD PTR bits$[rsp]
  002bb	48 8d 54 24 70	 lea	 rdx, QWORD PTR d1$[rsp]
  002c0	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  002c5	e8 00 00 00 00	 call	 dfp_test_data_class
  002ca	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d2	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 5509 : 
; 5510 : } /* end DEF_INST(test_data_class_dfp_ext) */

  002d5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002dd	48 33 cc	 xor	 rcx, rsp
  002e0	e8 00 00 00 00	 call	 __security_check_cookie
  002e5	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002ec	c3		 ret	 0
z900_test_data_class_dfp_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv195 = 40
tv196 = 44
tv197 = 48
r2$ = 52
r3$ = 56
r1$ = 60
x2$ = 64
x3$ = 72
x1$ = 80
d1$ = 88
set$ = 128
d3$ = 160
d2$ = 200
__$ArrayPad$ = 240
inst$ = 272
regs$ = 280
z900_subtract_dfp_long_reg PROC

; 5432 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5433 : int             r1, r2, r3;             /* Values of R fields        */
; 5434 : decimal64       x1, x2, x3;             /* Long DFP values           */
; 5435 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 5436 : decContext      set;                    /* Working context           */
; 5437 : BYTE            dxc;                    /* Data exception code       */
; 5438 : 
; 5439 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_subtr:
  00062	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_subtr
  00085	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_subtr:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_subtr
$LN7@z900_subtr:

; 5440 : 
; 5441 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_subtr
  000a5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_subtr
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_subtr
  000be	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_subtr
  000d1	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_subtr
$LN10@z900_subtr:
  000e7	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197847
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_subtr:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_subtr

; 5442 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_subtr
  00154	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_subtr
  0016b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_subtr
$LN12@z900_subtr:
  00196	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_subtr:

; 5443 : 
; 5444 :     /* Initialise the context for long DFP */
; 5445 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001c3	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001c8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001d0	e8 00 00 00 00	 call	 decContextDefault

; 5446 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  001d5	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001dd	33 d2		 xor	 edx, edx
  001df	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001e7	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 5447 : 
; 5448 :     /* Subtract FP register r3 from FP register r2 */
; 5449 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001ec	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f4	48 8d 54 24 40	 lea	 rdx, QWORD PTR x2$[rsp]
  001f9	8b 4c 24 34	 mov	 ecx, DWORD PTR r2$[rsp]
  001fd	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 5450 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  00202	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020a	48 8d 54 24 48	 lea	 rdx, QWORD PTR x3$[rsp]
  0020f	8b 4c 24 38	 mov	 ecx, DWORD PTR r3$[rsp]
  00213	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 5451 :     decimal64ToNumber(&x2, &d2);

  00218	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00220	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x2$[rsp]
  00225	e8 00 00 00 00	 call	 decimal64ToNumber

; 5452 :     decimal64ToNumber(&x3, &d3);

  0022a	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  00232	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x3$[rsp]
  00237	e8 00 00 00 00	 call	 decimal64ToNumber

; 5453 :     decNumberSubtract(&d1, &d2, &d3, &set);

  0023c	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR set$[rsp]
  00244	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  0024c	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00254	48 8d 4c 24 58	 lea	 rcx, QWORD PTR d1$[rsp]
  00259	e8 00 00 00 00	 call	 decNumberSubtract

; 5454 :     decimal64FromNumber(&x1, &d1, &set);

  0025e	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  00266	48 8d 54 24 58	 lea	 rdx, QWORD PTR d1$[rsp]
  0026b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  00270	e8 00 00 00 00	 call	 decimal64FromNumber

; 5455 : 
; 5456 :     /* Check for exception condition */
; 5457 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00275	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0027d	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00285	e8 00 00 00 00	 call	 z900_dfp_status_check
  0028a	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 5458 : 
; 5459 :     /* Load result into FP register r1 */
; 5460 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  0028e	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00296	48 8d 54 24 50	 lea	 rdx, QWORD PTR x1$[rsp]
  0029b	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  0029f	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 5461 : 
; 5462 :     /* Set condition code */
; 5463 :     regs->psw.cc = decNumberIsNaN(&d1) ? 3 :

  002a4	0f b6 44 24 60	 movzx	 eax, BYTE PTR d1$[rsp+8]
  002a9	83 e0 30	 and	 eax, 48			; 00000030H
  002ac	85 c0		 test	 eax, eax
  002ae	74 0a		 je	 SHORT $LN19@z900_subtr
  002b0	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv197[rsp], 3
  002b8	eb 5f		 jmp	 SHORT $LN20@z900_subtr
$LN19@z900_subtr:
  002ba	b8 02 00 00 00	 mov	 eax, 2
  002bf	48 6b c0 00	 imul	 rax, rax, 0
  002c3	0f b7 44 04 62	 movzx	 eax, WORD PTR d1$[rsp+rax+10]
  002c8	85 c0		 test	 eax, eax
  002ca	75 1d		 jne	 SHORT $LN15@z900_subtr
  002cc	83 7c 24 58 01	 cmp	 DWORD PTR d1$[rsp], 1
  002d1	75 16		 jne	 SHORT $LN15@z900_subtr
  002d3	0f b6 44 24 60	 movzx	 eax, BYTE PTR d1$[rsp+8]
  002d8	83 e0 70	 and	 eax, 112		; 00000070H
  002db	85 c0		 test	 eax, eax
  002dd	75 0a		 jne	 SHORT $LN15@z900_subtr
  002df	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv196[rsp], 0
  002e7	eb 28		 jmp	 SHORT $LN18@z900_subtr
$LN15@z900_subtr:
  002e9	0f b6 44 24 60	 movzx	 eax, BYTE PTR d1$[rsp+8]
  002ee	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002f3	85 c0		 test	 eax, eax
  002f5	74 0a		 je	 SHORT $LN16@z900_subtr
  002f7	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv195[rsp], 1
  002ff	eb 08		 jmp	 SHORT $LN17@z900_subtr
$LN16@z900_subtr:
  00301	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv195[rsp], 2
$LN17@z900_subtr:
  00309	8b 44 24 28	 mov	 eax, DWORD PTR tv195[rsp]
  0030d	89 44 24 2c	 mov	 DWORD PTR tv196[rsp], eax
$LN18@z900_subtr:
  00311	8b 44 24 2c	 mov	 eax, DWORD PTR tv196[rsp]
  00315	89 44 24 30	 mov	 DWORD PTR tv197[rsp], eax
$LN20@z900_subtr:
  00319	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00321	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv197[rsp]
  00326	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5464 :                    decNumberIsZero(&d1) ? 0 :
; 5465 :                    decNumberIsNegative(&d1) ? 1 : 2;
; 5466 : 
; 5467 :     /* Raise data exception if error occurred */
; 5468 :     if (dxc != 0)

  00329	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0032e	85 c0		 test	 eax, eax
  00330	74 25		 je	 SHORT $LN13@z900_subtr

; 5469 :     {
; 5470 :         regs->dxc = dxc;

  00332	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00337	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033f	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 5471 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00345	ba 07 00 00 00	 mov	 edx, 7
  0034a	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00352	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_subtr:

; 5472 :     }
; 5473 : 
; 5474 : } /* end DEF_INST(subtract_dfp_long_reg) */

  00357	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0035f	48 33 cc	 xor	 rcx, rsp
  00362	e8 00 00 00 00	 call	 __security_check_cookie
  00367	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  0036e	c3		 ret	 0
z900_subtract_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
tv204 = 52
tv205 = 56
tv206 = 60
d1$ = 64
set$ = 104
x2$ = 136
x3$ = 152
x1$ = 168
d3$ = 184
d2$ = 224
__$ArrayPad$ = 264
inst$ = 288
regs$ = 296
z900_subtract_dfp_ext_reg PROC

; 5382 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5383 : int             r1, r2, r3;             /* Values of R fields        */
; 5384 : decimal128      x1, x2, x3;             /* Extended DFP values       */
; 5385 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 5386 : decContext      set;                    /* Working context           */
; 5387 : BYTE            dxc;                    /* Data exception code       */
; 5388 : 
; 5389 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_subtr:
  00062	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_subtr
  00085	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_subtr:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_subtr
$LN7@z900_subtr:

; 5390 : 
; 5391 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_subtr
  000a5	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_subtr
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_subtr
  000be	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_subtr
  000d1	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_subtr
$LN10@z900_subtr:
  000e7	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197815
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_subtr:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_subtr

; 5392 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_subtr
  00154	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_subtr
  0016b	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_subtr
$LN12@z900_subtr:
  00196	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_subtr:

; 5393 :     DFPREGPAIR3_CHECK(r1, r2, r3, regs);

  001c3	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  001c7	83 e0 02	 and	 eax, 2
  001ca	85 c0		 test	 eax, eax
  001cc	75 16		 jne	 SHORT $LN14@z900_subtr
  001ce	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001d2	83 e0 02	 and	 eax, 2
  001d5	85 c0		 test	 eax, eax
  001d7	75 0b		 jne	 SHORT $LN14@z900_subtr
  001d9	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  001dd	83 e0 02	 and	 eax, 2
  001e0	85 c0		 test	 eax, eax
  001e2	74 1b		 je	 SHORT $LN13@z900_subtr
$LN14@z900_subtr:
  001e4	ba 06 00 00 00	 mov	 edx, 6
  001e9	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f1	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_subtr:

; 5394 : 
; 5395 :     /* Initialise the context for extended DFP */
; 5396 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001ff	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00204	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00209	e8 00 00 00 00	 call	 decContextDefault

; 5397 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  0020e	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00216	33 d2		 xor	 edx, edx
  00218	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  0021d	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 5398 : 
; 5399 :     /* Subtract FP register r3 from FP register r2 */
; 5400 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00222	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0022a	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  00232	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00236	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 5401 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  0023b	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00243	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR x3$[rsp]
  0024b	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  0024f	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 5402 :     decimal128ToNumber(&x2, &d2);

  00254	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0025c	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  00264	e8 00 00 00 00	 call	 decimal128ToNumber

; 5403 :     decimal128ToNumber(&x3, &d3);

  00269	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  00271	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR x3$[rsp]
  00279	e8 00 00 00 00	 call	 decimal128ToNumber

; 5404 :     decNumberSubtract(&d1, &d2, &d3, &set);

  0027e	4c 8d 4c 24 68	 lea	 r9, QWORD PTR set$[rsp]
  00283	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  0028b	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00293	48 8d 4c 24 40	 lea	 rcx, QWORD PTR d1$[rsp]
  00298	e8 00 00 00 00	 call	 decNumberSubtract

; 5405 :     decimal128FromNumber(&x1, &d1, &set);

  0029d	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  002a2	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  002a7	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR x1$[rsp]
  002af	e8 00 00 00 00	 call	 decimal128FromNumber

; 5406 : 
; 5407 :     /* Check for exception condition */
; 5408 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  002b4	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002bc	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  002c1	e8 00 00 00 00	 call	 z900_dfp_status_check
  002c6	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 5409 : 
; 5410 :     /* Load result into FP register r1 */
; 5411 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  002ca	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002d2	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR x1$[rsp]
  002da	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  002de	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 5412 : 
; 5413 :     /* Set condition code */
; 5414 :     regs->psw.cc = decNumberIsNaN(&d1) ? 3 :

  002e3	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  002e8	83 e0 30	 and	 eax, 48			; 00000030H
  002eb	85 c0		 test	 eax, eax
  002ed	74 0a		 je	 SHORT $LN21@z900_subtr
  002ef	c7 44 24 3c 03
	00 00 00	 mov	 DWORD PTR tv206[rsp], 3
  002f7	eb 5f		 jmp	 SHORT $LN22@z900_subtr
$LN21@z900_subtr:
  002f9	b8 02 00 00 00	 mov	 eax, 2
  002fe	48 6b c0 00	 imul	 rax, rax, 0
  00302	0f b7 44 04 4a	 movzx	 eax, WORD PTR d1$[rsp+rax+10]
  00307	85 c0		 test	 eax, eax
  00309	75 1d		 jne	 SHORT $LN17@z900_subtr
  0030b	83 7c 24 40 01	 cmp	 DWORD PTR d1$[rsp], 1
  00310	75 16		 jne	 SHORT $LN17@z900_subtr
  00312	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  00317	83 e0 70	 and	 eax, 112		; 00000070H
  0031a	85 c0		 test	 eax, eax
  0031c	75 0a		 jne	 SHORT $LN17@z900_subtr
  0031e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv205[rsp], 0
  00326	eb 28		 jmp	 SHORT $LN20@z900_subtr
$LN17@z900_subtr:
  00328	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0032d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00332	85 c0		 test	 eax, eax
  00334	74 0a		 je	 SHORT $LN18@z900_subtr
  00336	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv204[rsp], 1
  0033e	eb 08		 jmp	 SHORT $LN19@z900_subtr
$LN18@z900_subtr:
  00340	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv204[rsp], 2
$LN19@z900_subtr:
  00348	8b 44 24 34	 mov	 eax, DWORD PTR tv204[rsp]
  0034c	89 44 24 38	 mov	 DWORD PTR tv205[rsp], eax
$LN20@z900_subtr:
  00350	8b 44 24 38	 mov	 eax, DWORD PTR tv205[rsp]
  00354	89 44 24 3c	 mov	 DWORD PTR tv206[rsp], eax
$LN22@z900_subtr:
  00358	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00360	0f b6 4c 24 3c	 movzx	 ecx, BYTE PTR tv206[rsp]
  00365	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5415 :                    decNumberIsZero(&d1) ? 0 :
; 5416 :                    decNumberIsNegative(&d1) ? 1 : 2;
; 5417 : 
; 5418 :     /* Raise data exception if error occurred */
; 5419 :     if (dxc != 0)

  00368	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0036d	85 c0		 test	 eax, eax
  0036f	74 25		 je	 SHORT $LN15@z900_subtr

; 5420 :     {
; 5421 :         regs->dxc = dxc;

  00371	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00376	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037e	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 5422 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00384	ba 07 00 00 00	 mov	 edx, 7
  00389	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00391	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_subtr:

; 5423 :     }
; 5424 : 
; 5425 : } /* end DEF_INST(subtract_dfp_ext_reg) */

  00396	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0039e	48 33 cc	 xor	 rcx, rsp
  003a1	e8 00 00 00 00	 call	 __security_check_cookie
  003a6	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  003ad	c3		 ret	 0
z900_subtract_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
effective_addr2$ = 40
x2$ = 48
b2$ = 52
r3$ = 56
n$ = 60
r1$ = 64
x1$ = 72
x3$ = 80
d3$ = 88
d1$ = 128
set$ = 168
__$ArrayPad$ = 200
inst$ = 224
regs$ = 232
z900_shift_coefficient_right_dfp_long PROC

; 5320 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5321 : int             r1, r3;                 /* Values of R fields        */
; 5322 : int             x2;                     /* Index register            */
; 5323 : int             b2;                     /* Base of effective addr    */
; 5324 : VADR            effective_addr2;        /* Effective address         */
; 5325 : decimal64       x1, x3;                 /* Long DFP values           */
; 5326 : decNumber       d1, d3;                 /* Working decimal numbers   */
; 5327 : decContext      set;                    /* Working context           */
; 5328 : int             n;                      /* Number of bits to shift   */
; 5329 : 
; 5330 :     RXF(inst, regs, r1, r3, x2, b2, effective_addr2);

  00023	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	48 6b c0 04	 imul	 rax, rax, 4
  00044	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0004c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00050	c1 f8 04	 sar	 eax, 4
  00053	89 44 24 40	 mov	 DWORD PTR r1$[rsp], eax
  00057	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00060	8b c0		 mov	 eax, eax
  00062	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00067	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0006b	c1 e8 10	 shr	 eax, 16
  0006e	83 e0 0f	 and	 eax, 15
  00071	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00075	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00079	c1 e8 14	 shr	 eax, 20
  0007c	83 e0 0f	 and	 eax, 15
  0007f	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
  00083	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00088	74 25		 je	 SHORT $LN8@z900_shift
  0008a	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  0008f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_shift:
  000af	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  000b3	c1 e8 0c	 shr	 eax, 12
  000b6	83 e0 0f	 and	 eax, 15
  000b9	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  000bd	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000c2	74 25		 je	 SHORT $LN9@z900_shift
  000c4	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000c9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000de	48 03 c8	 add	 rcx, rax
  000e1	48 8b c1	 mov	 rax, rcx
  000e4	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_shift:
  000e9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000fd	48 23 c8	 and	 rcx, rax
  00100	48 8b c1	 mov	 rax, rcx
  00103	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_shift:
  00108	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00114	48 83 c0 06	 add	 rax, 6
  00118	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00120	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0f		 je	 SHORT $LN10@z900_shift
  0012b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00133	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_shift:
  0013a	33 c0		 xor	 eax, eax
  0013c	85 c0		 test	 eax, eax
  0013e	75 c8		 jne	 SHORT $LN4@z900_shift
$LN7@z900_shift:

; 5331 : 
; 5332 :     TXF_FLOAT_INSTR_CHECK( regs );

  00140	33 c0		 xor	 eax, eax
  00142	83 f8 01	 cmp	 eax, 1
  00145	0f 84 81 00 00
	00		 je	 $LN11@z900_shift
  0014b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00153	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0015a	85 c0		 test	 eax, eax
  0015c	74 6e		 je	 SHORT $LN11@z900_shift
  0015e	33 c0		 xor	 eax, eax
  00160	85 c0		 test	 eax, eax
  00162	75 29		 jne	 SHORT $LN12@z900_shift
  00164	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016c	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00173	85 c0		 test	 eax, eax
  00175	75 16		 jne	 SHORT $LN12@z900_shift
  00177	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017f	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00186	83 e0 04	 and	 eax, 4
  00189	85 c0		 test	 eax, eax
  0018b	75 3f		 jne	 SHORT $LN11@z900_shift
$LN12@z900_shift:
  0018d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00195	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0019b	0f ba e8 0b	 bts	 eax, 11
  0019f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001ad	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197778
  001b4	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001ba	ba 02 00 00 00	 mov	 edx, 2
  001bf	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_shift:
  001cc	33 c0		 xor	 eax, eax
  001ce	85 c0		 test	 eax, eax
  001d0	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_shift

; 5333 :     DFPINST_CHECK(regs);

  001d6	b8 08 00 00 00	 mov	 eax, 8
  001db	48 6b c0 01	 imul	 rax, rax, 1
  001df	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001ef	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001f5	48 85 c0	 test	 rax, rax
  001f8	74 42		 je	 SHORT $LN14@z900_shift
  001fa	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00202	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00208	d1 e8		 shr	 eax, 1
  0020a	83 e0 01	 and	 eax, 1
  0020d	85 c0		 test	 eax, eax
  0020f	74 58		 je	 SHORT $LN13@z900_shift
  00211	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00219	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00220	b9 08 00 00 00	 mov	 ecx, 8
  00225	48 6b c9 01	 imul	 rcx, rcx, 1
  00229	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00231	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00237	48 85 c0	 test	 rax, rax
  0023a	75 2d		 jne	 SHORT $LN13@z900_shift
$LN14@z900_shift:
  0023c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00244	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0024e	ba 07 00 00 00	 mov	 edx, 7
  00253	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00263	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_shift:

; 5334 : 
; 5335 :     /* Isolate rightmost 6 bits of second operand address */
; 5336 :     n = effective_addr2 & 0x3F;

  00269	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0026e	48 83 e0 3f	 and	 rax, 63			; 0000003fH
  00272	89 44 24 3c	 mov	 DWORD PTR n$[rsp], eax

; 5337 : 
; 5338 :     /* Initialise the context for long DFP */
; 5339 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00276	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0027b	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00283	e8 00 00 00 00	 call	 decContextDefault

; 5340 : 
; 5341 :     /* Load DFP long number from FP register r3 */
; 5342 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  00288	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00290	48 8d 54 24 50	 lea	 rdx, QWORD PTR x3$[rsp]
  00295	8b 4c 24 38	 mov	 ecx, DWORD PTR r3$[rsp]
  00299	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 5343 : 
; 5344 :     /* Convert to internal decimal number format */
; 5345 :     decimal64ToNumber(&x3, &d3);

  0029e	48 8d 54 24 58	 lea	 rdx, QWORD PTR d3$[rsp]
  002a3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x3$[rsp]
  002a8	e8 00 00 00 00	 call	 decimal64ToNumber

; 5346 : 
; 5347 :     /* For NaN and Inf use coefficient continuation digits only */
; 5348 :     if (decNumberIsNaN(&d3) || decNumberIsInfinite(&d3))

  002ad	0f b6 44 24 60	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002b2	83 e0 30	 and	 eax, 48			; 00000030H
  002b5	85 c0		 test	 eax, eax
  002b7	75 0c		 jne	 SHORT $LN17@z900_shift
  002b9	0f b6 44 24 60	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002be	83 e0 40	 and	 eax, 64			; 00000040H
  002c1	85 c0		 test	 eax, eax
  002c3	74 1e		 je	 SHORT $LN15@z900_shift
$LN17@z900_shift:

; 5349 :     {
; 5350 :         dfp64_clear_cf_and_bxcf(&x3);

  002c5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x3$[rsp]
  002ca	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 5351 :         decimal64ToNumber(&x3, &d1);

  002cf	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  002d7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x3$[rsp]
  002dc	e8 00 00 00 00	 call	 decimal64ToNumber

; 5352 :     }

  002e1	eb 12		 jmp	 SHORT $LN16@z900_shift
$LN15@z900_shift:

; 5353 :     else
; 5354 :     {
; 5355 :         decNumberCopy(&d1, &d3);

  002e3	48 8d 54 24 58	 lea	 rdx, QWORD PTR d3$[rsp]
  002e8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  002f0	e8 00 00 00 00	 call	 decNumberCopy
$LN16@z900_shift:

; 5356 :     }
; 5357 : 
; 5358 :     /* Shift coefficient right n digit positions */
; 5359 :     dfp_shift_coeff(&set, &d1, -n);

  002f5	8b 44 24 3c	 mov	 eax, DWORD PTR n$[rsp]
  002f9	f7 d8		 neg	 eax
  002fb	44 8b c0	 mov	 r8d, eax
  002fe	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00306	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  0030e	e8 00 00 00 00	 call	 dfp_shift_coeff

; 5360 : 
; 5361 :     /* Convert result to DFP long format */
; 5362 :     decimal64FromNumber(&x1, &d1, &set);

  00313	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  0031b	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00323	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00328	e8 00 00 00 00	 call	 decimal64FromNumber

; 5363 : 
; 5364 :     /* Restore Nan or Inf indicators in the result */
; 5365 :     if (decNumberIsQNaN(&d3))

  0032d	0f b6 44 24 60	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00332	83 e0 20	 and	 eax, 32			; 00000020H
  00335	85 c0		 test	 eax, eax
  00337	74 11		 je	 SHORT $LN18@z900_shift

; 5366 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  00339	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  0033e	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00343	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
  00348	eb 38		 jmp	 SHORT $LN19@z900_shift
$LN18@z900_shift:

; 5367 :     else if (decNumberIsSNaN(&d3))

  0034a	0f b6 44 24 60	 movzx	 eax, BYTE PTR d3$[rsp+8]
  0034f	83 e0 10	 and	 eax, 16
  00352	85 c0		 test	 eax, eax
  00354	74 11		 je	 SHORT $LN20@z900_shift

; 5368 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  00356	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  0035b	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00360	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
  00365	eb 1b		 jmp	 SHORT $LN21@z900_shift
$LN20@z900_shift:

; 5369 :     else if (decNumberIsInfinite(&d3))

  00367	0f b6 44 24 60	 movzx	 eax, BYTE PTR d3$[rsp+8]
  0036c	83 e0 40	 and	 eax, 64			; 00000040H
  0036f	85 c0		 test	 eax, eax
  00371	74 0f		 je	 SHORT $LN22@z900_shift

; 5370 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  00373	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00378	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  0037d	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
$LN22@z900_shift:
$LN21@z900_shift:
$LN19@z900_shift:

; 5371 : 
; 5372 :     /* Load result into FP register r1 */
; 5373 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  00382	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0038a	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  0038f	8b 4c 24 40	 mov	 ecx, DWORD PTR r1$[rsp]
  00393	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 5374 : 
; 5375 : } /* end DEF_INST(shift_coefficient_right_dfp_long) */

  00398	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003a0	48 33 cc	 xor	 rcx, rsp
  003a3	e8 00 00 00 00	 call	 __security_check_cookie
  003a8	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  003af	c3		 ret	 0
z900_shift_coefficient_right_dfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
effective_addr2$ = 40
x2$ = 48
b2$ = 52
r3$ = 56
r1$ = 60
n$ = 64
x1$ = 72
x3$ = 88
d3$ = 104
d1$ = 144
set$ = 184
__$ArrayPad$ = 216
inst$ = 240
regs$ = 248
z900_shift_coefficient_right_dfp_ext PROC

; 5257 : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5258 : int             r1, r3;                 /* Values of R fields        */
; 5259 : int             x2;                     /* Index register            */
; 5260 : int             b2;                     /* Base of effective addr    */
; 5261 : VADR            effective_addr2;        /* Effective address         */
; 5262 : decimal128      x1, x3;                 /* Extended DFP values       */
; 5263 : decNumber       d1, d3;                 /* Working decimal numbers   */
; 5264 : decContext      set;                    /* Working context           */
; 5265 : int             n;                      /* Number of bits to shift   */
; 5266 : 
; 5267 :     RXF(inst, regs, r1, r3, x2, b2, effective_addr2);

  00023	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	48 6b c0 04	 imul	 rax, rax, 4
  00044	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0004c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00050	c1 f8 04	 sar	 eax, 4
  00053	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00057	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00060	8b c0		 mov	 eax, eax
  00062	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00067	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0006b	c1 e8 10	 shr	 eax, 16
  0006e	83 e0 0f	 and	 eax, 15
  00071	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00075	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00079	c1 e8 14	 shr	 eax, 20
  0007c	83 e0 0f	 and	 eax, 15
  0007f	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
  00083	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00088	74 25		 je	 SHORT $LN8@z900_shift
  0008a	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  0008f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_shift:
  000af	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  000b3	c1 e8 0c	 shr	 eax, 12
  000b6	83 e0 0f	 and	 eax, 15
  000b9	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  000bd	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000c2	74 25		 je	 SHORT $LN9@z900_shift
  000c4	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000c9	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000de	48 03 c8	 add	 rcx, rax
  000e1	48 8b c1	 mov	 rax, rcx
  000e4	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_shift:
  000e9	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000fd	48 23 c8	 and	 rcx, rax
  00100	48 8b c1	 mov	 rax, rcx
  00103	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_shift:
  00108	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00114	48 83 c0 06	 add	 rax, 6
  00118	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00120	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0f		 je	 SHORT $LN10@z900_shift
  0012b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00133	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_shift:
  0013a	33 c0		 xor	 eax, eax
  0013c	85 c0		 test	 eax, eax
  0013e	75 c8		 jne	 SHORT $LN4@z900_shift
$LN7@z900_shift:

; 5268 : 
; 5269 :     TXF_FLOAT_INSTR_CHECK( regs );

  00140	33 c0		 xor	 eax, eax
  00142	83 f8 01	 cmp	 eax, 1
  00145	0f 84 81 00 00
	00		 je	 $LN11@z900_shift
  0014b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00153	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0015a	85 c0		 test	 eax, eax
  0015c	74 6e		 je	 SHORT $LN11@z900_shift
  0015e	33 c0		 xor	 eax, eax
  00160	85 c0		 test	 eax, eax
  00162	75 29		 jne	 SHORT $LN12@z900_shift
  00164	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016c	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00173	85 c0		 test	 eax, eax
  00175	75 16		 jne	 SHORT $LN12@z900_shift
  00177	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017f	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00186	83 e0 04	 and	 eax, 4
  00189	85 c0		 test	 eax, eax
  0018b	75 3f		 jne	 SHORT $LN11@z900_shift
$LN12@z900_shift:
  0018d	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00195	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0019b	0f ba e8 0b	 bts	 eax, 11
  0019f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001ad	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197737
  001b4	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001ba	ba 02 00 00 00	 mov	 edx, 2
  001bf	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_shift:
  001cc	33 c0		 xor	 eax, eax
  001ce	85 c0		 test	 eax, eax
  001d0	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_shift

; 5270 :     DFPINST_CHECK(regs);

  001d6	b8 08 00 00 00	 mov	 eax, 8
  001db	48 6b c0 01	 imul	 rax, rax, 1
  001df	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001ef	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001f5	48 85 c0	 test	 rax, rax
  001f8	74 42		 je	 SHORT $LN14@z900_shift
  001fa	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00202	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00208	d1 e8		 shr	 eax, 1
  0020a	83 e0 01	 and	 eax, 1
  0020d	85 c0		 test	 eax, eax
  0020f	74 58		 je	 SHORT $LN13@z900_shift
  00211	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00219	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00220	b9 08 00 00 00	 mov	 ecx, 8
  00225	48 6b c9 01	 imul	 rcx, rcx, 1
  00229	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00231	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00237	48 85 c0	 test	 rax, rax
  0023a	75 2d		 jne	 SHORT $LN13@z900_shift
$LN14@z900_shift:
  0023c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00244	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0024e	ba 07 00 00 00	 mov	 edx, 7
  00253	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00263	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_shift:

; 5271 :     DFPREGPAIR2_CHECK(r1, r3, regs);

  00269	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  0026d	83 e0 02	 and	 eax, 2
  00270	85 c0		 test	 eax, eax
  00272	75 0b		 jne	 SHORT $LN16@z900_shift
  00274	8b 44 24 38	 mov	 eax, DWORD PTR r3$[rsp]
  00278	83 e0 02	 and	 eax, 2
  0027b	85 c0		 test	 eax, eax
  0027d	74 1b		 je	 SHORT $LN15@z900_shift
$LN16@z900_shift:
  0027f	ba 06 00 00 00	 mov	 edx, 6
  00284	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00294	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_shift:

; 5272 : 
; 5273 :     /* Isolate rightmost 6 bits of second operand address */
; 5274 :     n = effective_addr2 & 0x3F;

  0029a	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0029f	48 83 e0 3f	 and	 rax, 63			; 0000003fH
  002a3	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax

; 5275 : 
; 5276 :     /* Initialise the context for extended DFP */
; 5277 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  002a7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  002ac	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  002b4	e8 00 00 00 00	 call	 decContextDefault

; 5278 : 
; 5279 :     /* Load DFP extended number from FP register r3 */
; 5280 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  002b9	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002c1	48 8d 54 24 58	 lea	 rdx, QWORD PTR x3$[rsp]
  002c6	8b 4c 24 38	 mov	 ecx, DWORD PTR r3$[rsp]
  002ca	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 5281 : 
; 5282 :     /* Convert to internal decimal number format */
; 5283 :     decimal128ToNumber(&x3, &d3);

  002cf	48 8d 54 24 68	 lea	 rdx, QWORD PTR d3$[rsp]
  002d4	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x3$[rsp]
  002d9	e8 00 00 00 00	 call	 decimal128ToNumber

; 5284 : 
; 5285 :     /* For NaN and Inf use coefficient continuation digits only */
; 5286 :     if (decNumberIsNaN(&d3) || decNumberIsInfinite(&d3))

  002de	0f b6 44 24 70	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002e3	83 e0 30	 and	 eax, 48			; 00000030H
  002e6	85 c0		 test	 eax, eax
  002e8	75 0c		 jne	 SHORT $LN19@z900_shift
  002ea	0f b6 44 24 70	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002ef	83 e0 40	 and	 eax, 64			; 00000040H
  002f2	85 c0		 test	 eax, eax
  002f4	74 1e		 je	 SHORT $LN17@z900_shift
$LN19@z900_shift:

; 5287 :     {
; 5288 :         dfp128_clear_cf_and_bxcf(&x3);

  002f6	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x3$[rsp]
  002fb	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 5289 :         decimal128ToNumber(&x3, &d1);

  00300	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00308	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x3$[rsp]
  0030d	e8 00 00 00 00	 call	 decimal128ToNumber

; 5290 :     }

  00312	eb 12		 jmp	 SHORT $LN18@z900_shift
$LN17@z900_shift:

; 5291 :     else
; 5292 :     {
; 5293 :         decNumberCopy(&d1, &d3);

  00314	48 8d 54 24 68	 lea	 rdx, QWORD PTR d3$[rsp]
  00319	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  00321	e8 00 00 00 00	 call	 decNumberCopy
$LN18@z900_shift:

; 5294 :     }
; 5295 : 
; 5296 :     /* Shift coefficient right n digit positions */
; 5297 :     dfp_shift_coeff(&set, &d1, -n);

  00326	8b 44 24 40	 mov	 eax, DWORD PTR n$[rsp]
  0032a	f7 d8		 neg	 eax
  0032c	44 8b c0	 mov	 r8d, eax
  0032f	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00337	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  0033f	e8 00 00 00 00	 call	 dfp_shift_coeff

; 5298 : 
; 5299 :     /* Convert result to DFP extended format */
; 5300 :     decimal128FromNumber(&x1, &d1, &set);

  00344	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  0034c	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00354	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00359	e8 00 00 00 00	 call	 decimal128FromNumber

; 5301 : 
; 5302 :     /* Restore Nan or Inf indicators in the result */
; 5303 :     if (decNumberIsQNaN(&d3))

  0035e	0f b6 44 24 70	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00363	83 e0 20	 and	 eax, 32			; 00000020H
  00366	85 c0		 test	 eax, eax
  00368	74 11		 je	 SHORT $LN20@z900_shift

; 5304 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  0036a	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  0036f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00374	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf
  00379	eb 38		 jmp	 SHORT $LN21@z900_shift
$LN20@z900_shift:

; 5305 :     else if (decNumberIsSNaN(&d3))

  0037b	0f b6 44 24 70	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00380	83 e0 10	 and	 eax, 16
  00383	85 c0		 test	 eax, eax
  00385	74 11		 je	 SHORT $LN22@z900_shift

; 5306 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  00387	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  0038c	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00391	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf
  00396	eb 1b		 jmp	 SHORT $LN23@z900_shift
$LN22@z900_shift:

; 5307 :     else if (decNumberIsInfinite(&d3))

  00398	0f b6 44 24 70	 movzx	 eax, BYTE PTR d3$[rsp+8]
  0039d	83 e0 40	 and	 eax, 64			; 00000040H
  003a0	85 c0		 test	 eax, eax
  003a2	74 0f		 je	 SHORT $LN24@z900_shift

; 5308 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  003a4	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  003a9	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  003ae	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf
$LN24@z900_shift:
$LN23@z900_shift:
$LN21@z900_shift:

; 5309 : 
; 5310 :     /* Load result into FP register r1 */
; 5311 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  003b3	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003bb	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  003c0	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  003c4	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 5312 : 
; 5313 : } /* end DEF_INST(shift_coefficient_right_dfp_ext) */

  003c9	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003d1	48 33 cc	 xor	 rcx, rsp
  003d4	e8 00 00 00 00	 call	 __security_check_cookie
  003d9	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  003e0	c3		 ret	 0
z900_shift_coefficient_right_dfp_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
effective_addr2$ = 40
x2$ = 48
b2$ = 52
r3$ = 56
n$ = 60
r1$ = 64
x1$ = 72
x3$ = 80
d3$ = 88
d1$ = 128
set$ = 168
__$ArrayPad$ = 200
inst$ = 224
regs$ = 232
z900_shift_coefficient_left_dfp_long PROC

; 5195 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5196 : int             r1, r3;                 /* Values of R fields        */
; 5197 : int             x2;                     /* Index register            */
; 5198 : int             b2;                     /* Base of effective addr    */
; 5199 : VADR            effective_addr2;        /* Effective address         */
; 5200 : decimal64       x1, x3;                 /* Long DFP values           */
; 5201 : decNumber       d1, d3;                 /* Working decimal numbers   */
; 5202 : decContext      set;                    /* Working context           */
; 5203 : int             n;                      /* Number of bits to shift   */
; 5204 : 
; 5205 :     RXF(inst, regs, r1, r3, x2, b2, effective_addr2);

  00023	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	48 6b c0 04	 imul	 rax, rax, 4
  00044	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0004c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00050	c1 f8 04	 sar	 eax, 4
  00053	89 44 24 40	 mov	 DWORD PTR r1$[rsp], eax
  00057	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00060	8b c0		 mov	 eax, eax
  00062	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00067	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0006b	c1 e8 10	 shr	 eax, 16
  0006e	83 e0 0f	 and	 eax, 15
  00071	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00075	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00079	c1 e8 14	 shr	 eax, 20
  0007c	83 e0 0f	 and	 eax, 15
  0007f	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
  00083	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00088	74 25		 je	 SHORT $LN8@z900_shift
  0008a	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  0008f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_shift:
  000af	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  000b3	c1 e8 0c	 shr	 eax, 12
  000b6	83 e0 0f	 and	 eax, 15
  000b9	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  000bd	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000c2	74 25		 je	 SHORT $LN9@z900_shift
  000c4	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000c9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000de	48 03 c8	 add	 rcx, rax
  000e1	48 8b c1	 mov	 rax, rcx
  000e4	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_shift:
  000e9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000fd	48 23 c8	 and	 rcx, rax
  00100	48 8b c1	 mov	 rax, rcx
  00103	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_shift:
  00108	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00114	48 83 c0 06	 add	 rax, 6
  00118	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00120	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0f		 je	 SHORT $LN10@z900_shift
  0012b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00133	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_shift:
  0013a	33 c0		 xor	 eax, eax
  0013c	85 c0		 test	 eax, eax
  0013e	75 c8		 jne	 SHORT $LN4@z900_shift
$LN7@z900_shift:

; 5206 : 
; 5207 :     TXF_FLOAT_INSTR_CHECK( regs );

  00140	33 c0		 xor	 eax, eax
  00142	83 f8 01	 cmp	 eax, 1
  00145	0f 84 81 00 00
	00		 je	 $LN11@z900_shift
  0014b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00153	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0015a	85 c0		 test	 eax, eax
  0015c	74 6e		 je	 SHORT $LN11@z900_shift
  0015e	33 c0		 xor	 eax, eax
  00160	85 c0		 test	 eax, eax
  00162	75 29		 jne	 SHORT $LN12@z900_shift
  00164	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016c	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00173	85 c0		 test	 eax, eax
  00175	75 16		 jne	 SHORT $LN12@z900_shift
  00177	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017f	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00186	83 e0 04	 and	 eax, 4
  00189	85 c0		 test	 eax, eax
  0018b	75 3f		 jne	 SHORT $LN11@z900_shift
$LN12@z900_shift:
  0018d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00195	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0019b	0f ba e8 0b	 bts	 eax, 11
  0019f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001ad	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197698
  001b4	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001ba	ba 02 00 00 00	 mov	 edx, 2
  001bf	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_shift:
  001cc	33 c0		 xor	 eax, eax
  001ce	85 c0		 test	 eax, eax
  001d0	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_shift

; 5208 :     DFPINST_CHECK(regs);

  001d6	b8 08 00 00 00	 mov	 eax, 8
  001db	48 6b c0 01	 imul	 rax, rax, 1
  001df	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001ef	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001f5	48 85 c0	 test	 rax, rax
  001f8	74 42		 je	 SHORT $LN14@z900_shift
  001fa	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00202	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00208	d1 e8		 shr	 eax, 1
  0020a	83 e0 01	 and	 eax, 1
  0020d	85 c0		 test	 eax, eax
  0020f	74 58		 je	 SHORT $LN13@z900_shift
  00211	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00219	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00220	b9 08 00 00 00	 mov	 ecx, 8
  00225	48 6b c9 01	 imul	 rcx, rcx, 1
  00229	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00231	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00237	48 85 c0	 test	 rax, rax
  0023a	75 2d		 jne	 SHORT $LN13@z900_shift
$LN14@z900_shift:
  0023c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00244	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0024e	ba 07 00 00 00	 mov	 edx, 7
  00253	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00263	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_shift:

; 5209 : 
; 5210 :     /* Isolate rightmost 6 bits of second operand address */
; 5211 :     n = effective_addr2 & 0x3F;

  00269	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0026e	48 83 e0 3f	 and	 rax, 63			; 0000003fH
  00272	89 44 24 3c	 mov	 DWORD PTR n$[rsp], eax

; 5212 : 
; 5213 :     /* Initialise the context for long DFP */
; 5214 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00276	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0027b	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00283	e8 00 00 00 00	 call	 decContextDefault

; 5215 : 
; 5216 :     /* Load DFP long number from FP register r3 */
; 5217 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  00288	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00290	48 8d 54 24 50	 lea	 rdx, QWORD PTR x3$[rsp]
  00295	8b 4c 24 38	 mov	 ecx, DWORD PTR r3$[rsp]
  00299	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 5218 : 
; 5219 :     /* Convert to internal decimal number format */
; 5220 :     decimal64ToNumber(&x3, &d3);

  0029e	48 8d 54 24 58	 lea	 rdx, QWORD PTR d3$[rsp]
  002a3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x3$[rsp]
  002a8	e8 00 00 00 00	 call	 decimal64ToNumber

; 5221 : 
; 5222 :     /* For NaN and Inf use coefficient continuation digits only */
; 5223 :     if (decNumberIsNaN(&d3) || decNumberIsInfinite(&d3))

  002ad	0f b6 44 24 60	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002b2	83 e0 30	 and	 eax, 48			; 00000030H
  002b5	85 c0		 test	 eax, eax
  002b7	75 0c		 jne	 SHORT $LN17@z900_shift
  002b9	0f b6 44 24 60	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002be	83 e0 40	 and	 eax, 64			; 00000040H
  002c1	85 c0		 test	 eax, eax
  002c3	74 1e		 je	 SHORT $LN15@z900_shift
$LN17@z900_shift:

; 5224 :     {
; 5225 :         dfp64_clear_cf_and_bxcf(&x3);

  002c5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x3$[rsp]
  002ca	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 5226 :         decimal64ToNumber(&x3, &d1);

  002cf	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  002d7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x3$[rsp]
  002dc	e8 00 00 00 00	 call	 decimal64ToNumber

; 5227 :     }

  002e1	eb 12		 jmp	 SHORT $LN16@z900_shift
$LN15@z900_shift:

; 5228 :     else
; 5229 :     {
; 5230 :         decNumberCopy(&d1, &d3);

  002e3	48 8d 54 24 58	 lea	 rdx, QWORD PTR d3$[rsp]
  002e8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  002f0	e8 00 00 00 00	 call	 decNumberCopy
$LN16@z900_shift:

; 5231 :     }
; 5232 : 
; 5233 :     /* Shift coefficient left n digit positions */
; 5234 :     dfp_shift_coeff(&set, &d1, n);

  002f5	44 8b 44 24 3c	 mov	 r8d, DWORD PTR n$[rsp]
  002fa	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00302	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  0030a	e8 00 00 00 00	 call	 dfp_shift_coeff

; 5235 : 
; 5236 :     /* Convert result to DFP long format */
; 5237 :     decimal64FromNumber(&x1, &d1, &set);

  0030f	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  00317	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0031f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00324	e8 00 00 00 00	 call	 decimal64FromNumber

; 5238 : 
; 5239 :     /* Restore Nan or Inf indicators in the result */
; 5240 :     if (decNumberIsQNaN(&d3))

  00329	0f b6 44 24 60	 movzx	 eax, BYTE PTR d3$[rsp+8]
  0032e	83 e0 20	 and	 eax, 32			; 00000020H
  00331	85 c0		 test	 eax, eax
  00333	74 11		 je	 SHORT $LN18@z900_shift

; 5241 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  00335	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  0033a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  0033f	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
  00344	eb 38		 jmp	 SHORT $LN19@z900_shift
$LN18@z900_shift:

; 5242 :     else if (decNumberIsSNaN(&d3))

  00346	0f b6 44 24 60	 movzx	 eax, BYTE PTR d3$[rsp+8]
  0034b	83 e0 10	 and	 eax, 16
  0034e	85 c0		 test	 eax, eax
  00350	74 11		 je	 SHORT $LN20@z900_shift

; 5243 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  00352	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  00357	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  0035c	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
  00361	eb 1b		 jmp	 SHORT $LN21@z900_shift
$LN20@z900_shift:

; 5244 :     else if (decNumberIsInfinite(&d3))

  00363	0f b6 44 24 60	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00368	83 e0 40	 and	 eax, 64			; 00000040H
  0036b	85 c0		 test	 eax, eax
  0036d	74 0f		 je	 SHORT $LN22@z900_shift

; 5245 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  0036f	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00374	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00379	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
$LN22@z900_shift:
$LN21@z900_shift:
$LN19@z900_shift:

; 5246 : 
; 5247 :     /* Load result into FP register r1 */
; 5248 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  0037e	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00386	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  0038b	8b 4c 24 40	 mov	 ecx, DWORD PTR r1$[rsp]
  0038f	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 5249 : 
; 5250 : } /* end DEF_INST(shift_coefficient_left_dfp_long) */

  00394	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0039c	48 33 cc	 xor	 rcx, rsp
  0039f	e8 00 00 00 00	 call	 __security_check_cookie
  003a4	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  003ab	c3		 ret	 0
z900_shift_coefficient_left_dfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
effective_addr2$ = 40
x2$ = 48
b2$ = 52
r3$ = 56
r1$ = 60
n$ = 64
x1$ = 72
x3$ = 88
d3$ = 104
d1$ = 144
set$ = 184
__$ArrayPad$ = 216
inst$ = 240
regs$ = 248
z900_shift_coefficient_left_dfp_ext PROC

; 5132 : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5133 : int             r1, r3;                 /* Values of R fields        */
; 5134 : int             x2;                     /* Index register            */
; 5135 : int             b2;                     /* Base of effective addr    */
; 5136 : VADR            effective_addr2;        /* Effective address         */
; 5137 : decimal128      x1, x3;                 /* Extended DFP values       */
; 5138 : decNumber       d1, d3;                 /* Working decimal numbers   */
; 5139 : decContext      set;                    /* Working context           */
; 5140 : int             n;                      /* Number of bits to shift   */
; 5141 : 
; 5142 :     RXF(inst, regs, r1, r3, x2, b2, effective_addr2);

  00023	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	48 6b c0 04	 imul	 rax, rax, 4
  00044	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0004c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00050	c1 f8 04	 sar	 eax, 4
  00053	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00057	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00060	8b c0		 mov	 eax, eax
  00062	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00067	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0006b	c1 e8 10	 shr	 eax, 16
  0006e	83 e0 0f	 and	 eax, 15
  00071	89 44 24 30	 mov	 DWORD PTR x2$[rsp], eax
  00075	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00079	c1 e8 14	 shr	 eax, 20
  0007c	83 e0 0f	 and	 eax, 15
  0007f	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
  00083	83 7c 24 30 00	 cmp	 DWORD PTR x2$[rsp], 0
  00088	74 25		 je	 SHORT $LN8@z900_shift
  0008a	48 63 44 24 30	 movsxd	 rax, DWORD PTR x2$[rsp]
  0008f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a4	48 03 c8	 add	 rcx, rax
  000a7	48 8b c1	 mov	 rax, rcx
  000aa	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_shift:
  000af	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  000b3	c1 e8 0c	 shr	 eax, 12
  000b6	83 e0 0f	 and	 eax, 15
  000b9	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  000bd	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000c2	74 25		 je	 SHORT $LN9@z900_shift
  000c4	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000c9	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000de	48 03 c8	 add	 rcx, rax
  000e1	48 8b c1	 mov	 rax, rcx
  000e4	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_shift:
  000e9	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000fd	48 23 c8	 and	 rcx, rax
  00100	48 8b c1	 mov	 rax, rcx
  00103	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_shift:
  00108	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00114	48 83 c0 06	 add	 rax, 6
  00118	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00120	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00124	33 c0		 xor	 eax, eax
  00126	83 f8 06	 cmp	 eax, 6
  00129	74 0f		 je	 SHORT $LN10@z900_shift
  0012b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00133	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_shift:
  0013a	33 c0		 xor	 eax, eax
  0013c	85 c0		 test	 eax, eax
  0013e	75 c8		 jne	 SHORT $LN4@z900_shift
$LN7@z900_shift:

; 5143 : 
; 5144 :     TXF_FLOAT_INSTR_CHECK( regs );

  00140	33 c0		 xor	 eax, eax
  00142	83 f8 01	 cmp	 eax, 1
  00145	0f 84 81 00 00
	00		 je	 $LN11@z900_shift
  0014b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00153	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0015a	85 c0		 test	 eax, eax
  0015c	74 6e		 je	 SHORT $LN11@z900_shift
  0015e	33 c0		 xor	 eax, eax
  00160	85 c0		 test	 eax, eax
  00162	75 29		 jne	 SHORT $LN12@z900_shift
  00164	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016c	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00173	85 c0		 test	 eax, eax
  00175	75 16		 jne	 SHORT $LN12@z900_shift
  00177	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017f	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00186	83 e0 04	 and	 eax, 4
  00189	85 c0		 test	 eax, eax
  0018b	75 3f		 jne	 SHORT $LN11@z900_shift
$LN12@z900_shift:
  0018d	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00195	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0019b	0f ba e8 0b	 bts	 eax, 11
  0019f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001ad	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197657
  001b4	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001ba	ba 02 00 00 00	 mov	 edx, 2
  001bf	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	e8 00 00 00 00	 call	 z900_abort_transaction
$LN11@z900_shift:
  001cc	33 c0		 xor	 eax, eax
  001ce	85 c0		 test	 eax, eax
  001d0	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_shift

; 5145 :     DFPINST_CHECK(regs);

  001d6	b8 08 00 00 00	 mov	 eax, 8
  001db	48 6b c0 01	 imul	 rax, rax, 1
  001df	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001ef	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001f5	48 85 c0	 test	 rax, rax
  001f8	74 42		 je	 SHORT $LN14@z900_shift
  001fa	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00202	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00208	d1 e8		 shr	 eax, 1
  0020a	83 e0 01	 and	 eax, 1
  0020d	85 c0		 test	 eax, eax
  0020f	74 58		 je	 SHORT $LN13@z900_shift
  00211	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00219	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00220	b9 08 00 00 00	 mov	 ecx, 8
  00225	48 6b c9 01	 imul	 rcx, rcx, 1
  00229	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00231	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00237	48 85 c0	 test	 rax, rax
  0023a	75 2d		 jne	 SHORT $LN13@z900_shift
$LN14@z900_shift:
  0023c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00244	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0024e	ba 07 00 00 00	 mov	 edx, 7
  00253	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00263	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_shift:

; 5146 :     DFPREGPAIR2_CHECK(r1, r3, regs);

  00269	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  0026d	83 e0 02	 and	 eax, 2
  00270	85 c0		 test	 eax, eax
  00272	75 0b		 jne	 SHORT $LN16@z900_shift
  00274	8b 44 24 38	 mov	 eax, DWORD PTR r3$[rsp]
  00278	83 e0 02	 and	 eax, 2
  0027b	85 c0		 test	 eax, eax
  0027d	74 1b		 je	 SHORT $LN15@z900_shift
$LN16@z900_shift:
  0027f	ba 06 00 00 00	 mov	 edx, 6
  00284	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00294	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_shift:

; 5147 : 
; 5148 :     /* Isolate rightmost 6 bits of second operand address */
; 5149 :     n = effective_addr2 & 0x3F;

  0029a	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0029f	48 83 e0 3f	 and	 rax, 63			; 0000003fH
  002a3	89 44 24 40	 mov	 DWORD PTR n$[rsp], eax

; 5150 : 
; 5151 :     /* Initialise the context for extended DFP */
; 5152 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  002a7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  002ac	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  002b4	e8 00 00 00 00	 call	 decContextDefault

; 5153 : 
; 5154 :     /* Load DFP extended number from FP register r3 */
; 5155 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  002b9	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002c1	48 8d 54 24 58	 lea	 rdx, QWORD PTR x3$[rsp]
  002c6	8b 4c 24 38	 mov	 ecx, DWORD PTR r3$[rsp]
  002ca	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 5156 : 
; 5157 :     /* Convert to internal decimal number format */
; 5158 :     decimal128ToNumber(&x3, &d3);

  002cf	48 8d 54 24 68	 lea	 rdx, QWORD PTR d3$[rsp]
  002d4	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x3$[rsp]
  002d9	e8 00 00 00 00	 call	 decimal128ToNumber

; 5159 : 
; 5160 :     /* For NaN and Inf use coefficient continuation digits only */
; 5161 :     if (decNumberIsNaN(&d3) || decNumberIsInfinite(&d3))

  002de	0f b6 44 24 70	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002e3	83 e0 30	 and	 eax, 48			; 00000030H
  002e6	85 c0		 test	 eax, eax
  002e8	75 0c		 jne	 SHORT $LN19@z900_shift
  002ea	0f b6 44 24 70	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002ef	83 e0 40	 and	 eax, 64			; 00000040H
  002f2	85 c0		 test	 eax, eax
  002f4	74 1e		 je	 SHORT $LN17@z900_shift
$LN19@z900_shift:

; 5162 :     {
; 5163 :         dfp128_clear_cf_and_bxcf(&x3);

  002f6	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x3$[rsp]
  002fb	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 5164 :         decimal128ToNumber(&x3, &d1);

  00300	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00308	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x3$[rsp]
  0030d	e8 00 00 00 00	 call	 decimal128ToNumber

; 5165 :     }

  00312	eb 12		 jmp	 SHORT $LN18@z900_shift
$LN17@z900_shift:

; 5166 :     else
; 5167 :     {
; 5168 :         decNumberCopy(&d1, &d3);

  00314	48 8d 54 24 68	 lea	 rdx, QWORD PTR d3$[rsp]
  00319	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  00321	e8 00 00 00 00	 call	 decNumberCopy
$LN18@z900_shift:

; 5169 :     }
; 5170 : 
; 5171 :     /* Shift coefficient left n digit positions */
; 5172 :     dfp_shift_coeff(&set, &d1, n);

  00326	44 8b 44 24 40	 mov	 r8d, DWORD PTR n$[rsp]
  0032b	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00333	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  0033b	e8 00 00 00 00	 call	 dfp_shift_coeff

; 5173 : 
; 5174 :     /* Convert result to DFP extended format */
; 5175 :     decimal128FromNumber(&x1, &d1, &set);

  00340	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  00348	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00350	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00355	e8 00 00 00 00	 call	 decimal128FromNumber

; 5176 : 
; 5177 :     /* Restore Nan or Inf indicators in the result */
; 5178 :     if (decNumberIsQNaN(&d3))

  0035a	0f b6 44 24 70	 movzx	 eax, BYTE PTR d3$[rsp+8]
  0035f	83 e0 20	 and	 eax, 32			; 00000020H
  00362	85 c0		 test	 eax, eax
  00364	74 11		 je	 SHORT $LN20@z900_shift

; 5179 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  00366	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  0036b	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00370	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf
  00375	eb 38		 jmp	 SHORT $LN21@z900_shift
$LN20@z900_shift:

; 5180 :     else if (decNumberIsSNaN(&d3))

  00377	0f b6 44 24 70	 movzx	 eax, BYTE PTR d3$[rsp+8]
  0037c	83 e0 10	 and	 eax, 16
  0037f	85 c0		 test	 eax, eax
  00381	74 11		 je	 SHORT $LN22@z900_shift

; 5181 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  00383	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  00388	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  0038d	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf
  00392	eb 1b		 jmp	 SHORT $LN23@z900_shift
$LN22@z900_shift:

; 5182 :     else if (decNumberIsInfinite(&d3))

  00394	0f b6 44 24 70	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00399	83 e0 40	 and	 eax, 64			; 00000040H
  0039c	85 c0		 test	 eax, eax
  0039e	74 0f		 je	 SHORT $LN24@z900_shift

; 5183 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  003a0	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  003a5	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  003aa	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf
$LN24@z900_shift:
$LN23@z900_shift:
$LN21@z900_shift:

; 5184 : 
; 5185 :     /* Load result into FP register r1 */
; 5186 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  003af	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003b7	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  003bc	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  003c0	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 5187 : 
; 5188 : } /* end DEF_INST(shift_coefficient_left_dfp_ext) */

  003c5	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003cd	48 33 cc	 xor	 rcx, rsp
  003d0	e8 00 00 00 00	 call	 __security_check_cookie
  003d5	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  003dc	c3		 ret	 0
z900_shift_coefficient_left_dfp_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
signif$ = 40
m4$ = 44
r2$ = 48
r3$ = 52
r1$ = 56
x3$ = 64
x1$ = 72
d3$ = 80
set$ = 120
d1$ = 152
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
z900_reround_dfp_long_reg PROC

; 5076 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5077 : int             signif;                 /* Requested significance    */
; 5078 : int             r1, r2, r3, m4;         /* Values of R and M fields  */
; 5079 : decimal64       x1, x3;                 /* Long DFP values           */
; 5080 : decNumber       d1, d3;                 /* Working decimal numbers   */
; 5081 : decContext      set;                    /* Working context           */
; 5082 : BYTE            dxc;                    /* Data exception code       */
; 5083 : 
; 5084 :     RRF_RM(inst, regs, r1, r2, r3, m4);

  00023	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 34	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_rerou:
  00070	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_rerou
  00093	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_rerou:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_rerou
$LN7@z900_rerou:

; 5085 : 
; 5086 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_rerou
  000b3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_rerou
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_rerou
  000cc	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_rerou
  000df	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_rerou
$LN10@z900_rerou:
  000f5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197621
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_rerou:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_rerou

; 5087 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_rerou
  00162	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_rerou
  00179	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_rerou
$LN12@z900_rerou:
  001a4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_rerou:

; 5088 : 
; 5089 :     /* Initialise the context for long DFP */
; 5090 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001d1	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001d6	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  001db	e8 00 00 00 00	 call	 decContextDefault

; 5091 :     ARCH_DEP(dfp_rounding_mode)(&set, m4, regs);

  001e0	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e8	8b 54 24 2c	 mov	 edx, DWORD PTR m4$[rsp]
  001ec	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  001f1	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 5092 : 
; 5093 :     /* Load significance from bits 58-63 of general register r2 */
; 5094 :     signif = regs->GR_L(r2) & 0x3F;

  001f6	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  001fb	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00203	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0020a	83 e0 3f	 and	 eax, 63			; 0000003fH
  0020d	89 44 24 28	 mov	 DWORD PTR signif$[rsp], eax

; 5095 : 
; 5096 :     /* Reround FP register r3 */
; 5097 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  00211	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00219	48 8d 54 24 40	 lea	 rdx, QWORD PTR x3$[rsp]
  0021e	8b 4c 24 34	 mov	 ecx, DWORD PTR r3$[rsp]
  00222	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 5098 :     decimal64ToNumber(&x3, &d3);

  00227	48 8d 54 24 50	 lea	 rdx, QWORD PTR d3$[rsp]
  0022c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00231	e8 00 00 00 00	 call	 decimal64ToNumber

; 5099 :     if (decNumberIsInfinite(&d3) || decNumberIsNaN(&d3)
; 5100 :         || decNumberIsZero(&d3)
; 5101 :         || signif == 0 || d3.digits <= signif)

  00236	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  0023b	83 e0 40	 and	 eax, 64			; 00000040H
  0023e	85 c0		 test	 eax, eax
  00240	75 42		 jne	 SHORT $LN15@z900_rerou
  00242	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00247	83 e0 30	 and	 eax, 48			; 00000030H
  0024a	85 c0		 test	 eax, eax
  0024c	75 36		 jne	 SHORT $LN15@z900_rerou
  0024e	b8 02 00 00 00	 mov	 eax, 2
  00253	48 6b c0 00	 imul	 rax, rax, 0
  00257	0f b7 44 04 5a	 movzx	 eax, WORD PTR d3$[rsp+rax+10]
  0025c	85 c0		 test	 eax, eax
  0025e	75 13		 jne	 SHORT $LN16@z900_rerou
  00260	83 7c 24 50 01	 cmp	 DWORD PTR d3$[rsp], 1
  00265	75 0c		 jne	 SHORT $LN16@z900_rerou
  00267	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  0026c	83 e0 70	 and	 eax, 112		; 00000070H
  0026f	85 c0		 test	 eax, eax
  00271	74 11		 je	 SHORT $LN15@z900_rerou
$LN16@z900_rerou:
  00273	83 7c 24 28 00	 cmp	 DWORD PTR signif$[rsp], 0
  00278	74 0a		 je	 SHORT $LN15@z900_rerou
  0027a	8b 44 24 28	 mov	 eax, DWORD PTR signif$[rsp]
  0027e	39 44 24 50	 cmp	 DWORD PTR d3$[rsp], eax
  00282	7f 14		 jg	 SHORT $LN13@z900_rerou
$LN15@z900_rerou:

; 5102 :     {
; 5103 :         decNumberCopy(&d1, &d3);

  00284	48 8d 54 24 50	 lea	 rdx, QWORD PTR d3$[rsp]
  00289	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  00291	e8 00 00 00 00	 call	 decNumberCopy

; 5104 :     }

  00296	eb 1f		 jmp	 SHORT $LN14@z900_rerou
$LN13@z900_rerou:

; 5105 :     else
; 5106 :     {
; 5107 :         set.digits = signif;

  00298	8b 44 24 28	 mov	 eax, DWORD PTR signif$[rsp]
  0029c	89 44 24 78	 mov	 DWORD PTR set$[rsp], eax

; 5108 :         decNumberPlus(&d1, &d3, &set);

  002a0	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  002a5	48 8d 54 24 50	 lea	 rdx, QWORD PTR d3$[rsp]
  002aa	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  002b2	e8 00 00 00 00	 call	 decNumberPlus
$LN14@z900_rerou:

; 5109 :     }
; 5110 :     decimal64FromNumber(&x1, &d1, &set);

  002b7	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  002bc	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  002c4	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  002c9	e8 00 00 00 00	 call	 decimal64FromNumber

; 5111 : 
; 5112 :     /* Check for exception condition */
; 5113 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  002ce	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002d6	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  002db	e8 00 00 00 00	 call	 z900_dfp_status_check
  002e0	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 5114 : 
; 5115 :     /* Load result into FP register r1 */
; 5116 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  002e4	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002ec	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  002f1	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  002f5	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 5117 : 
; 5118 :     /* Raise data exception if error occurred */
; 5119 :     if (dxc != 0)

  002fa	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002ff	85 c0		 test	 eax, eax
  00301	74 25		 je	 SHORT $LN17@z900_rerou

; 5120 :     {
; 5121 :         regs->dxc = dxc;

  00303	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00308	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00310	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 5122 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00316	ba 07 00 00 00	 mov	 edx, 7
  0031b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00323	e8 00 00 00 00	 call	 z900_program_interrupt
$LN17@z900_rerou:

; 5123 :     }
; 5124 : 
; 5125 : } /* end DEF_INST(reround_dfp_long_reg) */

  00328	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00330	48 33 cc	 xor	 rcx, rsp
  00333	e8 00 00 00 00	 call	 __security_check_cookie
  00338	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0033f	c3		 ret	 0
z900_reround_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
signif$ = 40
r3$ = 44
r1$ = 48
m4$ = 52
r2$ = 56
d3$ = 64
set$ = 104
x3$ = 136
x1$ = 152
d1$ = 168
__$ArrayPad$ = 208
inst$ = 240
regs$ = 248
z900_reround_dfp_ext_reg PROC

; 5019 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5020 : int             signif;                 /* Requested significance    */
; 5021 : int             r1, r2, r3, m4;         /* Values of R and M fields  */
; 5022 : decimal128      x1, x3;                 /* Extended DFP values       */
; 5023 : decNumber       d1, d3;                 /* Working decimal numbers   */
; 5024 : decContext      set;                    /* Working context           */
; 5025 : BYTE            dxc;                    /* Data exception code       */
; 5026 : 
; 5027 :     RRF_RM(inst, regs, r1, r2, r3, m4);

  00023	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_rerou:
  00070	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_rerou
  00093	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_rerou:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_rerou
$LN7@z900_rerou:

; 5028 : 
; 5029 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_rerou
  000b3	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_rerou
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_rerou
  000cc	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_rerou
  000df	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_rerou
$LN10@z900_rerou:
  000f5	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197585
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_rerou:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_rerou

; 5030 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_rerou
  00162	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_rerou
  00179	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_rerou
$LN12@z900_rerou:
  001a4	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_rerou:

; 5031 :     DFPREGPAIR2_CHECK(r1, r3, regs);

  001d1	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  001d5	83 e0 02	 and	 eax, 2
  001d8	85 c0		 test	 eax, eax
  001da	75 0b		 jne	 SHORT $LN14@z900_rerou
  001dc	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  001e0	83 e0 02	 and	 eax, 2
  001e3	85 c0		 test	 eax, eax
  001e5	74 1b		 je	 SHORT $LN13@z900_rerou
$LN14@z900_rerou:
  001e7	ba 06 00 00 00	 mov	 edx, 6
  001ec	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f4	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_rerou:

; 5032 : 
; 5033 :     /* Initialise the context for extended DFP */
; 5034 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00202	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00207	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  0020c	e8 00 00 00 00	 call	 decContextDefault

; 5035 :     ARCH_DEP(dfp_rounding_mode)(&set, m4, regs);

  00211	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00219	8b 54 24 34	 mov	 edx, DWORD PTR m4$[rsp]
  0021d	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00222	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 5036 : 
; 5037 :     /* Load significance from bits 58-63 of general register r2 */
; 5038 :     signif = regs->GR_L(r2) & 0x3F;

  00227	48 63 44 24 38	 movsxd	 rax, DWORD PTR r2$[rsp]
  0022c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00234	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0023b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0023e	89 44 24 28	 mov	 DWORD PTR signif$[rsp], eax

; 5039 : 
; 5040 :     /* Reround FP register r3 */
; 5041 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  00242	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0024a	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR x3$[rsp]
  00252	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  00256	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 5042 :     decimal128ToNumber(&x3, &d3);

  0025b	48 8d 54 24 40	 lea	 rdx, QWORD PTR d3$[rsp]
  00260	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR x3$[rsp]
  00268	e8 00 00 00 00	 call	 decimal128ToNumber

; 5043 :     if (decNumberIsInfinite(&d3) || decNumberIsNaN(&d3)
; 5044 :         || decNumberIsZero(&d3)
; 5045 :         || signif == 0 || d3.digits <= signif)

  0026d	0f b6 44 24 48	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00272	83 e0 40	 and	 eax, 64			; 00000040H
  00275	85 c0		 test	 eax, eax
  00277	75 42		 jne	 SHORT $LN17@z900_rerou
  00279	0f b6 44 24 48	 movzx	 eax, BYTE PTR d3$[rsp+8]
  0027e	83 e0 30	 and	 eax, 48			; 00000030H
  00281	85 c0		 test	 eax, eax
  00283	75 36		 jne	 SHORT $LN17@z900_rerou
  00285	b8 02 00 00 00	 mov	 eax, 2
  0028a	48 6b c0 00	 imul	 rax, rax, 0
  0028e	0f b7 44 04 4a	 movzx	 eax, WORD PTR d3$[rsp+rax+10]
  00293	85 c0		 test	 eax, eax
  00295	75 13		 jne	 SHORT $LN18@z900_rerou
  00297	83 7c 24 40 01	 cmp	 DWORD PTR d3$[rsp], 1
  0029c	75 0c		 jne	 SHORT $LN18@z900_rerou
  0029e	0f b6 44 24 48	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002a3	83 e0 70	 and	 eax, 112		; 00000070H
  002a6	85 c0		 test	 eax, eax
  002a8	74 11		 je	 SHORT $LN17@z900_rerou
$LN18@z900_rerou:
  002aa	83 7c 24 28 00	 cmp	 DWORD PTR signif$[rsp], 0
  002af	74 0a		 je	 SHORT $LN17@z900_rerou
  002b1	8b 44 24 28	 mov	 eax, DWORD PTR signif$[rsp]
  002b5	39 44 24 40	 cmp	 DWORD PTR d3$[rsp], eax
  002b9	7f 14		 jg	 SHORT $LN15@z900_rerou
$LN17@z900_rerou:

; 5046 :     {
; 5047 :         decNumberCopy(&d1, &d3);

  002bb	48 8d 54 24 40	 lea	 rdx, QWORD PTR d3$[rsp]
  002c0	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  002c8	e8 00 00 00 00	 call	 decNumberCopy

; 5048 :     }

  002cd	eb 1f		 jmp	 SHORT $LN16@z900_rerou
$LN15@z900_rerou:

; 5049 :     else
; 5050 :     {
; 5051 :         set.digits = signif;

  002cf	8b 44 24 28	 mov	 eax, DWORD PTR signif$[rsp]
  002d3	89 44 24 68	 mov	 DWORD PTR set$[rsp], eax

; 5052 :         decNumberPlus(&d1, &d3, &set);

  002d7	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  002dc	48 8d 54 24 40	 lea	 rdx, QWORD PTR d3$[rsp]
  002e1	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  002e9	e8 00 00 00 00	 call	 decNumberPlus
$LN16@z900_rerou:

; 5053 :     }
; 5054 :     decimal128FromNumber(&x1, &d1, &set);

  002ee	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  002f3	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  002fb	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR x1$[rsp]
  00303	e8 00 00 00 00	 call	 decimal128FromNumber

; 5055 : 
; 5056 :     /* Check for exception condition */
; 5057 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00308	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00310	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00315	e8 00 00 00 00	 call	 z900_dfp_status_check
  0031a	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 5058 : 
; 5059 :     /* Load result into FP register r1 */
; 5060 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  0031e	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00326	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR x1$[rsp]
  0032e	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  00332	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 5061 : 
; 5062 :     /* Raise data exception if error occurred */
; 5063 :     if (dxc != 0)

  00337	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0033c	85 c0		 test	 eax, eax
  0033e	74 25		 je	 SHORT $LN19@z900_rerou

; 5064 :     {
; 5065 :         regs->dxc = dxc;

  00340	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00345	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034d	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 5066 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00353	ba 07 00 00 00	 mov	 edx, 7
  00358	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00360	e8 00 00 00 00	 call	 z900_program_interrupt
$LN19@z900_rerou:

; 5067 :     }
; 5068 : 
; 5069 : } /* end DEF_INST(reround_dfp_ext_reg) */

  00365	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0036d	48 33 cc	 xor	 rcx, rsp
  00370	e8 00 00 00 00	 call	 __security_check_cookie
  00375	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0037c	c3		 ret	 0
z900_reround_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
m4$ = 40
r2$ = 44
r3$ = 48
r1$ = 52
x2$ = 56
x3$ = 64
x1$ = 72
set$ = 80
d3$ = 112
d2$ = 152
d1$ = 192
__$ArrayPad$ = 232
inst$ = 256
regs$ = 264
z900_quantize_dfp_long_reg PROC

; 4975 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4976 : int             r1, r2, r3, m4;         /* Values of R and M fields  */
; 4977 : decimal64       x1, x2, x3;             /* Long DFP values           */
; 4978 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 4979 : decContext      set;                    /* Working context           */
; 4980 : BYTE            dxc;                    /* Data exception code       */
; 4981 : 
; 4982 :     RRF_RM(inst, regs, r1, r2, r3, m4);

  00023	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 28	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_quant:
  00070	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_quant
  00093	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_quant:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_quant
$LN7@z900_quant:

; 4983 : 
; 4984 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_quant
  000b3	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_quant
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_quant
  000cc	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_quant
  000df	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_quant
$LN10@z900_quant:
  000f5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197555
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_quant:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_quant

; 4985 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_quant
  00162	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_quant
  00179	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_quant
$LN12@z900_quant:
  001a4	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_quant:

; 4986 : 
; 4987 :     /* Initialise the context for long DFP */
; 4988 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001d1	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001d6	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001db	e8 00 00 00 00	 call	 decContextDefault

; 4989 :     ARCH_DEP(dfp_rounding_mode)(&set, m4, regs);

  001e0	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e8	8b 54 24 28	 mov	 edx, DWORD PTR m4$[rsp]
  001ec	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001f1	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 4990 : 
; 4991 :     /* Quantize FP register r3 using FP register r2 */
; 4992 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001f6	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001fe	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  00203	8b 4c 24 2c	 mov	 ecx, DWORD PTR r2$[rsp]
  00207	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 4993 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  0020c	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00214	48 8d 54 24 40	 lea	 rdx, QWORD PTR x3$[rsp]
  00219	8b 4c 24 30	 mov	 ecx, DWORD PTR r3$[rsp]
  0021d	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 4994 :     decimal64ToNumber(&x2, &d2);

  00222	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0022a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  0022f	e8 00 00 00 00	 call	 decimal64ToNumber

; 4995 :     decimal64ToNumber(&x3, &d3);

  00234	48 8d 54 24 70	 lea	 rdx, QWORD PTR d3$[rsp]
  00239	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  0023e	e8 00 00 00 00	 call	 decimal64ToNumber

; 4996 :     decNumberQuantize(&d1, &d2, &d3, &set);

  00243	4c 8d 4c 24 50	 lea	 r9, QWORD PTR set$[rsp]
  00248	4c 8d 44 24 70	 lea	 r8, QWORD PTR d3$[rsp]
  0024d	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00255	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  0025d	e8 00 00 00 00	 call	 decNumberQuantize

; 4997 :     decimal64FromNumber(&x1, &d1, &set);

  00262	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  00267	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0026f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00274	e8 00 00 00 00	 call	 decimal64FromNumber

; 4998 : 
; 4999 :     /* Check for exception condition */
; 5000 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00279	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00281	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00286	e8 00 00 00 00	 call	 z900_dfp_status_check
  0028b	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 5001 : 
; 5002 :     /* Load result into FP register r1 */
; 5003 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  0028f	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00297	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  0029c	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  002a0	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 5004 : 
; 5005 :     /* Raise data exception if error occurred */
; 5006 :     if (dxc != 0)

  002a5	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002aa	85 c0		 test	 eax, eax
  002ac	74 25		 je	 SHORT $LN13@z900_quant

; 5007 :     {
; 5008 :         regs->dxc = dxc;

  002ae	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002b3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bb	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 5009 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002c1	ba 07 00 00 00	 mov	 edx, 7
  002c6	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ce	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_quant:

; 5010 :     }
; 5011 : 
; 5012 : } /* end DEF_INST(quantize_dfp_long_reg) */

  002d3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002db	48 33 cc	 xor	 rcx, rsp
  002de	e8 00 00 00 00	 call	 __security_check_cookie
  002e3	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  002ea	c3		 ret	 0
z900_quantize_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
m4$ = 52
set$ = 56
x2$ = 88
x3$ = 104
x1$ = 120
d3$ = 136
d2$ = 176
d1$ = 216
__$ArrayPad$ = 256
inst$ = 288
regs$ = 296
z900_quantize_dfp_ext_reg PROC

; 4930 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4931 : int             r1, r2, r3, m4;         /* Values of R and M fields  */
; 4932 : decimal128      x1, x2, x3;             /* Extended DFP values       */
; 4933 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 4934 : decContext      set;                    /* Working context           */
; 4935 : BYTE            dxc;                    /* Data exception code       */
; 4936 : 
; 4937 :     RRF_RM(inst, regs, r1, r2, r3, m4);

  00023	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_quant:
  00070	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_quant
  00093	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_quant:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_quant
$LN7@z900_quant:

; 4938 : 
; 4939 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_quant
  000b3	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_quant
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_quant
  000cc	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_quant
  000df	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_quant
$LN10@z900_quant:
  000f5	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197522
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_quant:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_quant

; 4940 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_quant
  00162	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_quant
  00179	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_quant
$LN12@z900_quant:
  001a4	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_quant:

; 4941 :     DFPREGPAIR3_CHECK(r1, r2, r3, regs);

  001d1	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  001d5	83 e0 02	 and	 eax, 2
  001d8	85 c0		 test	 eax, eax
  001da	75 16		 jne	 SHORT $LN14@z900_quant
  001dc	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001e0	83 e0 02	 and	 eax, 2
  001e3	85 c0		 test	 eax, eax
  001e5	75 0b		 jne	 SHORT $LN14@z900_quant
  001e7	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  001eb	83 e0 02	 and	 eax, 2
  001ee	85 c0		 test	 eax, eax
  001f0	74 1b		 je	 SHORT $LN13@z900_quant
$LN14@z900_quant:
  001f2	ba 06 00 00 00	 mov	 edx, 6
  001f7	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ff	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00207	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_quant:

; 4942 : 
; 4943 :     /* Initialise the context for extended DFP */
; 4944 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0020d	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00212	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  00217	e8 00 00 00 00	 call	 decContextDefault

; 4945 :     ARCH_DEP(dfp_rounding_mode)(&set, m4, regs);

  0021c	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00224	8b 54 24 34	 mov	 edx, DWORD PTR m4$[rsp]
  00228	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  0022d	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 4946 : 
; 4947 :     /* Quantize FP register r3 using FP register r2 */
; 4948 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00232	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0023a	48 8d 54 24 58	 lea	 rdx, QWORD PTR x2$[rsp]
  0023f	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00243	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 4949 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  00248	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00250	48 8d 54 24 68	 lea	 rdx, QWORD PTR x3$[rsp]
  00255	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  00259	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 4950 :     decimal128ToNumber(&x2, &d2);

  0025e	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00266	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x2$[rsp]
  0026b	e8 00 00 00 00	 call	 decimal128ToNumber

; 4951 :     decimal128ToNumber(&x3, &d3);

  00270	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  00278	48 8d 4c 24 68	 lea	 rcx, QWORD PTR x3$[rsp]
  0027d	e8 00 00 00 00	 call	 decimal128ToNumber

; 4952 :     decNumberQuantize(&d1, &d2, &d3, &set);

  00282	4c 8d 4c 24 38	 lea	 r9, QWORD PTR set$[rsp]
  00287	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  0028f	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00297	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  0029f	e8 00 00 00 00	 call	 decNumberQuantize

; 4953 :     decimal128FromNumber(&x1, &d1, &set);

  002a4	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  002a9	48 8d 94 24 d8
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  002b1	48 8d 4c 24 78	 lea	 rcx, QWORD PTR x1$[rsp]
  002b6	e8 00 00 00 00	 call	 decimal128FromNumber

; 4954 : 
; 4955 :     /* Check for exception condition */
; 4956 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  002bb	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002c3	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  002c8	e8 00 00 00 00	 call	 z900_dfp_status_check
  002cd	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4957 : 
; 4958 :     /* Load result into FP register r1 */
; 4959 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  002d1	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002d9	48 8d 54 24 78	 lea	 rdx, QWORD PTR x1$[rsp]
  002de	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  002e2	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 4960 : 
; 4961 :     /* Raise data exception if error occurred */
; 4962 :     if (dxc != 0)

  002e7	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002ec	85 c0		 test	 eax, eax
  002ee	74 25		 je	 SHORT $LN15@z900_quant

; 4963 :     {
; 4964 :         regs->dxc = dxc;

  002f0	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002f5	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fd	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4965 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00303	ba 07 00 00 00	 mov	 edx, 7
  00308	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00310	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_quant:

; 4966 :     }
; 4967 : 
; 4968 : } /* end DEF_INST(quantize_dfp_ext_reg) */

  00315	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0031d	48 33 cc	 xor	 rcx, rsp
  00320	e8 00 00 00 00	 call	 __security_check_cookie
  00325	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0032c	c3		 ret	 0
z900_quantize_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
x2$ = 56
x3$ = 64
x1$ = 72
set$ = 80
d3$ = 112
d2$ = 152
d1$ = 192
__$ArrayPad$ = 232
inst$ = 256
regs$ = 264
z900_multiply_dfp_long_reg PROC

; 4886 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4887 : int             r1, r2, r3;             /* Values of R fields        */
; 4888 : decimal64       x1, x2, x3;             /* Long DFP values           */
; 4889 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 4890 : decContext      set;                    /* Working context           */
; 4891 : BYTE            dxc;                    /* Data exception code       */
; 4892 : 
; 4893 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_multi:
  00062	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_multi
  00085	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_multi:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_multi
$LN7@z900_multi:

; 4894 : 
; 4895 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_multi
  000a5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_multi
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_multi
  000be	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_multi
  000d1	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_multi
$LN10@z900_multi:
  000e7	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197491
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_multi:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_multi

; 4896 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_multi
  00154	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_multi
  0016b	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_multi
$LN12@z900_multi:
  00196	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_multi:

; 4897 : 
; 4898 :     /* Initialise the context for long DFP */
; 4899 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001c3	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001c8	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001cd	e8 00 00 00 00	 call	 decContextDefault

; 4900 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  001d2	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001da	33 d2		 xor	 edx, edx
  001dc	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001e1	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 4901 : 
; 4902 :     /* Multiply FP register r2 by FP register r3 */
; 4903 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001e6	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001ee	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  001f3	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  001f7	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 4904 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  001fc	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00204	48 8d 54 24 40	 lea	 rdx, QWORD PTR x3$[rsp]
  00209	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  0020d	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 4905 :     decimal64ToNumber(&x2, &d2);

  00212	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0021a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  0021f	e8 00 00 00 00	 call	 decimal64ToNumber

; 4906 :     decimal64ToNumber(&x3, &d3);

  00224	48 8d 54 24 70	 lea	 rdx, QWORD PTR d3$[rsp]
  00229	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  0022e	e8 00 00 00 00	 call	 decimal64ToNumber

; 4907 :     decNumberMultiply(&d1, &d2, &d3, &set);

  00233	4c 8d 4c 24 50	 lea	 r9, QWORD PTR set$[rsp]
  00238	4c 8d 44 24 70	 lea	 r8, QWORD PTR d3$[rsp]
  0023d	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00245	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  0024d	e8 00 00 00 00	 call	 decNumberMultiply

; 4908 :     decimal64FromNumber(&x1, &d1, &set);

  00252	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  00257	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0025f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00264	e8 00 00 00 00	 call	 decimal64FromNumber

; 4909 : 
; 4910 :     /* Check for exception condition */
; 4911 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00269	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00271	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00276	e8 00 00 00 00	 call	 z900_dfp_status_check
  0027b	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4912 : 
; 4913 :     /* Load result into FP register r1 */
; 4914 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  0027f	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00287	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  0028c	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  00290	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 4915 : 
; 4916 :     /* Raise data exception if error occurred */
; 4917 :     if (dxc != 0)

  00295	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0029a	85 c0		 test	 eax, eax
  0029c	74 25		 je	 SHORT $LN13@z900_multi

; 4918 :     {
; 4919 :         regs->dxc = dxc;

  0029e	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002a3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ab	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4920 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002b1	ba 07 00 00 00	 mov	 edx, 7
  002b6	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002be	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_multi:

; 4921 :     }
; 4922 : 
; 4923 : } /* end DEF_INST(multiply_dfp_long_reg) */

  002c3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002cb	48 33 cc	 xor	 rcx, rsp
  002ce	e8 00 00 00 00	 call	 __security_check_cookie
  002d3	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  002da	c3		 ret	 0
z900_multiply_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
set$ = 56
x2$ = 88
x3$ = 104
x1$ = 120
d3$ = 136
d2$ = 176
d1$ = 216
__$ArrayPad$ = 256
inst$ = 288
regs$ = 296
z900_multiply_dfp_ext_reg PROC

; 4841 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4842 : int             r1, r2, r3;             /* Values of R fields        */
; 4843 : decimal128      x1, x2, x3;             /* Extended DFP values       */
; 4844 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 4845 : decContext      set;                    /* Working context           */
; 4846 : BYTE            dxc;                    /* Data exception code       */
; 4847 : 
; 4848 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_multi:
  00062	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_multi
  00085	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_multi:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_multi
$LN7@z900_multi:

; 4849 : 
; 4850 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_multi
  000a5	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_multi
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_multi
  000be	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_multi
  000d1	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_multi
$LN10@z900_multi:
  000e7	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197459
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_multi:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_multi

; 4851 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_multi
  00154	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_multi
  0016b	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_multi
$LN12@z900_multi:
  00196	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_multi:

; 4852 :     DFPREGPAIR3_CHECK(r1, r2, r3, regs);

  001c3	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  001c7	83 e0 02	 and	 eax, 2
  001ca	85 c0		 test	 eax, eax
  001cc	75 16		 jne	 SHORT $LN14@z900_multi
  001ce	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001d2	83 e0 02	 and	 eax, 2
  001d5	85 c0		 test	 eax, eax
  001d7	75 0b		 jne	 SHORT $LN14@z900_multi
  001d9	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  001dd	83 e0 02	 and	 eax, 2
  001e0	85 c0		 test	 eax, eax
  001e2	74 1b		 je	 SHORT $LN13@z900_multi
$LN14@z900_multi:
  001e4	ba 06 00 00 00	 mov	 edx, 6
  001e9	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f1	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_multi:

; 4853 : 
; 4854 :     /* Initialise the context for extended DFP */
; 4855 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001ff	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00204	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  00209	e8 00 00 00 00	 call	 decContextDefault

; 4856 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  0020e	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00216	33 d2		 xor	 edx, edx
  00218	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  0021d	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 4857 : 
; 4858 :     /* Multiply FP register r2 by FP register r3 */
; 4859 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00222	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0022a	48 8d 54 24 58	 lea	 rdx, QWORD PTR x2$[rsp]
  0022f	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00233	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 4860 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  00238	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00240	48 8d 54 24 68	 lea	 rdx, QWORD PTR x3$[rsp]
  00245	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  00249	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 4861 :     decimal128ToNumber(&x2, &d2);

  0024e	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00256	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x2$[rsp]
  0025b	e8 00 00 00 00	 call	 decimal128ToNumber

; 4862 :     decimal128ToNumber(&x3, &d3);

  00260	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  00268	48 8d 4c 24 68	 lea	 rcx, QWORD PTR x3$[rsp]
  0026d	e8 00 00 00 00	 call	 decimal128ToNumber

; 4863 :     decNumberMultiply(&d1, &d2, &d3, &set);

  00272	4c 8d 4c 24 38	 lea	 r9, QWORD PTR set$[rsp]
  00277	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  0027f	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00287	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  0028f	e8 00 00 00 00	 call	 decNumberMultiply

; 4864 :     decimal128FromNumber(&x1, &d1, &set);

  00294	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  00299	48 8d 94 24 d8
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  002a1	48 8d 4c 24 78	 lea	 rcx, QWORD PTR x1$[rsp]
  002a6	e8 00 00 00 00	 call	 decimal128FromNumber

; 4865 : 
; 4866 :     /* Check for exception condition */
; 4867 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  002ab	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002b3	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  002b8	e8 00 00 00 00	 call	 z900_dfp_status_check
  002bd	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4868 : 
; 4869 :     /* Load result into FP register r1 */
; 4870 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  002c1	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002c9	48 8d 54 24 78	 lea	 rdx, QWORD PTR x1$[rsp]
  002ce	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  002d2	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 4871 : 
; 4872 :     /* Raise data exception if error occurred */
; 4873 :     if (dxc != 0)

  002d7	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002dc	85 c0		 test	 eax, eax
  002de	74 25		 je	 SHORT $LN15@z900_multi

; 4874 :     {
; 4875 :         regs->dxc = dxc;

  002e0	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002e5	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ed	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4876 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002f3	ba 07 00 00 00	 mov	 edx, 7
  002f8	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00300	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_multi:

; 4877 :     }
; 4878 : 
; 4879 : } /* end DEF_INST(multiply_dfp_ext_reg) */

  00305	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0030d	48 33 cc	 xor	 rcx, rsp
  00310	e8 00 00 00 00	 call	 __security_check_cookie
  00315	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0031c	c3		 ret	 0
z900_multiply_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
x1$ = 36
temp$1 = 40
scale$ = 44
m4$ = 48
m3$ = 52
r2$ = 56
r1$ = 60
x2$ = 64
set$ = 72
d2$ = 104
d1$ = 144
pwork$ = 184
__$ArrayPad$ = 200
inst$ = 224
regs$ = 232
z900_load_rounded_dfp_long_to_short_reg PROC

; 4755 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4756 : int             r1, r2, m3, m4;         /* Values of R and M fields  */
; 4757 : decimal32       x1;                     /* Short DFP value           */
; 4758 : decimal64       x2;                     /* Long DFP value            */
; 4759 : decNumber       d1, d2;                 /* Working decimal numbers   */
; 4760 : decContext      set;                    /* Working context           */
; 4761 : int32_t         scale;                  /* Scaling factor            */
; 4762 : BYTE            pwork[9];               /* 17-digit packed work area */
; 4763 : BYTE            dxc;                    /* Data exception code       */
; 4764 : 
; 4765 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 30	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 34	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_load_:
  00070	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_load_
  00093	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 4766 : 
; 4767 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_load_
  000b3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_load_
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_load_
  000cc	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_load_
  000df	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000f5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197419
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 4768 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_load_
  00162	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_load_
  00179	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  001a4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 4769 : 
; 4770 :     /* Initialise the context for long DFP */
; 4771 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001d1	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001d6	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001db	e8 00 00 00 00	 call	 decContextDefault

; 4772 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  001e0	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e8	8b 54 24 34	 mov	 edx, DWORD PTR m3$[rsp]
  001ec	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001f1	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 4773 : 
; 4774 :     /* Load DFP long number from FP register r2 */
; 4775 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001f6	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001fe	48 8d 54 24 40	 lea	 rdx, QWORD PTR x2$[rsp]
  00203	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  00207	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 4776 :     decimal64ToNumber(&x2, &d2);

  0020c	48 8d 54 24 68	 lea	 rdx, QWORD PTR d2$[rsp]
  00211	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x2$[rsp]
  00216	e8 00 00 00 00	 call	 decimal64ToNumber

; 4777 : 
; 4778 :     /* Convert number to DFP short format */
; 4779 :     if ((decNumberIsInfinite(&d2) && (m4 & 0x08))
; 4780 :          || decNumberIsNaN(&d2))

  0021b	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00220	83 e0 40	 and	 eax, 64			; 00000040H
  00223	85 c0		 test	 eax, eax
  00225	74 0b		 je	 SHORT $LN16@z900_load_
  00227	8b 44 24 30	 mov	 eax, DWORD PTR m4$[rsp]
  0022b	83 e0 08	 and	 eax, 8
  0022e	85 c0		 test	 eax, eax
  00230	75 10		 jne	 SHORT $LN15@z900_load_
$LN16@z900_load_:
  00232	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00237	83 e0 30	 and	 eax, 48			; 00000030H
  0023a	85 c0		 test	 eax, eax
  0023c	0f 84 fc 00 00
	00		 je	 $LN13@z900_load_
$LN15@z900_load_:

; 4781 :     {
; 4782 :         /* For Inf with mask bit 0 set, or for QNan or SNan,
; 4783 :            propagate the low 6 digits */
; 4784 :         dfp64_clear_cf_and_bxcf(&x2);

  00242	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x2$[rsp]
  00247	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 4785 :         decimal64ToNumber(&x2, &d1);

  0024c	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00254	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x2$[rsp]
  00259	e8 00 00 00 00	 call	 decimal64ToNumber

; 4786 :         decPackedFromNumber(pwork, sizeof(pwork), &scale, &d1);

  0025e	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR d1$[rsp]
  00266	4c 8d 44 24 2c	 lea	 r8, QWORD PTR scale$[rsp]
  0026b	ba 09 00 00 00	 mov	 edx, 9
  00270	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  00278	e8 00 00 00 00	 call	 decPackedFromNumber

; 4787 :         scale = 0;

  0027d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR scale$[rsp], 0

; 4788 :         decPackedToNumber(pwork+sizeof(pwork)-4, 4, &scale, &d1);

  00285	48 8d 84 24 bd
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+5]
  0028d	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR d1$[rsp]
  00295	4c 8d 44 24 2c	 lea	 r8, QWORD PTR scale$[rsp]
  0029a	ba 04 00 00 00	 mov	 edx, 4
  0029f	48 8b c8	 mov	 rcx, rax
  002a2	e8 00 00 00 00	 call	 decPackedToNumber

; 4789 :         decimal32FromNumber(&x1, &d1, &set);

  002a7	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  002ac	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  002b4	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x1$[rsp]
  002b9	e8 00 00 00 00	 call	 decimal32FromNumber

; 4790 :         if (decNumberIsInfinite(&d2))

  002be	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002c3	83 e0 40	 and	 eax, 64			; 00000040H
  002c6	85 c0		 test	 eax, eax
  002c8	74 11		 je	 SHORT $LN17@z900_load_

; 4791 :         {
; 4792 :             dfp32_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  002ca	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  002cf	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x1$[rsp]
  002d4	e8 00 00 00 00	 call	 dfp32_set_cf_and_bxcf

; 4793 :         }

  002d9	eb 61		 jmp	 SHORT $LN18@z900_load_
$LN17@z900_load_:

; 4794 :         else if (decNumberIsQNaN(&d2))

  002db	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002e0	83 e0 20	 and	 eax, 32			; 00000020H
  002e3	85 c0		 test	 eax, eax
  002e5	74 11		 je	 SHORT $LN19@z900_load_

; 4795 :         {
; 4796 :             dfp32_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  002e7	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  002ec	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x1$[rsp]
  002f1	e8 00 00 00 00	 call	 dfp32_set_cf_and_bxcf

; 4797 :         }

  002f6	eb 44		 jmp	 SHORT $LN20@z900_load_
$LN19@z900_load_:

; 4798 :         else /* it is an SNaN */
; 4799 :         {
; 4800 :             /* For SNaN with mask bit 0 off, convert to a QNaN
; 4801 :                and raise signaling condition */
; 4802 :             if (decNumberIsSNaN(&d2) && (m4 & 0x08) == 0)

  002f8	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002fd	83 e0 10	 and	 eax, 16
  00300	85 c0		 test	 eax, eax
  00302	74 29		 je	 SHORT $LN21@z900_load_
  00304	8b 44 24 30	 mov	 eax, DWORD PTR m4$[rsp]
  00308	83 e0 08	 and	 eax, 8
  0030b	85 c0		 test	 eax, eax
  0030d	75 1e		 jne	 SHORT $LN21@z900_load_

; 4803 :             {
; 4804 :                 dfp32_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  0030f	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  00314	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x1$[rsp]
  00319	e8 00 00 00 00	 call	 dfp32_set_cf_and_bxcf

; 4805 :                 set.status |= DEC_IEEE_854_Invalid_operation;

  0031e	8b 44 24 5c	 mov	 eax, DWORD PTR set$[rsp+20]
  00322	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00327	89 44 24 5c	 mov	 DWORD PTR set$[rsp+20], eax

; 4806 :             }

  0032b	eb 0f		 jmp	 SHORT $LN22@z900_load_
$LN21@z900_load_:

; 4807 :             else
; 4808 :             {
; 4809 :                 dfp32_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  0032d	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  00332	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x1$[rsp]
  00337	e8 00 00 00 00	 call	 dfp32_set_cf_and_bxcf
$LN22@z900_load_:
$LN20@z900_load_:
$LN18@z900_load_:

; 4810 :             }
; 4811 :         }
; 4812 :     }

  0033c	eb 29		 jmp	 SHORT $LN14@z900_load_
$LN13@z900_load_:

; 4813 :     else
; 4814 :     {
; 4815 :         /* For finite number, load value rounded to short DFP format,
; 4816 :            or for Inf with mask bit 0 not set, load default infinity */
; 4817 :         decNumberCopy(&d1, &d2);

  0033e	48 8d 54 24 68	 lea	 rdx, QWORD PTR d2$[rsp]
  00343	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  0034b	e8 00 00 00 00	 call	 decNumberCopy

; 4818 :         decimal32FromNumber(&x1, &d1, &set);

  00350	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  00355	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0035d	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x1$[rsp]
  00362	e8 00 00 00 00	 call	 decimal32FromNumber
$LN14@z900_load_:

; 4819 :     }
; 4820 : 
; 4821 :     /* Check for exception condition */
; 4822 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00367	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0036f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00374	e8 00 00 00 00	 call	 z900_dfp_status_check
  00379	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4823 : 
; 4824 :     /* Load result into FP register r1 */
; 4825 :     ARCH_DEP(dfp_reg_from_decimal32)(r1, &x1, regs);

  0037d	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00385	48 8d 54 24 24	 lea	 rdx, QWORD PTR x1$[rsp]
  0038a	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  0038e	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal32

; 4826 : 
; 4827 :     /* Raise data exception if error occurred */
; 4828 :     if (dxc != 0)

  00393	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00398	85 c0		 test	 eax, eax
  0039a	74 25		 je	 SHORT $LN23@z900_load_

; 4829 :     {
; 4830 :         regs->dxc = dxc;

  0039c	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  003a1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a9	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4831 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  003af	ba 07 00 00 00	 mov	 edx, 7
  003b4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003bc	e8 00 00 00 00	 call	 z900_program_interrupt
$LN23@z900_load_:

; 4832 :     }
; 4833 : 
; 4834 : } /* end DEF_INST(load_rounded_dfp_long_to_short_reg) */

  003c1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003c9	48 33 cc	 xor	 rcx, rsp
  003cc	e8 00 00 00 00	 call	 __security_check_cookie
  003d1	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  003d8	c3		 ret	 0
z900_load_rounded_dfp_long_to_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
scale$ = 44
m4$ = 48
m3$ = 52
r1$ = 56
x1$ = 64
x2$ = 72
set$ = 88
d2$ = 120
d1$ = 160
pwork$ = 200
__$ArrayPad$ = 224
inst$ = 256
regs$ = 264
z900_load_rounded_dfp_ext_to_long_reg PROC

; 4668 : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4669 : int             r1, r2, m3, m4;         /* Values of R and M fields  */
; 4670 : decimal64       x1;                     /* Long DFP value            */
; 4671 : decimal128      x2;                     /* Extended DFP value        */
; 4672 : decNumber       d1, d2;                 /* Working decimal numbers   */
; 4673 : decContext      set;                    /* Working context           */
; 4674 : int32_t         scale;                  /* Scaling factor            */
; 4675 : BYTE            pwork[17];              /* 33-digit packed work area */
; 4676 : BYTE            dxc;                    /* Data exception code       */
; 4677 : 
; 4678 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 30	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 34	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_load_:
  00070	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_load_
  00093	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 4679 : 
; 4680 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_load_
  000b3	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_load_
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_load_
  000cc	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_load_
  000df	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000f5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197377
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 4681 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_load_
  00162	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_load_
  00179	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  001a4	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 4682 :     DFPREGPAIR_CHECK(r2, regs);

  001d1	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001d5	83 e0 02	 and	 eax, 2
  001d8	85 c0		 test	 eax, eax
  001da	74 1b		 je	 SHORT $LN13@z900_load_
  001dc	ba 06 00 00 00	 mov	 edx, 6
  001e1	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_load_:

; 4683 : 
; 4684 :     /* Initialise the context for extended DFP */
; 4685 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001f7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001fc	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  00201	e8 00 00 00 00	 call	 decContextDefault

; 4686 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00206	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020e	8b 54 24 34	 mov	 edx, DWORD PTR m3$[rsp]
  00212	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  00217	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 4687 : 
; 4688 :     /* Load DFP extended number from FP register r2 */
; 4689 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  0021c	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00224	48 8d 54 24 48	 lea	 rdx, QWORD PTR x2$[rsp]
  00229	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  0022d	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 4690 :     decimal128ToNumber(&x2, &d2);

  00232	48 8d 54 24 78	 lea	 rdx, QWORD PTR d2$[rsp]
  00237	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  0023c	e8 00 00 00 00	 call	 decimal128ToNumber

; 4691 : 
; 4692 :     /* Convert number to DFP long format */
; 4693 :     if ((decNumberIsInfinite(&d2) && (m4 & 0x08))
; 4694 :          || decNumberIsNaN(&d2))

  00241	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00249	83 e0 40	 and	 eax, 64			; 00000040H
  0024c	85 c0		 test	 eax, eax
  0024e	74 0b		 je	 SHORT $LN17@z900_load_
  00250	8b 44 24 30	 mov	 eax, DWORD PTR m4$[rsp]
  00254	83 e0 08	 and	 eax, 8
  00257	85 c0		 test	 eax, eax
  00259	75 13		 jne	 SHORT $LN16@z900_load_
$LN17@z900_load_:
  0025b	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00263	83 e0 30	 and	 eax, 48			; 00000030H
  00266	85 c0		 test	 eax, eax
  00268	0f 84 05 01 00
	00		 je	 $LN14@z900_load_
$LN16@z900_load_:

; 4695 :     {
; 4696 :         /* For Inf with mask bit 0 set, or for QNan or SNan,
; 4697 :            propagate the low 15 digits */
; 4698 :         dfp128_clear_cf_and_bxcf(&x2);

  0026e	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  00273	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 4699 :         decimal128ToNumber(&x2, &d1);

  00278	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00280	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  00285	e8 00 00 00 00	 call	 decimal128ToNumber

; 4700 :         decPackedFromNumber(pwork, sizeof(pwork), &scale, &d1);

  0028a	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR d1$[rsp]
  00292	4c 8d 44 24 2c	 lea	 r8, QWORD PTR scale$[rsp]
  00297	ba 11 00 00 00	 mov	 edx, 17
  0029c	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  002a4	e8 00 00 00 00	 call	 decPackedFromNumber

; 4701 :         scale = 0;

  002a9	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR scale$[rsp], 0

; 4702 :         decPackedToNumber(pwork+sizeof(pwork)-8, 8, &scale, &d1);

  002b1	48 8d 84 24 d1
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+9]
  002b9	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR d1$[rsp]
  002c1	4c 8d 44 24 2c	 lea	 r8, QWORD PTR scale$[rsp]
  002c6	ba 08 00 00 00	 mov	 edx, 8
  002cb	48 8b c8	 mov	 rcx, rax
  002ce	e8 00 00 00 00	 call	 decPackedToNumber

; 4703 :         decimal64FromNumber(&x1, &d1, &set);

  002d3	4c 8d 44 24 58	 lea	 r8, QWORD PTR set$[rsp]
  002d8	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  002e0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002e5	e8 00 00 00 00	 call	 decimal64FromNumber

; 4704 :         if (decNumberIsInfinite(&d2))

  002ea	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002f2	83 e0 40	 and	 eax, 64			; 00000040H
  002f5	85 c0		 test	 eax, eax
  002f7	74 11		 je	 SHORT $LN18@z900_load_

; 4705 :         {
; 4706 :             dfp64_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  002f9	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  002fe	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00303	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4707 :         }

  00308	eb 67		 jmp	 SHORT $LN19@z900_load_
$LN18@z900_load_:

; 4708 :         else if (decNumberIsQNaN(&d2))

  0030a	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00312	83 e0 20	 and	 eax, 32			; 00000020H
  00315	85 c0		 test	 eax, eax
  00317	74 11		 je	 SHORT $LN20@z900_load_

; 4709 :         {
; 4710 :             dfp64_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  00319	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  0031e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00323	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4711 :         }

  00328	eb 47		 jmp	 SHORT $LN21@z900_load_
$LN20@z900_load_:

; 4712 :         else /* it is an SNaN */
; 4713 :         {
; 4714 :             /* For SNaN with mask bit 0 off, convert to a QNaN
; 4715 :                and raise signaling condition */
; 4716 :             if (decNumberIsSNaN(&d2) && (m4 & 0x08) == 0)

  0032a	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00332	83 e0 10	 and	 eax, 16
  00335	85 c0		 test	 eax, eax
  00337	74 29		 je	 SHORT $LN22@z900_load_
  00339	8b 44 24 30	 mov	 eax, DWORD PTR m4$[rsp]
  0033d	83 e0 08	 and	 eax, 8
  00340	85 c0		 test	 eax, eax
  00342	75 1e		 jne	 SHORT $LN22@z900_load_

; 4717 :             {
; 4718 :                 dfp64_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  00344	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  00349	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  0034e	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4719 :                 set.status |= DEC_IEEE_854_Invalid_operation;

  00353	8b 44 24 6c	 mov	 eax, DWORD PTR set$[rsp+20]
  00357	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  0035c	89 44 24 6c	 mov	 DWORD PTR set$[rsp+20], eax

; 4720 :             }

  00360	eb 0f		 jmp	 SHORT $LN23@z900_load_
$LN22@z900_load_:

; 4721 :             else
; 4722 :             {
; 4723 :                 dfp64_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  00362	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  00367	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  0036c	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
$LN23@z900_load_:
$LN21@z900_load_:
$LN19@z900_load_:

; 4724 :             }
; 4725 :         }
; 4726 :     }

  00371	eb 29		 jmp	 SHORT $LN15@z900_load_
$LN14@z900_load_:

; 4727 :     else
; 4728 :     {
; 4729 :         /* For finite number, load value rounded to long DFP format,
; 4730 :            or for Inf with mask bit 0 not set, load default infinity */
; 4731 :         decNumberCopy(&d1, &d2);

  00373	48 8d 54 24 78	 lea	 rdx, QWORD PTR d2$[rsp]
  00378	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  00380	e8 00 00 00 00	 call	 decNumberCopy

; 4732 :         decimal64FromNumber(&x1, &d1, &set);

  00385	4c 8d 44 24 58	 lea	 r8, QWORD PTR set$[rsp]
  0038a	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00392	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00397	e8 00 00 00 00	 call	 decimal64FromNumber
$LN15@z900_load_:

; 4733 :     }
; 4734 : 
; 4735 :     /* Check for exception condition */
; 4736 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0039c	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003a4	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  003a9	e8 00 00 00 00	 call	 z900_dfp_status_check
  003ae	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4737 : 
; 4738 :     /* Load result into FP register r1 */
; 4739 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  003b2	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003ba	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  003bf	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  003c3	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 4740 : 
; 4741 :     /* Raise data exception if error occurred */
; 4742 :     if (dxc != 0)

  003c8	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  003cd	85 c0		 test	 eax, eax
  003cf	74 25		 je	 SHORT $LN24@z900_load_

; 4743 :     {
; 4744 :         regs->dxc = dxc;

  003d1	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  003d6	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003de	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4745 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  003e4	ba 07 00 00 00	 mov	 edx, 7
  003e9	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f1	e8 00 00 00 00	 call	 z900_program_interrupt
$LN24@z900_load_:

; 4746 :     }
; 4747 : 
; 4748 : } /* end DEF_INST(load_rounded_dfp_ext_to_long_reg) */

  003f6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003fe	48 33 cc	 xor	 rcx, rsp
  00401	e8 00 00 00 00	 call	 __security_check_cookie
  00406	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  0040d	c3		 ret	 0
z900_load_rounded_dfp_ext_to_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
x2$ = 36
temp$1 = 40
m4$ = 44
r2$ = 48
r1$ = 52
x1$ = 56
d1$ = 64
set$ = 104
d2$ = 136
__$ArrayPad$ = 176
inst$ = 208
regs$ = 216
z900_load_lengthened_dfp_short_to_long_reg PROC

; 4600 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4601 : int             r1, r2, m4;             /* Values of R and M fields  */
; 4602 : decimal64       x1;                     /* Long DFP value            */
; 4603 : decimal32       x2;                     /* Short DFP value           */
; 4604 : decNumber       d1, d2;                 /* Working decimal numbers   */
; 4605 : decContext      set;                    /* Working context           */
; 4606 : BYTE            dxc;                    /* Data exception code       */
; 4607 : 
; 4608 :     RRF_M4(inst, regs, r1, r2, m4);

  00023	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR m4$[rsp], eax
$LN4@z900_load_:
  00062	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_load_
  00085	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 4609 : 
; 4610 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_load_
  000a5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_load_
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_load_
  000be	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_load_
  000d1	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000e7	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197341
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 4611 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_load_
  00154	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_load_
  0016b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  00196	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 4612 : 
; 4613 :     /* Initialise the context for long DFP */
; 4614 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001c3	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001c8	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  001cd	e8 00 00 00 00	 call	 decContextDefault

; 4615 : 
; 4616 :     /* Load DFP short number from FP register r2 */
; 4617 :     ARCH_DEP(dfp_reg_to_decimal32)(r2, &x2, regs);

  001d2	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001da	48 8d 54 24 24	 lea	 rdx, QWORD PTR x2$[rsp]
  001df	8b 4c 24 30	 mov	 ecx, DWORD PTR r2$[rsp]
  001e3	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal32

; 4618 :     decimal32ToNumber(&x2, &d2);

  001e8	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001f0	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x2$[rsp]
  001f5	e8 00 00 00 00	 call	 decimal32ToNumber

; 4619 : 
; 4620 :     /* Convert number to DFP long format */
; 4621 :     if (decNumberIsInfinite(&d2) && (m4 & 0x08))

  001fa	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00202	83 e0 40	 and	 eax, 64			; 00000040H
  00205	85 c0		 test	 eax, eax
  00207	74 4c		 je	 SHORT $LN13@z900_load_
  00209	8b 44 24 2c	 mov	 eax, DWORD PTR m4$[rsp]
  0020d	83 e0 08	 and	 eax, 8
  00210	85 c0		 test	 eax, eax
  00212	74 41		 je	 SHORT $LN13@z900_load_

; 4622 :     {
; 4623 :         /* For Inf with mask bit 0 set, propagate the digits */
; 4624 :         dfp32_clear_cf_and_bxcf(&x2);

  00214	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x2$[rsp]
  00219	e8 00 00 00 00	 call	 dfp32_clear_cf_and_bxcf

; 4625 :         decimal32ToNumber(&x2, &d1);

  0021e	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  00223	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x2$[rsp]
  00228	e8 00 00 00 00	 call	 decimal32ToNumber

; 4626 :         decimal64FromNumber(&x1, &d1, &set);

  0022d	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  00232	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  00237	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  0023c	e8 00 00 00 00	 call	 decimal64FromNumber

; 4627 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  00241	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00246	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  0024b	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4628 :     }

  00250	e9 99 00 00 00	 jmp	 $LN14@z900_load_
$LN13@z900_load_:

; 4629 :     else if (decNumberIsNaN(&d2))

  00255	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0025d	83 e0 30	 and	 eax, 48			; 00000030H
  00260	85 c0		 test	 eax, eax
  00262	74 64		 je	 SHORT $LN15@z900_load_

; 4630 :     {
; 4631 :         decimal32ToNumber(&x2, &d1);

  00264	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  00269	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x2$[rsp]
  0026e	e8 00 00 00 00	 call	 decimal32ToNumber

; 4632 :         /* For SNaN with mask bit 0 off, convert to a QNaN
; 4633 :            and raise signaling condition */
; 4634 :         if (decNumberIsSNaN(&d2) && (m4 & 0x08) == 0)

  00273	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0027b	83 e0 10	 and	 eax, 16
  0027e	85 c0		 test	 eax, eax
  00280	74 30		 je	 SHORT $LN17@z900_load_
  00282	8b 44 24 2c	 mov	 eax, DWORD PTR m4$[rsp]
  00286	83 e0 08	 and	 eax, 8
  00289	85 c0		 test	 eax, eax
  0028b	75 25		 jne	 SHORT $LN17@z900_load_

; 4635 :         {
; 4636 :             set.status |= DEC_IEEE_854_Invalid_operation;

  0028d	8b 44 24 7c	 mov	 eax, DWORD PTR set$[rsp+20]
  00291	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00296	89 44 24 7c	 mov	 DWORD PTR set$[rsp+20], eax

; 4637 :             d1.bits &= ~DECSNAN;

  0029a	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0029f	83 e0 ef	 and	 eax, -17
  002a2	88 44 24 48	 mov	 BYTE PTR d1$[rsp+8], al

; 4638 :             d1.bits |= DECNAN;

  002a6	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  002ab	83 c8 20	 or	 eax, 32			; 00000020H
  002ae	88 44 24 48	 mov	 BYTE PTR d1$[rsp+8], al
$LN17@z900_load_:

; 4639 :         }
; 4640 :         decimal64FromNumber(&x1, &d1, &set);

  002b2	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  002b7	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  002bc	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  002c1	e8 00 00 00 00	 call	 decimal64FromNumber

; 4641 :     }

  002c6	eb 26		 jmp	 SHORT $LN16@z900_load_
$LN15@z900_load_:

; 4642 :     else
; 4643 :     {
; 4644 :         decNumberCopy(&d1, &d2);

  002c8	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  002d0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR d1$[rsp]
  002d5	e8 00 00 00 00	 call	 decNumberCopy

; 4645 :         decimal64FromNumber(&x1, &d1, &set);

  002da	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  002df	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  002e4	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  002e9	e8 00 00 00 00	 call	 decimal64FromNumber
$LN16@z900_load_:
$LN14@z900_load_:

; 4646 :     }
; 4647 : 
; 4648 :     /* Check for exception condition */
; 4649 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  002ee	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002f6	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  002fb	e8 00 00 00 00	 call	 z900_dfp_status_check
  00300	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4650 : 
; 4651 :     /* Load result into FP register r1 */
; 4652 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  00304	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0030c	48 8d 54 24 38	 lea	 rdx, QWORD PTR x1$[rsp]
  00311	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00315	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 4653 : 
; 4654 :     /* Raise data exception if error occurred */
; 4655 :     if (dxc != 0)

  0031a	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0031f	85 c0		 test	 eax, eax
  00321	74 25		 je	 SHORT $LN18@z900_load_

; 4656 :     {
; 4657 :         regs->dxc = dxc;

  00323	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00328	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00330	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4658 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00336	ba 07 00 00 00	 mov	 edx, 7
  0033b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00343	e8 00 00 00 00	 call	 z900_program_interrupt
$LN18@z900_load_:

; 4659 :     }
; 4660 : 
; 4661 : } /* end DEF_INST(load_lengthened_dfp_short_to_long_reg) */

  00348	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00350	48 33 cc	 xor	 rcx, rsp
  00353	e8 00 00 00 00	 call	 __security_check_cookie
  00358	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0035f	c3		 ret	 0
z900_load_lengthened_dfp_short_to_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
m4$ = 40
r1$ = 44
r2$ = 48
x2$ = 56
x1$ = 64
d1$ = 80
set$ = 120
d2$ = 152
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
z900_load_lengthened_dfp_long_to_ext_reg PROC

; 4531 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4532 : int             r1, r2, m4;             /* Values of R and M fields  */
; 4533 : decimal128      x1;                     /* Extended DFP value        */
; 4534 : decimal64       x2;                     /* Long DFP value            */
; 4535 : decNumber       d1, d2;                 /* Working decimal numbers   */
; 4536 : decContext      set;                    /* Working context           */
; 4537 : BYTE            dxc;                    /* Data exception code       */
; 4538 : 
; 4539 :     RRF_M4(inst, regs, r1, r2, m4);

  00023	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 28	 mov	 DWORD PTR m4$[rsp], eax
$LN4@z900_load_:
  00062	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_load_
  00085	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 4540 : 
; 4541 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_load_
  000a5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_load_
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_load_
  000be	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_load_
  000d1	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000e7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197307
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 4542 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_load_
  00154	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_load_
  0016b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  00196	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 4543 :     DFPREGPAIR_CHECK(r1, regs);

  001c3	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001c7	83 e0 02	 and	 eax, 2
  001ca	85 c0		 test	 eax, eax
  001cc	74 1b		 je	 SHORT $LN13@z900_load_
  001ce	ba 06 00 00 00	 mov	 edx, 6
  001d3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e3	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_load_:

; 4544 : 
; 4545 :     /* Initialise the context for extended DFP */
; 4546 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001e9	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001ee	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  001f3	e8 00 00 00 00	 call	 decContextDefault

; 4547 : 
; 4548 :     /* Load DFP long number from FP register r2 */
; 4549 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001f8	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00200	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  00205	8b 4c 24 30	 mov	 ecx, DWORD PTR r2$[rsp]
  00209	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 4550 :     decimal64ToNumber(&x2, &d2);

  0020e	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00216	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  0021b	e8 00 00 00 00	 call	 decimal64ToNumber

; 4551 : 
; 4552 :     /* Convert number to DFP extended format */
; 4553 :     if (decNumberIsInfinite(&d2) && (m4 & 0x08))

  00220	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00228	83 e0 40	 and	 eax, 64			; 00000040H
  0022b	85 c0		 test	 eax, eax
  0022d	74 4c		 je	 SHORT $LN14@z900_load_
  0022f	8b 44 24 28	 mov	 eax, DWORD PTR m4$[rsp]
  00233	83 e0 08	 and	 eax, 8
  00236	85 c0		 test	 eax, eax
  00238	74 41		 je	 SHORT $LN14@z900_load_

; 4554 :     {
; 4555 :         /* For Inf with mask bit 0 set, propagate the digits */
; 4556 :         dfp64_clear_cf_and_bxcf(&x2);

  0023a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  0023f	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 4557 :         decimal64ToNumber(&x2, &d1);

  00244	48 8d 54 24 50	 lea	 rdx, QWORD PTR d1$[rsp]
  00249	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  0024e	e8 00 00 00 00	 call	 decimal64ToNumber

; 4558 :         decimal128FromNumber(&x1, &d1, &set);

  00253	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  00258	48 8d 54 24 50	 lea	 rdx, QWORD PTR d1$[rsp]
  0025d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00262	e8 00 00 00 00	 call	 decimal128FromNumber

; 4559 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  00267	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  0026c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00271	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf

; 4560 :     }

  00276	e9 9f 00 00 00	 jmp	 $LN15@z900_load_
$LN14@z900_load_:

; 4561 :     else if (decNumberIsNaN(&d2))

  0027b	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00283	83 e0 30	 and	 eax, 48			; 00000030H
  00286	85 c0		 test	 eax, eax
  00288	74 6a		 je	 SHORT $LN16@z900_load_

; 4562 :     {
; 4563 :         decimal64ToNumber(&x2, &d1);

  0028a	48 8d 54 24 50	 lea	 rdx, QWORD PTR d1$[rsp]
  0028f	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00294	e8 00 00 00 00	 call	 decimal64ToNumber

; 4564 :         /* For SNaN with mask bit 0 off, convert to a QNaN
; 4565 :            and raise signaling condition */
; 4566 :         if (decNumberIsSNaN(&d2) && (m4 & 0x08) == 0)

  00299	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002a1	83 e0 10	 and	 eax, 16
  002a4	85 c0		 test	 eax, eax
  002a6	74 36		 je	 SHORT $LN18@z900_load_
  002a8	8b 44 24 28	 mov	 eax, DWORD PTR m4$[rsp]
  002ac	83 e0 08	 and	 eax, 8
  002af	85 c0		 test	 eax, eax
  002b1	75 2b		 jne	 SHORT $LN18@z900_load_

; 4567 :         {
; 4568 :             set.status |= DEC_IEEE_854_Invalid_operation;

  002b3	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR set$[rsp+20]
  002ba	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  002bf	89 84 24 8c 00
	00 00		 mov	 DWORD PTR set$[rsp+20], eax

; 4569 :             d1.bits &= ~DECSNAN;

  002c6	0f b6 44 24 58	 movzx	 eax, BYTE PTR d1$[rsp+8]
  002cb	83 e0 ef	 and	 eax, -17
  002ce	88 44 24 58	 mov	 BYTE PTR d1$[rsp+8], al

; 4570 :             d1.bits |= DECNAN;

  002d2	0f b6 44 24 58	 movzx	 eax, BYTE PTR d1$[rsp+8]
  002d7	83 c8 20	 or	 eax, 32			; 00000020H
  002da	88 44 24 58	 mov	 BYTE PTR d1$[rsp+8], al
$LN18@z900_load_:

; 4571 :         }
; 4572 :         decimal128FromNumber(&x1, &d1, &set);

  002de	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  002e3	48 8d 54 24 50	 lea	 rdx, QWORD PTR d1$[rsp]
  002e8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002ed	e8 00 00 00 00	 call	 decimal128FromNumber

; 4573 :     }

  002f2	eb 26		 jmp	 SHORT $LN17@z900_load_
$LN16@z900_load_:

; 4574 :     else
; 4575 :     {
; 4576 :         decNumberCopy(&d1, &d2);

  002f4	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  002fc	48 8d 4c 24 50	 lea	 rcx, QWORD PTR d1$[rsp]
  00301	e8 00 00 00 00	 call	 decNumberCopy

; 4577 :         decimal128FromNumber(&x1, &d1, &set);

  00306	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  0030b	48 8d 54 24 50	 lea	 rdx, QWORD PTR d1$[rsp]
  00310	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00315	e8 00 00 00 00	 call	 decimal128FromNumber
$LN17@z900_load_:
$LN15@z900_load_:

; 4578 :     }
; 4579 : 
; 4580 :     /* Check for exception condition */
; 4581 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0031a	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00322	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  00327	e8 00 00 00 00	 call	 z900_dfp_status_check
  0032c	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4582 : 
; 4583 :     /* Load result into FP register r1 */
; 4584 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  00330	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00338	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  0033d	8b 4c 24 2c	 mov	 ecx, DWORD PTR r1$[rsp]
  00341	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 4585 : 
; 4586 :     /* Raise data exception if error occurred */
; 4587 :     if (dxc != 0)

  00346	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0034b	85 c0		 test	 eax, eax
  0034d	74 25		 je	 SHORT $LN19@z900_load_

; 4588 :     {
; 4589 :         regs->dxc = dxc;

  0034f	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00354	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0035c	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4590 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00362	ba 07 00 00 00	 mov	 edx, 7
  00367	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036f	e8 00 00 00 00	 call	 z900_program_interrupt
$LN19@z900_load_:

; 4591 :     }
; 4592 : 
; 4593 : } /* end DEF_INST(load_lengthened_dfp_long_to_ext_reg) */

  00374	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0037c	48 33 cc	 xor	 rcx, rsp
  0037f	e8 00 00 00 00	 call	 __security_check_cookie
  00384	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0038b	c3		 ret	 0
z900_load_lengthened_dfp_long_to_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv167 = 40
tv172 = 44
tv191 = 48
tv200 = 52
tv201 = 56
m3$ = 60
r2$ = 64
m4$ = 68
r1$ = 72
set$ = 80
x2$ = 112
x1$ = 120
d2$ = 128
d1$ = 168
dc$ = 208
__$ArrayPad$ = 248
inst$ = 272
regs$ = 280
z900_load_fp_int_dfp_long_reg PROC

; 4456 : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4457 : int             r1, r2, m3, m4;         /* Values of R and M fields  */
; 4458 : decimal64       x1, x2;                 /* Long DFP values           */
; 4459 : decNumber       d1, d2, dc;             /* Working decimal numbers   */
; 4460 : decContext      set;                    /* Working context           */
; 4461 : BYTE            dxc;                    /* Data exception code       */
; 4462 : 
; 4463 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 40	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 44	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_load_:
  00070	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_load_
  00093	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 4464 : 
; 4465 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_load_
  000b3	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_load_
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_load_
  000cc	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_load_
  000df	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000f5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197273
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 4466 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_load_
  00162	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_load_
  00179	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  001a4	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 4467 : 
; 4468 :     /* Initialise the context for long DFP */
; 4469 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001d1	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001d6	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001db	e8 00 00 00 00	 call	 decContextDefault

; 4470 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  001e0	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e8	8b 54 24 3c	 mov	 edx, DWORD PTR m3$[rsp]
  001ec	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001f1	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 4471 : 
; 4472 :     /* Load decimal number from FP register r2 */
; 4473 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001f6	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001fe	48 8d 54 24 70	 lea	 rdx, QWORD PTR x2$[rsp]
  00203	8b 4c 24 40	 mov	 ecx, DWORD PTR r2$[rsp]
  00207	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 4474 :     decimal64ToNumber(&x2, &d2);

  0020c	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00214	48 8d 4c 24 70	 lea	 rcx, QWORD PTR x2$[rsp]
  00219	e8 00 00 00 00	 call	 decimal64ToNumber

; 4475 : 
; 4476 :     if (decNumberIsInfinite(&d2) == 0 && decNumberIsNaN(&d2) == 0)

  0021e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00226	83 e0 40	 and	 eax, 64			; 00000040H
  00229	85 c0		 test	 eax, eax
  0022b	74 0a		 je	 SHORT $LN21@z900_load_
  0022d	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv167[rsp], 1
  00235	eb 08		 jmp	 SHORT $LN22@z900_load_
$LN21@z900_load_:
  00237	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN22@z900_load_:
  0023f	83 7c 24 28 00	 cmp	 DWORD PTR tv167[rsp], 0
  00244	0f 85 27 01 00
	00		 jne	 $LN13@z900_load_
  0024a	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00252	83 e0 30	 and	 eax, 48			; 00000030H
  00255	85 c0		 test	 eax, eax
  00257	74 0a		 je	 SHORT $LN23@z900_load_
  00259	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv172[rsp], 1
  00261	eb 08		 jmp	 SHORT $LN24@z900_load_
$LN23@z900_load_:
  00263	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN24@z900_load_:
  0026b	83 7c 24 2c 00	 cmp	 DWORD PTR tv172[rsp], 0
  00270	0f 85 fb 00 00
	00		 jne	 $LN13@z900_load_

; 4477 :     {
; 4478 :         /* Remove fractional part of decimal number */
; 4479 :         decNumberToIntegralValue(&d1, &d2, &set);

  00276	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  0027b	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00283	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  0028b	e8 00 00 00 00	 call	 decNumberToIntegralValue

; 4480 : 
; 4481 :         /* Raise inexact condition if M4 bit 1 is zero and
; 4482 :            result differs in value from original value */
; 4483 :         if ((m4 & 0x04) == 0)

  00290	8b 44 24 44	 mov	 eax, DWORD PTR m4$[rsp]
  00294	83 e0 04	 and	 eax, 4
  00297	85 c0		 test	 eax, eax
  00299	0f 85 d0 00 00
	00		 jne	 $LN15@z900_load_

; 4484 :         {
; 4485 :             decNumberCompare(&dc, &d1, &d2, &set);

  0029f	4c 8d 4c 24 50	 lea	 r9, QWORD PTR set$[rsp]
  002a4	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR d2$[rsp]
  002ac	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  002b4	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR dc$[rsp]
  002bc	e8 00 00 00 00	 call	 decNumberCompare

; 4486 :             if (decNumberIsZero(&dc) == 0)

  002c1	b8 02 00 00 00	 mov	 eax, 2
  002c6	48 6b c0 00	 imul	 rax, rax, 0
  002ca	0f b7 84 04 da
	00 00 00	 movzx	 eax, WORD PTR dc$[rsp+rax+10]
  002d2	85 c0		 test	 eax, eax
  002d4	75 23		 jne	 SHORT $LN25@z900_load_
  002d6	83 bc 24 d0 00
	00 00 01	 cmp	 DWORD PTR dc$[rsp], 1
  002de	75 19		 jne	 SHORT $LN25@z900_load_
  002e0	0f b6 84 24 d8
	00 00 00	 movzx	 eax, BYTE PTR dc$[rsp+8]
  002e8	83 e0 70	 and	 eax, 112		; 00000070H
  002eb	85 c0		 test	 eax, eax
  002ed	75 0a		 jne	 SHORT $LN25@z900_load_
  002ef	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv191[rsp], 1
  002f7	eb 08		 jmp	 SHORT $LN26@z900_load_
$LN25@z900_load_:
  002f9	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv191[rsp], 0
$LN26@z900_load_:
  00301	83 7c 24 30 00	 cmp	 DWORD PTR tv191[rsp], 0
  00306	75 67		 jne	 SHORT $LN16@z900_load_

; 4487 :             {
; 4488 :                 set.status |= DEC_IEEE_854_Inexact;

  00308	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  0030c	83 c8 20	 or	 eax, 32			; 00000020H
  0030f	89 44 24 64	 mov	 DWORD PTR set$[rsp+20], eax

; 4489 :                 if (decNumberIsNegative(&dc) == decNumberIsNegative(&d2))

  00313	0f b6 84 24 d8
	00 00 00	 movzx	 eax, BYTE PTR dc$[rsp+8]
  0031b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00320	85 c0		 test	 eax, eax
  00322	74 0a		 je	 SHORT $LN29@z900_load_
  00324	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv201[rsp], 1
  0032c	eb 08		 jmp	 SHORT $LN30@z900_load_
$LN29@z900_load_:
  0032e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv201[rsp], 0
$LN30@z900_load_:
  00336	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0033e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00343	85 c0		 test	 eax, eax
  00345	74 0a		 je	 SHORT $LN27@z900_load_
  00347	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv200[rsp], 1
  0034f	eb 08		 jmp	 SHORT $LN28@z900_load_
$LN27@z900_load_:
  00351	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv200[rsp], 0
$LN28@z900_load_:
  00359	8b 44 24 34	 mov	 eax, DWORD PTR tv200[rsp]
  0035d	39 44 24 38	 cmp	 DWORD PTR tv201[rsp], eax
  00361	75 0c		 jne	 SHORT $LN17@z900_load_

; 4490 :                     set.status |= DEC_Rounded;

  00363	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  00367	0f ba e8 0b	 bts	 eax, 11
  0036b	89 44 24 64	 mov	 DWORD PTR set$[rsp+20], eax
$LN17@z900_load_:
$LN16@z900_load_:
$LN15@z900_load_:

; 4491 :             }
; 4492 :         }
; 4493 :     }

  0036f	eb 55		 jmp	 SHORT $LN14@z900_load_
$LN13@z900_load_:

; 4494 :     else
; 4495 :     {
; 4496 :         /* Propagate NaN or default infinity */
; 4497 :         decNumberCopy(&d1, &d2);

  00371	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00379	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  00381	e8 00 00 00 00	 call	 decNumberCopy

; 4498 : 
; 4499 :         /* For SNaN, force signaling condition and convert to QNaN */
; 4500 :         if (decNumberIsSNaN(&d2))

  00386	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0038e	83 e0 10	 and	 eax, 16
  00391	85 c0		 test	 eax, eax
  00393	74 31		 je	 SHORT $LN18@z900_load_

; 4501 :         {
; 4502 :             set.status |= DEC_IEEE_854_Invalid_operation;

  00395	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  00399	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  0039e	89 44 24 64	 mov	 DWORD PTR set$[rsp+20], eax

; 4503 :             d1.bits &= ~DECSNAN;

  003a2	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR d1$[rsp+8]
  003aa	83 e0 ef	 and	 eax, -17
  003ad	88 84 24 b0 00
	00 00		 mov	 BYTE PTR d1$[rsp+8], al

; 4504 :             d1.bits |= DECNAN;

  003b4	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR d1$[rsp+8]
  003bc	83 c8 20	 or	 eax, 32			; 00000020H
  003bf	88 84 24 b0 00
	00 00		 mov	 BYTE PTR d1$[rsp+8], al
$LN18@z900_load_:
$LN14@z900_load_:

; 4505 :         }
; 4506 :     }
; 4507 : 
; 4508 :     /* Convert result to long DFP format */
; 4509 :     decimal64FromNumber(&x1, &d1, &set);

  003c6	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  003cb	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  003d3	48 8d 4c 24 78	 lea	 rcx, QWORD PTR x1$[rsp]
  003d8	e8 00 00 00 00	 call	 decimal64FromNumber

; 4510 : 
; 4511 :     /* Check for exception condition */
; 4512 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  003dd	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003e5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  003ea	e8 00 00 00 00	 call	 z900_dfp_status_check
  003ef	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4513 : 
; 4514 :     /* Load result into FP register r1 */
; 4515 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  003f3	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003fb	48 8d 54 24 78	 lea	 rdx, QWORD PTR x1$[rsp]
  00400	8b 4c 24 48	 mov	 ecx, DWORD PTR r1$[rsp]
  00404	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 4516 : 
; 4517 :     /* Raise data exception if error occurred */
; 4518 :     if (dxc != 0)

  00409	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0040e	85 c0		 test	 eax, eax
  00410	74 25		 je	 SHORT $LN19@z900_load_

; 4519 :     {
; 4520 :         regs->dxc = dxc;

  00412	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00417	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041f	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4521 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00425	ba 07 00 00 00	 mov	 edx, 7
  0042a	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00432	e8 00 00 00 00	 call	 z900_program_interrupt
$LN19@z900_load_:

; 4522 :     }
; 4523 : 
; 4524 : } /* end DEF_INST(load_fp_int_dfp_long_reg) */

  00437	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0043f	48 33 cc	 xor	 rcx, rsp
  00442	e8 00 00 00 00	 call	 __security_check_cookie
  00447	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  0044e	c3		 ret	 0
z900_load_fp_int_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
tv174 = 44
tv179 = 48
tv198 = 52
tv207 = 56
tv208 = 60
r1$ = 64
m3$ = 68
m4$ = 72
set$ = 80
d2$ = 112
d1$ = 152
dc$ = 192
x2$ = 232
x1$ = 248
__$ArrayPad$ = 264
inst$ = 288
regs$ = 296
z900_load_fp_int_dfp_ext_reg PROC

; 4380 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4381 : int             r1, r2, m3, m4;         /* Values of R and M fields  */
; 4382 : decimal128      x1, x2;                 /* Extended DFP values       */
; 4383 : decNumber       d1, d2, dc;             /* Working decimal numbers   */
; 4384 : decContext      set;                    /* Working context           */
; 4385 : BYTE            dxc;                    /* Data exception code       */
; 4386 : 
; 4387 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 40	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 48	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 44	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_load_:
  00070	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_load_
  00093	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 4388 : 
; 4389 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_load_
  000b3	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_load_
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_load_
  000cc	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_load_
  000df	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000f5	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197235
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 4390 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_load_
  00162	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_load_
  00179	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  001a4	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 4391 :     DFPREGPAIR2_CHECK(r1, r2, regs);

  001d1	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  001d5	83 e0 02	 and	 eax, 2
  001d8	85 c0		 test	 eax, eax
  001da	75 0b		 jne	 SHORT $LN14@z900_load_
  001dc	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001e0	83 e0 02	 and	 eax, 2
  001e3	85 c0		 test	 eax, eax
  001e5	74 1b		 je	 SHORT $LN13@z900_load_
$LN14@z900_load_:
  001e7	ba 06 00 00 00	 mov	 edx, 6
  001ec	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f4	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_load_:

; 4392 : 
; 4393 :     /* Initialise the context for extended DFP */
; 4394 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00202	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00207	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0020c	e8 00 00 00 00	 call	 decContextDefault

; 4395 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00211	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00219	8b 54 24 44	 mov	 edx, DWORD PTR m3$[rsp]
  0021d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00222	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 4396 : 
; 4397 :     /* Load decimal number from FP register r2 */
; 4398 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00227	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0022f	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  00237	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  0023b	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 4399 :     decimal128ToNumber(&x2, &d2);

  00240	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  00245	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  0024d	e8 00 00 00 00	 call	 decimal128ToNumber

; 4400 : 
; 4401 :     if (decNumberIsInfinite(&d2) == 0 && decNumberIsNaN(&d2) == 0)

  00252	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00257	83 e0 40	 and	 eax, 64			; 00000040H
  0025a	85 c0		 test	 eax, eax
  0025c	74 0a		 je	 SHORT $LN23@z900_load_
  0025e	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  00266	eb 08		 jmp	 SHORT $LN24@z900_load_
$LN23@z900_load_:
  00268	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN24@z900_load_:
  00270	83 7c 24 2c 00	 cmp	 DWORD PTR tv174[rsp], 0
  00275	0f 85 1b 01 00
	00		 jne	 $LN15@z900_load_
  0027b	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00280	83 e0 30	 and	 eax, 48			; 00000030H
  00283	85 c0		 test	 eax, eax
  00285	74 0a		 je	 SHORT $LN25@z900_load_
  00287	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
  0028f	eb 08		 jmp	 SHORT $LN26@z900_load_
$LN25@z900_load_:
  00291	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv179[rsp], 0
$LN26@z900_load_:
  00299	83 7c 24 30 00	 cmp	 DWORD PTR tv179[rsp], 0
  0029e	0f 85 f2 00 00
	00		 jne	 $LN15@z900_load_

; 4402 :     {
; 4403 :         /* Remove fractional part of decimal number */
; 4404 :         decNumberToIntegralValue(&d1, &d2, &set);

  002a4	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  002a9	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  002ae	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  002b6	e8 00 00 00 00	 call	 decNumberToIntegralValue

; 4405 : 
; 4406 :         /* Raise inexact condition if M4 bit 1 is zero and
; 4407 :            result differs in value from original value */
; 4408 :         if ((m4 & 0x04) == 0)

  002bb	8b 44 24 48	 mov	 eax, DWORD PTR m4$[rsp]
  002bf	83 e0 04	 and	 eax, 4
  002c2	85 c0		 test	 eax, eax
  002c4	0f 85 ca 00 00
	00		 jne	 $LN17@z900_load_

; 4409 :         {
; 4410 :             decNumberCompare(&dc, &d1, &d2, &set);

  002ca	4c 8d 4c 24 50	 lea	 r9, QWORD PTR set$[rsp]
  002cf	4c 8d 44 24 70	 lea	 r8, QWORD PTR d2$[rsp]
  002d4	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  002dc	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dc$[rsp]
  002e4	e8 00 00 00 00	 call	 decNumberCompare

; 4411 :             if (decNumberIsZero(&dc) == 0)

  002e9	b8 02 00 00 00	 mov	 eax, 2
  002ee	48 6b c0 00	 imul	 rax, rax, 0
  002f2	0f b7 84 04 ca
	00 00 00	 movzx	 eax, WORD PTR dc$[rsp+rax+10]
  002fa	85 c0		 test	 eax, eax
  002fc	75 23		 jne	 SHORT $LN27@z900_load_
  002fe	83 bc 24 c0 00
	00 00 01	 cmp	 DWORD PTR dc$[rsp], 1
  00306	75 19		 jne	 SHORT $LN27@z900_load_
  00308	0f b6 84 24 c8
	00 00 00	 movzx	 eax, BYTE PTR dc$[rsp+8]
  00310	83 e0 70	 and	 eax, 112		; 00000070H
  00313	85 c0		 test	 eax, eax
  00315	75 0a		 jne	 SHORT $LN27@z900_load_
  00317	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv198[rsp], 1
  0031f	eb 08		 jmp	 SHORT $LN28@z900_load_
$LN27@z900_load_:
  00321	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv198[rsp], 0
$LN28@z900_load_:
  00329	83 7c 24 34 00	 cmp	 DWORD PTR tv198[rsp], 0
  0032e	75 64		 jne	 SHORT $LN18@z900_load_

; 4412 :             {
; 4413 :                 set.status |= DEC_IEEE_854_Inexact;

  00330	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  00334	83 c8 20	 or	 eax, 32			; 00000020H
  00337	89 44 24 64	 mov	 DWORD PTR set$[rsp+20], eax

; 4414 :                 if (decNumberIsNegative(&dc) == decNumberIsNegative(&d2))

  0033b	0f b6 84 24 c8
	00 00 00	 movzx	 eax, BYTE PTR dc$[rsp+8]
  00343	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00348	85 c0		 test	 eax, eax
  0034a	74 0a		 je	 SHORT $LN31@z900_load_
  0034c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv208[rsp], 1
  00354	eb 08		 jmp	 SHORT $LN32@z900_load_
$LN31@z900_load_:
  00356	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv208[rsp], 0
$LN32@z900_load_:
  0035e	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00363	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00368	85 c0		 test	 eax, eax
  0036a	74 0a		 je	 SHORT $LN29@z900_load_
  0036c	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv207[rsp], 1
  00374	eb 08		 jmp	 SHORT $LN30@z900_load_
$LN29@z900_load_:
  00376	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv207[rsp], 0
$LN30@z900_load_:
  0037e	8b 44 24 38	 mov	 eax, DWORD PTR tv207[rsp]
  00382	39 44 24 3c	 cmp	 DWORD PTR tv208[rsp], eax
  00386	75 0c		 jne	 SHORT $LN19@z900_load_

; 4415 :                     set.status |= DEC_Rounded;

  00388	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  0038c	0f ba e8 0b	 bts	 eax, 11
  00390	89 44 24 64	 mov	 DWORD PTR set$[rsp+20], eax
$LN19@z900_load_:
$LN18@z900_load_:
$LN17@z900_load_:

; 4416 :             }
; 4417 :         }
; 4418 :     }

  00394	eb 4f		 jmp	 SHORT $LN16@z900_load_
$LN15@z900_load_:

; 4419 :     else
; 4420 :     {
; 4421 :         /* Propagate NaN or default infinity */
; 4422 :         decNumberCopy(&d1, &d2);

  00396	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  0039b	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  003a3	e8 00 00 00 00	 call	 decNumberCopy

; 4423 : 
; 4424 :         /* For SNaN, force signaling condition and convert to QNaN */
; 4425 :         if (decNumberIsSNaN(&d2))

  003a8	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  003ad	83 e0 10	 and	 eax, 16
  003b0	85 c0		 test	 eax, eax
  003b2	74 31		 je	 SHORT $LN20@z900_load_

; 4426 :         {
; 4427 :             set.status |= DEC_IEEE_854_Invalid_operation;

  003b4	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  003b8	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  003bd	89 44 24 64	 mov	 DWORD PTR set$[rsp+20], eax

; 4428 :             d1.bits &= ~DECSNAN;

  003c1	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR d1$[rsp+8]
  003c9	83 e0 ef	 and	 eax, -17
  003cc	88 84 24 a0 00
	00 00		 mov	 BYTE PTR d1$[rsp+8], al

; 4429 :             d1.bits |= DECNAN;

  003d3	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR d1$[rsp+8]
  003db	83 c8 20	 or	 eax, 32			; 00000020H
  003de	88 84 24 a0 00
	00 00		 mov	 BYTE PTR d1$[rsp+8], al
$LN20@z900_load_:
$LN16@z900_load_:

; 4430 :         }
; 4431 :     }
; 4432 : 
; 4433 :     /* Convert result to extended DFP format */
; 4434 :     decimal128FromNumber(&x1, &d1, &set);

  003e5	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  003ea	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  003f2	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR x1$[rsp]
  003fa	e8 00 00 00 00	 call	 decimal128FromNumber

; 4435 : 
; 4436 :     /* Check for exception condition */
; 4437 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  003ff	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00407	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0040c	e8 00 00 00 00	 call	 z900_dfp_status_check
  00411	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4438 : 
; 4439 :     /* Load result into FP register r1 */
; 4440 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  00415	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0041d	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR x1$[rsp]
  00425	8b 4c 24 40	 mov	 ecx, DWORD PTR r1$[rsp]
  00429	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 4441 : 
; 4442 :     /* Raise data exception if error occurred */
; 4443 :     if (dxc != 0)

  0042e	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00433	85 c0		 test	 eax, eax
  00435	74 25		 je	 SHORT $LN21@z900_load_

; 4444 :     {
; 4445 :         regs->dxc = dxc;

  00437	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0043c	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00444	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4446 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0044a	ba 07 00 00 00	 mov	 edx, 7
  0044f	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00457	e8 00 00 00 00	 call	 z900_program_interrupt
$LN21@z900_load_:

; 4447 :     }
; 4448 : 
; 4449 : } /* end DEF_INST(load_fp_int_dfp_ext_reg) */

  0045c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00464	48 33 cc	 xor	 rcx, rsp
  00467	e8 00 00 00 00	 call	 __security_check_cookie
  0046c	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00473	c3		 ret	 0
z900_load_fp_int_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
tv190 = 40
tv191 = 44
tv192 = 48
r2$ = 52
r1$ = 56
d$ = 64
x2$ = 104
x1$ = 112
set$ = 120
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
z900_load_and_test_dfp_long_reg PROC

; 4327 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4328 : int             r1, r2;                 /* Values of R fields        */
; 4329 : decimal64       x1, x2;                 /* Long DFP values           */
; 4330 : decNumber       d;                      /* Working decimal number    */
; 4331 : decContext      set;                    /* Working context           */
; 4332 : BYTE            dxc;                    /* Data exception code       */
; 4333 : 
; 4334 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  00055	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_load_
  00078	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 4335 : 
; 4336 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_load_
  00098	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_load_
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_load_
  000b1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_load_
  000c4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000da	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197204
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 4337 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_load_
  00147	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_load_
  0015e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  00189	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 4338 : 
; 4339 :     /* Initialise the context for long DFP */
; 4340 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001b6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001bb	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  001c0	e8 00 00 00 00	 call	 decContextDefault

; 4341 : 
; 4342 :     /* Load value from FP register r2 */
; 4343 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001c5	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001cd	48 8d 54 24 68	 lea	 rdx, QWORD PTR x2$[rsp]
  001d2	8b 4c 24 34	 mov	 ecx, DWORD PTR r2$[rsp]
  001d6	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 4344 :     decimal64ToNumber(&x2, &d);

  001db	48 8d 54 24 40	 lea	 rdx, QWORD PTR d$[rsp]
  001e0	48 8d 4c 24 68	 lea	 rcx, QWORD PTR x2$[rsp]
  001e5	e8 00 00 00 00	 call	 decimal64ToNumber

; 4345 : 
; 4346 :     /* For SNaN, force signaling condition and convert to QNaN */
; 4347 :     if (decNumberIsSNaN(&d))

  001ea	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  001ef	83 e0 10	 and	 eax, 16
  001f2	85 c0		 test	 eax, eax
  001f4	74 2b		 je	 SHORT $LN13@z900_load_

; 4348 :     {
; 4349 :         set.status |= DEC_IEEE_854_Invalid_operation;

  001f6	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR set$[rsp+20]
  001fd	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00202	89 84 24 8c 00
	00 00		 mov	 DWORD PTR set$[rsp+20], eax

; 4350 :         d.bits &= ~DECSNAN;

  00209	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  0020e	83 e0 ef	 and	 eax, -17
  00211	88 44 24 48	 mov	 BYTE PTR d$[rsp+8], al

; 4351 :         d.bits |= DECNAN;

  00215	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  0021a	83 c8 20	 or	 eax, 32			; 00000020H
  0021d	88 44 24 48	 mov	 BYTE PTR d$[rsp+8], al
$LN13@z900_load_:

; 4352 :     }
; 4353 : 
; 4354 :     /* Check for exception condition */
; 4355 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00221	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00229	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  0022e	e8 00 00 00 00	 call	 z900_dfp_status_check
  00233	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4356 : 
; 4357 :     /* Reencode value and load into FP register r1 */
; 4358 :     decimal64FromNumber(&x1, &d, &set);

  00237	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  0023c	48 8d 54 24 40	 lea	 rdx, QWORD PTR d$[rsp]
  00241	48 8d 4c 24 70	 lea	 rcx, QWORD PTR x1$[rsp]
  00246	e8 00 00 00 00	 call	 decimal64FromNumber

; 4359 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  0024b	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00253	48 8d 54 24 70	 lea	 rdx, QWORD PTR x1$[rsp]
  00258	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  0025c	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 4360 : 
; 4361 :     /* Set condition code */
; 4362 :     regs->psw.cc = decNumberIsNaN(&d) ? 3 :

  00261	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  00266	83 e0 30	 and	 eax, 48			; 00000030H
  00269	85 c0		 test	 eax, eax
  0026b	74 0a		 je	 SHORT $LN20@z900_load_
  0026d	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv192[rsp], 3
  00275	eb 5f		 jmp	 SHORT $LN21@z900_load_
$LN20@z900_load_:
  00277	b8 02 00 00 00	 mov	 eax, 2
  0027c	48 6b c0 00	 imul	 rax, rax, 0
  00280	0f b7 44 04 4a	 movzx	 eax, WORD PTR d$[rsp+rax+10]
  00285	85 c0		 test	 eax, eax
  00287	75 1d		 jne	 SHORT $LN16@z900_load_
  00289	83 7c 24 40 01	 cmp	 DWORD PTR d$[rsp], 1
  0028e	75 16		 jne	 SHORT $LN16@z900_load_
  00290	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  00295	83 e0 70	 and	 eax, 112		; 00000070H
  00298	85 c0		 test	 eax, eax
  0029a	75 0a		 jne	 SHORT $LN16@z900_load_
  0029c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv191[rsp], 0
  002a4	eb 28		 jmp	 SHORT $LN19@z900_load_
$LN16@z900_load_:
  002a6	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  002ab	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002b0	85 c0		 test	 eax, eax
  002b2	74 0a		 je	 SHORT $LN17@z900_load_
  002b4	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv190[rsp], 1
  002bc	eb 08		 jmp	 SHORT $LN18@z900_load_
$LN17@z900_load_:
  002be	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv190[rsp], 2
$LN18@z900_load_:
  002c6	8b 44 24 28	 mov	 eax, DWORD PTR tv190[rsp]
  002ca	89 44 24 2c	 mov	 DWORD PTR tv191[rsp], eax
$LN19@z900_load_:
  002ce	8b 44 24 2c	 mov	 eax, DWORD PTR tv191[rsp]
  002d2	89 44 24 30	 mov	 DWORD PTR tv192[rsp], eax
$LN21@z900_load_:
  002d6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002de	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv192[rsp]
  002e3	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 4363 :                    decNumberIsZero(&d) ? 0 :
; 4364 :                    decNumberIsNegative(&d) ? 1 : 2;
; 4365 : 
; 4366 :     /* Raise data exception if error occurred */
; 4367 :     if (dxc != 0)

  002e6	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002eb	85 c0		 test	 eax, eax
  002ed	74 25		 je	 SHORT $LN14@z900_load_

; 4368 :     {
; 4369 :         regs->dxc = dxc;

  002ef	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002f4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fc	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4370 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00302	ba 07 00 00 00	 mov	 edx, 7
  00307	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030f	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_load_:

; 4371 :     }
; 4372 : 
; 4373 : } /* end DEF_INST(load_and_test_dfp_long_reg) */

  00314	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0031c	48 33 cc	 xor	 rcx, rsp
  0031f	e8 00 00 00 00	 call	 __security_check_cookie
  00324	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0032b	c3		 ret	 0
z900_load_and_test_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
tv197 = 48
tv198 = 52
tv199 = 56
d$ = 64
set$ = 104
x2$ = 136
x1$ = 152
__$ArrayPad$ = 168
inst$ = 192
regs$ = 200
z900_load_and_test_dfp_ext_reg PROC

; 4273 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4274 : int             r1, r2;                 /* Values of R fields        */
; 4275 : decimal128      x1, x2;                 /* Extended DFP values       */
; 4276 : decNumber       d;                      /* Working decimal number    */
; 4277 : decContext      set;                    /* Working context           */
; 4278 : BYTE            dxc;                    /* Data exception code       */
; 4279 : 
; 4280 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  00055	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_load_
  00078	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 4281 : 
; 4282 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_load_
  00098	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_load_
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_load_
  000b1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_load_
  000c4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_load_
$LN10@z900_load_:
  000da	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197175
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_load_

; 4283 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_load_
  00147	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_load_
  0015e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  00189	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 4284 :     DFPREGPAIR2_CHECK(r1, r2, regs);

  001b6	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001ba	83 e0 02	 and	 eax, 2
  001bd	85 c0		 test	 eax, eax
  001bf	75 0b		 jne	 SHORT $LN14@z900_load_
  001c1	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001c5	83 e0 02	 and	 eax, 2
  001c8	85 c0		 test	 eax, eax
  001ca	74 1b		 je	 SHORT $LN13@z900_load_
$LN14@z900_load_:
  001cc	ba 06 00 00 00	 mov	 edx, 6
  001d1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_load_:

; 4285 : 
; 4286 :     /* Initialise the context for extended DFP */
; 4287 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001e7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001ec	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  001f1	e8 00 00 00 00	 call	 decContextDefault

; 4288 : 
; 4289 :     /* Load value from FP register r2 */
; 4290 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  001f6	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001fe	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  00206	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  0020a	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 4291 :     decimal128ToNumber(&x2, &d);

  0020f	48 8d 54 24 40	 lea	 rdx, QWORD PTR d$[rsp]
  00214	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  0021c	e8 00 00 00 00	 call	 decimal128ToNumber

; 4292 : 
; 4293 :     /* For SNaN, force signaling condition and convert to QNaN */
; 4294 :     if (decNumberIsSNaN(&d))

  00221	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  00226	83 e0 10	 and	 eax, 16
  00229	85 c0		 test	 eax, eax
  0022b	74 25		 je	 SHORT $LN15@z900_load_

; 4295 :     {
; 4296 :         set.status |= DEC_IEEE_854_Invalid_operation;

  0022d	8b 44 24 7c	 mov	 eax, DWORD PTR set$[rsp+20]
  00231	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00236	89 44 24 7c	 mov	 DWORD PTR set$[rsp+20], eax

; 4297 :         d.bits &= ~DECSNAN;

  0023a	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  0023f	83 e0 ef	 and	 eax, -17
  00242	88 44 24 48	 mov	 BYTE PTR d$[rsp+8], al

; 4298 :         d.bits |= DECNAN;

  00246	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  0024b	83 c8 20	 or	 eax, 32			; 00000020H
  0024e	88 44 24 48	 mov	 BYTE PTR d$[rsp+8], al
$LN15@z900_load_:

; 4299 :     }
; 4300 : 
; 4301 :     /* Check for exception condition */
; 4302 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00252	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0025a	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  0025f	e8 00 00 00 00	 call	 z900_dfp_status_check
  00264	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4303 : 
; 4304 :     /* Reencode value and load into FP register r1 */
; 4305 :     decimal128FromNumber(&x1, &d, &set);

  00268	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  0026d	48 8d 54 24 40	 lea	 rdx, QWORD PTR d$[rsp]
  00272	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR x1$[rsp]
  0027a	e8 00 00 00 00	 call	 decimal128FromNumber

; 4306 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  0027f	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00287	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR x1$[rsp]
  0028f	8b 4c 24 2c	 mov	 ecx, DWORD PTR r1$[rsp]
  00293	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 4307 : 
; 4308 :     /* Set condition code */
; 4309 :     regs->psw.cc = decNumberIsNaN(&d) ? 3 :

  00298	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  0029d	83 e0 30	 and	 eax, 48			; 00000030H
  002a0	85 c0		 test	 eax, eax
  002a2	74 0a		 je	 SHORT $LN22@z900_load_
  002a4	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv199[rsp], 3
  002ac	eb 5f		 jmp	 SHORT $LN23@z900_load_
$LN22@z900_load_:
  002ae	b8 02 00 00 00	 mov	 eax, 2
  002b3	48 6b c0 00	 imul	 rax, rax, 0
  002b7	0f b7 44 04 4a	 movzx	 eax, WORD PTR d$[rsp+rax+10]
  002bc	85 c0		 test	 eax, eax
  002be	75 1d		 jne	 SHORT $LN18@z900_load_
  002c0	83 7c 24 40 01	 cmp	 DWORD PTR d$[rsp], 1
  002c5	75 16		 jne	 SHORT $LN18@z900_load_
  002c7	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  002cc	83 e0 70	 and	 eax, 112		; 00000070H
  002cf	85 c0		 test	 eax, eax
  002d1	75 0a		 jne	 SHORT $LN18@z900_load_
  002d3	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv198[rsp], 0
  002db	eb 28		 jmp	 SHORT $LN21@z900_load_
$LN18@z900_load_:
  002dd	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  002e2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002e7	85 c0		 test	 eax, eax
  002e9	74 0a		 je	 SHORT $LN19@z900_load_
  002eb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv197[rsp], 1
  002f3	eb 08		 jmp	 SHORT $LN20@z900_load_
$LN19@z900_load_:
  002f5	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv197[rsp], 2
$LN20@z900_load_:
  002fd	8b 44 24 30	 mov	 eax, DWORD PTR tv197[rsp]
  00301	89 44 24 34	 mov	 DWORD PTR tv198[rsp], eax
$LN21@z900_load_:
  00305	8b 44 24 34	 mov	 eax, DWORD PTR tv198[rsp]
  00309	89 44 24 38	 mov	 DWORD PTR tv199[rsp], eax
$LN23@z900_load_:
  0030d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00315	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv199[rsp]
  0031a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 4310 :                    decNumberIsZero(&d) ? 0 :
; 4311 :                    decNumberIsNegative(&d) ? 1 : 2;
; 4312 : 
; 4313 :     /* Raise data exception if error occurred */
; 4314 :     if (dxc != 0)

  0031d	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00322	85 c0		 test	 eax, eax
  00324	74 25		 je	 SHORT $LN16@z900_load_

; 4315 :     {
; 4316 :         regs->dxc = dxc;

  00326	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0032b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00333	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4317 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00339	ba 07 00 00 00	 mov	 edx, 7
  0033e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00346	e8 00 00 00 00	 call	 z900_program_interrupt
$LN16@z900_load_:

; 4318 :     }
; 4319 : 
; 4320 : } /* end DEF_INST(load_and_test_dfp_ext_reg) */

  0034b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00353	48 33 cc	 xor	 rcx, rsp
  00356	e8 00 00 00 00	 call	 __security_check_cookie
  0035b	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00362	c3		 ret	 0
z900_load_and_test_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
bexp$ = 40
r2$ = 48
r3$ = 52
r1$ = 56
x3$ = 64
x1$ = 72
d$ = 80
set$ = 120
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
z900_insert_biased_exponent_fix64_to_dfp_long_reg PROC

; 4203 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4204 : int             r1, r2, r3;             /* Values of R fields        */
; 4205 : decimal64       x1, x3;                 /* Long DFP values           */
; 4206 : decNumber       d;                      /* Working decimal number    */
; 4207 : decContext      set;                    /* Working context           */
; 4208 : S64             bexp;                   /* Biased exponent           */
; 4209 : 
; 4210 :     RRF_M(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_inser:
  00062	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_inser
  00085	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_inser:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_inser
$LN7@z900_inser:

; 4211 : 
; 4212 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_inser
  000a5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_inser
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_inser
  000be	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_inser
  000d1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_inser
$LN10@z900_inser:
  000e7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197141
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_inser:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_inser

; 4213 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_inser
  00154	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_inser
  0016b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_inser
$LN12@z900_inser:
  00196	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_inser:

; 4214 : 
; 4215 :     /* Initialise the context for long DFP */
; 4216 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001c3	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001c8	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  001cd	e8 00 00 00 00	 call	 decContextDefault

; 4217 : 
; 4218 :     /* Load biased exponent from general register r2 */
; 4219 :     bexp = (S64)(regs->GR(r2));

  001d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  001d7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001df	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001e7	48 89 44 24 28	 mov	 QWORD PTR bexp$[rsp], rax

; 4220 : 
; 4221 :     /* Load DFP long number from FP register r3 */
; 4222 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  001ec	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f4	48 8d 54 24 40	 lea	 rdx, QWORD PTR x3$[rsp]
  001f9	8b 4c 24 34	 mov	 ecx, DWORD PTR r3$[rsp]
  001fd	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 4223 : 
; 4224 :     /* Insert biased exponent into number */
; 4225 :     if (bexp > DECIMAL64_Ehigh || bexp == -2 || bexp <= -4)

  00202	48 81 7c 24 28
	ff 02 00 00	 cmp	 QWORD PTR bexp$[rsp], 767 ; 000002ffH
  0020b	7f 10		 jg	 SHORT $LN15@z900_inser
  0020d	48 83 7c 24 28
	fe		 cmp	 QWORD PTR bexp$[rsp], -2
  00213	74 08		 je	 SHORT $LN15@z900_inser
  00215	48 83 7c 24 28
	fc		 cmp	 QWORD PTR bexp$[rsp], -4
  0021b	7f 41		 jg	 SHORT $LN13@z900_inser
$LN15@z900_inser:

; 4226 :     {
; 4227 :         /* Result is a QNaN with re-encoded coefficient-continuation */
; 4228 :         dfp64_clear_cf_and_bxcf(&x3);

  0021d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00222	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 4229 :         decimal64ToNumber(&x3, &d);

  00227	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  0022c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00231	e8 00 00 00 00	 call	 decimal64ToNumber

; 4230 :         decimal64FromNumber(&x1, &d, &set);

  00236	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  0023b	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  00240	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00245	e8 00 00 00 00	 call	 decimal64FromNumber

; 4231 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  0024a	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  0024f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00254	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4232 :     }

  00259	e9 f2 00 00 00	 jmp	 $LN14@z900_inser
$LN13@z900_inser:

; 4233 :     else if (bexp == -3)

  0025e	48 83 7c 24 28
	fd		 cmp	 QWORD PTR bexp$[rsp], -3
  00264	75 41		 jne	 SHORT $LN16@z900_inser

; 4234 :     {
; 4235 :         /* Result is a SNaN with re-encoded coefficient-continuation */
; 4236 :         dfp64_clear_cf_and_bxcf(&x3);

  00266	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  0026b	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 4237 :         decimal64ToNumber(&x3, &d);

  00270	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  00275	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  0027a	e8 00 00 00 00	 call	 decimal64ToNumber

; 4238 :         decimal64FromNumber(&x1, &d, &set);

  0027f	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  00284	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  00289	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  0028e	e8 00 00 00 00	 call	 decimal64FromNumber

; 4239 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  00293	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  00298	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  0029d	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4240 :     }

  002a2	e9 a9 00 00 00	 jmp	 $LN17@z900_inser
$LN16@z900_inser:

; 4241 :     else if (bexp == -1) /* Infinity */

  002a7	48 83 7c 24 28
	ff		 cmp	 QWORD PTR bexp$[rsp], -1
  002ad	75 3e		 jne	 SHORT $LN18@z900_inser

; 4242 :     {
; 4243 :         /* Result is Infinity with re-encoded coefficient-continuation */
; 4244 :         dfp64_clear_cf_and_bxcf(&x3);

  002af	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  002b4	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 4245 :         decimal64ToNumber(&x3, &d);

  002b9	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  002be	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  002c3	e8 00 00 00 00	 call	 decimal64ToNumber

; 4246 :         decimal64FromNumber(&x1, &d, &set);

  002c8	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  002cd	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  002d2	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  002d7	e8 00 00 00 00	 call	 decimal64FromNumber

; 4247 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  002dc	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  002e1	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  002e6	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4248 :     }

  002eb	eb 63		 jmp	 SHORT $LN19@z900_inser
$LN18@z900_inser:

; 4249 :     else
; 4250 :     {
; 4251 :         decimal64ToNumber(&x3, &d);

  002ed	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  002f2	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  002f7	e8 00 00 00 00	 call	 decimal64ToNumber

; 4252 :         /* Clear CF and BXCF if source is Infinity or NaN */
; 4253 :         if (decNumberIsInfinite(&d) || decNumberIsNaN(&d))

  002fc	0f b6 44 24 58	 movzx	 eax, BYTE PTR d$[rsp+8]
  00301	83 e0 40	 and	 eax, 64			; 00000040H
  00304	85 c0		 test	 eax, eax
  00306	75 0c		 jne	 SHORT $LN21@z900_inser
  00308	0f b6 44 24 58	 movzx	 eax, BYTE PTR d$[rsp+8]
  0030d	83 e0 30	 and	 eax, 48			; 00000030H
  00310	85 c0		 test	 eax, eax
  00312	74 19		 je	 SHORT $LN20@z900_inser
$LN21@z900_inser:

; 4254 :         {
; 4255 :             dfp64_clear_cf_and_bxcf(&x3);

  00314	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00319	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 4256 :             decimal64ToNumber(&x3, &d);

  0031e	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  00323	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00328	e8 00 00 00 00	 call	 decimal64ToNumber
$LN20@z900_inser:

; 4257 :         }
; 4258 :         /* Update exponent and re-encode coefficient-continuation */
; 4259 :         d.exponent = bexp - DECIMAL64_Bias;

  0032d	48 8b 44 24 28	 mov	 rax, QWORD PTR bexp$[rsp]
  00332	48 2d 8e 01 00
	00		 sub	 rax, 398		; 0000018eH
  00338	89 44 24 54	 mov	 DWORD PTR d$[rsp+4], eax

; 4260 :         decimal64FromNumber(&x1, &d, &set);

  0033c	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  00341	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  00346	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  0034b	e8 00 00 00 00	 call	 decimal64FromNumber
$LN19@z900_inser:
$LN17@z900_inser:
$LN14@z900_inser:

; 4261 :     }
; 4262 : 
; 4263 :     /* Load result into FP register r1 */
; 4264 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  00350	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00358	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  0035d	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  00361	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 4265 : 
; 4266 : } /* end DEF_INST(insert_biased_exponent_fix64_to_dfp_long_reg) */

  00366	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0036e	48 33 cc	 xor	 rcx, rsp
  00371	e8 00 00 00 00	 call	 __security_check_cookie
  00376	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0037d	c3		 ret	 0
z900_insert_biased_exponent_fix64_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
bexp$ = 40
r3$ = 48
r1$ = 52
r2$ = 56
x3$ = 64
x1$ = 80
d$ = 96
set$ = 136
__$ArrayPad$ = 168
inst$ = 192
regs$ = 200
z900_insert_biased_exponent_fix64_to_dfp_ext_reg PROC

; 4132 : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4133 : int             r1, r2, r3;             /* Values of R fields        */
; 4134 : decimal128      x1, x3;                 /* Extended DFP values       */
; 4135 : decNumber       d;                      /* Working decimal number    */
; 4136 : decContext      set;                    /* Working context           */
; 4137 : S64             bexp;                   /* Biased exponent           */
; 4138 : 
; 4139 :     RRF_M(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_inser:
  00062	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_inser
  00085	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_inser:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_inser
$LN7@z900_inser:

; 4140 : 
; 4141 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_inser
  000a5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_inser
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_inser
  000be	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_inser
  000d1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_inser
$LN10@z900_inser:
  000e7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197103
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_inser:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_inser

; 4142 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_inser
  00154	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_inser
  0016b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_inser
$LN12@z900_inser:
  00196	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_inser:

; 4143 :     DFPREGPAIR2_CHECK(r1, r3, regs);

  001c3	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  001c7	83 e0 02	 and	 eax, 2
  001ca	85 c0		 test	 eax, eax
  001cc	75 0b		 jne	 SHORT $LN14@z900_inser
  001ce	8b 44 24 30	 mov	 eax, DWORD PTR r3$[rsp]
  001d2	83 e0 02	 and	 eax, 2
  001d5	85 c0		 test	 eax, eax
  001d7	74 1b		 je	 SHORT $LN13@z900_inser
$LN14@z900_inser:
  001d9	ba 06 00 00 00	 mov	 edx, 6
  001de	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ee	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_inser:

; 4144 : 
; 4145 :     /* Initialise the context for extended DFP */
; 4146 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001f4	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001f9	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00201	e8 00 00 00 00	 call	 decContextDefault

; 4147 : 
; 4148 :     /* Load biased exponent from general register r2 */
; 4149 :     bexp = (S64)(regs->GR(r2));

  00206	48 63 44 24 38	 movsxd	 rax, DWORD PTR r2$[rsp]
  0020b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00213	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0021b	48 89 44 24 28	 mov	 QWORD PTR bexp$[rsp], rax

; 4150 : 
; 4151 :     /* Load DFP extended number from FP register r3 */
; 4152 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  00220	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00228	48 8d 54 24 40	 lea	 rdx, QWORD PTR x3$[rsp]
  0022d	8b 4c 24 30	 mov	 ecx, DWORD PTR r3$[rsp]
  00231	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 4153 : 
; 4154 :     /* Insert biased exponent into number */
; 4155 :     if (bexp > DECIMAL128_Ehigh || bexp == -2 || bexp <= -4)

  00236	48 81 7c 24 28
	ff 2f 00 00	 cmp	 QWORD PTR bexp$[rsp], 12287 ; 00002fffH
  0023f	7f 10		 jg	 SHORT $LN17@z900_inser
  00241	48 83 7c 24 28
	fe		 cmp	 QWORD PTR bexp$[rsp], -2
  00247	74 08		 je	 SHORT $LN17@z900_inser
  00249	48 83 7c 24 28
	fc		 cmp	 QWORD PTR bexp$[rsp], -4
  0024f	7f 44		 jg	 SHORT $LN15@z900_inser
$LN17@z900_inser:

; 4156 :     {
; 4157 :         /* Result is a QNaN with re-encoded coefficient-continuation */
; 4158 :         dfp128_clear_cf_and_bxcf(&x3);

  00251	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00256	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 4159 :         decimal128ToNumber(&x3, &d);

  0025b	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  00260	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00265	e8 00 00 00 00	 call	 decimal128ToNumber

; 4160 :         decimal128FromNumber(&x1, &d, &set);

  0026a	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  00272	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  00277	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  0027c	e8 00 00 00 00	 call	 decimal128FromNumber

; 4161 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  00281	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  00286	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  0028b	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf

; 4162 :     }

  00290	e9 fb 00 00 00	 jmp	 $LN16@z900_inser
$LN15@z900_inser:

; 4163 :     else if (bexp == -3)

  00295	48 83 7c 24 28
	fd		 cmp	 QWORD PTR bexp$[rsp], -3
  0029b	75 44		 jne	 SHORT $LN18@z900_inser

; 4164 :     {
; 4165 :         /* Result is a SNaN with re-encoded coefficient-continuation */
; 4166 :         dfp128_clear_cf_and_bxcf(&x3);

  0029d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  002a2	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 4167 :         decimal128ToNumber(&x3, &d);

  002a7	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  002ac	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  002b1	e8 00 00 00 00	 call	 decimal128ToNumber

; 4168 :         decimal128FromNumber(&x1, &d, &set);

  002b6	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  002be	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  002c3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  002c8	e8 00 00 00 00	 call	 decimal128FromNumber

; 4169 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  002cd	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  002d2	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  002d7	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf

; 4170 :     }

  002dc	e9 af 00 00 00	 jmp	 $LN19@z900_inser
$LN18@z900_inser:

; 4171 :     else if (bexp == -1) /* Infinity */

  002e1	48 83 7c 24 28
	ff		 cmp	 QWORD PTR bexp$[rsp], -1
  002e7	75 41		 jne	 SHORT $LN20@z900_inser

; 4172 :     {
; 4173 :         /* Result is Infinity with re-encoded coefficient-continuation */
; 4174 :         dfp128_clear_cf_and_bxcf(&x3);

  002e9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  002ee	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 4175 :         decimal128ToNumber(&x3, &d);

  002f3	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  002f8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  002fd	e8 00 00 00 00	 call	 decimal128ToNumber

; 4176 :         decimal128FromNumber(&x1, &d, &set);

  00302	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  0030a	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  0030f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  00314	e8 00 00 00 00	 call	 decimal128FromNumber

; 4177 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  00319	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  0031e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  00323	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf

; 4178 :     }

  00328	eb 66		 jmp	 SHORT $LN21@z900_inser
$LN20@z900_inser:

; 4179 :     else
; 4180 :     {
; 4181 :         decimal128ToNumber(&x3, &d);

  0032a	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  0032f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00334	e8 00 00 00 00	 call	 decimal128ToNumber

; 4182 :         /* Clear CF and BXCF if source is Infinity or NaN */
; 4183 :         if (decNumberIsInfinite(&d) || decNumberIsNaN(&d))

  00339	0f b6 44 24 68	 movzx	 eax, BYTE PTR d$[rsp+8]
  0033e	83 e0 40	 and	 eax, 64			; 00000040H
  00341	85 c0		 test	 eax, eax
  00343	75 0c		 jne	 SHORT $LN23@z900_inser
  00345	0f b6 44 24 68	 movzx	 eax, BYTE PTR d$[rsp+8]
  0034a	83 e0 30	 and	 eax, 48			; 00000030H
  0034d	85 c0		 test	 eax, eax
  0034f	74 19		 je	 SHORT $LN22@z900_inser
$LN23@z900_inser:

; 4184 :         {
; 4185 :             dfp128_clear_cf_and_bxcf(&x3);

  00351	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00356	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 4186 :             decimal128ToNumber(&x3, &d);

  0035b	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  00360	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00365	e8 00 00 00 00	 call	 decimal128ToNumber
$LN22@z900_inser:

; 4187 :         }
; 4188 :         /* Update exponent and re-encode coefficient-continuation */
; 4189 :         d.exponent = bexp - DECIMAL128_Bias;

  0036a	48 8b 44 24 28	 mov	 rax, QWORD PTR bexp$[rsp]
  0036f	48 2d 20 18 00
	00		 sub	 rax, 6176		; 00001820H
  00375	89 44 24 64	 mov	 DWORD PTR d$[rsp+4], eax

; 4190 :         decimal128FromNumber(&x1, &d, &set);

  00379	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  00381	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  00386	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  0038b	e8 00 00 00 00	 call	 decimal128FromNumber
$LN21@z900_inser:
$LN19@z900_inser:
$LN16@z900_inser:

; 4191 :     }
; 4192 : 
; 4193 :     /* Load result into FP register r1 */
; 4194 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  00390	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00398	48 8d 54 24 50	 lea	 rdx, QWORD PTR x1$[rsp]
  0039d	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  003a1	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 4195 : 
; 4196 : } /* end DEF_INST(insert_biased_exponent_fix64_to_dfp_ext_reg) */

  003a6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003ae	48 33 cc	 xor	 rcx, rsp
  003b1	e8 00 00 00 00	 call	 __security_check_cookie
  003b6	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003bd	c3		 ret	 0
z900_insert_biased_exponent_fix64_to_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
digits$ = 40
r2$ = 48
r1$ = 52
x2$ = 56
d2$ = 64
set$ = 104
__$ArrayPad$ = 136
inst$ = 160
regs$ = 168
z900_extract_significance_dfp_long_reg PROC

; 4089 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4090 : int             r1, r2;                 /* Values of R fields        */
; 4091 : decimal64       x2;                     /* Long DFP value            */
; 4092 : decNumber       d2;                     /* Working decimal number    */
; 4093 : decContext      set;                    /* Working context           */
; 4094 : S64             digits;                 /* Number of decimal digits  */
; 4095 : 
; 4096 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_extra:
  00055	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_extra
  00078	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_extra:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_extra
$LN7@z900_extra:

; 4097 : 
; 4098 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_extra
  00098	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_extra
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_extra
  000b1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_extra
  000c4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_extra
$LN10@z900_extra:
  000da	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197068
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_extra:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_extra

; 4099 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_extra
  00147	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_extra
  0015e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_extra
$LN12@z900_extra:
  00189	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_extra:

; 4100 : 
; 4101 :     /* Initialise the context for long DFP */
; 4102 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001b6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001bb	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  001c0	e8 00 00 00 00	 call	 decContextDefault

; 4103 : 
; 4104 :     /* Load DFP long number from FP register r2 */
; 4105 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001c5	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001cd	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  001d2	8b 4c 24 30	 mov	 ecx, DWORD PTR r2$[rsp]
  001d6	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 4106 : 
; 4107 :     /* Convert to internal decimal number format */
; 4108 :     decimal64ToNumber(&x2, &d2);

  001db	48 8d 54 24 40	 lea	 rdx, QWORD PTR d2$[rsp]
  001e0	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  001e5	e8 00 00 00 00	 call	 decimal64ToNumber

; 4109 : 
; 4110 :     /* Calculate number of significant digits */
; 4111 :     if (decNumberIsZero(&d2))

  001ea	b8 02 00 00 00	 mov	 eax, 2
  001ef	48 6b c0 00	 imul	 rax, rax, 0
  001f3	0f b7 44 04 4a	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  001f8	85 c0		 test	 eax, eax
  001fa	75 1e		 jne	 SHORT $LN13@z900_extra
  001fc	83 7c 24 40 01	 cmp	 DWORD PTR d2$[rsp], 1
  00201	75 17		 jne	 SHORT $LN13@z900_extra
  00203	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00208	83 e0 70	 and	 eax, 112		; 00000070H
  0020b	85 c0		 test	 eax, eax
  0020d	75 0b		 jne	 SHORT $LN13@z900_extra

; 4112 :         digits = 0;

  0020f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR digits$[rsp], 0
  00218	eb 4f		 jmp	 SHORT $LN14@z900_extra
$LN13@z900_extra:

; 4113 :     else if (decNumberIsInfinite(&d2))

  0021a	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0021f	83 e0 40	 and	 eax, 64			; 00000040H
  00222	85 c0		 test	 eax, eax
  00224	74 0b		 je	 SHORT $LN15@z900_extra

; 4114 :         digits = -1;

  00226	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR digits$[rsp], -1
  0022f	eb 38		 jmp	 SHORT $LN16@z900_extra
$LN15@z900_extra:

; 4115 :     else if (decNumberIsQNaN(&d2))

  00231	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00236	83 e0 20	 and	 eax, 32			; 00000020H
  00239	85 c0		 test	 eax, eax
  0023b	74 0b		 je	 SHORT $LN17@z900_extra

; 4116 :         digits = -2;

  0023d	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR digits$[rsp], -2
  00246	eb 21		 jmp	 SHORT $LN18@z900_extra
$LN17@z900_extra:

; 4117 :     else if (decNumberIsSNaN(&d2))

  00248	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0024d	83 e0 10	 and	 eax, 16
  00250	85 c0		 test	 eax, eax
  00252	74 0b		 je	 SHORT $LN19@z900_extra

; 4118 :         digits = -3;

  00254	48 c7 44 24 28
	fd ff ff ff	 mov	 QWORD PTR digits$[rsp], -3
  0025d	eb 0a		 jmp	 SHORT $LN20@z900_extra
$LN19@z900_extra:

; 4119 :     else
; 4120 :         digits = d2.digits;

  0025f	48 63 44 24 40	 movsxd	 rax, DWORD PTR d2$[rsp]
  00264	48 89 44 24 28	 mov	 QWORD PTR digits$[rsp], rax
$LN20@z900_extra:
$LN18@z900_extra:
$LN16@z900_extra:
$LN14@z900_extra:

; 4121 : 
; 4122 :     /* Load result into general register r1 */
; 4123 :     regs->GR(r1) = digits;

  00269	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0026e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00276	48 8b 54 24 28	 mov	 rdx, QWORD PTR digits$[rsp]
  0027b	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 4124 : 
; 4125 : } /* end DEF_INST(extract_significance_dfp_long_reg) */

  00283	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0028b	48 33 cc	 xor	 rcx, rsp
  0028e	e8 00 00 00 00	 call	 __security_check_cookie
  00293	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0029a	c3		 ret	 0
z900_extract_significance_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
digits$ = 40
r1$ = 48
d2$ = 56
x2$ = 96
set$ = 112
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
z900_extract_significance_dfp_ext_reg PROC

; 4045 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4046 : int             r1, r2;                 /* Values of R fields        */
; 4047 : decimal128      x2;                     /* Extended DFP value        */
; 4048 : decNumber       d2;                     /* Working decimal number    */
; 4049 : decContext      set;                    /* Working context           */
; 4050 : S64             digits;                 /* Number of decimal digits  */
; 4051 : 
; 4052 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_extra:
  00055	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_extra
  00078	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_extra:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_extra
$LN7@z900_extra:

; 4053 : 
; 4054 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_extra
  00098	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_extra
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_extra
  000b1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_extra
  000c4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_extra
$LN10@z900_extra:
  000da	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197035
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_extra:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_extra

; 4055 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_extra
  00147	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_extra
  0015e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_extra
$LN12@z900_extra:
  00189	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_extra:

; 4056 :     DFPREGPAIR_CHECK(r2, regs);

  001b6	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  001ba	83 e0 02	 and	 eax, 2
  001bd	85 c0		 test	 eax, eax
  001bf	74 1b		 je	 SHORT $LN13@z900_extra
  001c1	ba 06 00 00 00	 mov	 edx, 6
  001c6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_extra:

; 4057 : 
; 4058 :     /* Initialise the context for extended DFP */
; 4059 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001dc	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001e1	48 8d 4c 24 70	 lea	 rcx, QWORD PTR set$[rsp]
  001e6	e8 00 00 00 00	 call	 decContextDefault

; 4060 : 
; 4061 :     /* Load DFP extended number from FP register r2 */
; 4062 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  001eb	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f3	48 8d 54 24 60	 lea	 rdx, QWORD PTR x2$[rsp]
  001f8	8b 4c 24 24	 mov	 ecx, DWORD PTR r2$[rsp]
  001fc	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 4063 : 
; 4064 :     /* Convert to internal decimal number format */
; 4065 :     decimal128ToNumber(&x2, &d2);

  00201	48 8d 54 24 38	 lea	 rdx, QWORD PTR d2$[rsp]
  00206	48 8d 4c 24 60	 lea	 rcx, QWORD PTR x2$[rsp]
  0020b	e8 00 00 00 00	 call	 decimal128ToNumber

; 4066 : 
; 4067 :     /* Calculate number of significant digits */
; 4068 :     if (decNumberIsZero(&d2))

  00210	b8 02 00 00 00	 mov	 eax, 2
  00215	48 6b c0 00	 imul	 rax, rax, 0
  00219	0f b7 44 04 42	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  0021e	85 c0		 test	 eax, eax
  00220	75 1e		 jne	 SHORT $LN14@z900_extra
  00222	83 7c 24 38 01	 cmp	 DWORD PTR d2$[rsp], 1
  00227	75 17		 jne	 SHORT $LN14@z900_extra
  00229	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0022e	83 e0 70	 and	 eax, 112		; 00000070H
  00231	85 c0		 test	 eax, eax
  00233	75 0b		 jne	 SHORT $LN14@z900_extra

; 4069 :         digits = 0;

  00235	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR digits$[rsp], 0
  0023e	eb 4f		 jmp	 SHORT $LN15@z900_extra
$LN14@z900_extra:

; 4070 :     else if (decNumberIsInfinite(&d2))

  00240	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00245	83 e0 40	 and	 eax, 64			; 00000040H
  00248	85 c0		 test	 eax, eax
  0024a	74 0b		 je	 SHORT $LN16@z900_extra

; 4071 :         digits = -1;

  0024c	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR digits$[rsp], -1
  00255	eb 38		 jmp	 SHORT $LN17@z900_extra
$LN16@z900_extra:

; 4072 :     else if (decNumberIsQNaN(&d2))

  00257	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0025c	83 e0 20	 and	 eax, 32			; 00000020H
  0025f	85 c0		 test	 eax, eax
  00261	74 0b		 je	 SHORT $LN18@z900_extra

; 4073 :         digits = -2;

  00263	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR digits$[rsp], -2
  0026c	eb 21		 jmp	 SHORT $LN19@z900_extra
$LN18@z900_extra:

; 4074 :     else if (decNumberIsSNaN(&d2))

  0026e	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00273	83 e0 10	 and	 eax, 16
  00276	85 c0		 test	 eax, eax
  00278	74 0b		 je	 SHORT $LN20@z900_extra

; 4075 :         digits = -3;

  0027a	48 c7 44 24 28
	fd ff ff ff	 mov	 QWORD PTR digits$[rsp], -3
  00283	eb 0a		 jmp	 SHORT $LN21@z900_extra
$LN20@z900_extra:

; 4076 :     else
; 4077 :         digits = d2.digits;

  00285	48 63 44 24 38	 movsxd	 rax, DWORD PTR d2$[rsp]
  0028a	48 89 44 24 28	 mov	 QWORD PTR digits$[rsp], rax
$LN21@z900_extra:
$LN19@z900_extra:
$LN17@z900_extra:
$LN15@z900_extra:

; 4078 : 
; 4079 :     /* Load result into general register r1 */
; 4080 :     regs->GR(r1) = digits;

  0028f	48 63 44 24 30	 movsxd	 rax, DWORD PTR r1$[rsp]
  00294	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029c	48 8b 54 24 28	 mov	 rdx, QWORD PTR digits$[rsp]
  002a1	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 4081 : 
; 4082 : } /* end DEF_INST(extract_significance_dfp_ext_reg) */

  002a9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002b1	48 33 cc	 xor	 rcx, rsp
  002b4	e8 00 00 00 00	 call	 __security_check_cookie
  002b9	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002c0	c3		 ret	 0
z900_extract_significance_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
exponent$ = 40
r2$ = 48
r1$ = 52
x2$ = 56
d2$ = 64
set$ = 104
__$ArrayPad$ = 136
inst$ = 160
regs$ = 168
z900_extract_biased_exponent_dfp_long_to_fix64_reg PROC

; 4004 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4005 : int             r1, r2;                 /* Values of R fields        */
; 4006 : decimal64       x2;                     /* Long DFP value            */
; 4007 : decNumber       d2;                     /* Working decimal number    */
; 4008 : decContext      set;                    /* Working context           */
; 4009 : S64             exponent;               /* Biased exponent           */
; 4010 : 
; 4011 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_extra:
  00055	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_extra
  00078	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_extra:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_extra
$LN7@z900_extra:

; 4012 : 
; 4013 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_extra
  00098	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_extra
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_extra
  000b1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_extra
  000c4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_extra
$LN10@z900_extra:
  000da	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG197005
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_extra:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_extra

; 4014 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_extra
  00147	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_extra
  0015e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_extra
$LN12@z900_extra:
  00189	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_extra:

; 4015 : 
; 4016 :     /* Initialise the context for long DFP */
; 4017 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001b6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001bb	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  001c0	e8 00 00 00 00	 call	 decContextDefault

; 4018 : 
; 4019 :     /* Load DFP long number from FP register r2 */
; 4020 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001c5	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001cd	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  001d2	8b 4c 24 30	 mov	 ecx, DWORD PTR r2$[rsp]
  001d6	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 4021 : 
; 4022 :     /* Convert to internal decimal number format */
; 4023 :     decimal64ToNumber(&x2, &d2);

  001db	48 8d 54 24 40	 lea	 rdx, QWORD PTR d2$[rsp]
  001e0	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  001e5	e8 00 00 00 00	 call	 decimal64ToNumber

; 4024 : 
; 4025 :     /* Calculate the biased exponent */
; 4026 :     if (decNumberIsInfinite(&d2))

  001ea	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001ef	83 e0 40	 and	 eax, 64			; 00000040H
  001f2	85 c0		 test	 eax, eax
  001f4	74 0b		 je	 SHORT $LN13@z900_extra

; 4027 :         exponent = -1;

  001f6	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR exponent$[rsp], -1
  001ff	eb 3e		 jmp	 SHORT $LN14@z900_extra
$LN13@z900_extra:

; 4028 :     else if (decNumberIsQNaN(&d2))

  00201	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00206	83 e0 20	 and	 eax, 32			; 00000020H
  00209	85 c0		 test	 eax, eax
  0020b	74 0b		 je	 SHORT $LN15@z900_extra

; 4029 :         exponent = -2;

  0020d	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR exponent$[rsp], -2
  00216	eb 27		 jmp	 SHORT $LN16@z900_extra
$LN15@z900_extra:

; 4030 :     else if (decNumberIsSNaN(&d2))

  00218	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0021d	83 e0 10	 and	 eax, 16
  00220	85 c0		 test	 eax, eax
  00222	74 0b		 je	 SHORT $LN17@z900_extra

; 4031 :         exponent = -3;

  00224	48 c7 44 24 28
	fd ff ff ff	 mov	 QWORD PTR exponent$[rsp], -3
  0022d	eb 10		 jmp	 SHORT $LN18@z900_extra
$LN17@z900_extra:

; 4032 :     else
; 4033 :         exponent = d2.exponent + DECIMAL64_Bias;

  0022f	8b 44 24 44	 mov	 eax, DWORD PTR d2$[rsp+4]
  00233	05 8e 01 00 00	 add	 eax, 398		; 0000018eH
  00238	48 98		 cdqe
  0023a	48 89 44 24 28	 mov	 QWORD PTR exponent$[rsp], rax
$LN18@z900_extra:
$LN16@z900_extra:
$LN14@z900_extra:

; 4034 : 
; 4035 :     /* Load result into general register r1 */
; 4036 :     regs->GR(r1) = exponent;

  0023f	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  00244	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0024c	48 8b 54 24 28	 mov	 rdx, QWORD PTR exponent$[rsp]
  00251	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 4037 : 
; 4038 : } /* end DEF_INST(extract_biased_exponent_dfp_long_to_fix64_reg) */

  00259	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00261	48 33 cc	 xor	 rcx, rsp
  00264	e8 00 00 00 00	 call	 __security_check_cookie
  00269	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00270	c3		 ret	 0
z900_extract_biased_exponent_dfp_long_to_fix64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
exponent$ = 40
r1$ = 48
d2$ = 56
x2$ = 96
set$ = 112
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
z900_extract_biased_exponent_dfp_ext_to_fix64_reg PROC

; 3962 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3963 : int             r1, r2;                 /* Values of R fields        */
; 3964 : decimal128      x2;                     /* Extended DFP value        */
; 3965 : decNumber       d2;                     /* Working decimal number    */
; 3966 : decContext      set;                    /* Working context           */
; 3967 : S64             exponent;               /* Biased exponent           */
; 3968 : 
; 3969 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_extra:
  00055	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_extra
  00078	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_extra:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_extra
$LN7@z900_extra:

; 3970 : 
; 3971 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_extra
  00098	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_extra
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_extra
  000b1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_extra
  000c4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_extra
$LN10@z900_extra:
  000da	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196974
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_extra:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_extra

; 3972 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_extra
  00147	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_extra
  0015e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_extra
$LN12@z900_extra:
  00189	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_extra:

; 3973 :     DFPREGPAIR_CHECK(r2, regs);

  001b6	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  001ba	83 e0 02	 and	 eax, 2
  001bd	85 c0		 test	 eax, eax
  001bf	74 1b		 je	 SHORT $LN13@z900_extra
  001c1	ba 06 00 00 00	 mov	 edx, 6
  001c6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_extra:

; 3974 : 
; 3975 :     /* Initialise the context for extended DFP */
; 3976 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001dc	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001e1	48 8d 4c 24 70	 lea	 rcx, QWORD PTR set$[rsp]
  001e6	e8 00 00 00 00	 call	 decContextDefault

; 3977 : 
; 3978 :     /* Load DFP extended number from FP register r2 */
; 3979 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  001eb	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f3	48 8d 54 24 60	 lea	 rdx, QWORD PTR x2$[rsp]
  001f8	8b 4c 24 24	 mov	 ecx, DWORD PTR r2$[rsp]
  001fc	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 3980 : 
; 3981 :     /* Convert to internal decimal number format */
; 3982 :     decimal128ToNumber(&x2, &d2);

  00201	48 8d 54 24 38	 lea	 rdx, QWORD PTR d2$[rsp]
  00206	48 8d 4c 24 60	 lea	 rcx, QWORD PTR x2$[rsp]
  0020b	e8 00 00 00 00	 call	 decimal128ToNumber

; 3983 : 
; 3984 :     /* Calculate the biased exponent */
; 3985 :     if (decNumberIsInfinite(&d2))

  00210	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00215	83 e0 40	 and	 eax, 64			; 00000040H
  00218	85 c0		 test	 eax, eax
  0021a	74 0b		 je	 SHORT $LN14@z900_extra

; 3986 :         exponent = -1;

  0021c	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR exponent$[rsp], -1
  00225	eb 3e		 jmp	 SHORT $LN15@z900_extra
$LN14@z900_extra:

; 3987 :     else if (decNumberIsQNaN(&d2))

  00227	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0022c	83 e0 20	 and	 eax, 32			; 00000020H
  0022f	85 c0		 test	 eax, eax
  00231	74 0b		 je	 SHORT $LN16@z900_extra

; 3988 :         exponent = -2;

  00233	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR exponent$[rsp], -2
  0023c	eb 27		 jmp	 SHORT $LN17@z900_extra
$LN16@z900_extra:

; 3989 :     else if (decNumberIsSNaN(&d2))

  0023e	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00243	83 e0 10	 and	 eax, 16
  00246	85 c0		 test	 eax, eax
  00248	74 0b		 je	 SHORT $LN18@z900_extra

; 3990 :         exponent = -3;

  0024a	48 c7 44 24 28
	fd ff ff ff	 mov	 QWORD PTR exponent$[rsp], -3
  00253	eb 10		 jmp	 SHORT $LN19@z900_extra
$LN18@z900_extra:

; 3991 :     else
; 3992 :         exponent = d2.exponent + DECIMAL128_Bias;

  00255	8b 44 24 3c	 mov	 eax, DWORD PTR d2$[rsp+4]
  00259	05 20 18 00 00	 add	 eax, 6176		; 00001820H
  0025e	48 98		 cdqe
  00260	48 89 44 24 28	 mov	 QWORD PTR exponent$[rsp], rax
$LN19@z900_extra:
$LN17@z900_extra:
$LN15@z900_extra:

; 3993 : 
; 3994 :     /* Load result into general register r1 */
; 3995 :     regs->GR(r1) = exponent;

  00265	48 63 44 24 30	 movsxd	 rax, DWORD PTR r1$[rsp]
  0026a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00272	48 8b 54 24 28	 mov	 rdx, QWORD PTR exponent$[rsp]
  00277	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3996 : 
; 3997 : } /* end DEF_INST(extract_biased_exponent_dfp_ext_to_fix64_reg) */

  0027f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00287	48 33 cc	 xor	 rcx, rsp
  0028a	e8 00 00 00 00	 call	 __security_check_cookie
  0028f	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00296	c3		 ret	 0
z900_extract_biased_exponent_dfp_ext_to_fix64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
x2$ = 56
x3$ = 64
x1$ = 72
set$ = 80
d3$ = 112
d2$ = 152
d1$ = 192
__$ArrayPad$ = 232
inst$ = 256
regs$ = 264
z900_divide_dfp_long_reg PROC

; 3918 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3919 : int             r1, r2, r3;             /* Values of R fields        */
; 3920 : decimal64       x1, x2, x3;             /* Long DFP values           */
; 3921 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 3922 : decContext      set;                    /* Working context           */
; 3923 : BYTE            dxc;                    /* Data exception code       */
; 3924 : 
; 3925 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_divid:
  00062	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_divid
  00085	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_divid:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_divid
$LN7@z900_divid:

; 3926 : 
; 3927 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_divid
  000a5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_divid
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_divid
  000be	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_divid
  000d1	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_divid
$LN10@z900_divid:
  000e7	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196949
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_divid:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_divid

; 3928 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_divid
  00154	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_divid
  0016b	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_divid
$LN12@z900_divid:
  00196	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_divid:

; 3929 : 
; 3930 :     /* Initialise the context for long DFP */
; 3931 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001c3	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001c8	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001cd	e8 00 00 00 00	 call	 decContextDefault

; 3932 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  001d2	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001da	33 d2		 xor	 edx, edx
  001dc	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001e1	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 3933 : 
; 3934 :     /* Divide FP register r2 by FP register r3 */
; 3935 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001e6	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001ee	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  001f3	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  001f7	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 3936 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  001fc	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00204	48 8d 54 24 40	 lea	 rdx, QWORD PTR x3$[rsp]
  00209	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  0020d	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 3937 :     decimal64ToNumber(&x2, &d2);

  00212	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0021a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  0021f	e8 00 00 00 00	 call	 decimal64ToNumber

; 3938 :     decimal64ToNumber(&x3, &d3);

  00224	48 8d 54 24 70	 lea	 rdx, QWORD PTR d3$[rsp]
  00229	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  0022e	e8 00 00 00 00	 call	 decimal64ToNumber

; 3939 :     decNumberDivide(&d1, &d2, &d3, &set);

  00233	4c 8d 4c 24 50	 lea	 r9, QWORD PTR set$[rsp]
  00238	4c 8d 44 24 70	 lea	 r8, QWORD PTR d3$[rsp]
  0023d	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00245	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  0024d	e8 00 00 00 00	 call	 decNumberDivide

; 3940 :     decimal64FromNumber(&x1, &d1, &set);

  00252	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  00257	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0025f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00264	e8 00 00 00 00	 call	 decimal64FromNumber

; 3941 : 
; 3942 :     /* Check for exception condition */
; 3943 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00269	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00271	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00276	e8 00 00 00 00	 call	 z900_dfp_status_check
  0027b	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3944 : 
; 3945 :     /* Load result into FP register r1 */
; 3946 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  0027f	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00287	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  0028c	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  00290	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 3947 : 
; 3948 :     /* Raise data exception if error occurred */
; 3949 :     if (dxc != 0)

  00295	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0029a	85 c0		 test	 eax, eax
  0029c	74 25		 je	 SHORT $LN13@z900_divid

; 3950 :     {
; 3951 :         regs->dxc = dxc;

  0029e	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002a3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ab	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3952 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002b1	ba 07 00 00 00	 mov	 edx, 7
  002b6	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002be	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_divid:

; 3953 :     }
; 3954 : 
; 3955 : } /* end DEF_INST(divide_dfp_long_reg) */

  002c3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002cb	48 33 cc	 xor	 rcx, rsp
  002ce	e8 00 00 00 00	 call	 __security_check_cookie
  002d3	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  002da	c3		 ret	 0
z900_divide_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
set$ = 56
x2$ = 88
x3$ = 104
x1$ = 120
d3$ = 136
d2$ = 176
d1$ = 216
__$ArrayPad$ = 256
inst$ = 288
regs$ = 296
z900_divide_dfp_ext_reg PROC

; 3873 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3874 : int             r1, r2, r3;             /* Values of R fields        */
; 3875 : decimal128      x1, x2, x3;             /* Extended DFP values       */
; 3876 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 3877 : decContext      set;                    /* Working context           */
; 3878 : BYTE            dxc;                    /* Data exception code       */
; 3879 : 
; 3880 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_divid:
  00062	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_divid
  00085	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_divid:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_divid
$LN7@z900_divid:

; 3881 : 
; 3882 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_divid
  000a5	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_divid
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_divid
  000be	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_divid
  000d1	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_divid
$LN10@z900_divid:
  000e7	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196917
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_divid:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_divid

; 3883 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_divid
  00154	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_divid
  0016b	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_divid
$LN12@z900_divid:
  00196	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_divid:

; 3884 :     DFPREGPAIR3_CHECK(r1, r2, r3, regs);

  001c3	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  001c7	83 e0 02	 and	 eax, 2
  001ca	85 c0		 test	 eax, eax
  001cc	75 16		 jne	 SHORT $LN14@z900_divid
  001ce	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001d2	83 e0 02	 and	 eax, 2
  001d5	85 c0		 test	 eax, eax
  001d7	75 0b		 jne	 SHORT $LN14@z900_divid
  001d9	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  001dd	83 e0 02	 and	 eax, 2
  001e0	85 c0		 test	 eax, eax
  001e2	74 1b		 je	 SHORT $LN13@z900_divid
$LN14@z900_divid:
  001e4	ba 06 00 00 00	 mov	 edx, 6
  001e9	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f1	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_divid:

; 3885 : 
; 3886 :     /* Initialise the context for extended DFP */
; 3887 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001ff	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00204	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  00209	e8 00 00 00 00	 call	 decContextDefault

; 3888 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  0020e	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00216	33 d2		 xor	 edx, edx
  00218	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  0021d	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 3889 : 
; 3890 :     /* Divide FP register r2 by FP register r3 */
; 3891 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00222	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0022a	48 8d 54 24 58	 lea	 rdx, QWORD PTR x2$[rsp]
  0022f	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00233	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 3892 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  00238	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00240	48 8d 54 24 68	 lea	 rdx, QWORD PTR x3$[rsp]
  00245	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  00249	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 3893 :     decimal128ToNumber(&x2, &d2);

  0024e	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00256	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x2$[rsp]
  0025b	e8 00 00 00 00	 call	 decimal128ToNumber

; 3894 :     decimal128ToNumber(&x3, &d3);

  00260	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  00268	48 8d 4c 24 68	 lea	 rcx, QWORD PTR x3$[rsp]
  0026d	e8 00 00 00 00	 call	 decimal128ToNumber

; 3895 :     decNumberDivide(&d1, &d2, &d3, &set);

  00272	4c 8d 4c 24 38	 lea	 r9, QWORD PTR set$[rsp]
  00277	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  0027f	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00287	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  0028f	e8 00 00 00 00	 call	 decNumberDivide

; 3896 :     decimal128FromNumber(&x1, &d1, &set);

  00294	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  00299	48 8d 94 24 d8
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  002a1	48 8d 4c 24 78	 lea	 rcx, QWORD PTR x1$[rsp]
  002a6	e8 00 00 00 00	 call	 decimal128FromNumber

; 3897 : 
; 3898 :     /* Check for exception condition */
; 3899 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  002ab	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002b3	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  002b8	e8 00 00 00 00	 call	 z900_dfp_status_check
  002bd	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3900 : 
; 3901 :     /* Load result into FP register r1 */
; 3902 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  002c1	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002c9	48 8d 54 24 78	 lea	 rdx, QWORD PTR x1$[rsp]
  002ce	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  002d2	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 3903 : 
; 3904 :     /* Raise data exception if error occurred */
; 3905 :     if (dxc != 0)

  002d7	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002dc	85 c0		 test	 eax, eax
  002de	74 25		 je	 SHORT $LN15@z900_divid

; 3906 :     {
; 3907 :         regs->dxc = dxc;

  002e0	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002e5	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ed	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3908 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002f3	ba 07 00 00 00	 mov	 edx, 7
  002f8	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00300	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_divid:

; 3909 :     }
; 3910 : 
; 3911 : } /* end DEF_INST(divide_dfp_ext_reg) */

  00305	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0030d	48 33 cc	 xor	 rcx, rsp
  00310	e8 00 00 00 00	 call	 __security_check_cookie
  00315	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0031c	c3		 ret	 0
z900_divide_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
scale$ = 48
x2$ = 56
dwork$ = 64
set$ = 104
pwork$ = 136
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
z900_convert_dfp_long_to_ubcd64_reg PROC

; 3609 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3610 : int             i;                      /* Array subscript           */
; 3611 : int             r1, r2;                 /* Values of R fields        */
; 3612 : decimal64       x2;                     /* Long DFP values           */
; 3613 : decNumber       dwork;                  /* Working decimal number    */
; 3614 : decContext      set;                    /* Working context           */
; 3615 : int32_t         scale;                  /* Scaling factor            */
; 3616 : BYTE            pwork[9];               /* 17-digit packed work area */
; 3617 : 
; 3618 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_conve:
  00055	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN11@z900_conve
  00078	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_conve:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 3619 : 
; 3620 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN12@z900_conve
  00098	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN12@z900_conve
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN13@z900_conve
  000b1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN13@z900_conve
  000c4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  000da	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196752
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_conve:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3621 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN15@z900_conve
  00147	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN14@z900_conve
  0015e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN14@z900_conve
$LN15@z900_conve:
  00189	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_conve:

; 3622 : 
; 3623 :     /* Initialise the context for long DFP */
; 3624 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001b6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001bb	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  001c0	e8 00 00 00 00	 call	 decContextDefault

; 3625 : 
; 3626 :     /* Load DFP long number from FP register r2 */
; 3627 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001c5	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001cd	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  001d2	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  001d6	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 3628 :     decimal64ToNumber(&x2, &dwork);

  001db	48 8d 54 24 40	 lea	 rdx, QWORD PTR dwork$[rsp]
  001e0	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  001e5	e8 00 00 00 00	 call	 decimal64ToNumber

; 3629 : 
; 3630 :     /* If NaN or Inf then use coefficient only */
; 3631 :     if (decNumberIsNaN(&dwork) || (decNumberIsInfinite(&dwork)))

  001ea	0f b6 44 24 48	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  001ef	83 e0 30	 and	 eax, 48			; 00000030H
  001f2	85 c0		 test	 eax, eax
  001f4	75 0c		 jne	 SHORT $LN17@z900_conve
  001f6	0f b6 44 24 48	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  001fb	83 e0 40	 and	 eax, 64			; 00000040H
  001fe	85 c0		 test	 eax, eax
  00200	74 19		 je	 SHORT $LN16@z900_conve
$LN17@z900_conve:

; 3632 :     {
; 3633 :         dfp64_clear_cf_and_bxcf(&x2);

  00202	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00207	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 3634 :         decimal64ToNumber(&x2, &dwork);

  0020c	48 8d 54 24 40	 lea	 rdx, QWORD PTR dwork$[rsp]
  00211	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00216	e8 00 00 00 00	 call	 decimal64ToNumber
$LN16@z900_conve:

; 3635 :     }
; 3636 : 
; 3637 :     /* Convert number to signed BCD in work area */
; 3638 :     decPackedFromNumber(pwork, sizeof(pwork), &scale, &dwork);

  0021b	4c 8d 4c 24 40	 lea	 r9, QWORD PTR dwork$[rsp]
  00220	4c 8d 44 24 30	 lea	 r8, QWORD PTR scale$[rsp]
  00225	ba 09 00 00 00	 mov	 edx, 9
  0022a	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  00232	e8 00 00 00 00	 call	 decPackedFromNumber

; 3639 : 
; 3640 :     /* Convert signed BCD to unsigned BCD */
; 3641 :     for (i = sizeof(pwork)-1; i > 0; i--)

  00237	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR i$[rsp], 8
  0023f	eb 0a		 jmp	 SHORT $LN10@z900_conve
$LN8@z900_conve:
  00241	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00245	ff c8		 dec	 eax
  00247	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_conve:
  0024b	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00250	7e 37		 jle	 SHORT $LN9@z900_conve

; 3642 :         pwork[i] = (pwork[i] >> 4) | ((pwork[i-1] & 0x0F) << 4);

  00252	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00257	0f b6 84 04 88
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  0025f	c1 f8 04	 sar	 eax, 4
  00262	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00266	ff c9		 dec	 ecx
  00268	48 63 c9	 movsxd	 rcx, ecx
  0026b	0f b6 8c 0c 88
	00 00 00	 movzx	 ecx, BYTE PTR pwork$[rsp+rcx]
  00273	83 e1 0f	 and	 ecx, 15
  00276	c1 e1 04	 shl	 ecx, 4
  00279	0b c1		 or	 eax, ecx
  0027b	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00280	88 84 0c 88 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al
  00287	eb b8		 jmp	 SHORT $LN8@z900_conve
$LN9@z900_conve:

; 3643 : 
; 3644 :     /* Load general register r1 from rightmost
; 3645 :        16 packed decimal digits of work area */
; 3646 :     FETCH_DW(regs->GR_G(r1), pwork+sizeof(pwork)-8);

  00289	48 8d 84 24 89
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+1]
  00291	48 8b c8	 mov	 rcx, rax
  00294	e8 00 00 00 00	 call	 fetch_dw_noswap
  00299	48 8b c8	 mov	 rcx, rax
  0029c	e8 00 00 00 00	 call	 _byteswap_uint64
  002a1	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r1$[rsp]
  002a6	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002ae	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3647 : 
; 3648 : } /* end DEF_INST(convert_dfp_long_to_ubcd64_reg) */

  002b6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002be	48 33 cc	 xor	 rcx, rsp
  002c1	e8 00 00 00 00	 call	 __security_check_cookie
  002c6	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002cd	c3		 ret	 0
z900_convert_dfp_long_to_ubcd64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
scale$ = 48
x2$ = 56
dwork$ = 72
set$ = 112
pwork$ = 144
__$ArrayPad$ = 168
inst$ = 192
regs$ = 200
z900_convert_dfp_ext_to_ubcd128_reg PROC

; 3560 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3561 : int             i;                      /* Array subscript           */
; 3562 : int             r1, r2;                 /* Values of R fields        */
; 3563 : decimal128      x2;                     /* Extended DFP values       */
; 3564 : decNumber       dwork;                  /* Working decimal number    */
; 3565 : decContext      set;                    /* Working context           */
; 3566 : int32_t         scale;                  /* Scaling factor            */
; 3567 : BYTE            pwork[17];              /* 33-digit packed work area */
; 3568 : 
; 3569 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_conve:
  00055	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN11@z900_conve
  00078	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_conve:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 3570 : 
; 3571 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN12@z900_conve
  00098	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN12@z900_conve
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN13@z900_conve
  000b1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN13@z900_conve
  000c4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  000da	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196719
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_conve:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3572 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN15@z900_conve
  00147	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN14@z900_conve
  0015e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN14@z900_conve
$LN15@z900_conve:
  00189	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_conve:

; 3573 :     DFPREGPAIR_CHECK(r2, regs);

  001b6	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001ba	83 e0 02	 and	 eax, 2
  001bd	85 c0		 test	 eax, eax
  001bf	74 1b		 je	 SHORT $LN16@z900_conve
  001c1	ba 06 00 00 00	 mov	 edx, 6
  001c6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_conve:

; 3574 :     ODD_CHECK(r1, regs);

  001dc	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001e0	83 e0 01	 and	 eax, 1
  001e3	85 c0		 test	 eax, eax
  001e5	74 1b		 je	 SHORT $LN17@z900_conve
  001e7	ba 06 00 00 00	 mov	 edx, 6
  001ec	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_conve:

; 3575 : 
; 3576 :     /* Initialise the context for extended DFP */
; 3577 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00202	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00207	48 8d 4c 24 70	 lea	 rcx, QWORD PTR set$[rsp]
  0020c	e8 00 00 00 00	 call	 decContextDefault

; 3578 : 
; 3579 :     /* Load DFP extended number from FP register r2 */
; 3580 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00211	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00219	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  0021e	8b 4c 24 2c	 mov	 ecx, DWORD PTR r2$[rsp]
  00222	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 3581 :     decimal128ToNumber(&x2, &dwork);

  00227	48 8d 54 24 48	 lea	 rdx, QWORD PTR dwork$[rsp]
  0022c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00231	e8 00 00 00 00	 call	 decimal128ToNumber

; 3582 : 
; 3583 :     /* If NaN or Inf then use coefficient only */
; 3584 :     if (decNumberIsNaN(&dwork) || (decNumberIsInfinite(&dwork)))

  00236	0f b6 44 24 50	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  0023b	83 e0 30	 and	 eax, 48			; 00000030H
  0023e	85 c0		 test	 eax, eax
  00240	75 0c		 jne	 SHORT $LN19@z900_conve
  00242	0f b6 44 24 50	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  00247	83 e0 40	 and	 eax, 64			; 00000040H
  0024a	85 c0		 test	 eax, eax
  0024c	74 19		 je	 SHORT $LN18@z900_conve
$LN19@z900_conve:

; 3585 :     {
; 3586 :         dfp128_clear_cf_and_bxcf(&x2);

  0024e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00253	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 3587 :         decimal128ToNumber(&x2, &dwork);

  00258	48 8d 54 24 48	 lea	 rdx, QWORD PTR dwork$[rsp]
  0025d	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00262	e8 00 00 00 00	 call	 decimal128ToNumber
$LN18@z900_conve:

; 3588 :     }
; 3589 : 
; 3590 :     /* Convert number to signed BCD in work area */
; 3591 :     decPackedFromNumber(pwork, sizeof(pwork), &scale, &dwork);

  00267	4c 8d 4c 24 48	 lea	 r9, QWORD PTR dwork$[rsp]
  0026c	4c 8d 44 24 30	 lea	 r8, QWORD PTR scale$[rsp]
  00271	ba 11 00 00 00	 mov	 edx, 17
  00276	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  0027e	e8 00 00 00 00	 call	 decPackedFromNumber

; 3592 : 
; 3593 :     /* Convert signed BCD to unsigned BCD */
; 3594 :     for (i = sizeof(pwork)-1; i > 0; i--)

  00283	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR i$[rsp], 16
  0028b	eb 0a		 jmp	 SHORT $LN10@z900_conve
$LN8@z900_conve:
  0028d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00291	ff c8		 dec	 eax
  00293	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_conve:
  00297	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0029c	7e 37		 jle	 SHORT $LN9@z900_conve

; 3595 :         pwork[i] = (pwork[i] >> 4) | ((pwork[i-1] & 0x0F) << 4);

  0029e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002a3	0f b6 84 04 90
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  002ab	c1 f8 04	 sar	 eax, 4
  002ae	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  002b2	ff c9		 dec	 ecx
  002b4	48 63 c9	 movsxd	 rcx, ecx
  002b7	0f b6 8c 0c 90
	00 00 00	 movzx	 ecx, BYTE PTR pwork$[rsp+rcx]
  002bf	83 e1 0f	 and	 ecx, 15
  002c2	c1 e1 04	 shl	 ecx, 4
  002c5	0b c1		 or	 eax, ecx
  002c7	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  002cc	88 84 0c 90 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al
  002d3	eb b8		 jmp	 SHORT $LN8@z900_conve
$LN9@z900_conve:

; 3596 : 
; 3597 :     /* Load general register pair r1 and r1+1 from
; 3598 :        rightmost 32 packed decimal digits of work area */
; 3599 :     FETCH_DW(regs->GR_G(r1), pwork+sizeof(pwork)-16);

  002d5	48 8d 84 24 91
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+1]
  002dd	48 8b c8	 mov	 rcx, rax
  002e0	e8 00 00 00 00	 call	 fetch_dw_noswap
  002e5	48 8b c8	 mov	 rcx, rax
  002e8	e8 00 00 00 00	 call	 _byteswap_uint64
  002ed	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  002f2	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002fa	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3600 :     FETCH_DW(regs->GR_G(r1+1), pwork+sizeof(pwork)-8);

  00302	48 8d 84 24 99
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+9]
  0030a	48 8b c8	 mov	 rcx, rax
  0030d	e8 00 00 00 00	 call	 fetch_dw_noswap
  00312	48 8b c8	 mov	 rcx, rax
  00315	e8 00 00 00 00	 call	 _byteswap_uint64
  0031a	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  0031e	ff c1		 inc	 ecx
  00320	48 63 c9	 movsxd	 rcx, ecx
  00323	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0032b	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3601 : 
; 3602 : } /* end DEF_INST(convert_dfp_ext_to_ubcd128_reg) */

  00333	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0033b	48 33 cc	 xor	 rcx, rsp
  0033e	e8 00 00 00 00	 call	 __security_check_cookie
  00343	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0034a	c3		 ret	 0
z900_convert_dfp_ext_to_ubcd128_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
r2$ = 36
m4$ = 40
r1$ = 44
scale$ = 48
x2$ = 56
dwork$ = 64
set$ = 104
pwork$ = 136
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
z900_convert_dfp_long_to_sbcd64_reg PROC

; 3514 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3515 : int             r1, r2;                 /* Values of R fields        */
; 3516 : int             m4;                     /* Values of M fields        */
; 3517 : decimal64       x2;                     /* Long DFP values           */
; 3518 : decNumber       dwork;                  /* Working decimal number    */
; 3519 : decContext      set;                    /* Working context           */
; 3520 : int32_t         scale;                  /* Scaling factor            */
; 3521 : BYTE            pwork[9];               /* 17-digit packed work area */
; 3522 : 
; 3523 :     RRF_M4(inst, regs, r1, r2, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 28	 mov	 DWORD PTR m4$[rsp], eax
$LN4@z900_conve:
  00062	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_conve
  00085	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 3524 : 
; 3525 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000a5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_conve
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_conve
  000be	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_conve
  000d1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000e7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196687
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3526 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_conve
  00154	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_conve
  0016b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00196	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 3527 : 
; 3528 :     /* Initialise the context for long DFP */
; 3529 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001c3	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001c8	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  001cd	e8 00 00 00 00	 call	 decContextDefault

; 3530 : 
; 3531 :     /* Load DFP long number from FP register r2 */
; 3532 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001d2	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001da	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  001df	8b 4c 24 24	 mov	 ecx, DWORD PTR r2$[rsp]
  001e3	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 3533 :     decimal64ToNumber(&x2, &dwork);

  001e8	48 8d 54 24 40	 lea	 rdx, QWORD PTR dwork$[rsp]
  001ed	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  001f2	e8 00 00 00 00	 call	 decimal64ToNumber

; 3534 : 
; 3535 :     /* If NaN or Inf then use coefficient only */
; 3536 :     if (decNumberIsNaN(&dwork) || (decNumberIsInfinite(&dwork)))

  001f7	0f b6 44 24 48	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  001fc	83 e0 30	 and	 eax, 48			; 00000030H
  001ff	85 c0		 test	 eax, eax
  00201	75 0c		 jne	 SHORT $LN14@z900_conve
  00203	0f b6 44 24 48	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  00208	83 e0 40	 and	 eax, 64			; 00000040H
  0020b	85 c0		 test	 eax, eax
  0020d	74 19		 je	 SHORT $LN13@z900_conve
$LN14@z900_conve:

; 3537 :     {
; 3538 :         dfp64_clear_cf_and_bxcf(&x2);

  0020f	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00214	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 3539 :         decimal64ToNumber(&x2, &dwork);

  00219	48 8d 54 24 40	 lea	 rdx, QWORD PTR dwork$[rsp]
  0021e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00223	e8 00 00 00 00	 call	 decimal64ToNumber
$LN13@z900_conve:

; 3540 :     }
; 3541 : 
; 3542 :     /* Convert number to signed BCD in work area */
; 3543 :     decPackedFromNumber(pwork, sizeof(pwork), &scale, &dwork);

  00228	4c 8d 4c 24 40	 lea	 r9, QWORD PTR dwork$[rsp]
  0022d	4c 8d 44 24 30	 lea	 r8, QWORD PTR scale$[rsp]
  00232	ba 09 00 00 00	 mov	 edx, 9
  00237	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  0023f	e8 00 00 00 00	 call	 decPackedFromNumber

; 3544 : 
; 3545 :     /* Make the plus-sign X'F' if m4 bit 3 is one */
; 3546 :     if ((m4 & 0x01) && !decNumberIsNegative(&dwork))

  00244	8b 44 24 28	 mov	 eax, DWORD PTR m4$[rsp]
  00248	83 e0 01	 and	 eax, 1
  0024b	85 c0		 test	 eax, eax
  0024d	74 32		 je	 SHORT $LN15@z900_conve
  0024f	0f b6 44 24 48	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  00254	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00259	85 c0		 test	 eax, eax
  0025b	75 24		 jne	 SHORT $LN15@z900_conve

; 3547 :         pwork[sizeof(pwork)-1] |= 0x0F;

  0025d	b8 01 00 00 00	 mov	 eax, 1
  00262	48 6b c0 08	 imul	 rax, rax, 8
  00266	0f b6 84 04 88
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  0026e	83 c8 0f	 or	 eax, 15
  00271	b9 01 00 00 00	 mov	 ecx, 1
  00276	48 6b c9 08	 imul	 rcx, rcx, 8
  0027a	88 84 0c 88 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al
$LN15@z900_conve:

; 3548 : 
; 3549 :     /* Load general register r1 from rightmost
; 3550 :        15 packed decimal digits of work area */
; 3551 :     FETCH_DW(regs->GR_G(r1), pwork+sizeof(pwork)-8);

  00281	48 8d 84 24 89
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+1]
  00289	48 8b c8	 mov	 rcx, rax
  0028c	e8 00 00 00 00	 call	 fetch_dw_noswap
  00291	48 8b c8	 mov	 rcx, rax
  00294	e8 00 00 00 00	 call	 _byteswap_uint64
  00299	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0029e	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002a6	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3552 : 
; 3553 : } /* end DEF_INST(convert_dfp_long_to_sbcd64_reg) */

  002ae	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002b6	48 33 cc	 xor	 rcx, rsp
  002b9	e8 00 00 00 00	 call	 __security_check_cookie
  002be	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002c5	c3		 ret	 0
z900_convert_dfp_long_to_sbcd64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
r2$ = 40
m4$ = 44
scale$ = 48
x2$ = 56
dwork$ = 72
set$ = 112
pwork$ = 144
__$ArrayPad$ = 168
inst$ = 192
regs$ = 200
z900_convert_dfp_ext_to_sbcd128_reg PROC

; 3465 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3466 : int             r1, r2;                 /* Values of R fields        */
; 3467 : int             m4;                     /* Values of M fields        */
; 3468 : decimal128      x2;                     /* Extended DFP values       */
; 3469 : decNumber       dwork;                  /* Working decimal number    */
; 3470 : decContext      set;                    /* Working context           */
; 3471 : int32_t         scale;                  /* Scaling factor            */
; 3472 : BYTE            pwork[18];              /* 33-digit packed work area */
; 3473 : 
; 3474 :     RRF_M4(inst, regs, r1, r2, m4);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR m4$[rsp], eax
$LN4@z900_conve:
  00062	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_conve
  00085	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 3475 : 
; 3476 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000a5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_conve
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_conve
  000be	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_conve
  000d1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000e7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196656
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3477 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_conve
  00154	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_conve
  0016b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00196	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 3478 :     DFPREGPAIR_CHECK(r2, regs);

  001c3	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001c7	83 e0 02	 and	 eax, 2
  001ca	85 c0		 test	 eax, eax
  001cc	74 1b		 je	 SHORT $LN13@z900_conve
  001ce	ba 06 00 00 00	 mov	 edx, 6
  001d3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e3	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 3479 :     ODD_CHECK(r1, regs);

  001e9	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001ed	83 e0 01	 and	 eax, 1
  001f0	85 c0		 test	 eax, eax
  001f2	74 1b		 je	 SHORT $LN14@z900_conve
  001f4	ba 06 00 00 00	 mov	 edx, 6
  001f9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00201	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00209	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_conve:

; 3480 : 
; 3481 :     /* Initialise the context for extended DFP */
; 3482 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0020f	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00214	48 8d 4c 24 70	 lea	 rcx, QWORD PTR set$[rsp]
  00219	e8 00 00 00 00	 call	 decContextDefault

; 3483 : 
; 3484 :     /* Load DFP extended number from FP register r2 */
; 3485 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  0021e	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00226	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  0022b	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  0022f	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 3486 :     decimal128ToNumber(&x2, &dwork);

  00234	48 8d 54 24 48	 lea	 rdx, QWORD PTR dwork$[rsp]
  00239	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  0023e	e8 00 00 00 00	 call	 decimal128ToNumber

; 3487 : 
; 3488 :     /* If NaN or Inf then use coefficient only */
; 3489 :     if (decNumberIsNaN(&dwork) || (decNumberIsInfinite(&dwork)))

  00243	0f b6 44 24 50	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  00248	83 e0 30	 and	 eax, 48			; 00000030H
  0024b	85 c0		 test	 eax, eax
  0024d	75 0c		 jne	 SHORT $LN16@z900_conve
  0024f	0f b6 44 24 50	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  00254	83 e0 40	 and	 eax, 64			; 00000040H
  00257	85 c0		 test	 eax, eax
  00259	74 19		 je	 SHORT $LN15@z900_conve
$LN16@z900_conve:

; 3490 :     {
; 3491 :         dfp128_clear_cf_and_bxcf(&x2);

  0025b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00260	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 3492 :         decimal128ToNumber(&x2, &dwork);

  00265	48 8d 54 24 48	 lea	 rdx, QWORD PTR dwork$[rsp]
  0026a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  0026f	e8 00 00 00 00	 call	 decimal128ToNumber
$LN15@z900_conve:

; 3493 :     }
; 3494 : 
; 3495 :     /* Convert number to signed BCD in work area */
; 3496 :     decPackedFromNumber(pwork, sizeof(pwork), &scale, &dwork);

  00274	4c 8d 4c 24 48	 lea	 r9, QWORD PTR dwork$[rsp]
  00279	4c 8d 44 24 30	 lea	 r8, QWORD PTR scale$[rsp]
  0027e	ba 12 00 00 00	 mov	 edx, 18
  00283	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  0028b	e8 00 00 00 00	 call	 decPackedFromNumber

; 3497 : 
; 3498 :     /* Make the plus-sign X'F' if m4 bit 3 is one */
; 3499 :     if ((m4 & 0x01) && !decNumberIsNegative(&dwork))

  00290	8b 44 24 2c	 mov	 eax, DWORD PTR m4$[rsp]
  00294	83 e0 01	 and	 eax, 1
  00297	85 c0		 test	 eax, eax
  00299	74 32		 je	 SHORT $LN17@z900_conve
  0029b	0f b6 44 24 50	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  002a0	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002a5	85 c0		 test	 eax, eax
  002a7	75 24		 jne	 SHORT $LN17@z900_conve

; 3500 :         pwork[sizeof(pwork)-1] |= 0x0F;

  002a9	b8 01 00 00 00	 mov	 eax, 1
  002ae	48 6b c0 11	 imul	 rax, rax, 17
  002b2	0f b6 84 04 90
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  002ba	83 c8 0f	 or	 eax, 15
  002bd	b9 01 00 00 00	 mov	 ecx, 1
  002c2	48 6b c9 11	 imul	 rcx, rcx, 17
  002c6	88 84 0c 90 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al
$LN17@z900_conve:

; 3501 : 
; 3502 :     /* Load general register pair r1 and r1+1 from
; 3503 :        rightmost 31 packed decimal digits of work area */
; 3504 :     FETCH_DW(regs->GR_G(r1), pwork+sizeof(pwork)-16);

  002cd	48 8d 84 24 92
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+2]
  002d5	48 8b c8	 mov	 rcx, rax
  002d8	e8 00 00 00 00	 call	 fetch_dw_noswap
  002dd	48 8b c8	 mov	 rcx, rax
  002e0	e8 00 00 00 00	 call	 _byteswap_uint64
  002e5	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  002ea	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002f2	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3505 :     FETCH_DW(regs->GR_G(r1+1), pwork+sizeof(pwork)-8);

  002fa	48 8d 84 24 9a
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+10]
  00302	48 8b c8	 mov	 rcx, rax
  00305	e8 00 00 00 00	 call	 fetch_dw_noswap
  0030a	48 8b c8	 mov	 rcx, rax
  0030d	e8 00 00 00 00	 call	 _byteswap_uint64
  00312	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  00316	ff c1		 inc	 ecx
  00318	48 63 c9	 movsxd	 rcx, ecx
  0031b	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00323	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3506 : 
; 3507 : } /* end DEF_INST(convert_dfp_ext_to_sbcd128_reg) */

  0032b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00333	48 33 cc	 xor	 rcx, rsp
  00336	e8 00 00 00 00	 call	 __security_check_cookie
  0033b	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00342	c3		 ret	 0
z900_convert_dfp_ext_to_sbcd128_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv186 = 40
tv187 = 44
tv189 = 48
m3$ = 52
r2$ = 56
r1$ = 60
n1$ = 64
x2$ = 72
set$ = 80
d2$ = 112
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
z900_convert_dfp_long_to_fix64_reg PROC

; 3312 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3313 : int             r1, r2;                 /* Values of R fields        */
; 3314 : int             m3;                     /* Values of M fields        */
; 3315 : S64             n1;                     /* Result value              */
; 3316 : decimal64       x2;                     /* Long DFP value            */
; 3317 : decNumber       d2;                     /* Working decimal number    */
; 3318 : decContext      set;                    /* Working context           */
; 3319 : BYTE            dxc;                    /* Data exception code       */
; 3320 : 
; 3321 :     RRF_M(inst, regs, r1, r2, m3);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00062	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_conve
  00085	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 3322 : 
; 3323 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000a5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_conve
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_conve
  000be	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_conve
  000d1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000e7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196572
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3324 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_conve
  00154	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_conve
  0016b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00196	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 3325 : 
; 3326 :     /* Initialise the context for long DFP */
; 3327 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001c3	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001c8	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001cd	e8 00 00 00 00	 call	 decContextDefault

; 3328 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  001d2	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001da	8b 54 24 34	 mov	 edx, DWORD PTR m3$[rsp]
  001de	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001e3	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 3329 : 
; 3330 :     /* Load long DFP value from FP register r2 */
; 3331 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001e8	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f0	48 8d 54 24 48	 lea	 rdx, QWORD PTR x2$[rsp]
  001f5	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  001f9	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 3332 :     decimal64ToNumber(&x2, &d2);

  001fe	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  00203	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  00208	e8 00 00 00 00	 call	 decimal64ToNumber

; 3333 : 
; 3334 :     /* Convert decimal number to 64-bit binary integer */
; 3335 :     n1 = dfp_number_to_fix64(&d2, &set);

  0020d	48 8d 54 24 50	 lea	 rdx, QWORD PTR set$[rsp]
  00212	48 8d 4c 24 70	 lea	 rcx, QWORD PTR d2$[rsp]
  00217	e8 00 00 00 00	 call	 dfp_number_to_fix64
  0021c	48 89 44 24 40	 mov	 QWORD PTR n1$[rsp], rax

; 3336 : 
; 3337 :     /* Check for exception condition */
; 3338 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00221	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00229	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0022e	e8 00 00 00 00	 call	 z900_dfp_status_check
  00233	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3339 : 
; 3340 :     /* Load result into general register r1 */
; 3341 :     regs->GR_G(r1) = n1;

  00237	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0023c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00244	48 8b 54 24 40	 mov	 rdx, QWORD PTR n1$[rsp]
  00249	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3342 : 
; 3343 :     /* Set condition code */
; 3344 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  00251	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  00255	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  0025a	85 c0		 test	 eax, eax
  0025c	74 0a		 je	 SHORT $LN19@z900_conve
  0025e	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv189[rsp], 3
  00266	eb 5f		 jmp	 SHORT $LN20@z900_conve
$LN19@z900_conve:
  00268	b8 02 00 00 00	 mov	 eax, 2
  0026d	48 6b c0 00	 imul	 rax, rax, 0
  00271	0f b7 44 04 7a	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  00276	85 c0		 test	 eax, eax
  00278	75 1d		 jne	 SHORT $LN15@z900_conve
  0027a	83 7c 24 70 01	 cmp	 DWORD PTR d2$[rsp], 1
  0027f	75 16		 jne	 SHORT $LN15@z900_conve
  00281	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00286	83 e0 70	 and	 eax, 112		; 00000070H
  00289	85 c0		 test	 eax, eax
  0028b	75 0a		 jne	 SHORT $LN15@z900_conve
  0028d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
  00295	eb 28		 jmp	 SHORT $LN18@z900_conve
$LN15@z900_conve:
  00297	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0029c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002a1	85 c0		 test	 eax, eax
  002a3	74 0a		 je	 SHORT $LN16@z900_conve
  002a5	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv186[rsp], 1
  002ad	eb 08		 jmp	 SHORT $LN17@z900_conve
$LN16@z900_conve:
  002af	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv186[rsp], 2
$LN17@z900_conve:
  002b7	8b 44 24 28	 mov	 eax, DWORD PTR tv186[rsp]
  002bb	89 44 24 2c	 mov	 DWORD PTR tv187[rsp], eax
$LN18@z900_conve:
  002bf	8b 44 24 2c	 mov	 eax, DWORD PTR tv187[rsp]
  002c3	89 44 24 30	 mov	 DWORD PTR tv189[rsp], eax
$LN20@z900_conve:
  002c7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002cf	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv189[rsp]
  002d4	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3345 :                    decNumberIsZero(&d2) ? 0 :
; 3346 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3347 : 
; 3348 :     /* Raise data exception if error occurred */
; 3349 :     if (dxc != 0)

  002d7	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002dc	85 c0		 test	 eax, eax
  002de	74 25		 je	 SHORT $LN13@z900_conve

; 3350 :     {
; 3351 :         regs->dxc = dxc;

  002e0	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002e5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ed	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3352 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002f3	ba 07 00 00 00	 mov	 edx, 7
  002f8	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00300	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_conve:

; 3353 :     }
; 3354 : 
; 3355 : } /* end DEF_INST(convert_dfp_long_to_fix64_reg) */

  00305	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0030d	48 33 cc	 xor	 rcx, rsp
  00310	e8 00 00 00 00	 call	 __security_check_cookie
  00315	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0031c	c3		 ret	 0
z900_convert_dfp_long_to_fix64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
tv191 = 44
tv192 = 48
tv194 = 52
m3$ = 56
r1$ = 60
n1$ = 64
set$ = 72
d2$ = 104
x2$ = 144
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
z900_convert_dfp_ext_to_fix64_reg PROC

; 3261 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3262 : int             r1, r2;                 /* Values of R fields        */
; 3263 : int             m3;                     /* Values of M fields        */
; 3264 : S64             n1;                     /* Result value              */
; 3265 : decimal128      x2;                     /* Extended DFP value        */
; 3266 : decNumber       d2;                     /* Working decimal number    */
; 3267 : decContext      set;                    /* Working context           */
; 3268 : BYTE            dxc;                    /* Data exception code       */
; 3269 : 
; 3270 :     RRF_M(inst, regs, r1, r2, m3);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00062	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_conve
  00085	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 3271 : 
; 3272 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000a5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_conve
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_conve
  000be	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_conve
  000d1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000e7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196544
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3273 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_conve
  00154	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_conve
  0016b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00196	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 3274 :     DFPREGPAIR_CHECK(r2, regs);

  001c3	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001c7	83 e0 02	 and	 eax, 2
  001ca	85 c0		 test	 eax, eax
  001cc	74 1b		 je	 SHORT $LN13@z900_conve
  001ce	ba 06 00 00 00	 mov	 edx, 6
  001d3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e3	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 3275 : 
; 3276 :     /* Initialise the context for extended DFP */
; 3277 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001e9	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001ee	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001f3	e8 00 00 00 00	 call	 decContextDefault

; 3278 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  001f8	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00200	8b 54 24 38	 mov	 edx, DWORD PTR m3$[rsp]
  00204	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00209	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 3279 : 
; 3280 :     /* Load extended DFP value from FP register r2 */
; 3281 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  0020e	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00216	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  0021e	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00222	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 3282 :     decimal128ToNumber(&x2, &d2);

  00227	48 8d 54 24 68	 lea	 rdx, QWORD PTR d2$[rsp]
  0022c	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  00234	e8 00 00 00 00	 call	 decimal128ToNumber

; 3283 : 
; 3284 :     /* Convert decimal number to 64-bit binary integer */
; 3285 :     n1 = dfp_number_to_fix64(&d2, &set);

  00239	48 8d 54 24 48	 lea	 rdx, QWORD PTR set$[rsp]
  0023e	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d2$[rsp]
  00243	e8 00 00 00 00	 call	 dfp_number_to_fix64
  00248	48 89 44 24 40	 mov	 QWORD PTR n1$[rsp], rax

; 3286 : 
; 3287 :     /* Check for exception condition */
; 3288 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0024d	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00255	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  0025a	e8 00 00 00 00	 call	 z900_dfp_status_check
  0025f	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3289 : 
; 3290 :     /* Load result into general register r1 */
; 3291 :     regs->GR_G(r1) = n1;

  00263	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00268	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00270	48 8b 54 24 40	 mov	 rdx, QWORD PTR n1$[rsp]
  00275	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3292 : 
; 3293 :     /* Set condition code */
; 3294 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  0027d	8b 44 24 5c	 mov	 eax, DWORD PTR set$[rsp+20]
  00281	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  00286	85 c0		 test	 eax, eax
  00288	74 0a		 je	 SHORT $LN20@z900_conve
  0028a	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv194[rsp], 3
  00292	eb 5f		 jmp	 SHORT $LN21@z900_conve
$LN20@z900_conve:
  00294	b8 02 00 00 00	 mov	 eax, 2
  00299	48 6b c0 00	 imul	 rax, rax, 0
  0029d	0f b7 44 04 72	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  002a2	85 c0		 test	 eax, eax
  002a4	75 1d		 jne	 SHORT $LN16@z900_conve
  002a6	83 7c 24 68 01	 cmp	 DWORD PTR d2$[rsp], 1
  002ab	75 16		 jne	 SHORT $LN16@z900_conve
  002ad	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002b2	83 e0 70	 and	 eax, 112		; 00000070H
  002b5	85 c0		 test	 eax, eax
  002b7	75 0a		 jne	 SHORT $LN16@z900_conve
  002b9	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
  002c1	eb 28		 jmp	 SHORT $LN19@z900_conve
$LN16@z900_conve:
  002c3	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002c8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002cd	85 c0		 test	 eax, eax
  002cf	74 0a		 je	 SHORT $LN17@z900_conve
  002d1	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv191[rsp], 1
  002d9	eb 08		 jmp	 SHORT $LN18@z900_conve
$LN17@z900_conve:
  002db	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv191[rsp], 2
$LN18@z900_conve:
  002e3	8b 44 24 2c	 mov	 eax, DWORD PTR tv191[rsp]
  002e7	89 44 24 30	 mov	 DWORD PTR tv192[rsp], eax
$LN19@z900_conve:
  002eb	8b 44 24 30	 mov	 eax, DWORD PTR tv192[rsp]
  002ef	89 44 24 34	 mov	 DWORD PTR tv194[rsp], eax
$LN21@z900_conve:
  002f3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002fb	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv194[rsp]
  00300	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3295 :                    decNumberIsZero(&d2) ? 0 :
; 3296 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3297 : 
; 3298 :     /* Raise data exception if error occurred */
; 3299 :     if (dxc != 0)

  00303	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00308	85 c0		 test	 eax, eax
  0030a	74 25		 je	 SHORT $LN14@z900_conve

; 3300 :     {
; 3301 :         regs->dxc = dxc;

  0030c	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00311	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00319	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3302 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0031f	ba 07 00 00 00	 mov	 edx, 7
  00324	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032c	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_conve:

; 3303 :     }
; 3304 : 
; 3305 : } /* end DEF_INST(convert_dfp_ext_to_fix64_reg) */

  00331	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00339	48 33 cc	 xor	 rcx, rsp
  0033c	e8 00 00 00 00	 call	 __security_check_cookie
  00341	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00348	c3		 ret	 0
z900_convert_dfp_ext_to_fix64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
i$1 = 36
r2$ = 40
scale$ = 44
r1$ = 48
$T2 = 56
dp$ = 64
x1$ = 72
set$ = 80
dwork$ = 112
pwork$ = 152
__$ArrayPad$ = 168
inst$ = 192
regs$ = 200
z900_convert_ubcd64_to_dfp_long_reg PROC

; 2768 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2769 : unsigned        i;                      /* Array subscript           */
; 2770 : int             r1, r2;                 /* Values of R fields        */
; 2771 : decimal64       x1;                     /* Long DFP values           */
; 2772 : decNumber       dwork, *dp;             /* Working decimal numbers   */
; 2773 : decContext      set;                    /* Working context           */
; 2774 : BYTE            pwork[9];               /* 17-digit packed work area */
; 2775 : int32_t         scale = 0;              /* Scaling factor            */

  00023	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR scale$[rsp], 0

; 2776 : 
; 2777 :     RRE(inst, regs, r1, r2);

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 03	 imul	 rax, rax, 3
  00034	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00040	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0004f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00053	c1 f8 04	 sar	 eax, 4
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_conve:
  0005d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00079	33 c0		 xor	 eax, eax
  0007b	83 f8 04	 cmp	 eax, 4
  0007e	74 0f		 je	 SHORT $LN11@z900_conve
  00080	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_conve:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2778 : 
; 2779 :     TXF_FLOAT_INSTR_CHECK( regs );

  00095	33 c0		 xor	 eax, eax
  00097	83 f8 01	 cmp	 eax, 1
  0009a	0f 84 81 00 00
	00		 je	 $LN12@z900_conve
  000a0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000af	85 c0		 test	 eax, eax
  000b1	74 6e		 je	 SHORT $LN12@z900_conve
  000b3	33 c0		 xor	 eax, eax
  000b5	85 c0		 test	 eax, eax
  000b7	75 29		 jne	 SHORT $LN13@z900_conve
  000b9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c8	85 c0		 test	 eax, eax
  000ca	75 16		 jne	 SHORT $LN13@z900_conve
  000cc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000db	83 e0 04	 and	 eax, 4
  000de	85 c0		 test	 eax, eax
  000e0	75 3f		 jne	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  000e2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ea	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f0	0f ba e8 0b	 bts	 eax, 11
  000f4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00102	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196265
  00109	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0010f	ba 02 00 00 00	 mov	 edx, 2
  00114	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011c	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_conve:
  00121	33 c0		 xor	 eax, eax
  00123	85 c0		 test	 eax, eax
  00125	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2780 :     DFPINST_CHECK(regs);

  0012b	b8 08 00 00 00	 mov	 eax, 8
  00130	48 6b c0 01	 imul	 rax, rax, 1
  00134	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013c	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00144	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014a	48 85 c0	 test	 rax, rax
  0014d	74 42		 je	 SHORT $LN15@z900_conve
  0014f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015d	d1 e8		 shr	 eax, 1
  0015f	83 e0 01	 and	 eax, 1
  00162	85 c0		 test	 eax, eax
  00164	74 58		 je	 SHORT $LN14@z900_conve
  00166	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00175	b9 08 00 00 00	 mov	 ecx, 8
  0017a	48 6b c9 01	 imul	 rcx, rcx, 1
  0017e	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00186	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0018c	48 85 c0	 test	 rax, rax
  0018f	75 2d		 jne	 SHORT $LN14@z900_conve
$LN15@z900_conve:
  00191	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00199	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a3	ba 07 00 00 00	 mov	 edx, 7
  001a8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_conve:

; 2781 : 
; 2782 :     /* Initialise the context for long DFP */
; 2783 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001be	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001c3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001c8	e8 00 00 00 00	 call	 decContextDefault

; 2784 : 
; 2785 :     /* Store general register in work area */
; 2786 :     pwork[0] = 0;

  001cd	b8 01 00 00 00	 mov	 eax, 1
  001d2	48 6b c0 00	 imul	 rax, rax, 0
  001d6	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  001db	48 83 7c 24 38
	09		 cmp	 QWORD PTR $T2[rsp], 9
  001e1	73 02		 jae	 SHORT $LN18@z900_conve
  001e3	eb 05		 jmp	 SHORT $LN19@z900_conve
$LN18@z900_conve:
  001e5	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN19@z900_conve:
  001ea	48 8b 44 24 38	 mov	 rax, QWORD PTR $T2[rsp]
  001ef	c6 84 04 98 00
	00 00 00	 mov	 BYTE PTR pwork$[rsp+rax], 0

; 2787 :     STORE_DW(pwork+1, regs->GR_G(r2));

  001f7	48 63 44 24 28	 movsxd	 rax, DWORD PTR r2$[rsp]
  001fc	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00204	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  0020c	e8 00 00 00 00	 call	 _byteswap_uint64
  00211	48 8d 8c 24 99
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp+1]
  00219	48 8b d0	 mov	 rdx, rax
  0021c	e8 00 00 00 00	 call	 store_dw_noswap

; 2788 : 
; 2789 :     /* Convert unsigned BCD to signed BCD */
; 2790 :     for (i = 0; i < sizeof(pwork)-1; i++)

  00221	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00229	eb 0a		 jmp	 SHORT $LN10@z900_conve
$LN8@z900_conve:
  0022b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0022f	ff c0		 inc	 eax
  00231	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_conve:
  00235	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00239	48 83 f8 08	 cmp	 rax, 8
  0023d	73 34		 jae	 SHORT $LN9@z900_conve

; 2791 :         pwork[i] = ((pwork[i] & 0x0F) << 4) | (pwork[i+1] >> 4);

  0023f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00243	0f b6 84 04 98
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  0024b	83 e0 0f	 and	 eax, 15
  0024e	c1 e0 04	 shl	 eax, 4
  00251	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00255	ff c1		 inc	 ecx
  00257	8b c9		 mov	 ecx, ecx
  00259	0f b6 8c 0c 98
	00 00 00	 movzx	 ecx, BYTE PTR pwork$[rsp+rcx]
  00261	c1 f9 04	 sar	 ecx, 4
  00264	0b c1		 or	 eax, ecx
  00266	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0026a	88 84 0c 98 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al
  00271	eb b8		 jmp	 SHORT $LN8@z900_conve
$LN9@z900_conve:

; 2792 :     pwork[i] = ((pwork[i] & 0x0F) << 4) | 0x0F;

  00273	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00277	0f b6 84 04 98
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  0027f	83 e0 0f	 and	 eax, 15
  00282	c1 e0 04	 shl	 eax, 4
  00285	83 c8 0f	 or	 eax, 15
  00288	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0028c	88 84 0c 98 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al

; 2793 : 
; 2794 :     /* Convert signed BCD to internal number format */
; 2795 :     dp = decPackedToNumber(pwork, sizeof(pwork), &scale, &dwork);

  00293	4c 8d 4c 24 70	 lea	 r9, QWORD PTR dwork$[rsp]
  00298	4c 8d 44 24 2c	 lea	 r8, QWORD PTR scale$[rsp]
  0029d	ba 09 00 00 00	 mov	 edx, 9
  002a2	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  002aa	e8 00 00 00 00	 call	 decPackedToNumber
  002af	48 89 44 24 40	 mov	 QWORD PTR dp$[rsp], rax

; 2796 : 
; 2797 :     /* Data exception if digits or sign was invalid */
; 2798 :     if (dp == NULL)

  002b4	48 83 7c 24 40
	00		 cmp	 QWORD PTR dp$[rsp], 0
  002ba	75 24		 jne	 SHORT $LN16@z900_conve

; 2799 :     {
; 2800 :         regs->dxc = DXC_DECIMAL;

  002bc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c4	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 2801 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002ce	ba 07 00 00 00	 mov	 edx, 7
  002d3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002db	e8 00 00 00 00	 call	 z900_program_interrupt
$LN16@z900_conve:

; 2802 :     }
; 2803 : 
; 2804 :     /* Convert internal number to DFP long format */
; 2805 :     decimal64FromNumber(&x1, &dwork, &set);

  002e0	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  002e5	48 8d 54 24 70	 lea	 rdx, QWORD PTR dwork$[rsp]
  002ea	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  002ef	e8 00 00 00 00	 call	 decimal64FromNumber

; 2806 : 
; 2807 :     /* Load result into FP register r1 */
; 2808 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  002f4	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002fc	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  00301	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  00305	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64
$LN17@z900_conve:

; 2809 : 
; 2810 : } /* end DEF_INST(convert_ubcd64_to_dfp_long_reg) */

  0030a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00312	48 33 cc	 xor	 rcx, rsp
  00315	e8 00 00 00 00	 call	 __security_check_cookie
  0031a	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00321	c3		 ret	 0
z900_convert_ubcd64_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
r2$ = 36
i$1 = 40
r1$ = 44
scale$ = 48
$T2 = 56
dp$ = 64
x1$ = 72
set$ = 88
dwork$ = 120
pwork$ = 160
__$ArrayPad$ = 184
inst$ = 208
regs$ = 216
z900_convert_ubcd128_to_dfp_ext_reg PROC

; 2716 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2717 : unsigned        i;                      /* Array subscript           */
; 2718 : int             r1, r2;                 /* Values of R fields        */
; 2719 : decimal128      x1;                     /* Extended DFP values       */
; 2720 : decNumber       dwork, *dp;             /* Working decimal numbers   */
; 2721 : decContext      set;                    /* Working context           */
; 2722 : BYTE            pwork[17];              /* 33-digit packed work area */
; 2723 : int32_t         scale = 0;              /* Scaling factor            */

  00023	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR scale$[rsp], 0

; 2724 : 
; 2725 :     RRE(inst, regs, r1, r2);

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 03	 imul	 rax, rax, 3
  00034	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00040	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0004f	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00053	c1 f8 04	 sar	 eax, 4
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_conve:
  0005d	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00079	33 c0		 xor	 eax, eax
  0007b	83 f8 04	 cmp	 eax, 4
  0007e	74 0f		 je	 SHORT $LN11@z900_conve
  00080	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN11@z900_conve:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2726 : 
; 2727 :     TXF_FLOAT_INSTR_CHECK( regs );

  00095	33 c0		 xor	 eax, eax
  00097	83 f8 01	 cmp	 eax, 1
  0009a	0f 84 81 00 00
	00		 je	 $LN12@z900_conve
  000a0	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000af	85 c0		 test	 eax, eax
  000b1	74 6e		 je	 SHORT $LN12@z900_conve
  000b3	33 c0		 xor	 eax, eax
  000b5	85 c0		 test	 eax, eax
  000b7	75 29		 jne	 SHORT $LN13@z900_conve
  000b9	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c8	85 c0		 test	 eax, eax
  000ca	75 16		 jne	 SHORT $LN13@z900_conve
  000cc	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000db	83 e0 04	 and	 eax, 4
  000de	85 c0		 test	 eax, eax
  000e0	75 3f		 jne	 SHORT $LN12@z900_conve
$LN13@z900_conve:
  000e2	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ea	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f0	0f ba e8 0b	 bts	 eax, 11
  000f4	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00102	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196230
  00109	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0010f	ba 02 00 00 00	 mov	 edx, 2
  00114	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011c	e8 00 00 00 00	 call	 z900_abort_transaction
$LN12@z900_conve:
  00121	33 c0		 xor	 eax, eax
  00123	85 c0		 test	 eax, eax
  00125	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2728 :     DFPINST_CHECK(regs);

  0012b	b8 08 00 00 00	 mov	 eax, 8
  00130	48 6b c0 01	 imul	 rax, rax, 1
  00134	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013c	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00144	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014a	48 85 c0	 test	 rax, rax
  0014d	74 42		 je	 SHORT $LN15@z900_conve
  0014f	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015d	d1 e8		 shr	 eax, 1
  0015f	83 e0 01	 and	 eax, 1
  00162	85 c0		 test	 eax, eax
  00164	74 58		 je	 SHORT $LN14@z900_conve
  00166	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00175	b9 08 00 00 00	 mov	 ecx, 8
  0017a	48 6b c9 01	 imul	 rcx, rcx, 1
  0017e	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00186	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0018c	48 85 c0	 test	 rax, rax
  0018f	75 2d		 jne	 SHORT $LN14@z900_conve
$LN15@z900_conve:
  00191	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00199	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a3	ba 07 00 00 00	 mov	 edx, 7
  001a8	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_conve:

; 2729 :     DFPREGPAIR_CHECK(r1, regs);

  001be	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  001c2	83 e0 02	 and	 eax, 2
  001c5	85 c0		 test	 eax, eax
  001c7	74 1b		 je	 SHORT $LN16@z900_conve
  001c9	ba 06 00 00 00	 mov	 edx, 6
  001ce	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d6	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001de	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_conve:

; 2730 :     ODD_CHECK(r2, regs);

  001e4	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  001e8	83 e0 01	 and	 eax, 1
  001eb	85 c0		 test	 eax, eax
  001ed	74 1b		 je	 SHORT $LN17@z900_conve
  001ef	ba 06 00 00 00	 mov	 edx, 6
  001f4	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fc	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00204	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_conve:

; 2731 : 
; 2732 :     /* Initialise the context for extended DFP */
; 2733 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0020a	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0020f	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  00214	e8 00 00 00 00	 call	 decContextDefault

; 2734 : 
; 2735 :     /* Store general register pair in work area */
; 2736 :     pwork[0] = 0;

  00219	b8 01 00 00 00	 mov	 eax, 1
  0021e	48 6b c0 00	 imul	 rax, rax, 0
  00222	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  00227	48 83 7c 24 38
	11		 cmp	 QWORD PTR $T2[rsp], 17
  0022d	73 02		 jae	 SHORT $LN20@z900_conve
  0022f	eb 05		 jmp	 SHORT $LN21@z900_conve
$LN20@z900_conve:
  00231	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN21@z900_conve:
  00236	48 8b 44 24 38	 mov	 rax, QWORD PTR $T2[rsp]
  0023b	c6 84 04 a0 00
	00 00 00	 mov	 BYTE PTR pwork$[rsp+rax], 0

; 2737 :     STORE_DW(pwork+1, regs->GR_G(r2));

  00243	48 63 44 24 24	 movsxd	 rax, DWORD PTR r2$[rsp]
  00248	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00250	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00258	e8 00 00 00 00	 call	 _byteswap_uint64
  0025d	48 8d 8c 24 a1
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp+1]
  00265	48 8b d0	 mov	 rdx, rax
  00268	e8 00 00 00 00	 call	 store_dw_noswap

; 2738 :     STORE_DW(pwork+9, regs->GR_G(r2+1));

  0026d	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00271	ff c0		 inc	 eax
  00273	48 98		 cdqe
  00275	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027d	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00285	e8 00 00 00 00	 call	 _byteswap_uint64
  0028a	48 8d 8c 24 a9
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp+9]
  00292	48 8b d0	 mov	 rdx, rax
  00295	e8 00 00 00 00	 call	 store_dw_noswap

; 2739 : 
; 2740 :     /* Convert unsigned BCD to signed BCD */
; 2741 :     for (i = 0; i < sizeof(pwork)-1; i++)

  0029a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002a2	eb 0a		 jmp	 SHORT $LN10@z900_conve
$LN8@z900_conve:
  002a4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002a8	ff c0		 inc	 eax
  002aa	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_conve:
  002ae	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002b2	48 83 f8 10	 cmp	 rax, 16
  002b6	73 34		 jae	 SHORT $LN9@z900_conve

; 2742 :         pwork[i] = ((pwork[i] & 0x0F) << 4) | (pwork[i+1] >> 4);

  002b8	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002bc	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  002c4	83 e0 0f	 and	 eax, 15
  002c7	c1 e0 04	 shl	 eax, 4
  002ca	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  002ce	ff c1		 inc	 ecx
  002d0	8b c9		 mov	 ecx, ecx
  002d2	0f b6 8c 0c a0
	00 00 00	 movzx	 ecx, BYTE PTR pwork$[rsp+rcx]
  002da	c1 f9 04	 sar	 ecx, 4
  002dd	0b c1		 or	 eax, ecx
  002df	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  002e3	88 84 0c a0 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al
  002ea	eb b8		 jmp	 SHORT $LN8@z900_conve
$LN9@z900_conve:

; 2743 :     pwork[i] = ((pwork[i] & 0x0F) << 4) | 0x0F;

  002ec	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002f0	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  002f8	83 e0 0f	 and	 eax, 15
  002fb	c1 e0 04	 shl	 eax, 4
  002fe	83 c8 0f	 or	 eax, 15
  00301	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00305	88 84 0c a0 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al

; 2744 : 
; 2745 :     /* Convert signed BCD to internal number format */
; 2746 :     dp = decPackedToNumber(pwork, sizeof(pwork), &scale, &dwork);

  0030c	4c 8d 4c 24 78	 lea	 r9, QWORD PTR dwork$[rsp]
  00311	4c 8d 44 24 30	 lea	 r8, QWORD PTR scale$[rsp]
  00316	ba 11 00 00 00	 mov	 edx, 17
  0031b	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  00323	e8 00 00 00 00	 call	 decPackedToNumber
  00328	48 89 44 24 40	 mov	 QWORD PTR dp$[rsp], rax

; 2747 : 
; 2748 :     /* Data exception if digits invalid */
; 2749 :     if (dp == NULL)

  0032d	48 83 7c 24 40
	00		 cmp	 QWORD PTR dp$[rsp], 0
  00333	75 24		 jne	 SHORT $LN18@z900_conve

; 2750 :     {
; 2751 :         regs->dxc = DXC_DECIMAL;

  00335	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0033d	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 2752 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00347	ba 07 00 00 00	 mov	 edx, 7
  0034c	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00354	e8 00 00 00 00	 call	 z900_program_interrupt
$LN18@z900_conve:

; 2753 :     }
; 2754 : 
; 2755 :     /* Convert internal number to DFP extended format */
; 2756 :     decimal128FromNumber(&x1, &dwork, &set);

  00359	4c 8d 44 24 58	 lea	 r8, QWORD PTR set$[rsp]
  0035e	48 8d 54 24 78	 lea	 rdx, QWORD PTR dwork$[rsp]
  00363	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00368	e8 00 00 00 00	 call	 decimal128FromNumber

; 2757 : 
; 2758 :     /* Load result into FP register r1 */
; 2759 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  0036d	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00375	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  0037a	8b 4c 24 2c	 mov	 ecx, DWORD PTR r1$[rsp]
  0037e	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128
$LN19@z900_conve:

; 2760 : 
; 2761 : } /* end DEF_INST(convert_ubcd128_to_dfp_ext_reg) */

  00383	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0038b	48 33 cc	 xor	 rcx, rsp
  0038e	e8 00 00 00 00	 call	 __security_check_cookie
  00393	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0039a	c3		 ret	 0
z900_convert_ubcd128_to_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
scale$ = 40
r1$ = 44
dp$ = 48
x1$ = 56
set$ = 64
dwork$ = 96
pwork$ = 136
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
z900_convert_sbcd64_to_dfp_long_reg PROC

; 2674 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2675 : int             r1, r2;                 /* Values of R fields        */
; 2676 : decimal64       x1;                     /* Long DFP values           */
; 2677 : decNumber       dwork, *dp;             /* Working decimal numbers   */
; 2678 : decContext      set;                    /* Working context           */
; 2679 : BYTE            pwork[8];               /* 15-digit packed work area */
; 2680 : int32_t         scale = 0;              /* Scaling factor            */

  00023	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR scale$[rsp], 0

; 2681 : 
; 2682 :     RRE(inst, regs, r1, r2);

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 03	 imul	 rax, rax, 3
  00034	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00040	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00044	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0004f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00053	c1 f8 04	 sar	 eax, 4
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_conve:
  0005d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00079	33 c0		 xor	 eax, eax
  0007b	83 f8 04	 cmp	 eax, 4
  0007e	74 0f		 je	 SHORT $LN8@z900_conve
  00080	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2683 : 
; 2684 :     TXF_FLOAT_INSTR_CHECK( regs );

  00095	33 c0		 xor	 eax, eax
  00097	83 f8 01	 cmp	 eax, 1
  0009a	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000a0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000af	85 c0		 test	 eax, eax
  000b1	74 6e		 je	 SHORT $LN9@z900_conve
  000b3	33 c0		 xor	 eax, eax
  000b5	85 c0		 test	 eax, eax
  000b7	75 29		 jne	 SHORT $LN10@z900_conve
  000b9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c8	85 c0		 test	 eax, eax
  000ca	75 16		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000db	83 e0 04	 and	 eax, 4
  000de	85 c0		 test	 eax, eax
  000e0	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000e2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ea	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f0	0f ba e8 0b	 bts	 eax, 11
  000f4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00102	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196197
  00109	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0010f	ba 02 00 00 00	 mov	 edx, 2
  00114	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011c	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00121	33 c0		 xor	 eax, eax
  00123	85 c0		 test	 eax, eax
  00125	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2685 :     DFPINST_CHECK(regs);

  0012b	b8 08 00 00 00	 mov	 eax, 8
  00130	48 6b c0 01	 imul	 rax, rax, 1
  00134	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013c	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00144	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014a	48 85 c0	 test	 rax, rax
  0014d	74 42		 je	 SHORT $LN12@z900_conve
  0014f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015d	d1 e8		 shr	 eax, 1
  0015f	83 e0 01	 and	 eax, 1
  00162	85 c0		 test	 eax, eax
  00164	74 58		 je	 SHORT $LN11@z900_conve
  00166	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00175	b9 08 00 00 00	 mov	 ecx, 8
  0017a	48 6b c9 01	 imul	 rcx, rcx, 1
  0017e	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00186	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0018c	48 85 c0	 test	 rax, rax
  0018f	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00191	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00199	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a3	ba 07 00 00 00	 mov	 edx, 7
  001a8	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2686 : 
; 2687 :     /* Initialise the context for long DFP */
; 2688 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001be	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001c3	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  001c8	e8 00 00 00 00	 call	 decContextDefault

; 2689 : 
; 2690 :     /* Store general register in work area */
; 2691 :     STORE_DW(pwork, regs->GR_G(r2));

  001cd	48 63 44 24 24	 movsxd	 rax, DWORD PTR r2$[rsp]
  001d2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001da	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  001e2	e8 00 00 00 00	 call	 _byteswap_uint64
  001e7	48 8b d0	 mov	 rdx, rax
  001ea	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  001f2	e8 00 00 00 00	 call	 store_dw_noswap

; 2692 : 
; 2693 :     /* Convert signed BCD to internal number format */
; 2694 :     dp = decPackedToNumber(pwork, sizeof(pwork), &scale, &dwork);

  001f7	4c 8d 4c 24 60	 lea	 r9, QWORD PTR dwork$[rsp]
  001fc	4c 8d 44 24 28	 lea	 r8, QWORD PTR scale$[rsp]
  00201	ba 08 00 00 00	 mov	 edx, 8
  00206	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  0020e	e8 00 00 00 00	 call	 decPackedToNumber
  00213	48 89 44 24 30	 mov	 QWORD PTR dp$[rsp], rax

; 2695 : 
; 2696 :     /* Data exception if digits or sign was invalid */
; 2697 :     if (dp == NULL)

  00218	48 83 7c 24 30
	00		 cmp	 QWORD PTR dp$[rsp], 0
  0021e	75 24		 jne	 SHORT $LN13@z900_conve

; 2698 :     {
; 2699 :         regs->dxc = DXC_DECIMAL;

  00220	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00228	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 2700 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00232	ba 07 00 00 00	 mov	 edx, 7
  00237	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023f	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_conve:

; 2701 :     }
; 2702 : 
; 2703 :     /* Convert internal number to DFP long format */
; 2704 :     decimal64FromNumber(&x1, &dwork, &set);

  00244	4c 8d 44 24 40	 lea	 r8, QWORD PTR set$[rsp]
  00249	48 8d 54 24 60	 lea	 rdx, QWORD PTR dwork$[rsp]
  0024e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  00253	e8 00 00 00 00	 call	 decimal64FromNumber

; 2705 : 
; 2706 :     /* Load result into FP register r1 */
; 2707 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  00258	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00260	48 8d 54 24 38	 lea	 rdx, QWORD PTR x1$[rsp]
  00265	8b 4c 24 2c	 mov	 ecx, DWORD PTR r1$[rsp]
  00269	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 2708 : 
; 2709 : } /* end DEF_INST(convert_sbcd64_to_dfp_long_reg) */

  0026e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00276	48 33 cc	 xor	 rcx, rsp
  00279	e8 00 00 00 00	 call	 __security_check_cookie
  0027e	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00285	c3		 ret	 0
z900_convert_sbcd64_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
r2$ = 32
i$1 = 36
r1$ = 40
scale$ = 44
dp$ = 48
x1$ = 56
set$ = 72
dwork$ = 104
pwork$ = 144
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
z900_convert_sbcd128_to_dfp_ext_reg PROC

; 2629 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2630 : int             r1, r2;                 /* Values of R fields        */
; 2631 : decimal128      x1;                     /* Extended DFP values       */
; 2632 : decNumber       dwork, *dp;             /* Working decimal numbers   */
; 2633 : decContext      set;                    /* Working context           */
; 2634 : BYTE            pwork[16];              /* 31-digit packed work area */
; 2635 : int32_t         scale = 0;              /* Scaling factor            */

  00023	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR scale$[rsp], 0

; 2636 : 
; 2637 :     RRE(inst, regs, r1, r2);

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 03	 imul	 rax, rax, 3
  00034	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00040	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 20	 mov	 DWORD PTR r2$[rsp], eax
  0004f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00053	c1 f8 04	 sar	 eax, 4
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_conve:
  0005d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00079	33 c0		 xor	 eax, eax
  0007b	83 f8 04	 cmp	 eax, 4
  0007e	74 0f		 je	 SHORT $LN8@z900_conve
  00080	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2638 : 
; 2639 :     TXF_FLOAT_INSTR_CHECK( regs );

  00095	33 c0		 xor	 eax, eax
  00097	83 f8 01	 cmp	 eax, 1
  0009a	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000a0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000af	85 c0		 test	 eax, eax
  000b1	74 6e		 je	 SHORT $LN9@z900_conve
  000b3	33 c0		 xor	 eax, eax
  000b5	85 c0		 test	 eax, eax
  000b7	75 29		 jne	 SHORT $LN10@z900_conve
  000b9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c8	85 c0		 test	 eax, eax
  000ca	75 16		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000db	83 e0 04	 and	 eax, 4
  000de	85 c0		 test	 eax, eax
  000e0	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000e2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ea	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f0	0f ba e8 0b	 bts	 eax, 11
  000f4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00102	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196167
  00109	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0010f	ba 02 00 00 00	 mov	 edx, 2
  00114	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011c	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00121	33 c0		 xor	 eax, eax
  00123	85 c0		 test	 eax, eax
  00125	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2640 :     DFPINST_CHECK(regs);

  0012b	b8 08 00 00 00	 mov	 eax, 8
  00130	48 6b c0 01	 imul	 rax, rax, 1
  00134	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013c	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00144	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014a	48 85 c0	 test	 rax, rax
  0014d	74 42		 je	 SHORT $LN12@z900_conve
  0014f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015d	d1 e8		 shr	 eax, 1
  0015f	83 e0 01	 and	 eax, 1
  00162	85 c0		 test	 eax, eax
  00164	74 58		 je	 SHORT $LN11@z900_conve
  00166	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00175	b9 08 00 00 00	 mov	 ecx, 8
  0017a	48 6b c9 01	 imul	 rcx, rcx, 1
  0017e	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00186	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0018c	48 85 c0	 test	 rax, rax
  0018f	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00191	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00199	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a3	ba 07 00 00 00	 mov	 edx, 7
  001a8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2641 :     DFPREGPAIR_CHECK(r1, regs);

  001be	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001c2	83 e0 02	 and	 eax, 2
  001c5	85 c0		 test	 eax, eax
  001c7	74 1b		 je	 SHORT $LN13@z900_conve
  001c9	ba 06 00 00 00	 mov	 edx, 6
  001ce	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001de	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 2642 :     ODD_CHECK(r2, regs);

  001e4	8b 44 24 20	 mov	 eax, DWORD PTR r2$[rsp]
  001e8	83 e0 01	 and	 eax, 1
  001eb	85 c0		 test	 eax, eax
  001ed	74 1b		 je	 SHORT $LN14@z900_conve
  001ef	ba 06 00 00 00	 mov	 edx, 6
  001f4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00204	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_conve:

; 2643 : 
; 2644 :     /* Initialise the context for extended DFP */
; 2645 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0020a	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0020f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00214	e8 00 00 00 00	 call	 decContextDefault

; 2646 : 
; 2647 :     /* Store general register pair in work area */
; 2648 :     STORE_DW(pwork, regs->GR_G(r2));

  00219	48 63 44 24 20	 movsxd	 rax, DWORD PTR r2$[rsp]
  0021e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00226	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  0022e	e8 00 00 00 00	 call	 _byteswap_uint64
  00233	48 8b d0	 mov	 rdx, rax
  00236	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  0023e	e8 00 00 00 00	 call	 store_dw_noswap

; 2649 :     STORE_DW(pwork+8, regs->GR_G(r2+1));

  00243	8b 44 24 20	 mov	 eax, DWORD PTR r2$[rsp]
  00247	ff c0		 inc	 eax
  00249	48 98		 cdqe
  0024b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00253	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  0025b	e8 00 00 00 00	 call	 _byteswap_uint64
  00260	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp+8]
  00268	48 8b d0	 mov	 rdx, rax
  0026b	e8 00 00 00 00	 call	 store_dw_noswap

; 2650 : 
; 2651 :     /* Convert signed BCD to internal number format */
; 2652 :     dp = decPackedToNumber(pwork, sizeof(pwork), &scale, &dwork);

  00270	4c 8d 4c 24 68	 lea	 r9, QWORD PTR dwork$[rsp]
  00275	4c 8d 44 24 2c	 lea	 r8, QWORD PTR scale$[rsp]
  0027a	ba 10 00 00 00	 mov	 edx, 16
  0027f	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  00287	e8 00 00 00 00	 call	 decPackedToNumber
  0028c	48 89 44 24 30	 mov	 QWORD PTR dp$[rsp], rax

; 2653 : 
; 2654 :     /* Data exception if digits or sign was invalid */
; 2655 :     if (dp == NULL)

  00291	48 83 7c 24 30
	00		 cmp	 QWORD PTR dp$[rsp], 0
  00297	75 24		 jne	 SHORT $LN15@z900_conve

; 2656 :     {
; 2657 :         regs->dxc = DXC_DECIMAL;

  00299	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a1	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 2658 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002ab	ba 07 00 00 00	 mov	 edx, 7
  002b0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b8	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_conve:

; 2659 :     }
; 2660 : 
; 2661 :     /* Convert internal number to DFP extended format */
; 2662 :     decimal128FromNumber(&x1, &dwork, &set);

  002bd	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  002c2	48 8d 54 24 68	 lea	 rdx, QWORD PTR dwork$[rsp]
  002c7	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  002cc	e8 00 00 00 00	 call	 decimal128FromNumber

; 2663 : 
; 2664 :     /* Load result into FP register r1 */
; 2665 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  002d1	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002d9	48 8d 54 24 38	 lea	 rdx, QWORD PTR x1$[rsp]
  002de	8b 4c 24 28	 mov	 ecx, DWORD PTR r1$[rsp]
  002e2	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 2666 : 
; 2667 : } /* end DEF_INST(convert_sbcd128_to_dfp_ext_reg) */

  002e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002ef	48 33 cc	 xor	 rcx, rsp
  002f2	e8 00 00 00 00	 call	 __security_check_cookie
  002f7	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  002fe	c3		 ret	 0
z900_convert_sbcd128_to_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
n2$ = 48
x1$ = 56
set$ = 64
d1$ = 96
__$ArrayPad$ = 136
inst$ = 160
regs$ = 168
z900_convert_fix64_to_dfp_long_reg PROC

; 2510 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2511 : int             r1, r2;                 /* Values of R fields        */
; 2512 : S64             n2;                     /* Value of R2 register      */
; 2513 : decimal64       x1;                     /* Long DFP value            */
; 2514 : decNumber       d1;                     /* Working decimal number    */
; 2515 : decContext      set;                    /* Working context           */
; 2516 : BYTE            dxc;                    /* Data exception code       */
; 2517 : 
; 2518 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_conve:
  00055	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_conve
  00078	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2519 : 
; 2520 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  00098	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_conve
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_conve
  000b1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_conve
  000c4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000da	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196085
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2521 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_conve
  00147	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_conve
  0015e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00189	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2522 : 
; 2523 :     /* Initialise the context for long DFP */
; 2524 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001b6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001bb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  001c0	e8 00 00 00 00	 call	 decContextDefault

; 2525 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  001c5	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001cd	33 d2		 xor	 edx, edx
  001cf	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  001d4	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 2526 : 
; 2527 :     /* Load 64-bit binary integer value from r2 register */
; 2528 :     n2 = (S64)(regs->GR_G(r2));

  001d9	48 63 44 24 28	 movsxd	 rax, DWORD PTR r2$[rsp]
  001de	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e6	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001ee	48 89 44 24 30	 mov	 QWORD PTR n2$[rsp], rax

; 2529 : 
; 2530 :     /* Convert binary integer to long DFP format */
; 2531 :     dfp_number_from_fix64(&d1, n2, &set);

  001f3	4c 8d 44 24 40	 lea	 r8, QWORD PTR set$[rsp]
  001f8	48 8b 54 24 30	 mov	 rdx, QWORD PTR n2$[rsp]
  001fd	48 8d 4c 24 60	 lea	 rcx, QWORD PTR d1$[rsp]
  00202	e8 00 00 00 00	 call	 dfp_number_from_fix64

; 2532 :     decimal64FromNumber(&x1, &d1, &set);

  00207	4c 8d 44 24 40	 lea	 r8, QWORD PTR set$[rsp]
  0020c	48 8d 54 24 60	 lea	 rdx, QWORD PTR d1$[rsp]
  00211	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  00216	e8 00 00 00 00	 call	 decimal64FromNumber

; 2533 : 
; 2534 :     /* Check for exception condition */
; 2535 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0021b	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00223	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  00228	e8 00 00 00 00	 call	 z900_dfp_status_check
  0022d	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2536 : 
; 2537 :     /* Load result into FP register r1 */
; 2538 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  00231	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00239	48 8d 54 24 38	 lea	 rdx, QWORD PTR x1$[rsp]
  0023e	8b 4c 24 2c	 mov	 ecx, DWORD PTR r1$[rsp]
  00242	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 2539 : 
; 2540 :     /* Raise data exception if error occurred */
; 2541 :     if (dxc != 0)

  00247	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0024c	85 c0		 test	 eax, eax
  0024e	74 25		 je	 SHORT $LN13@z900_conve

; 2542 :     {
; 2543 :         regs->dxc = dxc;

  00250	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00255	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2544 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00263	ba 07 00 00 00	 mov	 edx, 7
  00268	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00270	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_conve:

; 2545 :     }
; 2546 : 
; 2547 : } /* end DEF_INST(convert_fix64_to_dfp_long_reg) */

  00275	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0027d	48 33 cc	 xor	 rcx, rsp
  00280	e8 00 00 00 00	 call	 __security_check_cookie
  00285	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0028c	c3		 ret	 0
z900_convert_fix64_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
n2$ = 48
set$ = 56
x1$ = 88
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
z900_convert_fix64_to_dfp_ext_reg PROC

; 2476 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2477 : int             r1, r2;                 /* Values of R fields        */
; 2478 : S64             n2;                     /* Value of R2 register      */
; 2479 : decimal128      x1;                     /* Extended DFP value        */
; 2480 : decNumber       d1;                     /* Working decimal number    */
; 2481 : decContext      set;                    /* Working context           */
; 2482 : 
; 2483 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_conve:
  00055	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_conve
  00078	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2484 : 
; 2485 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  00098	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_conve
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_conve
  000b1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_conve
  000c4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000da	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196058
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2486 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_conve
  00147	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_conve
  0015e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  00189	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2487 :     DFPREGPAIR_CHECK(r1, regs);

  001b6	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001ba	83 e0 02	 and	 eax, 2
  001bd	85 c0		 test	 eax, eax
  001bf	74 1b		 je	 SHORT $LN13@z900_conve
  001c1	ba 06 00 00 00	 mov	 edx, 6
  001c6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 2488 : 
; 2489 :     /* Initialise the context for extended DFP */
; 2490 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001dc	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001e1	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  001e6	e8 00 00 00 00	 call	 decContextDefault

; 2491 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  001eb	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f3	33 d2		 xor	 edx, edx
  001f5	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  001fa	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 2492 : 
; 2493 :     /* Load 64-bit binary integer value from r2 register */
; 2494 :     n2 = (S64)(regs->GR_G(r2));

  001ff	48 63 44 24 28	 movsxd	 rax, DWORD PTR r2$[rsp]
  00204	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00214	48 89 44 24 30	 mov	 QWORD PTR n2$[rsp], rax

; 2495 : 
; 2496 :     /* Convert binary integer to extended DFP format */
; 2497 :     dfp_number_from_fix64(&d1, n2, &set);

  00219	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  0021e	48 8b 54 24 30	 mov	 rdx, QWORD PTR n2$[rsp]
  00223	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  00228	e8 00 00 00 00	 call	 dfp_number_from_fix64

; 2498 :     decimal128FromNumber(&x1, &d1, &set);

  0022d	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  00232	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  00237	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  0023c	e8 00 00 00 00	 call	 decimal128FromNumber

; 2499 : 
; 2500 :     /* Load result into FP register r1 */
; 2501 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  00241	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00249	48 8d 54 24 58	 lea	 rdx, QWORD PTR x1$[rsp]
  0024e	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  00252	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 2502 : 
; 2503 : } /* end DEF_INST(convert_fix64_to_dfp_ext_reg) */

  00257	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0025f	48 33 cc	 xor	 rcx, rsp
  00262	e8 00 00 00 00	 call	 __security_check_cookie
  00267	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0026e	c3		 ret	 0
z900_convert_fix64_to_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
x1$ = 48
x2$ = 56
d2$ = 64
d1$ = 104
set$ = 144
__$ArrayPad$ = 176
inst$ = 208
regs$ = 216
z900_compare_exponent_dfp_long_reg PROC

; 2298 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2299 : int             r1, r2;                 /* Values of R fields        */
; 2300 : decimal64       x1, x2;                 /* Long DFP values           */
; 2301 : decNumber       d1, d2;                 /* Working decimal numbers   */
; 2302 : decContext      set;                    /* Working context           */
; 2303 : 
; 2304 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00055	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_compa
  00078	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_compa:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 2305 : 
; 2306 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_compa
  00098	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_compa
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_compa
  000b1	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_compa
  000c4	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000da	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195923
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_compa

; 2307 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_compa
  00147	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_compa
  0015e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_compa
$LN12@z900_compa:
  00189	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_compa:

; 2308 : 
; 2309 :     /* Initialise the context for long DFP */
; 2310 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001b6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001bb	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001c3	e8 00 00 00 00	 call	 decContextDefault

; 2311 : 
; 2312 :     /* Convert FP register values to numbers */
; 2313 :     ARCH_DEP(dfp_reg_to_decimal64)(r1, &x1, regs);

  001c8	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001d0	48 8d 54 24 30	 lea	 rdx, QWORD PTR x1$[rsp]
  001d5	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  001d9	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 2314 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001de	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e6	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  001eb	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  001ef	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 2315 :     decimal64ToNumber(&x1, &d1);

  001f4	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  001f9	48 8d 4c 24 30	 lea	 rcx, QWORD PTR x1$[rsp]
  001fe	e8 00 00 00 00	 call	 decimal64ToNumber

; 2316 :     decimal64ToNumber(&x2, &d2);

  00203	48 8d 54 24 40	 lea	 rdx, QWORD PTR d2$[rsp]
  00208	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  0020d	e8 00 00 00 00	 call	 decimal64ToNumber

; 2317 : 
; 2318 :     /* Compare exponents and set condition code */
; 2319 :     regs->psw.cc = dfp_compare_exponent(&d1, &d2);

  00212	48 8d 54 24 40	 lea	 rdx, QWORD PTR d2$[rsp]
  00217	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  0021c	e8 00 00 00 00	 call	 dfp_compare_exponent
  00221	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2320 : 
; 2321 : } /* end DEF_INST(compare_exponent_dfp_long_reg) */

  0022c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00234	48 33 cc	 xor	 rcx, rsp
  00237	e8 00 00 00 00	 call	 __security_check_cookie
  0023c	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00243	c3		 ret	 0
z900_compare_exponent_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
x1$ = 48
x2$ = 64
d2$ = 80
d1$ = 120
set$ = 160
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
z900_compare_exponent_dfp_ext_reg PROC

; 2267 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2268 : int             r1, r2;                 /* Values of R fields        */
; 2269 : decimal128      x1, x2;                 /* Extended DFP values       */
; 2270 : decNumber       d1, d2;                 /* Working decimal numbers   */
; 2271 : decContext      set;                    /* Working context           */
; 2272 : 
; 2273 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00055	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_compa
  00078	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_compa:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 2274 : 
; 2275 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_compa
  00098	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_compa
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_compa
  000b1	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_compa
  000c4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000da	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195896
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_compa

; 2276 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_compa
  00147	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_compa
  0015e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_compa
$LN12@z900_compa:
  00189	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_compa:

; 2277 :     DFPREGPAIR2_CHECK(r1, r2, regs);

  001b6	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001ba	83 e0 02	 and	 eax, 2
  001bd	85 c0		 test	 eax, eax
  001bf	75 0b		 jne	 SHORT $LN14@z900_compa
  001c1	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001c5	83 e0 02	 and	 eax, 2
  001c8	85 c0		 test	 eax, eax
  001ca	74 1b		 je	 SHORT $LN13@z900_compa
$LN14@z900_compa:
  001cc	ba 06 00 00 00	 mov	 edx, 6
  001d1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_compa:

; 2278 : 
; 2279 :     /* Initialise the context for extended DFP */
; 2280 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001e7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001ec	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001f4	e8 00 00 00 00	 call	 decContextDefault

; 2281 : 
; 2282 :     /* Convert FP register values to numbers */
; 2283 :     ARCH_DEP(dfp_reg_to_decimal128)(r1, &x1, regs);

  001f9	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00201	48 8d 54 24 30	 lea	 rdx, QWORD PTR x1$[rsp]
  00206	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  0020a	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 2284 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  0020f	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00217	48 8d 54 24 40	 lea	 rdx, QWORD PTR x2$[rsp]
  0021c	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00220	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 2285 :     decimal128ToNumber(&x1, &d1);

  00225	48 8d 54 24 78	 lea	 rdx, QWORD PTR d1$[rsp]
  0022a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR x1$[rsp]
  0022f	e8 00 00 00 00	 call	 decimal128ToNumber

; 2286 :     decimal128ToNumber(&x2, &d2);

  00234	48 8d 54 24 50	 lea	 rdx, QWORD PTR d2$[rsp]
  00239	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x2$[rsp]
  0023e	e8 00 00 00 00	 call	 decimal128ToNumber

; 2287 : 
; 2288 :     /* Compare exponents and set condition code */
; 2289 :     regs->psw.cc = dfp_compare_exponent(&d1, &d2);

  00243	48 8d 54 24 50	 lea	 rdx, QWORD PTR d2$[rsp]
  00248	48 8d 4c 24 78	 lea	 rcx, QWORD PTR d1$[rsp]
  0024d	e8 00 00 00 00	 call	 dfp_compare_exponent
  00252	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025a	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2290 : 
; 2291 : } /* end DEF_INST(compare_exponent_dfp_ext_reg) */

  0025d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00265	48 33 cc	 xor	 rcx, rsp
  00268	e8 00 00 00 00	 call	 __security_check_cookie
  0026d	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00274	c3		 ret	 0
z900_compare_exponent_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
tv187 = 40
tv188 = 44
tv189 = 48
r1$ = 52
r2$ = 56
x1$ = 64
x2$ = 72
dr$ = 80
set$ = 120
d2$ = 152
d1$ = 192
__$ArrayPad$ = 232
inst$ = 256
regs$ = 264
z900_compare_and_signal_dfp_long_reg PROC

; 2219 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2220 : int             r1, r2;                 /* Values of R fields        */
; 2221 : decimal64       x1, x2;                 /* Long DFP values           */
; 2222 : decNumber       d1, d2, dr;             /* Working decimal numbers   */
; 2223 : decContext      set;                    /* Working context           */
; 2224 : BYTE            dxc;                    /* Data exception code       */
; 2225 : 
; 2226 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00055	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_compa
  00078	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_compa:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 2227 : 
; 2228 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_compa
  00098	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_compa
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_compa
  000b1	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_compa
  000c4	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000da	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195869
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_compa

; 2229 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_compa
  00147	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_compa
  0015e	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_compa
$LN12@z900_compa:
  00189	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_compa:

; 2230 : 
; 2231 :     /* Initialise the context for long DFP */
; 2232 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001b6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001bb	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  001c0	e8 00 00 00 00	 call	 decContextDefault

; 2233 : 
; 2234 :     /* Compare FP register r1 with FP register r2 */
; 2235 :     ARCH_DEP(dfp_reg_to_decimal64)(r1, &x1, regs);

  001c5	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001cd	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  001d2	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  001d6	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 2236 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001db	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e3	48 8d 54 24 48	 lea	 rdx, QWORD PTR x2$[rsp]
  001e8	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  001ec	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 2237 :     decimal64ToNumber(&x1, &d1);

  001f1	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  001f9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  001fe	e8 00 00 00 00	 call	 decimal64ToNumber

; 2238 :     decimal64ToNumber(&x2, &d2);

  00203	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0020b	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  00210	e8 00 00 00 00	 call	 decimal64ToNumber

; 2239 :     decNumberCompare(&dr, &d1, &d2, &set);

  00215	4c 8d 4c 24 78	 lea	 r9, QWORD PTR set$[rsp]
  0021a	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR d2$[rsp]
  00222	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0022a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR dr$[rsp]
  0022f	e8 00 00 00 00	 call	 decNumberCompare

; 2240 : 
; 2241 :     /* Force signaling condition if result is a NaN */
; 2242 :     if (decNumberIsNaN(&dr))

  00234	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  00239	83 e0 30	 and	 eax, 48			; 00000030H
  0023c	85 c0		 test	 eax, eax
  0023e	74 13		 je	 SHORT $LN13@z900_compa

; 2243 :         set.status |= DEC_IEEE_854_Invalid_operation;

  00240	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR set$[rsp+20]
  00247	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  0024c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR set$[rsp+20], eax
$LN13@z900_compa:

; 2244 : 
; 2245 :     /* Check for exception condition */
; 2246 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00253	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0025b	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  00260	e8 00 00 00 00	 call	 z900_dfp_status_check
  00265	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2247 : 
; 2248 :     /* Set condition code */
; 2249 :     regs->psw.cc = decNumberIsNaN(&dr) ? 3 :

  00269	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  0026e	83 e0 30	 and	 eax, 48			; 00000030H
  00271	85 c0		 test	 eax, eax
  00273	74 0a		 je	 SHORT $LN20@z900_compa
  00275	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv189[rsp], 3
  0027d	eb 5f		 jmp	 SHORT $LN21@z900_compa
$LN20@z900_compa:
  0027f	b8 02 00 00 00	 mov	 eax, 2
  00284	48 6b c0 00	 imul	 rax, rax, 0
  00288	0f b7 44 04 5a	 movzx	 eax, WORD PTR dr$[rsp+rax+10]
  0028d	85 c0		 test	 eax, eax
  0028f	75 1d		 jne	 SHORT $LN16@z900_compa
  00291	83 7c 24 50 01	 cmp	 DWORD PTR dr$[rsp], 1
  00296	75 16		 jne	 SHORT $LN16@z900_compa
  00298	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  0029d	83 e0 70	 and	 eax, 112		; 00000070H
  002a0	85 c0		 test	 eax, eax
  002a2	75 0a		 jne	 SHORT $LN16@z900_compa
  002a4	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv188[rsp], 0
  002ac	eb 28		 jmp	 SHORT $LN19@z900_compa
$LN16@z900_compa:
  002ae	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  002b3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002b8	85 c0		 test	 eax, eax
  002ba	74 0a		 je	 SHORT $LN17@z900_compa
  002bc	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv187[rsp], 1
  002c4	eb 08		 jmp	 SHORT $LN18@z900_compa
$LN17@z900_compa:
  002c6	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv187[rsp], 2
$LN18@z900_compa:
  002ce	8b 44 24 28	 mov	 eax, DWORD PTR tv187[rsp]
  002d2	89 44 24 2c	 mov	 DWORD PTR tv188[rsp], eax
$LN19@z900_compa:
  002d6	8b 44 24 2c	 mov	 eax, DWORD PTR tv188[rsp]
  002da	89 44 24 30	 mov	 DWORD PTR tv189[rsp], eax
$LN21@z900_compa:
  002de	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e6	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv189[rsp]
  002eb	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2250 :                    decNumberIsZero(&dr) ? 0 :
; 2251 :                    decNumberIsNegative(&dr) ? 1 : 2;
; 2252 : 
; 2253 :     /* Raise data exception if error occurred */
; 2254 :     if (dxc != 0)

  002ee	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002f3	85 c0		 test	 eax, eax
  002f5	74 25		 je	 SHORT $LN14@z900_compa

; 2255 :     {
; 2256 :         regs->dxc = dxc;

  002f7	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002fc	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00304	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2257 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0030a	ba 07 00 00 00	 mov	 edx, 7
  0030f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00317	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_compa:

; 2258 :     }
; 2259 : 
; 2260 : } /* end DEF_INST(compare_and_signal_dfp_long_reg) */

  0031c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00324	48 33 cc	 xor	 rcx, rsp
  00327	e8 00 00 00 00	 call	 __security_check_cookie
  0032c	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00333	c3		 ret	 0
z900_compare_and_signal_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
tv194 = 48
tv195 = 52
tv196 = 56
dr$ = 64
set$ = 104
x1$ = 136
x2$ = 152
d2$ = 168
d1$ = 208
__$ArrayPad$ = 248
inst$ = 272
regs$ = 280
z900_compare_and_signal_dfp_ext_reg PROC

; 2170 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2171 : int             r1, r2;                 /* Values of R fields        */
; 2172 : decimal128      x1, x2;                 /* Extended DFP values       */
; 2173 : decNumber       d1, d2, dr;             /* Working decimal numbers   */
; 2174 : decContext      set;                    /* Working context           */
; 2175 : BYTE            dxc;                    /* Data exception code       */
; 2176 : 
; 2177 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00055	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_compa
  00078	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_compa:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 2178 : 
; 2179 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_compa
  00098	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_compa
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_compa
  000b1	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_compa
  000c4	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000da	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195838
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_compa

; 2180 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_compa
  00147	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_compa
  0015e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_compa
$LN12@z900_compa:
  00189	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_compa:

; 2181 :     DFPREGPAIR2_CHECK(r1, r2, regs);

  001b6	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001ba	83 e0 02	 and	 eax, 2
  001bd	85 c0		 test	 eax, eax
  001bf	75 0b		 jne	 SHORT $LN14@z900_compa
  001c1	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001c5	83 e0 02	 and	 eax, 2
  001c8	85 c0		 test	 eax, eax
  001ca	74 1b		 je	 SHORT $LN13@z900_compa
$LN14@z900_compa:
  001cc	ba 06 00 00 00	 mov	 edx, 6
  001d1	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d9	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_compa:

; 2182 : 
; 2183 :     /* Initialise the context for extended DFP */
; 2184 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001e7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001ec	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  001f1	e8 00 00 00 00	 call	 decContextDefault

; 2185 : 
; 2186 :     /* Compare FP register r1 with FP register r2 */
; 2187 :     ARCH_DEP(dfp_reg_to_decimal128)(r1, &x1, regs);

  001f6	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001fe	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR x1$[rsp]
  00206	8b 4c 24 28	 mov	 ecx, DWORD PTR r1$[rsp]
  0020a	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 2188 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  0020f	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00217	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  0021f	8b 4c 24 2c	 mov	 ecx, DWORD PTR r2$[rsp]
  00223	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 2189 :     decimal128ToNumber(&x1, &d1);

  00228	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00230	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR x1$[rsp]
  00238	e8 00 00 00 00	 call	 decimal128ToNumber

; 2190 :     decimal128ToNumber(&x2, &d2);

  0023d	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00245	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  0024d	e8 00 00 00 00	 call	 decimal128ToNumber

; 2191 :     decNumberCompare(&dr, &d1, &d2, &set);

  00252	4c 8d 4c 24 68	 lea	 r9, QWORD PTR set$[rsp]
  00257	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR d2$[rsp]
  0025f	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00267	48 8d 4c 24 40	 lea	 rcx, QWORD PTR dr$[rsp]
  0026c	e8 00 00 00 00	 call	 decNumberCompare

; 2192 : 
; 2193 :     /* Force signaling condition if result is a NaN */
; 2194 :     if (decNumberIsNaN(&dr))

  00271	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  00276	83 e0 30	 and	 eax, 48			; 00000030H
  00279	85 c0		 test	 eax, eax
  0027b	74 0d		 je	 SHORT $LN15@z900_compa

; 2195 :         set.status |= DEC_IEEE_854_Invalid_operation;

  0027d	8b 44 24 7c	 mov	 eax, DWORD PTR set$[rsp+20]
  00281	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00286	89 44 24 7c	 mov	 DWORD PTR set$[rsp+20], eax
$LN15@z900_compa:

; 2196 : 
; 2197 :     /* Check for exception condition */
; 2198 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0028a	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00292	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00297	e8 00 00 00 00	 call	 z900_dfp_status_check
  0029c	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2199 : 
; 2200 :     /* Set condition code */
; 2201 :     regs->psw.cc = decNumberIsNaN(&dr) ? 3 :

  002a0	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  002a5	83 e0 30	 and	 eax, 48			; 00000030H
  002a8	85 c0		 test	 eax, eax
  002aa	74 0a		 je	 SHORT $LN22@z900_compa
  002ac	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv196[rsp], 3
  002b4	eb 5f		 jmp	 SHORT $LN23@z900_compa
$LN22@z900_compa:
  002b6	b8 02 00 00 00	 mov	 eax, 2
  002bb	48 6b c0 00	 imul	 rax, rax, 0
  002bf	0f b7 44 04 4a	 movzx	 eax, WORD PTR dr$[rsp+rax+10]
  002c4	85 c0		 test	 eax, eax
  002c6	75 1d		 jne	 SHORT $LN18@z900_compa
  002c8	83 7c 24 40 01	 cmp	 DWORD PTR dr$[rsp], 1
  002cd	75 16		 jne	 SHORT $LN18@z900_compa
  002cf	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  002d4	83 e0 70	 and	 eax, 112		; 00000070H
  002d7	85 c0		 test	 eax, eax
  002d9	75 0a		 jne	 SHORT $LN18@z900_compa
  002db	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv195[rsp], 0
  002e3	eb 28		 jmp	 SHORT $LN21@z900_compa
$LN18@z900_compa:
  002e5	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  002ea	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002ef	85 c0		 test	 eax, eax
  002f1	74 0a		 je	 SHORT $LN19@z900_compa
  002f3	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
  002fb	eb 08		 jmp	 SHORT $LN20@z900_compa
$LN19@z900_compa:
  002fd	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv194[rsp], 2
$LN20@z900_compa:
  00305	8b 44 24 30	 mov	 eax, DWORD PTR tv194[rsp]
  00309	89 44 24 34	 mov	 DWORD PTR tv195[rsp], eax
$LN21@z900_compa:
  0030d	8b 44 24 34	 mov	 eax, DWORD PTR tv195[rsp]
  00311	89 44 24 38	 mov	 DWORD PTR tv196[rsp], eax
$LN23@z900_compa:
  00315	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0031d	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv196[rsp]
  00322	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2202 :                    decNumberIsZero(&dr) ? 0 :
; 2203 :                    decNumberIsNegative(&dr) ? 1 : 2;
; 2204 : 
; 2205 :     /* Raise data exception if error occurred */
; 2206 :     if (dxc != 0)

  00325	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0032a	85 c0		 test	 eax, eax
  0032c	74 25		 je	 SHORT $LN16@z900_compa

; 2207 :     {
; 2208 :         regs->dxc = dxc;

  0032e	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00333	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033b	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2209 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00341	ba 07 00 00 00	 mov	 edx, 7
  00346	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034e	e8 00 00 00 00	 call	 z900_program_interrupt
$LN16@z900_compa:

; 2210 :     }
; 2211 : 
; 2212 : } /* end DEF_INST(compare_and_signal_dfp_ext_reg) */

  00353	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0035b	48 33 cc	 xor	 rcx, rsp
  0035e	e8 00 00 00 00	 call	 __security_check_cookie
  00363	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  0036a	c3		 ret	 0
z900_compare_and_signal_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
tv183 = 40
tv184 = 44
tv185 = 48
r1$ = 52
r2$ = 56
x1$ = 64
x2$ = 72
dr$ = 80
set$ = 120
d2$ = 152
d1$ = 192
__$ArrayPad$ = 232
inst$ = 256
regs$ = 264
z900_compare_dfp_long_reg PROC

; 2126 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2127 : int             r1, r2;                 /* Values of R fields        */
; 2128 : decimal64       x1, x2;                 /* Long DFP values           */
; 2129 : decNumber       d1, d2, dr;             /* Working decimal numbers   */
; 2130 : decContext      set;                    /* Working context           */
; 2131 : BYTE            dxc;                    /* Data exception code       */
; 2132 : 
; 2133 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00055	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_compa
  00078	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_compa:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 2134 : 
; 2135 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_compa
  00098	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_compa
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_compa
  000b1	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_compa
  000c4	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000da	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195810
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_compa

; 2136 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_compa
  00147	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_compa
  0015e	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_compa
$LN12@z900_compa:
  00189	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_compa:

; 2137 : 
; 2138 :     /* Initialise the context for long DFP */
; 2139 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001b6	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001bb	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  001c0	e8 00 00 00 00	 call	 decContextDefault

; 2140 : 
; 2141 :     /* Compare FP register r1 with FP register r2 */
; 2142 :     ARCH_DEP(dfp_reg_to_decimal64)(r1, &x1, regs);

  001c5	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001cd	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  001d2	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  001d6	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 2143 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001db	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e3	48 8d 54 24 48	 lea	 rdx, QWORD PTR x2$[rsp]
  001e8	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  001ec	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 2144 :     decimal64ToNumber(&x1, &d1);

  001f1	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  001f9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  001fe	e8 00 00 00 00	 call	 decimal64ToNumber

; 2145 :     decimal64ToNumber(&x2, &d2);

  00203	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0020b	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  00210	e8 00 00 00 00	 call	 decimal64ToNumber

; 2146 :     decNumberCompare(&dr, &d1, &d2, &set);

  00215	4c 8d 4c 24 78	 lea	 r9, QWORD PTR set$[rsp]
  0021a	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR d2$[rsp]
  00222	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0022a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR dr$[rsp]
  0022f	e8 00 00 00 00	 call	 decNumberCompare

; 2147 : 
; 2148 :     /* Check for exception condition */
; 2149 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00234	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0023c	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  00241	e8 00 00 00 00	 call	 z900_dfp_status_check
  00246	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2150 : 
; 2151 :     /* Set condition code */
; 2152 :     regs->psw.cc = decNumberIsNaN(&dr) ? 3 :

  0024a	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  0024f	83 e0 30	 and	 eax, 48			; 00000030H
  00252	85 c0		 test	 eax, eax
  00254	74 0a		 je	 SHORT $LN19@z900_compa
  00256	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv185[rsp], 3
  0025e	eb 5f		 jmp	 SHORT $LN20@z900_compa
$LN19@z900_compa:
  00260	b8 02 00 00 00	 mov	 eax, 2
  00265	48 6b c0 00	 imul	 rax, rax, 0
  00269	0f b7 44 04 5a	 movzx	 eax, WORD PTR dr$[rsp+rax+10]
  0026e	85 c0		 test	 eax, eax
  00270	75 1d		 jne	 SHORT $LN15@z900_compa
  00272	83 7c 24 50 01	 cmp	 DWORD PTR dr$[rsp], 1
  00277	75 16		 jne	 SHORT $LN15@z900_compa
  00279	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  0027e	83 e0 70	 and	 eax, 112		; 00000070H
  00281	85 c0		 test	 eax, eax
  00283	75 0a		 jne	 SHORT $LN15@z900_compa
  00285	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv184[rsp], 0
  0028d	eb 28		 jmp	 SHORT $LN18@z900_compa
$LN15@z900_compa:
  0028f	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  00294	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00299	85 c0		 test	 eax, eax
  0029b	74 0a		 je	 SHORT $LN16@z900_compa
  0029d	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv183[rsp], 1
  002a5	eb 08		 jmp	 SHORT $LN17@z900_compa
$LN16@z900_compa:
  002a7	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv183[rsp], 2
$LN17@z900_compa:
  002af	8b 44 24 28	 mov	 eax, DWORD PTR tv183[rsp]
  002b3	89 44 24 2c	 mov	 DWORD PTR tv184[rsp], eax
$LN18@z900_compa:
  002b7	8b 44 24 2c	 mov	 eax, DWORD PTR tv184[rsp]
  002bb	89 44 24 30	 mov	 DWORD PTR tv185[rsp], eax
$LN20@z900_compa:
  002bf	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c7	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv185[rsp]
  002cc	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2153 :                    decNumberIsZero(&dr) ? 0 :
; 2154 :                    decNumberIsNegative(&dr) ? 1 : 2;
; 2155 : 
; 2156 :     /* Raise data exception if error occurred */
; 2157 :     if (dxc != 0)

  002cf	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002d4	85 c0		 test	 eax, eax
  002d6	74 25		 je	 SHORT $LN13@z900_compa

; 2158 :     {
; 2159 :         regs->dxc = dxc;

  002d8	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002dd	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e5	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2160 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002eb	ba 07 00 00 00	 mov	 edx, 7
  002f0	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f8	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_compa:

; 2161 :     }
; 2162 : 
; 2163 : } /* end DEF_INST(compare_dfp_long_reg) */

  002fd	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00305	48 33 cc	 xor	 rcx, rsp
  00308	e8 00 00 00 00	 call	 __security_check_cookie
  0030d	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00314	c3		 ret	 0
z900_compare_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
tv190 = 48
tv191 = 52
tv192 = 56
dr$ = 64
x1$ = 104
x2$ = 120
set$ = 136
d2$ = 168
d1$ = 208
__$ArrayPad$ = 248
inst$ = 272
regs$ = 280
z900_compare_dfp_ext_reg PROC

; 2081 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2082 : int             r1, r2;                 /* Values of R fields        */
; 2083 : decimal128      x1, x2;                 /* Extended DFP values       */
; 2084 : decNumber       d1, d2, dr;             /* Working decimal numbers   */
; 2085 : decContext      set;                    /* Working context           */
; 2086 : BYTE            dxc;                    /* Data exception code       */
; 2087 : 
; 2088 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_compa:
  00055	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@z900_compa
  00078	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_compa:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_compa
$LN7@z900_compa:

; 2089 : 
; 2090 :     TXF_FLOAT_INSTR_CHECK( regs );

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	0f 84 81 00 00
	00		 je	 $LN9@z900_compa
  00098	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000a7	85 c0		 test	 eax, eax
  000a9	74 6e		 je	 SHORT $LN9@z900_compa
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 29		 jne	 SHORT $LN10@z900_compa
  000b1	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c0	85 c0		 test	 eax, eax
  000c2	75 16		 jne	 SHORT $LN10@z900_compa
  000c4	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	75 3f		 jne	 SHORT $LN9@z900_compa
$LN10@z900_compa:
  000da	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000e8	0f ba e8 0b	 bts	 eax, 11
  000ec	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195780
  00101	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00107	ba 02 00 00 00	 mov	 edx, 2
  0010c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_compa:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_compa

; 2091 :     DFPINST_CHECK(regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00142	48 85 c0	 test	 rax, rax
  00145	74 42		 je	 SHORT $LN12@z900_compa
  00147	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00155	d1 e8		 shr	 eax, 1
  00157	83 e0 01	 and	 eax, 1
  0015a	85 c0		 test	 eax, eax
  0015c	74 58		 je	 SHORT $LN11@z900_compa
  0015e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	b9 08 00 00 00	 mov	 ecx, 8
  00172	48 6b c9 01	 imul	 rcx, rcx, 1
  00176	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	75 2d		 jne	 SHORT $LN11@z900_compa
$LN12@z900_compa:
  00189	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00191	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0019b	ba 07 00 00 00	 mov	 edx, 7
  001a0	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_compa:

; 2092 :     DFPREGPAIR2_CHECK(r1, r2, regs);

  001b6	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001ba	83 e0 02	 and	 eax, 2
  001bd	85 c0		 test	 eax, eax
  001bf	75 0b		 jne	 SHORT $LN14@z900_compa
  001c1	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001c5	83 e0 02	 and	 eax, 2
  001c8	85 c0		 test	 eax, eax
  001ca	74 1b		 je	 SHORT $LN13@z900_compa
$LN14@z900_compa:
  001cc	ba 06 00 00 00	 mov	 edx, 6
  001d1	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d9	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_compa:

; 2093 : 
; 2094 :     /* Initialise the context for extended DFP */
; 2095 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001e7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001ec	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001f4	e8 00 00 00 00	 call	 decContextDefault

; 2096 : 
; 2097 :     /* Compare FP register r1 with FP register r2 */
; 2098 :     ARCH_DEP(dfp_reg_to_decimal128)(r1, &x1, regs);

  001f9	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00201	48 8d 54 24 68	 lea	 rdx, QWORD PTR x1$[rsp]
  00206	8b 4c 24 28	 mov	 ecx, DWORD PTR r1$[rsp]
  0020a	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 2099 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  0020f	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00217	48 8d 54 24 78	 lea	 rdx, QWORD PTR x2$[rsp]
  0021c	8b 4c 24 2c	 mov	 ecx, DWORD PTR r2$[rsp]
  00220	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 2100 :     decimal128ToNumber(&x1, &d1);

  00225	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0022d	48 8d 4c 24 68	 lea	 rcx, QWORD PTR x1$[rsp]
  00232	e8 00 00 00 00	 call	 decimal128ToNumber

; 2101 :     decimal128ToNumber(&x2, &d2);

  00237	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0023f	48 8d 4c 24 78	 lea	 rcx, QWORD PTR x2$[rsp]
  00244	e8 00 00 00 00	 call	 decimal128ToNumber

; 2102 :     decNumberCompare(&dr, &d1, &d2, &set);

  00249	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR set$[rsp]
  00251	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR d2$[rsp]
  00259	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00261	48 8d 4c 24 40	 lea	 rcx, QWORD PTR dr$[rsp]
  00266	e8 00 00 00 00	 call	 decNumberCompare

; 2103 : 
; 2104 :     /* Check for exception condition */
; 2105 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0026b	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00273	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  0027b	e8 00 00 00 00	 call	 z900_dfp_status_check
  00280	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2106 : 
; 2107 :     /* Set condition code */
; 2108 :     regs->psw.cc = decNumberIsNaN(&dr) ? 3 :

  00284	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  00289	83 e0 30	 and	 eax, 48			; 00000030H
  0028c	85 c0		 test	 eax, eax
  0028e	74 0a		 je	 SHORT $LN21@z900_compa
  00290	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv192[rsp], 3
  00298	eb 5f		 jmp	 SHORT $LN22@z900_compa
$LN21@z900_compa:
  0029a	b8 02 00 00 00	 mov	 eax, 2
  0029f	48 6b c0 00	 imul	 rax, rax, 0
  002a3	0f b7 44 04 4a	 movzx	 eax, WORD PTR dr$[rsp+rax+10]
  002a8	85 c0		 test	 eax, eax
  002aa	75 1d		 jne	 SHORT $LN17@z900_compa
  002ac	83 7c 24 40 01	 cmp	 DWORD PTR dr$[rsp], 1
  002b1	75 16		 jne	 SHORT $LN17@z900_compa
  002b3	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  002b8	83 e0 70	 and	 eax, 112		; 00000070H
  002bb	85 c0		 test	 eax, eax
  002bd	75 0a		 jne	 SHORT $LN17@z900_compa
  002bf	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv191[rsp], 0
  002c7	eb 28		 jmp	 SHORT $LN20@z900_compa
$LN17@z900_compa:
  002c9	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  002ce	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002d3	85 c0		 test	 eax, eax
  002d5	74 0a		 je	 SHORT $LN18@z900_compa
  002d7	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv190[rsp], 1
  002df	eb 08		 jmp	 SHORT $LN19@z900_compa
$LN18@z900_compa:
  002e1	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv190[rsp], 2
$LN19@z900_compa:
  002e9	8b 44 24 30	 mov	 eax, DWORD PTR tv190[rsp]
  002ed	89 44 24 34	 mov	 DWORD PTR tv191[rsp], eax
$LN20@z900_compa:
  002f1	8b 44 24 34	 mov	 eax, DWORD PTR tv191[rsp]
  002f5	89 44 24 38	 mov	 DWORD PTR tv192[rsp], eax
$LN22@z900_compa:
  002f9	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00301	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv192[rsp]
  00306	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2109 :                    decNumberIsZero(&dr) ? 0 :
; 2110 :                    decNumberIsNegative(&dr) ? 1 : 2;
; 2111 : 
; 2112 :     /* Raise data exception if error occurred */
; 2113 :     if (dxc != 0)

  00309	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0030e	85 c0		 test	 eax, eax
  00310	74 25		 je	 SHORT $LN15@z900_compa

; 2114 :     {
; 2115 :         regs->dxc = dxc;

  00312	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00317	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031f	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2116 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00325	ba 07 00 00 00	 mov	 edx, 7
  0032a	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00332	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_compa:

; 2117 :     }
; 2118 : 
; 2119 : } /* end DEF_INST(compare_dfp_ext_reg) */

  00337	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0033f	48 33 cc	 xor	 rcx, rsp
  00342	e8 00 00 00 00	 call	 __security_check_cookie
  00347	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  0034e	c3		 ret	 0
z900_compare_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv195 = 40
tv196 = 44
tv197 = 48
r2$ = 52
r3$ = 56
r1$ = 60
x2$ = 64
x3$ = 72
x1$ = 80
d1$ = 88
set$ = 128
d3$ = 160
d2$ = 200
__$ArrayPad$ = 240
inst$ = 272
regs$ = 280
z900_add_dfp_long_reg PROC

; 2032 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2033 : int             r1, r2, r3;             /* Values of R fields        */
; 2034 : decimal64       x1, x2, x3;             /* Long DFP values           */
; 2035 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 2036 : decContext      set;                    /* Working context           */
; 2037 : BYTE            dxc;                    /* Data exception code       */
; 2038 : 
; 2039 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_add_d:
  00062	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_add_d
  00085	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_add_d:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_add_d
$LN7@z900_add_d:

; 2040 : 
; 2041 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_add_d
  000a5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_add_d
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_add_d
  000be	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_add_d
  000d1	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_add_d
$LN10@z900_add_d:
  000e7	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195752
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_add_d:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_add_d

; 2042 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_add_d
  00154	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_add_d
  0016b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_add_d
$LN12@z900_add_d:
  00196	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_add_d:

; 2043 : 
; 2044 :     /* Initialise the context for long DFP */
; 2045 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001c3	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001c8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001d0	e8 00 00 00 00	 call	 decContextDefault

; 2046 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  001d5	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001dd	33 d2		 xor	 edx, edx
  001df	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001e7	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 2047 : 
; 2048 :     /* Add FP register r3 to FP register r2 */
; 2049 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001ec	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f4	48 8d 54 24 40	 lea	 rdx, QWORD PTR x2$[rsp]
  001f9	8b 4c 24 34	 mov	 ecx, DWORD PTR r2$[rsp]
  001fd	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 2050 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  00202	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020a	48 8d 54 24 48	 lea	 rdx, QWORD PTR x3$[rsp]
  0020f	8b 4c 24 38	 mov	 ecx, DWORD PTR r3$[rsp]
  00213	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 2051 :     decimal64ToNumber(&x2, &d2);

  00218	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00220	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x2$[rsp]
  00225	e8 00 00 00 00	 call	 decimal64ToNumber

; 2052 :     decimal64ToNumber(&x3, &d3);

  0022a	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  00232	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x3$[rsp]
  00237	e8 00 00 00 00	 call	 decimal64ToNumber

; 2053 :     decNumberAdd(&d1, &d2, &d3, &set);

  0023c	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR set$[rsp]
  00244	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  0024c	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00254	48 8d 4c 24 58	 lea	 rcx, QWORD PTR d1$[rsp]
  00259	e8 00 00 00 00	 call	 decNumberAdd

; 2054 :     decimal64FromNumber(&x1, &d1, &set);

  0025e	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  00266	48 8d 54 24 58	 lea	 rdx, QWORD PTR d1$[rsp]
  0026b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  00270	e8 00 00 00 00	 call	 decimal64FromNumber

; 2055 : 
; 2056 :     /* Check for exception condition */
; 2057 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00275	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0027d	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00285	e8 00 00 00 00	 call	 z900_dfp_status_check
  0028a	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2058 : 
; 2059 :     /* Load result into FP register r1 */
; 2060 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  0028e	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00296	48 8d 54 24 50	 lea	 rdx, QWORD PTR x1$[rsp]
  0029b	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  0029f	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 2061 : 
; 2062 :     /* Set condition code */
; 2063 :     regs->psw.cc = decNumberIsNaN(&d1) ? 3 :

  002a4	0f b6 44 24 60	 movzx	 eax, BYTE PTR d1$[rsp+8]
  002a9	83 e0 30	 and	 eax, 48			; 00000030H
  002ac	85 c0		 test	 eax, eax
  002ae	74 0a		 je	 SHORT $LN19@z900_add_d
  002b0	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv197[rsp], 3
  002b8	eb 5f		 jmp	 SHORT $LN20@z900_add_d
$LN19@z900_add_d:
  002ba	b8 02 00 00 00	 mov	 eax, 2
  002bf	48 6b c0 00	 imul	 rax, rax, 0
  002c3	0f b7 44 04 62	 movzx	 eax, WORD PTR d1$[rsp+rax+10]
  002c8	85 c0		 test	 eax, eax
  002ca	75 1d		 jne	 SHORT $LN15@z900_add_d
  002cc	83 7c 24 58 01	 cmp	 DWORD PTR d1$[rsp], 1
  002d1	75 16		 jne	 SHORT $LN15@z900_add_d
  002d3	0f b6 44 24 60	 movzx	 eax, BYTE PTR d1$[rsp+8]
  002d8	83 e0 70	 and	 eax, 112		; 00000070H
  002db	85 c0		 test	 eax, eax
  002dd	75 0a		 jne	 SHORT $LN15@z900_add_d
  002df	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv196[rsp], 0
  002e7	eb 28		 jmp	 SHORT $LN18@z900_add_d
$LN15@z900_add_d:
  002e9	0f b6 44 24 60	 movzx	 eax, BYTE PTR d1$[rsp+8]
  002ee	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002f3	85 c0		 test	 eax, eax
  002f5	74 0a		 je	 SHORT $LN16@z900_add_d
  002f7	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv195[rsp], 1
  002ff	eb 08		 jmp	 SHORT $LN17@z900_add_d
$LN16@z900_add_d:
  00301	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv195[rsp], 2
$LN17@z900_add_d:
  00309	8b 44 24 28	 mov	 eax, DWORD PTR tv195[rsp]
  0030d	89 44 24 2c	 mov	 DWORD PTR tv196[rsp], eax
$LN18@z900_add_d:
  00311	8b 44 24 2c	 mov	 eax, DWORD PTR tv196[rsp]
  00315	89 44 24 30	 mov	 DWORD PTR tv197[rsp], eax
$LN20@z900_add_d:
  00319	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00321	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv197[rsp]
  00326	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2064 :                    decNumberIsZero(&d1) ? 0 :
; 2065 :                    decNumberIsNegative(&d1) ? 1 : 2;
; 2066 : 
; 2067 :     /* Raise data exception if error occurred */
; 2068 :     if (dxc != 0)

  00329	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0032e	85 c0		 test	 eax, eax
  00330	74 25		 je	 SHORT $LN13@z900_add_d

; 2069 :     {
; 2070 :         regs->dxc = dxc;

  00332	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00337	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033f	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2071 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00345	ba 07 00 00 00	 mov	 edx, 7
  0034a	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00352	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_add_d:

; 2072 :     }
; 2073 : 
; 2074 : } /* end DEF_INST(add_dfp_long_reg) */

  00357	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0035f	48 33 cc	 xor	 rcx, rsp
  00362	e8 00 00 00 00	 call	 __security_check_cookie
  00367	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  0036e	c3		 ret	 0
z900_add_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
tv204 = 52
tv205 = 56
tv206 = 60
d1$ = 64
set$ = 104
x2$ = 136
x3$ = 152
x1$ = 168
d3$ = 184
d2$ = 224
__$ArrayPad$ = 264
inst$ = 288
regs$ = 296
z900_add_dfp_ext_reg PROC

; 1982 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1983 : int             r1, r2, r3;             /* Values of R fields        */
; 1984 : decimal128      x1, x2, x3;             /* Extended DFP values       */
; 1985 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 1986 : decContext      set;                    /* Working context           */
; 1987 : BYTE            dxc;                    /* Data exception code       */
; 1988 : 
; 1989 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_add_d:
  00062	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN8@z900_add_d
  00085	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_add_d:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@z900_add_d
$LN7@z900_add_d:

; 1990 : 
; 1991 :     TXF_FLOAT_INSTR_CHECK( regs );

  0009a	33 c0		 xor	 eax, eax
  0009c	83 f8 01	 cmp	 eax, 1
  0009f	0f 84 81 00 00
	00		 je	 $LN9@z900_add_d
  000a5	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b4	85 c0		 test	 eax, eax
  000b6	74 6e		 je	 SHORT $LN9@z900_add_d
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 29		 jne	 SHORT $LN10@z900_add_d
  000be	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cd	85 c0		 test	 eax, eax
  000cf	75 16		 jne	 SHORT $LN10@z900_add_d
  000d1	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000e0	83 e0 04	 and	 eax, 4
  000e3	85 c0		 test	 eax, eax
  000e5	75 3f		 jne	 SHORT $LN9@z900_add_d
$LN10@z900_add_d:
  000e7	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000f5	0f ba e8 0b	 bts	 eax, 11
  000f9	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00107	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195720
  0010e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00114	ba 02 00 00 00	 mov	 edx, 2
  00119	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_add_d:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_add_d

; 1992 :     DFPINST_CHECK(regs);

  00130	b8 08 00 00 00	 mov	 eax, 8
  00135	48 6b c0 01	 imul	 rax, rax, 1
  00139	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00149	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0014f	48 85 c0	 test	 rax, rax
  00152	74 42		 je	 SHORT $LN12@z900_add_d
  00154	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00162	d1 e8		 shr	 eax, 1
  00164	83 e0 01	 and	 eax, 1
  00167	85 c0		 test	 eax, eax
  00169	74 58		 je	 SHORT $LN11@z900_add_d
  0016b	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0017a	b9 08 00 00 00	 mov	 ecx, 8
  0017f	48 6b c9 01	 imul	 rcx, rcx, 1
  00183	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0018b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00191	48 85 c0	 test	 rax, rax
  00194	75 2d		 jne	 SHORT $LN11@z900_add_d
$LN12@z900_add_d:
  00196	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001a8	ba 07 00 00 00	 mov	 edx, 7
  001ad	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_add_d:

; 1993 :     DFPREGPAIR3_CHECK(r1, r2, r3, regs);

  001c3	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  001c7	83 e0 02	 and	 eax, 2
  001ca	85 c0		 test	 eax, eax
  001cc	75 16		 jne	 SHORT $LN14@z900_add_d
  001ce	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001d2	83 e0 02	 and	 eax, 2
  001d5	85 c0		 test	 eax, eax
  001d7	75 0b		 jne	 SHORT $LN14@z900_add_d
  001d9	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  001dd	83 e0 02	 and	 eax, 2
  001e0	85 c0		 test	 eax, eax
  001e2	74 1b		 je	 SHORT $LN13@z900_add_d
$LN14@z900_add_d:
  001e4	ba 06 00 00 00	 mov	 edx, 6
  001e9	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f1	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_add_d:

; 1994 : 
; 1995 :     /* Initialise the context for extended DFP */
; 1996 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001ff	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00204	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00209	e8 00 00 00 00	 call	 decContextDefault

; 1997 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  0020e	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00216	33 d2		 xor	 edx, edx
  00218	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  0021d	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 1998 : 
; 1999 :     /* Add FP register r3 to FP register r2 */
; 2000 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00222	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0022a	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  00232	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00236	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 2001 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  0023b	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00243	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR x3$[rsp]
  0024b	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  0024f	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 2002 :     decimal128ToNumber(&x2, &d2);

  00254	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0025c	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  00264	e8 00 00 00 00	 call	 decimal128ToNumber

; 2003 :     decimal128ToNumber(&x3, &d3);

  00269	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  00271	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR x3$[rsp]
  00279	e8 00 00 00 00	 call	 decimal128ToNumber

; 2004 :     decNumberAdd(&d1, &d2, &d3, &set);

  0027e	4c 8d 4c 24 68	 lea	 r9, QWORD PTR set$[rsp]
  00283	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  0028b	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00293	48 8d 4c 24 40	 lea	 rcx, QWORD PTR d1$[rsp]
  00298	e8 00 00 00 00	 call	 decNumberAdd

; 2005 :     decimal128FromNumber(&x1, &d1, &set);

  0029d	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  002a2	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  002a7	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR x1$[rsp]
  002af	e8 00 00 00 00	 call	 decimal128FromNumber

; 2006 : 
; 2007 :     /* Check for exception condition */
; 2008 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  002b4	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002bc	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  002c1	e8 00 00 00 00	 call	 z900_dfp_status_check
  002c6	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2009 : 
; 2010 :     /* Load result into FP register r1 */
; 2011 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  002ca	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002d2	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR x1$[rsp]
  002da	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  002de	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 2012 : 
; 2013 :     /* Set condition code */
; 2014 :     regs->psw.cc = decNumberIsNaN(&d1) ? 3 :

  002e3	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  002e8	83 e0 30	 and	 eax, 48			; 00000030H
  002eb	85 c0		 test	 eax, eax
  002ed	74 0a		 je	 SHORT $LN21@z900_add_d
  002ef	c7 44 24 3c 03
	00 00 00	 mov	 DWORD PTR tv206[rsp], 3
  002f7	eb 5f		 jmp	 SHORT $LN22@z900_add_d
$LN21@z900_add_d:
  002f9	b8 02 00 00 00	 mov	 eax, 2
  002fe	48 6b c0 00	 imul	 rax, rax, 0
  00302	0f b7 44 04 4a	 movzx	 eax, WORD PTR d1$[rsp+rax+10]
  00307	85 c0		 test	 eax, eax
  00309	75 1d		 jne	 SHORT $LN17@z900_add_d
  0030b	83 7c 24 40 01	 cmp	 DWORD PTR d1$[rsp], 1
  00310	75 16		 jne	 SHORT $LN17@z900_add_d
  00312	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  00317	83 e0 70	 and	 eax, 112		; 00000070H
  0031a	85 c0		 test	 eax, eax
  0031c	75 0a		 jne	 SHORT $LN17@z900_add_d
  0031e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv205[rsp], 0
  00326	eb 28		 jmp	 SHORT $LN20@z900_add_d
$LN17@z900_add_d:
  00328	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0032d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00332	85 c0		 test	 eax, eax
  00334	74 0a		 je	 SHORT $LN18@z900_add_d
  00336	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv204[rsp], 1
  0033e	eb 08		 jmp	 SHORT $LN19@z900_add_d
$LN18@z900_add_d:
  00340	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv204[rsp], 2
$LN19@z900_add_d:
  00348	8b 44 24 34	 mov	 eax, DWORD PTR tv204[rsp]
  0034c	89 44 24 38	 mov	 DWORD PTR tv205[rsp], eax
$LN20@z900_add_d:
  00350	8b 44 24 38	 mov	 eax, DWORD PTR tv205[rsp]
  00354	89 44 24 3c	 mov	 DWORD PTR tv206[rsp], eax
$LN22@z900_add_d:
  00358	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00360	0f b6 4c 24 3c	 movzx	 ecx, BYTE PTR tv206[rsp]
  00365	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2015 :                    decNumberIsZero(&d1) ? 0 :
; 2016 :                    decNumberIsNegative(&d1) ? 1 : 2;
; 2017 : 
; 2018 :     /* Raise data exception if error occurred */
; 2019 :     if (dxc != 0)

  00368	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0036d	85 c0		 test	 eax, eax
  0036f	74 25		 je	 SHORT $LN15@z900_add_d

; 2020 :     {
; 2021 :         regs->dxc = dxc;

  00371	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00376	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037e	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2022 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00384	ba 07 00 00 00	 mov	 edx, 7
  00389	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00391	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_add_d:

; 2023 :     }
; 2024 : 
; 2025 : } /* end DEF_INST(add_dfp_ext_reg) */

  00396	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0039e	48 33 cc	 xor	 rcx, rsp
  003a1	e8 00 00 00 00	 call	 __security_check_cookie
  003a6	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  003ad	c3		 ret	 0
z900_add_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
src_fpc$ = 36
i$1 = 40
new_fpc$ = 44
r1$ = 48
r2$ = 52
inst$ = 80
regs$ = 88
z900_set_fpc_and_signal PROC

; 332  : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 333  : int             r1, r2;                 /* Values of R fields        */
; 334  : U32             src_fpc, new_fpc;       /* New value for FPC         */
; 335  : BYTE            dxc;                    /* Data exception code       */
; 336  : 
; 337  :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_set_f:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@z900_set_f
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_set_f:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_set_f
$LN7@z900_set_f:

; 338  : 
; 339  :     TXFC_INSTR_CHECK( regs );

  0006c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00071	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00078	85 c0		 test	 eax, eax
  0007a	74 36		 je	 SHORT $LN9@z900_set_f
  0007c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00081	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00087	0f ba e8 0f	 bts	 eax, 15
  0008b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00096	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195424
  0009d	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000a3	ba 02 00 00 00	 mov	 edx, 2
  000a8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_set_f:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 b4		 jne	 SHORT $LN7@z900_set_f

; 340  :     DFPINST_CHECK( regs );

  000b8	b8 08 00 00 00	 mov	 eax, 8
  000bd	48 6b c0 01	 imul	 rax, rax, 1
  000c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000ce	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  000d4	48 85 c0	 test	 rax, rax
  000d7	74 3c		 je	 SHORT $LN11@z900_set_f
  000d9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000de	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e4	d1 e8		 shr	 eax, 1
  000e6	83 e0 01	 and	 eax, 1
  000e9	85 c0		 test	 eax, eax
  000eb	74 4c		 je	 SHORT $LN10@z900_set_f
  000ed	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0010a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00110	48 85 c0	 test	 rax, rax
  00113	75 24		 jne	 SHORT $LN10@z900_set_f
$LN11@z900_set_f:
  00115	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00124	ba 07 00 00 00	 mov	 edx, 7
  00129	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00133	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@z900_set_f:

; 341  : 
; 342  :     /* Load new FPC register contents from R1 register bits 32-63 */
; 343  :     src_fpc = regs->GR_L(r1);

  00139	48 63 44 24 30	 movsxd	 rax, DWORD PTR r1$[rsp]
  0013e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00143	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0014a	89 44 24 24	 mov	 DWORD PTR src_fpc$[rsp], eax

; 344  : 
; 345  :     /* Program check if reserved bits are non-zero */
; 346  :     FPC_CHECK( src_fpc, regs );

  0014e	8b 54 24 24	 mov	 edx, DWORD PTR src_fpc$[rsp]
  00152	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	e8 00 00 00 00	 call	 z900_FPC_check

; 347  : 
; 348  :     /* OR the flags from the current FPC register */
; 349  : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 350  :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0015c	b8 01 00 00 00	 mov	 eax, 1
  00161	48 6b c0 04	 imul	 rax, rax, 4
  00165	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0016a	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00172	83 e0 04	 and	 eax, 4
  00175	85 c0		 test	 eax, eax
  00177	74 1e		 je	 SHORT $LN12@z900_set_f

; 351  :         new_fpc = src_fpc | (regs->fpc & FPC_FPX_FLAGS);

  00179	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0017e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00184	25 00 00 fc 00	 and	 eax, 16515072		; 00fc0000H
  00189	8b 4c 24 24	 mov	 ecx, DWORD PTR src_fpc$[rsp]
  0018d	0b c8		 or	 ecx, eax
  0018f	8b c1		 mov	 eax, ecx
  00191	89 44 24 2c	 mov	 DWORD PTR new_fpc$[rsp], eax
  00195	eb 1c		 jmp	 SHORT $LN13@z900_set_f
$LN12@z900_set_f:

; 352  :     else
; 353  : #endif
; 354  :         new_fpc = src_fpc | (regs->fpc & FPC_FLAGS);

  00197	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0019c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001a2	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  001a7	8b 4c 24 24	 mov	 ecx, DWORD PTR src_fpc$[rsp]
  001ab	0b c8		 or	 ecx, eax
  001ad	8b c1		 mov	 eax, ecx
  001af	89 44 24 2c	 mov	 DWORD PTR new_fpc$[rsp], eax
$LN13@z900_set_f:

; 355  : 
; 356  :     /* Determine whether an event is to be signaled */
; 357  :     dxc = fpc_signal_check(regs->fpc, src_fpc);

  001b3	8b 54 24 24	 mov	 edx, DWORD PTR src_fpc$[rsp]
  001b7	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	8b 88 c0 03 00
	00		 mov	 ecx, DWORD PTR [rax+960]
  001c2	e8 00 00 00 00	 call	 fpc_signal_check
  001c7	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 358  : 
; 359  :     /* Update the FPC register */
; 360  :     regs->fpc = new_fpc;

  001cb	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001d0	8b 4c 24 2c	 mov	 ecx, DWORD PTR new_fpc$[rsp]
  001d4	89 88 c0 03 00
	00		 mov	 DWORD PTR [rax+960], ecx

; 361  : 
; 362  :     /* Signal a simulated-IEEE-exception event if needed */
; 363  :     if (dxc != 0)

  001da	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  001df	85 c0		 test	 eax, eax
  001e1	74 1f		 je	 SHORT $LN14@z900_set_f

; 364  :     {
; 365  :         regs->dxc = dxc;

  001e3	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  001e8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ed	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 366  :         ARCH_DEP( program_interrupt )( regs, PGM_DATA_EXCEPTION );

  001f3	ba 07 00 00 00	 mov	 edx, 7
  001f8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001fd	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_set_f:

; 367  :     }
; 368  : 
; 369  : } /* end DEF_INST(set_fpc_and_signal) */

  00202	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00206	c3		 ret	 0
z900_set_fpc_and_signal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
b2$ = 36
src_fpc$ = 40
temp$1 = 44
new_fpc$ = 48
effective_addr2$ = 56
inst$ = 80
regs$ = 88
z900_load_fpc_and_signal PROC

; 286  : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 287  : int             b2;                     /* Base of effective addr    */
; 288  : VADR            effective_addr2;        /* Effective address         */
; 289  : U32             src_fpc, new_fpc;       /* New value for FPC         */
; 290  : BYTE            dxc;                    /* Data exception code       */
; 291  : 
; 292  :     S( inst, regs, b2, effective_addr2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 2c	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 2c	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 0c	 shr	 eax, 12
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 24	 mov	 DWORD PTR b2$[rsp], eax
  00041	83 7c 24 24 00	 cmp	 DWORD PTR b2$[rsp], 0
  00046	74 3e		 je	 SHORT $LN8@z900_load_
  00048	48 63 44 24 24	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0005f	48 03 c8	 add	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00076	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 23 c8	 and	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_load_:
$LN4@z900_load_:
  00086	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008f	48 83 c0 04	 add	 rax, 4
  00093	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0009c	33 c0		 xor	 eax, eax
  0009e	83 f8 04	 cmp	 eax, 4
  000a1	74 0c		 je	 SHORT $LN9@z900_load_
  000a3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN9@z900_load_:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 d1		 jne	 SHORT $LN4@z900_load_

; 293  :     PER_ZEROADDR_XCHECK( regs, b2 );

  000b5	8b 54 24 24	 mov	 edx, DWORD PTR b2$[rsp]
  000b9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000be	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_load_:

; 294  : 
; 295  :     TXFC_INSTR_CHECK( regs );

  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000cf	85 c0		 test	 eax, eax
  000d1	74 36		 je	 SHORT $LN10@z900_load_
  000d3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000de	0f ba e8 0f	 bts	 eax, 15
  000e2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ed	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195399
  000f4	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000fa	ba 02 00 00 00	 mov	 edx, 2
  000ff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00104	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_load_:
  00109	33 c0		 xor	 eax, eax
  0010b	85 c0		 test	 eax, eax
  0010d	75 b4		 jne	 SHORT $LN7@z900_load_

; 296  :     DFPINST_CHECK( regs );

  0010f	b8 08 00 00 00	 mov	 eax, 8
  00114	48 6b c0 01	 imul	 rax, rax, 1
  00118	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00125	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0012b	48 85 c0	 test	 rax, rax
  0012e	74 3c		 je	 SHORT $LN12@z900_load_
  00130	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00135	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0013b	d1 e8		 shr	 eax, 1
  0013d	83 e0 01	 and	 eax, 1
  00140	85 c0		 test	 eax, eax
  00142	74 4c		 je	 SHORT $LN11@z900_load_
  00144	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00149	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00150	b9 08 00 00 00	 mov	 ecx, 8
  00155	48 6b c9 01	 imul	 rcx, rcx, 1
  00159	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00161	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00167	48 85 c0	 test	 rax, rax
  0016a	75 24		 jne	 SHORT $LN11@z900_load_
$LN12@z900_load_:
  0016c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00171	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0017b	ba 07 00 00 00	 mov	 edx, 7
  00180	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00185	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0018a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_load_:

; 297  : 
; 298  :     /* Load new FPC register contents from operand location */
; 299  :     src_fpc = ARCH_DEP( vfetch4 )( effective_addr2, b2, regs );

  00190	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00195	8b 54 24 24	 mov	 edx, DWORD PTR b2$[rsp]
  00199	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0019e	e8 00 00 00 00	 call	 z900_vfetch4
  001a3	89 44 24 28	 mov	 DWORD PTR src_fpc$[rsp], eax

; 300  : 
; 301  :     /* Program check if reserved bits are non-zero */
; 302  :     FPC_CHECK( src_fpc, regs );

  001a7	8b 54 24 28	 mov	 edx, DWORD PTR src_fpc$[rsp]
  001ab	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	e8 00 00 00 00	 call	 z900_FPC_check

; 303  : 
; 304  :     /* OR the flags from the current FPC register */
; 305  : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 306  :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  001b5	b8 01 00 00 00	 mov	 eax, 1
  001ba	48 6b c0 04	 imul	 rax, rax, 4
  001be	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001cb	83 e0 04	 and	 eax, 4
  001ce	85 c0		 test	 eax, eax
  001d0	74 1e		 je	 SHORT $LN13@z900_load_

; 307  :         new_fpc = src_fpc | (regs->fpc & FPC_FPX_FLAGS);

  001d2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001d7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001dd	25 00 00 fc 00	 and	 eax, 16515072		; 00fc0000H
  001e2	8b 4c 24 28	 mov	 ecx, DWORD PTR src_fpc$[rsp]
  001e6	0b c8		 or	 ecx, eax
  001e8	8b c1		 mov	 eax, ecx
  001ea	89 44 24 30	 mov	 DWORD PTR new_fpc$[rsp], eax
  001ee	eb 1c		 jmp	 SHORT $LN14@z900_load_
$LN13@z900_load_:

; 308  :     else
; 309  : #endif
; 310  :         new_fpc = src_fpc | (regs->fpc & FPC_FLAGS);

  001f0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001f5	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001fb	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00200	8b 4c 24 28	 mov	 ecx, DWORD PTR src_fpc$[rsp]
  00204	0b c8		 or	 ecx, eax
  00206	8b c1		 mov	 eax, ecx
  00208	89 44 24 30	 mov	 DWORD PTR new_fpc$[rsp], eax
$LN14@z900_load_:

; 311  : 
; 312  :     /* Determine whether an event is to be signaled */
; 313  :     dxc = fpc_signal_check(regs->fpc, src_fpc);

  0020c	8b 54 24 28	 mov	 edx, DWORD PTR src_fpc$[rsp]
  00210	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00215	8b 88 c0 03 00
	00		 mov	 ecx, DWORD PTR [rax+960]
  0021b	e8 00 00 00 00	 call	 fpc_signal_check
  00220	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 314  : 
; 315  :     /* Update the FPC register */
; 316  :     regs->fpc = new_fpc;

  00224	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00229	8b 4c 24 30	 mov	 ecx, DWORD PTR new_fpc$[rsp]
  0022d	89 88 c0 03 00
	00		 mov	 DWORD PTR [rax+960], ecx

; 317  : 
; 318  :     /* Signal a simulated-IEEE-exception event if needed */
; 319  :     if (dxc != 0)

  00233	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00238	85 c0		 test	 eax, eax
  0023a	74 1f		 je	 SHORT $LN15@z900_load_

; 320  :     {
; 321  :         regs->dxc = dxc;

  0023c	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00241	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 322  :         ARCH_DEP( program_interrupt )( regs, PGM_DATA_EXCEPTION );

  0024c	ba 07 00 00 00	 mov	 edx, 7
  00251	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00256	e8 00 00 00 00	 call	 z900_program_interrupt
$LN15@z900_load_:

; 323  :     }
; 324  : 
; 325  : } /* end DEF_INST(load_fpc_and_signal) */

  0025b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0025f	c3		 ret	 0
z900_load_fpc_and_signal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
i2$ = 44
i1$ = 48
inst$ = 80
regs$ = 88
z900_load_positive_fpr_long_reg PROC

; 46   : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 47   : int     r1, r2;                         /* Values of R fields        */
; 48   : int     i1, i2;                         /* FP register subscripts    */
; 49   : 
; 50   :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@z900_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 51   : 
; 52   :     TXFC_INSTR_CHECK( regs );

  0006c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00071	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00078	85 c0		 test	 eax, eax
  0007a	74 36		 je	 SHORT $LN9@z900_load_
  0007c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00081	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00087	0f ba e8 0f	 bts	 eax, 15
  0008b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00096	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195237
  0009d	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000a3	ba 02 00 00 00	 mov	 edx, 2
  000a8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 b4		 jne	 SHORT $LN7@z900_load_

; 53   :     HFPREG2_CHECK(r1, r2, regs);

  000b8	b8 08 00 00 00	 mov	 eax, 8
  000bd	48 6b c0 01	 imul	 rax, rax, 1
  000c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000ce	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  000d4	48 85 c0	 test	 rax, rax
  000d7	74 3c		 je	 SHORT $LN11@z900_load_
  000d9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000de	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e4	d1 e8		 shr	 eax, 1
  000e6	83 e0 01	 and	 eax, 1
  000e9	85 c0		 test	 eax, eax
  000eb	74 62		 je	 SHORT $LN10@z900_load_
  000ed	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0010a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00110	48 85 c0	 test	 rax, rax
  00113	75 3a		 jne	 SHORT $LN10@z900_load_
$LN11@z900_load_:
  00115	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00119	83 e0 09	 and	 eax, 9
  0011c	85 c0		 test	 eax, eax
  0011e	75 0b		 jne	 SHORT $LN13@z900_load_
  00120	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00124	83 e0 09	 and	 eax, 9
  00127	85 c0		 test	 eax, eax
  00129	74 24		 je	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  0012b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00130	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  0013a	ba 07 00 00 00	 mov	 edx, 7
  0013f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00149	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_load_:
$LN10@z900_load_:

; 54   : 
; 55   :     i1 = FPR2I(r1);

  0014f	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00153	d1 e0		 shl	 eax, 1
  00155	89 44 24 30	 mov	 DWORD PTR i1$[rsp], eax

; 56   :     i2 = FPR2I(r2);

  00159	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0015d	d1 e0		 shl	 eax, 1
  0015f	89 44 24 2c	 mov	 DWORD PTR i2$[rsp], eax

; 57   : 
; 58   :     /* Copy register contents, clear the sign bit */
; 59   :     regs->fpr[i1] = regs->fpr[i2] & 0x7FFFFFFF;

  00163	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i2$[rsp]
  00168	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0016d	8b 84 81 40 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+832]
  00174	0f ba f0 1f	 btr	 eax, 31
  00178	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i1$[rsp]
  0017d	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00182	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 60   :     regs->fpr[i1+1] = regs->fpr[i2+1];

  00189	8b 44 24 2c	 mov	 eax, DWORD PTR i2$[rsp]
  0018d	ff c0		 inc	 eax
  0018f	48 98		 cdqe
  00191	8b 4c 24 30	 mov	 ecx, DWORD PTR i1$[rsp]
  00195	ff c1		 inc	 ecx
  00197	48 63 c9	 movsxd	 rcx, ecx
  0019a	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0019f	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  001a4	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  001ac	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 61   : 
; 62   : } /* end DEF_INST(load_positive_fpr_long_reg) */

  001b3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001b7	c3		 ret	 0
z900_load_positive_fpr_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
i2$ = 44
i1$ = 48
inst$ = 80
regs$ = 88
z900_load_negative_fpr_long_reg PROC

; 69   : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 70   : int     r1, r2;                         /* Values of R fields        */
; 71   : int     i1, i2;                         /* FP register subscripts    */
; 72   : 
; 73   :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@z900_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 74   : 
; 75   :     TXFC_INSTR_CHECK( regs );

  0006c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00071	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00078	85 c0		 test	 eax, eax
  0007a	74 36		 je	 SHORT $LN9@z900_load_
  0007c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00081	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00087	0f ba e8 0f	 bts	 eax, 15
  0008b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00096	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195260
  0009d	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000a3	ba 02 00 00 00	 mov	 edx, 2
  000a8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 b4		 jne	 SHORT $LN7@z900_load_

; 76   :     HFPREG2_CHECK(r1, r2, regs);

  000b8	b8 08 00 00 00	 mov	 eax, 8
  000bd	48 6b c0 01	 imul	 rax, rax, 1
  000c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000ce	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  000d4	48 85 c0	 test	 rax, rax
  000d7	74 3c		 je	 SHORT $LN11@z900_load_
  000d9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000de	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e4	d1 e8		 shr	 eax, 1
  000e6	83 e0 01	 and	 eax, 1
  000e9	85 c0		 test	 eax, eax
  000eb	74 62		 je	 SHORT $LN10@z900_load_
  000ed	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0010a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00110	48 85 c0	 test	 rax, rax
  00113	75 3a		 jne	 SHORT $LN10@z900_load_
$LN11@z900_load_:
  00115	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00119	83 e0 09	 and	 eax, 9
  0011c	85 c0		 test	 eax, eax
  0011e	75 0b		 jne	 SHORT $LN13@z900_load_
  00120	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00124	83 e0 09	 and	 eax, 9
  00127	85 c0		 test	 eax, eax
  00129	74 24		 je	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  0012b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00130	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  0013a	ba 07 00 00 00	 mov	 edx, 7
  0013f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00149	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_load_:
$LN10@z900_load_:

; 77   : 
; 78   :     i1 = FPR2I(r1);

  0014f	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00153	d1 e0		 shl	 eax, 1
  00155	89 44 24 30	 mov	 DWORD PTR i1$[rsp], eax

; 79   :     i2 = FPR2I(r2);

  00159	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0015d	d1 e0		 shl	 eax, 1
  0015f	89 44 24 2c	 mov	 DWORD PTR i2$[rsp], eax

; 80   : 
; 81   :     /* Copy register contents, set the sign bit */
; 82   :     regs->fpr[i1] = regs->fpr[i2] | 0x80000000;

  00163	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i2$[rsp]
  00168	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0016d	8b 84 81 40 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+832]
  00174	0f ba e8 1f	 bts	 eax, 31
  00178	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i1$[rsp]
  0017d	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00182	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 83   :     regs->fpr[i1+1] = regs->fpr[i2+1];

  00189	8b 44 24 2c	 mov	 eax, DWORD PTR i2$[rsp]
  0018d	ff c0		 inc	 eax
  0018f	48 98		 cdqe
  00191	8b 4c 24 30	 mov	 ecx, DWORD PTR i1$[rsp]
  00195	ff c1		 inc	 ecx
  00197	48 63 c9	 movsxd	 rcx, ecx
  0019a	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0019f	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  001a4	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  001ac	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 84   : 
; 85   : } /* end DEF_INST(load_negative_fpr_long_reg) */

  001b3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001b7	c3		 ret	 0
z900_load_negative_fpr_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
i2$ = 44
i1$ = 48
inst$ = 80
regs$ = 88
z900_load_complement_fpr_long_reg PROC

; 125  : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 126  : int     r1, r2;                         /* Values of R fields        */
; 127  : int     i1, i2;                         /* FP register subscripts    */
; 128  : 
; 129  :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@z900_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 130  : 
; 131  :     TXFC_INSTR_CHECK( regs );

  0006c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00071	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00078	85 c0		 test	 eax, eax
  0007a	74 36		 je	 SHORT $LN9@z900_load_
  0007c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00081	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00087	0f ba e8 0f	 bts	 eax, 15
  0008b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00096	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195312
  0009d	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000a3	ba 02 00 00 00	 mov	 edx, 2
  000a8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 b4		 jne	 SHORT $LN7@z900_load_

; 132  :     HFPREG2_CHECK(r1, r2, regs);

  000b8	b8 08 00 00 00	 mov	 eax, 8
  000bd	48 6b c0 01	 imul	 rax, rax, 1
  000c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000ce	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  000d4	48 85 c0	 test	 rax, rax
  000d7	74 3c		 je	 SHORT $LN11@z900_load_
  000d9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000de	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e4	d1 e8		 shr	 eax, 1
  000e6	83 e0 01	 and	 eax, 1
  000e9	85 c0		 test	 eax, eax
  000eb	74 62		 je	 SHORT $LN10@z900_load_
  000ed	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0010a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00110	48 85 c0	 test	 rax, rax
  00113	75 3a		 jne	 SHORT $LN10@z900_load_
$LN11@z900_load_:
  00115	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00119	83 e0 09	 and	 eax, 9
  0011c	85 c0		 test	 eax, eax
  0011e	75 0b		 jne	 SHORT $LN13@z900_load_
  00120	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00124	83 e0 09	 and	 eax, 9
  00127	85 c0		 test	 eax, eax
  00129	74 24		 je	 SHORT $LN12@z900_load_
$LN13@z900_load_:
  0012b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00130	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  0013a	ba 07 00 00 00	 mov	 edx, 7
  0013f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00149	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_load_:
$LN10@z900_load_:

; 133  : 
; 134  :     i1 = FPR2I(r1);

  0014f	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00153	d1 e0		 shl	 eax, 1
  00155	89 44 24 30	 mov	 DWORD PTR i1$[rsp], eax

; 135  :     i2 = FPR2I(r2);

  00159	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0015d	d1 e0		 shl	 eax, 1
  0015f	89 44 24 2c	 mov	 DWORD PTR i2$[rsp], eax

; 136  : 
; 137  :     /* Copy register contents, invert sign bit */
; 138  :     regs->fpr[i1] = regs->fpr[i2] ^ 0x80000000;

  00163	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i2$[rsp]
  00168	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0016d	8b 84 81 40 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+832]
  00174	0f ba f8 1f	 btc	 eax, 31
  00178	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i1$[rsp]
  0017d	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00182	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 139  :     regs->fpr[i1+1] = regs->fpr[i2+1];

  00189	8b 44 24 2c	 mov	 eax, DWORD PTR i2$[rsp]
  0018d	ff c0		 inc	 eax
  0018f	48 98		 cdqe
  00191	8b 4c 24 30	 mov	 ecx, DWORD PTR i1$[rsp]
  00195	ff c1		 inc	 ecx
  00197	48 63 c9	 movsxd	 rcx, ecx
  0019a	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0019f	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  001a4	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  001ac	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 140  : 
; 141  : } /* end DEF_INST(load_complement_fpr_long_reg) */

  001b3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001b7	c3		 ret	 0
z900_load_complement_fpr_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i1$ = 32
temp$1 = 36
r1$ = 40
r2$ = 44
r3$ = 48
i2$ = 52
i3$ = 56
sign$ = 60
inst$ = 80
regs$ = 88
z900_copy_sign_fpr_long_reg PROC

; 92   : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 93   : int     r1, r2, r3;                     /* Values of R fields        */
; 94   : int     i1, i2, i3;                     /* FP register subscripts    */
; 95   : U32     sign;                           /* Work area for sign bit    */
; 96   : 
; 97   :     RRF_M(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_copy_:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN8@z900_copy_
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_copy_:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_copy_
$LN7@z900_copy_:

; 98   : 
; 99   :     TXFC_INSTR_CHECK( regs );

  00079	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00085	85 c0		 test	 eax, eax
  00087	74 36		 je	 SHORT $LN9@z900_copy_
  00089	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00094	0f ba e8 0f	 bts	 eax, 15
  00098	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000a3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195286
  000aa	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000b0	ba 02 00 00 00	 mov	 edx, 2
  000b5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ba	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_copy_:
  000bf	33 c0		 xor	 eax, eax
  000c1	85 c0		 test	 eax, eax
  000c3	75 b4		 jne	 SHORT $LN7@z900_copy_

; 100  :     HFPREG2_CHECK(r1, r2, regs);

  000c5	b8 08 00 00 00	 mov	 eax, 8
  000ca	48 6b c0 01	 imul	 rax, rax, 1
  000ce	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000db	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  000e1	48 85 c0	 test	 rax, rax
  000e4	74 3c		 je	 SHORT $LN11@z900_copy_
  000e6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000f1	d1 e8		 shr	 eax, 1
  000f3	83 e0 01	 and	 eax, 1
  000f6	85 c0		 test	 eax, eax
  000f8	74 62		 je	 SHORT $LN10@z900_copy_
  000fa	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ff	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00106	b9 08 00 00 00	 mov	 ecx, 8
  0010b	48 6b c9 01	 imul	 rcx, rcx, 1
  0010f	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00117	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0011d	48 85 c0	 test	 rax, rax
  00120	75 3a		 jne	 SHORT $LN10@z900_copy_
$LN11@z900_copy_:
  00122	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00126	83 e0 09	 and	 eax, 9
  00129	85 c0		 test	 eax, eax
  0012b	75 0b		 jne	 SHORT $LN13@z900_copy_
  0012d	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00131	83 e0 09	 and	 eax, 9
  00134	85 c0		 test	 eax, eax
  00136	74 24		 je	 SHORT $LN12@z900_copy_
$LN13@z900_copy_:
  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0013d	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  00147	ba 07 00 00 00	 mov	 edx, 7
  0014c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00151	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00156	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_copy_:
$LN10@z900_copy_:

; 101  :     HFPREG_CHECK(r3, regs);

  0015c	b8 08 00 00 00	 mov	 eax, 8
  00161	48 6b c0 01	 imul	 rax, rax, 1
  00165	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0016a	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00172	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00178	48 85 c0	 test	 rax, rax
  0017b	74 3c		 je	 SHORT $LN15@z900_copy_
  0017d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00182	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00188	d1 e8		 shr	 eax, 1
  0018a	83 e0 01	 and	 eax, 1
  0018d	85 c0		 test	 eax, eax
  0018f	74 57		 je	 SHORT $LN14@z900_copy_
  00191	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00196	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0019d	b9 08 00 00 00	 mov	 ecx, 8
  001a2	48 6b c9 01	 imul	 rcx, rcx, 1
  001a6	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  001ae	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001b4	48 85 c0	 test	 rax, rax
  001b7	75 2f		 jne	 SHORT $LN14@z900_copy_
$LN15@z900_copy_:
  001b9	8b 44 24 30	 mov	 eax, DWORD PTR r3$[rsp]
  001bd	83 e0 09	 and	 eax, 9
  001c0	85 c0		 test	 eax, eax
  001c2	74 24		 je	 SHORT $LN16@z900_copy_
  001c4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001c9	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  001d3	ba 07 00 00 00	 mov	 edx, 7
  001d8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001dd	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001e2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@z900_copy_:
$LN14@z900_copy_:

; 102  : 
; 103  :     i1 = FPR2I(r1);

  001e8	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  001ec	d1 e0		 shl	 eax, 1
  001ee	89 44 24 20	 mov	 DWORD PTR i1$[rsp], eax

; 104  :     i2 = FPR2I(r2);

  001f2	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  001f6	d1 e0		 shl	 eax, 1
  001f8	89 44 24 34	 mov	 DWORD PTR i2$[rsp], eax

; 105  :     i3 = FPR2I(r3);

  001fc	8b 44 24 30	 mov	 eax, DWORD PTR r3$[rsp]
  00200	d1 e0		 shl	 eax, 1
  00202	89 44 24 38	 mov	 DWORD PTR i3$[rsp], eax

; 106  : 
; 107  :     /* Copy the sign bit from r3 register */
; 108  :     sign = regs->fpr[i3] & 0x80000000;

  00206	48 63 44 24 38	 movsxd	 rax, DWORD PTR i3$[rsp]
  0020b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00210	8b 84 81 40 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+832]
  00217	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0021c	89 44 24 3c	 mov	 DWORD PTR sign$[rsp], eax

; 109  : 
; 110  :     /* Copy r2 register contents to r1 register */
; 111  :     regs->fpr[i1] = regs->fpr[i2];

  00220	48 63 44 24 34	 movsxd	 rax, DWORD PTR i2$[rsp]
  00225	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i1$[rsp]
  0022a	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0022f	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00234	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  0023c	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 112  :     regs->fpr[i1+1] = regs->fpr[i2+1];

  00243	8b 44 24 34	 mov	 eax, DWORD PTR i2$[rsp]
  00247	ff c0		 inc	 eax
  00249	48 98		 cdqe
  0024b	8b 4c 24 20	 mov	 ecx, DWORD PTR i1$[rsp]
  0024f	ff c1		 inc	 ecx
  00251	48 63 c9	 movsxd	 rcx, ecx
  00254	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00259	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0025e	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  00266	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 113  : 
; 114  :     /* Insert the sign bit into r1 register */
; 115  :     regs->fpr[i1] &= 0x7FFFFFFF;

  0026d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i1$[rsp]
  00272	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00277	8b 84 81 40 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+832]
  0027e	0f ba f0 1f	 btr	 eax, 31
  00282	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i1$[rsp]
  00287	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0028c	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 116  :     regs->fpr[i1] |= sign;

  00293	48 63 44 24 20	 movsxd	 rax, DWORD PTR i1$[rsp]
  00298	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0029d	8b 54 24 3c	 mov	 edx, DWORD PTR sign$[rsp]
  002a1	8b 84 81 40 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+832]
  002a8	0b c2		 or	 eax, edx
  002aa	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i1$[rsp]
  002af	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  002b4	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 117  : 
; 118  : } /* end DEF_INST(copy_sign_fpr_long_reg) */

  002bb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002bf	c3		 ret	 0
z900_copy_sign_fpr_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
i2$ = 40
r1$ = 44
inst$ = 64
regs$ = 72
z900_load_gr_from_fpr_long_reg PROC

; 172  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 173  : int     r1, r2;                         /* Values of R fields        */
; 174  : int     i2;                             /* FP register subscript     */
; 175  : 
; 176  :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@z900_load_
  0005a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 177  : 
; 178  :     TXFC_INSTR_CHECK( regs );

  0006c	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00071	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00078	85 c0		 test	 eax, eax
  0007a	74 36		 je	 SHORT $LN9@z900_load_
  0007c	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00081	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00087	0f ba e8 0f	 bts	 eax, 15
  0008b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00096	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195355
  0009d	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000a3	ba 02 00 00 00	 mov	 edx, 2
  000a8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 b4		 jne	 SHORT $LN7@z900_load_

; 179  :     HFPREG_CHECK(r2, regs);

  000b8	b8 08 00 00 00	 mov	 eax, 8
  000bd	48 6b c0 01	 imul	 rax, rax, 1
  000c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000ce	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  000d4	48 85 c0	 test	 rax, rax
  000d7	74 3c		 je	 SHORT $LN11@z900_load_
  000d9	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000de	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e4	d1 e8		 shr	 eax, 1
  000e6	83 e0 01	 and	 eax, 1
  000e9	85 c0		 test	 eax, eax
  000eb	74 57		 je	 SHORT $LN10@z900_load_
  000ed	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0010a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00110	48 85 c0	 test	 rax, rax
  00113	75 2f		 jne	 SHORT $LN10@z900_load_
$LN11@z900_load_:
  00115	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00119	83 e0 09	 and	 eax, 9
  0011c	85 c0		 test	 eax, eax
  0011e	74 24		 je	 SHORT $LN12@z900_load_
  00120	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00125	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  0012f	ba 07 00 00 00	 mov	 edx, 7
  00134	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_load_:
$LN10@z900_load_:

; 180  : 
; 181  :     i2 = FPR2I(r2);

  00144	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  00148	d1 e0		 shl	 eax, 1
  0014a	89 44 24 28	 mov	 DWORD PTR i2$[rsp], eax

; 182  : 
; 183  :     /* Load general register contents from FP register */
; 184  :     regs->GR_H(r1) = regs->fpr[i2];

  0014e	48 63 44 24 28	 movsxd	 rax, DWORD PTR i2$[rsp]
  00153	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00158	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  0015d	4c 8b 44 24 48	 mov	 r8, QWORD PTR regs$[rsp]
  00162	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  0016a	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 185  :     regs->GR_L(r1) = regs->fpr[i2+1];

  00171	8b 44 24 28	 mov	 eax, DWORD PTR i2$[rsp]
  00175	ff c0		 inc	 eax
  00177	48 98		 cdqe
  00179	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0017e	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	4c 8b 44 24 48	 mov	 r8, QWORD PTR regs$[rsp]
  00188	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  00190	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 186  : 
; 187  : } /* end DEF_INST(load_gr_from_fpr_long_reg) */

  00197	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0019b	c3		 ret	 0
z900_load_gr_from_fpr_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
i1$ = 44
inst$ = 64
regs$ = 72
z900_load_fpr_from_gr_long_reg PROC

; 150  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 151  : int     r1, r2;                         /* Values of R fields        */
; 152  : int     i1;                             /* FP register subscript     */
; 153  : 
; 154  :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_load_:
  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@z900_load_
  0005a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_load_
$LN7@z900_load_:

; 155  : 
; 156  :     TXFC_INSTR_CHECK( regs );

  0006c	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00071	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00078	85 c0		 test	 eax, eax
  0007a	74 36		 je	 SHORT $LN9@z900_load_
  0007c	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00081	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00087	0f ba e8 0f	 bts	 eax, 15
  0008b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00096	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195334
  0009d	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000a3	ba 02 00 00 00	 mov	 edx, 2
  000a8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_load_:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 b4		 jne	 SHORT $LN7@z900_load_

; 157  :     HFPREG_CHECK(r1, regs);

  000b8	b8 08 00 00 00	 mov	 eax, 8
  000bd	48 6b c0 01	 imul	 rax, rax, 1
  000c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000ce	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  000d4	48 85 c0	 test	 rax, rax
  000d7	74 3c		 je	 SHORT $LN11@z900_load_
  000d9	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000de	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e4	d1 e8		 shr	 eax, 1
  000e6	83 e0 01	 and	 eax, 1
  000e9	85 c0		 test	 eax, eax
  000eb	74 57		 je	 SHORT $LN10@z900_load_
  000ed	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000f9	b9 08 00 00 00	 mov	 ecx, 8
  000fe	48 6b c9 01	 imul	 rcx, rcx, 1
  00102	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  0010a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00110	48 85 c0	 test	 rax, rax
  00113	75 2f		 jne	 SHORT $LN10@z900_load_
$LN11@z900_load_:
  00115	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00119	83 e0 09	 and	 eax, 9
  0011c	85 c0		 test	 eax, eax
  0011e	74 24		 je	 SHORT $LN12@z900_load_
  00120	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00125	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  0012f	ba 07 00 00 00	 mov	 edx, 7
  00134	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_load_:
$LN10@z900_load_:

; 158  : 
; 159  :     i1 = FPR2I(r1);

  00144	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00148	d1 e0		 shl	 eax, 1
  0014a	89 44 24 2c	 mov	 DWORD PTR i1$[rsp], eax

; 160  : 
; 161  :     /* Load FP register contents from general register */
; 162  :     regs->fpr[i1] = regs->GR_H(r2);

  0014e	48 63 44 24 28	 movsxd	 rax, DWORD PTR r2$[rsp]
  00153	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR i1$[rsp]
  00158	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  0015d	4c 8b 44 24 48	 mov	 r8, QWORD PTR regs$[rsp]
  00162	41 8b 84 c0 84
	02 00 00	 mov	 eax, DWORD PTR [r8+rax*8+644]
  0016a	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 163  :     regs->fpr[i1+1] = regs->GR_L(r2);

  00171	48 63 44 24 28	 movsxd	 rax, DWORD PTR r2$[rsp]
  00176	8b 4c 24 2c	 mov	 ecx, DWORD PTR i1$[rsp]
  0017a	ff c1		 inc	 ecx
  0017c	48 63 c9	 movsxd	 rcx, ecx
  0017f	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  00184	4c 8b 44 24 48	 mov	 r8, QWORD PTR regs$[rsp]
  00189	41 8b 84 c0 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax*8+640]
  00191	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 164  : 
; 165  : } /* end DEF_INST(load_fpr_from_gr_long_reg) */

  00198	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0019c	c3		 ret	 0
z900_load_fpr_from_gr_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
b2$ = 36
effective_addr2$ = 40
inst$ = 64
regs$ = 72
z900_set_dfp_rounding_mode PROC

; 196  : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 197  : int             b2;                     /* Base of effective addr    */
; 198  : VADR            effective_addr2;        /* Effective address         */
; 199  : 
; 200  :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 0c	 shr	 eax, 12
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 24	 mov	 DWORD PTR b2$[rsp], eax
  00041	83 7c 24 24 00	 cmp	 DWORD PTR b2$[rsp], 0
  00046	74 3e		 je	 SHORT $LN8@z900_set_d
  00048	48 63 44 24 24	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0005f	48 03 c8	 add	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0006a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00076	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 23 c8	 and	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN8@z900_set_d:
$LN4@z900_set_d:
  00086	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008f	48 83 c0 04	 add	 rax, 4
  00093	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0009c	33 c0		 xor	 eax, eax
  0009e	83 f8 04	 cmp	 eax, 4
  000a1	74 0c		 je	 SHORT $LN9@z900_set_d
  000a3	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN9@z900_set_d:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 d1		 jne	 SHORT $LN4@z900_set_d
$LN7@z900_set_d:

; 201  : 
; 202  :     TXFC_INSTR_CHECK( regs );

  000b5	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000c1	85 c0		 test	 eax, eax
  000c3	74 36		 je	 SHORT $LN10@z900_set_d
  000c5	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000d0	0f ba e8 0f	 bts	 eax, 15
  000d4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000d9	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000df	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195376
  000e6	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000ec	ba 02 00 00 00	 mov	 edx, 2
  000f1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	e8 00 00 00 00	 call	 z900_abort_transaction
$LN10@z900_set_d:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 b4		 jne	 SHORT $LN7@z900_set_d

; 203  :     DFPINST_CHECK(regs);

  00101	b8 08 00 00 00	 mov	 eax, 8
  00106	48 6b c0 01	 imul	 rax, rax, 1
  0010a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00117	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0011d	48 85 c0	 test	 rax, rax
  00120	74 3c		 je	 SHORT $LN12@z900_set_d
  00122	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00127	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0012d	d1 e8		 shr	 eax, 1
  0012f	83 e0 01	 and	 eax, 1
  00132	85 c0		 test	 eax, eax
  00134	74 4c		 je	 SHORT $LN11@z900_set_d
  00136	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00142	b9 08 00 00 00	 mov	 ecx, 8
  00147	48 6b c9 01	 imul	 rcx, rcx, 1
  0014b	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00153	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00159	48 85 c0	 test	 rax, rax
  0015c	75 24		 jne	 SHORT $LN11@z900_set_d
$LN12@z900_set_d:
  0015e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00163	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0016d	ba 07 00 00 00	 mov	 edx, 7
  00172	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0017c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_set_d:

; 204  : 
; 205  :     /* Set DFP rounding mode in FPC register from address bits 61-63 */
; 206  :     regs->fpc &= ~(FPC_DRM);

  00182	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00187	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0018d	83 e0 8f	 and	 eax, -113		; ffffff8fH
  00190	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00195	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 207  :     regs->fpc |= ((effective_addr2 << FPC_DRM_SHIFT) & FPC_DRM);

  0019b	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001a0	48 c1 e0 04	 shl	 rax, 4
  001a4	48 83 e0 70	 and	 rax, 112		; 00000070H
  001a8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  001ad	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  001b3	48 0b c8	 or	 rcx, rax
  001b6	48 8b c1	 mov	 rax, rcx
  001b9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  001be	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 208  : 
; 209  : } /* end DEF_INST(set_dfp_rounding_mode) */

  001c4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001c8	c3		 ret	 0
z900_set_dfp_rounding_mode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv188 = 40
tv189 = 44
tv191 = 48
m3$ = 52
r2$ = 56
r1$ = 60
m4$ = 64
n1$ = 72
x2$ = 80
set$ = 88
d2$ = 120
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
z900_convert_dfp_long_to_u64_reg PROC

; 3414 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3415 : int             r1, r2;                 /* Values of R fields        */
; 3416 : int             m3, m4;                 /* Values of M fields        */
; 3417 : U64             n1;                     /* Result value              */
; 3418 : decimal64       x2;                     /* Long DFP value            */
; 3419 : decNumber       d2;                     /* Working decimal number    */
; 3420 : decContext      set;                    /* Working context           */
; 3421 : BYTE            dxc;                    /* Data exception code       */
; 3422 : 
; 3423 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 40	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 34	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00070	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_conve
  00093	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 3424 : 
; 3425 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000b3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_conve
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_conve
  000df	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196629
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3426 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_conve
  00162	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_conve
  00179	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 3427 : 
; 3428 :     /* Initialise the context for long DFP */
; 3429 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001d1	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001d6	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  001db	e8 00 00 00 00	 call	 decContextDefault

; 3430 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  001e0	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e8	8b 54 24 34	 mov	 edx, DWORD PTR m3$[rsp]
  001ec	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  001f1	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 3431 : 
; 3432 :     /* Load long DFP value from FP register r2 */
; 3433 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001f6	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001fe	48 8d 54 24 50	 lea	 rdx, QWORD PTR x2$[rsp]
  00203	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  00207	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 3434 :     decimal64ToNumber(&x2, &d2);

  0020c	48 8d 54 24 78	 lea	 rdx, QWORD PTR d2$[rsp]
  00211	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x2$[rsp]
  00216	e8 00 00 00 00	 call	 decimal64ToNumber

; 3435 : 
; 3436 :     /* Convert decimal number to 64-bit unsigned integer */
; 3437 :     n1 = dfp_number_to_u64(&d2, &set);

  0021b	48 8d 54 24 58	 lea	 rdx, QWORD PTR set$[rsp]
  00220	48 8d 4c 24 78	 lea	 rcx, QWORD PTR d2$[rsp]
  00225	e8 00 00 00 00	 call	 dfp_number_to_u64
  0022a	48 89 44 24 48	 mov	 QWORD PTR n1$[rsp], rax

; 3438 : 
; 3439 :     /* Check for exception condition */
; 3440 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0022f	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00237	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  0023c	e8 00 00 00 00	 call	 z900_dfp_status_check
  00241	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3441 : 
; 3442 :     /* Load result into general register r1 */
; 3443 :     regs->GR_G(r1) = n1;

  00245	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  0024a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00252	48 8b 54 24 48	 mov	 rdx, QWORD PTR n1$[rsp]
  00257	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3444 : 
; 3445 :     /* Set condition code */
; 3446 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  0025f	8b 44 24 6c	 mov	 eax, DWORD PTR set$[rsp+20]
  00263	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  00268	85 c0		 test	 eax, eax
  0026a	74 0a		 je	 SHORT $LN19@z900_conve
  0026c	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv191[rsp], 3
  00274	eb 68		 jmp	 SHORT $LN20@z900_conve
$LN19@z900_conve:
  00276	b8 02 00 00 00	 mov	 eax, 2
  0027b	48 6b c0 00	 imul	 rax, rax, 0
  0027f	0f b7 84 04 82
	00 00 00	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  00287	85 c0		 test	 eax, eax
  00289	75 20		 jne	 SHORT $LN15@z900_conve
  0028b	83 7c 24 78 01	 cmp	 DWORD PTR d2$[rsp], 1
  00290	75 19		 jne	 SHORT $LN15@z900_conve
  00292	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0029a	83 e0 70	 and	 eax, 112		; 00000070H
  0029d	85 c0		 test	 eax, eax
  0029f	75 0a		 jne	 SHORT $LN15@z900_conve
  002a1	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv189[rsp], 0
  002a9	eb 2b		 jmp	 SHORT $LN18@z900_conve
$LN15@z900_conve:
  002ab	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002b3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002b8	85 c0		 test	 eax, eax
  002ba	74 0a		 je	 SHORT $LN16@z900_conve
  002bc	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv188[rsp], 1
  002c4	eb 08		 jmp	 SHORT $LN17@z900_conve
$LN16@z900_conve:
  002c6	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv188[rsp], 2
$LN17@z900_conve:
  002ce	8b 44 24 28	 mov	 eax, DWORD PTR tv188[rsp]
  002d2	89 44 24 2c	 mov	 DWORD PTR tv189[rsp], eax
$LN18@z900_conve:
  002d6	8b 44 24 2c	 mov	 eax, DWORD PTR tv189[rsp]
  002da	89 44 24 30	 mov	 DWORD PTR tv191[rsp], eax
$LN20@z900_conve:
  002de	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e6	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv191[rsp]
  002eb	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3447 :                    decNumberIsZero(&d2) ? 0 :
; 3448 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3449 : 
; 3450 :     /* Raise data exception if error occurred */
; 3451 :     if (dxc != 0)

  002ee	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002f3	85 c0		 test	 eax, eax
  002f5	74 25		 je	 SHORT $LN13@z900_conve

; 3452 :     {
; 3453 :         regs->dxc = dxc;

  002f7	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002fc	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00304	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3454 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0030a	ba 07 00 00 00	 mov	 edx, 7
  0030f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00317	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_conve:

; 3455 :     }
; 3456 : 
; 3457 : } /* end DEF_INST(convert_dfp_long_to_u64_reg) */

  0031c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00324	48 33 cc	 xor	 rcx, rsp
  00327	e8 00 00 00 00	 call	 __security_check_cookie
  0032c	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00333	c3		 ret	 0
z900_convert_dfp_long_to_u64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
tv193 = 44
tv194 = 48
tv196 = 52
m3$ = 56
r1$ = 60
m4$ = 64
n1$ = 72
set$ = 80
d2$ = 112
x2$ = 152
__$ArrayPad$ = 168
inst$ = 192
regs$ = 200
z900_convert_dfp_ext_to_u64_reg PROC

; 3363 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3364 : int             r1, r2;                 /* Values of R fields        */
; 3365 : int             m3, m4;                 /* Values of M fields        */
; 3366 : U64             n1;                     /* Result value              */
; 3367 : decimal128      x2;                     /* Extended DFP value        */
; 3368 : decNumber       d2;                     /* Working decimal number    */
; 3369 : decContext      set;                    /* Working context           */
; 3370 : BYTE            dxc;                    /* Data exception code       */
; 3371 : 
; 3372 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 40	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00070	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_conve
  00093	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 3373 : 
; 3374 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000b3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_conve
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_conve
  000df	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196600
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3375 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_conve
  00162	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_conve
  00179	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 3376 :     DFPREGPAIR_CHECK(r2, regs);

  001d1	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001d5	83 e0 02	 and	 eax, 2
  001d8	85 c0		 test	 eax, eax
  001da	74 1b		 je	 SHORT $LN13@z900_conve
  001dc	ba 06 00 00 00	 mov	 edx, 6
  001e1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 3377 : 
; 3378 :     /* Initialise the context for extended DFP */
; 3379 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001f7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001fc	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00201	e8 00 00 00 00	 call	 decContextDefault

; 3380 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00206	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020e	8b 54 24 38	 mov	 edx, DWORD PTR m3$[rsp]
  00212	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00217	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 3381 : 
; 3382 :     /* Load extended DFP value from FP register r2 */
; 3383 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  0021c	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00224	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  0022c	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00230	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 3384 :     decimal128ToNumber(&x2, &d2);

  00235	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  0023a	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  00242	e8 00 00 00 00	 call	 decimal128ToNumber

; 3385 : 
; 3386 :     /* Convert decimal number to 64-bit unsigned integer */
; 3387 :     n1 = dfp_number_to_u64(&d2, &set);

  00247	48 8d 54 24 50	 lea	 rdx, QWORD PTR set$[rsp]
  0024c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR d2$[rsp]
  00251	e8 00 00 00 00	 call	 dfp_number_to_u64
  00256	48 89 44 24 48	 mov	 QWORD PTR n1$[rsp], rax

; 3388 : 
; 3389 :     /* Check for exception condition */
; 3390 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0025b	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00263	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00268	e8 00 00 00 00	 call	 z900_dfp_status_check
  0026d	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3391 : 
; 3392 :     /* Load result into general register r1 */
; 3393 :     regs->GR_G(r1) = n1;

  00271	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00276	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027e	48 8b 54 24 48	 mov	 rdx, QWORD PTR n1$[rsp]
  00283	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3394 : 
; 3395 :     /* Set condition code */
; 3396 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  0028b	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  0028f	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  00294	85 c0		 test	 eax, eax
  00296	74 0a		 je	 SHORT $LN20@z900_conve
  00298	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv196[rsp], 3
  002a0	eb 5f		 jmp	 SHORT $LN21@z900_conve
$LN20@z900_conve:
  002a2	b8 02 00 00 00	 mov	 eax, 2
  002a7	48 6b c0 00	 imul	 rax, rax, 0
  002ab	0f b7 44 04 7a	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  002b0	85 c0		 test	 eax, eax
  002b2	75 1d		 jne	 SHORT $LN16@z900_conve
  002b4	83 7c 24 70 01	 cmp	 DWORD PTR d2$[rsp], 1
  002b9	75 16		 jne	 SHORT $LN16@z900_conve
  002bb	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002c0	83 e0 70	 and	 eax, 112		; 00000070H
  002c3	85 c0		 test	 eax, eax
  002c5	75 0a		 jne	 SHORT $LN16@z900_conve
  002c7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
  002cf	eb 28		 jmp	 SHORT $LN19@z900_conve
$LN16@z900_conve:
  002d1	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002d6	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002db	85 c0		 test	 eax, eax
  002dd	74 0a		 je	 SHORT $LN17@z900_conve
  002df	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv193[rsp], 1
  002e7	eb 08		 jmp	 SHORT $LN18@z900_conve
$LN17@z900_conve:
  002e9	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv193[rsp], 2
$LN18@z900_conve:
  002f1	8b 44 24 2c	 mov	 eax, DWORD PTR tv193[rsp]
  002f5	89 44 24 30	 mov	 DWORD PTR tv194[rsp], eax
$LN19@z900_conve:
  002f9	8b 44 24 30	 mov	 eax, DWORD PTR tv194[rsp]
  002fd	89 44 24 34	 mov	 DWORD PTR tv196[rsp], eax
$LN21@z900_conve:
  00301	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00309	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv196[rsp]
  0030e	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3397 :                    decNumberIsZero(&d2) ? 0 :
; 3398 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3399 : 
; 3400 :     /* Raise data exception if error occurred */
; 3401 :     if (dxc != 0)

  00311	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00316	85 c0		 test	 eax, eax
  00318	74 25		 je	 SHORT $LN14@z900_conve

; 3402 :     {
; 3403 :         regs->dxc = dxc;

  0031a	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0031f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00327	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3404 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0032d	ba 07 00 00 00	 mov	 edx, 7
  00332	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033a	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_conve:

; 3405 :     }
; 3406 : 
; 3407 : } /* end DEF_INST(convert_dfp_ext_to_u64_reg) */

  0033f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00347	48 33 cc	 xor	 rcx, rsp
  0034a	e8 00 00 00 00	 call	 __security_check_cookie
  0034f	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00356	c3		 ret	 0
z900_convert_dfp_ext_to_u64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv188 = 40
tv189 = 44
tv191 = 48
m3$ = 52
r2$ = 56
r1$ = 60
n1$ = 64
m4$ = 68
x2$ = 72
set$ = 80
d2$ = 112
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
z900_convert_dfp_long_to_u32_reg PROC

; 3210 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3211 : int             r1, r2;                 /* Values of R fields        */
; 3212 : int             m3, m4;                 /* Values of M fields        */
; 3213 : U32             n1;                     /* Result value              */
; 3214 : decimal64       x2;                     /* Long DFP value            */
; 3215 : decNumber       d2;                     /* Working decimal number    */
; 3216 : decContext      set;                    /* Working context           */
; 3217 : BYTE            dxc;                    /* Data exception code       */
; 3218 : 
; 3219 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 44	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 34	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 3220 : 
; 3221 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000b3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_conve
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_conve
  000df	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196517
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3222 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_conve
  00162	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_conve
  00179	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 3223 : 
; 3224 :     /* Initialise the context for long DFP */
; 3225 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001d1	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001d6	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001db	e8 00 00 00 00	 call	 decContextDefault

; 3226 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  001e0	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e8	8b 54 24 34	 mov	 edx, DWORD PTR m3$[rsp]
  001ec	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001f1	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 3227 : 
; 3228 :     /* Load long DFP value from FP register r2 */
; 3229 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001f6	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001fe	48 8d 54 24 48	 lea	 rdx, QWORD PTR x2$[rsp]
  00203	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  00207	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 3230 :     decimal64ToNumber(&x2, &d2);

  0020c	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  00211	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  00216	e8 00 00 00 00	 call	 decimal64ToNumber

; 3231 : 
; 3232 :     /* Convert decimal number to 32-bit unsigned integer */
; 3233 :     n1 = dfp_number_to_u32(&d2, &set);

  0021b	48 8d 54 24 50	 lea	 rdx, QWORD PTR set$[rsp]
  00220	48 8d 4c 24 70	 lea	 rcx, QWORD PTR d2$[rsp]
  00225	e8 00 00 00 00	 call	 dfp_number_to_u32
  0022a	89 44 24 40	 mov	 DWORD PTR n1$[rsp], eax

; 3234 : 
; 3235 :     /* Check for exception condition */
; 3236 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0022e	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00236	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0023b	e8 00 00 00 00	 call	 z900_dfp_status_check
  00240	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3237 : 
; 3238 :     /* Load result into general register r1 */
; 3239 :     regs->GR_L(r1) = n1;

  00244	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00249	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	8b 54 24 40	 mov	 edx, DWORD PTR n1$[rsp]
  00255	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3240 : 
; 3241 :     /* Set condition code */
; 3242 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  0025c	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  00260	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  00265	85 c0		 test	 eax, eax
  00267	74 0a		 je	 SHORT $LN19@z900_conve
  00269	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv191[rsp], 3
  00271	eb 5f		 jmp	 SHORT $LN20@z900_conve
$LN19@z900_conve:
  00273	b8 02 00 00 00	 mov	 eax, 2
  00278	48 6b c0 00	 imul	 rax, rax, 0
  0027c	0f b7 44 04 7a	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  00281	85 c0		 test	 eax, eax
  00283	75 1d		 jne	 SHORT $LN15@z900_conve
  00285	83 7c 24 70 01	 cmp	 DWORD PTR d2$[rsp], 1
  0028a	75 16		 jne	 SHORT $LN15@z900_conve
  0028c	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00291	83 e0 70	 and	 eax, 112		; 00000070H
  00294	85 c0		 test	 eax, eax
  00296	75 0a		 jne	 SHORT $LN15@z900_conve
  00298	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv189[rsp], 0
  002a0	eb 28		 jmp	 SHORT $LN18@z900_conve
$LN15@z900_conve:
  002a2	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002a7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002ac	85 c0		 test	 eax, eax
  002ae	74 0a		 je	 SHORT $LN16@z900_conve
  002b0	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv188[rsp], 1
  002b8	eb 08		 jmp	 SHORT $LN17@z900_conve
$LN16@z900_conve:
  002ba	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv188[rsp], 2
$LN17@z900_conve:
  002c2	8b 44 24 28	 mov	 eax, DWORD PTR tv188[rsp]
  002c6	89 44 24 2c	 mov	 DWORD PTR tv189[rsp], eax
$LN18@z900_conve:
  002ca	8b 44 24 2c	 mov	 eax, DWORD PTR tv189[rsp]
  002ce	89 44 24 30	 mov	 DWORD PTR tv191[rsp], eax
$LN20@z900_conve:
  002d2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002da	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv191[rsp]
  002df	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3243 :                    decNumberIsZero(&d2) ? 0 :
; 3244 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3245 : 
; 3246 :     /* Raise data exception if error occurred */
; 3247 :     if (dxc != 0)

  002e2	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002e7	85 c0		 test	 eax, eax
  002e9	74 25		 je	 SHORT $LN13@z900_conve

; 3248 :     {
; 3249 :         regs->dxc = dxc;

  002eb	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002f0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f8	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3250 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002fe	ba 07 00 00 00	 mov	 edx, 7
  00303	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030b	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_conve:

; 3251 :     }
; 3252 : 
; 3253 : } /* end DEF_INST(convert_dfp_long_to_u32_reg) */

  00310	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00318	48 33 cc	 xor	 rcx, rsp
  0031b	e8 00 00 00 00	 call	 __security_check_cookie
  00320	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00327	c3		 ret	 0
z900_convert_dfp_long_to_u32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
tv193 = 44
tv194 = 48
tv196 = 52
m3$ = 56
r1$ = 60
n1$ = 64
m4$ = 68
set$ = 72
d2$ = 104
x2$ = 144
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
z900_convert_dfp_ext_to_u32_reg PROC

; 3159 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3160 : int             r1, r2;                 /* Values of R fields        */
; 3161 : int             m3, m4;                 /* Values of M fields        */
; 3162 : U32             n1;                     /* Result value              */
; 3163 : decimal128      x2;                     /* Extended DFP value        */
; 3164 : decNumber       d2;                     /* Working decimal number    */
; 3165 : decContext      set;                    /* Working context           */
; 3166 : BYTE            dxc;                    /* Data exception code       */
; 3167 : 
; 3168 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 44	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00070	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_conve
  00093	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 3169 : 
; 3170 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000b3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_conve
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_conve
  000df	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196488
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3171 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_conve
  00162	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_conve
  00179	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 3172 :     DFPREGPAIR_CHECK(r2, regs);

  001d1	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001d5	83 e0 02	 and	 eax, 2
  001d8	85 c0		 test	 eax, eax
  001da	74 1b		 je	 SHORT $LN13@z900_conve
  001dc	ba 06 00 00 00	 mov	 edx, 6
  001e1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 3173 : 
; 3174 :     /* Initialise the context for extended DFP */
; 3175 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001f7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001fc	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00201	e8 00 00 00 00	 call	 decContextDefault

; 3176 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00206	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020e	8b 54 24 38	 mov	 edx, DWORD PTR m3$[rsp]
  00212	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00217	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 3177 : 
; 3178 :     /* Load extended DFP value from FP register r2 */
; 3179 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  0021c	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00224	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  0022c	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00230	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 3180 :     decimal128ToNumber(&x2, &d2);

  00235	48 8d 54 24 68	 lea	 rdx, QWORD PTR d2$[rsp]
  0023a	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  00242	e8 00 00 00 00	 call	 decimal128ToNumber

; 3181 : 
; 3182 :     /* Convert decimal number to 32-bit unsigned integer */
; 3183 :     n1 = dfp_number_to_u32(&d2, &set);

  00247	48 8d 54 24 48	 lea	 rdx, QWORD PTR set$[rsp]
  0024c	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d2$[rsp]
  00251	e8 00 00 00 00	 call	 dfp_number_to_u32
  00256	89 44 24 40	 mov	 DWORD PTR n1$[rsp], eax

; 3184 : 
; 3185 :     /* Check for exception condition */
; 3186 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0025a	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00262	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00267	e8 00 00 00 00	 call	 z900_dfp_status_check
  0026c	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3187 : 
; 3188 :     /* Load result into general register r1 */
; 3189 :     regs->GR_L(r1) = n1;

  00270	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00275	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027d	8b 54 24 40	 mov	 edx, DWORD PTR n1$[rsp]
  00281	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3190 : 
; 3191 :     /* Set condition code */
; 3192 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  00288	8b 44 24 5c	 mov	 eax, DWORD PTR set$[rsp+20]
  0028c	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  00291	85 c0		 test	 eax, eax
  00293	74 0a		 je	 SHORT $LN20@z900_conve
  00295	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv196[rsp], 3
  0029d	eb 5f		 jmp	 SHORT $LN21@z900_conve
$LN20@z900_conve:
  0029f	b8 02 00 00 00	 mov	 eax, 2
  002a4	48 6b c0 00	 imul	 rax, rax, 0
  002a8	0f b7 44 04 72	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  002ad	85 c0		 test	 eax, eax
  002af	75 1d		 jne	 SHORT $LN16@z900_conve
  002b1	83 7c 24 68 01	 cmp	 DWORD PTR d2$[rsp], 1
  002b6	75 16		 jne	 SHORT $LN16@z900_conve
  002b8	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002bd	83 e0 70	 and	 eax, 112		; 00000070H
  002c0	85 c0		 test	 eax, eax
  002c2	75 0a		 jne	 SHORT $LN16@z900_conve
  002c4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
  002cc	eb 28		 jmp	 SHORT $LN19@z900_conve
$LN16@z900_conve:
  002ce	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002d3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002d8	85 c0		 test	 eax, eax
  002da	74 0a		 je	 SHORT $LN17@z900_conve
  002dc	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv193[rsp], 1
  002e4	eb 08		 jmp	 SHORT $LN18@z900_conve
$LN17@z900_conve:
  002e6	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv193[rsp], 2
$LN18@z900_conve:
  002ee	8b 44 24 2c	 mov	 eax, DWORD PTR tv193[rsp]
  002f2	89 44 24 30	 mov	 DWORD PTR tv194[rsp], eax
$LN19@z900_conve:
  002f6	8b 44 24 30	 mov	 eax, DWORD PTR tv194[rsp]
  002fa	89 44 24 34	 mov	 DWORD PTR tv196[rsp], eax
$LN21@z900_conve:
  002fe	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00306	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv196[rsp]
  0030b	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3193 :                    decNumberIsZero(&d2) ? 0 :
; 3194 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3195 : 
; 3196 :     /* Raise data exception if error occurred */
; 3197 :     if (dxc != 0)

  0030e	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00313	85 c0		 test	 eax, eax
  00315	74 25		 je	 SHORT $LN14@z900_conve

; 3198 :     {
; 3199 :         regs->dxc = dxc;

  00317	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0031c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00324	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3200 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0032a	ba 07 00 00 00	 mov	 edx, 7
  0032f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00337	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_conve:

; 3201 :     }
; 3202 : 
; 3203 : } /* end DEF_INST(convert_dfp_ext_to_u32_reg) */

  0033c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00344	48 33 cc	 xor	 rcx, rsp
  00347	e8 00 00 00 00	 call	 __security_check_cookie
  0034c	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00353	c3		 ret	 0
z900_convert_dfp_ext_to_u32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv188 = 40
tv189 = 44
tv191 = 48
m3$ = 52
r2$ = 56
r1$ = 60
n1$ = 64
m4$ = 68
x2$ = 72
set$ = 80
d2$ = 112
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
z900_convert_dfp_long_to_fix32_reg PROC

; 3109 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3110 : int             r1, r2;                 /* Values of R fields        */
; 3111 : int             m3, m4;                 /* Values of M fields        */
; 3112 : S32             n1;                     /* Result value              */
; 3113 : decimal64       x2;                     /* Long DFP value            */
; 3114 : decNumber       d2;                     /* Working decimal number    */
; 3115 : decContext      set;                    /* Working context           */
; 3116 : BYTE            dxc;                    /* Data exception code       */
; 3117 : 
; 3118 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 44	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 34	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 3119 : 
; 3120 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000b3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_conve
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_conve
  000df	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196460
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3121 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_conve
  00162	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_conve
  00179	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 3122 : 
; 3123 :     /* Initialise the context for long DFP */
; 3124 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001d1	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001d6	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001db	e8 00 00 00 00	 call	 decContextDefault

; 3125 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  001e0	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e8	8b 54 24 34	 mov	 edx, DWORD PTR m3$[rsp]
  001ec	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001f1	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 3126 : 
; 3127 :     /* Load long DFP value from FP register r2 */
; 3128 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  001f6	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001fe	48 8d 54 24 48	 lea	 rdx, QWORD PTR x2$[rsp]
  00203	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  00207	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal64

; 3129 :     decimal64ToNumber(&x2, &d2);

  0020c	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  00211	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  00216	e8 00 00 00 00	 call	 decimal64ToNumber

; 3130 : 
; 3131 :     /* Convert decimal number to 32-bit binary integer */
; 3132 :     n1 = dfp_number_to_fix32(&d2, &set);

  0021b	48 8d 54 24 50	 lea	 rdx, QWORD PTR set$[rsp]
  00220	48 8d 4c 24 70	 lea	 rcx, QWORD PTR d2$[rsp]
  00225	e8 00 00 00 00	 call	 dfp_number_to_fix32
  0022a	89 44 24 40	 mov	 DWORD PTR n1$[rsp], eax

; 3133 : 
; 3134 :     /* Check for exception condition */
; 3135 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0022e	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00236	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0023b	e8 00 00 00 00	 call	 z900_dfp_status_check
  00240	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3136 : 
; 3137 :     /* Load result into general register r1 */
; 3138 :     regs->GR_L(r1) = n1;

  00244	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00249	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	8b 54 24 40	 mov	 edx, DWORD PTR n1$[rsp]
  00255	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3139 : 
; 3140 :     /* Set condition code */
; 3141 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  0025c	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  00260	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  00265	85 c0		 test	 eax, eax
  00267	74 0a		 je	 SHORT $LN19@z900_conve
  00269	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv191[rsp], 3
  00271	eb 5f		 jmp	 SHORT $LN20@z900_conve
$LN19@z900_conve:
  00273	b8 02 00 00 00	 mov	 eax, 2
  00278	48 6b c0 00	 imul	 rax, rax, 0
  0027c	0f b7 44 04 7a	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  00281	85 c0		 test	 eax, eax
  00283	75 1d		 jne	 SHORT $LN15@z900_conve
  00285	83 7c 24 70 01	 cmp	 DWORD PTR d2$[rsp], 1
  0028a	75 16		 jne	 SHORT $LN15@z900_conve
  0028c	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00291	83 e0 70	 and	 eax, 112		; 00000070H
  00294	85 c0		 test	 eax, eax
  00296	75 0a		 jne	 SHORT $LN15@z900_conve
  00298	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv189[rsp], 0
  002a0	eb 28		 jmp	 SHORT $LN18@z900_conve
$LN15@z900_conve:
  002a2	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002a7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002ac	85 c0		 test	 eax, eax
  002ae	74 0a		 je	 SHORT $LN16@z900_conve
  002b0	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv188[rsp], 1
  002b8	eb 08		 jmp	 SHORT $LN17@z900_conve
$LN16@z900_conve:
  002ba	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv188[rsp], 2
$LN17@z900_conve:
  002c2	8b 44 24 28	 mov	 eax, DWORD PTR tv188[rsp]
  002c6	89 44 24 2c	 mov	 DWORD PTR tv189[rsp], eax
$LN18@z900_conve:
  002ca	8b 44 24 2c	 mov	 eax, DWORD PTR tv189[rsp]
  002ce	89 44 24 30	 mov	 DWORD PTR tv191[rsp], eax
$LN20@z900_conve:
  002d2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002da	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv191[rsp]
  002df	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3142 :                    decNumberIsZero(&d2) ? 0 :
; 3143 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3144 : 
; 3145 :     /* Raise data exception if error occurred */
; 3146 :     if (dxc != 0)

  002e2	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002e7	85 c0		 test	 eax, eax
  002e9	74 25		 je	 SHORT $LN13@z900_conve

; 3147 :     {
; 3148 :         regs->dxc = dxc;

  002eb	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002f0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f8	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3149 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002fe	ba 07 00 00 00	 mov	 edx, 7
  00303	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030b	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_conve:

; 3150 :     }
; 3151 : 
; 3152 : } /* end DEF_INST(convert_dfp_long_to_fix32_reg) */

  00310	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00318	48 33 cc	 xor	 rcx, rsp
  0031b	e8 00 00 00 00	 call	 __security_check_cookie
  00320	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00327	c3		 ret	 0
z900_convert_dfp_long_to_fix32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
tv193 = 44
tv194 = 48
tv196 = 52
m3$ = 56
r1$ = 60
n1$ = 64
m4$ = 68
set$ = 72
d2$ = 104
x2$ = 144
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
z900_convert_dfp_ext_to_fix32_reg PROC

; 3058 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3059 : int             r1, r2;                 /* Values of R fields        */
; 3060 : int             m3, m4;                 /* Values of M fields        */
; 3061 : S32             n1;                     /* Result value              */
; 3062 : decimal128      x2;                     /* Extended DFP value        */
; 3063 : decNumber       d2;                     /* Working decimal number    */
; 3064 : decContext      set;                    /* Working context           */
; 3065 : BYTE            dxc;                    /* Data exception code       */
; 3066 : 
; 3067 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 44	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00070	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_conve
  00093	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 3068 : 
; 3069 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000b3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_conve
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_conve
  000df	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196431
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 3070 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_conve
  00162	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_conve
  00179	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 3071 :     DFPREGPAIR_CHECK(r2, regs);

  001d1	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  001d5	83 e0 02	 and	 eax, 2
  001d8	85 c0		 test	 eax, eax
  001da	74 1b		 je	 SHORT $LN13@z900_conve
  001dc	ba 06 00 00 00	 mov	 edx, 6
  001e1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 3072 : 
; 3073 :     /* Initialise the context for extended DFP */
; 3074 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001f7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001fc	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00201	e8 00 00 00 00	 call	 decContextDefault

; 3075 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00206	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020e	8b 54 24 38	 mov	 edx, DWORD PTR m3$[rsp]
  00212	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00217	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 3076 : 
; 3077 :     /* Load extended DFP value from FP register r2 */
; 3078 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  0021c	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00224	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  0022c	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00230	e8 00 00 00 00	 call	 z900_dfp_reg_to_decimal128

; 3079 :     decimal128ToNumber(&x2, &d2);

  00235	48 8d 54 24 68	 lea	 rdx, QWORD PTR d2$[rsp]
  0023a	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  00242	e8 00 00 00 00	 call	 decimal128ToNumber

; 3080 : 
; 3081 :     /* Convert decimal number to 32-bit binary integer */
; 3082 :     n1 = dfp_number_to_fix32(&d2, &set);

  00247	48 8d 54 24 48	 lea	 rdx, QWORD PTR set$[rsp]
  0024c	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d2$[rsp]
  00251	e8 00 00 00 00	 call	 dfp_number_to_fix32
  00256	89 44 24 40	 mov	 DWORD PTR n1$[rsp], eax

; 3083 : 
; 3084 :     /* Check for exception condition */
; 3085 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0025a	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00262	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00267	e8 00 00 00 00	 call	 z900_dfp_status_check
  0026c	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3086 : 
; 3087 :     /* Load result into general register r1 */
; 3088 :     regs->GR_L(r1) = n1;

  00270	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  00275	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027d	8b 54 24 40	 mov	 edx, DWORD PTR n1$[rsp]
  00281	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3089 : 
; 3090 :     /* Set condition code */
; 3091 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  00288	8b 44 24 5c	 mov	 eax, DWORD PTR set$[rsp+20]
  0028c	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  00291	85 c0		 test	 eax, eax
  00293	74 0a		 je	 SHORT $LN20@z900_conve
  00295	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv196[rsp], 3
  0029d	eb 5f		 jmp	 SHORT $LN21@z900_conve
$LN20@z900_conve:
  0029f	b8 02 00 00 00	 mov	 eax, 2
  002a4	48 6b c0 00	 imul	 rax, rax, 0
  002a8	0f b7 44 04 72	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  002ad	85 c0		 test	 eax, eax
  002af	75 1d		 jne	 SHORT $LN16@z900_conve
  002b1	83 7c 24 68 01	 cmp	 DWORD PTR d2$[rsp], 1
  002b6	75 16		 jne	 SHORT $LN16@z900_conve
  002b8	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002bd	83 e0 70	 and	 eax, 112		; 00000070H
  002c0	85 c0		 test	 eax, eax
  002c2	75 0a		 jne	 SHORT $LN16@z900_conve
  002c4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
  002cc	eb 28		 jmp	 SHORT $LN19@z900_conve
$LN16@z900_conve:
  002ce	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002d3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002d8	85 c0		 test	 eax, eax
  002da	74 0a		 je	 SHORT $LN17@z900_conve
  002dc	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv193[rsp], 1
  002e4	eb 08		 jmp	 SHORT $LN18@z900_conve
$LN17@z900_conve:
  002e6	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv193[rsp], 2
$LN18@z900_conve:
  002ee	8b 44 24 2c	 mov	 eax, DWORD PTR tv193[rsp]
  002f2	89 44 24 30	 mov	 DWORD PTR tv194[rsp], eax
$LN19@z900_conve:
  002f6	8b 44 24 30	 mov	 eax, DWORD PTR tv194[rsp]
  002fa	89 44 24 34	 mov	 DWORD PTR tv196[rsp], eax
$LN21@z900_conve:
  002fe	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00306	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv196[rsp]
  0030b	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3092 :                    decNumberIsZero(&d2) ? 0 :
; 3093 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3094 : 
; 3095 :     /* Raise data exception if error occurred */
; 3096 :     if (dxc != 0)

  0030e	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00313	85 c0		 test	 eax, eax
  00315	74 25		 je	 SHORT $LN14@z900_conve

; 3097 :     {
; 3098 :         regs->dxc = dxc;

  00317	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0031c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00324	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3099 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0032a	ba 07 00 00 00	 mov	 edx, 7
  0032f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00337	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_conve:

; 3100 :     }
; 3101 : 
; 3102 : } /* end DEF_INST(convert_dfp_ext_to_fix32_reg) */

  0033c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00344	48 33 cc	 xor	 rcx, rsp
  00347	e8 00 00 00 00	 call	 __security_check_cookie
  0034c	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00353	c3		 ret	 0
z900_convert_dfp_ext_to_fix32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
dxc$ = 36
m3$ = 40
r2$ = 44
r1$ = 48
m4$ = 52
n2$ = 56
x1$ = 64
set$ = 72
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
z900_convert_u64_to_dfp_long_reg PROC

; 2590 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2591 : int             r1, r2;                 /* Values of R fields        */
; 2592 : int             m3, m4;                 /* Values of M fields        */
; 2593 : U64             n2;                     /* Value of R2 register      */
; 2594 : decimal64       x1;                     /* Long DFP value            */
; 2595 : decNumber       d1;                     /* Working decimal number    */
; 2596 : decContext      set;                    /* Working context           */
; 2597 : BYTE            dxc;                    /* Data exception code       */
; 2598 : 
; 2599 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2600 : 
; 2601 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000b3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_conve
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_conve
  000df	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196140
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2602 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_conve
  00162	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_conve
  00179	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2603 : 
; 2604 :     /* Initialise the context for long DFP */
; 2605 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001d1	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001d6	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001db	e8 00 00 00 00	 call	 decContextDefault

; 2606 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  001e0	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e8	8b 54 24 28	 mov	 edx, DWORD PTR m3$[rsp]
  001ec	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001f1	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 2607 : 
; 2608 :     /* Load 64-bit unsigned value from r2 register */
; 2609 :     n2 = regs->GR_G(r2);

  001f6	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  001fb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00203	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0020b	48 89 44 24 38	 mov	 QWORD PTR n2$[rsp], rax

; 2610 : 
; 2611 :     /* Convert unsigned binary integer to long DFP format */
; 2612 :     dfp_number_from_u64(&d1, n2, &set);

  00210	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  00215	48 8b 54 24 38	 mov	 rdx, QWORD PTR n2$[rsp]
  0021a	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  0021f	e8 00 00 00 00	 call	 dfp_number_from_u64

; 2613 :     decimal64FromNumber(&x1, &d1, &set);

  00224	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  00229	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  0022e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00233	e8 00 00 00 00	 call	 decimal64FromNumber

; 2614 : 
; 2615 :     /* Check for exception condition */
; 2616 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00238	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00240	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00245	e8 00 00 00 00	 call	 z900_dfp_status_check
  0024a	88 44 24 24	 mov	 BYTE PTR dxc$[rsp], al

; 2617 : 
; 2618 :     /* Load result into FP register r1 */
; 2619 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  0024e	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00256	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  0025b	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  0025f	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 2620 : 
; 2621 : } /* end DEF_INST(convert_u64_to_dfp_long_reg) */

  00264	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0026c	48 33 cc	 xor	 rcx, rsp
  0026f	e8 00 00 00 00	 call	 __security_check_cookie
  00274	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0027b	c3		 ret	 0
z900_convert_u64_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
m3$ = 40
r2$ = 44
m4$ = 48
n2$ = 56
set$ = 64
x1$ = 96
d1$ = 112
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
z900_convert_u64_to_dfp_ext_reg PROC

; 2555 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2556 : int             r1, r2;                 /* Values of R fields        */
; 2557 : int             m3, m4;                 /* Values of M fields        */
; 2558 : U64             n2;                     /* Value of R2 register      */
; 2559 : decimal128      x1;                     /* Extended DFP value        */
; 2560 : decNumber       d1;                     /* Working decimal number    */
; 2561 : decContext      set;                    /* Working context           */
; 2562 : 
; 2563 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 30	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2564 : 
; 2565 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000b3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_conve
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_conve
  000df	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196112
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2566 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_conve
  00162	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_conve
  00179	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2567 :     DFPREGPAIR_CHECK(r1, regs);

  001d1	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001d5	83 e0 02	 and	 eax, 2
  001d8	85 c0		 test	 eax, eax
  001da	74 1b		 je	 SHORT $LN13@z900_conve
  001dc	ba 06 00 00 00	 mov	 edx, 6
  001e1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 2568 : 
; 2569 :     /* Initialise the context for extended DFP */
; 2570 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001f7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001fc	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  00201	e8 00 00 00 00	 call	 decContextDefault

; 2571 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00206	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020e	8b 54 24 28	 mov	 edx, DWORD PTR m3$[rsp]
  00212	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  00217	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 2572 : 
; 2573 :     /* Load 64-bit unsigned value from r2 register */
; 2574 :     n2 = regs->GR_G(r2);

  0021c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  00221	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00231	48 89 44 24 38	 mov	 QWORD PTR n2$[rsp], rax

; 2575 : 
; 2576 :     /* Convert unsigned binary integer to extended DFP format */
; 2577 :     dfp_number_from_u64(&d1, n2, &set);

  00236	4c 8d 44 24 40	 lea	 r8, QWORD PTR set$[rsp]
  0023b	48 8b 54 24 38	 mov	 rdx, QWORD PTR n2$[rsp]
  00240	48 8d 4c 24 70	 lea	 rcx, QWORD PTR d1$[rsp]
  00245	e8 00 00 00 00	 call	 dfp_number_from_u64

; 2578 :     decimal128FromNumber(&x1, &d1, &set);

  0024a	4c 8d 44 24 40	 lea	 r8, QWORD PTR set$[rsp]
  0024f	48 8d 54 24 70	 lea	 rdx, QWORD PTR d1$[rsp]
  00254	48 8d 4c 24 60	 lea	 rcx, QWORD PTR x1$[rsp]
  00259	e8 00 00 00 00	 call	 decimal128FromNumber

; 2579 : 
; 2580 :     /* Load result into FP register r1 */
; 2581 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  0025e	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00266	48 8d 54 24 60	 lea	 rdx, QWORD PTR x1$[rsp]
  0026b	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  0026f	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 2582 : 
; 2583 : } /* end DEF_INST(convert_u64_to_dfp_ext_reg) */

  00274	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0027c	48 33 cc	 xor	 rcx, rsp
  0027f	e8 00 00 00 00	 call	 __security_check_cookie
  00284	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0028b	c3		 ret	 0
z900_convert_u64_to_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
dxc$ = 36
m3$ = 40
r2$ = 44
n2$ = 48
r1$ = 52
m4$ = 56
x1$ = 64
set$ = 72
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
z900_convert_u32_to_dfp_long_reg PROC

; 2437 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2438 : int             r1, r2;                 /* Values of R fields        */
; 2439 : int             m3, m4;                 /* Values of M fields        */
; 2440 : U32             n2;                     /* Value of R2 register      */
; 2441 : decimal64       x1;                     /* Long DFP value            */
; 2442 : decNumber       d1;                     /* Working decimal number    */
; 2443 : decContext      set;                    /* Working context           */
; 2444 : BYTE            dxc;                    /* Data exception code       */
; 2445 : 
; 2446 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 38	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2447 : 
; 2448 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000b3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_conve
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_conve
  000df	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196033
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2449 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_conve
  00162	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_conve
  00179	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2450 : 
; 2451 :     /* Initialise the context for long DFP */
; 2452 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001d1	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001d6	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001db	e8 00 00 00 00	 call	 decContextDefault

; 2453 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  001e0	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e8	8b 54 24 28	 mov	 edx, DWORD PTR m3$[rsp]
  001ec	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001f1	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 2454 : 
; 2455 :     /* Load 32-bit unsigned value from r2 register */
; 2456 :     n2 = regs->GR_L(r2);

  001f6	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  001fb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00203	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0020a	89 44 24 30	 mov	 DWORD PTR n2$[rsp], eax

; 2457 : 
; 2458 :     /* Convert unsigned binary integer to long DFP format */
; 2459 :     dfp_number_from_u32(&d1, n2, &set);

  0020e	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  00213	8b 54 24 30	 mov	 edx, DWORD PTR n2$[rsp]
  00217	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  0021c	e8 00 00 00 00	 call	 dfp_number_from_u32

; 2460 :     decimal64FromNumber(&x1, &d1, &set);

  00221	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  00226	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  0022b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00230	e8 00 00 00 00	 call	 decimal64FromNumber

; 2461 : 
; 2462 :     /* Check for exception condition */
; 2463 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00235	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0023d	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00242	e8 00 00 00 00	 call	 z900_dfp_status_check
  00247	88 44 24 24	 mov	 BYTE PTR dxc$[rsp], al

; 2464 : 
; 2465 :     /* Load result into FP register r1 */
; 2466 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  0024b	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00253	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  00258	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  0025c	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 2467 : 
; 2468 : } /* end DEF_INST(convert_u32_to_dfp_long_reg) */

  00261	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00269	48 33 cc	 xor	 rcx, rsp
  0026c	e8 00 00 00 00	 call	 __security_check_cookie
  00271	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00278	c3		 ret	 0
z900_convert_u32_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
m3$ = 40
r2$ = 44
n2$ = 48
m4$ = 52
set$ = 56
x1$ = 88
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
z900_convert_u32_to_dfp_ext_reg PROC

; 2402 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2403 : int             r1, r2;                 /* Values of R fields        */
; 2404 : int             m3, m4;                 /* Values of M fields        */
; 2405 : U32             n2;                     /* Value of R2 register      */
; 2406 : decimal128      x1;                     /* Extended DFP value        */
; 2407 : decNumber       d1;                     /* Working decimal number    */
; 2408 : decContext      set;                    /* Working context           */
; 2409 : 
; 2410 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2411 : 
; 2412 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000b3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_conve
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_conve
  000df	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196005
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2413 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_conve
  00162	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_conve
  00179	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2414 :     DFPREGPAIR_CHECK(r1, regs);

  001d1	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001d5	83 e0 02	 and	 eax, 2
  001d8	85 c0		 test	 eax, eax
  001da	74 1b		 je	 SHORT $LN13@z900_conve
  001dc	ba 06 00 00 00	 mov	 edx, 6
  001e1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 2415 : 
; 2416 :     /* Initialise the context for extended DFP */
; 2417 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001f7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001fc	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  00201	e8 00 00 00 00	 call	 decContextDefault

; 2418 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00206	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020e	8b 54 24 28	 mov	 edx, DWORD PTR m3$[rsp]
  00212	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  00217	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 2419 : 
; 2420 :     /* Load 32-bit unsigned value from r2 register */
; 2421 :     n2 = regs->GR_L(r2);

  0021c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  00221	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00230	89 44 24 30	 mov	 DWORD PTR n2$[rsp], eax

; 2422 : 
; 2423 :     /* Convert unsigned binary integer to extended DFP format */
; 2424 :     dfp_number_from_u32(&d1, n2, &set);

  00234	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  00239	8b 54 24 30	 mov	 edx, DWORD PTR n2$[rsp]
  0023d	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  00242	e8 00 00 00 00	 call	 dfp_number_from_u32

; 2425 :     decimal128FromNumber(&x1, &d1, &set);

  00247	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  0024c	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  00251	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  00256	e8 00 00 00 00	 call	 decimal128FromNumber

; 2426 : 
; 2427 :     /* Load result into FP register r1 */
; 2428 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  0025b	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00263	48 8d 54 24 58	 lea	 rdx, QWORD PTR x1$[rsp]
  00268	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  0026c	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 2429 : 
; 2430 : } /* end DEF_INST(convert_u32_to_dfp_ext_reg) */

  00271	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00279	48 33 cc	 xor	 rcx, rsp
  0027c	e8 00 00 00 00	 call	 __security_check_cookie
  00281	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00288	c3		 ret	 0
z900_convert_u32_to_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
dxc$ = 36
m3$ = 40
r2$ = 44
n2$ = 48
r1$ = 52
m4$ = 56
x1$ = 64
set$ = 72
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
z900_convert_fix32_to_dfp_long_reg PROC

; 2364 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2365 : int             r1, r2;                 /* Values of R fields        */
; 2366 : int             m3, m4;                 /* Values of M fields        */
; 2367 : S32             n2;                     /* Value of R2 register      */
; 2368 : decimal64       x1;                     /* Long DFP value            */
; 2369 : decNumber       d1;                     /* Working decimal number    */
; 2370 : decContext      set;                    /* Working context           */
; 2371 : BYTE            dxc;                    /* Data exception code       */
; 2372 : 
; 2373 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 38	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2374 : 
; 2375 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000b3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_conve
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_conve
  000df	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195979
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2376 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_conve
  00162	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_conve
  00179	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2377 : 
; 2378 :     /* Initialise the context for long DFP */
; 2379 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001d1	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001d6	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001db	e8 00 00 00 00	 call	 decContextDefault

; 2380 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  001e0	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e8	8b 54 24 28	 mov	 edx, DWORD PTR m3$[rsp]
  001ec	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001f1	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 2381 : 
; 2382 :     /* Load 32-bit binary integer value from r2 register */
; 2383 :     n2 = (S32)(regs->GR_L(r2));

  001f6	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  001fb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00203	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0020a	89 44 24 30	 mov	 DWORD PTR n2$[rsp], eax

; 2384 : 
; 2385 :     /* Convert binary integer to long DFP format */
; 2386 :     dfp_number_from_fix32(&d1, n2, &set);

  0020e	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  00213	8b 54 24 30	 mov	 edx, DWORD PTR n2$[rsp]
  00217	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  0021c	e8 00 00 00 00	 call	 dfp_number_from_fix32

; 2387 :     decimal64FromNumber(&x1, &d1, &set);

  00221	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  00226	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  0022b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00230	e8 00 00 00 00	 call	 decimal64FromNumber

; 2388 : 
; 2389 :     /* Check for exception condition */
; 2390 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00235	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0023d	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00242	e8 00 00 00 00	 call	 z900_dfp_status_check
  00247	88 44 24 24	 mov	 BYTE PTR dxc$[rsp], al

; 2391 : 
; 2392 :     /* Load result into FP register r1 */
; 2393 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  0024b	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00253	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  00258	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  0025c	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal64

; 2394 : 
; 2395 : } /* end DEF_INST(convert_fix32_to_dfp_long_reg) */

  00261	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00269	48 33 cc	 xor	 rcx, rsp
  0026c	e8 00 00 00 00	 call	 __security_check_cookie
  00271	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00278	c3		 ret	 0
z900_convert_fix32_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
m3$ = 40
r2$ = 44
n2$ = 48
m4$ = 52
set$ = 56
x1$ = 88
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
z900_convert_fix32_to_dfp_ext_reg PROC

; 2329 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2330 : int             r1, r2;                 /* Values of R fields        */
; 2331 : int             m3, m4;                 /* Values of M fields        */
; 2332 : S32             n2;                     /* Value of R2 register      */
; 2333 : decimal128      x1;                     /* Extended DFP value        */
; 2334 : decNumber       d1;                     /* Working decimal number    */
; 2335 : decContext      set;                    /* Working context           */
; 2336 : 
; 2337 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN8@z900_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@z900_conve
$LN7@z900_conve:

; 2338 : 
; 2339 :     TXF_FLOAT_INSTR_CHECK( regs );

  000a8	33 c0		 xor	 eax, eax
  000aa	83 f8 01	 cmp	 eax, 1
  000ad	0f 84 81 00 00
	00		 je	 $LN9@z900_conve
  000b3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c2	85 c0		 test	 eax, eax
  000c4	74 6e		 je	 SHORT $LN9@z900_conve
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 29		 jne	 SHORT $LN10@z900_conve
  000cc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  000db	85 c0		 test	 eax, eax
  000dd	75 16		 jne	 SHORT $LN10@z900_conve
  000df	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  000ee	83 e0 04	 and	 eax, 4
  000f1	85 c0		 test	 eax, eax
  000f3	75 3f		 jne	 SHORT $LN9@z900_conve
$LN10@z900_conve:
  000f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00103	0f ba e8 0b	 bts	 eax, 11
  00107	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195950
  0011c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00122	ba 02 00 00 00	 mov	 edx, 2
  00127	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_conve:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 6a ff ff
	ff		 jne	 $LN7@z900_conve

; 2340 :     DFPINST_CHECK(regs);

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00157	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0015d	48 85 c0	 test	 rax, rax
  00160	74 42		 je	 SHORT $LN12@z900_conve
  00162	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 58		 je	 SHORT $LN11@z900_conve
  00179	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00188	b9 08 00 00 00	 mov	 ecx, 8
  0018d	48 6b c9 01	 imul	 rcx, rcx, 1
  00191	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  00199	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0019f	48 85 c0	 test	 rax, rax
  001a2	75 2d		 jne	 SHORT $LN11@z900_conve
$LN12@z900_conve:
  001a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  001b6	ba 07 00 00 00	 mov	 edx, 7
  001bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_conve:

; 2341 :     DFPREGPAIR_CHECK(r1, regs);

  001d1	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  001d5	83 e0 02	 and	 eax, 2
  001d8	85 c0		 test	 eax, eax
  001da	74 1b		 je	 SHORT $LN13@z900_conve
  001dc	ba 06 00 00 00	 mov	 edx, 6
  001e1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_conve:

; 2342 : 
; 2343 :     /* Initialise the context for extended DFP */
; 2344 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001f7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001fc	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  00201	e8 00 00 00 00	 call	 decContextDefault

; 2345 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00206	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020e	8b 54 24 28	 mov	 edx, DWORD PTR m3$[rsp]
  00212	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  00217	e8 00 00 00 00	 call	 z900_dfp_rounding_mode

; 2346 : 
; 2347 :     /* Load 32-bit binary integer value from r2 register */
; 2348 :     n2 = (S32)(regs->GR_L(r2));

  0021c	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  00221	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00230	89 44 24 30	 mov	 DWORD PTR n2$[rsp], eax

; 2349 : 
; 2350 :     /* Convert binary integer to extended DFP format */
; 2351 :     dfp_number_from_fix32(&d1, n2, &set);

  00234	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  00239	8b 54 24 30	 mov	 edx, DWORD PTR n2$[rsp]
  0023d	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  00242	e8 00 00 00 00	 call	 dfp_number_from_fix32

; 2352 :     decimal128FromNumber(&x1, &d1, &set);

  00247	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  0024c	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  00251	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  00256	e8 00 00 00 00	 call	 decimal128FromNumber

; 2353 : 
; 2354 :     /* Load result into FP register r1 */
; 2355 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  0025b	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00263	48 8d 54 24 58	 lea	 rdx, QWORD PTR x1$[rsp]
  00268	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  0026c	e8 00 00 00 00	 call	 z900_dfp_reg_from_decimal128

; 2356 : 
; 2357 : } /* end DEF_INST(convert_fix32_to_dfp_ext_reg) */

  00271	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00279	48 33 cc	 xor	 rcx, rsp
  0027c	e8 00 00 00 00	 call	 __security_check_cookie
  00281	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00288	c3		 ret	 0
z900_convert_fix32_to_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
suppress$ = 36
tv128 = 40
tv130 = 44
tv153 = 48
tv161 = 52
tv175 = 56
pset$ = 80
regs$ = 88
s370_dfp_status_check PROC

; 1858 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1859 : BYTE    dxc = 0;                        /* Data exception code       */

  0000e	c6 44 24 20 00	 mov	 BYTE PTR dxc$[rsp], 0

; 1860 : int     suppress = 0;                   /* 1=suppress, 0=complete    */

  00013	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR suppress$[rsp], 0

; 1861 : 
; 1862 :     if (pset->status & DEC_IEEE_854_Invalid_operation)

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00020	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00023	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  00028	85 c0		 test	 eax, eax
  0002a	74 42		 je	 SHORT $LN2@s370_dfp_s

; 1863 :     {
; 1864 :         /* An IEEE-invalid-operation condition was recognized */
; 1865 :         if ((regs->fpc & FPC_MASK_IMI) == 0)

  0002c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00031	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00037	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0003c	85 c0		 test	 eax, eax
  0003e	75 1c		 jne	 SHORT $LN4@s370_dfp_s

; 1866 :         {
; 1867 :             regs->fpc |= FPC_FLAG_SFI;

  00040	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00045	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0004b	0f ba e8 17	 bts	 eax, 23
  0004f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1868 :         }

  0005a	eb 0d		 jmp	 SHORT $LN5@s370_dfp_s
$LN4@s370_dfp_s:

; 1869 :         else
; 1870 :         {
; 1871 :             dxc = DXC_IEEE_INVALID_OP;

  0005c	c6 44 24 20 80	 mov	 BYTE PTR dxc$[rsp], 128	; 00000080H

; 1872 :             suppress = 1;

  00061	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR suppress$[rsp], 1
$LN5@s370_dfp_s:

; 1873 :         }
; 1874 :     }

  00069	e9 4c 02 00 00	 jmp	 $LN3@s370_dfp_s
$LN2@s370_dfp_s:

; 1875 :     else if (pset->status & DEC_IEEE_854_Division_by_zero)

  0006e	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00073	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00076	83 e0 02	 and	 eax, 2
  00079	85 c0		 test	 eax, eax
  0007b	74 42		 je	 SHORT $LN6@s370_dfp_s

; 1876 :     {
; 1877 :         /* An IEEE-division-by-zero condition was recognized */
; 1878 :         if ((regs->fpc & FPC_MASK_IMZ) == 0)

  0007d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00082	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00088	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0008d	85 c0		 test	 eax, eax
  0008f	75 1c		 jne	 SHORT $LN8@s370_dfp_s

; 1879 :         {
; 1880 :             /* Division-by-zero mask is zero */
; 1881 :             regs->fpc |= FPC_FLAG_SFZ;

  00091	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00096	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0009c	0f ba e8 16	 bts	 eax, 22
  000a0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1882 :         }

  000ab	eb 0d		 jmp	 SHORT $LN9@s370_dfp_s
$LN8@s370_dfp_s:

; 1883 :         else
; 1884 :         {
; 1885 :             /* Division-by-zero mask is one */
; 1886 :             dxc = DXC_IEEE_DIV_ZERO;

  000ad	c6 44 24 20 40	 mov	 BYTE PTR dxc$[rsp], 64	; 00000040H

; 1887 :             suppress = 1;

  000b2	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR suppress$[rsp], 1
$LN9@s370_dfp_s:

; 1888 :         }
; 1889 :     }

  000ba	e9 fb 01 00 00	 jmp	 $LN7@s370_dfp_s
$LN6@s370_dfp_s:

; 1890 :     else if (pset->status & DEC_IEEE_854_Overflow)

  000bf	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  000c4	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000c7	25 00 02 00 00	 and	 eax, 512		; 00000200H
  000cc	85 c0		 test	 eax, eax
  000ce	0f 84 82 00 00
	00		 je	 $LN10@s370_dfp_s

; 1891 :     {
; 1892 :         /* An IEEE-overflow condition was recognized */
; 1893 :         if ((regs->fpc & FPC_MASK_IMO) == 0)

  000d4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  000df	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  000e4	85 c0		 test	 eax, eax
  000e6	75 1c		 jne	 SHORT $LN12@s370_dfp_s

; 1894 :         {
; 1895 :             /* Overflow mask is zero */
; 1896 :             regs->fpc |= FPC_FLAG_SFO;

  000e8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  000f3	0f ba e8 15	 bts	 eax, 21
  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1897 :         }

  00102	eb 4d		 jmp	 SHORT $LN13@s370_dfp_s
$LN12@s370_dfp_s:

; 1898 :         else
; 1899 :         {
; 1900 :             /* Overflow mask is one */
; 1901 :             dxc = (pset->status & DEC_IEEE_854_Inexact) ?

  00104	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00109	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0010c	83 e0 20	 and	 eax, 32			; 00000020H
  0010f	85 c0		 test	 eax, eax
  00111	74 2d		 je	 SHORT $LN30@s370_dfp_s
  00113	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00118	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0011b	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00120	85 c0		 test	 eax, eax
  00122	74 0a		 je	 SHORT $LN28@s370_dfp_s
  00124	c7 44 24 28 2c
	00 00 00	 mov	 DWORD PTR tv128[rsp], 44 ; 0000002cH
  0012c	eb 08		 jmp	 SHORT $LN29@s370_dfp_s
$LN28@s370_dfp_s:
  0012e	c7 44 24 28 28
	00 00 00	 mov	 DWORD PTR tv128[rsp], 40 ; 00000028H
$LN29@s370_dfp_s:
  00136	8b 44 24 28	 mov	 eax, DWORD PTR tv128[rsp]
  0013a	89 44 24 2c	 mov	 DWORD PTR tv130[rsp], eax
  0013e	eb 08		 jmp	 SHORT $LN31@s370_dfp_s
$LN30@s370_dfp_s:
  00140	c7 44 24 2c 20
	00 00 00	 mov	 DWORD PTR tv130[rsp], 32 ; 00000020H
$LN31@s370_dfp_s:
  00148	0f b6 44 24 2c	 movzx	 eax, BYTE PTR tv130[rsp]
  0014d	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al
$LN13@s370_dfp_s:

; 1902 :                     ((pset->status & DEC_Rounded) ?
; 1903 :                         DXC_IEEE_OF_INEX_INCR :
; 1904 :                         DXC_IEEE_OF_INEX_TRUNC ) :
; 1905 :                         DXC_IEEE_OF_EXACT ;
; 1906 :         }
; 1907 :     }

  00151	e9 64 01 00 00	 jmp	 $LN11@s370_dfp_s
$LN10@s370_dfp_s:

; 1908 :     else if (pset->status & DEC_IEEE_854_Underflow)

  00156	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  0015b	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0015e	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00163	85 c0		 test	 eax, eax
  00165	0f 84 e4 00 00
	00		 je	 $LN14@s370_dfp_s

; 1909 :     {
; 1910 :         /* An IEEE-underflow condition was recognized */
; 1911 :         if ((regs->fpc & FPC_MASK_IMU) == 0)

  0016b	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00170	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00176	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  0017b	85 c0		 test	 eax, eax
  0017d	0f 85 88 00 00
	00		 jne	 $LN16@s370_dfp_s

; 1912 :         {
; 1913 :             /* Underflow mask is zero */
; 1914 :             if (pset->status & DEC_IEEE_854_Inexact)

  00183	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00188	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0018b	83 e0 20	 and	 eax, 32			; 00000020H
  0018e	85 c0		 test	 eax, eax
  00190	74 77		 je	 SHORT $LN18@s370_dfp_s

; 1915 :             {
; 1916 :                 if ((regs->fpc & FPC_MASK_IMX) == 0)

  00192	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00197	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0019d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001a2	85 c0		 test	 eax, eax
  001a4	75 1d		 jne	 SHORT $LN19@s370_dfp_s

; 1917 :                 {
; 1918 :                     /* Inexact result with inexact mask zero */
; 1919 :                     regs->fpc |= (FPC_FLAG_SFU | FPC_FLAG_SFX);

  001a6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001ab	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001b1	0d 00 00 18 00	 or	 eax, 1572864		; 00180000H
  001b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001bb	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1920 :                 }

  001c1	eb 46		 jmp	 SHORT $LN20@s370_dfp_s
$LN19@s370_dfp_s:

; 1921 :                 else
; 1922 :                 {
; 1923 :                     /* Inexact result with inexact mask one */
; 1924 :                     regs->fpc |= FPC_FLAG_SFU;

  001c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001c8	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  001ce	0f ba e8 14	 bts	 eax, 20
  001d2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001d7	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1925 :                     dxc = (pset->status & DEC_Rounded) ?

  001dd	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  001e2	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001e5	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  001ea	85 c0		 test	 eax, eax
  001ec	74 0a		 je	 SHORT $LN32@s370_dfp_s
  001ee	c7 44 24 30 0c
	00 00 00	 mov	 DWORD PTR tv153[rsp], 12
  001f6	eb 08		 jmp	 SHORT $LN33@s370_dfp_s
$LN32@s370_dfp_s:
  001f8	c7 44 24 30 08
	00 00 00	 mov	 DWORD PTR tv153[rsp], 8
$LN33@s370_dfp_s:
  00200	0f b6 44 24 30	 movzx	 eax, BYTE PTR tv153[rsp]
  00205	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al
$LN20@s370_dfp_s:
$LN18@s370_dfp_s:

; 1926 :                             DXC_IEEE_INEXACT_INCR :
; 1927 :                             DXC_IEEE_INEXACT_TRUNC ;
; 1928 :                 }
; 1929 :             }
; 1930 :         }

  00209	eb 42		 jmp	 SHORT $LN17@s370_dfp_s
$LN16@s370_dfp_s:

; 1931 :         else
; 1932 :         {
; 1933 :             /* Underflow mask is one */
; 1934 :             if (pset->status & DEC_IEEE_854_Inexact)

  0020b	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00210	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00213	83 e0 20	 and	 eax, 32			; 00000020H
  00216	85 c0		 test	 eax, eax
  00218	74 2e		 je	 SHORT $LN21@s370_dfp_s

; 1935 :             {
; 1936 :                 /* Underflow with inexact result */
; 1937 :                 dxc = (pset->status & DEC_Rounded) ?

  0021a	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  0021f	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00222	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00227	85 c0		 test	 eax, eax
  00229	74 0a		 je	 SHORT $LN34@s370_dfp_s
  0022b	c7 44 24 34 1c
	00 00 00	 mov	 DWORD PTR tv161[rsp], 28
  00233	eb 08		 jmp	 SHORT $LN35@s370_dfp_s
$LN34@s370_dfp_s:
  00235	c7 44 24 34 18
	00 00 00	 mov	 DWORD PTR tv161[rsp], 24
$LN35@s370_dfp_s:
  0023d	0f b6 44 24 34	 movzx	 eax, BYTE PTR tv161[rsp]
  00242	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 1938 :                         DXC_IEEE_UF_INEX_INCR :
; 1939 :                         DXC_IEEE_UF_INEX_TRUNC ;
; 1940 :             }

  00246	eb 05		 jmp	 SHORT $LN22@s370_dfp_s
$LN21@s370_dfp_s:

; 1941 :             else
; 1942 :             {
; 1943 :                 /* Underflow with exact result */
; 1944 :                 dxc = DXC_IEEE_UF_EXACT;

  00248	c6 44 24 20 10	 mov	 BYTE PTR dxc$[rsp], 16
$LN22@s370_dfp_s:
$LN17@s370_dfp_s:

; 1945 :             }
; 1946 :         }
; 1947 :     }

  0024d	eb 6b		 jmp	 SHORT $LN15@s370_dfp_s
$LN14@s370_dfp_s:

; 1948 :     else if (pset->status & DEC_IEEE_854_Inexact)

  0024f	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00254	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00257	83 e0 20	 and	 eax, 32			; 00000020H
  0025a	85 c0		 test	 eax, eax
  0025c	74 5c		 je	 SHORT $LN23@s370_dfp_s

; 1949 :     {
; 1950 :         /* An IEEE-inexact condition was recognized */
; 1951 :         if ((regs->fpc & FPC_MASK_IMX) == 0)

  0025e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00263	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00269	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0026e	85 c0		 test	 eax, eax
  00270	75 1c		 jne	 SHORT $LN24@s370_dfp_s

; 1952 :         {
; 1953 :             /* Inexact mask is zero */
; 1954 :             regs->fpc |= FPC_FLAG_SFX;

  00272	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00277	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  0027d	0f ba e8 13	 bts	 eax, 19
  00281	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00286	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1955 :         }

  0028c	eb 2c		 jmp	 SHORT $LN25@s370_dfp_s
$LN24@s370_dfp_s:

; 1956 :         else
; 1957 :         {
; 1958 :             /* Inexact mask is one */
; 1959 :             dxc = (pset->status & DEC_Rounded) ?

  0028e	48 8b 44 24 50	 mov	 rax, QWORD PTR pset$[rsp]
  00293	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00296	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0029b	85 c0		 test	 eax, eax
  0029d	74 0a		 je	 SHORT $LN36@s370_dfp_s
  0029f	c7 44 24 38 0c
	00 00 00	 mov	 DWORD PTR tv175[rsp], 12
  002a7	eb 08		 jmp	 SHORT $LN37@s370_dfp_s
$LN36@s370_dfp_s:
  002a9	c7 44 24 38 08
	00 00 00	 mov	 DWORD PTR tv175[rsp], 8
$LN37@s370_dfp_s:
  002b1	0f b6 44 24 38	 movzx	 eax, BYTE PTR tv175[rsp]
  002b6	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al
$LN25@s370_dfp_s:
$LN23@s370_dfp_s:
$LN15@s370_dfp_s:
$LN11@s370_dfp_s:
$LN7@s370_dfp_s:
$LN3@s370_dfp_s:

; 1960 :                     DXC_IEEE_INEXACT_INCR :
; 1961 :                     DXC_IEEE_INEXACT_TRUNC ;
; 1962 :         }
; 1963 :     }
; 1964 : 
; 1965 :     /* If suppression is indicated, raise a data exception */
; 1966 :     if (suppress)

  002ba	83 7c 24 24 00	 cmp	 DWORD PTR suppress$[rsp], 0
  002bf	74 1f		 je	 SHORT $LN26@s370_dfp_s

; 1967 :     {
; 1968 :         regs->dxc = dxc;

  002c1	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002cb	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 1969 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002d1	ba 07 00 00 00	 mov	 edx, 7
  002d6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  002db	e8 00 00 00 00	 call	 s370_program_interrupt
$LN26@s370_dfp_s:

; 1970 :     }
; 1971 : 
; 1972 :     /* Otherwise return to complete the instruction */
; 1973 :     return dxc;

  002e0	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]

; 1974 : 
; 1975 : } /* end function dfp_status_check */

  002e5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002e9	c3		 ret	 0
s370_dfp_status_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 0
j$ = 4
qwp$ = 8
rn$ = 32
xp$ = 40
regs$ = 48
s370_dfp_reg_from_decimal128 PROC

; 1804 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1805 : int     i, j;                           /* FP register subscripts    */
; 1806 : QW      *qwp;                           /* Quadword pointer          */
; 1807 : 
; 1808 :     i = FPR2I(rn);                      /* Left register index       */

  00012	8b 44 24 20	 mov	 eax, DWORD PTR rn$[rsp]
  00016	d1 e0		 shl	 eax, 1
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 1809 :     j = i + FPREX;                      /* Right register index      */

  0001b	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 44 24 04	 mov	 DWORD PTR j$[rsp], eax

; 1810 :     qwp = (QW*)xp;                      /* Convert to QW pointer     */

  00025	48 8b 44 24 28	 mov	 rax, QWORD PTR xp$[rsp]
  0002a	48 89 44 24 08	 mov	 QWORD PTR qwp$[rsp], rax

; 1811 :     regs->fpr[i]   = qwp->F.HH.F;       /* Load FPR bits 0-31        */

  0002f	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00038	48 8b 54 24 08	 mov	 rdx, QWORD PTR qwp$[rsp]
  0003d	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  00040	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1812 :     regs->fpr[i+1] = qwp->F.HL.F;       /* Load FPR bits 32-63       */

  00047	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0004a	ff c0		 inc	 eax
  0004c	48 98		 cdqe
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	48 8b 54 24 08	 mov	 rdx, QWORD PTR qwp$[rsp]
  00058	8b 52 08	 mov	 edx, DWORD PTR [rdx+8]
  0005b	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1813 :     regs->fpr[j]   = qwp->F.LH.F;       /* Load FPR bits 64-95       */

  00062	48 63 44 24 04	 movsxd	 rax, DWORD PTR j$[rsp]
  00067	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 8b 54 24 08	 mov	 rdx, QWORD PTR qwp$[rsp]
  00071	8b 52 04	 mov	 edx, DWORD PTR [rdx+4]
  00074	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1814 :     regs->fpr[j+1] = qwp->F.LL.F;       /* Load FPR bits 96-127      */

  0007b	8b 44 24 04	 mov	 eax, DWORD PTR j$[rsp]
  0007f	ff c0		 inc	 eax
  00081	48 98		 cdqe
  00083	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 8b 54 24 08	 mov	 rdx, QWORD PTR qwp$[rsp]
  0008d	8b 12		 mov	 edx, DWORD PTR [rdx]
  0008f	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1815 : 
; 1816 : } /* end function dfp_reg_from_decimal128 */

  00096	48 83 c4 18	 add	 rsp, 24
  0009a	c3		 ret	 0
s370_dfp_reg_from_decimal128 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 0
j$ = 4
qwp$ = 8
rn$ = 32
xp$ = 40
regs$ = 48
s370_dfp_reg_to_decimal128 PROC

; 1780 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1781 : int     i, j;                           /* FP register subscripts    */
; 1782 : QW      *qwp;                           /* Quadword pointer          */
; 1783 : 
; 1784 :     i = FPR2I(rn);                      /* Left register index       */

  00012	8b 44 24 20	 mov	 eax, DWORD PTR rn$[rsp]
  00016	d1 e0		 shl	 eax, 1
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 1785 :     j = i + FPREX;                      /* Right register index      */

  0001b	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 44 24 04	 mov	 DWORD PTR j$[rsp], eax

; 1786 :     qwp = (QW*)xp;                      /* Convert to QW pointer     */

  00025	48 8b 44 24 28	 mov	 rax, QWORD PTR xp$[rsp]
  0002a	48 89 44 24 08	 mov	 QWORD PTR qwp$[rsp], rax

; 1787 :     qwp->F.HH.F = regs->fpr[i];         /* Copy FPR bits 0-31        */

  0002f	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00033	48 8b 4c 24 08	 mov	 rcx, QWORD PTR qwp$[rsp]
  00038	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  0003d	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  00044	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 1788 :     qwp->F.HL.F = regs->fpr[i+1];       /* Copy FPR bits 32-63       */

  00047	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0004a	ff c0		 inc	 eax
  0004c	48 98		 cdqe
  0004e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR qwp$[rsp]
  00053	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  00058	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  0005f	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1789 :     qwp->F.LH.F = regs->fpr[j];         /* Copy FPR bits 64-95       */

  00062	48 63 44 24 04	 movsxd	 rax, DWORD PTR j$[rsp]
  00067	48 8b 4c 24 08	 mov	 rcx, QWORD PTR qwp$[rsp]
  0006c	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  00071	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  00078	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1790 :     qwp->F.LL.F = regs->fpr[j+1];       /* Copy FPR bits 96-127      */

  0007b	8b 44 24 04	 mov	 eax, DWORD PTR j$[rsp]
  0007f	ff c0		 inc	 eax
  00081	48 98		 cdqe
  00083	48 8b 4c 24 08	 mov	 rcx, QWORD PTR qwp$[rsp]
  00088	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  0008d	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  00094	89 01		 mov	 DWORD PTR [rcx], eax

; 1791 : 
; 1792 : } /* end function dfp_reg_to_decimal128 */

  00096	48 83 c4 18	 add	 rsp, 24
  0009a	c3		 ret	 0
s370_dfp_reg_to_decimal128 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 0
dwp$ = 8
rn$ = 32
xp$ = 40
regs$ = 48
s370_dfp_reg_from_decimal64 PROC

; 1759 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1760 : int     i;                              /* FP register subscript     */
; 1761 : DW      *dwp;                           /* Doubleword pointer        */
; 1762 : 
; 1763 :     i = FPR2I(rn);                      /* Register index            */

  00012	8b 44 24 20	 mov	 eax, DWORD PTR rn$[rsp]
  00016	d1 e0		 shl	 eax, 1
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 1764 :     dwp = (DW*)xp;                      /* Convert to DW pointer     */

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR xp$[rsp]
  00020	48 89 44 24 08	 mov	 QWORD PTR dwp$[rsp], rax

; 1765 :     regs->fpr[i]   = dwp->F.H.F;        /* Load FPR bits 0-31        */

  00025	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0002e	48 8b 54 24 08	 mov	 rdx, QWORD PTR dwp$[rsp]
  00033	8b 52 04	 mov	 edx, DWORD PTR [rdx+4]
  00036	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1766 :     regs->fpr[i+1] = dwp->F.L.F;        /* Load FPR bits 32-63       */

  0003d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00040	ff c0		 inc	 eax
  00042	48 98		 cdqe
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	48 8b 54 24 08	 mov	 rdx, QWORD PTR dwp$[rsp]
  0004e	8b 12		 mov	 edx, DWORD PTR [rdx]
  00050	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1767 : 
; 1768 : } /* end function dfp_reg_from_decimal64 */

  00057	48 83 c4 18	 add	 rsp, 24
  0005b	c3		 ret	 0
s370_dfp_reg_from_decimal64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 0
dwp$ = 8
rn$ = 32
xp$ = 40
regs$ = 48
s370_dfp_reg_to_decimal64 PROC

; 1738 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1739 : int     i;                              /* FP register subscript     */
; 1740 : DW      *dwp;                           /* Doubleword pointer        */
; 1741 : 
; 1742 :     i = FPR2I(rn);                      /* Register index            */

  00012	8b 44 24 20	 mov	 eax, DWORD PTR rn$[rsp]
  00016	d1 e0		 shl	 eax, 1
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 1743 :     dwp = (DW*)xp;                      /* Convert to DW pointer     */

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR xp$[rsp]
  00020	48 89 44 24 08	 mov	 QWORD PTR dwp$[rsp], rax

; 1744 :     dwp->F.H.F = regs->fpr[i];          /* Copy FPR bits 0-31        */

  00025	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00029	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dwp$[rsp]
  0002e	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  00033	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  0003a	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1745 :     dwp->F.L.F = regs->fpr[i+1];        /* Copy FPR bits 32-63       */

  0003d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00040	ff c0		 inc	 eax
  00042	48 98		 cdqe
  00044	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dwp$[rsp]
  00049	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  0004e	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  00055	89 01		 mov	 DWORD PTR [rcx], eax

; 1746 : 
; 1747 : } /* end function dfp_reg_to_decimal64 */

  00057	48 83 c4 18	 add	 rsp, 24
  0005b	c3		 ret	 0
s370_dfp_reg_to_decimal64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 0
fwp$ = 8
rn$ = 32
xp$ = 40
regs$ = 48
s370_dfp_reg_from_decimal32 PROC

; 1718 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1719 : int     i;                              /* FP register subscript     */
; 1720 : FW      *fwp;                           /* Fullword pointer          */
; 1721 : 
; 1722 :     i = FPR2I(rn);                      /* Register index            */

  00012	8b 44 24 20	 mov	 eax, DWORD PTR rn$[rsp]
  00016	d1 e0		 shl	 eax, 1
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 1723 :     fwp = (FW*)xp;                      /* Convert to FW pointer     */

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR xp$[rsp]
  00020	48 89 44 24 08	 mov	 QWORD PTR fwp$[rsp], rax

; 1724 :     regs->fpr[i] = fwp->F;              /* Load FPR bits 0-31        */

  00025	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0002e	48 8b 54 24 08	 mov	 rdx, QWORD PTR fwp$[rsp]
  00033	8b 12		 mov	 edx, DWORD PTR [rdx]
  00035	89 94 81 40 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+832], edx

; 1725 : 
; 1726 : } /* end function dfp_reg_from_decimal32 */

  0003c	48 83 c4 18	 add	 rsp, 24
  00040	c3		 ret	 0
s370_dfp_reg_from_decimal32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 0
fwp$ = 8
rn$ = 32
xp$ = 40
regs$ = 48
s370_dfp_reg_to_decimal32 PROC

; 1698 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1699 : int     i;                              /* FP register subscript     */
; 1700 : FW      *fwp;                           /* Fullword pointer          */
; 1701 : 
; 1702 :     i = FPR2I(rn);                      /* Register index            */

  00012	8b 44 24 20	 mov	 eax, DWORD PTR rn$[rsp]
  00016	d1 e0		 shl	 eax, 1
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax

; 1703 :     fwp = (FW*)xp;                      /* Convert to FW pointer     */

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR xp$[rsp]
  00020	48 89 44 24 08	 mov	 QWORD PTR fwp$[rsp], rax

; 1704 :     fwp->F = regs->fpr[i];              /* Copy FPR bits 0-31        */

  00025	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00029	48 8b 4c 24 08	 mov	 rcx, QWORD PTR fwp$[rsp]
  0002e	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  00033	8b 84 82 40 03
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+832]
  0003a	89 01		 mov	 DWORD PTR [rcx], eax

; 1705 : 
; 1706 : } /* end function dfp_reg_to_decimal32 */

  0003c	48 83 c4 18	 add	 rsp, 24
  00040	c3		 ret	 0
s370_dfp_reg_to_decimal32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
drm$ = 0
tv73 = 4
pset$ = 32
mask$ = 40
regs$ = 48
s370_dfp_rounding_mode PROC

; 1661 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 1662 : BYTE    drm;                            /* Decimal rounding mode     */
; 1663 : 
; 1664 :     /* Load DRM from mask or from FPC register */
; 1665 :     if (mask & 0x08)

  00012	8b 44 24 28	 mov	 eax, DWORD PTR mask$[rsp]
  00016	83 e0 08	 and	 eax, 8
  00019	85 c0		 test	 eax, eax
  0001b	74 0c		 je	 SHORT $LN4@s370_dfp_r

; 1666 :         drm = mask & 0x07;

  0001d	8b 44 24 28	 mov	 eax, DWORD PTR mask$[rsp]
  00021	83 e0 07	 and	 eax, 7
  00024	88 04 24	 mov	 BYTE PTR drm$[rsp], al
  00027	eb 14		 jmp	 SHORT $LN5@s370_dfp_r
$LN4@s370_dfp_r:

; 1667 :     else
; 1668 :         drm = (regs->fpc & FPC_DRM) >> FPC_DRM_SHIFT;

  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00034	83 e0 70	 and	 eax, 112		; 00000070H
  00037	c1 e8 04	 shr	 eax, 4
  0003a	88 04 24	 mov	 BYTE PTR drm$[rsp], al
$LN5@s370_dfp_r:

; 1669 : 
; 1670 :     /* Set rounding mode according to DRM value */
; 1671 :     switch (drm) {

  0003d	0f b6 04 24	 movzx	 eax, BYTE PTR drm$[rsp]
  00041	89 44 24 04	 mov	 DWORD PTR tv73[rsp], eax
  00045	83 7c 24 04 07	 cmp	 DWORD PTR tv73[rsp], 7
  0004a	0f 87 86 00 00
	00		 ja	 $LN2@s370_dfp_r
  00050	48 63 44 24 04	 movsxd	 rax, DWORD PTR tv73[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0005c	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN15@s370_dfp_r[rcx+rax*4]
  00063	48 03 c1	 add	 rax, rcx
  00066	ff e0		 jmp	 rax
$LN6@s370_dfp_r:

; 1672 :     case DRM_RNE:  pset->round = DEC_ROUND_HALF_EVEN; break;

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  0006d	c7 40 0c 03 00
	00 00		 mov	 DWORD PTR [rax+12], 3
  00074	eb 60		 jmp	 SHORT $LN2@s370_dfp_r
$LN7@s370_dfp_r:

; 1673 :     case DRM_RTZ:  pset->round = DEC_ROUND_DOWN; break;

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  0007b	c7 40 0c 05 00
	00 00		 mov	 DWORD PTR [rax+12], 5
  00082	eb 52		 jmp	 SHORT $LN2@s370_dfp_r
$LN8@s370_dfp_r:

; 1674 :     case DRM_RTPI: pset->round = DEC_ROUND_CEILING; break;

  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  00089	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0
  00090	eb 44		 jmp	 SHORT $LN2@s370_dfp_r
$LN9@s370_dfp_r:

; 1675 :     case DRM_RTMI: pset->round = DEC_ROUND_FLOOR; break;

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  00097	c7 40 0c 06 00
	00 00		 mov	 DWORD PTR [rax+12], 6
  0009e	eb 36		 jmp	 SHORT $LN2@s370_dfp_r
$LN10@s370_dfp_r:

; 1676 :     case DRM_RNAZ: pset->round = DEC_ROUND_HALF_UP; break;

  000a0	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  000a5	c7 40 0c 02 00
	00 00		 mov	 DWORD PTR [rax+12], 2
  000ac	eb 28		 jmp	 SHORT $LN2@s370_dfp_r
$LN11@s370_dfp_r:

; 1677 :     case DRM_RNTZ: pset->round = DEC_ROUND_HALF_DOWN; break;

  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  000b3	c7 40 0c 04 00
	00 00		 mov	 DWORD PTR [rax+12], 4
  000ba	eb 1a		 jmp	 SHORT $LN2@s370_dfp_r
$LN12@s370_dfp_r:

; 1678 :     case DRM_RAFZ: pset->round = DEC_ROUND_UP; break;

  000bc	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  000c1	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [rax+12], 1
  000c8	eb 0c		 jmp	 SHORT $LN2@s370_dfp_r
$LN13@s370_dfp_r:

; 1679 :     case DRM_RFSP:
; 1680 :     /* Rounding mode DRM_RFSP is not supported by
; 1681 :        the decNumber library, so we arbitrarily
; 1682 :        convert it to another mode instead... */
; 1683 :         pset->round = DEC_ROUND_DOWN; break;

  000ca	48 8b 44 24 20	 mov	 rax, QWORD PTR pset$[rsp]
  000cf	c7 40 0c 05 00
	00 00		 mov	 DWORD PTR [rax+12], 5
$LN2@s370_dfp_r:

; 1684 :     } /* end switch(drm) */
; 1685 : 
; 1686 : } /* end function dfp_rounding_mode */

  000d6	48 83 c4 18	 add	 rsp, 24
  000da	c3		 ret	 0
  000db	90		 npad	 1
$LN15@s370_dfp_r:
  000dc	00 00 00 00	 DD	 $LN6@s370_dfp_r
  000e0	00 00 00 00	 DD	 $LN7@s370_dfp_r
  000e4	00 00 00 00	 DD	 $LN8@s370_dfp_r
  000e8	00 00 00 00	 DD	 $LN9@s370_dfp_r
  000ec	00 00 00 00	 DD	 $LN10@s370_dfp_r
  000f0	00 00 00 00	 DD	 $LN11@s370_dfp_r
  000f4	00 00 00 00	 DD	 $LN12@s370_dfp_r
  000f8	00 00 00 00	 DD	 $LN13@s370_dfp_r
s370_dfp_rounding_mode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
n$ = 40
scale$ = 48
tv94 = 52
tv136 = 56
tv153 = 60
tv165 = 64
tv166 = 68
tv206 = 72
c$ = 80
p$ = 120
setmax$ = 160
packed$ = 192
__$ArrayPad$ = 216
b$ = 240
pset$ = 248
dfp_number_to_u64 PROC

; 1191 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1192 : U64             n;                      /* 64-bit unsigned result    */
; 1193 : int32_t         scale;                  /* Scaling factor            */
; 1194 : unsigned        i;                      /* Array subscript           */
; 1195 : BYTE            packed[17];             /* 33-digit packed work area */
; 1196 : decNumber       p, c;                   /* Working decimal numbers   */
; 1197 : static U64      mu64 = 0xFFFFFFFFFFFFFFFFULL;    /* Max unsigned int */
; 1198 : static char     mu64zd[]="18446744073709551615"; /* Max zoned dec    */
; 1199 : static BYTE     mu64flag = 0;           /* 1=mu64dn is initialized   */
; 1200 : static decNumber mu64dn;                /* Decimal maximum unsigned  */
; 1201 : decContext      setmax;                 /* Working context           */
; 1202 : 
; 1203 :     /* Prime the decimal number structure representing the maximum
; 1204 :        unsigned number representable in 64 bits. Use a 128-bit DFP
; 1205 :        working context because this number is too big to be
; 1206 :        represented in the 32-bit or 64-bit DFP format */
; 1207 :     if (mu64flag == 0)

  00023	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?mu64flag@?1??dfp_number_to_u64@@9@9
  0002a	85 c0		 test	 eax, eax
  0002c	75 34		 jne	 SHORT $LN7@dfp_number

; 1208 :     {
; 1209 :         decContextDefault(&setmax, DEC_INIT_DECIMAL128);

  0002e	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00033	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR setmax$[rsp]
  0003b	e8 00 00 00 00	 call	 decContextDefault

; 1210 :         decNumberFromString(&mu64dn, mu64zd, &setmax);

  00040	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR setmax$[rsp]
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?mu64zd@?1??dfp_number_to_u64@@9@9
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mu64dn@?1??dfp_number_to_u64@@9@9
  00056	e8 00 00 00 00	 call	 decNumberFromString

; 1211 :         mu64flag = 1;

  0005b	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?mu64flag@?1??dfp_number_to_u64@@9@9, 1
$LN7@dfp_number:

; 1212 :     }
; 1213 : 
; 1214 :     /* If operand is a NaN then set invalid operation
; 1215 :        and return zero result */
; 1216 :     if (decNumberIsNaN(b))

  00062	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0006a	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  0006e	83 e0 30	 and	 eax, 48			; 00000030H
  00071	85 c0		 test	 eax, eax
  00073	74 22		 je	 SHORT $LN8@dfp_number

; 1217 :     {
; 1218 :         pset->status |= DEC_IEEE_854_Invalid_operation;

  00075	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  0007d	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00080	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00085	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  0008d	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 1219 :         return (U64)0;

  00090	33 c0		 xor	 eax, eax
  00092	e9 b8 02 00 00	 jmp	 $LN1@dfp_number
$LN8@dfp_number:

; 1220 :     }
; 1221 : 
; 1222 :     /* Round decimal number to integer using current rounding mode */
; 1223 :     decNumberToIntegralValue(&p, b, pset);

  00097	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR pset$[rsp]
  0009f	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  000a7	48 8d 4c 24 78	 lea	 rcx, QWORD PTR p$[rsp]
  000ac	e8 00 00 00 00	 call	 decNumberToIntegralValue

; 1224 : 
; 1225 :     /* If rounded value is less than zero then set invalid operation
; 1226 :        and return zero result */
; 1227 :     if (decNumberIsNegative(&p))

  000b1	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR p$[rsp+8]
  000b9	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000be	85 c0		 test	 eax, eax
  000c0	74 22		 je	 SHORT $LN9@dfp_number

; 1228 :     {
; 1229 :         pset->status |= DEC_IEEE_854_Invalid_operation;

  000c2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  000ca	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000cd	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  000d2	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  000da	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 1230 :         return (U64)0;

  000dd	33 c0		 xor	 eax, eax
  000df	e9 6b 02 00 00	 jmp	 $LN1@dfp_number
$LN9@dfp_number:

; 1231 :     }
; 1232 : 
; 1233 :     /* If rounded value is greater than maximum unsigned number
; 1234 :        (including where operand is positive infinity) then set
; 1235 :        invalid operation and return maximum unsigned result */
; 1236 :     decNumberCompare(&c, &p, &mu64dn, pset);

  000e4	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  000ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?mu64dn@?1??dfp_number_to_u64@@9@9
  000f3	48 8d 54 24 78	 lea	 rdx, QWORD PTR p$[rsp]
  000f8	48 8d 4c 24 50	 lea	 rcx, QWORD PTR c$[rsp]
  000fd	e8 00 00 00 00	 call	 decNumberCompare

; 1237 :     if (decNumberIsNegative(&c) == 0 && decNumberIsZero(&c) == 0)

  00102	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp+8]
  00107	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0010c	85 c0		 test	 eax, eax
  0010e	74 0a		 je	 SHORT $LN14@dfp_number
  00110	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00118	eb 08		 jmp	 SHORT $LN15@dfp_number
$LN14@dfp_number:
  0011a	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN15@dfp_number:
  00122	83 7c 24 34 00	 cmp	 DWORD PTR tv94[rsp], 0
  00127	75 65		 jne	 SHORT $LN10@dfp_number
  00129	b8 02 00 00 00	 mov	 eax, 2
  0012e	48 6b c0 00	 imul	 rax, rax, 0
  00132	0f b7 44 04 5a	 movzx	 eax, WORD PTR c$[rsp+rax+10]
  00137	85 c0		 test	 eax, eax
  00139	75 1d		 jne	 SHORT $LN16@dfp_number
  0013b	83 7c 24 50 01	 cmp	 DWORD PTR c$[rsp], 1
  00140	75 16		 jne	 SHORT $LN16@dfp_number
  00142	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp+8]
  00147	83 e0 70	 and	 eax, 112		; 00000070H
  0014a	85 c0		 test	 eax, eax
  0014c	75 0a		 jne	 SHORT $LN16@dfp_number
  0014e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  00156	eb 08		 jmp	 SHORT $LN17@dfp_number
$LN16@dfp_number:
  00158	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN17@dfp_number:
  00160	83 7c 24 38 00	 cmp	 DWORD PTR tv136[rsp], 0
  00165	75 27		 jne	 SHORT $LN10@dfp_number

; 1238 :     {
; 1239 :         pset->status |= DEC_IEEE_854_Invalid_operation;

  00167	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  0016f	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00172	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00177	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  0017f	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 1240 :         return (U64)mu64;

  00182	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?mu64@?1??dfp_number_to_u64@@9@9
  00189	e9 c1 01 00 00	 jmp	 $LN1@dfp_number
$LN10@dfp_number:

; 1241 :     }
; 1242 : 
; 1243 :     /* Raise inexact condition if result was rounded */
; 1244 :     decNumberCompare(&c, &p, b, pset);

  0018e	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  00196	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR b$[rsp]
  0019e	48 8d 54 24 78	 lea	 rdx, QWORD PTR p$[rsp]
  001a3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR c$[rsp]
  001a8	e8 00 00 00 00	 call	 decNumberCompare

; 1245 :     if (decNumberIsZero(&c) == 0)

  001ad	b8 02 00 00 00	 mov	 eax, 2
  001b2	48 6b c0 00	 imul	 rax, rax, 0
  001b6	0f b7 44 04 5a	 movzx	 eax, WORD PTR c$[rsp+rax+10]
  001bb	85 c0		 test	 eax, eax
  001bd	75 1d		 jne	 SHORT $LN18@dfp_number
  001bf	83 7c 24 50 01	 cmp	 DWORD PTR c$[rsp], 1
  001c4	75 16		 jne	 SHORT $LN18@dfp_number
  001c6	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp+8]
  001cb	83 e0 70	 and	 eax, 112		; 00000070H
  001ce	85 c0		 test	 eax, eax
  001d0	75 0a		 jne	 SHORT $LN18@dfp_number
  001d2	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
  001da	eb 08		 jmp	 SHORT $LN19@dfp_number
$LN18@dfp_number:
  001dc	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN19@dfp_number:
  001e4	83 7c 24 3c 00	 cmp	 DWORD PTR tv153[rsp], 0
  001e9	0f 85 84 00 00
	00		 jne	 $LN11@dfp_number

; 1246 :     {
; 1247 :         pset->status |= DEC_IEEE_854_Inexact;

  001ef	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  001f7	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001fa	83 c8 20	 or	 eax, 32			; 00000020H
  001fd	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  00205	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 1248 :         if (decNumberIsNegative(&c) == decNumberIsNegative(b))

  00208	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp+8]
  0020d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00212	85 c0		 test	 eax, eax
  00214	74 0a		 je	 SHORT $LN22@dfp_number
  00216	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv166[rsp], 1
  0021e	eb 08		 jmp	 SHORT $LN23@dfp_number
$LN22@dfp_number:
  00220	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv166[rsp], 0
$LN23@dfp_number:
  00228	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00230	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00234	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00239	85 c0		 test	 eax, eax
  0023b	74 0a		 je	 SHORT $LN20@dfp_number
  0023d	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv165[rsp], 1
  00245	eb 08		 jmp	 SHORT $LN21@dfp_number
$LN20@dfp_number:
  00247	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
$LN21@dfp_number:
  0024f	8b 44 24 40	 mov	 eax, DWORD PTR tv165[rsp]
  00253	39 44 24 44	 cmp	 DWORD PTR tv166[rsp], eax
  00257	75 1a		 jne	 SHORT $LN12@dfp_number

; 1249 :             pset->status |= DEC_Rounded;

  00259	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  00261	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00264	0f ba e8 0b	 bts	 eax, 11
  00268	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  00270	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN12@dfp_number:
$LN11@dfp_number:

; 1250 :     }
; 1251 : 
; 1252 :     /* Convert decimal number structure to packed decimal */
; 1253 :     decPackedFromNumber(packed, sizeof(packed), &scale, &p);

  00273	4c 8d 4c 24 78	 lea	 r9, QWORD PTR p$[rsp]
  00278	4c 8d 44 24 30	 lea	 r8, QWORD PTR scale$[rsp]
  0027d	ba 11 00 00 00	 mov	 edx, 17
  00282	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR packed$[rsp]
  0028a	e8 00 00 00 00	 call	 decPackedFromNumber

; 1254 : 
; 1255 :     /* Convert packed decimal to binary value */
; 1256 :     for (i = 0, n = 0; i < sizeof(packed)-1; i++)

  0028f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00297	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0
  002a0	eb 0a		 jmp	 SHORT $LN4@dfp_number
$LN2@dfp_number:
  002a2	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002a6	ff c0		 inc	 eax
  002a8	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@dfp_number:
  002ac	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002b0	48 83 f8 10	 cmp	 rax, 16
  002b4	73 48		 jae	 SHORT $LN3@dfp_number

; 1257 :     {
; 1258 :         n = n * 10 + ((packed[i] & 0xF0) >> 4);

  002b6	48 6b 44 24 28
	0a		 imul	 rax, QWORD PTR n$[rsp], 10
  002bc	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  002c0	0f b6 8c 0c c0
	00 00 00	 movzx	 ecx, BYTE PTR packed$[rsp+rcx]
  002c8	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  002ce	c1 f9 04	 sar	 ecx, 4
  002d1	48 63 c9	 movsxd	 rcx, ecx
  002d4	48 03 c1	 add	 rax, rcx
  002d7	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 1259 :         n = n * 10 + (packed[i] & 0x0F);

  002dc	48 6b 44 24 28
	0a		 imul	 rax, QWORD PTR n$[rsp], 10
  002e2	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  002e6	0f b6 8c 0c c0
	00 00 00	 movzx	 ecx, BYTE PTR packed$[rsp+rcx]
  002ee	83 e1 0f	 and	 ecx, 15
  002f1	48 63 c9	 movsxd	 rcx, ecx
  002f4	48 03 c1	 add	 rax, rcx
  002f7	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 1260 :     }

  002fc	eb a4		 jmp	 SHORT $LN2@dfp_number
$LN3@dfp_number:

; 1261 :     n = n * 10 + ((packed[i] & 0xF0) >> 4);

  002fe	48 6b 44 24 28
	0a		 imul	 rax, QWORD PTR n$[rsp], 10
  00304	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00308	0f b6 8c 0c c0
	00 00 00	 movzx	 ecx, BYTE PTR packed$[rsp+rcx]
  00310	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00316	c1 f9 04	 sar	 ecx, 4
  00319	48 63 c9	 movsxd	 rcx, ecx
  0031c	48 03 c1	 add	 rax, rcx
  0031f	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax
$LN5@dfp_number:

; 1262 :     while (scale++) n *= 10;

  00324	8b 44 24 30	 mov	 eax, DWORD PTR scale$[rsp]
  00328	89 44 24 48	 mov	 DWORD PTR tv206[rsp], eax
  0032c	8b 44 24 30	 mov	 eax, DWORD PTR scale$[rsp]
  00330	ff c0		 inc	 eax
  00332	89 44 24 30	 mov	 DWORD PTR scale$[rsp], eax
  00336	83 7c 24 48 00	 cmp	 DWORD PTR tv206[rsp], 0
  0033b	74 0d		 je	 SHORT $LN6@dfp_number
  0033d	48 6b 44 24 28
	0a		 imul	 rax, QWORD PTR n$[rsp], 10
  00343	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax
  00348	eb da		 jmp	 SHORT $LN5@dfp_number
$LN6@dfp_number:

; 1263 : 
; 1264 :     /* Return 64-bit unsigned result */
; 1265 :     return n;

  0034a	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
$LN1@dfp_number:

; 1266 : 
; 1267 : } /* end function dfp_number_to_u64 */

  0034f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00357	48 33 cc	 xor	 rcx, rsp
  0035a	e8 00 00 00 00	 call	 __security_check_cookie
  0035f	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00366	c3		 ret	 0
dfp_number_to_u64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
n$ = 32
i$ = 36
scale$ = 40
tv94 = 44
tv136 = 48
tv153 = 52
tv165 = 56
tv166 = 60
tv203 = 64
c$ = 72
p$ = 112
setmax$ = 152
packed$ = 184
__$ArrayPad$ = 208
b$ = 240
pset$ = 248
dfp_number_to_u32 PROC

; 1095 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1096 : U32             n;                      /* 32-bit unsigned result    */
; 1097 : int32_t         scale;                  /* Scaling factor            */
; 1098 : unsigned        i;                      /* Array subscript           */
; 1099 : BYTE            packed[17];             /* 33-digit packed work area */
; 1100 : decNumber       p, c;                   /* Working decimal numbers   */
; 1101 : static U32      mu32 = 0xFFFFFFFFUL;    /* Max unsigned integer      */
; 1102 : static char     mu32zd[]="4294967295";  /* Max unsigned zoned dec    */
; 1103 : static BYTE     mu32flag = 0;           /* 1=mu32dn is initialized   */
; 1104 : static decNumber mu32dn;                /* Decimal maximum unsigned  */
; 1105 : decContext      setmax;                 /* Working context           */
; 1106 : 
; 1107 :     /* Prime the decimal number structure representing the maximum
; 1108 :        unsigned number representable in 32 bits. Use a 64-bit DFP
; 1109 :        working context because this number is too big to be
; 1110 :        represented in the 32-bit DFP format */
; 1111 :     if (mu32flag == 0)

  00023	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?mu32flag@?1??dfp_number_to_u32@@9@9
  0002a	85 c0		 test	 eax, eax
  0002c	75 34		 jne	 SHORT $LN7@dfp_number

; 1112 :     {
; 1113 :         decContextDefault(&setmax, DEC_INIT_DECIMAL64);

  0002e	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00033	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR setmax$[rsp]
  0003b	e8 00 00 00 00	 call	 decContextDefault

; 1114 :         decNumberFromString(&mu32dn, mu32zd, &setmax);

  00040	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR setmax$[rsp]
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?mu32zd@?1??dfp_number_to_u32@@9@9
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mu32dn@?1??dfp_number_to_u32@@9@9
  00056	e8 00 00 00 00	 call	 decNumberFromString

; 1115 :         mu32flag = 1;

  0005b	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?mu32flag@?1??dfp_number_to_u32@@9@9, 1
$LN7@dfp_number:

; 1116 :     }
; 1117 : 
; 1118 :     /* If operand is a NaN then set invalid operation
; 1119 :        and return zero result */
; 1120 :     if (decNumberIsNaN(b))

  00062	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0006a	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  0006e	83 e0 30	 and	 eax, 48			; 00000030H
  00071	85 c0		 test	 eax, eax
  00073	74 22		 je	 SHORT $LN8@dfp_number

; 1121 :     {
; 1122 :         pset->status |= DEC_IEEE_854_Invalid_operation;

  00075	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  0007d	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00080	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00085	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  0008d	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 1123 :         return (U32)0;

  00090	33 c0		 xor	 eax, eax
  00092	e9 9e 02 00 00	 jmp	 $LN1@dfp_number
$LN8@dfp_number:

; 1124 :     }
; 1125 : 
; 1126 :     /* Round decimal number to integer using current rounding mode */
; 1127 :     decNumberToIntegralValue(&p, b, pset);

  00097	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR pset$[rsp]
  0009f	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  000a7	48 8d 4c 24 70	 lea	 rcx, QWORD PTR p$[rsp]
  000ac	e8 00 00 00 00	 call	 decNumberToIntegralValue

; 1128 : 
; 1129 :     /* If rounded value is less than zero then set invalid operation
; 1130 :        and return zero result */
; 1131 :     if (decNumberIsNegative(&p))

  000b1	0f b6 44 24 78	 movzx	 eax, BYTE PTR p$[rsp+8]
  000b6	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000bb	85 c0		 test	 eax, eax
  000bd	74 22		 je	 SHORT $LN9@dfp_number

; 1132 :     {
; 1133 :         pset->status |= DEC_IEEE_854_Invalid_operation;

  000bf	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  000c7	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000ca	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  000cf	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  000d7	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 1134 :         return (U32)0;

  000da	33 c0		 xor	 eax, eax
  000dc	e9 54 02 00 00	 jmp	 $LN1@dfp_number
$LN9@dfp_number:

; 1135 :     }
; 1136 : 
; 1137 :     /* If rounded value is greater than maximum unsigned number
; 1138 :        (including where operand is positive infinity) then set
; 1139 :        invalid operation and return maximum unsigned result */
; 1140 :     decNumberCompare(&c, &p, &mu32dn, pset);

  000e1	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  000e9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?mu32dn@?1??dfp_number_to_u32@@9@9
  000f0	48 8d 54 24 70	 lea	 rdx, QWORD PTR p$[rsp]
  000f5	48 8d 4c 24 48	 lea	 rcx, QWORD PTR c$[rsp]
  000fa	e8 00 00 00 00	 call	 decNumberCompare

; 1141 :     if (decNumberIsNegative(&c) == 0 && decNumberIsZero(&c) == 0)

  000ff	0f b6 44 24 50	 movzx	 eax, BYTE PTR c$[rsp+8]
  00104	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00109	85 c0		 test	 eax, eax
  0010b	74 0a		 je	 SHORT $LN14@dfp_number
  0010d	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00115	eb 08		 jmp	 SHORT $LN15@dfp_number
$LN14@dfp_number:
  00117	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN15@dfp_number:
  0011f	83 7c 24 2c 00	 cmp	 DWORD PTR tv94[rsp], 0
  00124	75 64		 jne	 SHORT $LN10@dfp_number
  00126	b8 02 00 00 00	 mov	 eax, 2
  0012b	48 6b c0 00	 imul	 rax, rax, 0
  0012f	0f b7 44 04 52	 movzx	 eax, WORD PTR c$[rsp+rax+10]
  00134	85 c0		 test	 eax, eax
  00136	75 1d		 jne	 SHORT $LN16@dfp_number
  00138	83 7c 24 48 01	 cmp	 DWORD PTR c$[rsp], 1
  0013d	75 16		 jne	 SHORT $LN16@dfp_number
  0013f	0f b6 44 24 50	 movzx	 eax, BYTE PTR c$[rsp+8]
  00144	83 e0 70	 and	 eax, 112		; 00000070H
  00147	85 c0		 test	 eax, eax
  00149	75 0a		 jne	 SHORT $LN16@dfp_number
  0014b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  00153	eb 08		 jmp	 SHORT $LN17@dfp_number
$LN16@dfp_number:
  00155	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN17@dfp_number:
  0015d	83 7c 24 30 00	 cmp	 DWORD PTR tv136[rsp], 0
  00162	75 26		 jne	 SHORT $LN10@dfp_number

; 1142 :     {
; 1143 :         pset->status |= DEC_IEEE_854_Invalid_operation;

  00164	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  0016c	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0016f	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00174	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  0017c	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 1144 :         return (U32)mu32;

  0017f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?mu32@?1??dfp_number_to_u32@@9@9
  00185	e9 ab 01 00 00	 jmp	 $LN1@dfp_number
$LN10@dfp_number:

; 1145 :     }
; 1146 : 
; 1147 :     /* Raise inexact condition if result was rounded */
; 1148 :     decNumberCompare(&c, &p, b, pset);

  0018a	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  00192	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR b$[rsp]
  0019a	48 8d 54 24 70	 lea	 rdx, QWORD PTR p$[rsp]
  0019f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR c$[rsp]
  001a4	e8 00 00 00 00	 call	 decNumberCompare

; 1149 :     if (decNumberIsZero(&c) == 0)

  001a9	b8 02 00 00 00	 mov	 eax, 2
  001ae	48 6b c0 00	 imul	 rax, rax, 0
  001b2	0f b7 44 04 52	 movzx	 eax, WORD PTR c$[rsp+rax+10]
  001b7	85 c0		 test	 eax, eax
  001b9	75 1d		 jne	 SHORT $LN18@dfp_number
  001bb	83 7c 24 48 01	 cmp	 DWORD PTR c$[rsp], 1
  001c0	75 16		 jne	 SHORT $LN18@dfp_number
  001c2	0f b6 44 24 50	 movzx	 eax, BYTE PTR c$[rsp+8]
  001c7	83 e0 70	 and	 eax, 112		; 00000070H
  001ca	85 c0		 test	 eax, eax
  001cc	75 0a		 jne	 SHORT $LN18@dfp_number
  001ce	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
  001d6	eb 08		 jmp	 SHORT $LN19@dfp_number
$LN18@dfp_number:
  001d8	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN19@dfp_number:
  001e0	83 7c 24 34 00	 cmp	 DWORD PTR tv153[rsp], 0
  001e5	0f 85 84 00 00
	00		 jne	 $LN11@dfp_number

; 1150 :     {
; 1151 :         pset->status |= DEC_IEEE_854_Inexact;

  001eb	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  001f3	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  001f6	83 c8 20	 or	 eax, 32			; 00000020H
  001f9	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  00201	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 1152 :         if (decNumberIsNegative(&c) == decNumberIsNegative(b))

  00204	0f b6 44 24 50	 movzx	 eax, BYTE PTR c$[rsp+8]
  00209	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0020e	85 c0		 test	 eax, eax
  00210	74 0a		 je	 SHORT $LN22@dfp_number
  00212	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv166[rsp], 1
  0021a	eb 08		 jmp	 SHORT $LN23@dfp_number
$LN22@dfp_number:
  0021c	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv166[rsp], 0
$LN23@dfp_number:
  00224	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0022c	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00230	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00235	85 c0		 test	 eax, eax
  00237	74 0a		 je	 SHORT $LN20@dfp_number
  00239	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv165[rsp], 1
  00241	eb 08		 jmp	 SHORT $LN21@dfp_number
$LN20@dfp_number:
  00243	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
$LN21@dfp_number:
  0024b	8b 44 24 38	 mov	 eax, DWORD PTR tv165[rsp]
  0024f	39 44 24 3c	 cmp	 DWORD PTR tv166[rsp], eax
  00253	75 1a		 jne	 SHORT $LN12@dfp_number

; 1153 :             pset->status |= DEC_Rounded;

  00255	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  0025d	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00260	0f ba e8 0b	 bts	 eax, 11
  00264	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  0026c	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN12@dfp_number:
$LN11@dfp_number:

; 1154 :     }
; 1155 : 
; 1156 :     /* Convert decimal number structure to packed decimal */
; 1157 :     decPackedFromNumber(packed, sizeof(packed), &scale, &p);

  0026f	4c 8d 4c 24 70	 lea	 r9, QWORD PTR p$[rsp]
  00274	4c 8d 44 24 28	 lea	 r8, QWORD PTR scale$[rsp]
  00279	ba 11 00 00 00	 mov	 edx, 17
  0027e	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR packed$[rsp]
  00286	e8 00 00 00 00	 call	 decPackedFromNumber

; 1158 : 
; 1159 :     /* Convert packed decimal to binary value */
; 1160 :     for (i = 0, n = 0; i < sizeof(packed)-1; i++)

  0028b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00293	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  0029b	eb 0a		 jmp	 SHORT $LN4@dfp_number
$LN2@dfp_number:
  0029d	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  002a1	ff c0		 inc	 eax
  002a3	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@dfp_number:
  002a7	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  002ab	48 83 f8 10	 cmp	 rax, 16
  002af	73 3c		 jae	 SHORT $LN3@dfp_number

; 1161 :     {
; 1162 :         n = n * 10 + ((packed[i] & 0xF0) >> 4);

  002b1	6b 44 24 20 0a	 imul	 eax, DWORD PTR n$[rsp], 10
  002b6	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  002ba	0f b6 8c 0c b8
	00 00 00	 movzx	 ecx, BYTE PTR packed$[rsp+rcx]
  002c2	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  002c8	c1 f9 04	 sar	 ecx, 4
  002cb	03 c1		 add	 eax, ecx
  002cd	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 1163 :         n = n * 10 + (packed[i] & 0x0F);

  002d1	6b 44 24 20 0a	 imul	 eax, DWORD PTR n$[rsp], 10
  002d6	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  002da	0f b6 8c 0c b8
	00 00 00	 movzx	 ecx, BYTE PTR packed$[rsp+rcx]
  002e2	83 e1 0f	 and	 ecx, 15
  002e5	03 c1		 add	 eax, ecx
  002e7	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 1164 :     }

  002eb	eb b0		 jmp	 SHORT $LN2@dfp_number
$LN3@dfp_number:

; 1165 :     n = n * 10 + ((packed[i] & 0xF0) >> 4);

  002ed	6b 44 24 20 0a	 imul	 eax, DWORD PTR n$[rsp], 10
  002f2	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  002f6	0f b6 8c 0c b8
	00 00 00	 movzx	 ecx, BYTE PTR packed$[rsp+rcx]
  002fe	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00304	c1 f9 04	 sar	 ecx, 4
  00307	03 c1		 add	 eax, ecx
  00309	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
$LN5@dfp_number:

; 1166 :     while (scale++) n *= 10;

  0030d	8b 44 24 28	 mov	 eax, DWORD PTR scale$[rsp]
  00311	89 44 24 40	 mov	 DWORD PTR tv203[rsp], eax
  00315	8b 44 24 28	 mov	 eax, DWORD PTR scale$[rsp]
  00319	ff c0		 inc	 eax
  0031b	89 44 24 28	 mov	 DWORD PTR scale$[rsp], eax
  0031f	83 7c 24 40 00	 cmp	 DWORD PTR tv203[rsp], 0
  00324	74 0b		 je	 SHORT $LN6@dfp_number
  00326	6b 44 24 20 0a	 imul	 eax, DWORD PTR n$[rsp], 10
  0032b	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
  0032f	eb dc		 jmp	 SHORT $LN5@dfp_number
$LN6@dfp_number:

; 1167 : 
; 1168 :     /* Return 32-bit unsigned result */
; 1169 :     return n;

  00331	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
$LN1@dfp_number:

; 1170 : 
; 1171 : } /* end function dfp_number_to_u32 */

  00335	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0033d	48 33 cc	 xor	 rcx, rsp
  00340	e8 00 00 00 00	 call	 __security_check_cookie
  00345	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0034c	c3		 ret	 0
dfp_number_to_u32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
n$ = 32
i$ = 36
scale$ = 40
tv143 = 44
tv153 = 48
tv162 = 52
tv172 = 56
tv192 = 60
tv204 = 64
tv205 = 68
tv242 = 72
c$ = 80
p$ = 120
setmax$ = 160
packed$ = 192
__$ArrayPad$ = 216
b$ = 240
pset$ = 248
dfp_number_to_fix32 PROC

; 979  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 980  : S32             n;                      /* 32-bit signed result      */
; 981  : int32_t         scale;                  /* Scaling factor            */
; 982  : unsigned        i;                      /* Array subscript           */
; 983  : BYTE            packed[17];             /* 33-digit packed work area */
; 984  : decNumber       p, c;                   /* Working decimal numbers   */
; 985  : static U32      mp32 = 0x7FFFFFFFUL;    /* Max positive fixed 32     */
; 986  : static U32      mn32 = 0x80000000UL;    /* Max negative fixed 32     */
; 987  : static char     mp32zd[]="2147483647";  /* Max positive zoned dec    */
; 988  : static char     mn32zd[]="-2147483648"; /* Max negative zoned dec    */
; 989  : static BYTE     mp32flag = 0;           /* 1=mp32dn,mn32dn inited    */
; 990  : static decNumber mp32dn, mn32dn;        /* Decimal maximum pos,neg   */
; 991  : decContext      setmax;                 /* Working context           */
; 992  : 
; 993  :     /* Prime the decimal number structures representing the maximum
; 994  :        positive and negative numbers representable in 32 bits. Use
; 995  :        a 64-bit DFP working context because these numbers are too
; 996  :        big to be represented in the 32-bit DFP format */
; 997  :     if (mp32flag == 0)

  00023	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?mp32flag@?1??dfp_number_to_fix32@@9@9
  0002a	85 c0		 test	 eax, eax
  0002c	75 4f		 jne	 SHORT $LN7@dfp_number

; 998  :     {
; 999  :         decContextDefault(&setmax, DEC_INIT_DECIMAL64);

  0002e	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00033	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR setmax$[rsp]
  0003b	e8 00 00 00 00	 call	 decContextDefault

; 1000 :         decNumberFromString(&mp32dn, mp32zd, &setmax);

  00040	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR setmax$[rsp]
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?mp32zd@?1??dfp_number_to_fix32@@9@9
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mp32dn@?1??dfp_number_to_fix32@@9@9
  00056	e8 00 00 00 00	 call	 decNumberFromString

; 1001 :         decNumberFromString(&mn32dn, mn32zd, &setmax);

  0005b	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR setmax$[rsp]
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?mn32zd@?1??dfp_number_to_fix32@@9@9
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mn32dn@?1??dfp_number_to_fix32@@9@9
  00071	e8 00 00 00 00	 call	 decNumberFromString

; 1002 :         mp32flag = 1;

  00076	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?mp32flag@?1??dfp_number_to_fix32@@9@9, 1
$LN7@dfp_number:

; 1003 :     }
; 1004 : 
; 1005 :     /* If operand is a NaN then set invalid operation
; 1006 :        and return maximum negative result */
; 1007 :     if (decNumberIsNaN(b))

  0007d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00085	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00089	83 e0 30	 and	 eax, 48			; 00000030H
  0008c	85 c0		 test	 eax, eax
  0008e	74 26		 je	 SHORT $LN8@dfp_number

; 1008 :     {
; 1009 :         pset->status |= DEC_IEEE_854_Invalid_operation;

  00090	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  00098	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0009b	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  000a0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  000a8	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 1010 :         return (S32)mn32;

  000ab	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?mn32@?1??dfp_number_to_fix32@@9@9
  000b1	e9 d1 03 00 00	 jmp	 $LN1@dfp_number
$LN8@dfp_number:

; 1011 :     }
; 1012 : 
; 1013 :     /* Remove fractional part of decimal number */
; 1014 :     decNumberToIntegralValue(&p, b, pset);

  000b6	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR pset$[rsp]
  000be	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  000c6	48 8d 4c 24 78	 lea	 rcx, QWORD PTR p$[rsp]
  000cb	e8 00 00 00 00	 call	 decNumberToIntegralValue

; 1015 : 
; 1016 :     /* Special case if operand is less than maximum negative
; 1017 :        number (including where operand is negative infinity) */
; 1018 :     decNumberCompare(&c, b, &mn32dn, pset);

  000d0	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  000d8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?mn32dn@?1??dfp_number_to_fix32@@9@9
  000df	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  000e7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR c$[rsp]
  000ec	e8 00 00 00 00	 call	 decNumberCompare

; 1019 :     if (decNumberIsNegative(&c))

  000f1	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp+8]
  000f6	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000fb	85 c0		 test	 eax, eax
  000fd	74 6d		 je	 SHORT $LN9@dfp_number

; 1020 :     {
; 1021 :         /* If rounded value is less than maximum negative number
; 1022 :            then set invalid operation otherwise set inexact */
; 1023 :         decNumberCompare(&c, &p, &mn32dn, pset);

  000ff	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  00107	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?mn32dn@?1??dfp_number_to_fix32@@9@9
  0010e	48 8d 54 24 78	 lea	 rdx, QWORD PTR p$[rsp]
  00113	48 8d 4c 24 50	 lea	 rcx, QWORD PTR c$[rsp]
  00118	e8 00 00 00 00	 call	 decNumberCompare

; 1024 :         if (decNumberIsNegative(&c))

  0011d	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp+8]
  00122	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00127	85 c0		 test	 eax, eax
  00129	74 1d		 je	 SHORT $LN10@dfp_number

; 1025 :             pset->status |= DEC_IEEE_854_Invalid_operation;

  0012b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  00133	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00136	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  0013b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  00143	89 41 14	 mov	 DWORD PTR [rcx+20], eax
  00146	eb 19		 jmp	 SHORT $LN11@dfp_number
$LN10@dfp_number:

; 1026 :         else
; 1027 :             pset->status |= DEC_IEEE_854_Inexact;

  00148	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  00150	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00153	83 c8 20	 or	 eax, 32			; 00000020H
  00156	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  0015e	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN11@dfp_number:

; 1028 : 
; 1029 :         /* Return maximum negative result */
; 1030 :         return (S32)mn32;

  00161	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?mn32@?1??dfp_number_to_fix32@@9@9
  00167	e9 1b 03 00 00	 jmp	 $LN1@dfp_number
$LN9@dfp_number:

; 1031 :     }
; 1032 : 
; 1033 :     /* Special case if operand is greater than maximum positive
; 1034 :        number (including where operand is positive infinity) */
; 1035 :     decNumberCompare(&c, b, &mp32dn, pset);

  0016c	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  00174	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?mp32dn@?1??dfp_number_to_fix32@@9@9
  0017b	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  00183	48 8d 4c 24 50	 lea	 rcx, QWORD PTR c$[rsp]
  00188	e8 00 00 00 00	 call	 decNumberCompare

; 1036 :     if (decNumberIsNegative(&c) == 0 && decNumberIsZero(&c) == 0)

  0018d	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp+8]
  00192	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00197	85 c0		 test	 eax, eax
  00199	74 0a		 je	 SHORT $LN19@dfp_number
  0019b	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv143[rsp], 1
  001a3	eb 08		 jmp	 SHORT $LN20@dfp_number
$LN19@dfp_number:
  001a5	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN20@dfp_number:
  001ad	83 7c 24 2c 00	 cmp	 DWORD PTR tv143[rsp], 0
  001b2	0f 85 06 01 00
	00		 jne	 $LN12@dfp_number
  001b8	b8 02 00 00 00	 mov	 eax, 2
  001bd	48 6b c0 00	 imul	 rax, rax, 0
  001c1	0f b7 44 04 5a	 movzx	 eax, WORD PTR c$[rsp+rax+10]
  001c6	85 c0		 test	 eax, eax
  001c8	75 1d		 jne	 SHORT $LN21@dfp_number
  001ca	83 7c 24 50 01	 cmp	 DWORD PTR c$[rsp], 1
  001cf	75 16		 jne	 SHORT $LN21@dfp_number
  001d1	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp+8]
  001d6	83 e0 70	 and	 eax, 112		; 00000070H
  001d9	85 c0		 test	 eax, eax
  001db	75 0a		 jne	 SHORT $LN21@dfp_number
  001dd	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
  001e5	eb 08		 jmp	 SHORT $LN22@dfp_number
$LN21@dfp_number:
  001e7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN22@dfp_number:
  001ef	83 7c 24 30 00	 cmp	 DWORD PTR tv153[rsp], 0
  001f4	0f 85 c4 00 00
	00		 jne	 $LN12@dfp_number

; 1037 :     {
; 1038 :         /* If rounded value is greater than maximum positive number
; 1039 :            then set invalid operation otherwise set inexact */
; 1040 :         decNumberCompare(&c, &p, &mp32dn, pset);

  001fa	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  00202	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?mp32dn@?1??dfp_number_to_fix32@@9@9
  00209	48 8d 54 24 78	 lea	 rdx, QWORD PTR p$[rsp]
  0020e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR c$[rsp]
  00213	e8 00 00 00 00	 call	 decNumberCompare

; 1041 :         if (decNumberIsNegative(&c) == 0 && decNumberIsZero(&c) == 0)

  00218	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp+8]
  0021d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00222	85 c0		 test	 eax, eax
  00224	74 0a		 je	 SHORT $LN23@dfp_number
  00226	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv162[rsp], 1
  0022e	eb 08		 jmp	 SHORT $LN24@dfp_number
$LN23@dfp_number:
  00230	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN24@dfp_number:
  00238	83 7c 24 34 00	 cmp	 DWORD PTR tv162[rsp], 0
  0023d	75 5b		 jne	 SHORT $LN13@dfp_number
  0023f	b8 02 00 00 00	 mov	 eax, 2
  00244	48 6b c0 00	 imul	 rax, rax, 0
  00248	0f b7 44 04 5a	 movzx	 eax, WORD PTR c$[rsp+rax+10]
  0024d	85 c0		 test	 eax, eax
  0024f	75 1d		 jne	 SHORT $LN25@dfp_number
  00251	83 7c 24 50 01	 cmp	 DWORD PTR c$[rsp], 1
  00256	75 16		 jne	 SHORT $LN25@dfp_number
  00258	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp+8]
  0025d	83 e0 70	 and	 eax, 112		; 00000070H
  00260	85 c0		 test	 eax, eax
  00262	75 0a		 jne	 SHORT $LN25@dfp_number
  00264	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv172[rsp], 1
  0026c	eb 08		 jmp	 SHORT $LN26@dfp_number
$LN25@dfp_number:
  0026e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN26@dfp_number:
  00276	83 7c 24 38 00	 cmp	 DWORD PTR tv172[rsp], 0
  0027b	75 1d		 jne	 SHORT $LN13@dfp_number

; 1042 :             pset->status |= DEC_IEEE_854_Invalid_operation;

  0027d	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  00285	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00288	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  0028d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  00295	89 41 14	 mov	 DWORD PTR [rcx+20], eax
  00298	eb 19		 jmp	 SHORT $LN14@dfp_number
$LN13@dfp_number:

; 1043 :         else
; 1044 :             pset->status |= DEC_IEEE_854_Inexact;

  0029a	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  002a2	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  002a5	83 c8 20	 or	 eax, 32			; 00000020H
  002a8	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  002b0	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN14@dfp_number:

; 1045 : 
; 1046 :         /* Return maximum positive result */
; 1047 :         return (S32)mp32;

  002b3	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?mp32@?1??dfp_number_to_fix32@@9@9
  002b9	e9 c9 01 00 00	 jmp	 $LN1@dfp_number
$LN12@dfp_number:

; 1048 :     }
; 1049 : 
; 1050 :     /* Raise inexact condition if result was rounded */
; 1051 :     decNumberCompare(&c, &p, b, pset);

  002be	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  002c6	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR b$[rsp]
  002ce	48 8d 54 24 78	 lea	 rdx, QWORD PTR p$[rsp]
  002d3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR c$[rsp]
  002d8	e8 00 00 00 00	 call	 decNumberCompare

; 1052 :     if (decNumberIsZero(&c) == 0)

  002dd	b8 02 00 00 00	 mov	 eax, 2
  002e2	48 6b c0 00	 imul	 rax, rax, 0
  002e6	0f b7 44 04 5a	 movzx	 eax, WORD PTR c$[rsp+rax+10]
  002eb	85 c0		 test	 eax, eax
  002ed	75 1d		 jne	 SHORT $LN27@dfp_number
  002ef	83 7c 24 50 01	 cmp	 DWORD PTR c$[rsp], 1
  002f4	75 16		 jne	 SHORT $LN27@dfp_number
  002f6	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp+8]
  002fb	83 e0 70	 and	 eax, 112		; 00000070H
  002fe	85 c0		 test	 eax, eax
  00300	75 0a		 jne	 SHORT $LN27@dfp_number
  00302	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv192[rsp], 1
  0030a	eb 08		 jmp	 SHORT $LN28@dfp_number
$LN27@dfp_number:
  0030c	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
$LN28@dfp_number:
  00314	83 7c 24 3c 00	 cmp	 DWORD PTR tv192[rsp], 0
  00319	0f 85 84 00 00
	00		 jne	 $LN15@dfp_number

; 1053 :     {
; 1054 :         pset->status |= DEC_IEEE_854_Inexact;

  0031f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  00327	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0032a	83 c8 20	 or	 eax, 32			; 00000020H
  0032d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  00335	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 1055 :         if (decNumberIsNegative(&c) == decNumberIsNegative(b))

  00338	0f b6 44 24 58	 movzx	 eax, BYTE PTR c$[rsp+8]
  0033d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00342	85 c0		 test	 eax, eax
  00344	74 0a		 je	 SHORT $LN31@dfp_number
  00346	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv205[rsp], 1
  0034e	eb 08		 jmp	 SHORT $LN32@dfp_number
$LN31@dfp_number:
  00350	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv205[rsp], 0
$LN32@dfp_number:
  00358	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00360	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00364	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00369	85 c0		 test	 eax, eax
  0036b	74 0a		 je	 SHORT $LN29@dfp_number
  0036d	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv204[rsp], 1
  00375	eb 08		 jmp	 SHORT $LN30@dfp_number
$LN29@dfp_number:
  00377	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
$LN30@dfp_number:
  0037f	8b 44 24 40	 mov	 eax, DWORD PTR tv204[rsp]
  00383	39 44 24 44	 cmp	 DWORD PTR tv205[rsp], eax
  00387	75 1a		 jne	 SHORT $LN16@dfp_number

; 1056 :             pset->status |= DEC_Rounded;

  00389	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  00391	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00394	0f ba e8 0b	 bts	 eax, 11
  00398	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  003a0	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN16@dfp_number:
$LN15@dfp_number:

; 1057 :     }
; 1058 : 
; 1059 :     /* Convert decimal number structure to packed decimal */
; 1060 :     decPackedFromNumber(packed, sizeof(packed), &scale, &p);

  003a3	4c 8d 4c 24 78	 lea	 r9, QWORD PTR p$[rsp]
  003a8	4c 8d 44 24 28	 lea	 r8, QWORD PTR scale$[rsp]
  003ad	ba 11 00 00 00	 mov	 edx, 17
  003b2	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR packed$[rsp]
  003ba	e8 00 00 00 00	 call	 decPackedFromNumber

; 1061 : 
; 1062 :     /* Convert packed decimal to binary value */
; 1063 :     for (i = 0, n = 0; i < sizeof(packed)-1; i++)

  003bf	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003c7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  003cf	eb 0a		 jmp	 SHORT $LN4@dfp_number
$LN2@dfp_number:
  003d1	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  003d5	ff c0		 inc	 eax
  003d7	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@dfp_number:
  003db	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  003df	48 83 f8 10	 cmp	 rax, 16
  003e3	73 3c		 jae	 SHORT $LN3@dfp_number

; 1064 :     {
; 1065 :         n = n * 10 + ((packed[i] & 0xF0) >> 4);

  003e5	6b 44 24 20 0a	 imul	 eax, DWORD PTR n$[rsp], 10
  003ea	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  003ee	0f b6 8c 0c c0
	00 00 00	 movzx	 ecx, BYTE PTR packed$[rsp+rcx]
  003f6	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  003fc	c1 f9 04	 sar	 ecx, 4
  003ff	03 c1		 add	 eax, ecx
  00401	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 1066 :         n = n * 10 + (packed[i] & 0x0F);

  00405	6b 44 24 20 0a	 imul	 eax, DWORD PTR n$[rsp], 10
  0040a	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  0040e	0f b6 8c 0c c0
	00 00 00	 movzx	 ecx, BYTE PTR packed$[rsp+rcx]
  00416	83 e1 0f	 and	 ecx, 15
  00419	03 c1		 add	 eax, ecx
  0041b	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 1067 :     }

  0041f	eb b0		 jmp	 SHORT $LN2@dfp_number
$LN3@dfp_number:

; 1068 :     n = n * 10 + ((packed[i] & 0xF0) >> 4);

  00421	6b 44 24 20 0a	 imul	 eax, DWORD PTR n$[rsp], 10
  00426	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  0042a	0f b6 8c 0c c0
	00 00 00	 movzx	 ecx, BYTE PTR packed$[rsp+rcx]
  00432	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00438	c1 f9 04	 sar	 ecx, 4
  0043b	03 c1		 add	 eax, ecx
  0043d	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
$LN5@dfp_number:

; 1069 :     while (scale++) n *= 10;

  00441	8b 44 24 28	 mov	 eax, DWORD PTR scale$[rsp]
  00445	89 44 24 48	 mov	 DWORD PTR tv242[rsp], eax
  00449	8b 44 24 28	 mov	 eax, DWORD PTR scale$[rsp]
  0044d	ff c0		 inc	 eax
  0044f	89 44 24 28	 mov	 DWORD PTR scale$[rsp], eax
  00453	83 7c 24 48 00	 cmp	 DWORD PTR tv242[rsp], 0
  00458	74 0b		 je	 SHORT $LN6@dfp_number
  0045a	6b 44 24 20 0a	 imul	 eax, DWORD PTR n$[rsp], 10
  0045f	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
  00463	eb dc		 jmp	 SHORT $LN5@dfp_number
$LN6@dfp_number:

; 1070 :     if ((packed[i] & 0x0F) == 0x0D) n = -n;

  00465	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00469	0f b6 84 04 c0
	00 00 00	 movzx	 eax, BYTE PTR packed$[rsp+rax]
  00471	83 e0 0f	 and	 eax, 15
  00474	83 f8 0d	 cmp	 eax, 13
  00477	75 0a		 jne	 SHORT $LN17@dfp_number
  00479	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0047d	f7 d8		 neg	 eax
  0047f	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
$LN17@dfp_number:

; 1071 : 
; 1072 :     /* Return 32-bit signed result */
; 1073 :     return n;

  00483	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
$LN1@dfp_number:

; 1074 : 
; 1075 : } /* end function dfp_number_to_fix32 */

  00487	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0048f	48 33 cc	 xor	 rcx, rsp
  00492	e8 00 00 00 00	 call	 __security_check_cookie
  00497	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0049e	c3		 ret	 0
dfp_number_to_fix32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
$T1 = 40
zoned$ = 48
__$ArrayPad$ = 80
dn$ = 112
n$ = 120
pset$ = 128
dfp_number_from_u64 PROC

; 944  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 945  : int             i;                      /* Counter                   */
; 946  : char            zoned[32];              /* Zoned decimal work area   */
; 947  : 
; 948  :     /* Convert unsigned binary value to zoned decimal */
; 949  :     i = sizeof(zoned) - 1;

  00022	c7 44 24 20 1f
	00 00 00	 mov	 DWORD PTR i$[rsp], 31

; 950  :     zoned[i] = '\0';

  0002a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0002f	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00034	48 83 7c 24 28
	20		 cmp	 QWORD PTR $T1[rsp], 32	; 00000020H
  0003a	73 02		 jae	 SHORT $LN7@dfp_number
  0003c	eb 05		 jmp	 SHORT $LN8@dfp_number
$LN7@dfp_number:
  0003e	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN8@dfp_number:
  00043	48 8b 44 24 28	 mov	 rax, QWORD PTR $T1[rsp]
  00048	c6 44 04 30 00	 mov	 BYTE PTR zoned$[rsp+rax], 0
$LN4@dfp_number:

; 951  :     do {
; 952  :         zoned[--i] = (n % 10) + '0';

  0004d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00051	ff c8		 dec	 eax
  00053	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00057	33 d2		 xor	 edx, edx
  00059	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0005e	b9 0a 00 00 00	 mov	 ecx, 10
  00063	48 f7 f1	 div	 rcx
  00066	48 8b c2	 mov	 rax, rdx
  00069	48 83 c0 30	 add	 rax, 48			; 00000030H
  0006d	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00072	88 44 0c 30	 mov	 BYTE PTR zoned$[rsp+rcx], al

; 953  :         n /= 10;

  00076	33 d2		 xor	 edx, edx
  00078	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  0007d	b9 0a 00 00 00	 mov	 ecx, 10
  00082	48 f7 f1	 div	 rcx
  00085	48 89 44 24 78	 mov	 QWORD PTR n$[rsp], rax

; 954  :     } while(i > 1 && n > 0);

  0008a	83 7c 24 20 01	 cmp	 DWORD PTR i$[rsp], 1
  0008f	7e 08		 jle	 SHORT $LN5@dfp_number
  00091	48 83 7c 24 78
	00		 cmp	 QWORD PTR n$[rsp], 0
  00097	77 b4		 ja	 SHORT $LN4@dfp_number
$LN5@dfp_number:

; 955  : 
; 956  :     /* Convert zoned decimal value to decimal number structure */
; 957  :     decNumberFromString(dn, zoned+i, pset);

  00099	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0009e	48 8d 44 04 30	 lea	 rax, QWORD PTR zoned$[rsp+rax]
  000a3	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pset$[rsp]
  000ab	48 8b d0	 mov	 rdx, rax
  000ae	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dn$[rsp]
  000b3	e8 00 00 00 00	 call	 decNumberFromString
$LN6@dfp_number:

; 958  : 
; 959  : } /* end function dfp_number_from_u64 */

  000b8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000bd	48 33 cc	 xor	 rcx, rsp
  000c0	e8 00 00 00 00	 call	 __security_check_cookie
  000c5	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000c9	c3		 ret	 0
dfp_number_from_u64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
$T1 = 40
zoned$ = 48
__$ArrayPad$ = 80
dn$ = 112
n$ = 120
pset$ = 128
dfp_number_from_u32 PROC

; 909  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 910  : int             i;                      /* Counter                   */
; 911  : char            zoned[32];              /* Zoned decimal work area   */
; 912  : 
; 913  :     /* Convert unsigned binary value to zoned decimal */
; 914  :     i = sizeof(zoned) - 1;

  00021	c7 44 24 20 1f
	00 00 00	 mov	 DWORD PTR i$[rsp], 31

; 915  :     zoned[i] = '\0';

  00029	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0002e	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00033	48 83 7c 24 28
	20		 cmp	 QWORD PTR $T1[rsp], 32	; 00000020H
  00039	73 02		 jae	 SHORT $LN7@dfp_number
  0003b	eb 05		 jmp	 SHORT $LN8@dfp_number
$LN7@dfp_number:
  0003d	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN8@dfp_number:
  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR $T1[rsp]
  00047	c6 44 04 30 00	 mov	 BYTE PTR zoned$[rsp+rax], 0
$LN4@dfp_number:

; 916  :     do {
; 917  :         zoned[--i] = (n % 10) + '0';

  0004c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00050	ff c8		 dec	 eax
  00052	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00056	33 d2		 xor	 edx, edx
  00058	8b 44 24 78	 mov	 eax, DWORD PTR n$[rsp]
  0005c	b9 0a 00 00 00	 mov	 ecx, 10
  00061	f7 f1		 div	 ecx
  00063	8b c2		 mov	 eax, edx
  00065	83 c0 30	 add	 eax, 48			; 00000030H
  00068	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0006d	88 44 0c 30	 mov	 BYTE PTR zoned$[rsp+rcx], al

; 918  :         n /= 10;

  00071	33 d2		 xor	 edx, edx
  00073	8b 44 24 78	 mov	 eax, DWORD PTR n$[rsp]
  00077	b9 0a 00 00 00	 mov	 ecx, 10
  0007c	f7 f1		 div	 ecx
  0007e	89 44 24 78	 mov	 DWORD PTR n$[rsp], eax

; 919  :     } while(i > 1 && n > 0);

  00082	83 7c 24 20 01	 cmp	 DWORD PTR i$[rsp], 1
  00087	7e 07		 jle	 SHORT $LN5@dfp_number
  00089	83 7c 24 78 00	 cmp	 DWORD PTR n$[rsp], 0
  0008e	77 bc		 ja	 SHORT $LN4@dfp_number
$LN5@dfp_number:

; 920  : 
; 921  :     /* Convert zoned decimal value to decimal number structure */
; 922  :     decNumberFromString(dn, zoned+i, pset);

  00090	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00095	48 8d 44 04 30	 lea	 rax, QWORD PTR zoned$[rsp+rax]
  0009a	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pset$[rsp]
  000a2	48 8b d0	 mov	 rdx, rax
  000a5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dn$[rsp]
  000aa	e8 00 00 00 00	 call	 decNumberFromString
$LN6@dfp_number:

; 923  : 
; 924  : } /* end function dfp_number_from_u32 */

  000af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b4	48 33 cc	 xor	 rcx, rsp
  000b7	e8 00 00 00 00	 call	 __security_check_cookie
  000bc	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000c0	c3		 ret	 0
dfp_number_from_u32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
sign$ = 36
$T1 = 40
zoned$ = 48
__$ArrayPad$ = 80
dn$ = 112
n$ = 120
pset$ = 128
dfp_number_from_fix32 PROC

; 862  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 863  : int             sign = 0;               /* Sign of binary integer    */

  00021	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR sign$[rsp], 0

; 864  : int             i;                      /* Counter                   */
; 865  : char            zoned[32];              /* Zoned decimal work area   */
; 866  : static char     maxnegzd[]="-2147483648";
; 867  : static U32      maxneg32 = 0x80000000UL;
; 868  : 
; 869  :     /* Handle maximum negative number as special case */
; 870  :     if (n == (S32)maxneg32)

  00029	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?maxneg32@?1??dfp_number_from_fix32@@9@9
  0002f	39 44 24 78	 cmp	 DWORD PTR n$[rsp], eax
  00033	75 1e		 jne	 SHORT $LN5@dfp_number

; 871  :     {
; 872  :         decNumberFromString(dn, maxnegzd, pset);

  00035	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pset$[rsp]
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?maxnegzd@?1??dfp_number_from_fix32@@9@9
  00044	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dn$[rsp]
  00049	e8 00 00 00 00	 call	 decNumberFromString

; 873  :         return;

  0004e	e9 c0 00 00 00	 jmp	 $LN1@dfp_number
$LN5@dfp_number:

; 874  :     }
; 875  : 
; 876  :     /* Convert binary value to zoned decimal */
; 877  :     if (n < 0) { n = -n; sign = 1; }

  00053	83 7c 24 78 00	 cmp	 DWORD PTR n$[rsp], 0
  00058	7d 12		 jge	 SHORT $LN6@dfp_number
  0005a	8b 44 24 78	 mov	 eax, DWORD PTR n$[rsp]
  0005e	f7 d8		 neg	 eax
  00060	89 44 24 78	 mov	 DWORD PTR n$[rsp], eax
  00064	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1
$LN6@dfp_number:

; 878  :     i = sizeof(zoned) - 1;

  0006c	c7 44 24 20 1f
	00 00 00	 mov	 DWORD PTR i$[rsp], 31

; 879  :     zoned[i] = '\0';

  00074	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00079	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  0007e	48 83 7c 24 28
	20		 cmp	 QWORD PTR $T1[rsp], 32	; 00000020H
  00084	73 02		 jae	 SHORT $LN10@dfp_number
  00086	eb 05		 jmp	 SHORT $LN11@dfp_number
$LN10@dfp_number:
  00088	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN11@dfp_number:
  0008d	48 8b 44 24 28	 mov	 rax, QWORD PTR $T1[rsp]
  00092	c6 44 04 30 00	 mov	 BYTE PTR zoned$[rsp+rax], 0
$LN4@dfp_number:

; 880  :     do {
; 881  :         zoned[--i] = (n % 10) + '0';

  00097	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0009b	ff c8		 dec	 eax
  0009d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  000a1	8b 44 24 78	 mov	 eax, DWORD PTR n$[rsp]
  000a5	99		 cdq
  000a6	b9 0a 00 00 00	 mov	 ecx, 10
  000ab	f7 f9		 idiv	 ecx
  000ad	8b c2		 mov	 eax, edx
  000af	83 c0 30	 add	 eax, 48			; 00000030H
  000b2	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000b7	88 44 0c 30	 mov	 BYTE PTR zoned$[rsp+rcx], al

; 882  :         n /= 10;

  000bb	8b 44 24 78	 mov	 eax, DWORD PTR n$[rsp]
  000bf	99		 cdq
  000c0	b9 0a 00 00 00	 mov	 ecx, 10
  000c5	f7 f9		 idiv	 ecx
  000c7	89 44 24 78	 mov	 DWORD PTR n$[rsp], eax

; 883  :     } while(i > 1 && n > 0);

  000cb	83 7c 24 20 01	 cmp	 DWORD PTR i$[rsp], 1
  000d0	7e 07		 jle	 SHORT $LN7@dfp_number
  000d2	83 7c 24 78 00	 cmp	 DWORD PTR n$[rsp], 0
  000d7	7f be		 jg	 SHORT $LN4@dfp_number
$LN7@dfp_number:

; 884  :     if (sign) zoned[--i] = '-';

  000d9	83 7c 24 24 00	 cmp	 DWORD PTR sign$[rsp], 0
  000de	74 14		 je	 SHORT $LN8@dfp_number
  000e0	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000e4	ff c8		 dec	 eax
  000e6	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  000ea	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000ef	c6 44 04 30 2d	 mov	 BYTE PTR zoned$[rsp+rax], 45 ; 0000002dH
$LN8@dfp_number:

; 885  : 
; 886  :     /* Convert zoned decimal value to decimal number structure */
; 887  :     decNumberFromString(dn, zoned+i, pset);

  000f4	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000f9	48 8d 44 04 30	 lea	 rax, QWORD PTR zoned$[rsp+rax]
  000fe	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pset$[rsp]
  00106	48 8b d0	 mov	 rdx, rax
  00109	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dn$[rsp]
  0010e	e8 00 00 00 00	 call	 decNumberFromString
$LN1@dfp_number:
$LN9@dfp_number:

; 888  : 
; 889  : } /* end function dfp_number_from_fix32 */

  00113	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00118	48 33 cc	 xor	 rcx, rsp
  0011b	e8 00 00 00 00	 call	 __security_check_cookie
  00120	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00124	c3		 ret	 0
dfp_number_from_fix32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
bitn$ = 0
exp$ = 4
tv72 = 8
tv85 = 12
extreme$ = 16
tv128 = 20
pset$ = 48
dn$ = 56
lmd$ = 64
bits$ = 72
dfp_test_data_group PROC

; 811  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 812  : int             bitn;                   /* Bit number                */
; 813  : int             extreme;                /* 1=exponent is min or max  */
; 814  : int             exp;                    /* Adjusted exponent         */
; 815  : 
; 816  :     exp = dn->exponent + pset->digits - 1;

  00018	48 8b 44 24 38	 mov	 rax, QWORD PTR dn$[rsp]
  0001d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pset$[rsp]
  00025	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00027	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0002b	89 44 24 04	 mov	 DWORD PTR exp$[rsp], eax

; 817  :     extreme = (exp == pset->emin) || (exp == pset->emax);

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR pset$[rsp]
  00034	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00037	39 44 24 04	 cmp	 DWORD PTR exp$[rsp], eax
  0003b	74 18		 je	 SHORT $LN11@dfp_test_d
  0003d	48 8b 44 24 30	 mov	 rax, QWORD PTR pset$[rsp]
  00042	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00045	39 44 24 04	 cmp	 DWORD PTR exp$[rsp], eax
  00049	74 0a		 je	 SHORT $LN11@dfp_test_d
  0004b	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
  00053	eb 08		 jmp	 SHORT $LN12@dfp_test_d
$LN11@dfp_test_d:
  00055	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
$LN12@dfp_test_d:
  0005d	8b 44 24 08	 mov	 eax, DWORD PTR tv72[rsp]
  00061	89 44 24 10	 mov	 DWORD PTR extreme$[rsp], eax

; 818  : 
; 819  :     if (decNumberIsZero(dn))

  00065	b8 02 00 00 00	 mov	 eax, 2
  0006a	48 6b c0 00	 imul	 rax, rax, 0
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dn$[rsp]
  00073	0f b7 44 01 0a	 movzx	 eax, WORD PTR [rcx+rax+10]
  00078	85 c0		 test	 eax, eax
  0007a	75 3c		 jne	 SHORT $LN2@dfp_test_d
  0007c	48 8b 44 24 38	 mov	 rax, QWORD PTR dn$[rsp]
  00081	83 38 01	 cmp	 DWORD PTR [rax], 1
  00084	75 32		 jne	 SHORT $LN2@dfp_test_d
  00086	48 8b 44 24 38	 mov	 rax, QWORD PTR dn$[rsp]
  0008b	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  0008f	83 e0 70	 and	 eax, 112		; 00000070H
  00092	85 c0		 test	 eax, eax
  00094	75 22		 jne	 SHORT $LN2@dfp_test_d

; 820  :         bitn = extreme ?

  00096	83 7c 24 10 00	 cmp	 DWORD PTR extreme$[rsp], 0
  0009b	74 0a		 je	 SHORT $LN13@dfp_test_d
  0009d	c7 44 24 0c 36
	00 00 00	 mov	 DWORD PTR tv85[rsp], 54	; 00000036H
  000a5	eb 08		 jmp	 SHORT $LN14@dfp_test_d
$LN13@dfp_test_d:
  000a7	c7 44 24 0c 34
	00 00 00	 mov	 DWORD PTR tv85[rsp], 52	; 00000034H
$LN14@dfp_test_d:
  000af	8b 44 24 0c	 mov	 eax, DWORD PTR tv85[rsp]
  000b3	89 04 24	 mov	 DWORD PTR bitn$[rsp], eax
  000b6	eb 59		 jmp	 SHORT $LN3@dfp_test_d
$LN2@dfp_test_d:

; 821  :                 DFP_TDG_EXTREME_ZERO :
; 822  :                 DFP_TDG_SAFE_ZERO ;
; 823  :     else if (decNumberIsInfinite(dn) || decNumberIsNaN(dn))

  000b8	48 8b 44 24 38	 mov	 rax, QWORD PTR dn$[rsp]
  000bd	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  000c1	83 e0 40	 and	 eax, 64			; 00000040H
  000c4	85 c0		 test	 eax, eax
  000c6	75 10		 jne	 SHORT $LN6@dfp_test_d
  000c8	48 8b 44 24 38	 mov	 rax, QWORD PTR dn$[rsp]
  000cd	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  000d1	83 e0 30	 and	 eax, 48			; 00000030H
  000d4	85 c0		 test	 eax, eax
  000d6	74 09		 je	 SHORT $LN4@dfp_test_d
$LN6@dfp_test_d:

; 824  :         bitn = DFP_TDG_SPECIAL;

  000d8	c7 04 24 3e 00
	00 00		 mov	 DWORD PTR bitn$[rsp], 62 ; 0000003eH
  000df	eb 30		 jmp	 SHORT $LN5@dfp_test_d
$LN4@dfp_test_d:

; 825  :     else if (extreme)

  000e1	83 7c 24 10 00	 cmp	 DWORD PTR extreme$[rsp], 0
  000e6	74 09		 je	 SHORT $LN7@dfp_test_d

; 826  :         bitn = DFP_TDG_EXTREME_NONZERO;

  000e8	c7 04 24 38 00
	00 00		 mov	 DWORD PTR bitn$[rsp], 56 ; 00000038H
  000ef	eb 20		 jmp	 SHORT $LN8@dfp_test_d
$LN7@dfp_test_d:

; 827  :     else {
; 828  :         bitn = (lmd == 0) ?

  000f1	83 7c 24 40 00	 cmp	 DWORD PTR lmd$[rsp], 0
  000f6	75 0a		 jne	 SHORT $LN15@dfp_test_d
  000f8	c7 44 24 14 3a
	00 00 00	 mov	 DWORD PTR tv128[rsp], 58 ; 0000003aH
  00100	eb 08		 jmp	 SHORT $LN16@dfp_test_d
$LN15@dfp_test_d:
  00102	c7 44 24 14 3c
	00 00 00	 mov	 DWORD PTR tv128[rsp], 60 ; 0000003cH
$LN16@dfp_test_d:
  0010a	8b 44 24 14	 mov	 eax, DWORD PTR tv128[rsp]
  0010e	89 04 24	 mov	 DWORD PTR bitn$[rsp], eax
$LN8@dfp_test_d:
$LN5@dfp_test_d:
$LN3@dfp_test_d:

; 829  :                 DFP_TDG_SAFE_NZ_LMD_Z :
; 830  :                 DFP_TDG_SAFE_NZ_LMD_NZ ;
; 831  :     }
; 832  : 
; 833  :     if (decNumberIsNegative(dn)) bitn++;

  00111	48 8b 44 24 38	 mov	 rax, QWORD PTR dn$[rsp]
  00116	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  0011a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0011f	85 c0		 test	 eax, eax
  00121	74 08		 je	 SHORT $LN9@dfp_test_d
  00123	8b 04 24	 mov	 eax, DWORD PTR bitn$[rsp]
  00126	ff c0		 inc	 eax
  00128	89 04 24	 mov	 DWORD PTR bitn$[rsp], eax
$LN9@dfp_test_d:

; 834  : 
; 835  :     return (bits >> (63 - bitn)) & 0x01;

  0012b	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00130	2b 04 24	 sub	 eax, DWORD PTR bitn$[rsp]
  00133	0f b6 c8	 movzx	 ecx, al
  00136	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0013a	d3 e8		 shr	 eax, cl
  0013c	83 e0 01	 and	 eax, 1

; 836  : 
; 837  : } /* end function dfp_test_data_group */

  0013f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00143	c3		 ret	 0
dfp_test_data_group ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
bitn$ = 32
tv92 = 36
dm$ = 40
__$ArrayPad$ = 80
pset$ = 112
dn$ = 120
bits$ = 128
dfp_test_data_class PROC

; 758  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 759  : int             bitn;                   /* Bit number                */
; 760  : decNumber       dm;                     /* Normalized value of dn    */
; 761  : 
; 762  :     if (decNumberIsZero(dn))

  00022	b8 02 00 00 00	 mov	 eax, 2
  00027	48 6b c0 00	 imul	 rax, rax, 0
  0002b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dn$[rsp]
  00030	0f b7 44 01 0a	 movzx	 eax, WORD PTR [rcx+rax+10]
  00035	85 c0		 test	 eax, eax
  00037	75 27		 jne	 SHORT $LN2@dfp_test_d
  00039	48 8b 44 24 78	 mov	 rax, QWORD PTR dn$[rsp]
  0003e	83 38 01	 cmp	 DWORD PTR [rax], 1
  00041	75 1d		 jne	 SHORT $LN2@dfp_test_d
  00043	48 8b 44 24 78	 mov	 rax, QWORD PTR dn$[rsp]
  00048	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  0004c	83 e0 70	 and	 eax, 112		; 00000070H
  0004f	85 c0		 test	 eax, eax
  00051	75 0d		 jne	 SHORT $LN2@dfp_test_d

; 763  :         bitn = DFP_TDC_ZERO;

  00053	c7 44 24 20 34
	00 00 00	 mov	 DWORD PTR bitn$[rsp], 52 ; 00000034H
  0005b	e9 8a 00 00 00	 jmp	 $LN3@dfp_test_d
$LN2@dfp_test_d:

; 764  :     else if (decNumberIsInfinite(dn))

  00060	48 8b 44 24 78	 mov	 rax, QWORD PTR dn$[rsp]
  00065	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00069	83 e0 40	 and	 eax, 64			; 00000040H
  0006c	85 c0		 test	 eax, eax
  0006e	74 0a		 je	 SHORT $LN4@dfp_test_d

; 765  :         bitn = DFP_TDC_INFINITY;

  00070	c7 44 24 20 3a
	00 00 00	 mov	 DWORD PTR bitn$[rsp], 58 ; 0000003aH
  00078	eb 70		 jmp	 SHORT $LN5@dfp_test_d
$LN4@dfp_test_d:

; 766  :     else if (decNumberIsQNaN(dn))

  0007a	48 8b 44 24 78	 mov	 rax, QWORD PTR dn$[rsp]
  0007f	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00083	83 e0 20	 and	 eax, 32			; 00000020H
  00086	85 c0		 test	 eax, eax
  00088	74 0a		 je	 SHORT $LN6@dfp_test_d

; 767  :         bitn = DFP_TDC_QUIET_NAN;

  0008a	c7 44 24 20 3c
	00 00 00	 mov	 DWORD PTR bitn$[rsp], 60 ; 0000003cH
  00092	eb 56		 jmp	 SHORT $LN7@dfp_test_d
$LN6@dfp_test_d:

; 768  :     else if (decNumberIsSNaN(dn))

  00094	48 8b 44 24 78	 mov	 rax, QWORD PTR dn$[rsp]
  00099	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  0009d	83 e0 10	 and	 eax, 16
  000a0	85 c0		 test	 eax, eax
  000a2	74 0a		 je	 SHORT $LN8@dfp_test_d

; 769  :         bitn = DFP_TDC_SIGNALING_NAN;

  000a4	c7 44 24 20 3e
	00 00 00	 mov	 DWORD PTR bitn$[rsp], 62 ; 0000003eH
  000ac	eb 3c		 jmp	 SHORT $LN9@dfp_test_d
$LN8@dfp_test_d:

; 770  :     else {
; 771  :         decNumberNormalize(&dm, dn, pset);

  000ae	4c 8b 44 24 70	 mov	 r8, QWORD PTR pset$[rsp]
  000b3	48 8b 54 24 78	 mov	 rdx, QWORD PTR dn$[rsp]
  000b8	48 8d 4c 24 28	 lea	 rcx, QWORD PTR dm$[rsp]
  000bd	e8 00 00 00 00	 call	 decNumberNormalize

; 772  :         bitn = (dm.exponent < pset->emin) ?

  000c2	48 8b 44 24 70	 mov	 rax, QWORD PTR pset$[rsp]
  000c7	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000ca	39 44 24 2c	 cmp	 DWORD PTR dm$[rsp+4], eax
  000ce	7d 0a		 jge	 SHORT $LN12@dfp_test_d
  000d0	c7 44 24 24 36
	00 00 00	 mov	 DWORD PTR tv92[rsp], 54	; 00000036H
  000d8	eb 08		 jmp	 SHORT $LN13@dfp_test_d
$LN12@dfp_test_d:
  000da	c7 44 24 24 38
	00 00 00	 mov	 DWORD PTR tv92[rsp], 56	; 00000038H
$LN13@dfp_test_d:
  000e2	8b 44 24 24	 mov	 eax, DWORD PTR tv92[rsp]
  000e6	89 44 24 20	 mov	 DWORD PTR bitn$[rsp], eax
$LN9@dfp_test_d:
$LN7@dfp_test_d:
$LN5@dfp_test_d:
$LN3@dfp_test_d:

; 773  :                 DFP_TDC_SUBNORMAL :
; 774  :                 DFP_TDC_NORMAL ;
; 775  :     }
; 776  : 
; 777  :     if (decNumberIsNegative(dn)) bitn++;

  000ea	48 8b 44 24 78	 mov	 rax, QWORD PTR dn$[rsp]
  000ef	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  000f3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000f8	85 c0		 test	 eax, eax
  000fa	74 0a		 je	 SHORT $LN10@dfp_test_d
  000fc	8b 44 24 20	 mov	 eax, DWORD PTR bitn$[rsp]
  00100	ff c0		 inc	 eax
  00102	89 44 24 20	 mov	 DWORD PTR bitn$[rsp], eax
$LN10@dfp_test_d:

; 778  : 
; 779  :     return (bits >> (63 - bitn)) & 0x01;

  00106	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  0010b	2b 44 24 20	 sub	 eax, DWORD PTR bitn$[rsp]
  0010f	0f b6 c8	 movzx	 ecx, al
  00112	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR bits$[rsp]
  00119	d3 e8		 shr	 eax, cl
  0011b	83 e0 01	 and	 eax, 1

; 780  : 
; 781  : } /* end function dfp_test_data_class */

  0011e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00123	48 33 cc	 xor	 rcx, rsp
  00126	e8 00 00 00 00	 call	 __security_check_cookie
  0012b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0012f	c3		 ret	 0
dfp_test_data_class ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
bits$ = 32
len$ = 40
tv91 = 48
maxlen$ = 56
exp$ = 64
$T1 = 72
tv79 = 80
zd$ = 96
__$ArrayPad$ = 208
pset$ = 240
dn$ = 248
count$ = 256
dfp_shift_coeff PROC

; 687  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 688  : size_t          len;                    /* String length             */
; 689  : size_t          maxlen;                 /* Maximum coefficient length*/
; 690  : int32_t         exp;                    /* Original exponent         */
; 691  : uint8_t         bits;                   /* Original flag bits        */
; 692  : char            zd[MAXDECSTRLEN+64];    /* Zoned decimal work area   */
; 693  : 
; 694  :     /* Save original exponent and sign/Inf/NaN bits */
; 695  :     exp = dn->exponent;

  00029	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  00031	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00034	89 44 24 40	 mov	 DWORD PTR exp$[rsp], eax

; 696  :     bits = dn->bits;

  00038	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  00040	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00044	88 44 24 20	 mov	 BYTE PTR bits$[rsp], al

; 697  : 
; 698  :     /* Clear exponent and sign/Inf/NaN bits */
; 699  :     dn->exponent = 0;

  00048	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  00050	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 700  :     dn->bits &= ~(DECNEG | DECSPECIAL);

  00057	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  0005f	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00063	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  00068	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  00070	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 701  : 
; 702  :     /* Convert coefficient digits to zoned decimal */
; 703  :     decNumberToString(dn, zd);

  00073	48 8d 54 24 60	 lea	 rdx, QWORD PTR zd$[rsp]
  00078	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  00080	e8 00 00 00 00	 call	 decNumberToString

; 704  :     len = strlen(zd);

  00085	48 8d 4c 24 60	 lea	 rcx, QWORD PTR zd$[rsp]
  0008a	e8 00 00 00 00	 call	 strlen
  0008f	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax

; 705  : 
; 706  :     /* Shift zoned digits left or right */
; 707  :     if (count > 0)

  00094	83 bc 24 00 01
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  0009c	7e 26		 jle	 SHORT $LN2@dfp_shift_

; 708  :         memset(zd + len, '0', count);

  0009e	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR count$[rsp]
  000a6	48 89 44 24 50	 mov	 QWORD PTR tv79[rsp], rax
  000ab	48 8b 4c 24 28	 mov	 rcx, QWORD PTR len$[rsp]
  000b0	48 8d 4c 0c 60	 lea	 rcx, QWORD PTR zd$[rsp+rcx]
  000b5	48 8b f9	 mov	 rdi, rcx
  000b8	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  000bd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv79[rsp]
  000c2	f3 aa		 rep stosb
$LN2@dfp_shift_:

; 709  :     len += count;

  000c4	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR count$[rsp]
  000cc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR len$[rsp]
  000d1	48 03 c8	 add	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax

; 710  :     maxlen = (bits & DECSPECIAL) ? pset->digits - 1 : pset->digits;

  000dc	0f b6 44 24 20	 movzx	 eax, BYTE PTR bits$[rsp]
  000e1	83 e0 70	 and	 eax, 112		; 00000070H
  000e4	85 c0		 test	 eax, eax
  000e6	74 12		 je	 SHORT $LN7@dfp_shift_
  000e8	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  000f0	8b 00		 mov	 eax, DWORD PTR [rax]
  000f2	ff c8		 dec	 eax
  000f4	89 44 24 30	 mov	 DWORD PTR tv91[rsp], eax
  000f8	eb 0e		 jmp	 SHORT $LN8@dfp_shift_
$LN7@dfp_shift_:
  000fa	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  00102	8b 00		 mov	 eax, DWORD PTR [rax]
  00104	89 44 24 30	 mov	 DWORD PTR tv91[rsp], eax
$LN8@dfp_shift_:
  00108	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv91[rsp]
  0010d	48 89 44 24 38	 mov	 QWORD PTR maxlen$[rsp], rax

; 711  :     if (len > maxlen)

  00112	48 8b 44 24 38	 mov	 rax, QWORD PTR maxlen$[rsp]
  00117	48 39 44 24 28	 cmp	 QWORD PTR len$[rsp], rax
  0011c	76 2d		 jbe	 SHORT $LN3@dfp_shift_

; 712  :     {
; 713  :         memmove(zd, zd + len - maxlen, maxlen);

  0011e	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  00123	48 8d 44 04 60	 lea	 rax, QWORD PTR zd$[rsp+rax]
  00128	48 2b 44 24 38	 sub	 rax, QWORD PTR maxlen$[rsp]
  0012d	4c 8b 44 24 38	 mov	 r8, QWORD PTR maxlen$[rsp]
  00132	48 8b d0	 mov	 rdx, rax
  00135	48 8d 4c 24 60	 lea	 rcx, QWORD PTR zd$[rsp]
  0013a	e8 00 00 00 00	 call	 memmove

; 714  :         len = maxlen;

  0013f	48 8b 44 24 38	 mov	 rax, QWORD PTR maxlen$[rsp]
  00144	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax

; 715  :     }

  00149	eb 1f		 jmp	 SHORT $LN4@dfp_shift_
$LN3@dfp_shift_:

; 716  :     else if (len < 1)

  0014b	48 83 7c 24 28
	01		 cmp	 QWORD PTR len$[rsp], 1
  00151	73 17		 jae	 SHORT $LN5@dfp_shift_

; 717  :     {
; 718  :         zd[0] = '0';

  00153	b8 01 00 00 00	 mov	 eax, 1
  00158	48 6b c0 00	 imul	 rax, rax, 0
  0015c	c6 44 04 60 30	 mov	 BYTE PTR zd$[rsp+rax], 48 ; 00000030H

; 719  :         len = 1;

  00161	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR len$[rsp], 1
$LN5@dfp_shift_:
$LN4@dfp_shift_:

; 720  :     }
; 721  :     zd[len] = '\0';

  0016a	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  0016f	48 89 44 24 48	 mov	 QWORD PTR $T1[rsp], rax
  00174	48 83 7c 24 48
	6b		 cmp	 QWORD PTR $T1[rsp], 107	; 0000006bH
  0017a	73 02		 jae	 SHORT $LN9@dfp_shift_
  0017c	eb 05		 jmp	 SHORT $LN10@dfp_shift_
$LN9@dfp_shift_:
  0017e	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN10@dfp_shift_:
  00183	48 8b 44 24 48	 mov	 rax, QWORD PTR $T1[rsp]
  00188	c6 44 04 60 00	 mov	 BYTE PTR zd$[rsp+rax], 0

; 722  : 
; 723  :     /* Convert shifted coefficient to decimal number structure */
; 724  :     decNumberFromString(dn, zd, pset);

  0018d	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR pset$[rsp]
  00195	48 8d 54 24 60	 lea	 rdx, QWORD PTR zd$[rsp]
  0019a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  001a2	e8 00 00 00 00	 call	 decNumberFromString

; 725  : 
; 726  :     /* Restore original exponent and sign/Inf/NaN bits */
; 727  :     dn->exponent = exp;

  001a7	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR dn$[rsp]
  001af	8b 4c 24 40	 mov	 ecx, DWORD PTR exp$[rsp]
  001b3	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 728  :     dn->bits |= bits & (DECNEG | DECSPECIAL);

  001b6	0f b6 44 24 20	 movzx	 eax, BYTE PTR bits$[rsp]
  001bb	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  001c0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  001c8	0f b6 49 08	 movzx	 ecx, BYTE PTR [rcx+8]
  001cc	0b c8		 or	 ecx, eax
  001ce	8b c1		 mov	 eax, ecx
  001d0	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR dn$[rsp]
  001d8	88 41 08	 mov	 BYTE PTR [rcx+8], al
$LN6@dfp_shift_:

; 729  : 
; 730  : } /* end function dfp_shift_coeff */

  001db	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e3	48 33 cc	 xor	 rcx, rsp
  001e6	e8 00 00 00 00	 call	 __security_check_cookie
  001eb	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  001f2	5f		 pop	 rdi
  001f3	c3		 ret	 0
dfp_shift_coeff ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
n$ = 40
scale$ = 48
tv143 = 52
tv153 = 56
tv162 = 60
tv172 = 64
tv192 = 68
tv204 = 72
tv205 = 76
tv245 = 80
c$ = 88
p$ = 128
setmax$ = 168
packed$ = 200
__$ArrayPad$ = 224
b$ = 256
pset$ = 264
dfp_number_to_fix64 PROC

; 569  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 570  : S64             n;                      /* 64-bit signed result      */
; 571  : int32_t         scale;                  /* Scaling factor            */
; 572  : unsigned        i;                      /* Array subscript           */
; 573  : BYTE            packed[17];             /* 33-digit packed work area */
; 574  : decNumber       p, c;                   /* Working decimal numbers   */
; 575  : static U64      mp64 = 0x7FFFFFFFFFFFFFFFULL;   /* Max pos fixed 64  */
; 576  : static U64      mn64 = 0x8000000000000000ULL;   /* Max neg fixed 64  */
; 577  : static char     mpzd[]="9223372036854775807";   /* Max pos zoned dec */
; 578  : static char     mnzd[]="-9223372036854775808";  /* Max neg zoned dec */
; 579  : static BYTE     mpflag = 0;             /* 1=mp,mn are initialized   */
; 580  : static decNumber mp, mn;                /* Decimal maximum pos,neg   */
; 581  : decContext      setmax;                 /* Working context for mp,mn */
; 582  : 
; 583  :     /* Prime the decimal number structures representing the maximum
; 584  :        positive and negative numbers representable in 64 bits. Use
; 585  :        a 128-bit DFP working context because these numbers are too
; 586  :        big to be represented in the 32-bit and 64-bit DFP formats */
; 587  :     if (mpflag == 0)

  00023	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?mpflag@?1??dfp_number_to_fix64@@9@9
  0002a	85 c0		 test	 eax, eax
  0002c	75 4f		 jne	 SHORT $LN7@dfp_number

; 588  :     {
; 589  :         decContextDefault(&setmax, DEC_INIT_DECIMAL128);

  0002e	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00033	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR setmax$[rsp]
  0003b	e8 00 00 00 00	 call	 decContextDefault

; 590  :         decNumberFromString(&mp, mpzd, &setmax);

  00040	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR setmax$[rsp]
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?mpzd@?1??dfp_number_to_fix64@@9@9
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mp@?1??dfp_number_to_fix64@@9@9
  00056	e8 00 00 00 00	 call	 decNumberFromString

; 591  :         decNumberFromString(&mn, mnzd, &setmax);

  0005b	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR setmax$[rsp]
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?mnzd@?1??dfp_number_to_fix64@@9@9
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mn@?1??dfp_number_to_fix64@@9@9
  00071	e8 00 00 00 00	 call	 decNumberFromString

; 592  :         mpflag = 1;

  00076	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?mpflag@?1??dfp_number_to_fix64@@9@9, 1
$LN7@dfp_number:

; 593  :     }
; 594  : 
; 595  :     /* If operand is a NaN then set invalid operation
; 596  :        and return maximum negative result */
; 597  :     if (decNumberIsNaN(b))

  0007d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR b$[rsp]
  00085	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00089	83 e0 30	 and	 eax, 48			; 00000030H
  0008c	85 c0		 test	 eax, eax
  0008e	74 27		 je	 SHORT $LN8@dfp_number

; 598  :     {
; 599  :         pset->status |= DEC_IEEE_854_Invalid_operation;

  00090	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  00098	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0009b	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  000a0	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  000a8	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 600  :         return (S64)mn64;

  000ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?mn64@?1??dfp_number_to_fix64@@9@9
  000b2	e9 fb 03 00 00	 jmp	 $LN1@dfp_number
$LN8@dfp_number:

; 601  :     }
; 602  : 
; 603  :     /* Remove fractional part of decimal number */
; 604  :     decNumberToIntegralValue(&p, b, pset);

  000b7	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR pset$[rsp]
  000bf	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  000c7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR p$[rsp]
  000cf	e8 00 00 00 00	 call	 decNumberToIntegralValue

; 605  : 
; 606  :     /* Special case if operand is less than maximum negative
; 607  :        number (including where operand is negative infinity) */
; 608  :     decNumberCompare(&c, b, &mn, pset);

  000d4	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  000dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?mn@?1??dfp_number_to_fix64@@9@9
  000e3	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  000eb	48 8d 4c 24 58	 lea	 rcx, QWORD PTR c$[rsp]
  000f0	e8 00 00 00 00	 call	 decNumberCompare

; 609  :     if (decNumberIsNegative(&c))

  000f5	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp+8]
  000fa	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000ff	85 c0		 test	 eax, eax
  00101	74 71		 je	 SHORT $LN9@dfp_number

; 610  :     {
; 611  :         /* If rounded value is less than maximum negative number
; 612  :            then set invalid operation otherwise set inexact */
; 613  :         decNumberCompare(&c, &p, &mn, pset);

  00103	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  0010b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?mn@?1??dfp_number_to_fix64@@9@9
  00112	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR p$[rsp]
  0011a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR c$[rsp]
  0011f	e8 00 00 00 00	 call	 decNumberCompare

; 614  :         if (decNumberIsNegative(&c))

  00124	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp+8]
  00129	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0012e	85 c0		 test	 eax, eax
  00130	74 1d		 je	 SHORT $LN10@dfp_number

; 615  :             pset->status |= DEC_IEEE_854_Invalid_operation;

  00132	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  0013a	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0013d	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00142	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  0014a	89 41 14	 mov	 DWORD PTR [rcx+20], eax
  0014d	eb 19		 jmp	 SHORT $LN11@dfp_number
$LN10@dfp_number:

; 616  :         else
; 617  :             pset->status |= DEC_IEEE_854_Inexact;

  0014f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  00157	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0015a	83 c8 20	 or	 eax, 32			; 00000020H
  0015d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  00165	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN11@dfp_number:

; 618  : 
; 619  :         /* Return maximum negative result */
; 620  :         return (S64)mn64;

  00168	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?mn64@?1??dfp_number_to_fix64@@9@9
  0016f	e9 3e 03 00 00	 jmp	 $LN1@dfp_number
$LN9@dfp_number:

; 621  :     }
; 622  : 
; 623  :     /* Special case if operand is greater than maximum positive
; 624  :        number (including where operand is positive infinity) */
; 625  :     decNumberCompare(&c, b, &mp, pset);

  00174	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  0017c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?mp@?1??dfp_number_to_fix64@@9@9
  00183	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR b$[rsp]
  0018b	48 8d 4c 24 58	 lea	 rcx, QWORD PTR c$[rsp]
  00190	e8 00 00 00 00	 call	 decNumberCompare

; 626  :     if (decNumberIsNegative(&c) == 0 && decNumberIsZero(&c) == 0)

  00195	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp+8]
  0019a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0019f	85 c0		 test	 eax, eax
  001a1	74 0a		 je	 SHORT $LN19@dfp_number
  001a3	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv143[rsp], 1
  001ab	eb 08		 jmp	 SHORT $LN20@dfp_number
$LN19@dfp_number:
  001ad	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN20@dfp_number:
  001b5	83 7c 24 34 00	 cmp	 DWORD PTR tv143[rsp], 0
  001ba	0f 85 0a 01 00
	00		 jne	 $LN12@dfp_number
  001c0	b8 02 00 00 00	 mov	 eax, 2
  001c5	48 6b c0 00	 imul	 rax, rax, 0
  001c9	0f b7 44 04 62	 movzx	 eax, WORD PTR c$[rsp+rax+10]
  001ce	85 c0		 test	 eax, eax
  001d0	75 1d		 jne	 SHORT $LN21@dfp_number
  001d2	83 7c 24 58 01	 cmp	 DWORD PTR c$[rsp], 1
  001d7	75 16		 jne	 SHORT $LN21@dfp_number
  001d9	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp+8]
  001de	83 e0 70	 and	 eax, 112		; 00000070H
  001e1	85 c0		 test	 eax, eax
  001e3	75 0a		 jne	 SHORT $LN21@dfp_number
  001e5	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
  001ed	eb 08		 jmp	 SHORT $LN22@dfp_number
$LN21@dfp_number:
  001ef	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN22@dfp_number:
  001f7	83 7c 24 38 00	 cmp	 DWORD PTR tv153[rsp], 0
  001fc	0f 85 c8 00 00
	00		 jne	 $LN12@dfp_number

; 627  :     {
; 628  :         /* If rounded value is greater than maximum positive number
; 629  :            then set invalid operation otherwise set inexact */
; 630  :         decNumberCompare(&c, &p, &mp, pset);

  00202	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  0020a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?mp@?1??dfp_number_to_fix64@@9@9
  00211	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR p$[rsp]
  00219	48 8d 4c 24 58	 lea	 rcx, QWORD PTR c$[rsp]
  0021e	e8 00 00 00 00	 call	 decNumberCompare

; 631  :         if (decNumberIsNegative(&c) == 0 && decNumberIsZero(&c) == 0)

  00223	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp+8]
  00228	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0022d	85 c0		 test	 eax, eax
  0022f	74 0a		 je	 SHORT $LN23@dfp_number
  00231	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv162[rsp], 1
  00239	eb 08		 jmp	 SHORT $LN24@dfp_number
$LN23@dfp_number:
  0023b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN24@dfp_number:
  00243	83 7c 24 3c 00	 cmp	 DWORD PTR tv162[rsp], 0
  00248	75 5b		 jne	 SHORT $LN13@dfp_number
  0024a	b8 02 00 00 00	 mov	 eax, 2
  0024f	48 6b c0 00	 imul	 rax, rax, 0
  00253	0f b7 44 04 62	 movzx	 eax, WORD PTR c$[rsp+rax+10]
  00258	85 c0		 test	 eax, eax
  0025a	75 1d		 jne	 SHORT $LN25@dfp_number
  0025c	83 7c 24 58 01	 cmp	 DWORD PTR c$[rsp], 1
  00261	75 16		 jne	 SHORT $LN25@dfp_number
  00263	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp+8]
  00268	83 e0 70	 and	 eax, 112		; 00000070H
  0026b	85 c0		 test	 eax, eax
  0026d	75 0a		 jne	 SHORT $LN25@dfp_number
  0026f	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv172[rsp], 1
  00277	eb 08		 jmp	 SHORT $LN26@dfp_number
$LN25@dfp_number:
  00279	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN26@dfp_number:
  00281	83 7c 24 40 00	 cmp	 DWORD PTR tv172[rsp], 0
  00286	75 1d		 jne	 SHORT $LN13@dfp_number

; 632  :             pset->status |= DEC_IEEE_854_Invalid_operation;

  00288	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  00290	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00293	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00298	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  002a0	89 41 14	 mov	 DWORD PTR [rcx+20], eax
  002a3	eb 19		 jmp	 SHORT $LN14@dfp_number
$LN13@dfp_number:

; 633  :         else
; 634  :             pset->status |= DEC_IEEE_854_Inexact;

  002a5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  002ad	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  002b0	83 c8 20	 or	 eax, 32			; 00000020H
  002b3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  002bb	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN14@dfp_number:

; 635  : 
; 636  :         /* Return maximum positive result */
; 637  :         return (S64)mp64;

  002be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?mp64@?1??dfp_number_to_fix64@@9@9
  002c5	e9 e8 01 00 00	 jmp	 $LN1@dfp_number
$LN12@dfp_number:

; 638  :     }
; 639  : 
; 640  :     /* Raise inexact condition if result was rounded */
; 641  :     decNumberCompare(&c, &p, b, pset);

  002ca	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR pset$[rsp]
  002d2	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR b$[rsp]
  002da	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR p$[rsp]
  002e2	48 8d 4c 24 58	 lea	 rcx, QWORD PTR c$[rsp]
  002e7	e8 00 00 00 00	 call	 decNumberCompare

; 642  :     if (decNumberIsZero(&c) == 0)

  002ec	b8 02 00 00 00	 mov	 eax, 2
  002f1	48 6b c0 00	 imul	 rax, rax, 0
  002f5	0f b7 44 04 62	 movzx	 eax, WORD PTR c$[rsp+rax+10]
  002fa	85 c0		 test	 eax, eax
  002fc	75 1d		 jne	 SHORT $LN27@dfp_number
  002fe	83 7c 24 58 01	 cmp	 DWORD PTR c$[rsp], 1
  00303	75 16		 jne	 SHORT $LN27@dfp_number
  00305	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp+8]
  0030a	83 e0 70	 and	 eax, 112		; 00000070H
  0030d	85 c0		 test	 eax, eax
  0030f	75 0a		 jne	 SHORT $LN27@dfp_number
  00311	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv192[rsp], 1
  00319	eb 08		 jmp	 SHORT $LN28@dfp_number
$LN27@dfp_number:
  0031b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
$LN28@dfp_number:
  00323	83 7c 24 44 00	 cmp	 DWORD PTR tv192[rsp], 0
  00328	0f 85 84 00 00
	00		 jne	 $LN15@dfp_number

; 643  :     {
; 644  :         pset->status |= DEC_IEEE_854_Inexact;

  0032e	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  00336	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00339	83 c8 20	 or	 eax, 32			; 00000020H
  0033c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  00344	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 645  :         if (decNumberIsNegative(&c) == decNumberIsNegative(b))

  00347	0f b6 44 24 60	 movzx	 eax, BYTE PTR c$[rsp+8]
  0034c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00351	85 c0		 test	 eax, eax
  00353	74 0a		 je	 SHORT $LN31@dfp_number
  00355	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv205[rsp], 1
  0035d	eb 08		 jmp	 SHORT $LN32@dfp_number
$LN31@dfp_number:
  0035f	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv205[rsp], 0
$LN32@dfp_number:
  00367	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR b$[rsp]
  0036f	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00373	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00378	85 c0		 test	 eax, eax
  0037a	74 0a		 je	 SHORT $LN29@dfp_number
  0037c	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv204[rsp], 1
  00384	eb 08		 jmp	 SHORT $LN30@dfp_number
$LN29@dfp_number:
  00386	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
$LN30@dfp_number:
  0038e	8b 44 24 48	 mov	 eax, DWORD PTR tv204[rsp]
  00392	39 44 24 4c	 cmp	 DWORD PTR tv205[rsp], eax
  00396	75 1a		 jne	 SHORT $LN16@dfp_number

; 646  :             pset->status |= DEC_Rounded;

  00398	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pset$[rsp]
  003a0	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  003a3	0f ba e8 0b	 bts	 eax, 11
  003a7	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR pset$[rsp]
  003af	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN16@dfp_number:
$LN15@dfp_number:

; 647  :     }
; 648  : 
; 649  :     /* Convert decimal number structure to packed decimal */
; 650  :     decPackedFromNumber(packed, sizeof(packed), &scale, &p);

  003b2	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR p$[rsp]
  003ba	4c 8d 44 24 30	 lea	 r8, QWORD PTR scale$[rsp]
  003bf	ba 11 00 00 00	 mov	 edx, 17
  003c4	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR packed$[rsp]
  003cc	e8 00 00 00 00	 call	 decPackedFromNumber

; 651  : 
; 652  :     /* Convert packed decimal to binary value */
; 653  :     for (i = 0, n = 0; i < sizeof(packed)-1; i++)

  003d1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003d9	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR n$[rsp], 0
  003e2	eb 0a		 jmp	 SHORT $LN4@dfp_number
$LN2@dfp_number:
  003e4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  003e8	ff c0		 inc	 eax
  003ea	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@dfp_number:
  003ee	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  003f2	48 83 f8 10	 cmp	 rax, 16
  003f6	73 48		 jae	 SHORT $LN3@dfp_number

; 654  :     {
; 655  :         n = n * 10 + ((packed[i] & 0xF0) >> 4);

  003f8	48 6b 44 24 28
	0a		 imul	 rax, QWORD PTR n$[rsp], 10
  003fe	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00402	0f b6 8c 0c c8
	00 00 00	 movzx	 ecx, BYTE PTR packed$[rsp+rcx]
  0040a	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00410	c1 f9 04	 sar	 ecx, 4
  00413	48 63 c9	 movsxd	 rcx, ecx
  00416	48 03 c1	 add	 rax, rcx
  00419	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 656  :         n = n * 10 + (packed[i] & 0x0F);

  0041e	48 6b 44 24 28
	0a		 imul	 rax, QWORD PTR n$[rsp], 10
  00424	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00428	0f b6 8c 0c c8
	00 00 00	 movzx	 ecx, BYTE PTR packed$[rsp+rcx]
  00430	83 e1 0f	 and	 ecx, 15
  00433	48 63 c9	 movsxd	 rcx, ecx
  00436	48 03 c1	 add	 rax, rcx
  00439	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax

; 657  :     }

  0043e	eb a4		 jmp	 SHORT $LN2@dfp_number
$LN3@dfp_number:

; 658  :     n = n * 10 + ((packed[i] & 0xF0) >> 4);

  00440	48 6b 44 24 28
	0a		 imul	 rax, QWORD PTR n$[rsp], 10
  00446	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0044a	0f b6 8c 0c c8
	00 00 00	 movzx	 ecx, BYTE PTR packed$[rsp+rcx]
  00452	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00458	c1 f9 04	 sar	 ecx, 4
  0045b	48 63 c9	 movsxd	 rcx, ecx
  0045e	48 03 c1	 add	 rax, rcx
  00461	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax
$LN5@dfp_number:

; 659  :     while (scale++) n *= 10;

  00466	8b 44 24 30	 mov	 eax, DWORD PTR scale$[rsp]
  0046a	89 44 24 50	 mov	 DWORD PTR tv245[rsp], eax
  0046e	8b 44 24 30	 mov	 eax, DWORD PTR scale$[rsp]
  00472	ff c0		 inc	 eax
  00474	89 44 24 30	 mov	 DWORD PTR scale$[rsp], eax
  00478	83 7c 24 50 00	 cmp	 DWORD PTR tv245[rsp], 0
  0047d	74 0d		 je	 SHORT $LN6@dfp_number
  0047f	48 6b 44 24 28
	0a		 imul	 rax, QWORD PTR n$[rsp], 10
  00485	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax
  0048a	eb da		 jmp	 SHORT $LN5@dfp_number
$LN6@dfp_number:

; 660  :     if ((packed[i] & 0x0F) == 0x0D) n = -n;

  0048c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00490	0f b6 84 04 c8
	00 00 00	 movzx	 eax, BYTE PTR packed$[rsp+rax]
  00498	83 e0 0f	 and	 eax, 15
  0049b	83 f8 0d	 cmp	 eax, 13
  0049e	75 0d		 jne	 SHORT $LN17@dfp_number
  004a0	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
  004a5	48 f7 d8	 neg	 rax
  004a8	48 89 44 24 28	 mov	 QWORD PTR n$[rsp], rax
$LN17@dfp_number:

; 661  : 
; 662  :     /* Return 64-bit signed result */
; 663  :     return n;

  004ad	48 8b 44 24 28	 mov	 rax, QWORD PTR n$[rsp]
$LN1@dfp_number:

; 664  : 
; 665  : } /* end function dfp_number_to_fix64 */

  004b2	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004ba	48 33 cc	 xor	 rcx, rsp
  004bd	e8 00 00 00 00	 call	 __security_check_cookie
  004c2	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  004c9	c3		 ret	 0
dfp_number_to_fix64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
sign$ = 36
$T1 = 40
zoned$ = 48
__$ArrayPad$ = 80
dn$ = 112
n$ = 120
pset$ = 128
dfp_number_from_fix64 PROC

; 522  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 523  : int             sign = 0;               /* Sign of binary integer    */

  00022	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR sign$[rsp], 0

; 524  : int             i;                      /* Counter                   */
; 525  : char            zoned[32];              /* Zoned decimal work area   */
; 526  : static char     maxnegzd[]="-9223372036854775808";
; 527  : static U64      maxneg64 = 0x8000000000000000ULL;
; 528  : 
; 529  :     /* Handle maximum negative number as special case */
; 530  :     if (n == (S64)maxneg64)

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?maxneg64@?1??dfp_number_from_fix64@@9@9
  00031	48 39 44 24 78	 cmp	 QWORD PTR n$[rsp], rax
  00036	75 1e		 jne	 SHORT $LN5@dfp_number

; 531  :     {
; 532  :         decNumberFromString(dn, maxnegzd, pset);

  00038	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pset$[rsp]
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?maxnegzd@?1??dfp_number_from_fix64@@9@9
  00047	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dn$[rsp]
  0004c	e8 00 00 00 00	 call	 decNumberFromString

; 533  :         return;

  00051	e9 ce 00 00 00	 jmp	 $LN1@dfp_number
$LN5@dfp_number:

; 534  :     }
; 535  : 
; 536  :     /* Convert binary value to zoned decimal */
; 537  :     if (n < 0) { n = -n; sign = 1; }

  00056	48 83 7c 24 78
	00		 cmp	 QWORD PTR n$[rsp], 0
  0005c	7d 15		 jge	 SHORT $LN6@dfp_number
  0005e	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  00063	48 f7 d8	 neg	 rax
  00066	48 89 44 24 78	 mov	 QWORD PTR n$[rsp], rax
  0006b	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR sign$[rsp], 1
$LN6@dfp_number:

; 538  :     i = sizeof(zoned) - 1;

  00073	c7 44 24 20 1f
	00 00 00	 mov	 DWORD PTR i$[rsp], 31

; 539  :     zoned[i] = '\0';

  0007b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00080	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00085	48 83 7c 24 28
	20		 cmp	 QWORD PTR $T1[rsp], 32	; 00000020H
  0008b	73 02		 jae	 SHORT $LN10@dfp_number
  0008d	eb 05		 jmp	 SHORT $LN11@dfp_number
$LN10@dfp_number:
  0008f	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN11@dfp_number:
  00094	48 8b 44 24 28	 mov	 rax, QWORD PTR $T1[rsp]
  00099	c6 44 04 30 00	 mov	 BYTE PTR zoned$[rsp+rax], 0
$LN4@dfp_number:

; 540  :     do {
; 541  :         zoned[--i] = (n % 10) + '0';

  0009e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000a2	ff c8		 dec	 eax
  000a4	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  000a8	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000ad	48 99		 cdq
  000af	b9 0a 00 00 00	 mov	 ecx, 10
  000b4	48 f7 f9	 idiv	 rcx
  000b7	48 8b c2	 mov	 rax, rdx
  000ba	48 83 c0 30	 add	 rax, 48			; 00000030H
  000be	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000c3	88 44 0c 30	 mov	 BYTE PTR zoned$[rsp+rcx], al

; 542  :         n /= 10;

  000c7	48 8b 44 24 78	 mov	 rax, QWORD PTR n$[rsp]
  000cc	48 99		 cdq
  000ce	b9 0a 00 00 00	 mov	 ecx, 10
  000d3	48 f7 f9	 idiv	 rcx
  000d6	48 89 44 24 78	 mov	 QWORD PTR n$[rsp], rax

; 543  :     } while(i > 1 && n > 0);

  000db	83 7c 24 20 01	 cmp	 DWORD PTR i$[rsp], 1
  000e0	7e 08		 jle	 SHORT $LN7@dfp_number
  000e2	48 83 7c 24 78
	00		 cmp	 QWORD PTR n$[rsp], 0
  000e8	7f b4		 jg	 SHORT $LN4@dfp_number
$LN7@dfp_number:

; 544  :     if (sign) zoned[--i] = '-';

  000ea	83 7c 24 24 00	 cmp	 DWORD PTR sign$[rsp], 0
  000ef	74 14		 je	 SHORT $LN8@dfp_number
  000f1	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000f5	ff c8		 dec	 eax
  000f7	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  000fb	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00100	c6 44 04 30 2d	 mov	 BYTE PTR zoned$[rsp+rax], 45 ; 0000002dH
$LN8@dfp_number:

; 545  : 
; 546  :     /* Convert zoned decimal value to decimal number structure */
; 547  :     decNumberFromString(dn, zoned+i, pset);

  00105	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0010a	48 8d 44 04 30	 lea	 rax, QWORD PTR zoned$[rsp+rax]
  0010f	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pset$[rsp]
  00117	48 8b d0	 mov	 rdx, rax
  0011a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dn$[rsp]
  0011f	e8 00 00 00 00	 call	 decNumberFromString
$LN1@dfp_number:
$LN9@dfp_number:

; 548  : 
; 549  : } /* end function dfp_number_from_fix64 */

  00124	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00129	48 33 cc	 xor	 rcx, rsp
  0012c	e8 00 00 00 00	 call	 __security_check_cookie
  00131	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00135	c3		 ret	 0
dfp_number_from_fix64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
cc$ = 0
tv134 = 4
tv135 = 8
d1$ = 32
d2$ = 40
dfp_compare_exponent PROC

; 486  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 487  : int             cc;                     /* Condition code            */
; 488  : 
; 489  :     if (decNumberIsNaN(d1) && decNumberIsNaN(d2))

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR d1$[rsp]
  00013	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00017	83 e0 30	 and	 eax, 48			; 00000030H
  0001a	85 c0		 test	 eax, eax
  0001c	74 1c		 je	 SHORT $LN2@dfp_compar
  0001e	48 8b 44 24 28	 mov	 rax, QWORD PTR d2$[rsp]
  00023	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00027	83 e0 30	 and	 eax, 48			; 00000030H
  0002a	85 c0		 test	 eax, eax
  0002c	74 0c		 je	 SHORT $LN2@dfp_compar

; 490  :         cc = 0;

  0002e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR cc$[rsp], 0
  00035	e9 cd 00 00 00	 jmp	 $LN3@dfp_compar
$LN2@dfp_compar:

; 491  :     else if (decNumberIsNaN(d1) || decNumberIsNaN(d2))

  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR d1$[rsp]
  0003f	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00043	83 e0 30	 and	 eax, 48			; 00000030H
  00046	85 c0		 test	 eax, eax
  00048	75 10		 jne	 SHORT $LN6@dfp_compar
  0004a	48 8b 44 24 28	 mov	 rax, QWORD PTR d2$[rsp]
  0004f	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00053	83 e0 30	 and	 eax, 48			; 00000030H
  00056	85 c0		 test	 eax, eax
  00058	74 0c		 je	 SHORT $LN4@dfp_compar
$LN6@dfp_compar:

; 492  :         cc = 3;

  0005a	c7 04 24 03 00
	00 00		 mov	 DWORD PTR cc$[rsp], 3
  00061	e9 a1 00 00 00	 jmp	 $LN5@dfp_compar
$LN4@dfp_compar:

; 493  :     else if (decNumberIsInfinite(d1) && decNumberIsInfinite(d2))

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR d1$[rsp]
  0006b	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  0006f	83 e0 40	 and	 eax, 64			; 00000040H
  00072	85 c0		 test	 eax, eax
  00074	74 19		 je	 SHORT $LN7@dfp_compar
  00076	48 8b 44 24 28	 mov	 rax, QWORD PTR d2$[rsp]
  0007b	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  0007f	83 e0 40	 and	 eax, 64			; 00000040H
  00082	85 c0		 test	 eax, eax
  00084	74 09		 je	 SHORT $LN7@dfp_compar

; 494  :         cc = 0;

  00086	c7 04 24 00 00
	00 00		 mov	 DWORD PTR cc$[rsp], 0
  0008d	eb 78		 jmp	 SHORT $LN8@dfp_compar
$LN7@dfp_compar:

; 495  :     else if (decNumberIsInfinite(d1) || decNumberIsInfinite(d2))

  0008f	48 8b 44 24 20	 mov	 rax, QWORD PTR d1$[rsp]
  00094	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00098	83 e0 40	 and	 eax, 64			; 00000040H
  0009b	85 c0		 test	 eax, eax
  0009d	75 10		 jne	 SHORT $LN11@dfp_compar
  0009f	48 8b 44 24 28	 mov	 rax, QWORD PTR d2$[rsp]
  000a4	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  000a8	83 e0 40	 and	 eax, 64			; 00000040H
  000ab	85 c0		 test	 eax, eax
  000ad	74 09		 je	 SHORT $LN9@dfp_compar
$LN11@dfp_compar:

; 496  :         cc = 3;

  000af	c7 04 24 03 00
	00 00		 mov	 DWORD PTR cc$[rsp], 3
  000b6	eb 4f		 jmp	 SHORT $LN10@dfp_compar
$LN9@dfp_compar:

; 497  :     else
; 498  :         cc = (d1->exponent == d2->exponent) ? 0 :

  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR d1$[rsp]
  000bd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR d2$[rsp]
  000c2	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  000c5	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  000c8	75 0a		 jne	 SHORT $LN15@dfp_compar
  000ca	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
  000d2	eb 2c		 jmp	 SHORT $LN16@dfp_compar
$LN15@dfp_compar:
  000d4	48 8b 44 24 20	 mov	 rax, QWORD PTR d1$[rsp]
  000d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR d2$[rsp]
  000de	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  000e1	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  000e4	7d 0a		 jge	 SHORT $LN13@dfp_compar
  000e6	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000ee	eb 08		 jmp	 SHORT $LN14@dfp_compar
$LN13@dfp_compar:
  000f0	c7 44 24 04 02
	00 00 00	 mov	 DWORD PTR tv134[rsp], 2
$LN14@dfp_compar:
  000f8	8b 44 24 04	 mov	 eax, DWORD PTR tv134[rsp]
  000fc	89 44 24 08	 mov	 DWORD PTR tv135[rsp], eax
$LN16@dfp_compar:
  00100	8b 44 24 08	 mov	 eax, DWORD PTR tv135[rsp]
  00104	89 04 24	 mov	 DWORD PTR cc$[rsp], eax
$LN10@dfp_compar:
$LN8@dfp_compar:
$LN5@dfp_compar:
$LN3@dfp_compar:

; 499  :                 (d1->exponent < d2->exponent) ? 1 : 2 ;
; 500  : 
; 501  :     return cc;

  00107	8b 04 24	 mov	 eax, DWORD PTR cc$[rsp]

; 502  : } /* end function dfp_compare_exponent */

  0010a	48 83 c4 18	 add	 rsp, 24
  0010e	c3		 ret	 0
dfp_compare_exponent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
xp$ = 8
cfs$ = 16
dfp128_set_cf_and_bxcf PROC

; 466  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 467  :     ((QW*)xp)->F.HH.F &= 0x80003FFF;    /* Clear CF and BXCF fields  */

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR xp$[rsp]
  0000e	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00011	25 ff 3f 00 80	 and	 eax, -2147467265	; 80003fffH
  00016	48 8b 4c 24 08	 mov	 rcx, QWORD PTR xp$[rsp]
  0001b	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 468  :     ((QW*)xp)->F.HH.F |= (cfs & 0x3F) << 25;

  0001e	8b 44 24 10	 mov	 eax, DWORD PTR cfs$[rsp]
  00022	83 e0 3f	 and	 eax, 63			; 0000003fH
  00025	c1 e0 19	 shl	 eax, 25
  00028	48 8b 4c 24 08	 mov	 rcx, QWORD PTR xp$[rsp]
  0002d	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00030	0b c8		 or	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	48 8b 4c 24 08	 mov	 rcx, QWORD PTR xp$[rsp]
  00039	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 469  :                                         /* Set CF and BXCF S-bit     */
; 470  : } /* end function dfp128_set_cf_and_bxcf */

  0003c	c3		 ret	 0
dfp128_set_cf_and_bxcf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
xp$ = 8
cfs$ = 16
dfp64_set_cf_and_bxcf PROC

; 458  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 459  :     ((DW*)xp)->F.H.F &= 0x8003FFFF;     /* Clear CF and BXCF fields  */

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR xp$[rsp]
  0000e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00011	25 ff ff 03 80	 and	 eax, -2147221505	; 8003ffffH
  00016	48 8b 4c 24 08	 mov	 rcx, QWORD PTR xp$[rsp]
  0001b	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 460  :     ((DW*)xp)->F.H.F |= (cfs & 0x3F) << 25;

  0001e	8b 44 24 10	 mov	 eax, DWORD PTR cfs$[rsp]
  00022	83 e0 3f	 and	 eax, 63			; 0000003fH
  00025	c1 e0 19	 shl	 eax, 25
  00028	48 8b 4c 24 08	 mov	 rcx, QWORD PTR xp$[rsp]
  0002d	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00030	0b c8		 or	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	48 8b 4c 24 08	 mov	 rcx, QWORD PTR xp$[rsp]
  00039	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 461  :                                         /* Set CF and BXCF S-bit     */
; 462  : } /* end function dfp64_set_cf_and_bxcf */

  0003c	c3		 ret	 0
dfp64_set_cf_and_bxcf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
xp$ = 8
cfs$ = 16
dfp32_set_cf_and_bxcf PROC

; 450  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 451  :     ((FW*)xp)->F &= 0x800FFFFF;         /* Clear CF and BXCF fields  */

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR xp$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	25 ff ff 0f 80	 and	 eax, -2146435073	; 800fffffH
  00015	48 8b 4c 24 08	 mov	 rcx, QWORD PTR xp$[rsp]
  0001a	89 01		 mov	 DWORD PTR [rcx], eax

; 452  :     ((FW*)xp)->F |= (cfs & 0x3F) << 25;

  0001c	8b 44 24 10	 mov	 eax, DWORD PTR cfs$[rsp]
  00020	83 e0 3f	 and	 eax, 63			; 0000003fH
  00023	c1 e0 19	 shl	 eax, 25
  00026	48 8b 4c 24 08	 mov	 rcx, QWORD PTR xp$[rsp]
  0002b	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0002d	0b c8		 or	 ecx, eax
  0002f	8b c1		 mov	 eax, ecx
  00031	48 8b 4c 24 08	 mov	 rcx, QWORD PTR xp$[rsp]
  00036	89 01		 mov	 DWORD PTR [rcx], eax

; 453  :                                         /* Set CF and BXCF S-bit     */
; 454  : } /* end function dfp32_set_cf_and_bxcf */

  00038	c3		 ret	 0
dfp32_set_cf_and_bxcf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
xp$ = 8
dfp128_clear_cf_and_bxcf PROC

; 428  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 429  :     ((QW*)xp)->F.HH.F &= 0x80003FFF;    /* Clear CF and BXCF fields  */

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR xp$[rsp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0000d	25 ff 3f 00 80	 and	 eax, -2147467265	; 80003fffH
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR xp$[rsp]
  00017	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 430  : } /* end function dfp128_clear_cf_and_bxcf */

  0001a	c3		 ret	 0
dfp128_clear_cf_and_bxcf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
xp$ = 8
dfp64_clear_cf_and_bxcf PROC

; 422  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 423  :     ((DW*)xp)->F.H.F &= 0x8003FFFF;     /* Clear CF and BXCF fields  */

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR xp$[rsp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0000d	25 ff ff 03 80	 and	 eax, -2147221505	; 8003ffffH
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR xp$[rsp]
  00017	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 424  : } /* end function dfp64_clear_cf_and_bxcf */

  0001a	c3		 ret	 0
dfp64_clear_cf_and_bxcf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
xp$ = 8
dfp32_clear_cf_and_bxcf PROC

; 416  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 417  :     ((FW*)xp)->F &= 0x800FFFFF;         /* Clear CF and BXCF fields  */

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR xp$[rsp]
  0000a	8b 00		 mov	 eax, DWORD PTR [rax]
  0000c	25 ff ff 0f 80	 and	 eax, -2146435073	; 800fffffH
  00011	48 8b 4c 24 08	 mov	 rcx, QWORD PTR xp$[rsp]
  00016	89 01		 mov	 DWORD PTR [rcx], eax

; 418  : } /* end function dfp32_clear_cf_and_bxcf */

  00018	c3		 ret	 0
dfp32_clear_cf_and_bxcf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
cf$ = 0
xp$ = 32
dfp128_extract_lmd PROC

; 406  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 407  :     unsigned int cf = (((QW*)xp)->F.HH.F & 0x7C000000) >> 26;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR xp$[rsp]
  0000e	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00011	25 00 00 00 7c	 and	 eax, 2080374784		; 7c000000H
  00016	c1 e8 1a	 shr	 eax, 26
  00019	89 04 24	 mov	 DWORD PTR cf$[rsp], eax

; 408  :     return dfp_lmdtable[cf];

  0001c	8b 04 24	 mov	 eax, DWORD PTR cf$[rsp]
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dfp_lmdtable
  00026	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]

; 409  : } /* end function dfp128_extract_lmd */

  00029	48 83 c4 18	 add	 rsp, 24
  0002d	c3		 ret	 0
dfp128_extract_lmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
cf$ = 0
xp$ = 32
dfp64_extract_lmd PROC

; 399  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 400  :     unsigned int cf = (((DW*)xp)->F.H.F & 0x7C000000) >> 26;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR xp$[rsp]
  0000e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00011	25 00 00 00 7c	 and	 eax, 2080374784		; 7c000000H
  00016	c1 e8 1a	 shr	 eax, 26
  00019	89 04 24	 mov	 DWORD PTR cf$[rsp], eax

; 401  :     return dfp_lmdtable[cf];

  0001c	8b 04 24	 mov	 eax, DWORD PTR cf$[rsp]
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dfp_lmdtable
  00026	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]

; 402  : } /* end function dfp64_extract_lmd */

  00029	48 83 c4 18	 add	 rsp, 24
  0002d	c3		 ret	 0
dfp64_extract_lmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
cf$ = 0
xp$ = 32
dfp32_extract_lmd PROC

; 392  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 393  :     unsigned int cf = (((FW*)xp)->F & 0x7C000000) >> 26;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR xp$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	25 00 00 00 7c	 and	 eax, 2080374784		; 7c000000H
  00015	c1 e8 1a	 shr	 eax, 26
  00018	89 04 24	 mov	 DWORD PTR cf$[rsp], eax

; 394  :     return dfp_lmdtable[cf];

  0001b	8b 04 24	 mov	 eax, DWORD PTR cf$[rsp]
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dfp_lmdtable
  00025	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]

; 395  : } /* end function dfp32_extract_lmd */

  00028	48 83 c4 18	 add	 rsp, 24
  0002c	c3		 ret	 0
dfp32_extract_lmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 0
enabled_flags$ = 4
tv78 = 8
tv84 = 12
sm$ = 16
ff$ = 20
cur_fpc$ = 48
src_fpc$ = 56
fpc_signal_check PROC

; 235  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 236  : U32     ff, sm, enabled_flags;      /* Mask and flag work areas  */
; 237  : BYTE    dxc;                        /* Data exception code or 0      */
; 238  : 
; 239  :     /* AND the current FPC flags with the source FPC mask */
; 240  :     ff = (cur_fpc & FPC_FLAGS) >> FPC_FLAG_SHIFT;

  0000c	8b 44 24 30	 mov	 eax, DWORD PTR cur_fpc$[rsp]
  00010	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00015	c1 e8 13	 shr	 eax, 19
  00018	89 44 24 14	 mov	 DWORD PTR ff$[rsp], eax

; 241  :     sm = (src_fpc & FPC_MASKS) >> FPC_MASK_SHIFT;

  0001c	8b 44 24 38	 mov	 eax, DWORD PTR src_fpc$[rsp]
  00020	25 00 00 00 f8	 and	 eax, -134217728		; f8000000H
  00025	c1 e8 1b	 shr	 eax, 27
  00028	89 44 24 10	 mov	 DWORD PTR sm$[rsp], eax

; 242  :     enabled_flags = (ff & sm)  << FPC_FLAG_SHIFT;

  0002c	8b 44 24 10	 mov	 eax, DWORD PTR sm$[rsp]
  00030	8b 4c 24 14	 mov	 ecx, DWORD PTR ff$[rsp]
  00034	23 c8		 and	 ecx, eax
  00036	8b c1		 mov	 eax, ecx
  00038	c1 e0 13	 shl	 eax, 19
  0003b	89 44 24 04	 mov	 DWORD PTR enabled_flags$[rsp], eax

; 243  : 
; 244  :     /* A simulated-IEEE-exception event is recognized
; 245  :        if any current flag corresponds to the source mask */
; 246  :     if (enabled_flags & FPC_FLAG_SFI)

  0003f	8b 44 24 04	 mov	 eax, DWORD PTR enabled_flags$[rsp]
  00043	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00048	85 c0		 test	 eax, eax
  0004a	74 09		 je	 SHORT $LN2@fpc_signal

; 247  :     {
; 248  :         dxc = DXC_IEEE_INV_OP_IISE;

  0004c	c6 04 24 83	 mov	 BYTE PTR dxc$[rsp], 131	; 00000083H

; 249  :     }

  00050	e9 99 00 00 00	 jmp	 $LN3@fpc_signal
$LN2@fpc_signal:

; 250  :     else if (enabled_flags & FPC_FLAG_SFZ)

  00055	8b 44 24 04	 mov	 eax, DWORD PTR enabled_flags$[rsp]
  00059	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  0005e	85 c0		 test	 eax, eax
  00060	74 09		 je	 SHORT $LN4@fpc_signal

; 251  :     {
; 252  :         dxc = DXC_IEEE_DIV_ZERO_IISE;

  00062	c6 04 24 43	 mov	 BYTE PTR dxc$[rsp], 67	; 00000043H

; 253  :     }

  00066	e9 83 00 00 00	 jmp	 $LN5@fpc_signal
$LN4@fpc_signal:

; 254  :     else if (enabled_flags & FPC_FLAG_SFO)

  0006b	8b 44 24 04	 mov	 eax, DWORD PTR enabled_flags$[rsp]
  0006f	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00074	85 c0		 test	 eax, eax
  00076	74 29		 je	 SHORT $LN6@fpc_signal

; 255  :     {
; 256  :         dxc = (cur_fpc & FPC_FLAG_SFX) ?

  00078	8b 44 24 30	 mov	 eax, DWORD PTR cur_fpc$[rsp]
  0007c	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00081	85 c0		 test	 eax, eax
  00083	74 0a		 je	 SHORT $LN13@fpc_signal
  00085	c7 44 24 08 2b
	00 00 00	 mov	 DWORD PTR tv78[rsp], 43	; 0000002bH
  0008d	eb 08		 jmp	 SHORT $LN14@fpc_signal
$LN13@fpc_signal:
  0008f	c7 44 24 08 23
	00 00 00	 mov	 DWORD PTR tv78[rsp], 35	; 00000023H
$LN14@fpc_signal:
  00097	0f b6 44 24 08	 movzx	 eax, BYTE PTR tv78[rsp]
  0009c	88 04 24	 mov	 BYTE PTR dxc$[rsp], al

; 257  :                 DXC_IEEE_OF_INEX_IISE :
; 258  :                 DXC_IEEE_OF_EXACT_IISE;
; 259  :     }

  0009f	eb 4d		 jmp	 SHORT $LN7@fpc_signal
$LN6@fpc_signal:

; 260  :     else if (enabled_flags & FPC_FLAG_SFU)

  000a1	8b 44 24 04	 mov	 eax, DWORD PTR enabled_flags$[rsp]
  000a5	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 29		 je	 SHORT $LN8@fpc_signal

; 261  :     {
; 262  :         dxc = (cur_fpc & FPC_FLAG_SFX) ?

  000ae	8b 44 24 30	 mov	 eax, DWORD PTR cur_fpc$[rsp]
  000b2	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 0a		 je	 SHORT $LN15@fpc_signal
  000bb	c7 44 24 0c 1b
	00 00 00	 mov	 DWORD PTR tv84[rsp], 27
  000c3	eb 08		 jmp	 SHORT $LN16@fpc_signal
$LN15@fpc_signal:
  000c5	c7 44 24 0c 13
	00 00 00	 mov	 DWORD PTR tv84[rsp], 19
$LN16@fpc_signal:
  000cd	0f b6 44 24 0c	 movzx	 eax, BYTE PTR tv84[rsp]
  000d2	88 04 24	 mov	 BYTE PTR dxc$[rsp], al

; 263  :                 DXC_IEEE_UF_INEX_IISE :
; 264  :                 DXC_IEEE_UF_EXACT_IISE;
; 265  :     }

  000d5	eb 17		 jmp	 SHORT $LN9@fpc_signal
$LN8@fpc_signal:

; 266  :     else if (enabled_flags & FPC_FLAG_SFX)

  000d7	8b 44 24 04	 mov	 eax, DWORD PTR enabled_flags$[rsp]
  000db	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000e0	85 c0		 test	 eax, eax
  000e2	74 06		 je	 SHORT $LN10@fpc_signal

; 267  :     {
; 268  :         dxc = DXC_IEEE_INEXACT_IISE;

  000e4	c6 04 24 0b	 mov	 BYTE PTR dxc$[rsp], 11

; 269  :     }

  000e8	eb 04		 jmp	 SHORT $LN11@fpc_signal
$LN10@fpc_signal:

; 270  :     else
; 271  :     {
; 272  :         dxc = 0;

  000ea	c6 04 24 00	 mov	 BYTE PTR dxc$[rsp], 0
$LN11@fpc_signal:
$LN9@fpc_signal:
$LN7@fpc_signal:
$LN5@fpc_signal:
$LN3@fpc_signal:

; 273  :     }
; 274  : 
; 275  :     /* Return data exception code or zero */
; 276  :     return dxc;

  000ee	0f b6 04 24	 movzx	 eax, BYTE PTR dxc$[rsp]

; 277  : } /* end function fpc_signal_check */

  000f2	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000f6	c3		 ret	 0
fpc_signal_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv80 = 56
tv92 = 60
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch4 PROC					; COMDAT

; 695  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN9@s370_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN10@s370_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN13@s370_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN14@s370_vfetc
$LN13@s370_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN14@s370_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 14		 jne	 SHORT $LN6@s370_vfetc
  0004e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00057	3d fc 07 00 00	 cmp	 eax, 2044		; 000007fcH
  0005c	0f 87 9a 00 00
	00		 ja	 $LN5@s370_vfetc
$LN6@s370_vfetc:
$LN4@s370_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );

  00062	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00067	73 0a		 jae	 SHORT $LN17@s370_vfetc
  00069	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN18@s370_vfetc
$LN17@s370_vfetc:
  00073	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@s370_vfetc:
  0007b	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00080	74 16		 je	 SHORT $LN19@s370_vfetc
  00082	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00086	83 c0 03	 add	 eax, 3
  00089	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008c	72 0a		 jb	 SHORT $LN19@s370_vfetc
  0008e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00096	eb 08		 jmp	 SHORT $LN25@s370_vfetc
$LN19@s370_vfetc:
  00098	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN25@s370_vfetc:
  000a0	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000a5	74 0a		 je	 SHORT $LN7@s370_vfetc
  000a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b1	33 c0		 xor	 eax, eax
  000b3	85 c0		 test	 eax, eax
  000b5	75 ab		 jne	 SHORT $LN4@s370_vfetc

; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b7	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  000c0	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000c4	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cc	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000d1	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000d6	ba 04 00 00 00	 mov	 edx, 4
  000db	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000df	e8 00 00 00 00	 call	 s370_maddr_l
  000e4	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  000e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ee	e8 00 00 00 00	 call	 fetch_fw_noswap
  000f3	8b c8		 mov	 ecx, eax
  000f5	e8 00 00 00 00	 call	 _byteswap_ulong
  000fa	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000fc	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00101	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00105	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  00109	e8 00 00 00 00	 call	 s370_vfetch4_full
$LN1@s370_vfetc:

; 705  : }

  0010e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00112	c3		 ret	 0
s370_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s370_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002b	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s370_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000a7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000af	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000b3	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000b7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000bf	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c7	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000cc	48 8b d0	 mov	 rdx, rax
  000cf	e8 00 00 00 00	 call	 s370_maddr_l
  000d4	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000d9	b8 04 00 00 00	 mov	 eax, 4
  000de	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000e2	48 98		 cdqe
  000e4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000e9	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000ee	48 8b f9	 mov	 rdi, rcx
  000f1	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000f6	48 8b c8	 mov	 rcx, rax
  000f9	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  000fb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00100	e8 00 00 00 00	 call	 fetch_fw_noswap
  00105	8b c8		 mov	 ecx, eax
  00107	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0010c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00111	48 33 cc	 xor	 rcx, rsp
  00114	e8 00 00 00 00	 call	 __security_check_cookie
  00119	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	c3		 ret	 0
s370_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_FPC_check
_TEXT	SEGMENT
regs$ = 48
fpc$ = 56
s370_FPC_check PROC					; COMDAT

; 788  : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 789  :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0000d	b8 01 00 00 00	 mov	 eax, 1
  00012	48 6b c0 04	 imul	 rax, rax, 4
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00023	83 e0 04	 and	 eax, 4
  00026	85 c0		 test	 eax, eax
  00028	74 4e		 je	 SHORT $LN2@s370_FPC_c

; 790  :     {
; 791  :         if (0
; 792  :             || (fpc & FPC_RESV_FPX)
; 793  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV4
; 794  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV5
; 795  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV6

  0002a	33 c0		 xor	 eax, eax
  0002c	85 c0		 test	 eax, eax
  0002e	75 31		 jne	 SHORT $LN5@s370_FPC_c
  00030	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00034	25 88 00 03 03	 and	 eax, 50528392		; 03030088H
  00039	85 c0		 test	 eax, eax
  0003b	75 24		 jne	 SHORT $LN5@s370_FPC_c
  0003d	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00041	83 e0 07	 and	 eax, 7
  00044	83 f8 04	 cmp	 eax, 4
  00047	74 18		 je	 SHORT $LN5@s370_FPC_c
  00049	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  0004d	83 e0 07	 and	 eax, 7
  00050	83 f8 05	 cmp	 eax, 5
  00053	74 0c		 je	 SHORT $LN5@s370_FPC_c
  00055	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00059	83 e0 07	 and	 eax, 7
  0005c	83 f8 06	 cmp	 eax, 6
  0005f	75 15		 jne	 SHORT $LN4@s370_FPC_c
$LN5@s370_FPC_c:

; 796  :         )
; 797  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00061	ba 06 00 00 00	 mov	 edx, 6
  00066	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00070	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN4@s370_FPC_c:

; 798  :     }

  00076	eb 22		 jmp	 SHORT $LN3@s370_FPC_c
$LN2@s370_FPC_c:

; 799  :     else
; 800  :     {
; 801  :         if (fpc & FPC_RESERVED)

  00078	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  0007c	25 8c 00 07 07	 and	 eax, 117899404		; 0707008cH
  00081	85 c0		 test	 eax, eax
  00083	74 15		 je	 SHORT $LN6@s370_FPC_c

; 802  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00085	ba 06 00 00 00	 mov	 edx, 6
  0008a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00094	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_FPC_c:
$LN3@s370_FPC_c:

; 803  :     }
; 804  : }

  0009a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009e	c3		 ret	 0
s370_FPC_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
x1$ = 48
r1$ = 52
bits$ = 56
lmd$ = 60
set$ = 64
d1$ = 96
__$ArrayPad$ = 136
inst$ = 160
regs$ = 168
s370_test_data_group_dfp_short PROC

; 5670 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5671 : int             r1;                     /* Value of R field          */
; 5672 : int             x2;                     /* Index register            */
; 5673 : int             b2;                     /* Base of effective addr    */
; 5674 : VADR            effective_addr2;        /* Effective address         */
; 5675 : decimal32       x1;                     /* Short DFP value           */
; 5676 : decNumber       d1;                     /* Working decimal number    */
; 5677 : decContext      set;                    /* Working context           */
; 5678 : U32             bits;                   /* Low 12 bits of address    */
; 5679 : int             lmd;                    /* Leftmost digit            */
; 5680 : 
; 5681 :     RXE(inst, regs, r1, x2, b2, effective_addr2);

  00023	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00048	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 10	 shr	 eax, 16
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00056	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 14	 shr	 eax, 20
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00064	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00069	74 20		 je	 SHORT $LN5@s370_test_
  0006b	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00070	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00078	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007f	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_test_:
  0008b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008f	c1 e8 0c	 shr	 eax, 12
  00092	83 e0 0f	 and	 eax, 15
  00095	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00099	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009e	74 20		 je	 SHORT $LN6@s370_test_
  000a0	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b4	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b8	03 c8		 add	 ecx, eax
  000ba	8b c1		 mov	 eax, ecx
  000bc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_test_:
  000c0	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c9	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_test_:
  000cd	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d9	48 83 c0 06	 add	 rax, 6
  000dd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0f		 je	 SHORT $LN7@s370_test_
  000f0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_test_:
  000ff	33 c0		 xor	 eax, eax
  00101	85 c0		 test	 eax, eax
  00103	75 c8		 jne	 SHORT $LN4@s370_test_

; 5682 : 
; 5683 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5684 :     DFPINST_CHECK(regs);

  00105	b8 08 00 00 00	 mov	 eax, 8
  0010a	48 6b c0 01	 imul	 rax, rax, 1
  0010e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0011d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00122	85 c0		 test	 eax, eax
  00124	74 3f		 je	 SHORT $LN9@s370_test_
  00126	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00134	d1 e8		 shr	 eax, 1
  00136	83 e0 01	 and	 eax, 1
  00139	85 c0		 test	 eax, eax
  0013b	74 55		 je	 SHORT $LN8@s370_test_
  0013d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0015c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00161	85 c0		 test	 eax, eax
  00163	75 2d		 jne	 SHORT $LN8@s370_test_
$LN9@s370_test_:
  00165	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_test_:

; 5685 : 
; 5686 :     /* Initialise the context for short DFP */
; 5687 :     decContextDefault(&set, DEC_INIT_DECIMAL32);

  00192	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00197	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  0019c	e8 00 00 00 00	 call	 decContextDefault

; 5688 : 
; 5689 :     /* Load DFP short number from FP register r1 */
; 5690 :     ARCH_DEP(dfp_reg_to_decimal32)(r1, &x1, regs);

  001a1	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001a9	48 8d 54 24 30	 lea	 rdx, QWORD PTR x1$[rsp]
  001ae	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  001b2	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal32

; 5691 : 
; 5692 :     /* Extract the leftmost digit from FP register r1 */
; 5693 :     lmd = dfp32_extract_lmd(&x1);

  001b7	48 8d 4c 24 30	 lea	 rcx, QWORD PTR x1$[rsp]
  001bc	e8 00 00 00 00	 call	 dfp32_extract_lmd
  001c1	89 44 24 3c	 mov	 DWORD PTR lmd$[rsp], eax

; 5694 : 
; 5695 :     /* Convert to internal decimal number format */
; 5696 :     decimal32ToNumber(&x1, &d1);

  001c5	48 8d 54 24 60	 lea	 rdx, QWORD PTR d1$[rsp]
  001ca	48 8d 4c 24 30	 lea	 rcx, QWORD PTR x1$[rsp]
  001cf	e8 00 00 00 00	 call	 decimal32ToNumber

; 5697 : 
; 5698 :     /* Isolate rightmost 12 bits of second operand address */
; 5699 :     bits = effective_addr2 & 0xFFF;

  001d4	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001d8	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  001dd	89 44 24 38	 mov	 DWORD PTR bits$[rsp], eax

; 5700 : 
; 5701 :     /* Test data group and set condition code */
; 5702 :     regs->psw.cc = dfp_test_data_group(&set, &d1, lmd, bits);

  001e1	44 8b 4c 24 38	 mov	 r9d, DWORD PTR bits$[rsp]
  001e6	44 8b 44 24 3c	 mov	 r8d, DWORD PTR lmd$[rsp]
  001eb	48 8d 54 24 60	 lea	 rdx, QWORD PTR d1$[rsp]
  001f0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  001f5	e8 00 00 00 00	 call	 dfp_test_data_group
  001fa	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00202	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 5703 : 
; 5704 : } /* end DEF_INST(test_data_group_dfp_short) */

  00205	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0020d	48 33 cc	 xor	 rcx, rsp
  00210	e8 00 00 00 00	 call	 __security_check_cookie
  00215	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0021c	c3		 ret	 0
s370_test_data_group_dfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
r1$ = 48
bits$ = 52
lmd$ = 56
x1$ = 64
set$ = 72
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s370_test_data_group_dfp_long PROC

; 5629 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5630 : int             r1;                     /* Value of R field          */
; 5631 : int             x2;                     /* Index register            */
; 5632 : int             b2;                     /* Base of effective addr    */
; 5633 : VADR            effective_addr2;        /* Effective address         */
; 5634 : decimal64       x1;                     /* Long DFP value            */
; 5635 : decNumber       d1;                     /* Working decimal number    */
; 5636 : decContext      set;                    /* Working context           */
; 5637 : U32             bits;                   /* Low 12 bits of address    */
; 5638 : int             lmd;                    /* Leftmost digit            */
; 5639 : 
; 5640 :     RXE(inst, regs, r1, x2, b2, effective_addr2);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00048	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 10	 shr	 eax, 16
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00056	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 14	 shr	 eax, 20
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00064	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00069	74 20		 je	 SHORT $LN5@s370_test_
  0006b	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00070	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00078	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007f	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_test_:
  0008b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008f	c1 e8 0c	 shr	 eax, 12
  00092	83 e0 0f	 and	 eax, 15
  00095	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00099	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009e	74 20		 je	 SHORT $LN6@s370_test_
  000a0	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b4	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b8	03 c8		 add	 ecx, eax
  000ba	8b c1		 mov	 eax, ecx
  000bc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_test_:
  000c0	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c9	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_test_:
  000cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d9	48 83 c0 06	 add	 rax, 6
  000dd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0f		 je	 SHORT $LN7@s370_test_
  000f0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_test_:
  000ff	33 c0		 xor	 eax, eax
  00101	85 c0		 test	 eax, eax
  00103	75 c8		 jne	 SHORT $LN4@s370_test_

; 5641 : 
; 5642 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5643 :     DFPINST_CHECK(regs);

  00105	b8 08 00 00 00	 mov	 eax, 8
  0010a	48 6b c0 01	 imul	 rax, rax, 1
  0010e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0011d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00122	85 c0		 test	 eax, eax
  00124	74 3f		 je	 SHORT $LN9@s370_test_
  00126	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00134	d1 e8		 shr	 eax, 1
  00136	83 e0 01	 and	 eax, 1
  00139	85 c0		 test	 eax, eax
  0013b	74 55		 je	 SHORT $LN8@s370_test_
  0013d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0015c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00161	85 c0		 test	 eax, eax
  00163	75 2d		 jne	 SHORT $LN8@s370_test_
$LN9@s370_test_:
  00165	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_test_:

; 5644 : 
; 5645 :     /* Initialise the context for long DFP */
; 5646 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00192	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00197	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  0019c	e8 00 00 00 00	 call	 decContextDefault

; 5647 : 
; 5648 :     /* Load DFP long number from FP register r1 */
; 5649 :     ARCH_DEP(dfp_reg_to_decimal64)(r1, &x1, regs);

  001a1	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001a9	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  001ae	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  001b2	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 5650 : 
; 5651 :     /* Extract the leftmost digit from FP register r1 */
; 5652 :     lmd = dfp64_extract_lmd(&x1);

  001b7	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  001bc	e8 00 00 00 00	 call	 dfp64_extract_lmd
  001c1	89 44 24 38	 mov	 DWORD PTR lmd$[rsp], eax

; 5653 : 
; 5654 :     /* Convert to internal decimal number format */
; 5655 :     decimal64ToNumber(&x1, &d1);

  001c5	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  001ca	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  001cf	e8 00 00 00 00	 call	 decimal64ToNumber

; 5656 : 
; 5657 :     /* Isolate rightmost 12 bits of second operand address */
; 5658 :     bits = effective_addr2 & 0xFFF;

  001d4	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001d8	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  001dd	89 44 24 34	 mov	 DWORD PTR bits$[rsp], eax

; 5659 : 
; 5660 :     /* Test data group and set condition code */
; 5661 :     regs->psw.cc = dfp_test_data_group(&set, &d1, lmd, bits);

  001e1	44 8b 4c 24 34	 mov	 r9d, DWORD PTR bits$[rsp]
  001e6	44 8b 44 24 38	 mov	 r8d, DWORD PTR lmd$[rsp]
  001eb	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  001f0	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001f5	e8 00 00 00 00	 call	 dfp_test_data_group
  001fa	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00202	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 5662 : 
; 5663 : } /* end DEF_INST(test_data_group_dfp_long) */

  00205	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0020d	48 33 cc	 xor	 rcx, rsp
  00210	e8 00 00 00 00	 call	 __security_check_cookie
  00215	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0021c	c3		 ret	 0
s370_test_data_group_dfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
r1$ = 48
bits$ = 52
lmd$ = 56
x1$ = 64
set$ = 80
d1$ = 112
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
s370_test_data_group_dfp_ext PROC

; 5587 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5588 : int             r1;                     /* Value of R field          */
; 5589 : int             x2;                     /* Index register            */
; 5590 : int             b2;                     /* Base of effective addr    */
; 5591 : VADR            effective_addr2;        /* Effective address         */
; 5592 : decimal128      x1;                     /* Extended DFP value        */
; 5593 : decNumber       d1;                     /* Working decimal number    */
; 5594 : decContext      set;                    /* Working context           */
; 5595 : U32             bits;                   /* Low 12 bits of address    */
; 5596 : int             lmd;                    /* Leftmost digit            */
; 5597 : 
; 5598 :     RXE(inst, regs, r1, x2, b2, effective_addr2);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00048	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 10	 shr	 eax, 16
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00056	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 14	 shr	 eax, 20
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00064	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00069	74 20		 je	 SHORT $LN5@s370_test_
  0006b	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00070	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00078	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007f	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_test_:
  0008b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008f	c1 e8 0c	 shr	 eax, 12
  00092	83 e0 0f	 and	 eax, 15
  00095	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00099	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009e	74 20		 je	 SHORT $LN6@s370_test_
  000a0	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b4	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b8	03 c8		 add	 ecx, eax
  000ba	8b c1		 mov	 eax, ecx
  000bc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_test_:
  000c0	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c9	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_test_:
  000cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d9	48 83 c0 06	 add	 rax, 6
  000dd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0f		 je	 SHORT $LN7@s370_test_
  000f0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_test_:
  000ff	33 c0		 xor	 eax, eax
  00101	85 c0		 test	 eax, eax
  00103	75 c8		 jne	 SHORT $LN4@s370_test_

; 5599 : 
; 5600 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5601 :     DFPINST_CHECK(regs);

  00105	b8 08 00 00 00	 mov	 eax, 8
  0010a	48 6b c0 01	 imul	 rax, rax, 1
  0010e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0011d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00122	85 c0		 test	 eax, eax
  00124	74 3f		 je	 SHORT $LN9@s370_test_
  00126	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00134	d1 e8		 shr	 eax, 1
  00136	83 e0 01	 and	 eax, 1
  00139	85 c0		 test	 eax, eax
  0013b	74 55		 je	 SHORT $LN8@s370_test_
  0013d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0015c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00161	85 c0		 test	 eax, eax
  00163	75 2d		 jne	 SHORT $LN8@s370_test_
$LN9@s370_test_:
  00165	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_test_:

; 5602 :     DFPREGPAIR_CHECK(r1, regs);

  00192	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00196	83 e0 02	 and	 eax, 2
  00199	85 c0		 test	 eax, eax
  0019b	74 1b		 je	 SHORT $LN10@s370_test_
  0019d	ba 06 00 00 00	 mov	 edx, 6
  001a2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001aa	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s370_test_:

; 5603 : 
; 5604 :     /* Initialise the context for extended DFP */
; 5605 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001b8	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001bd	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001c2	e8 00 00 00 00	 call	 decContextDefault

; 5606 : 
; 5607 :     /* Load DFP extended number from FP register r1 */
; 5608 :     ARCH_DEP(dfp_reg_to_decimal128)(r1, &x1, regs);

  001c7	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001cf	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  001d4	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  001d8	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 5609 : 
; 5610 :     /* Extract the leftmost digit from FP register r1 */
; 5611 :     lmd = dfp128_extract_lmd(&x1);

  001dd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  001e2	e8 00 00 00 00	 call	 dfp128_extract_lmd
  001e7	89 44 24 38	 mov	 DWORD PTR lmd$[rsp], eax

; 5612 : 
; 5613 :     /* Convert to internal decimal number format */
; 5614 :     decimal128ToNumber(&x1, &d1);

  001eb	48 8d 54 24 70	 lea	 rdx, QWORD PTR d1$[rsp]
  001f0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  001f5	e8 00 00 00 00	 call	 decimal128ToNumber

; 5615 : 
; 5616 :     /* Isolate rightmost 12 bits of second operand address */
; 5617 :     bits = effective_addr2 & 0xFFF;

  001fa	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001fe	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00203	89 44 24 34	 mov	 DWORD PTR bits$[rsp], eax

; 5618 : 
; 5619 :     /* Test data group and set condition code */
; 5620 :     regs->psw.cc = dfp_test_data_group(&set, &d1, lmd, bits);

  00207	44 8b 4c 24 34	 mov	 r9d, DWORD PTR bits$[rsp]
  0020c	44 8b 44 24 38	 mov	 r8d, DWORD PTR lmd$[rsp]
  00211	48 8d 54 24 70	 lea	 rdx, QWORD PTR d1$[rsp]
  00216	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0021b	e8 00 00 00 00	 call	 dfp_test_data_group
  00220	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00228	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 5621 : 
; 5622 : } /* end DEF_INST(test_data_group_dfp_ext) */

  0022b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00233	48 33 cc	 xor	 rcx, rsp
  00236	e8 00 00 00 00	 call	 __security_check_cookie
  0023b	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00242	c3		 ret	 0
s370_test_data_group_dfp_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
r1$ = 48
x1$ = 52
bits$ = 56
set$ = 64
d1$ = 96
__$ArrayPad$ = 136
inst$ = 160
regs$ = 168
s370_test_data_class_dfp_short PROC

; 5552 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5553 : int             r1;                     /* Value of R field          */
; 5554 : int             x2;                     /* Index register            */
; 5555 : int             b2;                     /* Base of effective addr    */
; 5556 : VADR            effective_addr2;        /* Effective address         */
; 5557 : decimal32       x1;                     /* Short DFP value           */
; 5558 : decNumber       d1;                     /* Working decimal number    */
; 5559 : decContext      set;                    /* Working context           */
; 5560 : U32             bits;                   /* Low 12 bits of address    */
; 5561 : 
; 5562 :     RXE(inst, regs, r1, x2, b2, effective_addr2);

  00023	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00048	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 10	 shr	 eax, 16
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00056	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 14	 shr	 eax, 20
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00064	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00069	74 20		 je	 SHORT $LN5@s370_test_
  0006b	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00070	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00078	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007f	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_test_:
  0008b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008f	c1 e8 0c	 shr	 eax, 12
  00092	83 e0 0f	 and	 eax, 15
  00095	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00099	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009e	74 20		 je	 SHORT $LN6@s370_test_
  000a0	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b4	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b8	03 c8		 add	 ecx, eax
  000ba	8b c1		 mov	 eax, ecx
  000bc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_test_:
  000c0	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c9	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_test_:
  000cd	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d9	48 83 c0 06	 add	 rax, 6
  000dd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0f		 je	 SHORT $LN7@s370_test_
  000f0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_test_:
  000ff	33 c0		 xor	 eax, eax
  00101	85 c0		 test	 eax, eax
  00103	75 c8		 jne	 SHORT $LN4@s370_test_

; 5563 : 
; 5564 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5565 :     DFPINST_CHECK(regs);

  00105	b8 08 00 00 00	 mov	 eax, 8
  0010a	48 6b c0 01	 imul	 rax, rax, 1
  0010e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0011d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00122	85 c0		 test	 eax, eax
  00124	74 3f		 je	 SHORT $LN9@s370_test_
  00126	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00134	d1 e8		 shr	 eax, 1
  00136	83 e0 01	 and	 eax, 1
  00139	85 c0		 test	 eax, eax
  0013b	74 55		 je	 SHORT $LN8@s370_test_
  0013d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0015c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00161	85 c0		 test	 eax, eax
  00163	75 2d		 jne	 SHORT $LN8@s370_test_
$LN9@s370_test_:
  00165	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_test_:

; 5566 : 
; 5567 :     /* Initialise the context for short DFP */
; 5568 :     decContextDefault(&set, DEC_INIT_DECIMAL32);

  00192	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00197	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  0019c	e8 00 00 00 00	 call	 decContextDefault

; 5569 : 
; 5570 :     /* Convert FP register r1 to decimal number format */
; 5571 :     ARCH_DEP(dfp_reg_to_decimal32)(r1, &x1, regs);

  001a1	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001a9	48 8d 54 24 34	 lea	 rdx, QWORD PTR x1$[rsp]
  001ae	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  001b2	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal32

; 5572 :     decimal32ToNumber(&x1, &d1);

  001b7	48 8d 54 24 60	 lea	 rdx, QWORD PTR d1$[rsp]
  001bc	48 8d 4c 24 34	 lea	 rcx, QWORD PTR x1$[rsp]
  001c1	e8 00 00 00 00	 call	 decimal32ToNumber

; 5573 : 
; 5574 :     /* Isolate rightmost 12 bits of second operand address */
; 5575 :     bits = effective_addr2 & 0xFFF;

  001c6	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001ca	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  001cf	89 44 24 38	 mov	 DWORD PTR bits$[rsp], eax

; 5576 : 
; 5577 :     /* Test data class and set condition code */
; 5578 :     regs->psw.cc = dfp_test_data_class(&set, &d1, bits);

  001d3	44 8b 44 24 38	 mov	 r8d, DWORD PTR bits$[rsp]
  001d8	48 8d 54 24 60	 lea	 rdx, QWORD PTR d1$[rsp]
  001dd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  001e2	e8 00 00 00 00	 call	 dfp_test_data_class
  001e7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ef	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 5579 : 
; 5580 : } /* end DEF_INST(test_data_class_dfp_short) */

  001f2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001fa	48 33 cc	 xor	 rcx, rsp
  001fd	e8 00 00 00 00	 call	 __security_check_cookie
  00202	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00209	c3		 ret	 0
s370_test_data_class_dfp_short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
r1$ = 48
bits$ = 52
x1$ = 56
set$ = 64
d1$ = 96
__$ArrayPad$ = 136
inst$ = 160
regs$ = 168
s370_test_data_class_dfp_long PROC

; 5517 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5518 : int             r1;                     /* Value of R field          */
; 5519 : int             x2;                     /* Index register            */
; 5520 : int             b2;                     /* Base of effective addr    */
; 5521 : VADR            effective_addr2;        /* Effective address         */
; 5522 : decimal64       x1;                     /* Long DFP value            */
; 5523 : decNumber       d1;                     /* Working decimal number    */
; 5524 : decContext      set;                    /* Working context           */
; 5525 : U32             bits;                   /* Low 12 bits of address    */
; 5526 : 
; 5527 :     RXE(inst, regs, r1, x2, b2, effective_addr2);

  00023	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00048	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 10	 shr	 eax, 16
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00056	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 14	 shr	 eax, 20
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00064	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00069	74 20		 je	 SHORT $LN5@s370_test_
  0006b	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00070	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00078	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007f	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_test_:
  0008b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008f	c1 e8 0c	 shr	 eax, 12
  00092	83 e0 0f	 and	 eax, 15
  00095	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00099	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009e	74 20		 je	 SHORT $LN6@s370_test_
  000a0	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b4	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b8	03 c8		 add	 ecx, eax
  000ba	8b c1		 mov	 eax, ecx
  000bc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_test_:
  000c0	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c9	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_test_:
  000cd	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d9	48 83 c0 06	 add	 rax, 6
  000dd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0f		 je	 SHORT $LN7@s370_test_
  000f0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_test_:
  000ff	33 c0		 xor	 eax, eax
  00101	85 c0		 test	 eax, eax
  00103	75 c8		 jne	 SHORT $LN4@s370_test_

; 5528 : 
; 5529 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5530 :     DFPINST_CHECK(regs);

  00105	b8 08 00 00 00	 mov	 eax, 8
  0010a	48 6b c0 01	 imul	 rax, rax, 1
  0010e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0011d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00122	85 c0		 test	 eax, eax
  00124	74 3f		 je	 SHORT $LN9@s370_test_
  00126	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00134	d1 e8		 shr	 eax, 1
  00136	83 e0 01	 and	 eax, 1
  00139	85 c0		 test	 eax, eax
  0013b	74 55		 je	 SHORT $LN8@s370_test_
  0013d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0015c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00161	85 c0		 test	 eax, eax
  00163	75 2d		 jne	 SHORT $LN8@s370_test_
$LN9@s370_test_:
  00165	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_test_:

; 5531 : 
; 5532 :     /* Initialise the context for long DFP */
; 5533 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00192	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00197	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  0019c	e8 00 00 00 00	 call	 decContextDefault

; 5534 : 
; 5535 :     /* Convert FP register r1 to decimal number format */
; 5536 :     ARCH_DEP(dfp_reg_to_decimal64)(r1, &x1, regs);

  001a1	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001a9	48 8d 54 24 38	 lea	 rdx, QWORD PTR x1$[rsp]
  001ae	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  001b2	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 5537 :     decimal64ToNumber(&x1, &d1);

  001b7	48 8d 54 24 60	 lea	 rdx, QWORD PTR d1$[rsp]
  001bc	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  001c1	e8 00 00 00 00	 call	 decimal64ToNumber

; 5538 : 
; 5539 :     /* Isolate rightmost 12 bits of second operand address */
; 5540 :     bits = effective_addr2 & 0xFFF;

  001c6	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001ca	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  001cf	89 44 24 34	 mov	 DWORD PTR bits$[rsp], eax

; 5541 : 
; 5542 :     /* Test data class and set condition code */
; 5543 :     regs->psw.cc = dfp_test_data_class(&set, &d1, bits);

  001d3	44 8b 44 24 34	 mov	 r8d, DWORD PTR bits$[rsp]
  001d8	48 8d 54 24 60	 lea	 rdx, QWORD PTR d1$[rsp]
  001dd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  001e2	e8 00 00 00 00	 call	 dfp_test_data_class
  001e7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ef	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 5544 : 
; 5545 : } /* end DEF_INST(test_data_class_dfp_long) */

  001f2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001fa	48 33 cc	 xor	 rcx, rsp
  001fd	e8 00 00 00 00	 call	 __security_check_cookie
  00202	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00209	c3		 ret	 0
s370_test_data_class_dfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
r1$ = 48
bits$ = 52
x1$ = 56
set$ = 72
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s370_test_data_class_dfp_ext PROC

; 5481 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5482 : int             r1;                     /* Value of R field          */
; 5483 : int             x2;                     /* Index register            */
; 5484 : int             b2;                     /* Base of effective addr    */
; 5485 : VADR            effective_addr2;        /* Effective address         */
; 5486 : decimal128      x1;                     /* Extended DFP value        */
; 5487 : decNumber       d1;                     /* Working decimal number    */
; 5488 : decContext      set;                    /* Working context           */
; 5489 : U32             bits;                   /* Low 12 bits of address    */
; 5490 : 
; 5491 :     RXE(inst, regs, r1, x2, b2, effective_addr2);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00048	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 10	 shr	 eax, 16
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00056	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 14	 shr	 eax, 20
  0005d	83 e0 0f	 and	 eax, 15
  00060	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00064	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00069	74 20		 je	 SHORT $LN5@s370_test_
  0006b	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  00070	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00078	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007f	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_test_:
  0008b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0008f	c1 e8 0c	 shr	 eax, 12
  00092	83 e0 0f	 and	 eax, 15
  00095	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  00099	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009e	74 20		 je	 SHORT $LN6@s370_test_
  000a0	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b4	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b8	03 c8		 add	 ecx, eax
  000ba	8b c1		 mov	 eax, ecx
  000bc	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_test_:
  000c0	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c9	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_test_:
  000cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d9	48 83 c0 06	 add	 rax, 6
  000dd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e9	33 c0		 xor	 eax, eax
  000eb	83 f8 06	 cmp	 eax, 6
  000ee	74 0f		 je	 SHORT $LN7@s370_test_
  000f0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_test_:
  000ff	33 c0		 xor	 eax, eax
  00101	85 c0		 test	 eax, eax
  00103	75 c8		 jne	 SHORT $LN4@s370_test_

; 5492 : 
; 5493 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5494 :     DFPINST_CHECK(regs);

  00105	b8 08 00 00 00	 mov	 eax, 8
  0010a	48 6b c0 01	 imul	 rax, rax, 1
  0010e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0011d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00122	85 c0		 test	 eax, eax
  00124	74 3f		 je	 SHORT $LN9@s370_test_
  00126	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00134	d1 e8		 shr	 eax, 1
  00136	83 e0 01	 and	 eax, 1
  00139	85 c0		 test	 eax, eax
  0013b	74 55		 je	 SHORT $LN8@s370_test_
  0013d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0014c	b9 08 00 00 00	 mov	 ecx, 8
  00151	48 6b c9 01	 imul	 rcx, rcx, 1
  00155	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  0015c	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00161	85 c0		 test	 eax, eax
  00163	75 2d		 jne	 SHORT $LN8@s370_test_
$LN9@s370_test_:
  00165	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00177	ba 07 00 00 00	 mov	 edx, 7
  0017c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_test_:

; 5495 :     DFPREGPAIR_CHECK(r1, regs);

  00192	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00196	83 e0 02	 and	 eax, 2
  00199	85 c0		 test	 eax, eax
  0019b	74 1b		 je	 SHORT $LN10@s370_test_
  0019d	ba 06 00 00 00	 mov	 edx, 6
  001a2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001aa	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s370_test_:

; 5496 : 
; 5497 :     /* Initialise the context for extended DFP */
; 5498 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001b8	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001bd	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001c2	e8 00 00 00 00	 call	 decContextDefault

; 5499 : 
; 5500 :     /* Convert FP register r1 to decimal number format */
; 5501 :     ARCH_DEP(dfp_reg_to_decimal128)(r1, &x1, regs);

  001c7	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001cf	48 8d 54 24 38	 lea	 rdx, QWORD PTR x1$[rsp]
  001d4	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  001d8	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 5502 :     decimal128ToNumber(&x1, &d1);

  001dd	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  001e2	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  001e7	e8 00 00 00 00	 call	 decimal128ToNumber

; 5503 : 
; 5504 :     /* Isolate rightmost 12 bits of second operand address */
; 5505 :     bits = effective_addr2 & 0xFFF;

  001ec	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001f0	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  001f5	89 44 24 34	 mov	 DWORD PTR bits$[rsp], eax

; 5506 : 
; 5507 :     /* Test data class and set condition code */
; 5508 :     regs->psw.cc = dfp_test_data_class(&set, &d1, bits);

  001f9	44 8b 44 24 34	 mov	 r8d, DWORD PTR bits$[rsp]
  001fe	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  00203	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00208	e8 00 00 00 00	 call	 dfp_test_data_class
  0020d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00215	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 5509 : 
; 5510 : } /* end DEF_INST(test_data_class_dfp_ext) */

  00218	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00220	48 33 cc	 xor	 rcx, rsp
  00223	e8 00 00 00 00	 call	 __security_check_cookie
  00228	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0022f	c3		 ret	 0
s370_test_data_class_dfp_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv175 = 40
tv176 = 44
tv177 = 48
r2$ = 52
r3$ = 56
r1$ = 60
x2$ = 64
x3$ = 72
x1$ = 80
d1$ = 88
set$ = 128
d3$ = 160
d2$ = 200
__$ArrayPad$ = 240
inst$ = 272
regs$ = 280
s370_subtract_dfp_long_reg PROC

; 5432 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5433 : int             r1, r2, r3;             /* Values of R fields        */
; 5434 : decimal64       x1, x2, x3;             /* Long DFP values           */
; 5435 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 5436 : decContext      set;                    /* Working context           */
; 5437 : BYTE            dxc;                    /* Data exception code       */
; 5438 : 
; 5439 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_subtr:
  00062	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_subtr
  00085	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_subtr:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_subtr

; 5440 : 
; 5441 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5442 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_subtr
  000bb	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_subtr
  000d2	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_subtr
$LN7@s370_subtr:
  000fa	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_subtr:

; 5443 : 
; 5444 :     /* Initialise the context for long DFP */
; 5445 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00127	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0012c	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00134	e8 00 00 00 00	 call	 decContextDefault

; 5446 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  00139	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00141	33 d2		 xor	 edx, edx
  00143	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  0014b	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 5447 : 
; 5448 :     /* Subtract FP register r3 from FP register r2 */
; 5449 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  00150	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00158	48 8d 54 24 40	 lea	 rdx, QWORD PTR x2$[rsp]
  0015d	8b 4c 24 34	 mov	 ecx, DWORD PTR r2$[rsp]
  00161	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 5450 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  00166	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0016e	48 8d 54 24 48	 lea	 rdx, QWORD PTR x3$[rsp]
  00173	8b 4c 24 38	 mov	 ecx, DWORD PTR r3$[rsp]
  00177	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 5451 :     decimal64ToNumber(&x2, &d2);

  0017c	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00184	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x2$[rsp]
  00189	e8 00 00 00 00	 call	 decimal64ToNumber

; 5452 :     decimal64ToNumber(&x3, &d3);

  0018e	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  00196	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x3$[rsp]
  0019b	e8 00 00 00 00	 call	 decimal64ToNumber

; 5453 :     decNumberSubtract(&d1, &d2, &d3, &set);

  001a0	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR set$[rsp]
  001a8	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  001b0	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001b8	48 8d 4c 24 58	 lea	 rcx, QWORD PTR d1$[rsp]
  001bd	e8 00 00 00 00	 call	 decNumberSubtract

; 5454 :     decimal64FromNumber(&x1, &d1, &set);

  001c2	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  001ca	48 8d 54 24 58	 lea	 rdx, QWORD PTR d1$[rsp]
  001cf	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  001d4	e8 00 00 00 00	 call	 decimal64FromNumber

; 5455 : 
; 5456 :     /* Check for exception condition */
; 5457 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  001d9	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001e1	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001e9	e8 00 00 00 00	 call	 s370_dfp_status_check
  001ee	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 5458 : 
; 5459 :     /* Load result into FP register r1 */
; 5460 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  001f2	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001fa	48 8d 54 24 50	 lea	 rdx, QWORD PTR x1$[rsp]
  001ff	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  00203	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 5461 : 
; 5462 :     /* Set condition code */
; 5463 :     regs->psw.cc = decNumberIsNaN(&d1) ? 3 :

  00208	0f b6 44 24 60	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0020d	83 e0 30	 and	 eax, 48			; 00000030H
  00210	85 c0		 test	 eax, eax
  00212	74 0a		 je	 SHORT $LN14@s370_subtr
  00214	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv177[rsp], 3
  0021c	eb 5f		 jmp	 SHORT $LN15@s370_subtr
$LN14@s370_subtr:
  0021e	b8 02 00 00 00	 mov	 eax, 2
  00223	48 6b c0 00	 imul	 rax, rax, 0
  00227	0f b7 44 04 62	 movzx	 eax, WORD PTR d1$[rsp+rax+10]
  0022c	85 c0		 test	 eax, eax
  0022e	75 1d		 jne	 SHORT $LN10@s370_subtr
  00230	83 7c 24 58 01	 cmp	 DWORD PTR d1$[rsp], 1
  00235	75 16		 jne	 SHORT $LN10@s370_subtr
  00237	0f b6 44 24 60	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0023c	83 e0 70	 and	 eax, 112		; 00000070H
  0023f	85 c0		 test	 eax, eax
  00241	75 0a		 jne	 SHORT $LN10@s370_subtr
  00243	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
  0024b	eb 28		 jmp	 SHORT $LN13@s370_subtr
$LN10@s370_subtr:
  0024d	0f b6 44 24 60	 movzx	 eax, BYTE PTR d1$[rsp+8]
  00252	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00257	85 c0		 test	 eax, eax
  00259	74 0a		 je	 SHORT $LN11@s370_subtr
  0025b	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv175[rsp], 1
  00263	eb 08		 jmp	 SHORT $LN12@s370_subtr
$LN11@s370_subtr:
  00265	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv175[rsp], 2
$LN12@s370_subtr:
  0026d	8b 44 24 28	 mov	 eax, DWORD PTR tv175[rsp]
  00271	89 44 24 2c	 mov	 DWORD PTR tv176[rsp], eax
$LN13@s370_subtr:
  00275	8b 44 24 2c	 mov	 eax, DWORD PTR tv176[rsp]
  00279	89 44 24 30	 mov	 DWORD PTR tv177[rsp], eax
$LN15@s370_subtr:
  0027d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00285	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv177[rsp]
  0028a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5464 :                    decNumberIsZero(&d1) ? 0 :
; 5465 :                    decNumberIsNegative(&d1) ? 1 : 2;
; 5466 : 
; 5467 :     /* Raise data exception if error occurred */
; 5468 :     if (dxc != 0)

  0028d	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00292	85 c0		 test	 eax, eax
  00294	74 25		 je	 SHORT $LN8@s370_subtr

; 5469 :     {
; 5470 :         regs->dxc = dxc;

  00296	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0029b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a3	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 5471 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002a9	ba 07 00 00 00	 mov	 edx, 7
  002ae	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b6	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_subtr:

; 5472 :     }
; 5473 : 
; 5474 : } /* end DEF_INST(subtract_dfp_long_reg) */

  002bb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002c3	48 33 cc	 xor	 rcx, rsp
  002c6	e8 00 00 00 00	 call	 __security_check_cookie
  002cb	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  002d2	c3		 ret	 0
s370_subtract_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
tv184 = 52
tv185 = 56
tv186 = 60
d1$ = 64
set$ = 104
x2$ = 136
x3$ = 152
x1$ = 168
d3$ = 184
d2$ = 224
__$ArrayPad$ = 264
inst$ = 288
regs$ = 296
s370_subtract_dfp_ext_reg PROC

; 5382 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5383 : int             r1, r2, r3;             /* Values of R fields        */
; 5384 : decimal128      x1, x2, x3;             /* Extended DFP values       */
; 5385 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 5386 : decContext      set;                    /* Working context           */
; 5387 : BYTE            dxc;                    /* Data exception code       */
; 5388 : 
; 5389 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_subtr:
  00062	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_subtr
  00085	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_subtr:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_subtr

; 5390 : 
; 5391 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5392 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_subtr
  000bb	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_subtr
  000d2	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_subtr
$LN7@s370_subtr:
  000fa	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_subtr:

; 5393 :     DFPREGPAIR3_CHECK(r1, r2, r3, regs);

  00127	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0012b	83 e0 02	 and	 eax, 2
  0012e	85 c0		 test	 eax, eax
  00130	75 16		 jne	 SHORT $LN9@s370_subtr
  00132	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00136	83 e0 02	 and	 eax, 2
  00139	85 c0		 test	 eax, eax
  0013b	75 0b		 jne	 SHORT $LN9@s370_subtr
  0013d	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  00141	83 e0 02	 and	 eax, 2
  00144	85 c0		 test	 eax, eax
  00146	74 1b		 je	 SHORT $LN8@s370_subtr
$LN9@s370_subtr:
  00148	ba 06 00 00 00	 mov	 edx, 6
  0014d	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00155	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_subtr:

; 5394 : 
; 5395 :     /* Initialise the context for extended DFP */
; 5396 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00163	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00168	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  0016d	e8 00 00 00 00	 call	 decContextDefault

; 5397 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  00172	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017a	33 d2		 xor	 edx, edx
  0017c	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00181	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 5398 : 
; 5399 :     /* Subtract FP register r3 from FP register r2 */
; 5400 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00186	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0018e	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  00196	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  0019a	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 5401 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  0019f	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001a7	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR x3$[rsp]
  001af	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  001b3	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 5402 :     decimal128ToNumber(&x2, &d2);

  001b8	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001c0	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  001c8	e8 00 00 00 00	 call	 decimal128ToNumber

; 5403 :     decimal128ToNumber(&x3, &d3);

  001cd	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  001d5	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR x3$[rsp]
  001dd	e8 00 00 00 00	 call	 decimal128ToNumber

; 5404 :     decNumberSubtract(&d1, &d2, &d3, &set);

  001e2	4c 8d 4c 24 68	 lea	 r9, QWORD PTR set$[rsp]
  001e7	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  001ef	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001f7	48 8d 4c 24 40	 lea	 rcx, QWORD PTR d1$[rsp]
  001fc	e8 00 00 00 00	 call	 decNumberSubtract

; 5405 :     decimal128FromNumber(&x1, &d1, &set);

  00201	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  00206	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  0020b	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR x1$[rsp]
  00213	e8 00 00 00 00	 call	 decimal128FromNumber

; 5406 : 
; 5407 :     /* Check for exception condition */
; 5408 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00218	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00220	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00225	e8 00 00 00 00	 call	 s370_dfp_status_check
  0022a	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 5409 : 
; 5410 :     /* Load result into FP register r1 */
; 5411 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  0022e	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00236	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR x1$[rsp]
  0023e	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  00242	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 5412 : 
; 5413 :     /* Set condition code */
; 5414 :     regs->psw.cc = decNumberIsNaN(&d1) ? 3 :

  00247	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0024c	83 e0 30	 and	 eax, 48			; 00000030H
  0024f	85 c0		 test	 eax, eax
  00251	74 0a		 je	 SHORT $LN16@s370_subtr
  00253	c7 44 24 3c 03
	00 00 00	 mov	 DWORD PTR tv186[rsp], 3
  0025b	eb 5f		 jmp	 SHORT $LN17@s370_subtr
$LN16@s370_subtr:
  0025d	b8 02 00 00 00	 mov	 eax, 2
  00262	48 6b c0 00	 imul	 rax, rax, 0
  00266	0f b7 44 04 4a	 movzx	 eax, WORD PTR d1$[rsp+rax+10]
  0026b	85 c0		 test	 eax, eax
  0026d	75 1d		 jne	 SHORT $LN12@s370_subtr
  0026f	83 7c 24 40 01	 cmp	 DWORD PTR d1$[rsp], 1
  00274	75 16		 jne	 SHORT $LN12@s370_subtr
  00276	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0027b	83 e0 70	 and	 eax, 112		; 00000070H
  0027e	85 c0		 test	 eax, eax
  00280	75 0a		 jne	 SHORT $LN12@s370_subtr
  00282	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
  0028a	eb 28		 jmp	 SHORT $LN15@s370_subtr
$LN12@s370_subtr:
  0028c	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  00291	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00296	85 c0		 test	 eax, eax
  00298	74 0a		 je	 SHORT $LN13@s370_subtr
  0029a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv184[rsp], 1
  002a2	eb 08		 jmp	 SHORT $LN14@s370_subtr
$LN13@s370_subtr:
  002a4	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv184[rsp], 2
$LN14@s370_subtr:
  002ac	8b 44 24 34	 mov	 eax, DWORD PTR tv184[rsp]
  002b0	89 44 24 38	 mov	 DWORD PTR tv185[rsp], eax
$LN15@s370_subtr:
  002b4	8b 44 24 38	 mov	 eax, DWORD PTR tv185[rsp]
  002b8	89 44 24 3c	 mov	 DWORD PTR tv186[rsp], eax
$LN17@s370_subtr:
  002bc	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c4	0f b6 4c 24 3c	 movzx	 ecx, BYTE PTR tv186[rsp]
  002c9	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 5415 :                    decNumberIsZero(&d1) ? 0 :
; 5416 :                    decNumberIsNegative(&d1) ? 1 : 2;
; 5417 : 
; 5418 :     /* Raise data exception if error occurred */
; 5419 :     if (dxc != 0)

  002cc	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002d1	85 c0		 test	 eax, eax
  002d3	74 25		 je	 SHORT $LN10@s370_subtr

; 5420 :     {
; 5421 :         regs->dxc = dxc;

  002d5	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002da	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 5422 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002e8	ba 07 00 00 00	 mov	 edx, 7
  002ed	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f5	e8 00 00 00 00	 call	 s370_program_interrupt
$LN10@s370_subtr:

; 5423 :     }
; 5424 : 
; 5425 : } /* end DEF_INST(subtract_dfp_ext_reg) */

  002fa	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00302	48 33 cc	 xor	 rcx, rsp
  00305	e8 00 00 00 00	 call	 __security_check_cookie
  0030a	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00311	c3		 ret	 0
s370_subtract_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
r3$ = 48
n$ = 52
r1$ = 56
x1$ = 64
x3$ = 72
d3$ = 80
d1$ = 120
set$ = 160
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
s370_shift_coefficient_right_dfp_long PROC

; 5320 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5321 : int             r1, r3;                 /* Values of R fields        */
; 5322 : int             x2;                     /* Index register            */
; 5323 : int             b2;                     /* Base of effective addr    */
; 5324 : VADR            effective_addr2;        /* Effective address         */
; 5325 : decimal64       x1, x3;                 /* Long DFP values           */
; 5326 : decNumber       d1, d3;                 /* Working decimal numbers   */
; 5327 : decContext      set;                    /* Working context           */
; 5328 : int             n;                      /* Number of bits to shift   */
; 5329 : 
; 5330 :     RXF(inst, regs, r1, r3, x2, b2, effective_addr2);

  00023	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	48 6b c0 04	 imul	 rax, rax, 4
  00044	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0004c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00050	c1 f8 04	 sar	 eax, 4
  00053	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00057	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00060	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00064	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00068	c1 e8 10	 shr	 eax, 16
  0006b	83 e0 0f	 and	 eax, 15
  0006e	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00072	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00076	c1 e8 14	 shr	 eax, 20
  00079	83 e0 0f	 and	 eax, 15
  0007c	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
  00080	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00085	74 20		 je	 SHORT $LN5@s370_shift
  00087	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  0008c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00094	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009b	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009f	03 c8		 add	 ecx, eax
  000a1	8b c1		 mov	 eax, ecx
  000a3	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_shift:
  000a7	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  000ab	c1 e8 0c	 shr	 eax, 12
  000ae	83 e0 0f	 and	 eax, 15
  000b1	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  000b5	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ba	74 20		 je	 SHORT $LN6@s370_shift
  000bc	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000c1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000d4	03 c8		 add	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_shift:
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000e0	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000e5	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_shift:
  000e9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f5	48 83 c0 06	 add	 rax, 6
  000f9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00105	33 c0		 xor	 eax, eax
  00107	83 f8 06	 cmp	 eax, 6
  0010a	74 0f		 je	 SHORT $LN7@s370_shift
  0010c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_shift:
  0011b	33 c0		 xor	 eax, eax
  0011d	85 c0		 test	 eax, eax
  0011f	75 c8		 jne	 SHORT $LN4@s370_shift

; 5331 : 
; 5332 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5333 :     DFPINST_CHECK(regs);

  00121	b8 08 00 00 00	 mov	 eax, 8
  00126	48 6b c0 01	 imul	 rax, rax, 1
  0012a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00139	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0013e	85 c0		 test	 eax, eax
  00140	74 3f		 je	 SHORT $LN9@s370_shift
  00142	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00150	d1 e8		 shr	 eax, 1
  00152	83 e0 01	 and	 eax, 1
  00155	85 c0		 test	 eax, eax
  00157	74 55		 je	 SHORT $LN8@s370_shift
  00159	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00161	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00168	b9 08 00 00 00	 mov	 ecx, 8
  0016d	48 6b c9 01	 imul	 rcx, rcx, 1
  00171	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00178	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0017d	85 c0		 test	 eax, eax
  0017f	75 2d		 jne	 SHORT $LN8@s370_shift
$LN9@s370_shift:
  00181	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00189	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00193	ba 07 00 00 00	 mov	 edx, 7
  00198	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_shift:

; 5334 : 
; 5335 :     /* Isolate rightmost 6 bits of second operand address */
; 5336 :     n = effective_addr2 & 0x3F;

  001ae	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001b2	83 e0 3f	 and	 eax, 63			; 0000003fH
  001b5	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 5337 : 
; 5338 :     /* Initialise the context for long DFP */
; 5339 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001b9	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001be	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001c6	e8 00 00 00 00	 call	 decContextDefault

; 5340 : 
; 5341 :     /* Load DFP long number from FP register r3 */
; 5342 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  001cb	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001d3	48 8d 54 24 48	 lea	 rdx, QWORD PTR x3$[rsp]
  001d8	8b 4c 24 30	 mov	 ecx, DWORD PTR r3$[rsp]
  001dc	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 5343 : 
; 5344 :     /* Convert to internal decimal number format */
; 5345 :     decimal64ToNumber(&x3, &d3);

  001e1	48 8d 54 24 50	 lea	 rdx, QWORD PTR d3$[rsp]
  001e6	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x3$[rsp]
  001eb	e8 00 00 00 00	 call	 decimal64ToNumber

; 5346 : 
; 5347 :     /* For NaN and Inf use coefficient continuation digits only */
; 5348 :     if (decNumberIsNaN(&d3) || decNumberIsInfinite(&d3))

  001f0	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  001f5	83 e0 30	 and	 eax, 48			; 00000030H
  001f8	85 c0		 test	 eax, eax
  001fa	75 0c		 jne	 SHORT $LN12@s370_shift
  001fc	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00201	83 e0 40	 and	 eax, 64			; 00000040H
  00204	85 c0		 test	 eax, eax
  00206	74 1b		 je	 SHORT $LN10@s370_shift
$LN12@s370_shift:

; 5349 :     {
; 5350 :         dfp64_clear_cf_and_bxcf(&x3);

  00208	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x3$[rsp]
  0020d	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 5351 :         decimal64ToNumber(&x3, &d1);

  00212	48 8d 54 24 78	 lea	 rdx, QWORD PTR d1$[rsp]
  00217	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x3$[rsp]
  0021c	e8 00 00 00 00	 call	 decimal64ToNumber

; 5352 :     }

  00221	eb 0f		 jmp	 SHORT $LN11@s370_shift
$LN10@s370_shift:

; 5353 :     else
; 5354 :     {
; 5355 :         decNumberCopy(&d1, &d3);

  00223	48 8d 54 24 50	 lea	 rdx, QWORD PTR d3$[rsp]
  00228	48 8d 4c 24 78	 lea	 rcx, QWORD PTR d1$[rsp]
  0022d	e8 00 00 00 00	 call	 decNumberCopy
$LN11@s370_shift:

; 5356 :     }
; 5357 : 
; 5358 :     /* Shift coefficient right n digit positions */
; 5359 :     dfp_shift_coeff(&set, &d1, -n);

  00232	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  00236	f7 d8		 neg	 eax
  00238	44 8b c0	 mov	 r8d, eax
  0023b	48 8d 54 24 78	 lea	 rdx, QWORD PTR d1$[rsp]
  00240	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00248	e8 00 00 00 00	 call	 dfp_shift_coeff

; 5360 : 
; 5361 :     /* Convert result to DFP long format */
; 5362 :     decimal64FromNumber(&x1, &d1, &set);

  0024d	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  00255	48 8d 54 24 78	 lea	 rdx, QWORD PTR d1$[rsp]
  0025a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  0025f	e8 00 00 00 00	 call	 decimal64FromNumber

; 5363 : 
; 5364 :     /* Restore Nan or Inf indicators in the result */
; 5365 :     if (decNumberIsQNaN(&d3))

  00264	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00269	83 e0 20	 and	 eax, 32			; 00000020H
  0026c	85 c0		 test	 eax, eax
  0026e	74 11		 je	 SHORT $LN13@s370_shift

; 5366 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  00270	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  00275	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  0027a	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
  0027f	eb 38		 jmp	 SHORT $LN14@s370_shift
$LN13@s370_shift:

; 5367 :     else if (decNumberIsSNaN(&d3))

  00281	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00286	83 e0 10	 and	 eax, 16
  00289	85 c0		 test	 eax, eax
  0028b	74 11		 je	 SHORT $LN15@s370_shift

; 5368 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  0028d	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  00292	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00297	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
  0029c	eb 1b		 jmp	 SHORT $LN16@s370_shift
$LN15@s370_shift:

; 5369 :     else if (decNumberIsInfinite(&d3))

  0029e	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002a3	83 e0 40	 and	 eax, 64			; 00000040H
  002a6	85 c0		 test	 eax, eax
  002a8	74 0f		 je	 SHORT $LN17@s370_shift

; 5370 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  002aa	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  002af	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002b4	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
$LN17@s370_shift:
$LN16@s370_shift:
$LN14@s370_shift:

; 5371 : 
; 5372 :     /* Load result into FP register r1 */
; 5373 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  002b9	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002c1	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  002c6	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  002ca	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 5374 : 
; 5375 : } /* end DEF_INST(shift_coefficient_right_dfp_long) */

  002cf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002d7	48 33 cc	 xor	 rcx, rsp
  002da	e8 00 00 00 00	 call	 __security_check_cookie
  002df	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  002e6	c3		 ret	 0
s370_shift_coefficient_right_dfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
r3$ = 48
r1$ = 52
n$ = 56
x1$ = 64
x3$ = 80
d3$ = 96
d1$ = 136
set$ = 176
__$ArrayPad$ = 208
inst$ = 240
regs$ = 248
s370_shift_coefficient_right_dfp_ext PROC

; 5257 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5258 : int             r1, r3;                 /* Values of R fields        */
; 5259 : int             x2;                     /* Index register            */
; 5260 : int             b2;                     /* Base of effective addr    */
; 5261 : VADR            effective_addr2;        /* Effective address         */
; 5262 : decimal128      x1, x3;                 /* Extended DFP values       */
; 5263 : decNumber       d1, d3;                 /* Working decimal numbers   */
; 5264 : decContext      set;                    /* Working context           */
; 5265 : int             n;                      /* Number of bits to shift   */
; 5266 : 
; 5267 :     RXF(inst, regs, r1, r3, x2, b2, effective_addr2);

  00023	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	48 6b c0 04	 imul	 rax, rax, 4
  00044	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0004c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00050	c1 f8 04	 sar	 eax, 4
  00053	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00057	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00060	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00064	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00068	c1 e8 10	 shr	 eax, 16
  0006b	83 e0 0f	 and	 eax, 15
  0006e	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00072	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00076	c1 e8 14	 shr	 eax, 20
  00079	83 e0 0f	 and	 eax, 15
  0007c	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
  00080	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00085	74 20		 je	 SHORT $LN5@s370_shift
  00087	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  0008c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00094	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009b	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009f	03 c8		 add	 ecx, eax
  000a1	8b c1		 mov	 eax, ecx
  000a3	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_shift:
  000a7	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  000ab	c1 e8 0c	 shr	 eax, 12
  000ae	83 e0 0f	 and	 eax, 15
  000b1	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  000b5	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ba	74 20		 je	 SHORT $LN6@s370_shift
  000bc	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000c1	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000d4	03 c8		 add	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_shift:
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000e0	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000e5	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_shift:
  000e9	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f5	48 83 c0 06	 add	 rax, 6
  000f9	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00105	33 c0		 xor	 eax, eax
  00107	83 f8 06	 cmp	 eax, 6
  0010a	74 0f		 je	 SHORT $LN7@s370_shift
  0010c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_shift:
  0011b	33 c0		 xor	 eax, eax
  0011d	85 c0		 test	 eax, eax
  0011f	75 c8		 jne	 SHORT $LN4@s370_shift

; 5268 : 
; 5269 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5270 :     DFPINST_CHECK(regs);

  00121	b8 08 00 00 00	 mov	 eax, 8
  00126	48 6b c0 01	 imul	 rax, rax, 1
  0012a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00139	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0013e	85 c0		 test	 eax, eax
  00140	74 3f		 je	 SHORT $LN9@s370_shift
  00142	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00150	d1 e8		 shr	 eax, 1
  00152	83 e0 01	 and	 eax, 1
  00155	85 c0		 test	 eax, eax
  00157	74 55		 je	 SHORT $LN8@s370_shift
  00159	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00161	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00168	b9 08 00 00 00	 mov	 ecx, 8
  0016d	48 6b c9 01	 imul	 rcx, rcx, 1
  00171	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00178	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0017d	85 c0		 test	 eax, eax
  0017f	75 2d		 jne	 SHORT $LN8@s370_shift
$LN9@s370_shift:
  00181	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00189	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00193	ba 07 00 00 00	 mov	 edx, 7
  00198	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_shift:

; 5271 :     DFPREGPAIR2_CHECK(r1, r3, regs);

  001ae	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  001b2	83 e0 02	 and	 eax, 2
  001b5	85 c0		 test	 eax, eax
  001b7	75 0b		 jne	 SHORT $LN11@s370_shift
  001b9	8b 44 24 30	 mov	 eax, DWORD PTR r3$[rsp]
  001bd	83 e0 02	 and	 eax, 2
  001c0	85 c0		 test	 eax, eax
  001c2	74 1b		 je	 SHORT $LN10@s370_shift
$LN11@s370_shift:
  001c4	ba 06 00 00 00	 mov	 edx, 6
  001c9	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d1	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s370_shift:

; 5272 : 
; 5273 :     /* Isolate rightmost 6 bits of second operand address */
; 5274 :     n = effective_addr2 & 0x3F;

  001df	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001e3	83 e0 3f	 and	 eax, 63			; 0000003fH
  001e6	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax

; 5275 : 
; 5276 :     /* Initialise the context for extended DFP */
; 5277 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001ea	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001ef	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001f7	e8 00 00 00 00	 call	 decContextDefault

; 5278 : 
; 5279 :     /* Load DFP extended number from FP register r3 */
; 5280 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  001fc	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00204	48 8d 54 24 50	 lea	 rdx, QWORD PTR x3$[rsp]
  00209	8b 4c 24 30	 mov	 ecx, DWORD PTR r3$[rsp]
  0020d	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 5281 : 
; 5282 :     /* Convert to internal decimal number format */
; 5283 :     decimal128ToNumber(&x3, &d3);

  00212	48 8d 54 24 60	 lea	 rdx, QWORD PTR d3$[rsp]
  00217	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x3$[rsp]
  0021c	e8 00 00 00 00	 call	 decimal128ToNumber

; 5284 : 
; 5285 :     /* For NaN and Inf use coefficient continuation digits only */
; 5286 :     if (decNumberIsNaN(&d3) || decNumberIsInfinite(&d3))

  00221	0f b6 44 24 68	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00226	83 e0 30	 and	 eax, 48			; 00000030H
  00229	85 c0		 test	 eax, eax
  0022b	75 0c		 jne	 SHORT $LN14@s370_shift
  0022d	0f b6 44 24 68	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00232	83 e0 40	 and	 eax, 64			; 00000040H
  00235	85 c0		 test	 eax, eax
  00237	74 1e		 je	 SHORT $LN12@s370_shift
$LN14@s370_shift:

; 5287 :     {
; 5288 :         dfp128_clear_cf_and_bxcf(&x3);

  00239	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x3$[rsp]
  0023e	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 5289 :         decimal128ToNumber(&x3, &d1);

  00243	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0024b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x3$[rsp]
  00250	e8 00 00 00 00	 call	 decimal128ToNumber

; 5290 :     }

  00255	eb 12		 jmp	 SHORT $LN13@s370_shift
$LN12@s370_shift:

; 5291 :     else
; 5292 :     {
; 5293 :         decNumberCopy(&d1, &d3);

  00257	48 8d 54 24 60	 lea	 rdx, QWORD PTR d3$[rsp]
  0025c	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  00264	e8 00 00 00 00	 call	 decNumberCopy
$LN13@s370_shift:

; 5294 :     }
; 5295 : 
; 5296 :     /* Shift coefficient right n digit positions */
; 5297 :     dfp_shift_coeff(&set, &d1, -n);

  00269	8b 44 24 38	 mov	 eax, DWORD PTR n$[rsp]
  0026d	f7 d8		 neg	 eax
  0026f	44 8b c0	 mov	 r8d, eax
  00272	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0027a	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00282	e8 00 00 00 00	 call	 dfp_shift_coeff

; 5298 : 
; 5299 :     /* Convert result to DFP extended format */
; 5300 :     decimal128FromNumber(&x1, &d1, &set);

  00287	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  0028f	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00297	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  0029c	e8 00 00 00 00	 call	 decimal128FromNumber

; 5301 : 
; 5302 :     /* Restore Nan or Inf indicators in the result */
; 5303 :     if (decNumberIsQNaN(&d3))

  002a1	0f b6 44 24 68	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002a6	83 e0 20	 and	 eax, 32			; 00000020H
  002a9	85 c0		 test	 eax, eax
  002ab	74 11		 je	 SHORT $LN15@s370_shift

; 5304 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  002ad	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  002b2	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002b7	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf
  002bc	eb 38		 jmp	 SHORT $LN16@s370_shift
$LN15@s370_shift:

; 5305 :     else if (decNumberIsSNaN(&d3))

  002be	0f b6 44 24 68	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002c3	83 e0 10	 and	 eax, 16
  002c6	85 c0		 test	 eax, eax
  002c8	74 11		 je	 SHORT $LN17@s370_shift

; 5306 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  002ca	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  002cf	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002d4	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf
  002d9	eb 1b		 jmp	 SHORT $LN18@s370_shift
$LN17@s370_shift:

; 5307 :     else if (decNumberIsInfinite(&d3))

  002db	0f b6 44 24 68	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002e0	83 e0 40	 and	 eax, 64			; 00000040H
  002e3	85 c0		 test	 eax, eax
  002e5	74 0f		 je	 SHORT $LN19@s370_shift

; 5308 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  002e7	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  002ec	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002f1	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf
$LN19@s370_shift:
$LN18@s370_shift:
$LN16@s370_shift:

; 5309 : 
; 5310 :     /* Load result into FP register r1 */
; 5311 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  002f6	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002fe	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  00303	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00307	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 5312 : 
; 5313 : } /* end DEF_INST(shift_coefficient_right_dfp_ext) */

  0030c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00314	48 33 cc	 xor	 rcx, rsp
  00317	e8 00 00 00 00	 call	 __security_check_cookie
  0031c	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00323	c3		 ret	 0
s370_shift_coefficient_right_dfp_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
r3$ = 48
n$ = 52
r1$ = 56
x1$ = 64
x3$ = 72
d3$ = 80
d1$ = 120
set$ = 160
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
s370_shift_coefficient_left_dfp_long PROC

; 5195 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5196 : int             r1, r3;                 /* Values of R fields        */
; 5197 : int             x2;                     /* Index register            */
; 5198 : int             b2;                     /* Base of effective addr    */
; 5199 : VADR            effective_addr2;        /* Effective address         */
; 5200 : decimal64       x1, x3;                 /* Long DFP values           */
; 5201 : decNumber       d1, d3;                 /* Working decimal numbers   */
; 5202 : decContext      set;                    /* Working context           */
; 5203 : int             n;                      /* Number of bits to shift   */
; 5204 : 
; 5205 :     RXF(inst, regs, r1, r3, x2, b2, effective_addr2);

  00023	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	48 6b c0 04	 imul	 rax, rax, 4
  00044	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0004c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00050	c1 f8 04	 sar	 eax, 4
  00053	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00057	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00060	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00064	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00068	c1 e8 10	 shr	 eax, 16
  0006b	83 e0 0f	 and	 eax, 15
  0006e	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00072	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00076	c1 e8 14	 shr	 eax, 20
  00079	83 e0 0f	 and	 eax, 15
  0007c	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
  00080	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00085	74 20		 je	 SHORT $LN5@s370_shift
  00087	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  0008c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00094	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009b	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009f	03 c8		 add	 ecx, eax
  000a1	8b c1		 mov	 eax, ecx
  000a3	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_shift:
  000a7	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  000ab	c1 e8 0c	 shr	 eax, 12
  000ae	83 e0 0f	 and	 eax, 15
  000b1	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  000b5	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ba	74 20		 je	 SHORT $LN6@s370_shift
  000bc	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000c1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000d4	03 c8		 add	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_shift:
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000e0	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000e5	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_shift:
  000e9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f5	48 83 c0 06	 add	 rax, 6
  000f9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00105	33 c0		 xor	 eax, eax
  00107	83 f8 06	 cmp	 eax, 6
  0010a	74 0f		 je	 SHORT $LN7@s370_shift
  0010c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_shift:
  0011b	33 c0		 xor	 eax, eax
  0011d	85 c0		 test	 eax, eax
  0011f	75 c8		 jne	 SHORT $LN4@s370_shift

; 5206 : 
; 5207 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5208 :     DFPINST_CHECK(regs);

  00121	b8 08 00 00 00	 mov	 eax, 8
  00126	48 6b c0 01	 imul	 rax, rax, 1
  0012a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00139	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0013e	85 c0		 test	 eax, eax
  00140	74 3f		 je	 SHORT $LN9@s370_shift
  00142	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00150	d1 e8		 shr	 eax, 1
  00152	83 e0 01	 and	 eax, 1
  00155	85 c0		 test	 eax, eax
  00157	74 55		 je	 SHORT $LN8@s370_shift
  00159	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00161	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00168	b9 08 00 00 00	 mov	 ecx, 8
  0016d	48 6b c9 01	 imul	 rcx, rcx, 1
  00171	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00178	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0017d	85 c0		 test	 eax, eax
  0017f	75 2d		 jne	 SHORT $LN8@s370_shift
$LN9@s370_shift:
  00181	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00189	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00193	ba 07 00 00 00	 mov	 edx, 7
  00198	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_shift:

; 5209 : 
; 5210 :     /* Isolate rightmost 6 bits of second operand address */
; 5211 :     n = effective_addr2 & 0x3F;

  001ae	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001b2	83 e0 3f	 and	 eax, 63			; 0000003fH
  001b5	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax

; 5212 : 
; 5213 :     /* Initialise the context for long DFP */
; 5214 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  001b9	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001be	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001c6	e8 00 00 00 00	 call	 decContextDefault

; 5215 : 
; 5216 :     /* Load DFP long number from FP register r3 */
; 5217 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  001cb	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001d3	48 8d 54 24 48	 lea	 rdx, QWORD PTR x3$[rsp]
  001d8	8b 4c 24 30	 mov	 ecx, DWORD PTR r3$[rsp]
  001dc	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 5218 : 
; 5219 :     /* Convert to internal decimal number format */
; 5220 :     decimal64ToNumber(&x3, &d3);

  001e1	48 8d 54 24 50	 lea	 rdx, QWORD PTR d3$[rsp]
  001e6	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x3$[rsp]
  001eb	e8 00 00 00 00	 call	 decimal64ToNumber

; 5221 : 
; 5222 :     /* For NaN and Inf use coefficient continuation digits only */
; 5223 :     if (decNumberIsNaN(&d3) || decNumberIsInfinite(&d3))

  001f0	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  001f5	83 e0 30	 and	 eax, 48			; 00000030H
  001f8	85 c0		 test	 eax, eax
  001fa	75 0c		 jne	 SHORT $LN12@s370_shift
  001fc	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00201	83 e0 40	 and	 eax, 64			; 00000040H
  00204	85 c0		 test	 eax, eax
  00206	74 1b		 je	 SHORT $LN10@s370_shift
$LN12@s370_shift:

; 5224 :     {
; 5225 :         dfp64_clear_cf_and_bxcf(&x3);

  00208	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x3$[rsp]
  0020d	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 5226 :         decimal64ToNumber(&x3, &d1);

  00212	48 8d 54 24 78	 lea	 rdx, QWORD PTR d1$[rsp]
  00217	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x3$[rsp]
  0021c	e8 00 00 00 00	 call	 decimal64ToNumber

; 5227 :     }

  00221	eb 0f		 jmp	 SHORT $LN11@s370_shift
$LN10@s370_shift:

; 5228 :     else
; 5229 :     {
; 5230 :         decNumberCopy(&d1, &d3);

  00223	48 8d 54 24 50	 lea	 rdx, QWORD PTR d3$[rsp]
  00228	48 8d 4c 24 78	 lea	 rcx, QWORD PTR d1$[rsp]
  0022d	e8 00 00 00 00	 call	 decNumberCopy
$LN11@s370_shift:

; 5231 :     }
; 5232 : 
; 5233 :     /* Shift coefficient left n digit positions */
; 5234 :     dfp_shift_coeff(&set, &d1, n);

  00232	44 8b 44 24 34	 mov	 r8d, DWORD PTR n$[rsp]
  00237	48 8d 54 24 78	 lea	 rdx, QWORD PTR d1$[rsp]
  0023c	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00244	e8 00 00 00 00	 call	 dfp_shift_coeff

; 5235 : 
; 5236 :     /* Convert result to DFP long format */
; 5237 :     decimal64FromNumber(&x1, &d1, &set);

  00249	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  00251	48 8d 54 24 78	 lea	 rdx, QWORD PTR d1$[rsp]
  00256	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  0025b	e8 00 00 00 00	 call	 decimal64FromNumber

; 5238 : 
; 5239 :     /* Restore Nan or Inf indicators in the result */
; 5240 :     if (decNumberIsQNaN(&d3))

  00260	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00265	83 e0 20	 and	 eax, 32			; 00000020H
  00268	85 c0		 test	 eax, eax
  0026a	74 11		 je	 SHORT $LN13@s370_shift

; 5241 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  0026c	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  00271	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00276	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
  0027b	eb 38		 jmp	 SHORT $LN14@s370_shift
$LN13@s370_shift:

; 5242 :     else if (decNumberIsSNaN(&d3))

  0027d	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00282	83 e0 10	 and	 eax, 16
  00285	85 c0		 test	 eax, eax
  00287	74 11		 je	 SHORT $LN15@s370_shift

; 5243 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  00289	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  0028e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00293	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
  00298	eb 1b		 jmp	 SHORT $LN16@s370_shift
$LN15@s370_shift:

; 5244 :     else if (decNumberIsInfinite(&d3))

  0029a	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  0029f	83 e0 40	 and	 eax, 64			; 00000040H
  002a2	85 c0		 test	 eax, eax
  002a4	74 0f		 je	 SHORT $LN17@s370_shift

; 5245 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  002a6	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  002ab	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002b0	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
$LN17@s370_shift:
$LN16@s370_shift:
$LN14@s370_shift:

; 5246 : 
; 5247 :     /* Load result into FP register r1 */
; 5248 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  002b5	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002bd	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  002c2	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  002c6	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 5249 : 
; 5250 : } /* end DEF_INST(shift_coefficient_left_dfp_long) */

  002cb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002d3	48 33 cc	 xor	 rcx, rsp
  002d6	e8 00 00 00 00	 call	 __security_check_cookie
  002db	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  002e2	c3		 ret	 0
s370_shift_coefficient_left_dfp_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
x2$ = 40
b2$ = 44
r3$ = 48
r1$ = 52
n$ = 56
x1$ = 64
x3$ = 80
d3$ = 96
d1$ = 136
set$ = 176
__$ArrayPad$ = 208
inst$ = 240
regs$ = 248
s370_shift_coefficient_left_dfp_ext PROC

; 5132 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5133 : int             r1, r3;                 /* Values of R fields        */
; 5134 : int             x2;                     /* Index register            */
; 5135 : int             b2;                     /* Base of effective addr    */
; 5136 : VADR            effective_addr2;        /* Effective address         */
; 5137 : decimal128      x1, x3;                 /* Extended DFP values       */
; 5138 : decNumber       d1, d3;                 /* Working decimal numbers   */
; 5139 : decContext      set;                    /* Working context           */
; 5140 : int             n;                      /* Number of bits to shift   */
; 5141 : 
; 5142 :     RXF(inst, regs, r1, r3, x2, b2, effective_addr2);

  00023	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	b8 01 00 00 00	 mov	 eax, 1
  00040	48 6b c0 04	 imul	 rax, rax, 4
  00044	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0004c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00050	c1 f8 04	 sar	 eax, 4
  00053	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00057	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0005b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00060	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00064	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00068	c1 e8 10	 shr	 eax, 16
  0006b	83 e0 0f	 and	 eax, 15
  0006e	89 44 24 28	 mov	 DWORD PTR x2$[rsp], eax
  00072	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00076	c1 e8 14	 shr	 eax, 20
  00079	83 e0 0f	 and	 eax, 15
  0007c	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
  00080	83 7c 24 28 00	 cmp	 DWORD PTR x2$[rsp], 0
  00085	74 20		 je	 SHORT $LN5@s370_shift
  00087	48 63 44 24 28	 movsxd	 rax, DWORD PTR x2$[rsp]
  0008c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00094	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0009b	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0009f	03 c8		 add	 ecx, eax
  000a1	8b c1		 mov	 eax, ecx
  000a3	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_shift:
  000a7	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  000ab	c1 e8 0c	 shr	 eax, 12
  000ae	83 e0 0f	 and	 eax, 15
  000b1	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  000b5	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ba	74 20		 je	 SHORT $LN6@s370_shift
  000bc	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000c1	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000d4	03 c8		 add	 ecx, eax
  000d6	8b c1		 mov	 eax, ecx
  000d8	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN6@s370_shift:
  000dc	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000e0	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000e5	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN4@s370_shift:
  000e9	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f5	48 83 c0 06	 add	 rax, 6
  000f9	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00105	33 c0		 xor	 eax, eax
  00107	83 f8 06	 cmp	 eax, 6
  0010a	74 0f		 je	 SHORT $LN7@s370_shift
  0010c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@s370_shift:
  0011b	33 c0		 xor	 eax, eax
  0011d	85 c0		 test	 eax, eax
  0011f	75 c8		 jne	 SHORT $LN4@s370_shift

; 5143 : 
; 5144 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5145 :     DFPINST_CHECK(regs);

  00121	b8 08 00 00 00	 mov	 eax, 8
  00126	48 6b c0 01	 imul	 rax, rax, 1
  0012a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00139	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0013e	85 c0		 test	 eax, eax
  00140	74 3f		 je	 SHORT $LN9@s370_shift
  00142	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00150	d1 e8		 shr	 eax, 1
  00152	83 e0 01	 and	 eax, 1
  00155	85 c0		 test	 eax, eax
  00157	74 55		 je	 SHORT $LN8@s370_shift
  00159	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00161	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00168	b9 08 00 00 00	 mov	 ecx, 8
  0016d	48 6b c9 01	 imul	 rcx, rcx, 1
  00171	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00178	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0017d	85 c0		 test	 eax, eax
  0017f	75 2d		 jne	 SHORT $LN8@s370_shift
$LN9@s370_shift:
  00181	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00189	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00193	ba 07 00 00 00	 mov	 edx, 7
  00198	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_shift:

; 5146 :     DFPREGPAIR2_CHECK(r1, r3, regs);

  001ae	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  001b2	83 e0 02	 and	 eax, 2
  001b5	85 c0		 test	 eax, eax
  001b7	75 0b		 jne	 SHORT $LN11@s370_shift
  001b9	8b 44 24 30	 mov	 eax, DWORD PTR r3$[rsp]
  001bd	83 e0 02	 and	 eax, 2
  001c0	85 c0		 test	 eax, eax
  001c2	74 1b		 je	 SHORT $LN10@s370_shift
$LN11@s370_shift:
  001c4	ba 06 00 00 00	 mov	 edx, 6
  001c9	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d1	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN10@s370_shift:

; 5147 : 
; 5148 :     /* Isolate rightmost 6 bits of second operand address */
; 5149 :     n = effective_addr2 & 0x3F;

  001df	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001e3	83 e0 3f	 and	 eax, 63			; 0000003fH
  001e6	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax

; 5150 : 
; 5151 :     /* Initialise the context for extended DFP */
; 5152 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  001ea	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001ef	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001f7	e8 00 00 00 00	 call	 decContextDefault

; 5153 : 
; 5154 :     /* Load DFP extended number from FP register r3 */
; 5155 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  001fc	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00204	48 8d 54 24 50	 lea	 rdx, QWORD PTR x3$[rsp]
  00209	8b 4c 24 30	 mov	 ecx, DWORD PTR r3$[rsp]
  0020d	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 5156 : 
; 5157 :     /* Convert to internal decimal number format */
; 5158 :     decimal128ToNumber(&x3, &d3);

  00212	48 8d 54 24 60	 lea	 rdx, QWORD PTR d3$[rsp]
  00217	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x3$[rsp]
  0021c	e8 00 00 00 00	 call	 decimal128ToNumber

; 5159 : 
; 5160 :     /* For NaN and Inf use coefficient continuation digits only */
; 5161 :     if (decNumberIsNaN(&d3) || decNumberIsInfinite(&d3))

  00221	0f b6 44 24 68	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00226	83 e0 30	 and	 eax, 48			; 00000030H
  00229	85 c0		 test	 eax, eax
  0022b	75 0c		 jne	 SHORT $LN14@s370_shift
  0022d	0f b6 44 24 68	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00232	83 e0 40	 and	 eax, 64			; 00000040H
  00235	85 c0		 test	 eax, eax
  00237	74 1e		 je	 SHORT $LN12@s370_shift
$LN14@s370_shift:

; 5162 :     {
; 5163 :         dfp128_clear_cf_and_bxcf(&x3);

  00239	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x3$[rsp]
  0023e	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 5164 :         decimal128ToNumber(&x3, &d1);

  00243	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0024b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x3$[rsp]
  00250	e8 00 00 00 00	 call	 decimal128ToNumber

; 5165 :     }

  00255	eb 12		 jmp	 SHORT $LN13@s370_shift
$LN12@s370_shift:

; 5166 :     else
; 5167 :     {
; 5168 :         decNumberCopy(&d1, &d3);

  00257	48 8d 54 24 60	 lea	 rdx, QWORD PTR d3$[rsp]
  0025c	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  00264	e8 00 00 00 00	 call	 decNumberCopy
$LN13@s370_shift:

; 5169 :     }
; 5170 : 
; 5171 :     /* Shift coefficient left n digit positions */
; 5172 :     dfp_shift_coeff(&set, &d1, n);

  00269	44 8b 44 24 38	 mov	 r8d, DWORD PTR n$[rsp]
  0026e	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00276	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  0027e	e8 00 00 00 00	 call	 dfp_shift_coeff

; 5173 : 
; 5174 :     /* Convert result to DFP extended format */
; 5175 :     decimal128FromNumber(&x1, &d1, &set);

  00283	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  0028b	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00293	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00298	e8 00 00 00 00	 call	 decimal128FromNumber

; 5176 : 
; 5177 :     /* Restore Nan or Inf indicators in the result */
; 5178 :     if (decNumberIsQNaN(&d3))

  0029d	0f b6 44 24 68	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002a2	83 e0 20	 and	 eax, 32			; 00000020H
  002a5	85 c0		 test	 eax, eax
  002a7	74 11		 je	 SHORT $LN15@s370_shift

; 5179 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  002a9	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  002ae	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002b3	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf
  002b8	eb 38		 jmp	 SHORT $LN16@s370_shift
$LN15@s370_shift:

; 5180 :     else if (decNumberIsSNaN(&d3))

  002ba	0f b6 44 24 68	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002bf	83 e0 10	 and	 eax, 16
  002c2	85 c0		 test	 eax, eax
  002c4	74 11		 je	 SHORT $LN17@s370_shift

; 5181 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  002c6	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  002cb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002d0	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf
  002d5	eb 1b		 jmp	 SHORT $LN18@s370_shift
$LN17@s370_shift:

; 5182 :     else if (decNumberIsInfinite(&d3))

  002d7	0f b6 44 24 68	 movzx	 eax, BYTE PTR d3$[rsp+8]
  002dc	83 e0 40	 and	 eax, 64			; 00000040H
  002df	85 c0		 test	 eax, eax
  002e1	74 0f		 je	 SHORT $LN19@s370_shift

; 5183 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  002e3	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  002e8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002ed	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf
$LN19@s370_shift:
$LN18@s370_shift:
$LN16@s370_shift:

; 5184 : 
; 5185 :     /* Load result into FP register r1 */
; 5186 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  002f2	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002fa	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  002ff	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00303	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 5187 : 
; 5188 : } /* end DEF_INST(shift_coefficient_left_dfp_ext) */

  00308	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00310	48 33 cc	 xor	 rcx, rsp
  00313	e8 00 00 00 00	 call	 __security_check_cookie
  00318	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0031f	c3		 ret	 0
s370_shift_coefficient_left_dfp_ext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
signif$ = 40
m4$ = 44
r2$ = 48
r3$ = 52
r1$ = 56
x3$ = 64
x1$ = 72
d3$ = 80
set$ = 120
d1$ = 152
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
s370_reround_dfp_long_reg PROC

; 5076 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5077 : int             signif;                 /* Requested significance    */
; 5078 : int             r1, r2, r3, m4;         /* Values of R and M fields  */
; 5079 : decimal64       x1, x3;                 /* Long DFP values           */
; 5080 : decNumber       d1, d3;                 /* Working decimal numbers   */
; 5081 : decContext      set;                    /* Working context           */
; 5082 : BYTE            dxc;                    /* Data exception code       */
; 5083 : 
; 5084 :     RRF_RM(inst, regs, r1, r2, r3, m4);

  00023	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 34	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_rerou:
  00070	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_rerou
  00093	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_rerou:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_rerou

; 5085 : 
; 5086 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5087 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_rerou
  000c9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_rerou
  000e0	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_rerou
$LN7@s370_rerou:
  00108	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_rerou:

; 5088 : 
; 5089 :     /* Initialise the context for long DFP */
; 5090 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00135	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0013a	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  0013f	e8 00 00 00 00	 call	 decContextDefault

; 5091 :     ARCH_DEP(dfp_rounding_mode)(&set, m4, regs);

  00144	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0014c	8b 54 24 2c	 mov	 edx, DWORD PTR m4$[rsp]
  00150	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  00155	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 5092 : 
; 5093 :     /* Load significance from bits 58-63 of general register r2 */
; 5094 :     signif = regs->GR_L(r2) & 0x3F;

  0015a	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  0015f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00167	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0016e	83 e0 3f	 and	 eax, 63			; 0000003fH
  00171	89 44 24 28	 mov	 DWORD PTR signif$[rsp], eax

; 5095 : 
; 5096 :     /* Reround FP register r3 */
; 5097 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  00175	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017d	48 8d 54 24 40	 lea	 rdx, QWORD PTR x3$[rsp]
  00182	8b 4c 24 34	 mov	 ecx, DWORD PTR r3$[rsp]
  00186	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 5098 :     decimal64ToNumber(&x3, &d3);

  0018b	48 8d 54 24 50	 lea	 rdx, QWORD PTR d3$[rsp]
  00190	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00195	e8 00 00 00 00	 call	 decimal64ToNumber

; 5099 :     if (decNumberIsInfinite(&d3) || decNumberIsNaN(&d3)
; 5100 :         || decNumberIsZero(&d3)
; 5101 :         || signif == 0 || d3.digits <= signif)

  0019a	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  0019f	83 e0 40	 and	 eax, 64			; 00000040H
  001a2	85 c0		 test	 eax, eax
  001a4	75 42		 jne	 SHORT $LN10@s370_rerou
  001a6	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  001ab	83 e0 30	 and	 eax, 48			; 00000030H
  001ae	85 c0		 test	 eax, eax
  001b0	75 36		 jne	 SHORT $LN10@s370_rerou
  001b2	b8 02 00 00 00	 mov	 eax, 2
  001b7	48 6b c0 00	 imul	 rax, rax, 0
  001bb	0f b7 44 04 5a	 movzx	 eax, WORD PTR d3$[rsp+rax+10]
  001c0	85 c0		 test	 eax, eax
  001c2	75 13		 jne	 SHORT $LN11@s370_rerou
  001c4	83 7c 24 50 01	 cmp	 DWORD PTR d3$[rsp], 1
  001c9	75 0c		 jne	 SHORT $LN11@s370_rerou
  001cb	0f b6 44 24 58	 movzx	 eax, BYTE PTR d3$[rsp+8]
  001d0	83 e0 70	 and	 eax, 112		; 00000070H
  001d3	85 c0		 test	 eax, eax
  001d5	74 11		 je	 SHORT $LN10@s370_rerou
$LN11@s370_rerou:
  001d7	83 7c 24 28 00	 cmp	 DWORD PTR signif$[rsp], 0
  001dc	74 0a		 je	 SHORT $LN10@s370_rerou
  001de	8b 44 24 28	 mov	 eax, DWORD PTR signif$[rsp]
  001e2	39 44 24 50	 cmp	 DWORD PTR d3$[rsp], eax
  001e6	7f 14		 jg	 SHORT $LN8@s370_rerou
$LN10@s370_rerou:

; 5102 :     {
; 5103 :         decNumberCopy(&d1, &d3);

  001e8	48 8d 54 24 50	 lea	 rdx, QWORD PTR d3$[rsp]
  001ed	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  001f5	e8 00 00 00 00	 call	 decNumberCopy

; 5104 :     }

  001fa	eb 1f		 jmp	 SHORT $LN9@s370_rerou
$LN8@s370_rerou:

; 5105 :     else
; 5106 :     {
; 5107 :         set.digits = signif;

  001fc	8b 44 24 28	 mov	 eax, DWORD PTR signif$[rsp]
  00200	89 44 24 78	 mov	 DWORD PTR set$[rsp], eax

; 5108 :         decNumberPlus(&d1, &d3, &set);

  00204	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  00209	48 8d 54 24 50	 lea	 rdx, QWORD PTR d3$[rsp]
  0020e	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  00216	e8 00 00 00 00	 call	 decNumberPlus
$LN9@s370_rerou:

; 5109 :     }
; 5110 :     decimal64FromNumber(&x1, &d1, &set);

  0021b	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  00220	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00228	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  0022d	e8 00 00 00 00	 call	 decimal64FromNumber

; 5111 : 
; 5112 :     /* Check for exception condition */
; 5113 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00232	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0023a	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  0023f	e8 00 00 00 00	 call	 s370_dfp_status_check
  00244	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 5114 : 
; 5115 :     /* Load result into FP register r1 */
; 5116 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  00248	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00250	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  00255	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  00259	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 5117 : 
; 5118 :     /* Raise data exception if error occurred */
; 5119 :     if (dxc != 0)

  0025e	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00263	85 c0		 test	 eax, eax
  00265	74 25		 je	 SHORT $LN12@s370_rerou

; 5120 :     {
; 5121 :         regs->dxc = dxc;

  00267	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0026c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00274	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 5122 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0027a	ba 07 00 00 00	 mov	 edx, 7
  0027f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00287	e8 00 00 00 00	 call	 s370_program_interrupt
$LN12@s370_rerou:

; 5123 :     }
; 5124 : 
; 5125 : } /* end DEF_INST(reround_dfp_long_reg) */

  0028c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00294	48 33 cc	 xor	 rcx, rsp
  00297	e8 00 00 00 00	 call	 __security_check_cookie
  0029c	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  002a3	c3		 ret	 0
s370_reround_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
signif$ = 40
r3$ = 44
r1$ = 48
m4$ = 52
r2$ = 56
d3$ = 64
set$ = 104
x3$ = 136
x1$ = 152
d1$ = 168
__$ArrayPad$ = 208
inst$ = 240
regs$ = 248
s370_reround_dfp_ext_reg PROC

; 5019 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5020 : int             signif;                 /* Requested significance    */
; 5021 : int             r1, r2, r3, m4;         /* Values of R and M fields  */
; 5022 : decimal128      x1, x3;                 /* Extended DFP values       */
; 5023 : decNumber       d1, d3;                 /* Working decimal numbers   */
; 5024 : decContext      set;                    /* Working context           */
; 5025 : BYTE            dxc;                    /* Data exception code       */
; 5026 : 
; 5027 :     RRF_RM(inst, regs, r1, r2, r3, m4);

  00023	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_rerou:
  00070	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_rerou
  00093	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_rerou:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_rerou

; 5028 : 
; 5029 :     TXF_FLOAT_INSTR_CHECK( regs );
; 5030 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_rerou
  000c9	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_rerou
  000e0	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_rerou
$LN7@s370_rerou:
  00108	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_rerou:

; 5031 :     DFPREGPAIR2_CHECK(r1, r3, regs);

  00135	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00139	83 e0 02	 and	 eax, 2
  0013c	85 c0		 test	 eax, eax
  0013e	75 0b		 jne	 SHORT $LN9@s370_rerou
  00140	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  00144	83 e0 02	 and	 eax, 2
  00147	85 c0		 test	 eax, eax
  00149	74 1b		 je	 SHORT $LN8@s370_rerou
$LN9@s370_rerou:
  0014b	ba 06 00 00 00	 mov	 edx, 6
  00150	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00160	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_rerou:

; 5032 : 
; 5033 :     /* Initialise the context for extended DFP */
; 5034 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00166	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0016b	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00170	e8 00 00 00 00	 call	 decContextDefault

; 5035 :     ARCH_DEP(dfp_rounding_mode)(&set, m4, regs);

  00175	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017d	8b 54 24 34	 mov	 edx, DWORD PTR m4$[rsp]
  00181	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00186	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 5036 : 
; 5037 :     /* Load significance from bits 58-63 of general register r2 */
; 5038 :     signif = regs->GR_L(r2) & 0x3F;

  0018b	48 63 44 24 38	 movsxd	 rax, DWORD PTR r2$[rsp]
  00190	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00198	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0019f	83 e0 3f	 and	 eax, 63			; 0000003fH
  001a2	89 44 24 28	 mov	 DWORD PTR signif$[rsp], eax

; 5039 : 
; 5040 :     /* Reround FP register r3 */
; 5041 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  001a6	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001ae	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR x3$[rsp]
  001b6	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  001ba	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 5042 :     decimal128ToNumber(&x3, &d3);

  001bf	48 8d 54 24 40	 lea	 rdx, QWORD PTR d3$[rsp]
  001c4	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR x3$[rsp]
  001cc	e8 00 00 00 00	 call	 decimal128ToNumber

; 5043 :     if (decNumberIsInfinite(&d3) || decNumberIsNaN(&d3)
; 5044 :         || decNumberIsZero(&d3)
; 5045 :         || signif == 0 || d3.digits <= signif)

  001d1	0f b6 44 24 48	 movzx	 eax, BYTE PTR d3$[rsp+8]
  001d6	83 e0 40	 and	 eax, 64			; 00000040H
  001d9	85 c0		 test	 eax, eax
  001db	75 42		 jne	 SHORT $LN12@s370_rerou
  001dd	0f b6 44 24 48	 movzx	 eax, BYTE PTR d3$[rsp+8]
  001e2	83 e0 30	 and	 eax, 48			; 00000030H
  001e5	85 c0		 test	 eax, eax
  001e7	75 36		 jne	 SHORT $LN12@s370_rerou
  001e9	b8 02 00 00 00	 mov	 eax, 2
  001ee	48 6b c0 00	 imul	 rax, rax, 0
  001f2	0f b7 44 04 4a	 movzx	 eax, WORD PTR d3$[rsp+rax+10]
  001f7	85 c0		 test	 eax, eax
  001f9	75 13		 jne	 SHORT $LN13@s370_rerou
  001fb	83 7c 24 40 01	 cmp	 DWORD PTR d3$[rsp], 1
  00200	75 0c		 jne	 SHORT $LN13@s370_rerou
  00202	0f b6 44 24 48	 movzx	 eax, BYTE PTR d3$[rsp+8]
  00207	83 e0 70	 and	 eax, 112		; 00000070H
  0020a	85 c0		 test	 eax, eax
  0020c	74 11		 je	 SHORT $LN12@s370_rerou
$LN13@s370_rerou:
  0020e	83 7c 24 28 00	 cmp	 DWORD PTR signif$[rsp], 0
  00213	74 0a		 je	 SHORT $LN12@s370_rerou
  00215	8b 44 24 28	 mov	 eax, DWORD PTR signif$[rsp]
  00219	39 44 24 40	 cmp	 DWORD PTR d3$[rsp], eax
  0021d	7f 14		 jg	 SHORT $LN10@s370_rerou
$LN12@s370_rerou:

; 5046 :     {
; 5047 :         decNumberCopy(&d1, &d3);

  0021f	48 8d 54 24 40	 lea	 rdx, QWORD PTR d3$[rsp]
  00224	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  0022c	e8 00 00 00 00	 call	 decNumberCopy

; 5048 :     }

  00231	eb 1f		 jmp	 SHORT $LN11@s370_rerou
$LN10@s370_rerou:

; 5049 :     else
; 5050 :     {
; 5051 :         set.digits = signif;

  00233	8b 44 24 28	 mov	 eax, DWORD PTR signif$[rsp]
  00237	89 44 24 68	 mov	 DWORD PTR set$[rsp], eax

; 5052 :         decNumberPlus(&d1, &d3, &set);

  0023b	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  00240	48 8d 54 24 40	 lea	 rdx, QWORD PTR d3$[rsp]
  00245	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  0024d	e8 00 00 00 00	 call	 decNumberPlus
$LN11@s370_rerou:

; 5053 :     }
; 5054 :     decimal128FromNumber(&x1, &d1, &set);

  00252	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  00257	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0025f	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR x1$[rsp]
  00267	e8 00 00 00 00	 call	 decimal128FromNumber

; 5055 : 
; 5056 :     /* Check for exception condition */
; 5057 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0026c	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00274	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00279	e8 00 00 00 00	 call	 s370_dfp_status_check
  0027e	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 5058 : 
; 5059 :     /* Load result into FP register r1 */
; 5060 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  00282	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0028a	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR x1$[rsp]
  00292	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  00296	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 5061 : 
; 5062 :     /* Raise data exception if error occurred */
; 5063 :     if (dxc != 0)

  0029b	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002a0	85 c0		 test	 eax, eax
  002a2	74 25		 je	 SHORT $LN14@s370_rerou

; 5064 :     {
; 5065 :         regs->dxc = dxc;

  002a4	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002a9	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b1	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 5066 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002b7	ba 07 00 00 00	 mov	 edx, 7
  002bc	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c4	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_rerou:

; 5067 :     }
; 5068 : 
; 5069 : } /* end DEF_INST(reround_dfp_ext_reg) */

  002c9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002d1	48 33 cc	 xor	 rcx, rsp
  002d4	e8 00 00 00 00	 call	 __security_check_cookie
  002d9	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  002e0	c3		 ret	 0
s370_reround_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
m4$ = 40
r2$ = 44
r3$ = 48
r1$ = 52
x2$ = 56
x3$ = 64
x1$ = 72
set$ = 80
d3$ = 112
d2$ = 152
d1$ = 192
__$ArrayPad$ = 232
inst$ = 256
regs$ = 264
s370_quantize_dfp_long_reg PROC

; 4975 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4976 : int             r1, r2, r3, m4;         /* Values of R and M fields  */
; 4977 : decimal64       x1, x2, x3;             /* Long DFP values           */
; 4978 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 4979 : decContext      set;                    /* Working context           */
; 4980 : BYTE            dxc;                    /* Data exception code       */
; 4981 : 
; 4982 :     RRF_RM(inst, regs, r1, r2, r3, m4);

  00023	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 28	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_quant:
  00070	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_quant
  00093	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_quant:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_quant

; 4983 : 
; 4984 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4985 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_quant
  000c9	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_quant
  000e0	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_quant
$LN7@s370_quant:
  00108	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_quant:

; 4986 : 
; 4987 :     /* Initialise the context for long DFP */
; 4988 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00135	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0013a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0013f	e8 00 00 00 00	 call	 decContextDefault

; 4989 :     ARCH_DEP(dfp_rounding_mode)(&set, m4, regs);

  00144	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0014c	8b 54 24 28	 mov	 edx, DWORD PTR m4$[rsp]
  00150	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00155	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 4990 : 
; 4991 :     /* Quantize FP register r3 using FP register r2 */
; 4992 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  0015a	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00162	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  00167	8b 4c 24 2c	 mov	 ecx, DWORD PTR r2$[rsp]
  0016b	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 4993 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  00170	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00178	48 8d 54 24 40	 lea	 rdx, QWORD PTR x3$[rsp]
  0017d	8b 4c 24 30	 mov	 ecx, DWORD PTR r3$[rsp]
  00181	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 4994 :     decimal64ToNumber(&x2, &d2);

  00186	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0018e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00193	e8 00 00 00 00	 call	 decimal64ToNumber

; 4995 :     decimal64ToNumber(&x3, &d3);

  00198	48 8d 54 24 70	 lea	 rdx, QWORD PTR d3$[rsp]
  0019d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  001a2	e8 00 00 00 00	 call	 decimal64ToNumber

; 4996 :     decNumberQuantize(&d1, &d2, &d3, &set);

  001a7	4c 8d 4c 24 50	 lea	 r9, QWORD PTR set$[rsp]
  001ac	4c 8d 44 24 70	 lea	 r8, QWORD PTR d3$[rsp]
  001b1	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001b9	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  001c1	e8 00 00 00 00	 call	 decNumberQuantize

; 4997 :     decimal64FromNumber(&x1, &d1, &set);

  001c6	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  001cb	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  001d3	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  001d8	e8 00 00 00 00	 call	 decimal64FromNumber

; 4998 : 
; 4999 :     /* Check for exception condition */
; 5000 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  001dd	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001e5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001ea	e8 00 00 00 00	 call	 s370_dfp_status_check
  001ef	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 5001 : 
; 5002 :     /* Load result into FP register r1 */
; 5003 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  001f3	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001fb	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  00200	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00204	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 5004 : 
; 5005 :     /* Raise data exception if error occurred */
; 5006 :     if (dxc != 0)

  00209	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0020e	85 c0		 test	 eax, eax
  00210	74 25		 je	 SHORT $LN8@s370_quant

; 5007 :     {
; 5008 :         regs->dxc = dxc;

  00212	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00217	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021f	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 5009 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00225	ba 07 00 00 00	 mov	 edx, 7
  0022a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00232	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_quant:

; 5010 :     }
; 5011 : 
; 5012 : } /* end DEF_INST(quantize_dfp_long_reg) */

  00237	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0023f	48 33 cc	 xor	 rcx, rsp
  00242	e8 00 00 00 00	 call	 __security_check_cookie
  00247	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  0024e	c3		 ret	 0
s370_quantize_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
m4$ = 52
set$ = 56
x2$ = 88
x3$ = 104
x1$ = 120
d3$ = 136
d2$ = 176
d1$ = 216
__$ArrayPad$ = 256
inst$ = 288
regs$ = 296
s370_quantize_dfp_ext_reg PROC

; 4930 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4931 : int             r1, r2, r3, m4;         /* Values of R and M fields  */
; 4932 : decimal128      x1, x2, x3;             /* Extended DFP values       */
; 4933 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 4934 : decContext      set;                    /* Working context           */
; 4935 : BYTE            dxc;                    /* Data exception code       */
; 4936 : 
; 4937 :     RRF_RM(inst, regs, r1, r2, r3, m4);

  00023	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_quant:
  00070	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_quant
  00093	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_quant:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_quant

; 4938 : 
; 4939 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4940 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_quant
  000c9	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_quant
  000e0	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_quant
$LN7@s370_quant:
  00108	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_quant:

; 4941 :     DFPREGPAIR3_CHECK(r1, r2, r3, regs);

  00135	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  00139	83 e0 02	 and	 eax, 2
  0013c	85 c0		 test	 eax, eax
  0013e	75 16		 jne	 SHORT $LN9@s370_quant
  00140	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00144	83 e0 02	 and	 eax, 2
  00147	85 c0		 test	 eax, eax
  00149	75 0b		 jne	 SHORT $LN9@s370_quant
  0014b	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  0014f	83 e0 02	 and	 eax, 2
  00152	85 c0		 test	 eax, eax
  00154	74 1b		 je	 SHORT $LN8@s370_quant
$LN9@s370_quant:
  00156	ba 06 00 00 00	 mov	 edx, 6
  0015b	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00163	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_quant:

; 4942 : 
; 4943 :     /* Initialise the context for extended DFP */
; 4944 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00171	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00176	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  0017b	e8 00 00 00 00	 call	 decContextDefault

; 4945 :     ARCH_DEP(dfp_rounding_mode)(&set, m4, regs);

  00180	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00188	8b 54 24 34	 mov	 edx, DWORD PTR m4$[rsp]
  0018c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  00191	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 4946 : 
; 4947 :     /* Quantize FP register r3 using FP register r2 */
; 4948 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00196	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0019e	48 8d 54 24 58	 lea	 rdx, QWORD PTR x2$[rsp]
  001a3	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  001a7	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 4949 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  001ac	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001b4	48 8d 54 24 68	 lea	 rdx, QWORD PTR x3$[rsp]
  001b9	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  001bd	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 4950 :     decimal128ToNumber(&x2, &d2);

  001c2	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001ca	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x2$[rsp]
  001cf	e8 00 00 00 00	 call	 decimal128ToNumber

; 4951 :     decimal128ToNumber(&x3, &d3);

  001d4	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  001dc	48 8d 4c 24 68	 lea	 rcx, QWORD PTR x3$[rsp]
  001e1	e8 00 00 00 00	 call	 decimal128ToNumber

; 4952 :     decNumberQuantize(&d1, &d2, &d3, &set);

  001e6	4c 8d 4c 24 38	 lea	 r9, QWORD PTR set$[rsp]
  001eb	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  001f3	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001fb	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  00203	e8 00 00 00 00	 call	 decNumberQuantize

; 4953 :     decimal128FromNumber(&x1, &d1, &set);

  00208	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  0020d	48 8d 94 24 d8
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00215	48 8d 4c 24 78	 lea	 rcx, QWORD PTR x1$[rsp]
  0021a	e8 00 00 00 00	 call	 decimal128FromNumber

; 4954 : 
; 4955 :     /* Check for exception condition */
; 4956 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0021f	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00227	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  0022c	e8 00 00 00 00	 call	 s370_dfp_status_check
  00231	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4957 : 
; 4958 :     /* Load result into FP register r1 */
; 4959 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  00235	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0023d	48 8d 54 24 78	 lea	 rdx, QWORD PTR x1$[rsp]
  00242	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  00246	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 4960 : 
; 4961 :     /* Raise data exception if error occurred */
; 4962 :     if (dxc != 0)

  0024b	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00250	85 c0		 test	 eax, eax
  00252	74 25		 je	 SHORT $LN10@s370_quant

; 4963 :     {
; 4964 :         regs->dxc = dxc;

  00254	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00259	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00261	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4965 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00267	ba 07 00 00 00	 mov	 edx, 7
  0026c	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00274	e8 00 00 00 00	 call	 s370_program_interrupt
$LN10@s370_quant:

; 4966 :     }
; 4967 : 
; 4968 : } /* end DEF_INST(quantize_dfp_ext_reg) */

  00279	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00281	48 33 cc	 xor	 rcx, rsp
  00284	e8 00 00 00 00	 call	 __security_check_cookie
  00289	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00290	c3		 ret	 0
s370_quantize_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
x2$ = 56
x3$ = 64
x1$ = 72
set$ = 80
d3$ = 112
d2$ = 152
d1$ = 192
__$ArrayPad$ = 232
inst$ = 256
regs$ = 264
s370_multiply_dfp_long_reg PROC

; 4886 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4887 : int             r1, r2, r3;             /* Values of R fields        */
; 4888 : decimal64       x1, x2, x3;             /* Long DFP values           */
; 4889 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 4890 : decContext      set;                    /* Working context           */
; 4891 : BYTE            dxc;                    /* Data exception code       */
; 4892 : 
; 4893 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_multi:
  00062	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_multi
  00085	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_multi:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_multi

; 4894 : 
; 4895 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4896 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_multi
  000bb	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_multi
  000d2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_multi
$LN7@s370_multi:
  000fa	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_multi:

; 4897 : 
; 4898 :     /* Initialise the context for long DFP */
; 4899 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00127	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0012c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00131	e8 00 00 00 00	 call	 decContextDefault

; 4900 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  00136	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0013e	33 d2		 xor	 edx, edx
  00140	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00145	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 4901 : 
; 4902 :     /* Multiply FP register r2 by FP register r3 */
; 4903 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  0014a	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00152	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  00157	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  0015b	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 4904 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  00160	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00168	48 8d 54 24 40	 lea	 rdx, QWORD PTR x3$[rsp]
  0016d	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  00171	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 4905 :     decimal64ToNumber(&x2, &d2);

  00176	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0017e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00183	e8 00 00 00 00	 call	 decimal64ToNumber

; 4906 :     decimal64ToNumber(&x3, &d3);

  00188	48 8d 54 24 70	 lea	 rdx, QWORD PTR d3$[rsp]
  0018d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00192	e8 00 00 00 00	 call	 decimal64ToNumber

; 4907 :     decNumberMultiply(&d1, &d2, &d3, &set);

  00197	4c 8d 4c 24 50	 lea	 r9, QWORD PTR set$[rsp]
  0019c	4c 8d 44 24 70	 lea	 r8, QWORD PTR d3$[rsp]
  001a1	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001a9	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  001b1	e8 00 00 00 00	 call	 decNumberMultiply

; 4908 :     decimal64FromNumber(&x1, &d1, &set);

  001b6	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  001bb	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  001c3	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  001c8	e8 00 00 00 00	 call	 decimal64FromNumber

; 4909 : 
; 4910 :     /* Check for exception condition */
; 4911 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  001cd	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001d5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001da	e8 00 00 00 00	 call	 s370_dfp_status_check
  001df	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4912 : 
; 4913 :     /* Load result into FP register r1 */
; 4914 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  001e3	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001eb	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  001f0	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  001f4	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 4915 : 
; 4916 :     /* Raise data exception if error occurred */
; 4917 :     if (dxc != 0)

  001f9	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  001fe	85 c0		 test	 eax, eax
  00200	74 25		 je	 SHORT $LN8@s370_multi

; 4918 :     {
; 4919 :         regs->dxc = dxc;

  00202	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00207	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4920 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00215	ba 07 00 00 00	 mov	 edx, 7
  0021a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00222	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_multi:

; 4921 :     }
; 4922 : 
; 4923 : } /* end DEF_INST(multiply_dfp_long_reg) */

  00227	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0022f	48 33 cc	 xor	 rcx, rsp
  00232	e8 00 00 00 00	 call	 __security_check_cookie
  00237	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  0023e	c3		 ret	 0
s370_multiply_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
set$ = 56
x2$ = 88
x3$ = 104
x1$ = 120
d3$ = 136
d2$ = 176
d1$ = 216
__$ArrayPad$ = 256
inst$ = 288
regs$ = 296
s370_multiply_dfp_ext_reg PROC

; 4841 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4842 : int             r1, r2, r3;             /* Values of R fields        */
; 4843 : decimal128      x1, x2, x3;             /* Extended DFP values       */
; 4844 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 4845 : decContext      set;                    /* Working context           */
; 4846 : BYTE            dxc;                    /* Data exception code       */
; 4847 : 
; 4848 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_multi:
  00062	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_multi
  00085	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_multi:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_multi

; 4849 : 
; 4850 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4851 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_multi
  000bb	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_multi
  000d2	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_multi
$LN7@s370_multi:
  000fa	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_multi:

; 4852 :     DFPREGPAIR3_CHECK(r1, r2, r3, regs);

  00127	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0012b	83 e0 02	 and	 eax, 2
  0012e	85 c0		 test	 eax, eax
  00130	75 16		 jne	 SHORT $LN9@s370_multi
  00132	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00136	83 e0 02	 and	 eax, 2
  00139	85 c0		 test	 eax, eax
  0013b	75 0b		 jne	 SHORT $LN9@s370_multi
  0013d	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  00141	83 e0 02	 and	 eax, 2
  00144	85 c0		 test	 eax, eax
  00146	74 1b		 je	 SHORT $LN8@s370_multi
$LN9@s370_multi:
  00148	ba 06 00 00 00	 mov	 edx, 6
  0014d	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00155	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_multi:

; 4853 : 
; 4854 :     /* Initialise the context for extended DFP */
; 4855 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00163	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00168	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  0016d	e8 00 00 00 00	 call	 decContextDefault

; 4856 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  00172	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017a	33 d2		 xor	 edx, edx
  0017c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  00181	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 4857 : 
; 4858 :     /* Multiply FP register r2 by FP register r3 */
; 4859 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00186	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0018e	48 8d 54 24 58	 lea	 rdx, QWORD PTR x2$[rsp]
  00193	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00197	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 4860 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  0019c	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001a4	48 8d 54 24 68	 lea	 rdx, QWORD PTR x3$[rsp]
  001a9	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  001ad	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 4861 :     decimal128ToNumber(&x2, &d2);

  001b2	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001ba	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x2$[rsp]
  001bf	e8 00 00 00 00	 call	 decimal128ToNumber

; 4862 :     decimal128ToNumber(&x3, &d3);

  001c4	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  001cc	48 8d 4c 24 68	 lea	 rcx, QWORD PTR x3$[rsp]
  001d1	e8 00 00 00 00	 call	 decimal128ToNumber

; 4863 :     decNumberMultiply(&d1, &d2, &d3, &set);

  001d6	4c 8d 4c 24 38	 lea	 r9, QWORD PTR set$[rsp]
  001db	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  001e3	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001eb	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  001f3	e8 00 00 00 00	 call	 decNumberMultiply

; 4864 :     decimal128FromNumber(&x1, &d1, &set);

  001f8	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  001fd	48 8d 94 24 d8
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00205	48 8d 4c 24 78	 lea	 rcx, QWORD PTR x1$[rsp]
  0020a	e8 00 00 00 00	 call	 decimal128FromNumber

; 4865 : 
; 4866 :     /* Check for exception condition */
; 4867 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0020f	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00217	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  0021c	e8 00 00 00 00	 call	 s370_dfp_status_check
  00221	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4868 : 
; 4869 :     /* Load result into FP register r1 */
; 4870 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  00225	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0022d	48 8d 54 24 78	 lea	 rdx, QWORD PTR x1$[rsp]
  00232	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  00236	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 4871 : 
; 4872 :     /* Raise data exception if error occurred */
; 4873 :     if (dxc != 0)

  0023b	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00240	85 c0		 test	 eax, eax
  00242	74 25		 je	 SHORT $LN10@s370_multi

; 4874 :     {
; 4875 :         regs->dxc = dxc;

  00244	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00249	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4876 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00257	ba 07 00 00 00	 mov	 edx, 7
  0025c	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00264	e8 00 00 00 00	 call	 s370_program_interrupt
$LN10@s370_multi:

; 4877 :     }
; 4878 : 
; 4879 : } /* end DEF_INST(multiply_dfp_ext_reg) */

  00269	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00271	48 33 cc	 xor	 rcx, rsp
  00274	e8 00 00 00 00	 call	 __security_check_cookie
  00279	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00280	c3		 ret	 0
s370_multiply_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
x1$ = 36
temp$1 = 40
scale$ = 44
m4$ = 48
m3$ = 52
r2$ = 56
r1$ = 60
x2$ = 64
set$ = 72
d2$ = 104
d1$ = 144
pwork$ = 184
__$ArrayPad$ = 200
inst$ = 224
regs$ = 232
s370_load_rounded_dfp_long_to_short_reg PROC

; 4755 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4756 : int             r1, r2, m3, m4;         /* Values of R and M fields  */
; 4757 : decimal32       x1;                     /* Short DFP value           */
; 4758 : decimal64       x2;                     /* Long DFP value            */
; 4759 : decNumber       d1, d2;                 /* Working decimal numbers   */
; 4760 : decContext      set;                    /* Working context           */
; 4761 : int32_t         scale;                  /* Scaling factor            */
; 4762 : BYTE            pwork[9];               /* 17-digit packed work area */
; 4763 : BYTE            dxc;                    /* Data exception code       */
; 4764 : 
; 4765 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 30	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 34	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_load_:
  00070	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_load_
  00093	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_load_

; 4766 : 
; 4767 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4768 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_load_
  000c9	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_load_
  000e0	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  00108	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 4769 : 
; 4770 :     /* Initialise the context for long DFP */
; 4771 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00135	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0013a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  0013f	e8 00 00 00 00	 call	 decContextDefault

; 4772 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00144	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0014c	8b 54 24 34	 mov	 edx, DWORD PTR m3$[rsp]
  00150	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00155	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 4773 : 
; 4774 :     /* Load DFP long number from FP register r2 */
; 4775 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  0015a	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00162	48 8d 54 24 40	 lea	 rdx, QWORD PTR x2$[rsp]
  00167	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  0016b	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 4776 :     decimal64ToNumber(&x2, &d2);

  00170	48 8d 54 24 68	 lea	 rdx, QWORD PTR d2$[rsp]
  00175	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x2$[rsp]
  0017a	e8 00 00 00 00	 call	 decimal64ToNumber

; 4777 : 
; 4778 :     /* Convert number to DFP short format */
; 4779 :     if ((decNumberIsInfinite(&d2) && (m4 & 0x08))
; 4780 :          || decNumberIsNaN(&d2))

  0017f	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00184	83 e0 40	 and	 eax, 64			; 00000040H
  00187	85 c0		 test	 eax, eax
  00189	74 0b		 je	 SHORT $LN11@s370_load_
  0018b	8b 44 24 30	 mov	 eax, DWORD PTR m4$[rsp]
  0018f	83 e0 08	 and	 eax, 8
  00192	85 c0		 test	 eax, eax
  00194	75 10		 jne	 SHORT $LN10@s370_load_
$LN11@s370_load_:
  00196	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0019b	83 e0 30	 and	 eax, 48			; 00000030H
  0019e	85 c0		 test	 eax, eax
  001a0	0f 84 fc 00 00
	00		 je	 $LN8@s370_load_
$LN10@s370_load_:

; 4781 :     {
; 4782 :         /* For Inf with mask bit 0 set, or for QNan or SNan,
; 4783 :            propagate the low 6 digits */
; 4784 :         dfp64_clear_cf_and_bxcf(&x2);

  001a6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x2$[rsp]
  001ab	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 4785 :         decimal64ToNumber(&x2, &d1);

  001b0	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  001b8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x2$[rsp]
  001bd	e8 00 00 00 00	 call	 decimal64ToNumber

; 4786 :         decPackedFromNumber(pwork, sizeof(pwork), &scale, &d1);

  001c2	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR d1$[rsp]
  001ca	4c 8d 44 24 2c	 lea	 r8, QWORD PTR scale$[rsp]
  001cf	ba 09 00 00 00	 mov	 edx, 9
  001d4	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  001dc	e8 00 00 00 00	 call	 decPackedFromNumber

; 4787 :         scale = 0;

  001e1	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR scale$[rsp], 0

; 4788 :         decPackedToNumber(pwork+sizeof(pwork)-4, 4, &scale, &d1);

  001e9	48 8d 84 24 bd
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+5]
  001f1	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR d1$[rsp]
  001f9	4c 8d 44 24 2c	 lea	 r8, QWORD PTR scale$[rsp]
  001fe	ba 04 00 00 00	 mov	 edx, 4
  00203	48 8b c8	 mov	 rcx, rax
  00206	e8 00 00 00 00	 call	 decPackedToNumber

; 4789 :         decimal32FromNumber(&x1, &d1, &set);

  0020b	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  00210	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00218	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x1$[rsp]
  0021d	e8 00 00 00 00	 call	 decimal32FromNumber

; 4790 :         if (decNumberIsInfinite(&d2))

  00222	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00227	83 e0 40	 and	 eax, 64			; 00000040H
  0022a	85 c0		 test	 eax, eax
  0022c	74 11		 je	 SHORT $LN12@s370_load_

; 4791 :         {
; 4792 :             dfp32_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  0022e	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00233	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x1$[rsp]
  00238	e8 00 00 00 00	 call	 dfp32_set_cf_and_bxcf

; 4793 :         }

  0023d	eb 61		 jmp	 SHORT $LN13@s370_load_
$LN12@s370_load_:

; 4794 :         else if (decNumberIsQNaN(&d2))

  0023f	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00244	83 e0 20	 and	 eax, 32			; 00000020H
  00247	85 c0		 test	 eax, eax
  00249	74 11		 je	 SHORT $LN14@s370_load_

; 4795 :         {
; 4796 :             dfp32_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  0024b	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  00250	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x1$[rsp]
  00255	e8 00 00 00 00	 call	 dfp32_set_cf_and_bxcf

; 4797 :         }

  0025a	eb 44		 jmp	 SHORT $LN15@s370_load_
$LN14@s370_load_:

; 4798 :         else /* it is an SNaN */
; 4799 :         {
; 4800 :             /* For SNaN with mask bit 0 off, convert to a QNaN
; 4801 :                and raise signaling condition */
; 4802 :             if (decNumberIsSNaN(&d2) && (m4 & 0x08) == 0)

  0025c	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00261	83 e0 10	 and	 eax, 16
  00264	85 c0		 test	 eax, eax
  00266	74 29		 je	 SHORT $LN16@s370_load_
  00268	8b 44 24 30	 mov	 eax, DWORD PTR m4$[rsp]
  0026c	83 e0 08	 and	 eax, 8
  0026f	85 c0		 test	 eax, eax
  00271	75 1e		 jne	 SHORT $LN16@s370_load_

; 4803 :             {
; 4804 :                 dfp32_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  00273	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  00278	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x1$[rsp]
  0027d	e8 00 00 00 00	 call	 dfp32_set_cf_and_bxcf

; 4805 :                 set.status |= DEC_IEEE_854_Invalid_operation;

  00282	8b 44 24 5c	 mov	 eax, DWORD PTR set$[rsp+20]
  00286	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  0028b	89 44 24 5c	 mov	 DWORD PTR set$[rsp+20], eax

; 4806 :             }

  0028f	eb 0f		 jmp	 SHORT $LN17@s370_load_
$LN16@s370_load_:

; 4807 :             else
; 4808 :             {
; 4809 :                 dfp32_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  00291	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  00296	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x1$[rsp]
  0029b	e8 00 00 00 00	 call	 dfp32_set_cf_and_bxcf
$LN17@s370_load_:
$LN15@s370_load_:
$LN13@s370_load_:

; 4810 :             }
; 4811 :         }
; 4812 :     }

  002a0	eb 29		 jmp	 SHORT $LN9@s370_load_
$LN8@s370_load_:

; 4813 :     else
; 4814 :     {
; 4815 :         /* For finite number, load value rounded to short DFP format,
; 4816 :            or for Inf with mask bit 0 not set, load default infinity */
; 4817 :         decNumberCopy(&d1, &d2);

  002a2	48 8d 54 24 68	 lea	 rdx, QWORD PTR d2$[rsp]
  002a7	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  002af	e8 00 00 00 00	 call	 decNumberCopy

; 4818 :         decimal32FromNumber(&x1, &d1, &set);

  002b4	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  002b9	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  002c1	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x1$[rsp]
  002c6	e8 00 00 00 00	 call	 decimal32FromNumber
$LN9@s370_load_:

; 4819 :     }
; 4820 : 
; 4821 :     /* Check for exception condition */
; 4822 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  002cb	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002d3	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  002d8	e8 00 00 00 00	 call	 s370_dfp_status_check
  002dd	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4823 : 
; 4824 :     /* Load result into FP register r1 */
; 4825 :     ARCH_DEP(dfp_reg_from_decimal32)(r1, &x1, regs);

  002e1	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002e9	48 8d 54 24 24	 lea	 rdx, QWORD PTR x1$[rsp]
  002ee	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  002f2	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal32

; 4826 : 
; 4827 :     /* Raise data exception if error occurred */
; 4828 :     if (dxc != 0)

  002f7	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002fc	85 c0		 test	 eax, eax
  002fe	74 25		 je	 SHORT $LN18@s370_load_

; 4829 :     {
; 4830 :         regs->dxc = dxc;

  00300	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00305	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030d	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4831 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00313	ba 07 00 00 00	 mov	 edx, 7
  00318	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00320	e8 00 00 00 00	 call	 s370_program_interrupt
$LN18@s370_load_:

; 4832 :     }
; 4833 : 
; 4834 : } /* end DEF_INST(load_rounded_dfp_long_to_short_reg) */

  00325	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0032d	48 33 cc	 xor	 rcx, rsp
  00330	e8 00 00 00 00	 call	 __security_check_cookie
  00335	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0033c	c3		 ret	 0
s370_load_rounded_dfp_long_to_short_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
scale$ = 44
m4$ = 48
m3$ = 52
r1$ = 56
x1$ = 64
x2$ = 72
set$ = 88
d2$ = 120
d1$ = 160
pwork$ = 200
__$ArrayPad$ = 224
inst$ = 256
regs$ = 264
s370_load_rounded_dfp_ext_to_long_reg PROC

; 4668 : {

$LN21:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4669 : int             r1, r2, m3, m4;         /* Values of R and M fields  */
; 4670 : decimal64       x1;                     /* Long DFP value            */
; 4671 : decimal128      x2;                     /* Extended DFP value        */
; 4672 : decNumber       d1, d2;                 /* Working decimal numbers   */
; 4673 : decContext      set;                    /* Working context           */
; 4674 : int32_t         scale;                  /* Scaling factor            */
; 4675 : BYTE            pwork[17];              /* 33-digit packed work area */
; 4676 : BYTE            dxc;                    /* Data exception code       */
; 4677 : 
; 4678 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 30	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 34	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_load_:
  00070	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_load_
  00093	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_load_

; 4679 : 
; 4680 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4681 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_load_
  000c9	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_load_
  000e0	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  00108	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 4682 :     DFPREGPAIR_CHECK(r2, regs);

  00135	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00139	83 e0 02	 and	 eax, 2
  0013c	85 c0		 test	 eax, eax
  0013e	74 1b		 je	 SHORT $LN8@s370_load_
  00140	ba 06 00 00 00	 mov	 edx, 6
  00145	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014d	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 4683 : 
; 4684 :     /* Initialise the context for extended DFP */
; 4685 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0015b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00160	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  00165	e8 00 00 00 00	 call	 decContextDefault

; 4686 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  0016a	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00172	8b 54 24 34	 mov	 edx, DWORD PTR m3$[rsp]
  00176	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  0017b	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 4687 : 
; 4688 :     /* Load DFP extended number from FP register r2 */
; 4689 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00180	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00188	48 8d 54 24 48	 lea	 rdx, QWORD PTR x2$[rsp]
  0018d	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00191	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 4690 :     decimal128ToNumber(&x2, &d2);

  00196	48 8d 54 24 78	 lea	 rdx, QWORD PTR d2$[rsp]
  0019b	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  001a0	e8 00 00 00 00	 call	 decimal128ToNumber

; 4691 : 
; 4692 :     /* Convert number to DFP long format */
; 4693 :     if ((decNumberIsInfinite(&d2) && (m4 & 0x08))
; 4694 :          || decNumberIsNaN(&d2))

  001a5	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001ad	83 e0 40	 and	 eax, 64			; 00000040H
  001b0	85 c0		 test	 eax, eax
  001b2	74 0b		 je	 SHORT $LN12@s370_load_
  001b4	8b 44 24 30	 mov	 eax, DWORD PTR m4$[rsp]
  001b8	83 e0 08	 and	 eax, 8
  001bb	85 c0		 test	 eax, eax
  001bd	75 13		 jne	 SHORT $LN11@s370_load_
$LN12@s370_load_:
  001bf	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001c7	83 e0 30	 and	 eax, 48			; 00000030H
  001ca	85 c0		 test	 eax, eax
  001cc	0f 84 05 01 00
	00		 je	 $LN9@s370_load_
$LN11@s370_load_:

; 4695 :     {
; 4696 :         /* For Inf with mask bit 0 set, or for QNan or SNan,
; 4697 :            propagate the low 15 digits */
; 4698 :         dfp128_clear_cf_and_bxcf(&x2);

  001d2	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  001d7	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 4699 :         decimal128ToNumber(&x2, &d1);

  001dc	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  001e4	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  001e9	e8 00 00 00 00	 call	 decimal128ToNumber

; 4700 :         decPackedFromNumber(pwork, sizeof(pwork), &scale, &d1);

  001ee	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR d1$[rsp]
  001f6	4c 8d 44 24 2c	 lea	 r8, QWORD PTR scale$[rsp]
  001fb	ba 11 00 00 00	 mov	 edx, 17
  00200	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  00208	e8 00 00 00 00	 call	 decPackedFromNumber

; 4701 :         scale = 0;

  0020d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR scale$[rsp], 0

; 4702 :         decPackedToNumber(pwork+sizeof(pwork)-8, 8, &scale, &d1);

  00215	48 8d 84 24 d1
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+9]
  0021d	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR d1$[rsp]
  00225	4c 8d 44 24 2c	 lea	 r8, QWORD PTR scale$[rsp]
  0022a	ba 08 00 00 00	 mov	 edx, 8
  0022f	48 8b c8	 mov	 rcx, rax
  00232	e8 00 00 00 00	 call	 decPackedToNumber

; 4703 :         decimal64FromNumber(&x1, &d1, &set);

  00237	4c 8d 44 24 58	 lea	 r8, QWORD PTR set$[rsp]
  0023c	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00244	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00249	e8 00 00 00 00	 call	 decimal64FromNumber

; 4704 :         if (decNumberIsInfinite(&d2))

  0024e	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00256	83 e0 40	 and	 eax, 64			; 00000040H
  00259	85 c0		 test	 eax, eax
  0025b	74 11		 je	 SHORT $LN13@s370_load_

; 4705 :         {
; 4706 :             dfp64_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  0025d	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00262	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00267	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4707 :         }

  0026c	eb 67		 jmp	 SHORT $LN14@s370_load_
$LN13@s370_load_:

; 4708 :         else if (decNumberIsQNaN(&d2))

  0026e	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00276	83 e0 20	 and	 eax, 32			; 00000020H
  00279	85 c0		 test	 eax, eax
  0027b	74 11		 je	 SHORT $LN15@s370_load_

; 4709 :         {
; 4710 :             dfp64_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  0027d	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  00282	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00287	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4711 :         }

  0028c	eb 47		 jmp	 SHORT $LN16@s370_load_
$LN15@s370_load_:

; 4712 :         else /* it is an SNaN */
; 4713 :         {
; 4714 :             /* For SNaN with mask bit 0 off, convert to a QNaN
; 4715 :                and raise signaling condition */
; 4716 :             if (decNumberIsSNaN(&d2) && (m4 & 0x08) == 0)

  0028e	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00296	83 e0 10	 and	 eax, 16
  00299	85 c0		 test	 eax, eax
  0029b	74 29		 je	 SHORT $LN17@s370_load_
  0029d	8b 44 24 30	 mov	 eax, DWORD PTR m4$[rsp]
  002a1	83 e0 08	 and	 eax, 8
  002a4	85 c0		 test	 eax, eax
  002a6	75 1e		 jne	 SHORT $LN17@s370_load_

; 4717 :             {
; 4718 :                 dfp64_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  002a8	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  002ad	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002b2	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4719 :                 set.status |= DEC_IEEE_854_Invalid_operation;

  002b7	8b 44 24 6c	 mov	 eax, DWORD PTR set$[rsp+20]
  002bb	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  002c0	89 44 24 6c	 mov	 DWORD PTR set$[rsp+20], eax

; 4720 :             }

  002c4	eb 0f		 jmp	 SHORT $LN18@s370_load_
$LN17@s370_load_:

; 4721 :             else
; 4722 :             {
; 4723 :                 dfp64_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  002c6	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  002cb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002d0	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf
$LN18@s370_load_:
$LN16@s370_load_:
$LN14@s370_load_:

; 4724 :             }
; 4725 :         }
; 4726 :     }

  002d5	eb 29		 jmp	 SHORT $LN10@s370_load_
$LN9@s370_load_:

; 4727 :     else
; 4728 :     {
; 4729 :         /* For finite number, load value rounded to long DFP format,
; 4730 :            or for Inf with mask bit 0 not set, load default infinity */
; 4731 :         decNumberCopy(&d1, &d2);

  002d7	48 8d 54 24 78	 lea	 rdx, QWORD PTR d2$[rsp]
  002dc	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  002e4	e8 00 00 00 00	 call	 decNumberCopy

; 4732 :         decimal64FromNumber(&x1, &d1, &set);

  002e9	4c 8d 44 24 58	 lea	 r8, QWORD PTR set$[rsp]
  002ee	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  002f6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  002fb	e8 00 00 00 00	 call	 decimal64FromNumber
$LN10@s370_load_:

; 4733 :     }
; 4734 : 
; 4735 :     /* Check for exception condition */
; 4736 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00300	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00308	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  0030d	e8 00 00 00 00	 call	 s370_dfp_status_check
  00312	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4737 : 
; 4738 :     /* Load result into FP register r1 */
; 4739 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  00316	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0031e	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  00323	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  00327	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 4740 : 
; 4741 :     /* Raise data exception if error occurred */
; 4742 :     if (dxc != 0)

  0032c	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00331	85 c0		 test	 eax, eax
  00333	74 25		 je	 SHORT $LN19@s370_load_

; 4743 :     {
; 4744 :         regs->dxc = dxc;

  00335	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0033a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00342	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4745 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00348	ba 07 00 00 00	 mov	 edx, 7
  0034d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00355	e8 00 00 00 00	 call	 s370_program_interrupt
$LN19@s370_load_:

; 4746 :     }
; 4747 : 
; 4748 : } /* end DEF_INST(load_rounded_dfp_ext_to_long_reg) */

  0035a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00362	48 33 cc	 xor	 rcx, rsp
  00365	e8 00 00 00 00	 call	 __security_check_cookie
  0036a	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00371	c3		 ret	 0
s370_load_rounded_dfp_ext_to_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
x2$ = 36
temp$1 = 40
m4$ = 44
r2$ = 48
r1$ = 52
x1$ = 56
d1$ = 64
set$ = 104
d2$ = 136
__$ArrayPad$ = 176
inst$ = 208
regs$ = 216
s370_load_lengthened_dfp_short_to_long_reg PROC

; 4600 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4601 : int             r1, r2, m4;             /* Values of R and M fields  */
; 4602 : decimal64       x1;                     /* Long DFP value            */
; 4603 : decimal32       x2;                     /* Short DFP value           */
; 4604 : decNumber       d1, d2;                 /* Working decimal numbers   */
; 4605 : decContext      set;                    /* Working context           */
; 4606 : BYTE            dxc;                    /* Data exception code       */
; 4607 : 
; 4608 :     RRF_M4(inst, regs, r1, r2, m4);

  00023	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR m4$[rsp], eax
$LN4@s370_load_:
  00062	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_load_
  00085	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_load_

; 4609 : 
; 4610 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4611 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_load_
  000bb	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_load_
  000d2	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000fa	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 4612 : 
; 4613 :     /* Initialise the context for long DFP */
; 4614 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00127	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0012c	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00131	e8 00 00 00 00	 call	 decContextDefault

; 4615 : 
; 4616 :     /* Load DFP short number from FP register r2 */
; 4617 :     ARCH_DEP(dfp_reg_to_decimal32)(r2, &x2, regs);

  00136	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0013e	48 8d 54 24 24	 lea	 rdx, QWORD PTR x2$[rsp]
  00143	8b 4c 24 30	 mov	 ecx, DWORD PTR r2$[rsp]
  00147	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal32

; 4618 :     decimal32ToNumber(&x2, &d2);

  0014c	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00154	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x2$[rsp]
  00159	e8 00 00 00 00	 call	 decimal32ToNumber

; 4619 : 
; 4620 :     /* Convert number to DFP long format */
; 4621 :     if (decNumberIsInfinite(&d2) && (m4 & 0x08))

  0015e	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00166	83 e0 40	 and	 eax, 64			; 00000040H
  00169	85 c0		 test	 eax, eax
  0016b	74 4c		 je	 SHORT $LN8@s370_load_
  0016d	8b 44 24 2c	 mov	 eax, DWORD PTR m4$[rsp]
  00171	83 e0 08	 and	 eax, 8
  00174	85 c0		 test	 eax, eax
  00176	74 41		 je	 SHORT $LN8@s370_load_

; 4622 :     {
; 4623 :         /* For Inf with mask bit 0 set, propagate the digits */
; 4624 :         dfp32_clear_cf_and_bxcf(&x2);

  00178	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x2$[rsp]
  0017d	e8 00 00 00 00	 call	 dfp32_clear_cf_and_bxcf

; 4625 :         decimal32ToNumber(&x2, &d1);

  00182	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  00187	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x2$[rsp]
  0018c	e8 00 00 00 00	 call	 decimal32ToNumber

; 4626 :         decimal64FromNumber(&x1, &d1, &set);

  00191	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  00196	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  0019b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  001a0	e8 00 00 00 00	 call	 decimal64FromNumber

; 4627 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  001a5	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  001aa	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  001af	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4628 :     }

  001b4	e9 99 00 00 00	 jmp	 $LN9@s370_load_
$LN8@s370_load_:

; 4629 :     else if (decNumberIsNaN(&d2))

  001b9	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001c1	83 e0 30	 and	 eax, 48			; 00000030H
  001c4	85 c0		 test	 eax, eax
  001c6	74 64		 je	 SHORT $LN10@s370_load_

; 4630 :     {
; 4631 :         decimal32ToNumber(&x2, &d1);

  001c8	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  001cd	48 8d 4c 24 24	 lea	 rcx, QWORD PTR x2$[rsp]
  001d2	e8 00 00 00 00	 call	 decimal32ToNumber

; 4632 :         /* For SNaN with mask bit 0 off, convert to a QNaN
; 4633 :            and raise signaling condition */
; 4634 :         if (decNumberIsSNaN(&d2) && (m4 & 0x08) == 0)

  001d7	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001df	83 e0 10	 and	 eax, 16
  001e2	85 c0		 test	 eax, eax
  001e4	74 30		 je	 SHORT $LN12@s370_load_
  001e6	8b 44 24 2c	 mov	 eax, DWORD PTR m4$[rsp]
  001ea	83 e0 08	 and	 eax, 8
  001ed	85 c0		 test	 eax, eax
  001ef	75 25		 jne	 SHORT $LN12@s370_load_

; 4635 :         {
; 4636 :             set.status |= DEC_IEEE_854_Invalid_operation;

  001f1	8b 44 24 7c	 mov	 eax, DWORD PTR set$[rsp+20]
  001f5	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  001fa	89 44 24 7c	 mov	 DWORD PTR set$[rsp+20], eax

; 4637 :             d1.bits &= ~DECSNAN;

  001fe	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  00203	83 e0 ef	 and	 eax, -17
  00206	88 44 24 48	 mov	 BYTE PTR d1$[rsp+8], al

; 4638 :             d1.bits |= DECNAN;

  0020a	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0020f	83 c8 20	 or	 eax, 32			; 00000020H
  00212	88 44 24 48	 mov	 BYTE PTR d1$[rsp+8], al
$LN12@s370_load_:

; 4639 :         }
; 4640 :         decimal64FromNumber(&x1, &d1, &set);

  00216	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  0021b	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  00220	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  00225	e8 00 00 00 00	 call	 decimal64FromNumber

; 4641 :     }

  0022a	eb 26		 jmp	 SHORT $LN11@s370_load_
$LN10@s370_load_:

; 4642 :     else
; 4643 :     {
; 4644 :         decNumberCopy(&d1, &d2);

  0022c	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00234	48 8d 4c 24 40	 lea	 rcx, QWORD PTR d1$[rsp]
  00239	e8 00 00 00 00	 call	 decNumberCopy

; 4645 :         decimal64FromNumber(&x1, &d1, &set);

  0023e	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  00243	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  00248	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  0024d	e8 00 00 00 00	 call	 decimal64FromNumber
$LN11@s370_load_:
$LN9@s370_load_:

; 4646 :     }
; 4647 : 
; 4648 :     /* Check for exception condition */
; 4649 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00252	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0025a	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  0025f	e8 00 00 00 00	 call	 s370_dfp_status_check
  00264	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4650 : 
; 4651 :     /* Load result into FP register r1 */
; 4652 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  00268	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00270	48 8d 54 24 38	 lea	 rdx, QWORD PTR x1$[rsp]
  00275	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00279	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 4653 : 
; 4654 :     /* Raise data exception if error occurred */
; 4655 :     if (dxc != 0)

  0027e	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00283	85 c0		 test	 eax, eax
  00285	74 25		 je	 SHORT $LN13@s370_load_

; 4656 :     {
; 4657 :         regs->dxc = dxc;

  00287	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0028c	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00294	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4658 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0029a	ba 07 00 00 00	 mov	 edx, 7
  0029f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a7	e8 00 00 00 00	 call	 s370_program_interrupt
$LN13@s370_load_:

; 4659 :     }
; 4660 : 
; 4661 : } /* end DEF_INST(load_lengthened_dfp_short_to_long_reg) */

  002ac	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002b4	48 33 cc	 xor	 rcx, rsp
  002b7	e8 00 00 00 00	 call	 __security_check_cookie
  002bc	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  002c3	c3		 ret	 0
s370_load_lengthened_dfp_short_to_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
m4$ = 40
r1$ = 44
r2$ = 48
x2$ = 56
x1$ = 64
d1$ = 80
set$ = 120
d2$ = 152
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
s370_load_lengthened_dfp_long_to_ext_reg PROC

; 4531 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4532 : int             r1, r2, m4;             /* Values of R and M fields  */
; 4533 : decimal128      x1;                     /* Extended DFP value        */
; 4534 : decimal64       x2;                     /* Long DFP value            */
; 4535 : decNumber       d1, d2;                 /* Working decimal numbers   */
; 4536 : decContext      set;                    /* Working context           */
; 4537 : BYTE            dxc;                    /* Data exception code       */
; 4538 : 
; 4539 :     RRF_M4(inst, regs, r1, r2, m4);

  00023	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 28	 mov	 DWORD PTR m4$[rsp], eax
$LN4@s370_load_:
  00062	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_load_
  00085	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_load_

; 4540 : 
; 4541 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4542 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_load_
  000bb	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_load_
  000d2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000fa	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 4543 :     DFPREGPAIR_CHECK(r1, regs);

  00127	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0012b	83 e0 02	 and	 eax, 2
  0012e	85 c0		 test	 eax, eax
  00130	74 1b		 je	 SHORT $LN8@s370_load_
  00132	ba 06 00 00 00	 mov	 edx, 6
  00137	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00147	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 4544 : 
; 4545 :     /* Initialise the context for extended DFP */
; 4546 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0014d	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00152	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  00157	e8 00 00 00 00	 call	 decContextDefault

; 4547 : 
; 4548 :     /* Load DFP long number from FP register r2 */
; 4549 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  0015c	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00164	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  00169	8b 4c 24 30	 mov	 ecx, DWORD PTR r2$[rsp]
  0016d	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 4550 :     decimal64ToNumber(&x2, &d2);

  00172	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0017a	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  0017f	e8 00 00 00 00	 call	 decimal64ToNumber

; 4551 : 
; 4552 :     /* Convert number to DFP extended format */
; 4553 :     if (decNumberIsInfinite(&d2) && (m4 & 0x08))

  00184	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0018c	83 e0 40	 and	 eax, 64			; 00000040H
  0018f	85 c0		 test	 eax, eax
  00191	74 4c		 je	 SHORT $LN9@s370_load_
  00193	8b 44 24 28	 mov	 eax, DWORD PTR m4$[rsp]
  00197	83 e0 08	 and	 eax, 8
  0019a	85 c0		 test	 eax, eax
  0019c	74 41		 je	 SHORT $LN9@s370_load_

; 4554 :     {
; 4555 :         /* For Inf with mask bit 0 set, propagate the digits */
; 4556 :         dfp64_clear_cf_and_bxcf(&x2);

  0019e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  001a3	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 4557 :         decimal64ToNumber(&x2, &d1);

  001a8	48 8d 54 24 50	 lea	 rdx, QWORD PTR d1$[rsp]
  001ad	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  001b2	e8 00 00 00 00	 call	 decimal64ToNumber

; 4558 :         decimal128FromNumber(&x1, &d1, &set);

  001b7	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  001bc	48 8d 54 24 50	 lea	 rdx, QWORD PTR d1$[rsp]
  001c1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  001c6	e8 00 00 00 00	 call	 decimal128FromNumber

; 4559 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  001cb	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  001d0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  001d5	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf

; 4560 :     }

  001da	e9 9f 00 00 00	 jmp	 $LN10@s370_load_
$LN9@s370_load_:

; 4561 :     else if (decNumberIsNaN(&d2))

  001df	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001e7	83 e0 30	 and	 eax, 48			; 00000030H
  001ea	85 c0		 test	 eax, eax
  001ec	74 6a		 je	 SHORT $LN11@s370_load_

; 4562 :     {
; 4563 :         decimal64ToNumber(&x2, &d1);

  001ee	48 8d 54 24 50	 lea	 rdx, QWORD PTR d1$[rsp]
  001f3	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  001f8	e8 00 00 00 00	 call	 decimal64ToNumber

; 4564 :         /* For SNaN with mask bit 0 off, convert to a QNaN
; 4565 :            and raise signaling condition */
; 4566 :         if (decNumberIsSNaN(&d2) && (m4 & 0x08) == 0)

  001fd	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00205	83 e0 10	 and	 eax, 16
  00208	85 c0		 test	 eax, eax
  0020a	74 36		 je	 SHORT $LN13@s370_load_
  0020c	8b 44 24 28	 mov	 eax, DWORD PTR m4$[rsp]
  00210	83 e0 08	 and	 eax, 8
  00213	85 c0		 test	 eax, eax
  00215	75 2b		 jne	 SHORT $LN13@s370_load_

; 4567 :         {
; 4568 :             set.status |= DEC_IEEE_854_Invalid_operation;

  00217	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR set$[rsp+20]
  0021e	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00223	89 84 24 8c 00
	00 00		 mov	 DWORD PTR set$[rsp+20], eax

; 4569 :             d1.bits &= ~DECSNAN;

  0022a	0f b6 44 24 58	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0022f	83 e0 ef	 and	 eax, -17
  00232	88 44 24 58	 mov	 BYTE PTR d1$[rsp+8], al

; 4570 :             d1.bits |= DECNAN;

  00236	0f b6 44 24 58	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0023b	83 c8 20	 or	 eax, 32			; 00000020H
  0023e	88 44 24 58	 mov	 BYTE PTR d1$[rsp+8], al
$LN13@s370_load_:

; 4571 :         }
; 4572 :         decimal128FromNumber(&x1, &d1, &set);

  00242	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  00247	48 8d 54 24 50	 lea	 rdx, QWORD PTR d1$[rsp]
  0024c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00251	e8 00 00 00 00	 call	 decimal128FromNumber

; 4573 :     }

  00256	eb 26		 jmp	 SHORT $LN12@s370_load_
$LN11@s370_load_:

; 4574 :     else
; 4575 :     {
; 4576 :         decNumberCopy(&d1, &d2);

  00258	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00260	48 8d 4c 24 50	 lea	 rcx, QWORD PTR d1$[rsp]
  00265	e8 00 00 00 00	 call	 decNumberCopy

; 4577 :         decimal128FromNumber(&x1, &d1, &set);

  0026a	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  0026f	48 8d 54 24 50	 lea	 rdx, QWORD PTR d1$[rsp]
  00274	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00279	e8 00 00 00 00	 call	 decimal128FromNumber
$LN12@s370_load_:
$LN10@s370_load_:

; 4578 :     }
; 4579 : 
; 4580 :     /* Check for exception condition */
; 4581 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0027e	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00286	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  0028b	e8 00 00 00 00	 call	 s370_dfp_status_check
  00290	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4582 : 
; 4583 :     /* Load result into FP register r1 */
; 4584 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  00294	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0029c	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  002a1	8b 4c 24 2c	 mov	 ecx, DWORD PTR r1$[rsp]
  002a5	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 4585 : 
; 4586 :     /* Raise data exception if error occurred */
; 4587 :     if (dxc != 0)

  002aa	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002af	85 c0		 test	 eax, eax
  002b1	74 25		 je	 SHORT $LN14@s370_load_

; 4588 :     {
; 4589 :         regs->dxc = dxc;

  002b3	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002b8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c0	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4590 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002c6	ba 07 00 00 00	 mov	 edx, 7
  002cb	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d3	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_load_:

; 4591 :     }
; 4592 : 
; 4593 : } /* end DEF_INST(load_lengthened_dfp_long_to_ext_reg) */

  002d8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002e0	48 33 cc	 xor	 rcx, rsp
  002e3	e8 00 00 00 00	 call	 __security_check_cookie
  002e8	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  002ef	c3		 ret	 0
s370_load_lengthened_dfp_long_to_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv147 = 40
tv152 = 44
tv171 = 48
tv180 = 52
tv181 = 56
m3$ = 60
r2$ = 64
m4$ = 68
r1$ = 72
set$ = 80
x2$ = 112
x1$ = 120
d2$ = 128
d1$ = 168
dc$ = 208
__$ArrayPad$ = 248
inst$ = 272
regs$ = 280
s370_load_fp_int_dfp_long_reg PROC

; 4456 : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4457 : int             r1, r2, m3, m4;         /* Values of R and M fields  */
; 4458 : decimal64       x1, x2;                 /* Long DFP values           */
; 4459 : decNumber       d1, d2, dc;             /* Working decimal numbers   */
; 4460 : decContext      set;                    /* Working context           */
; 4461 : BYTE            dxc;                    /* Data exception code       */
; 4462 : 
; 4463 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 40	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 44	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 3c	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_load_:
  00070	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_load_
  00093	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_load_

; 4464 : 
; 4465 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4466 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_load_
  000c9	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_load_
  000e0	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  00108	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 4467 : 
; 4468 :     /* Initialise the context for long DFP */
; 4469 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00135	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0013a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0013f	e8 00 00 00 00	 call	 decContextDefault

; 4470 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00144	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0014c	8b 54 24 3c	 mov	 edx, DWORD PTR m3$[rsp]
  00150	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00155	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 4471 : 
; 4472 :     /* Load decimal number from FP register r2 */
; 4473 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  0015a	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00162	48 8d 54 24 70	 lea	 rdx, QWORD PTR x2$[rsp]
  00167	8b 4c 24 40	 mov	 ecx, DWORD PTR r2$[rsp]
  0016b	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 4474 :     decimal64ToNumber(&x2, &d2);

  00170	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00178	48 8d 4c 24 70	 lea	 rcx, QWORD PTR x2$[rsp]
  0017d	e8 00 00 00 00	 call	 decimal64ToNumber

; 4475 : 
; 4476 :     if (decNumberIsInfinite(&d2) == 0 && decNumberIsNaN(&d2) == 0)

  00182	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0018a	83 e0 40	 and	 eax, 64			; 00000040H
  0018d	85 c0		 test	 eax, eax
  0018f	74 0a		 je	 SHORT $LN16@s370_load_
  00191	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv147[rsp], 1
  00199	eb 08		 jmp	 SHORT $LN17@s370_load_
$LN16@s370_load_:
  0019b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN17@s370_load_:
  001a3	83 7c 24 28 00	 cmp	 DWORD PTR tv147[rsp], 0
  001a8	0f 85 27 01 00
	00		 jne	 $LN8@s370_load_
  001ae	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001b6	83 e0 30	 and	 eax, 48			; 00000030H
  001b9	85 c0		 test	 eax, eax
  001bb	74 0a		 je	 SHORT $LN18@s370_load_
  001bd	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv152[rsp], 1
  001c5	eb 08		 jmp	 SHORT $LN19@s370_load_
$LN18@s370_load_:
  001c7	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN19@s370_load_:
  001cf	83 7c 24 2c 00	 cmp	 DWORD PTR tv152[rsp], 0
  001d4	0f 85 fb 00 00
	00		 jne	 $LN8@s370_load_

; 4477 :     {
; 4478 :         /* Remove fractional part of decimal number */
; 4479 :         decNumberToIntegralValue(&d1, &d2, &set);

  001da	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  001df	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001e7	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  001ef	e8 00 00 00 00	 call	 decNumberToIntegralValue

; 4480 : 
; 4481 :         /* Raise inexact condition if M4 bit 1 is zero and
; 4482 :            result differs in value from original value */
; 4483 :         if ((m4 & 0x04) == 0)

  001f4	8b 44 24 44	 mov	 eax, DWORD PTR m4$[rsp]
  001f8	83 e0 04	 and	 eax, 4
  001fb	85 c0		 test	 eax, eax
  001fd	0f 85 d0 00 00
	00		 jne	 $LN10@s370_load_

; 4484 :         {
; 4485 :             decNumberCompare(&dc, &d1, &d2, &set);

  00203	4c 8d 4c 24 50	 lea	 r9, QWORD PTR set$[rsp]
  00208	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR d2$[rsp]
  00210	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00218	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR dc$[rsp]
  00220	e8 00 00 00 00	 call	 decNumberCompare

; 4486 :             if (decNumberIsZero(&dc) == 0)

  00225	b8 02 00 00 00	 mov	 eax, 2
  0022a	48 6b c0 00	 imul	 rax, rax, 0
  0022e	0f b7 84 04 da
	00 00 00	 movzx	 eax, WORD PTR dc$[rsp+rax+10]
  00236	85 c0		 test	 eax, eax
  00238	75 23		 jne	 SHORT $LN20@s370_load_
  0023a	83 bc 24 d0 00
	00 00 01	 cmp	 DWORD PTR dc$[rsp], 1
  00242	75 19		 jne	 SHORT $LN20@s370_load_
  00244	0f b6 84 24 d8
	00 00 00	 movzx	 eax, BYTE PTR dc$[rsp+8]
  0024c	83 e0 70	 and	 eax, 112		; 00000070H
  0024f	85 c0		 test	 eax, eax
  00251	75 0a		 jne	 SHORT $LN20@s370_load_
  00253	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv171[rsp], 1
  0025b	eb 08		 jmp	 SHORT $LN21@s370_load_
$LN20@s370_load_:
  0025d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
$LN21@s370_load_:
  00265	83 7c 24 30 00	 cmp	 DWORD PTR tv171[rsp], 0
  0026a	75 67		 jne	 SHORT $LN11@s370_load_

; 4487 :             {
; 4488 :                 set.status |= DEC_IEEE_854_Inexact;

  0026c	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  00270	83 c8 20	 or	 eax, 32			; 00000020H
  00273	89 44 24 64	 mov	 DWORD PTR set$[rsp+20], eax

; 4489 :                 if (decNumberIsNegative(&dc) == decNumberIsNegative(&d2))

  00277	0f b6 84 24 d8
	00 00 00	 movzx	 eax, BYTE PTR dc$[rsp+8]
  0027f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00284	85 c0		 test	 eax, eax
  00286	74 0a		 je	 SHORT $LN24@s370_load_
  00288	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv181[rsp], 1
  00290	eb 08		 jmp	 SHORT $LN25@s370_load_
$LN24@s370_load_:
  00292	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
$LN25@s370_load_:
  0029a	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002a2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002a7	85 c0		 test	 eax, eax
  002a9	74 0a		 je	 SHORT $LN22@s370_load_
  002ab	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv180[rsp], 1
  002b3	eb 08		 jmp	 SHORT $LN23@s370_load_
$LN22@s370_load_:
  002b5	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN23@s370_load_:
  002bd	8b 44 24 34	 mov	 eax, DWORD PTR tv180[rsp]
  002c1	39 44 24 38	 cmp	 DWORD PTR tv181[rsp], eax
  002c5	75 0c		 jne	 SHORT $LN12@s370_load_

; 4490 :                     set.status |= DEC_Rounded;

  002c7	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  002cb	0f ba e8 0b	 bts	 eax, 11
  002cf	89 44 24 64	 mov	 DWORD PTR set$[rsp+20], eax
$LN12@s370_load_:
$LN11@s370_load_:
$LN10@s370_load_:

; 4491 :             }
; 4492 :         }
; 4493 :     }

  002d3	eb 55		 jmp	 SHORT $LN9@s370_load_
$LN8@s370_load_:

; 4494 :     else
; 4495 :     {
; 4496 :         /* Propagate NaN or default infinity */
; 4497 :         decNumberCopy(&d1, &d2);

  002d5	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  002dd	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  002e5	e8 00 00 00 00	 call	 decNumberCopy

; 4498 : 
; 4499 :         /* For SNaN, force signaling condition and convert to QNaN */
; 4500 :         if (decNumberIsSNaN(&d2))

  002ea	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002f2	83 e0 10	 and	 eax, 16
  002f5	85 c0		 test	 eax, eax
  002f7	74 31		 je	 SHORT $LN13@s370_load_

; 4501 :         {
; 4502 :             set.status |= DEC_IEEE_854_Invalid_operation;

  002f9	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  002fd	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00302	89 44 24 64	 mov	 DWORD PTR set$[rsp+20], eax

; 4503 :             d1.bits &= ~DECSNAN;

  00306	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0030e	83 e0 ef	 and	 eax, -17
  00311	88 84 24 b0 00
	00 00		 mov	 BYTE PTR d1$[rsp+8], al

; 4504 :             d1.bits |= DECNAN;

  00318	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR d1$[rsp+8]
  00320	83 c8 20	 or	 eax, 32			; 00000020H
  00323	88 84 24 b0 00
	00 00		 mov	 BYTE PTR d1$[rsp+8], al
$LN13@s370_load_:
$LN9@s370_load_:

; 4505 :         }
; 4506 :     }
; 4507 : 
; 4508 :     /* Convert result to long DFP format */
; 4509 :     decimal64FromNumber(&x1, &d1, &set);

  0032a	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  0032f	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00337	48 8d 4c 24 78	 lea	 rcx, QWORD PTR x1$[rsp]
  0033c	e8 00 00 00 00	 call	 decimal64FromNumber

; 4510 : 
; 4511 :     /* Check for exception condition */
; 4512 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00341	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00349	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0034e	e8 00 00 00 00	 call	 s370_dfp_status_check
  00353	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4513 : 
; 4514 :     /* Load result into FP register r1 */
; 4515 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  00357	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0035f	48 8d 54 24 78	 lea	 rdx, QWORD PTR x1$[rsp]
  00364	8b 4c 24 48	 mov	 ecx, DWORD PTR r1$[rsp]
  00368	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 4516 : 
; 4517 :     /* Raise data exception if error occurred */
; 4518 :     if (dxc != 0)

  0036d	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00372	85 c0		 test	 eax, eax
  00374	74 25		 je	 SHORT $LN14@s370_load_

; 4519 :     {
; 4520 :         regs->dxc = dxc;

  00376	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0037b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00383	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4521 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00389	ba 07 00 00 00	 mov	 edx, 7
  0038e	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00396	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_load_:

; 4522 :     }
; 4523 : 
; 4524 : } /* end DEF_INST(load_fp_int_dfp_long_reg) */

  0039b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003a3	48 33 cc	 xor	 rcx, rsp
  003a6	e8 00 00 00 00	 call	 __security_check_cookie
  003ab	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  003b2	c3		 ret	 0
s370_load_fp_int_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
tv154 = 44
tv159 = 48
tv178 = 52
tv187 = 56
tv188 = 60
r1$ = 64
m3$ = 68
m4$ = 72
set$ = 80
d2$ = 112
d1$ = 152
dc$ = 192
x2$ = 232
x1$ = 248
__$ArrayPad$ = 264
inst$ = 288
regs$ = 296
s370_load_fp_int_dfp_ext_reg PROC

; 4380 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4381 : int             r1, r2, m3, m4;         /* Values of R and M fields  */
; 4382 : decimal128      x1, x2;                 /* Extended DFP values       */
; 4383 : decNumber       d1, d2, dc;             /* Working decimal numbers   */
; 4384 : decContext      set;                    /* Working context           */
; 4385 : BYTE            dxc;                    /* Data exception code       */
; 4386 : 
; 4387 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 40	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 48	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 44	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_load_:
  00070	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_load_
  00093	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_load_

; 4388 : 
; 4389 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4390 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_load_
  000c9	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_load_
  000e0	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  00108	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 4391 :     DFPREGPAIR2_CHECK(r1, r2, regs);

  00135	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  00139	83 e0 02	 and	 eax, 2
  0013c	85 c0		 test	 eax, eax
  0013e	75 0b		 jne	 SHORT $LN9@s370_load_
  00140	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00144	83 e0 02	 and	 eax, 2
  00147	85 c0		 test	 eax, eax
  00149	74 1b		 je	 SHORT $LN8@s370_load_
$LN9@s370_load_:
  0014b	ba 06 00 00 00	 mov	 edx, 6
  00150	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00160	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 4392 : 
; 4393 :     /* Initialise the context for extended DFP */
; 4394 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00166	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0016b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00170	e8 00 00 00 00	 call	 decContextDefault

; 4395 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00175	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017d	8b 54 24 44	 mov	 edx, DWORD PTR m3$[rsp]
  00181	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00186	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 4396 : 
; 4397 :     /* Load decimal number from FP register r2 */
; 4398 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  0018b	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00193	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  0019b	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  0019f	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 4399 :     decimal128ToNumber(&x2, &d2);

  001a4	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  001a9	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  001b1	e8 00 00 00 00	 call	 decimal128ToNumber

; 4400 : 
; 4401 :     if (decNumberIsInfinite(&d2) == 0 && decNumberIsNaN(&d2) == 0)

  001b6	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001bb	83 e0 40	 and	 eax, 64			; 00000040H
  001be	85 c0		 test	 eax, eax
  001c0	74 0a		 je	 SHORT $LN18@s370_load_
  001c2	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001ca	eb 08		 jmp	 SHORT $LN19@s370_load_
$LN18@s370_load_:
  001cc	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv154[rsp], 0
$LN19@s370_load_:
  001d4	83 7c 24 2c 00	 cmp	 DWORD PTR tv154[rsp], 0
  001d9	0f 85 1b 01 00
	00		 jne	 $LN10@s370_load_
  001df	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001e4	83 e0 30	 and	 eax, 48			; 00000030H
  001e7	85 c0		 test	 eax, eax
  001e9	74 0a		 je	 SHORT $LN20@s370_load_
  001eb	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv159[rsp], 1
  001f3	eb 08		 jmp	 SHORT $LN21@s370_load_
$LN20@s370_load_:
  001f5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN21@s370_load_:
  001fd	83 7c 24 30 00	 cmp	 DWORD PTR tv159[rsp], 0
  00202	0f 85 f2 00 00
	00		 jne	 $LN10@s370_load_

; 4402 :     {
; 4403 :         /* Remove fractional part of decimal number */
; 4404 :         decNumberToIntegralValue(&d1, &d2, &set);

  00208	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  0020d	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  00212	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  0021a	e8 00 00 00 00	 call	 decNumberToIntegralValue

; 4405 : 
; 4406 :         /* Raise inexact condition if M4 bit 1 is zero and
; 4407 :            result differs in value from original value */
; 4408 :         if ((m4 & 0x04) == 0)

  0021f	8b 44 24 48	 mov	 eax, DWORD PTR m4$[rsp]
  00223	83 e0 04	 and	 eax, 4
  00226	85 c0		 test	 eax, eax
  00228	0f 85 ca 00 00
	00		 jne	 $LN12@s370_load_

; 4409 :         {
; 4410 :             decNumberCompare(&dc, &d1, &d2, &set);

  0022e	4c 8d 4c 24 50	 lea	 r9, QWORD PTR set$[rsp]
  00233	4c 8d 44 24 70	 lea	 r8, QWORD PTR d2$[rsp]
  00238	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00240	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dc$[rsp]
  00248	e8 00 00 00 00	 call	 decNumberCompare

; 4411 :             if (decNumberIsZero(&dc) == 0)

  0024d	b8 02 00 00 00	 mov	 eax, 2
  00252	48 6b c0 00	 imul	 rax, rax, 0
  00256	0f b7 84 04 ca
	00 00 00	 movzx	 eax, WORD PTR dc$[rsp+rax+10]
  0025e	85 c0		 test	 eax, eax
  00260	75 23		 jne	 SHORT $LN22@s370_load_
  00262	83 bc 24 c0 00
	00 00 01	 cmp	 DWORD PTR dc$[rsp], 1
  0026a	75 19		 jne	 SHORT $LN22@s370_load_
  0026c	0f b6 84 24 c8
	00 00 00	 movzx	 eax, BYTE PTR dc$[rsp+8]
  00274	83 e0 70	 and	 eax, 112		; 00000070H
  00277	85 c0		 test	 eax, eax
  00279	75 0a		 jne	 SHORT $LN22@s370_load_
  0027b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  00283	eb 08		 jmp	 SHORT $LN23@s370_load_
$LN22@s370_load_:
  00285	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN23@s370_load_:
  0028d	83 7c 24 34 00	 cmp	 DWORD PTR tv178[rsp], 0
  00292	75 64		 jne	 SHORT $LN13@s370_load_

; 4412 :             {
; 4413 :                 set.status |= DEC_IEEE_854_Inexact;

  00294	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  00298	83 c8 20	 or	 eax, 32			; 00000020H
  0029b	89 44 24 64	 mov	 DWORD PTR set$[rsp+20], eax

; 4414 :                 if (decNumberIsNegative(&dc) == decNumberIsNegative(&d2))

  0029f	0f b6 84 24 c8
	00 00 00	 movzx	 eax, BYTE PTR dc$[rsp+8]
  002a7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002ac	85 c0		 test	 eax, eax
  002ae	74 0a		 je	 SHORT $LN26@s370_load_
  002b0	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv188[rsp], 1
  002b8	eb 08		 jmp	 SHORT $LN27@s370_load_
$LN26@s370_load_:
  002ba	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv188[rsp], 0
$LN27@s370_load_:
  002c2	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  002c7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002cc	85 c0		 test	 eax, eax
  002ce	74 0a		 je	 SHORT $LN24@s370_load_
  002d0	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv187[rsp], 1
  002d8	eb 08		 jmp	 SHORT $LN25@s370_load_
$LN24@s370_load_:
  002da	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN25@s370_load_:
  002e2	8b 44 24 38	 mov	 eax, DWORD PTR tv187[rsp]
  002e6	39 44 24 3c	 cmp	 DWORD PTR tv188[rsp], eax
  002ea	75 0c		 jne	 SHORT $LN14@s370_load_

; 4415 :                     set.status |= DEC_Rounded;

  002ec	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  002f0	0f ba e8 0b	 bts	 eax, 11
  002f4	89 44 24 64	 mov	 DWORD PTR set$[rsp+20], eax
$LN14@s370_load_:
$LN13@s370_load_:
$LN12@s370_load_:

; 4416 :             }
; 4417 :         }
; 4418 :     }

  002f8	eb 4f		 jmp	 SHORT $LN11@s370_load_
$LN10@s370_load_:

; 4419 :     else
; 4420 :     {
; 4421 :         /* Propagate NaN or default infinity */
; 4422 :         decNumberCopy(&d1, &d2);

  002fa	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  002ff	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  00307	e8 00 00 00 00	 call	 decNumberCopy

; 4423 : 
; 4424 :         /* For SNaN, force signaling condition and convert to QNaN */
; 4425 :         if (decNumberIsSNaN(&d2))

  0030c	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00311	83 e0 10	 and	 eax, 16
  00314	85 c0		 test	 eax, eax
  00316	74 31		 je	 SHORT $LN15@s370_load_

; 4426 :         {
; 4427 :             set.status |= DEC_IEEE_854_Invalid_operation;

  00318	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  0031c	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00321	89 44 24 64	 mov	 DWORD PTR set$[rsp+20], eax

; 4428 :             d1.bits &= ~DECSNAN;

  00325	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0032d	83 e0 ef	 and	 eax, -17
  00330	88 84 24 a0 00
	00 00		 mov	 BYTE PTR d1$[rsp+8], al

; 4429 :             d1.bits |= DECNAN;

  00337	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0033f	83 c8 20	 or	 eax, 32			; 00000020H
  00342	88 84 24 a0 00
	00 00		 mov	 BYTE PTR d1$[rsp+8], al
$LN15@s370_load_:
$LN11@s370_load_:

; 4430 :         }
; 4431 :     }
; 4432 : 
; 4433 :     /* Convert result to extended DFP format */
; 4434 :     decimal128FromNumber(&x1, &d1, &set);

  00349	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  0034e	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00356	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR x1$[rsp]
  0035e	e8 00 00 00 00	 call	 decimal128FromNumber

; 4435 : 
; 4436 :     /* Check for exception condition */
; 4437 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00363	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0036b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00370	e8 00 00 00 00	 call	 s370_dfp_status_check
  00375	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4438 : 
; 4439 :     /* Load result into FP register r1 */
; 4440 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  00379	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00381	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR x1$[rsp]
  00389	8b 4c 24 40	 mov	 ecx, DWORD PTR r1$[rsp]
  0038d	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 4441 : 
; 4442 :     /* Raise data exception if error occurred */
; 4443 :     if (dxc != 0)

  00392	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00397	85 c0		 test	 eax, eax
  00399	74 25		 je	 SHORT $LN16@s370_load_

; 4444 :     {
; 4445 :         regs->dxc = dxc;

  0039b	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  003a0	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a8	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4446 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  003ae	ba 07 00 00 00	 mov	 edx, 7
  003b3	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003bb	e8 00 00 00 00	 call	 s370_program_interrupt
$LN16@s370_load_:

; 4447 :     }
; 4448 : 
; 4449 : } /* end DEF_INST(load_fp_int_dfp_ext_reg) */

  003c0	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003c8	48 33 cc	 xor	 rcx, rsp
  003cb	e8 00 00 00 00	 call	 __security_check_cookie
  003d0	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  003d7	c3		 ret	 0
s370_load_fp_int_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
tv170 = 40
tv171 = 44
tv172 = 48
r2$ = 52
r1$ = 56
d$ = 64
x2$ = 104
x1$ = 112
set$ = 120
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
s370_load_and_test_dfp_long_reg PROC

; 4327 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4328 : int             r1, r2;                 /* Values of R fields        */
; 4329 : decimal64       x1, x2;                 /* Long DFP values           */
; 4330 : decNumber       d;                      /* Working decimal number    */
; 4331 : decContext      set;                    /* Working context           */
; 4332 : BYTE            dxc;                    /* Data exception code       */
; 4333 : 
; 4334 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  00055	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_load_
  00078	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_load_

; 4335 : 
; 4336 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4337 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_load_
  000ae	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_load_
  000c5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000ed	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 4338 : 
; 4339 :     /* Initialise the context for long DFP */
; 4340 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0011a	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0011f	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  00124	e8 00 00 00 00	 call	 decContextDefault

; 4341 : 
; 4342 :     /* Load value from FP register r2 */
; 4343 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  00129	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00131	48 8d 54 24 68	 lea	 rdx, QWORD PTR x2$[rsp]
  00136	8b 4c 24 34	 mov	 ecx, DWORD PTR r2$[rsp]
  0013a	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 4344 :     decimal64ToNumber(&x2, &d);

  0013f	48 8d 54 24 40	 lea	 rdx, QWORD PTR d$[rsp]
  00144	48 8d 4c 24 68	 lea	 rcx, QWORD PTR x2$[rsp]
  00149	e8 00 00 00 00	 call	 decimal64ToNumber

; 4345 : 
; 4346 :     /* For SNaN, force signaling condition and convert to QNaN */
; 4347 :     if (decNumberIsSNaN(&d))

  0014e	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  00153	83 e0 10	 and	 eax, 16
  00156	85 c0		 test	 eax, eax
  00158	74 2b		 je	 SHORT $LN8@s370_load_

; 4348 :     {
; 4349 :         set.status |= DEC_IEEE_854_Invalid_operation;

  0015a	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR set$[rsp+20]
  00161	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  00166	89 84 24 8c 00
	00 00		 mov	 DWORD PTR set$[rsp+20], eax

; 4350 :         d.bits &= ~DECSNAN;

  0016d	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  00172	83 e0 ef	 and	 eax, -17
  00175	88 44 24 48	 mov	 BYTE PTR d$[rsp+8], al

; 4351 :         d.bits |= DECNAN;

  00179	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  0017e	83 c8 20	 or	 eax, 32			; 00000020H
  00181	88 44 24 48	 mov	 BYTE PTR d$[rsp+8], al
$LN8@s370_load_:

; 4352 :     }
; 4353 : 
; 4354 :     /* Check for exception condition */
; 4355 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00185	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0018d	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  00192	e8 00 00 00 00	 call	 s370_dfp_status_check
  00197	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4356 : 
; 4357 :     /* Reencode value and load into FP register r1 */
; 4358 :     decimal64FromNumber(&x1, &d, &set);

  0019b	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  001a0	48 8d 54 24 40	 lea	 rdx, QWORD PTR d$[rsp]
  001a5	48 8d 4c 24 70	 lea	 rcx, QWORD PTR x1$[rsp]
  001aa	e8 00 00 00 00	 call	 decimal64FromNumber

; 4359 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  001af	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001b7	48 8d 54 24 70	 lea	 rdx, QWORD PTR x1$[rsp]
  001bc	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  001c0	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 4360 : 
; 4361 :     /* Set condition code */
; 4362 :     regs->psw.cc = decNumberIsNaN(&d) ? 3 :

  001c5	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  001ca	83 e0 30	 and	 eax, 48			; 00000030H
  001cd	85 c0		 test	 eax, eax
  001cf	74 0a		 je	 SHORT $LN15@s370_load_
  001d1	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv172[rsp], 3
  001d9	eb 5f		 jmp	 SHORT $LN16@s370_load_
$LN15@s370_load_:
  001db	b8 02 00 00 00	 mov	 eax, 2
  001e0	48 6b c0 00	 imul	 rax, rax, 0
  001e4	0f b7 44 04 4a	 movzx	 eax, WORD PTR d$[rsp+rax+10]
  001e9	85 c0		 test	 eax, eax
  001eb	75 1d		 jne	 SHORT $LN11@s370_load_
  001ed	83 7c 24 40 01	 cmp	 DWORD PTR d$[rsp], 1
  001f2	75 16		 jne	 SHORT $LN11@s370_load_
  001f4	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  001f9	83 e0 70	 and	 eax, 112		; 00000070H
  001fc	85 c0		 test	 eax, eax
  001fe	75 0a		 jne	 SHORT $LN11@s370_load_
  00200	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
  00208	eb 28		 jmp	 SHORT $LN14@s370_load_
$LN11@s370_load_:
  0020a	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  0020f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00214	85 c0		 test	 eax, eax
  00216	74 0a		 je	 SHORT $LN12@s370_load_
  00218	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv170[rsp], 1
  00220	eb 08		 jmp	 SHORT $LN13@s370_load_
$LN12@s370_load_:
  00222	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv170[rsp], 2
$LN13@s370_load_:
  0022a	8b 44 24 28	 mov	 eax, DWORD PTR tv170[rsp]
  0022e	89 44 24 2c	 mov	 DWORD PTR tv171[rsp], eax
$LN14@s370_load_:
  00232	8b 44 24 2c	 mov	 eax, DWORD PTR tv171[rsp]
  00236	89 44 24 30	 mov	 DWORD PTR tv172[rsp], eax
$LN16@s370_load_:
  0023a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00242	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv172[rsp]
  00247	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 4363 :                    decNumberIsZero(&d) ? 0 :
; 4364 :                    decNumberIsNegative(&d) ? 1 : 2;
; 4365 : 
; 4366 :     /* Raise data exception if error occurred */
; 4367 :     if (dxc != 0)

  0024a	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0024f	85 c0		 test	 eax, eax
  00251	74 25		 je	 SHORT $LN9@s370_load_

; 4368 :     {
; 4369 :         regs->dxc = dxc;

  00253	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00258	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00260	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4370 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00266	ba 07 00 00 00	 mov	 edx, 7
  0026b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00273	e8 00 00 00 00	 call	 s370_program_interrupt
$LN9@s370_load_:

; 4371 :     }
; 4372 : 
; 4373 : } /* end DEF_INST(load_and_test_dfp_long_reg) */

  00278	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00280	48 33 cc	 xor	 rcx, rsp
  00283	e8 00 00 00 00	 call	 __security_check_cookie
  00288	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0028f	c3		 ret	 0
s370_load_and_test_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
tv177 = 48
tv178 = 52
tv179 = 56
d$ = 64
set$ = 104
x2$ = 136
x1$ = 152
__$ArrayPad$ = 168
inst$ = 192
regs$ = 200
s370_load_and_test_dfp_ext_reg PROC

; 4273 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4274 : int             r1, r2;                 /* Values of R fields        */
; 4275 : decimal128      x1, x2;                 /* Extended DFP values       */
; 4276 : decNumber       d;                      /* Working decimal number    */
; 4277 : decContext      set;                    /* Working context           */
; 4278 : BYTE            dxc;                    /* Data exception code       */
; 4279 : 
; 4280 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  00055	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_load_
  00078	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_load_

; 4281 : 
; 4282 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4283 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_load_
  000ae	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_load_
  000c5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000ed	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_load_:

; 4284 :     DFPREGPAIR2_CHECK(r1, r2, regs);

  0011a	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  0011e	83 e0 02	 and	 eax, 2
  00121	85 c0		 test	 eax, eax
  00123	75 0b		 jne	 SHORT $LN9@s370_load_
  00125	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00129	83 e0 02	 and	 eax, 2
  0012c	85 c0		 test	 eax, eax
  0012e	74 1b		 je	 SHORT $LN8@s370_load_
$LN9@s370_load_:
  00130	ba 06 00 00 00	 mov	 edx, 6
  00135	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:

; 4285 : 
; 4286 :     /* Initialise the context for extended DFP */
; 4287 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0014b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00150	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00155	e8 00 00 00 00	 call	 decContextDefault

; 4288 : 
; 4289 :     /* Load value from FP register r2 */
; 4290 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  0015a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00162	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  0016a	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  0016e	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 4291 :     decimal128ToNumber(&x2, &d);

  00173	48 8d 54 24 40	 lea	 rdx, QWORD PTR d$[rsp]
  00178	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  00180	e8 00 00 00 00	 call	 decimal128ToNumber

; 4292 : 
; 4293 :     /* For SNaN, force signaling condition and convert to QNaN */
; 4294 :     if (decNumberIsSNaN(&d))

  00185	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  0018a	83 e0 10	 and	 eax, 16
  0018d	85 c0		 test	 eax, eax
  0018f	74 25		 je	 SHORT $LN10@s370_load_

; 4295 :     {
; 4296 :         set.status |= DEC_IEEE_854_Invalid_operation;

  00191	8b 44 24 7c	 mov	 eax, DWORD PTR set$[rsp+20]
  00195	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  0019a	89 44 24 7c	 mov	 DWORD PTR set$[rsp+20], eax

; 4297 :         d.bits &= ~DECSNAN;

  0019e	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  001a3	83 e0 ef	 and	 eax, -17
  001a6	88 44 24 48	 mov	 BYTE PTR d$[rsp+8], al

; 4298 :         d.bits |= DECNAN;

  001aa	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  001af	83 c8 20	 or	 eax, 32			; 00000020H
  001b2	88 44 24 48	 mov	 BYTE PTR d$[rsp+8], al
$LN10@s370_load_:

; 4299 :     }
; 4300 : 
; 4301 :     /* Check for exception condition */
; 4302 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  001b6	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001be	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  001c3	e8 00 00 00 00	 call	 s370_dfp_status_check
  001c8	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 4303 : 
; 4304 :     /* Reencode value and load into FP register r1 */
; 4305 :     decimal128FromNumber(&x1, &d, &set);

  001cc	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  001d1	48 8d 54 24 40	 lea	 rdx, QWORD PTR d$[rsp]
  001d6	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR x1$[rsp]
  001de	e8 00 00 00 00	 call	 decimal128FromNumber

; 4306 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  001e3	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001eb	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR x1$[rsp]
  001f3	8b 4c 24 2c	 mov	 ecx, DWORD PTR r1$[rsp]
  001f7	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 4307 : 
; 4308 :     /* Set condition code */
; 4309 :     regs->psw.cc = decNumberIsNaN(&d) ? 3 :

  001fc	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  00201	83 e0 30	 and	 eax, 48			; 00000030H
  00204	85 c0		 test	 eax, eax
  00206	74 0a		 je	 SHORT $LN17@s370_load_
  00208	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv179[rsp], 3
  00210	eb 5f		 jmp	 SHORT $LN18@s370_load_
$LN17@s370_load_:
  00212	b8 02 00 00 00	 mov	 eax, 2
  00217	48 6b c0 00	 imul	 rax, rax, 0
  0021b	0f b7 44 04 4a	 movzx	 eax, WORD PTR d$[rsp+rax+10]
  00220	85 c0		 test	 eax, eax
  00222	75 1d		 jne	 SHORT $LN13@s370_load_
  00224	83 7c 24 40 01	 cmp	 DWORD PTR d$[rsp], 1
  00229	75 16		 jne	 SHORT $LN13@s370_load_
  0022b	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  00230	83 e0 70	 and	 eax, 112		; 00000070H
  00233	85 c0		 test	 eax, eax
  00235	75 0a		 jne	 SHORT $LN13@s370_load_
  00237	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
  0023f	eb 28		 jmp	 SHORT $LN16@s370_load_
$LN13@s370_load_:
  00241	0f b6 44 24 48	 movzx	 eax, BYTE PTR d$[rsp+8]
  00246	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0024b	85 c0		 test	 eax, eax
  0024d	74 0a		 je	 SHORT $LN14@s370_load_
  0024f	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv177[rsp], 1
  00257	eb 08		 jmp	 SHORT $LN15@s370_load_
$LN14@s370_load_:
  00259	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv177[rsp], 2
$LN15@s370_load_:
  00261	8b 44 24 30	 mov	 eax, DWORD PTR tv177[rsp]
  00265	89 44 24 34	 mov	 DWORD PTR tv178[rsp], eax
$LN16@s370_load_:
  00269	8b 44 24 34	 mov	 eax, DWORD PTR tv178[rsp]
  0026d	89 44 24 38	 mov	 DWORD PTR tv179[rsp], eax
$LN18@s370_load_:
  00271	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00279	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv179[rsp]
  0027e	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 4310 :                    decNumberIsZero(&d) ? 0 :
; 4311 :                    decNumberIsNegative(&d) ? 1 : 2;
; 4312 : 
; 4313 :     /* Raise data exception if error occurred */
; 4314 :     if (dxc != 0)

  00281	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00286	85 c0		 test	 eax, eax
  00288	74 25		 je	 SHORT $LN11@s370_load_

; 4315 :     {
; 4316 :         regs->dxc = dxc;

  0028a	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0028f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00297	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 4317 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0029d	ba 07 00 00 00	 mov	 edx, 7
  002a2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002aa	e8 00 00 00 00	 call	 s370_program_interrupt
$LN11@s370_load_:

; 4318 :     }
; 4319 : 
; 4320 : } /* end DEF_INST(load_and_test_dfp_ext_reg) */

  002af	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002b7	48 33 cc	 xor	 rcx, rsp
  002ba	e8 00 00 00 00	 call	 __security_check_cookie
  002bf	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  002c6	c3		 ret	 0
s370_load_and_test_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
bexp$ = 40
r2$ = 48
r3$ = 52
r1$ = 56
x3$ = 64
x1$ = 72
d$ = 80
set$ = 120
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
s370_insert_biased_exponent_fix64_to_dfp_long_reg PROC

; 4203 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4204 : int             r1, r2, r3;             /* Values of R fields        */
; 4205 : decimal64       x1, x3;                 /* Long DFP values           */
; 4206 : decNumber       d;                      /* Working decimal number    */
; 4207 : decContext      set;                    /* Working context           */
; 4208 : S64             bexp;                   /* Biased exponent           */
; 4209 : 
; 4210 :     RRF_M(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_inser:
  00062	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_inser
  00085	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_inser:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_inser

; 4211 : 
; 4212 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4213 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_inser
  000bb	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_inser
  000d2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_inser
$LN7@s370_inser:
  000fa	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_inser:

; 4214 : 
; 4215 :     /* Initialise the context for long DFP */
; 4216 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00127	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0012c	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  00131	e8 00 00 00 00	 call	 decContextDefault

; 4217 : 
; 4218 :     /* Load biased exponent from general register r2 */
; 4219 :     bexp = (S64)(regs->GR(r2));

  00136	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  0013b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00143	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0014a	48 89 44 24 28	 mov	 QWORD PTR bexp$[rsp], rax

; 4220 : 
; 4221 :     /* Load DFP long number from FP register r3 */
; 4222 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  0014f	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00157	48 8d 54 24 40	 lea	 rdx, QWORD PTR x3$[rsp]
  0015c	8b 4c 24 34	 mov	 ecx, DWORD PTR r3$[rsp]
  00160	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 4223 : 
; 4224 :     /* Insert biased exponent into number */
; 4225 :     if (bexp > DECIMAL64_Ehigh || bexp == -2 || bexp <= -4)

  00165	48 81 7c 24 28
	ff 02 00 00	 cmp	 QWORD PTR bexp$[rsp], 767 ; 000002ffH
  0016e	7f 10		 jg	 SHORT $LN10@s370_inser
  00170	48 83 7c 24 28
	fe		 cmp	 QWORD PTR bexp$[rsp], -2
  00176	74 08		 je	 SHORT $LN10@s370_inser
  00178	48 83 7c 24 28
	fc		 cmp	 QWORD PTR bexp$[rsp], -4
  0017e	7f 41		 jg	 SHORT $LN8@s370_inser
$LN10@s370_inser:

; 4226 :     {
; 4227 :         /* Result is a QNaN with re-encoded coefficient-continuation */
; 4228 :         dfp64_clear_cf_and_bxcf(&x3);

  00180	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00185	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 4229 :         decimal64ToNumber(&x3, &d);

  0018a	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  0018f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00194	e8 00 00 00 00	 call	 decimal64ToNumber

; 4230 :         decimal64FromNumber(&x1, &d, &set);

  00199	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  0019e	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  001a3	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  001a8	e8 00 00 00 00	 call	 decimal64FromNumber

; 4231 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  001ad	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  001b2	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  001b7	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4232 :     }

  001bc	e9 f2 00 00 00	 jmp	 $LN9@s370_inser
$LN8@s370_inser:

; 4233 :     else if (bexp == -3)

  001c1	48 83 7c 24 28
	fd		 cmp	 QWORD PTR bexp$[rsp], -3
  001c7	75 41		 jne	 SHORT $LN11@s370_inser

; 4234 :     {
; 4235 :         /* Result is a SNaN with re-encoded coefficient-continuation */
; 4236 :         dfp64_clear_cf_and_bxcf(&x3);

  001c9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  001ce	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 4237 :         decimal64ToNumber(&x3, &d);

  001d3	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  001d8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  001dd	e8 00 00 00 00	 call	 decimal64ToNumber

; 4238 :         decimal64FromNumber(&x1, &d, &set);

  001e2	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  001e7	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  001ec	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  001f1	e8 00 00 00 00	 call	 decimal64FromNumber

; 4239 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  001f6	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  001fb	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00200	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4240 :     }

  00205	e9 a9 00 00 00	 jmp	 $LN12@s370_inser
$LN11@s370_inser:

; 4241 :     else if (bexp == -1) /* Infinity */

  0020a	48 83 7c 24 28
	ff		 cmp	 QWORD PTR bexp$[rsp], -1
  00210	75 3e		 jne	 SHORT $LN13@s370_inser

; 4242 :     {
; 4243 :         /* Result is Infinity with re-encoded coefficient-continuation */
; 4244 :         dfp64_clear_cf_and_bxcf(&x3);

  00212	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00217	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 4245 :         decimal64ToNumber(&x3, &d);

  0021c	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  00221	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00226	e8 00 00 00 00	 call	 decimal64ToNumber

; 4246 :         decimal64FromNumber(&x1, &d, &set);

  0022b	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  00230	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  00235	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  0023a	e8 00 00 00 00	 call	 decimal64FromNumber

; 4247 :         dfp64_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  0023f	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00244	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00249	e8 00 00 00 00	 call	 dfp64_set_cf_and_bxcf

; 4248 :     }

  0024e	eb 63		 jmp	 SHORT $LN14@s370_inser
$LN13@s370_inser:

; 4249 :     else
; 4250 :     {
; 4251 :         decimal64ToNumber(&x3, &d);

  00250	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  00255	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  0025a	e8 00 00 00 00	 call	 decimal64ToNumber

; 4252 :         /* Clear CF and BXCF if source is Infinity or NaN */
; 4253 :         if (decNumberIsInfinite(&d) || decNumberIsNaN(&d))

  0025f	0f b6 44 24 58	 movzx	 eax, BYTE PTR d$[rsp+8]
  00264	83 e0 40	 and	 eax, 64			; 00000040H
  00267	85 c0		 test	 eax, eax
  00269	75 0c		 jne	 SHORT $LN16@s370_inser
  0026b	0f b6 44 24 58	 movzx	 eax, BYTE PTR d$[rsp+8]
  00270	83 e0 30	 and	 eax, 48			; 00000030H
  00273	85 c0		 test	 eax, eax
  00275	74 19		 je	 SHORT $LN15@s370_inser
$LN16@s370_inser:

; 4254 :         {
; 4255 :             dfp64_clear_cf_and_bxcf(&x3);

  00277	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  0027c	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 4256 :             decimal64ToNumber(&x3, &d);

  00281	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  00286	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  0028b	e8 00 00 00 00	 call	 decimal64ToNumber
$LN15@s370_inser:

; 4257 :         }
; 4258 :         /* Update exponent and re-encode coefficient-continuation */
; 4259 :         d.exponent = bexp - DECIMAL64_Bias;

  00290	48 8b 44 24 28	 mov	 rax, QWORD PTR bexp$[rsp]
  00295	48 2d 8e 01 00
	00		 sub	 rax, 398		; 0000018eH
  0029b	89 44 24 54	 mov	 DWORD PTR d$[rsp+4], eax

; 4260 :         decimal64FromNumber(&x1, &d, &set);

  0029f	4c 8d 44 24 78	 lea	 r8, QWORD PTR set$[rsp]
  002a4	48 8d 54 24 50	 lea	 rdx, QWORD PTR d$[rsp]
  002a9	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  002ae	e8 00 00 00 00	 call	 decimal64FromNumber
$LN14@s370_inser:
$LN12@s370_inser:
$LN9@s370_inser:

; 4261 :     }
; 4262 : 
; 4263 :     /* Load result into FP register r1 */
; 4264 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  002b3	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002bb	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  002c0	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  002c4	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 4265 : 
; 4266 : } /* end DEF_INST(insert_biased_exponent_fix64_to_dfp_long_reg) */

  002c9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002d1	48 33 cc	 xor	 rcx, rsp
  002d4	e8 00 00 00 00	 call	 __security_check_cookie
  002d9	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002e0	c3		 ret	 0
s370_insert_biased_exponent_fix64_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
bexp$ = 40
r3$ = 48
r1$ = 52
r2$ = 56
x3$ = 64
x1$ = 80
d$ = 96
set$ = 136
__$ArrayPad$ = 168
inst$ = 192
regs$ = 200
s370_insert_biased_exponent_fix64_to_dfp_ext_reg PROC

; 4132 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4133 : int             r1, r2, r3;             /* Values of R fields        */
; 4134 : decimal128      x1, x3;                 /* Extended DFP values       */
; 4135 : decNumber       d;                      /* Working decimal number    */
; 4136 : decContext      set;                    /* Working context           */
; 4137 : S64             bexp;                   /* Biased exponent           */
; 4138 : 
; 4139 :     RRF_M(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_inser:
  00062	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_inser
  00085	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_inser:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_inser

; 4140 : 
; 4141 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4142 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_inser
  000bb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_inser
  000d2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_inser
$LN7@s370_inser:
  000fa	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_inser:

; 4143 :     DFPREGPAIR2_CHECK(r1, r3, regs);

  00127	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0012b	83 e0 02	 and	 eax, 2
  0012e	85 c0		 test	 eax, eax
  00130	75 0b		 jne	 SHORT $LN9@s370_inser
  00132	8b 44 24 30	 mov	 eax, DWORD PTR r3$[rsp]
  00136	83 e0 02	 and	 eax, 2
  00139	85 c0		 test	 eax, eax
  0013b	74 1b		 je	 SHORT $LN8@s370_inser
$LN9@s370_inser:
  0013d	ba 06 00 00 00	 mov	 edx, 6
  00142	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00152	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_inser:

; 4144 : 
; 4145 :     /* Initialise the context for extended DFP */
; 4146 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00158	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0015d	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00165	e8 00 00 00 00	 call	 decContextDefault

; 4147 : 
; 4148 :     /* Load biased exponent from general register r2 */
; 4149 :     bexp = (S64)(regs->GR(r2));

  0016a	48 63 44 24 38	 movsxd	 rax, DWORD PTR r2$[rsp]
  0016f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0017e	48 89 44 24 28	 mov	 QWORD PTR bexp$[rsp], rax

; 4150 : 
; 4151 :     /* Load DFP extended number from FP register r3 */
; 4152 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  00183	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0018b	48 8d 54 24 40	 lea	 rdx, QWORD PTR x3$[rsp]
  00190	8b 4c 24 30	 mov	 ecx, DWORD PTR r3$[rsp]
  00194	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 4153 : 
; 4154 :     /* Insert biased exponent into number */
; 4155 :     if (bexp > DECIMAL128_Ehigh || bexp == -2 || bexp <= -4)

  00199	48 81 7c 24 28
	ff 2f 00 00	 cmp	 QWORD PTR bexp$[rsp], 12287 ; 00002fffH
  001a2	7f 10		 jg	 SHORT $LN12@s370_inser
  001a4	48 83 7c 24 28
	fe		 cmp	 QWORD PTR bexp$[rsp], -2
  001aa	74 08		 je	 SHORT $LN12@s370_inser
  001ac	48 83 7c 24 28
	fc		 cmp	 QWORD PTR bexp$[rsp], -4
  001b2	7f 44		 jg	 SHORT $LN10@s370_inser
$LN12@s370_inser:

; 4156 :     {
; 4157 :         /* Result is a QNaN with re-encoded coefficient-continuation */
; 4158 :         dfp128_clear_cf_and_bxcf(&x3);

  001b4	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  001b9	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 4159 :         decimal128ToNumber(&x3, &d);

  001be	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  001c3	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  001c8	e8 00 00 00 00	 call	 decimal128ToNumber

; 4160 :         decimal128FromNumber(&x1, &d, &set);

  001cd	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  001d5	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  001da	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  001df	e8 00 00 00 00	 call	 decimal128FromNumber

; 4161 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_QNAN);

  001e4	ba 3e 00 00 00	 mov	 edx, 62			; 0000003eH
  001e9	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  001ee	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf

; 4162 :     }

  001f3	e9 fb 00 00 00	 jmp	 $LN11@s370_inser
$LN10@s370_inser:

; 4163 :     else if (bexp == -3)

  001f8	48 83 7c 24 28
	fd		 cmp	 QWORD PTR bexp$[rsp], -3
  001fe	75 44		 jne	 SHORT $LN13@s370_inser

; 4164 :     {
; 4165 :         /* Result is a SNaN with re-encoded coefficient-continuation */
; 4166 :         dfp128_clear_cf_and_bxcf(&x3);

  00200	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00205	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 4167 :         decimal128ToNumber(&x3, &d);

  0020a	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  0020f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00214	e8 00 00 00 00	 call	 decimal128ToNumber

; 4168 :         decimal128FromNumber(&x1, &d, &set);

  00219	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  00221	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  00226	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  0022b	e8 00 00 00 00	 call	 decimal128FromNumber

; 4169 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_SNAN);

  00230	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  00235	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  0023a	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf

; 4170 :     }

  0023f	e9 af 00 00 00	 jmp	 $LN14@s370_inser
$LN13@s370_inser:

; 4171 :     else if (bexp == -1) /* Infinity */

  00244	48 83 7c 24 28
	ff		 cmp	 QWORD PTR bexp$[rsp], -1
  0024a	75 41		 jne	 SHORT $LN15@s370_inser

; 4172 :     {
; 4173 :         /* Result is Infinity with re-encoded coefficient-continuation */
; 4174 :         dfp128_clear_cf_and_bxcf(&x3);

  0024c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00251	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 4175 :         decimal128ToNumber(&x3, &d);

  00256	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  0025b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00260	e8 00 00 00 00	 call	 decimal128ToNumber

; 4176 :         decimal128FromNumber(&x1, &d, &set);

  00265	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  0026d	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  00272	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  00277	e8 00 00 00 00	 call	 decimal128FromNumber

; 4177 :         dfp128_set_cf_and_bxcf(&x1, DFP_CFS_INF);

  0027c	ba 3c 00 00 00	 mov	 edx, 60			; 0000003cH
  00281	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  00286	e8 00 00 00 00	 call	 dfp128_set_cf_and_bxcf

; 4178 :     }

  0028b	eb 66		 jmp	 SHORT $LN16@s370_inser
$LN15@s370_inser:

; 4179 :     else
; 4180 :     {
; 4181 :         decimal128ToNumber(&x3, &d);

  0028d	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  00292	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00297	e8 00 00 00 00	 call	 decimal128ToNumber

; 4182 :         /* Clear CF and BXCF if source is Infinity or NaN */
; 4183 :         if (decNumberIsInfinite(&d) || decNumberIsNaN(&d))

  0029c	0f b6 44 24 68	 movzx	 eax, BYTE PTR d$[rsp+8]
  002a1	83 e0 40	 and	 eax, 64			; 00000040H
  002a4	85 c0		 test	 eax, eax
  002a6	75 0c		 jne	 SHORT $LN18@s370_inser
  002a8	0f b6 44 24 68	 movzx	 eax, BYTE PTR d$[rsp+8]
  002ad	83 e0 30	 and	 eax, 48			; 00000030H
  002b0	85 c0		 test	 eax, eax
  002b2	74 19		 je	 SHORT $LN17@s370_inser
$LN18@s370_inser:

; 4184 :         {
; 4185 :             dfp128_clear_cf_and_bxcf(&x3);

  002b4	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  002b9	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 4186 :             decimal128ToNumber(&x3, &d);

  002be	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  002c3	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  002c8	e8 00 00 00 00	 call	 decimal128ToNumber
$LN17@s370_inser:

; 4187 :         }
; 4188 :         /* Update exponent and re-encode coefficient-continuation */
; 4189 :         d.exponent = bexp - DECIMAL128_Bias;

  002cd	48 8b 44 24 28	 mov	 rax, QWORD PTR bexp$[rsp]
  002d2	48 2d 20 18 00
	00		 sub	 rax, 6176		; 00001820H
  002d8	89 44 24 64	 mov	 DWORD PTR d$[rsp+4], eax

; 4190 :         decimal128FromNumber(&x1, &d, &set);

  002dc	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  002e4	48 8d 54 24 60	 lea	 rdx, QWORD PTR d$[rsp]
  002e9	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  002ee	e8 00 00 00 00	 call	 decimal128FromNumber
$LN16@s370_inser:
$LN14@s370_inser:
$LN11@s370_inser:

; 4191 :     }
; 4192 : 
; 4193 :     /* Load result into FP register r1 */
; 4194 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  002f3	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002fb	48 8d 54 24 50	 lea	 rdx, QWORD PTR x1$[rsp]
  00300	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00304	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 4195 : 
; 4196 : } /* end DEF_INST(insert_biased_exponent_fix64_to_dfp_ext_reg) */

  00309	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00311	48 33 cc	 xor	 rcx, rsp
  00314	e8 00 00 00 00	 call	 __security_check_cookie
  00319	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00320	c3		 ret	 0
s370_insert_biased_exponent_fix64_to_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
digits$ = 40
r2$ = 48
r1$ = 52
x2$ = 56
d2$ = 64
set$ = 104
__$ArrayPad$ = 136
inst$ = 160
regs$ = 168
s370_extract_significance_dfp_long_reg PROC

; 4089 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4090 : int             r1, r2;                 /* Values of R fields        */
; 4091 : decimal64       x2;                     /* Long DFP value            */
; 4092 : decNumber       d2;                     /* Working decimal number    */
; 4093 : decContext      set;                    /* Working context           */
; 4094 : S64             digits;                 /* Number of decimal digits  */
; 4095 : 
; 4096 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_extra:
  00055	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_extra
  00078	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_extra:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_extra

; 4097 : 
; 4098 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4099 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_extra
  000ae	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_extra
  000c5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_extra
$LN7@s370_extra:
  000ed	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_extra:

; 4100 : 
; 4101 :     /* Initialise the context for long DFP */
; 4102 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0011a	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0011f	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00124	e8 00 00 00 00	 call	 decContextDefault

; 4103 : 
; 4104 :     /* Load DFP long number from FP register r2 */
; 4105 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  00129	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00131	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  00136	8b 4c 24 30	 mov	 ecx, DWORD PTR r2$[rsp]
  0013a	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 4106 : 
; 4107 :     /* Convert to internal decimal number format */
; 4108 :     decimal64ToNumber(&x2, &d2);

  0013f	48 8d 54 24 40	 lea	 rdx, QWORD PTR d2$[rsp]
  00144	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00149	e8 00 00 00 00	 call	 decimal64ToNumber

; 4109 : 
; 4110 :     /* Calculate number of significant digits */
; 4111 :     if (decNumberIsZero(&d2))

  0014e	b8 02 00 00 00	 mov	 eax, 2
  00153	48 6b c0 00	 imul	 rax, rax, 0
  00157	0f b7 44 04 4a	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  0015c	85 c0		 test	 eax, eax
  0015e	75 1e		 jne	 SHORT $LN8@s370_extra
  00160	83 7c 24 40 01	 cmp	 DWORD PTR d2$[rsp], 1
  00165	75 17		 jne	 SHORT $LN8@s370_extra
  00167	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0016c	83 e0 70	 and	 eax, 112		; 00000070H
  0016f	85 c0		 test	 eax, eax
  00171	75 0b		 jne	 SHORT $LN8@s370_extra

; 4112 :         digits = 0;

  00173	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR digits$[rsp], 0
  0017c	eb 4f		 jmp	 SHORT $LN9@s370_extra
$LN8@s370_extra:

; 4113 :     else if (decNumberIsInfinite(&d2))

  0017e	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00183	83 e0 40	 and	 eax, 64			; 00000040H
  00186	85 c0		 test	 eax, eax
  00188	74 0b		 je	 SHORT $LN10@s370_extra

; 4114 :         digits = -1;

  0018a	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR digits$[rsp], -1
  00193	eb 38		 jmp	 SHORT $LN11@s370_extra
$LN10@s370_extra:

; 4115 :     else if (decNumberIsQNaN(&d2))

  00195	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0019a	83 e0 20	 and	 eax, 32			; 00000020H
  0019d	85 c0		 test	 eax, eax
  0019f	74 0b		 je	 SHORT $LN12@s370_extra

; 4116 :         digits = -2;

  001a1	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR digits$[rsp], -2
  001aa	eb 21		 jmp	 SHORT $LN13@s370_extra
$LN12@s370_extra:

; 4117 :     else if (decNumberIsSNaN(&d2))

  001ac	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001b1	83 e0 10	 and	 eax, 16
  001b4	85 c0		 test	 eax, eax
  001b6	74 0b		 je	 SHORT $LN14@s370_extra

; 4118 :         digits = -3;

  001b8	48 c7 44 24 28
	fd ff ff ff	 mov	 QWORD PTR digits$[rsp], -3
  001c1	eb 0a		 jmp	 SHORT $LN15@s370_extra
$LN14@s370_extra:

; 4119 :     else
; 4120 :         digits = d2.digits;

  001c3	48 63 44 24 40	 movsxd	 rax, DWORD PTR d2$[rsp]
  001c8	48 89 44 24 28	 mov	 QWORD PTR digits$[rsp], rax
$LN15@s370_extra:
$LN13@s370_extra:
$LN11@s370_extra:
$LN9@s370_extra:

; 4121 : 
; 4122 :     /* Load result into general register r1 */
; 4123 :     regs->GR(r1) = digits;

  001cd	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  001d2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001da	8b 54 24 28	 mov	 edx, DWORD PTR digits$[rsp]
  001de	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 4124 : 
; 4125 : } /* end DEF_INST(extract_significance_dfp_long_reg) */

  001e5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001ed	48 33 cc	 xor	 rcx, rsp
  001f0	e8 00 00 00 00	 call	 __security_check_cookie
  001f5	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001fc	c3		 ret	 0
s370_extract_significance_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
digits$ = 40
r1$ = 48
d2$ = 56
x2$ = 96
set$ = 112
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s370_extract_significance_dfp_ext_reg PROC

; 4045 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4046 : int             r1, r2;                 /* Values of R fields        */
; 4047 : decimal128      x2;                     /* Extended DFP value        */
; 4048 : decNumber       d2;                     /* Working decimal number    */
; 4049 : decContext      set;                    /* Working context           */
; 4050 : S64             digits;                 /* Number of decimal digits  */
; 4051 : 
; 4052 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_extra:
  00055	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_extra
  00078	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_extra:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_extra

; 4053 : 
; 4054 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4055 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_extra
  000ae	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_extra
  000c5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_extra
$LN7@s370_extra:
  000ed	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_extra:

; 4056 :     DFPREGPAIR_CHECK(r2, regs);

  0011a	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  0011e	83 e0 02	 and	 eax, 2
  00121	85 c0		 test	 eax, eax
  00123	74 1b		 je	 SHORT $LN8@s370_extra
  00125	ba 06 00 00 00	 mov	 edx, 6
  0012a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_extra:

; 4057 : 
; 4058 :     /* Initialise the context for extended DFP */
; 4059 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00140	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00145	48 8d 4c 24 70	 lea	 rcx, QWORD PTR set$[rsp]
  0014a	e8 00 00 00 00	 call	 decContextDefault

; 4060 : 
; 4061 :     /* Load DFP extended number from FP register r2 */
; 4062 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  0014f	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00157	48 8d 54 24 60	 lea	 rdx, QWORD PTR x2$[rsp]
  0015c	8b 4c 24 24	 mov	 ecx, DWORD PTR r2$[rsp]
  00160	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 4063 : 
; 4064 :     /* Convert to internal decimal number format */
; 4065 :     decimal128ToNumber(&x2, &d2);

  00165	48 8d 54 24 38	 lea	 rdx, QWORD PTR d2$[rsp]
  0016a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR x2$[rsp]
  0016f	e8 00 00 00 00	 call	 decimal128ToNumber

; 4066 : 
; 4067 :     /* Calculate number of significant digits */
; 4068 :     if (decNumberIsZero(&d2))

  00174	b8 02 00 00 00	 mov	 eax, 2
  00179	48 6b c0 00	 imul	 rax, rax, 0
  0017d	0f b7 44 04 42	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  00182	85 c0		 test	 eax, eax
  00184	75 1e		 jne	 SHORT $LN9@s370_extra
  00186	83 7c 24 38 01	 cmp	 DWORD PTR d2$[rsp], 1
  0018b	75 17		 jne	 SHORT $LN9@s370_extra
  0018d	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00192	83 e0 70	 and	 eax, 112		; 00000070H
  00195	85 c0		 test	 eax, eax
  00197	75 0b		 jne	 SHORT $LN9@s370_extra

; 4069 :         digits = 0;

  00199	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR digits$[rsp], 0
  001a2	eb 4f		 jmp	 SHORT $LN10@s370_extra
$LN9@s370_extra:

; 4070 :     else if (decNumberIsInfinite(&d2))

  001a4	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001a9	83 e0 40	 and	 eax, 64			; 00000040H
  001ac	85 c0		 test	 eax, eax
  001ae	74 0b		 je	 SHORT $LN11@s370_extra

; 4071 :         digits = -1;

  001b0	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR digits$[rsp], -1
  001b9	eb 38		 jmp	 SHORT $LN12@s370_extra
$LN11@s370_extra:

; 4072 :     else if (decNumberIsQNaN(&d2))

  001bb	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001c0	83 e0 20	 and	 eax, 32			; 00000020H
  001c3	85 c0		 test	 eax, eax
  001c5	74 0b		 je	 SHORT $LN13@s370_extra

; 4073 :         digits = -2;

  001c7	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR digits$[rsp], -2
  001d0	eb 21		 jmp	 SHORT $LN14@s370_extra
$LN13@s370_extra:

; 4074 :     else if (decNumberIsSNaN(&d2))

  001d2	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001d7	83 e0 10	 and	 eax, 16
  001da	85 c0		 test	 eax, eax
  001dc	74 0b		 je	 SHORT $LN15@s370_extra

; 4075 :         digits = -3;

  001de	48 c7 44 24 28
	fd ff ff ff	 mov	 QWORD PTR digits$[rsp], -3
  001e7	eb 0a		 jmp	 SHORT $LN16@s370_extra
$LN15@s370_extra:

; 4076 :     else
; 4077 :         digits = d2.digits;

  001e9	48 63 44 24 38	 movsxd	 rax, DWORD PTR d2$[rsp]
  001ee	48 89 44 24 28	 mov	 QWORD PTR digits$[rsp], rax
$LN16@s370_extra:
$LN14@s370_extra:
$LN12@s370_extra:
$LN10@s370_extra:

; 4078 : 
; 4079 :     /* Load result into general register r1 */
; 4080 :     regs->GR(r1) = digits;

  001f3	48 63 44 24 30	 movsxd	 rax, DWORD PTR r1$[rsp]
  001f8	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00200	8b 54 24 28	 mov	 edx, DWORD PTR digits$[rsp]
  00204	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 4081 : 
; 4082 : } /* end DEF_INST(extract_significance_dfp_ext_reg) */

  0020b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00213	48 33 cc	 xor	 rcx, rsp
  00216	e8 00 00 00 00	 call	 __security_check_cookie
  0021b	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00222	c3		 ret	 0
s370_extract_significance_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
exponent$ = 40
r2$ = 48
r1$ = 52
x2$ = 56
d2$ = 64
set$ = 104
__$ArrayPad$ = 136
inst$ = 160
regs$ = 168
s370_extract_biased_exponent_dfp_long_to_fix64_reg PROC

; 4004 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4005 : int             r1, r2;                 /* Values of R fields        */
; 4006 : decimal64       x2;                     /* Long DFP value            */
; 4007 : decNumber       d2;                     /* Working decimal number    */
; 4008 : decContext      set;                    /* Working context           */
; 4009 : S64             exponent;               /* Biased exponent           */
; 4010 : 
; 4011 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_extra:
  00055	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_extra
  00078	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_extra:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_extra

; 4012 : 
; 4013 :     TXF_FLOAT_INSTR_CHECK( regs );
; 4014 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_extra
  000ae	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_extra
  000c5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_extra
$LN7@s370_extra:
  000ed	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_extra:

; 4015 : 
; 4016 :     /* Initialise the context for long DFP */
; 4017 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0011a	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0011f	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00124	e8 00 00 00 00	 call	 decContextDefault

; 4018 : 
; 4019 :     /* Load DFP long number from FP register r2 */
; 4020 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  00129	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00131	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  00136	8b 4c 24 30	 mov	 ecx, DWORD PTR r2$[rsp]
  0013a	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 4021 : 
; 4022 :     /* Convert to internal decimal number format */
; 4023 :     decimal64ToNumber(&x2, &d2);

  0013f	48 8d 54 24 40	 lea	 rdx, QWORD PTR d2$[rsp]
  00144	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00149	e8 00 00 00 00	 call	 decimal64ToNumber

; 4024 : 
; 4025 :     /* Calculate the biased exponent */
; 4026 :     if (decNumberIsInfinite(&d2))

  0014e	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00153	83 e0 40	 and	 eax, 64			; 00000040H
  00156	85 c0		 test	 eax, eax
  00158	74 0b		 je	 SHORT $LN8@s370_extra

; 4027 :         exponent = -1;

  0015a	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR exponent$[rsp], -1
  00163	eb 3e		 jmp	 SHORT $LN9@s370_extra
$LN8@s370_extra:

; 4028 :     else if (decNumberIsQNaN(&d2))

  00165	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0016a	83 e0 20	 and	 eax, 32			; 00000020H
  0016d	85 c0		 test	 eax, eax
  0016f	74 0b		 je	 SHORT $LN10@s370_extra

; 4029 :         exponent = -2;

  00171	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR exponent$[rsp], -2
  0017a	eb 27		 jmp	 SHORT $LN11@s370_extra
$LN10@s370_extra:

; 4030 :     else if (decNumberIsSNaN(&d2))

  0017c	0f b6 44 24 48	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00181	83 e0 10	 and	 eax, 16
  00184	85 c0		 test	 eax, eax
  00186	74 0b		 je	 SHORT $LN12@s370_extra

; 4031 :         exponent = -3;

  00188	48 c7 44 24 28
	fd ff ff ff	 mov	 QWORD PTR exponent$[rsp], -3
  00191	eb 10		 jmp	 SHORT $LN13@s370_extra
$LN12@s370_extra:

; 4032 :     else
; 4033 :         exponent = d2.exponent + DECIMAL64_Bias;

  00193	8b 44 24 44	 mov	 eax, DWORD PTR d2$[rsp+4]
  00197	05 8e 01 00 00	 add	 eax, 398		; 0000018eH
  0019c	48 98		 cdqe
  0019e	48 89 44 24 28	 mov	 QWORD PTR exponent$[rsp], rax
$LN13@s370_extra:
$LN11@s370_extra:
$LN9@s370_extra:

; 4034 : 
; 4035 :     /* Load result into general register r1 */
; 4036 :     regs->GR(r1) = exponent;

  001a3	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  001a8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	8b 54 24 28	 mov	 edx, DWORD PTR exponent$[rsp]
  001b4	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 4037 : 
; 4038 : } /* end DEF_INST(extract_biased_exponent_dfp_long_to_fix64_reg) */

  001bb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c3	48 33 cc	 xor	 rcx, rsp
  001c6	e8 00 00 00 00	 call	 __security_check_cookie
  001cb	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001d2	c3		 ret	 0
s370_extract_biased_exponent_dfp_long_to_fix64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
exponent$ = 40
r1$ = 48
d2$ = 56
x2$ = 96
set$ = 112
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s370_extract_biased_exponent_dfp_ext_to_fix64_reg PROC

; 3962 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3963 : int             r1, r2;                 /* Values of R fields        */
; 3964 : decimal128      x2;                     /* Extended DFP value        */
; 3965 : decNumber       d2;                     /* Working decimal number    */
; 3966 : decContext      set;                    /* Working context           */
; 3967 : S64             exponent;               /* Biased exponent           */
; 3968 : 
; 3969 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_extra:
  00055	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_extra
  00078	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_extra:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_extra

; 3970 : 
; 3971 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3972 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_extra
  000ae	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_extra
  000c5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_extra
$LN7@s370_extra:
  000ed	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_extra:

; 3973 :     DFPREGPAIR_CHECK(r2, regs);

  0011a	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  0011e	83 e0 02	 and	 eax, 2
  00121	85 c0		 test	 eax, eax
  00123	74 1b		 je	 SHORT $LN8@s370_extra
  00125	ba 06 00 00 00	 mov	 edx, 6
  0012a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_extra:

; 3974 : 
; 3975 :     /* Initialise the context for extended DFP */
; 3976 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00140	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00145	48 8d 4c 24 70	 lea	 rcx, QWORD PTR set$[rsp]
  0014a	e8 00 00 00 00	 call	 decContextDefault

; 3977 : 
; 3978 :     /* Load DFP extended number from FP register r2 */
; 3979 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  0014f	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00157	48 8d 54 24 60	 lea	 rdx, QWORD PTR x2$[rsp]
  0015c	8b 4c 24 24	 mov	 ecx, DWORD PTR r2$[rsp]
  00160	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 3980 : 
; 3981 :     /* Convert to internal decimal number format */
; 3982 :     decimal128ToNumber(&x2, &d2);

  00165	48 8d 54 24 38	 lea	 rdx, QWORD PTR d2$[rsp]
  0016a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR x2$[rsp]
  0016f	e8 00 00 00 00	 call	 decimal128ToNumber

; 3983 : 
; 3984 :     /* Calculate the biased exponent */
; 3985 :     if (decNumberIsInfinite(&d2))

  00174	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00179	83 e0 40	 and	 eax, 64			; 00000040H
  0017c	85 c0		 test	 eax, eax
  0017e	74 0b		 je	 SHORT $LN9@s370_extra

; 3986 :         exponent = -1;

  00180	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR exponent$[rsp], -1
  00189	eb 3e		 jmp	 SHORT $LN10@s370_extra
$LN9@s370_extra:

; 3987 :     else if (decNumberIsQNaN(&d2))

  0018b	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00190	83 e0 20	 and	 eax, 32			; 00000020H
  00193	85 c0		 test	 eax, eax
  00195	74 0b		 je	 SHORT $LN11@s370_extra

; 3988 :         exponent = -2;

  00197	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR exponent$[rsp], -2
  001a0	eb 27		 jmp	 SHORT $LN12@s370_extra
$LN11@s370_extra:

; 3989 :     else if (decNumberIsSNaN(&d2))

  001a2	0f b6 44 24 40	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001a7	83 e0 10	 and	 eax, 16
  001aa	85 c0		 test	 eax, eax
  001ac	74 0b		 je	 SHORT $LN13@s370_extra

; 3990 :         exponent = -3;

  001ae	48 c7 44 24 28
	fd ff ff ff	 mov	 QWORD PTR exponent$[rsp], -3
  001b7	eb 10		 jmp	 SHORT $LN14@s370_extra
$LN13@s370_extra:

; 3991 :     else
; 3992 :         exponent = d2.exponent + DECIMAL128_Bias;

  001b9	8b 44 24 3c	 mov	 eax, DWORD PTR d2$[rsp+4]
  001bd	05 20 18 00 00	 add	 eax, 6176		; 00001820H
  001c2	48 98		 cdqe
  001c4	48 89 44 24 28	 mov	 QWORD PTR exponent$[rsp], rax
$LN14@s370_extra:
$LN12@s370_extra:
$LN10@s370_extra:

; 3993 : 
; 3994 :     /* Load result into general register r1 */
; 3995 :     regs->GR(r1) = exponent;

  001c9	48 63 44 24 30	 movsxd	 rax, DWORD PTR r1$[rsp]
  001ce	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d6	8b 54 24 28	 mov	 edx, DWORD PTR exponent$[rsp]
  001da	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3996 : 
; 3997 : } /* end DEF_INST(extract_biased_exponent_dfp_ext_to_fix64_reg) */

  001e1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e9	48 33 cc	 xor	 rcx, rsp
  001ec	e8 00 00 00 00	 call	 __security_check_cookie
  001f1	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001f8	c3		 ret	 0
s370_extract_biased_exponent_dfp_ext_to_fix64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
x2$ = 56
x3$ = 64
x1$ = 72
set$ = 80
d3$ = 112
d2$ = 152
d1$ = 192
__$ArrayPad$ = 232
inst$ = 256
regs$ = 264
s370_divide_dfp_long_reg PROC

; 3918 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3919 : int             r1, r2, r3;             /* Values of R fields        */
; 3920 : decimal64       x1, x2, x3;             /* Long DFP values           */
; 3921 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 3922 : decContext      set;                    /* Working context           */
; 3923 : BYTE            dxc;                    /* Data exception code       */
; 3924 : 
; 3925 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_divid:
  00062	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_divid
  00085	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_divid:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_divid

; 3926 : 
; 3927 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3928 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_divid
  000bb	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_divid
  000d2	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_divid
$LN7@s370_divid:
  000fa	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_divid:

; 3929 : 
; 3930 :     /* Initialise the context for long DFP */
; 3931 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00127	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0012c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00131	e8 00 00 00 00	 call	 decContextDefault

; 3932 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  00136	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0013e	33 d2		 xor	 edx, edx
  00140	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00145	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 3933 : 
; 3934 :     /* Divide FP register r2 by FP register r3 */
; 3935 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  0014a	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00152	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  00157	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  0015b	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 3936 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  00160	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00168	48 8d 54 24 40	 lea	 rdx, QWORD PTR x3$[rsp]
  0016d	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  00171	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 3937 :     decimal64ToNumber(&x2, &d2);

  00176	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0017e	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00183	e8 00 00 00 00	 call	 decimal64ToNumber

; 3938 :     decimal64ToNumber(&x3, &d3);

  00188	48 8d 54 24 70	 lea	 rdx, QWORD PTR d3$[rsp]
  0018d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x3$[rsp]
  00192	e8 00 00 00 00	 call	 decimal64ToNumber

; 3939 :     decNumberDivide(&d1, &d2, &d3, &set);

  00197	4c 8d 4c 24 50	 lea	 r9, QWORD PTR set$[rsp]
  0019c	4c 8d 44 24 70	 lea	 r8, QWORD PTR d3$[rsp]
  001a1	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001a9	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  001b1	e8 00 00 00 00	 call	 decNumberDivide

; 3940 :     decimal64FromNumber(&x1, &d1, &set);

  001b6	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  001bb	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  001c3	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  001c8	e8 00 00 00 00	 call	 decimal64FromNumber

; 3941 : 
; 3942 :     /* Check for exception condition */
; 3943 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  001cd	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001d5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001da	e8 00 00 00 00	 call	 s370_dfp_status_check
  001df	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3944 : 
; 3945 :     /* Load result into FP register r1 */
; 3946 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  001e3	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001eb	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  001f0	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  001f4	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 3947 : 
; 3948 :     /* Raise data exception if error occurred */
; 3949 :     if (dxc != 0)

  001f9	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  001fe	85 c0		 test	 eax, eax
  00200	74 25		 je	 SHORT $LN8@s370_divid

; 3950 :     {
; 3951 :         regs->dxc = dxc;

  00202	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00207	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3952 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00215	ba 07 00 00 00	 mov	 edx, 7
  0021a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00222	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_divid:

; 3953 :     }
; 3954 : 
; 3955 : } /* end DEF_INST(divide_dfp_long_reg) */

  00227	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0022f	48 33 cc	 xor	 rcx, rsp
  00232	e8 00 00 00 00	 call	 __security_check_cookie
  00237	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  0023e	c3		 ret	 0
s370_divide_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
set$ = 56
x2$ = 88
x3$ = 104
x1$ = 120
d3$ = 136
d2$ = 176
d1$ = 216
__$ArrayPad$ = 256
inst$ = 288
regs$ = 296
s370_divide_dfp_ext_reg PROC

; 3873 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3874 : int             r1, r2, r3;             /* Values of R fields        */
; 3875 : decimal128      x1, x2, x3;             /* Extended DFP values       */
; 3876 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 3877 : decContext      set;                    /* Working context           */
; 3878 : BYTE            dxc;                    /* Data exception code       */
; 3879 : 
; 3880 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_divid:
  00062	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_divid
  00085	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_divid:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_divid

; 3881 : 
; 3882 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3883 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_divid
  000bb	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_divid
  000d2	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_divid
$LN7@s370_divid:
  000fa	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_divid:

; 3884 :     DFPREGPAIR3_CHECK(r1, r2, r3, regs);

  00127	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0012b	83 e0 02	 and	 eax, 2
  0012e	85 c0		 test	 eax, eax
  00130	75 16		 jne	 SHORT $LN9@s370_divid
  00132	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00136	83 e0 02	 and	 eax, 2
  00139	85 c0		 test	 eax, eax
  0013b	75 0b		 jne	 SHORT $LN9@s370_divid
  0013d	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  00141	83 e0 02	 and	 eax, 2
  00144	85 c0		 test	 eax, eax
  00146	74 1b		 je	 SHORT $LN8@s370_divid
$LN9@s370_divid:
  00148	ba 06 00 00 00	 mov	 edx, 6
  0014d	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00155	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_divid:

; 3885 : 
; 3886 :     /* Initialise the context for extended DFP */
; 3887 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00163	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00168	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  0016d	e8 00 00 00 00	 call	 decContextDefault

; 3888 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  00172	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017a	33 d2		 xor	 edx, edx
  0017c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  00181	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 3889 : 
; 3890 :     /* Divide FP register r2 by FP register r3 */
; 3891 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00186	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0018e	48 8d 54 24 58	 lea	 rdx, QWORD PTR x2$[rsp]
  00193	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00197	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 3892 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  0019c	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001a4	48 8d 54 24 68	 lea	 rdx, QWORD PTR x3$[rsp]
  001a9	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  001ad	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 3893 :     decimal128ToNumber(&x2, &d2);

  001b2	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001ba	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x2$[rsp]
  001bf	e8 00 00 00 00	 call	 decimal128ToNumber

; 3894 :     decimal128ToNumber(&x3, &d3);

  001c4	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  001cc	48 8d 4c 24 68	 lea	 rcx, QWORD PTR x3$[rsp]
  001d1	e8 00 00 00 00	 call	 decimal128ToNumber

; 3895 :     decNumberDivide(&d1, &d2, &d3, &set);

  001d6	4c 8d 4c 24 38	 lea	 r9, QWORD PTR set$[rsp]
  001db	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  001e3	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001eb	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR d1$[rsp]
  001f3	e8 00 00 00 00	 call	 decNumberDivide

; 3896 :     decimal128FromNumber(&x1, &d1, &set);

  001f8	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  001fd	48 8d 94 24 d8
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00205	48 8d 4c 24 78	 lea	 rcx, QWORD PTR x1$[rsp]
  0020a	e8 00 00 00 00	 call	 decimal128FromNumber

; 3897 : 
; 3898 :     /* Check for exception condition */
; 3899 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0020f	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00217	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  0021c	e8 00 00 00 00	 call	 s370_dfp_status_check
  00221	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3900 : 
; 3901 :     /* Load result into FP register r1 */
; 3902 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  00225	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0022d	48 8d 54 24 78	 lea	 rdx, QWORD PTR x1$[rsp]
  00232	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  00236	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 3903 : 
; 3904 :     /* Raise data exception if error occurred */
; 3905 :     if (dxc != 0)

  0023b	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00240	85 c0		 test	 eax, eax
  00242	74 25		 je	 SHORT $LN10@s370_divid

; 3906 :     {
; 3907 :         regs->dxc = dxc;

  00244	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00249	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3908 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00257	ba 07 00 00 00	 mov	 edx, 7
  0025c	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00264	e8 00 00 00 00	 call	 s370_program_interrupt
$LN10@s370_divid:

; 3909 :     }
; 3910 : 
; 3911 : } /* end DEF_INST(divide_dfp_ext_reg) */

  00269	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00271	48 33 cc	 xor	 rcx, rsp
  00274	e8 00 00 00 00	 call	 __security_check_cookie
  00279	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00280	c3		 ret	 0
s370_divide_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
scale$ = 48
x2$ = 56
dwork$ = 64
set$ = 104
pwork$ = 136
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
s370_convert_dfp_long_to_ubcd64_reg PROC

; 3609 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3610 : int             i;                      /* Array subscript           */
; 3611 : int             r1, r2;                 /* Values of R fields        */
; 3612 : decimal64       x2;                     /* Long DFP values           */
; 3613 : decNumber       dwork;                  /* Working decimal number    */
; 3614 : decContext      set;                    /* Working context           */
; 3615 : int32_t         scale;                  /* Scaling factor            */
; 3616 : BYTE            pwork[9];               /* 17-digit packed work area */
; 3617 : 
; 3618 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_conve:
  00055	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@s370_conve
  00078	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_conve:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_conve

; 3619 : 
; 3620 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3621 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN10@s370_conve
  000ae	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN9@s370_conve
  000c5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN9@s370_conve
$LN10@s370_conve:
  000ed	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_conve:

; 3622 : 
; 3623 :     /* Initialise the context for long DFP */
; 3624 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0011a	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0011f	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00124	e8 00 00 00 00	 call	 decContextDefault

; 3625 : 
; 3626 :     /* Load DFP long number from FP register r2 */
; 3627 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  00129	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00131	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  00136	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  0013a	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 3628 :     decimal64ToNumber(&x2, &dwork);

  0013f	48 8d 54 24 40	 lea	 rdx, QWORD PTR dwork$[rsp]
  00144	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00149	e8 00 00 00 00	 call	 decimal64ToNumber

; 3629 : 
; 3630 :     /* If NaN or Inf then use coefficient only */
; 3631 :     if (decNumberIsNaN(&dwork) || (decNumberIsInfinite(&dwork)))

  0014e	0f b6 44 24 48	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  00153	83 e0 30	 and	 eax, 48			; 00000030H
  00156	85 c0		 test	 eax, eax
  00158	75 0c		 jne	 SHORT $LN12@s370_conve
  0015a	0f b6 44 24 48	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  0015f	83 e0 40	 and	 eax, 64			; 00000040H
  00162	85 c0		 test	 eax, eax
  00164	74 19		 je	 SHORT $LN11@s370_conve
$LN12@s370_conve:

; 3632 :     {
; 3633 :         dfp64_clear_cf_and_bxcf(&x2);

  00166	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  0016b	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 3634 :         decimal64ToNumber(&x2, &dwork);

  00170	48 8d 54 24 40	 lea	 rdx, QWORD PTR dwork$[rsp]
  00175	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  0017a	e8 00 00 00 00	 call	 decimal64ToNumber
$LN11@s370_conve:

; 3635 :     }
; 3636 : 
; 3637 :     /* Convert number to signed BCD in work area */
; 3638 :     decPackedFromNumber(pwork, sizeof(pwork), &scale, &dwork);

  0017f	4c 8d 4c 24 40	 lea	 r9, QWORD PTR dwork$[rsp]
  00184	4c 8d 44 24 30	 lea	 r8, QWORD PTR scale$[rsp]
  00189	ba 09 00 00 00	 mov	 edx, 9
  0018e	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  00196	e8 00 00 00 00	 call	 decPackedFromNumber

; 3639 : 
; 3640 :     /* Convert signed BCD to unsigned BCD */
; 3641 :     for (i = sizeof(pwork)-1; i > 0; i--)

  0019b	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR i$[rsp], 8
  001a3	eb 0a		 jmp	 SHORT $LN7@s370_conve
$LN5@s370_conve:
  001a5	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001a9	ff c8		 dec	 eax
  001ab	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_conve:
  001af	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  001b4	7e 37		 jle	 SHORT $LN6@s370_conve

; 3642 :         pwork[i] = (pwork[i] >> 4) | ((pwork[i-1] & 0x0F) << 4);

  001b6	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001bb	0f b6 84 04 88
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  001c3	c1 f8 04	 sar	 eax, 4
  001c6	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  001ca	ff c9		 dec	 ecx
  001cc	48 63 c9	 movsxd	 rcx, ecx
  001cf	0f b6 8c 0c 88
	00 00 00	 movzx	 ecx, BYTE PTR pwork$[rsp+rcx]
  001d7	83 e1 0f	 and	 ecx, 15
  001da	c1 e1 04	 shl	 ecx, 4
  001dd	0b c1		 or	 eax, ecx
  001df	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001e4	88 84 0c 88 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al
  001eb	eb b8		 jmp	 SHORT $LN5@s370_conve
$LN6@s370_conve:

; 3643 : 
; 3644 :     /* Load general register r1 from rightmost
; 3645 :        16 packed decimal digits of work area */
; 3646 :     FETCH_DW(regs->GR_G(r1), pwork+sizeof(pwork)-8);

  001ed	48 8d 84 24 89
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+1]
  001f5	48 8b c8	 mov	 rcx, rax
  001f8	e8 00 00 00 00	 call	 fetch_dw_noswap
  001fd	48 8b c8	 mov	 rcx, rax
  00200	e8 00 00 00 00	 call	 _byteswap_uint64
  00205	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0020a	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00212	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3647 : 
; 3648 : } /* end DEF_INST(convert_dfp_long_to_ubcd64_reg) */

  0021a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00222	48 33 cc	 xor	 rcx, rsp
  00225	e8 00 00 00 00	 call	 __security_check_cookie
  0022a	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00231	c3		 ret	 0
s370_convert_dfp_long_to_ubcd64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
r1$ = 36
i$1 = 40
r2$ = 44
scale$ = 48
x2$ = 56
dwork$ = 72
set$ = 112
pwork$ = 144
__$ArrayPad$ = 168
inst$ = 192
regs$ = 200
s370_convert_dfp_ext_to_ubcd128_reg PROC

; 3560 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3561 : int             i;                      /* Array subscript           */
; 3562 : int             r1, r2;                 /* Values of R fields        */
; 3563 : decimal128      x2;                     /* Extended DFP values       */
; 3564 : decNumber       dwork;                  /* Working decimal number    */
; 3565 : decContext      set;                    /* Working context           */
; 3566 : int32_t         scale;                  /* Scaling factor            */
; 3567 : BYTE            pwork[17];              /* 33-digit packed work area */
; 3568 : 
; 3569 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_conve:
  00055	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN8@s370_conve
  00078	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_conve:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_conve

; 3570 : 
; 3571 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3572 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN10@s370_conve
  000ae	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN9@s370_conve
  000c5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN9@s370_conve
$LN10@s370_conve:
  000ed	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_conve:

; 3573 :     DFPREGPAIR_CHECK(r2, regs);

  0011a	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0011e	83 e0 02	 and	 eax, 2
  00121	85 c0		 test	 eax, eax
  00123	74 1b		 je	 SHORT $LN11@s370_conve
  00125	ba 06 00 00 00	 mov	 edx, 6
  0012a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_conve:

; 3574 :     ODD_CHECK(r1, regs);

  00140	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00144	83 e0 01	 and	 eax, 1
  00147	85 c0		 test	 eax, eax
  00149	74 1b		 je	 SHORT $LN12@s370_conve
  0014b	ba 06 00 00 00	 mov	 edx, 6
  00150	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00160	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s370_conve:

; 3575 : 
; 3576 :     /* Initialise the context for extended DFP */
; 3577 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00166	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0016b	48 8d 4c 24 70	 lea	 rcx, QWORD PTR set$[rsp]
  00170	e8 00 00 00 00	 call	 decContextDefault

; 3578 : 
; 3579 :     /* Load DFP extended number from FP register r2 */
; 3580 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00175	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017d	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  00182	8b 4c 24 2c	 mov	 ecx, DWORD PTR r2$[rsp]
  00186	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 3581 :     decimal128ToNumber(&x2, &dwork);

  0018b	48 8d 54 24 48	 lea	 rdx, QWORD PTR dwork$[rsp]
  00190	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00195	e8 00 00 00 00	 call	 decimal128ToNumber

; 3582 : 
; 3583 :     /* If NaN or Inf then use coefficient only */
; 3584 :     if (decNumberIsNaN(&dwork) || (decNumberIsInfinite(&dwork)))

  0019a	0f b6 44 24 50	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  0019f	83 e0 30	 and	 eax, 48			; 00000030H
  001a2	85 c0		 test	 eax, eax
  001a4	75 0c		 jne	 SHORT $LN14@s370_conve
  001a6	0f b6 44 24 50	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  001ab	83 e0 40	 and	 eax, 64			; 00000040H
  001ae	85 c0		 test	 eax, eax
  001b0	74 19		 je	 SHORT $LN13@s370_conve
$LN14@s370_conve:

; 3585 :     {
; 3586 :         dfp128_clear_cf_and_bxcf(&x2);

  001b2	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  001b7	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 3587 :         decimal128ToNumber(&x2, &dwork);

  001bc	48 8d 54 24 48	 lea	 rdx, QWORD PTR dwork$[rsp]
  001c1	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  001c6	e8 00 00 00 00	 call	 decimal128ToNumber
$LN13@s370_conve:

; 3588 :     }
; 3589 : 
; 3590 :     /* Convert number to signed BCD in work area */
; 3591 :     decPackedFromNumber(pwork, sizeof(pwork), &scale, &dwork);

  001cb	4c 8d 4c 24 48	 lea	 r9, QWORD PTR dwork$[rsp]
  001d0	4c 8d 44 24 30	 lea	 r8, QWORD PTR scale$[rsp]
  001d5	ba 11 00 00 00	 mov	 edx, 17
  001da	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  001e2	e8 00 00 00 00	 call	 decPackedFromNumber

; 3592 : 
; 3593 :     /* Convert signed BCD to unsigned BCD */
; 3594 :     for (i = sizeof(pwork)-1; i > 0; i--)

  001e7	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR i$[rsp], 16
  001ef	eb 0a		 jmp	 SHORT $LN7@s370_conve
$LN5@s370_conve:
  001f1	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001f5	ff c8		 dec	 eax
  001f7	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_conve:
  001fb	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00200	7e 37		 jle	 SHORT $LN6@s370_conve

; 3595 :         pwork[i] = (pwork[i] >> 4) | ((pwork[i-1] & 0x0F) << 4);

  00202	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00207	0f b6 84 04 90
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  0020f	c1 f8 04	 sar	 eax, 4
  00212	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00216	ff c9		 dec	 ecx
  00218	48 63 c9	 movsxd	 rcx, ecx
  0021b	0f b6 8c 0c 90
	00 00 00	 movzx	 ecx, BYTE PTR pwork$[rsp+rcx]
  00223	83 e1 0f	 and	 ecx, 15
  00226	c1 e1 04	 shl	 ecx, 4
  00229	0b c1		 or	 eax, ecx
  0022b	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00230	88 84 0c 90 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al
  00237	eb b8		 jmp	 SHORT $LN5@s370_conve
$LN6@s370_conve:

; 3596 : 
; 3597 :     /* Load general register pair r1 and r1+1 from
; 3598 :        rightmost 32 packed decimal digits of work area */
; 3599 :     FETCH_DW(regs->GR_G(r1), pwork+sizeof(pwork)-16);

  00239	48 8d 84 24 91
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+1]
  00241	48 8b c8	 mov	 rcx, rax
  00244	e8 00 00 00 00	 call	 fetch_dw_noswap
  00249	48 8b c8	 mov	 rcx, rax
  0024c	e8 00 00 00 00	 call	 _byteswap_uint64
  00251	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00256	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0025e	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3600 :     FETCH_DW(regs->GR_G(r1+1), pwork+sizeof(pwork)-8);

  00266	48 8d 84 24 99
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+9]
  0026e	48 8b c8	 mov	 rcx, rax
  00271	e8 00 00 00 00	 call	 fetch_dw_noswap
  00276	48 8b c8	 mov	 rcx, rax
  00279	e8 00 00 00 00	 call	 _byteswap_uint64
  0027e	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  00282	ff c1		 inc	 ecx
  00284	48 63 c9	 movsxd	 rcx, ecx
  00287	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0028f	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3601 : 
; 3602 : } /* end DEF_INST(convert_dfp_ext_to_ubcd128_reg) */

  00297	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0029f	48 33 cc	 xor	 rcx, rsp
  002a2	e8 00 00 00 00	 call	 __security_check_cookie
  002a7	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  002ae	c3		 ret	 0
s370_convert_dfp_ext_to_ubcd128_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
r2$ = 36
m4$ = 40
r1$ = 44
scale$ = 48
x2$ = 56
dwork$ = 64
set$ = 104
pwork$ = 136
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
s370_convert_dfp_long_to_sbcd64_reg PROC

; 3514 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3515 : int             r1, r2;                 /* Values of R fields        */
; 3516 : int             m4;                     /* Values of M fields        */
; 3517 : decimal64       x2;                     /* Long DFP values           */
; 3518 : decNumber       dwork;                  /* Working decimal number    */
; 3519 : decContext      set;                    /* Working context           */
; 3520 : int32_t         scale;                  /* Scaling factor            */
; 3521 : BYTE            pwork[9];               /* 17-digit packed work area */
; 3522 : 
; 3523 :     RRF_M4(inst, regs, r1, r2, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 28	 mov	 DWORD PTR m4$[rsp], eax
$LN4@s370_conve:
  00062	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_conve
  00085	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_conve

; 3524 : 
; 3525 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3526 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_conve
  000bb	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_conve
  000d2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000fa	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 3527 : 
; 3528 :     /* Initialise the context for long DFP */
; 3529 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00127	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0012c	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00131	e8 00 00 00 00	 call	 decContextDefault

; 3530 : 
; 3531 :     /* Load DFP long number from FP register r2 */
; 3532 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  00136	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0013e	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  00143	8b 4c 24 24	 mov	 ecx, DWORD PTR r2$[rsp]
  00147	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 3533 :     decimal64ToNumber(&x2, &dwork);

  0014c	48 8d 54 24 40	 lea	 rdx, QWORD PTR dwork$[rsp]
  00151	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00156	e8 00 00 00 00	 call	 decimal64ToNumber

; 3534 : 
; 3535 :     /* If NaN or Inf then use coefficient only */
; 3536 :     if (decNumberIsNaN(&dwork) || (decNumberIsInfinite(&dwork)))

  0015b	0f b6 44 24 48	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  00160	83 e0 30	 and	 eax, 48			; 00000030H
  00163	85 c0		 test	 eax, eax
  00165	75 0c		 jne	 SHORT $LN9@s370_conve
  00167	0f b6 44 24 48	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  0016c	83 e0 40	 and	 eax, 64			; 00000040H
  0016f	85 c0		 test	 eax, eax
  00171	74 19		 je	 SHORT $LN8@s370_conve
$LN9@s370_conve:

; 3537 :     {
; 3538 :         dfp64_clear_cf_and_bxcf(&x2);

  00173	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00178	e8 00 00 00 00	 call	 dfp64_clear_cf_and_bxcf

; 3539 :         decimal64ToNumber(&x2, &dwork);

  0017d	48 8d 54 24 40	 lea	 rdx, QWORD PTR dwork$[rsp]
  00182	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00187	e8 00 00 00 00	 call	 decimal64ToNumber
$LN8@s370_conve:

; 3540 :     }
; 3541 : 
; 3542 :     /* Convert number to signed BCD in work area */
; 3543 :     decPackedFromNumber(pwork, sizeof(pwork), &scale, &dwork);

  0018c	4c 8d 4c 24 40	 lea	 r9, QWORD PTR dwork$[rsp]
  00191	4c 8d 44 24 30	 lea	 r8, QWORD PTR scale$[rsp]
  00196	ba 09 00 00 00	 mov	 edx, 9
  0019b	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  001a3	e8 00 00 00 00	 call	 decPackedFromNumber

; 3544 : 
; 3545 :     /* Make the plus-sign X'F' if m4 bit 3 is one */
; 3546 :     if ((m4 & 0x01) && !decNumberIsNegative(&dwork))

  001a8	8b 44 24 28	 mov	 eax, DWORD PTR m4$[rsp]
  001ac	83 e0 01	 and	 eax, 1
  001af	85 c0		 test	 eax, eax
  001b1	74 32		 je	 SHORT $LN10@s370_conve
  001b3	0f b6 44 24 48	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  001b8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001bd	85 c0		 test	 eax, eax
  001bf	75 24		 jne	 SHORT $LN10@s370_conve

; 3547 :         pwork[sizeof(pwork)-1] |= 0x0F;

  001c1	b8 01 00 00 00	 mov	 eax, 1
  001c6	48 6b c0 08	 imul	 rax, rax, 8
  001ca	0f b6 84 04 88
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  001d2	83 c8 0f	 or	 eax, 15
  001d5	b9 01 00 00 00	 mov	 ecx, 1
  001da	48 6b c9 08	 imul	 rcx, rcx, 8
  001de	88 84 0c 88 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al
$LN10@s370_conve:

; 3548 : 
; 3549 :     /* Load general register r1 from rightmost
; 3550 :        15 packed decimal digits of work area */
; 3551 :     FETCH_DW(regs->GR_G(r1), pwork+sizeof(pwork)-8);

  001e5	48 8d 84 24 89
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+1]
  001ed	48 8b c8	 mov	 rcx, rax
  001f0	e8 00 00 00 00	 call	 fetch_dw_noswap
  001f5	48 8b c8	 mov	 rcx, rax
  001f8	e8 00 00 00 00	 call	 _byteswap_uint64
  001fd	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00202	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0020a	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3552 : 
; 3553 : } /* end DEF_INST(convert_dfp_long_to_sbcd64_reg) */

  00212	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0021a	48 33 cc	 xor	 rcx, rsp
  0021d	e8 00 00 00 00	 call	 __security_check_cookie
  00222	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00229	c3		 ret	 0
s370_convert_dfp_long_to_sbcd64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
r2$ = 40
m4$ = 44
scale$ = 48
x2$ = 56
dwork$ = 72
set$ = 112
pwork$ = 144
__$ArrayPad$ = 168
inst$ = 192
regs$ = 200
s370_convert_dfp_ext_to_sbcd128_reg PROC

; 3465 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3466 : int             r1, r2;                 /* Values of R fields        */
; 3467 : int             m4;                     /* Values of M fields        */
; 3468 : decimal128      x2;                     /* Extended DFP values       */
; 3469 : decNumber       dwork;                  /* Working decimal number    */
; 3470 : decContext      set;                    /* Working context           */
; 3471 : int32_t         scale;                  /* Scaling factor            */
; 3472 : BYTE            pwork[18];              /* 33-digit packed work area */
; 3473 : 
; 3474 :     RRF_M4(inst, regs, r1, r2, m4);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR m4$[rsp], eax
$LN4@s370_conve:
  00062	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_conve
  00085	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_conve

; 3475 : 
; 3476 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3477 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_conve
  000bb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_conve
  000d2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000fa	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 3478 :     DFPREGPAIR_CHECK(r2, regs);

  00127	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0012b	83 e0 02	 and	 eax, 2
  0012e	85 c0		 test	 eax, eax
  00130	74 1b		 je	 SHORT $LN8@s370_conve
  00132	ba 06 00 00 00	 mov	 edx, 6
  00137	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00147	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 3479 :     ODD_CHECK(r1, regs);

  0014d	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00151	83 e0 01	 and	 eax, 1
  00154	85 c0		 test	 eax, eax
  00156	74 1b		 je	 SHORT $LN9@s370_conve
  00158	ba 06 00 00 00	 mov	 edx, 6
  0015d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_conve:

; 3480 : 
; 3481 :     /* Initialise the context for extended DFP */
; 3482 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00173	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00178	48 8d 4c 24 70	 lea	 rcx, QWORD PTR set$[rsp]
  0017d	e8 00 00 00 00	 call	 decContextDefault

; 3483 : 
; 3484 :     /* Load DFP extended number from FP register r2 */
; 3485 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00182	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0018a	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  0018f	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00193	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 3486 :     decimal128ToNumber(&x2, &dwork);

  00198	48 8d 54 24 48	 lea	 rdx, QWORD PTR dwork$[rsp]
  0019d	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  001a2	e8 00 00 00 00	 call	 decimal128ToNumber

; 3487 : 
; 3488 :     /* If NaN or Inf then use coefficient only */
; 3489 :     if (decNumberIsNaN(&dwork) || (decNumberIsInfinite(&dwork)))

  001a7	0f b6 44 24 50	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  001ac	83 e0 30	 and	 eax, 48			; 00000030H
  001af	85 c0		 test	 eax, eax
  001b1	75 0c		 jne	 SHORT $LN11@s370_conve
  001b3	0f b6 44 24 50	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  001b8	83 e0 40	 and	 eax, 64			; 00000040H
  001bb	85 c0		 test	 eax, eax
  001bd	74 19		 je	 SHORT $LN10@s370_conve
$LN11@s370_conve:

; 3490 :     {
; 3491 :         dfp128_clear_cf_and_bxcf(&x2);

  001bf	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  001c4	e8 00 00 00 00	 call	 dfp128_clear_cf_and_bxcf

; 3492 :         decimal128ToNumber(&x2, &dwork);

  001c9	48 8d 54 24 48	 lea	 rdx, QWORD PTR dwork$[rsp]
  001ce	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  001d3	e8 00 00 00 00	 call	 decimal128ToNumber
$LN10@s370_conve:

; 3493 :     }
; 3494 : 
; 3495 :     /* Convert number to signed BCD in work area */
; 3496 :     decPackedFromNumber(pwork, sizeof(pwork), &scale, &dwork);

  001d8	4c 8d 4c 24 48	 lea	 r9, QWORD PTR dwork$[rsp]
  001dd	4c 8d 44 24 30	 lea	 r8, QWORD PTR scale$[rsp]
  001e2	ba 12 00 00 00	 mov	 edx, 18
  001e7	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  001ef	e8 00 00 00 00	 call	 decPackedFromNumber

; 3497 : 
; 3498 :     /* Make the plus-sign X'F' if m4 bit 3 is one */
; 3499 :     if ((m4 & 0x01) && !decNumberIsNegative(&dwork))

  001f4	8b 44 24 2c	 mov	 eax, DWORD PTR m4$[rsp]
  001f8	83 e0 01	 and	 eax, 1
  001fb	85 c0		 test	 eax, eax
  001fd	74 32		 je	 SHORT $LN12@s370_conve
  001ff	0f b6 44 24 50	 movzx	 eax, BYTE PTR dwork$[rsp+8]
  00204	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00209	85 c0		 test	 eax, eax
  0020b	75 24		 jne	 SHORT $LN12@s370_conve

; 3500 :         pwork[sizeof(pwork)-1] |= 0x0F;

  0020d	b8 01 00 00 00	 mov	 eax, 1
  00212	48 6b c0 11	 imul	 rax, rax, 17
  00216	0f b6 84 04 90
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  0021e	83 c8 0f	 or	 eax, 15
  00221	b9 01 00 00 00	 mov	 ecx, 1
  00226	48 6b c9 11	 imul	 rcx, rcx, 17
  0022a	88 84 0c 90 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al
$LN12@s370_conve:

; 3501 : 
; 3502 :     /* Load general register pair r1 and r1+1 from
; 3503 :        rightmost 31 packed decimal digits of work area */
; 3504 :     FETCH_DW(regs->GR_G(r1), pwork+sizeof(pwork)-16);

  00231	48 8d 84 24 92
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+2]
  00239	48 8b c8	 mov	 rcx, rax
  0023c	e8 00 00 00 00	 call	 fetch_dw_noswap
  00241	48 8b c8	 mov	 rcx, rax
  00244	e8 00 00 00 00	 call	 _byteswap_uint64
  00249	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0024e	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00256	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3505 :     FETCH_DW(regs->GR_G(r1+1), pwork+sizeof(pwork)-8);

  0025e	48 8d 84 24 9a
	00 00 00	 lea	 rax, QWORD PTR pwork$[rsp+10]
  00266	48 8b c8	 mov	 rcx, rax
  00269	e8 00 00 00 00	 call	 fetch_dw_noswap
  0026e	48 8b c8	 mov	 rcx, rax
  00271	e8 00 00 00 00	 call	 _byteswap_uint64
  00276	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  0027a	ff c1		 inc	 ecx
  0027c	48 63 c9	 movsxd	 rcx, ecx
  0027f	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00287	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 3506 : 
; 3507 : } /* end DEF_INST(convert_dfp_ext_to_sbcd128_reg) */

  0028f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00297	48 33 cc	 xor	 rcx, rsp
  0029a	e8 00 00 00 00	 call	 __security_check_cookie
  0029f	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  002a6	c3		 ret	 0
s370_convert_dfp_ext_to_sbcd128_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv166 = 40
tv167 = 44
tv169 = 48
m3$ = 52
r2$ = 56
r1$ = 60
n1$ = 64
x2$ = 72
set$ = 80
d2$ = 112
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
s370_convert_dfp_long_to_fix64_reg PROC

; 3312 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3313 : int             r1, r2;                 /* Values of R fields        */
; 3314 : int             m3;                     /* Values of M fields        */
; 3315 : S64             n1;                     /* Result value              */
; 3316 : decimal64       x2;                     /* Long DFP value            */
; 3317 : decNumber       d2;                     /* Working decimal number    */
; 3318 : decContext      set;                    /* Working context           */
; 3319 : BYTE            dxc;                    /* Data exception code       */
; 3320 : 
; 3321 :     RRF_M(inst, regs, r1, r2, m3);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00062	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_conve
  00085	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_conve

; 3322 : 
; 3323 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3324 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_conve
  000bb	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_conve
  000d2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000fa	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 3325 : 
; 3326 :     /* Initialise the context for long DFP */
; 3327 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00127	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0012c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00131	e8 00 00 00 00	 call	 decContextDefault

; 3328 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00136	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0013e	8b 54 24 34	 mov	 edx, DWORD PTR m3$[rsp]
  00142	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00147	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 3329 : 
; 3330 :     /* Load long DFP value from FP register r2 */
; 3331 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  0014c	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00154	48 8d 54 24 48	 lea	 rdx, QWORD PTR x2$[rsp]
  00159	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  0015d	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 3332 :     decimal64ToNumber(&x2, &d2);

  00162	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  00167	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  0016c	e8 00 00 00 00	 call	 decimal64ToNumber

; 3333 : 
; 3334 :     /* Convert decimal number to 64-bit binary integer */
; 3335 :     n1 = dfp_number_to_fix64(&d2, &set);

  00171	48 8d 54 24 50	 lea	 rdx, QWORD PTR set$[rsp]
  00176	48 8d 4c 24 70	 lea	 rcx, QWORD PTR d2$[rsp]
  0017b	e8 00 00 00 00	 call	 dfp_number_to_fix64
  00180	48 89 44 24 40	 mov	 QWORD PTR n1$[rsp], rax

; 3336 : 
; 3337 :     /* Check for exception condition */
; 3338 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00185	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0018d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00192	e8 00 00 00 00	 call	 s370_dfp_status_check
  00197	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3339 : 
; 3340 :     /* Load result into general register r1 */
; 3341 :     regs->GR_G(r1) = n1;

  0019b	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001a0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 8b 54 24 40	 mov	 rdx, QWORD PTR n1$[rsp]
  001ad	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3342 : 
; 3343 :     /* Set condition code */
; 3344 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  001b5	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  001b9	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  001be	85 c0		 test	 eax, eax
  001c0	74 0a		 je	 SHORT $LN14@s370_conve
  001c2	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv169[rsp], 3
  001ca	eb 5f		 jmp	 SHORT $LN15@s370_conve
$LN14@s370_conve:
  001cc	b8 02 00 00 00	 mov	 eax, 2
  001d1	48 6b c0 00	 imul	 rax, rax, 0
  001d5	0f b7 44 04 7a	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  001da	85 c0		 test	 eax, eax
  001dc	75 1d		 jne	 SHORT $LN10@s370_conve
  001de	83 7c 24 70 01	 cmp	 DWORD PTR d2$[rsp], 1
  001e3	75 16		 jne	 SHORT $LN10@s370_conve
  001e5	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001ea	83 e0 70	 and	 eax, 112		; 00000070H
  001ed	85 c0		 test	 eax, eax
  001ef	75 0a		 jne	 SHORT $LN10@s370_conve
  001f1	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
  001f9	eb 28		 jmp	 SHORT $LN13@s370_conve
$LN10@s370_conve:
  001fb	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00200	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00205	85 c0		 test	 eax, eax
  00207	74 0a		 je	 SHORT $LN11@s370_conve
  00209	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv166[rsp], 1
  00211	eb 08		 jmp	 SHORT $LN12@s370_conve
$LN11@s370_conve:
  00213	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv166[rsp], 2
$LN12@s370_conve:
  0021b	8b 44 24 28	 mov	 eax, DWORD PTR tv166[rsp]
  0021f	89 44 24 2c	 mov	 DWORD PTR tv167[rsp], eax
$LN13@s370_conve:
  00223	8b 44 24 2c	 mov	 eax, DWORD PTR tv167[rsp]
  00227	89 44 24 30	 mov	 DWORD PTR tv169[rsp], eax
$LN15@s370_conve:
  0022b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00233	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv169[rsp]
  00238	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3345 :                    decNumberIsZero(&d2) ? 0 :
; 3346 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3347 : 
; 3348 :     /* Raise data exception if error occurred */
; 3349 :     if (dxc != 0)

  0023b	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00240	85 c0		 test	 eax, eax
  00242	74 25		 je	 SHORT $LN8@s370_conve

; 3350 :     {
; 3351 :         regs->dxc = dxc;

  00244	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00249	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3352 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00257	ba 07 00 00 00	 mov	 edx, 7
  0025c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00264	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_conve:

; 3353 :     }
; 3354 : 
; 3355 : } /* end DEF_INST(convert_dfp_long_to_fix64_reg) */

  00269	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00271	48 33 cc	 xor	 rcx, rsp
  00274	e8 00 00 00 00	 call	 __security_check_cookie
  00279	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00280	c3		 ret	 0
s370_convert_dfp_long_to_fix64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
tv171 = 44
tv172 = 48
tv174 = 52
m3$ = 56
r1$ = 60
n1$ = 64
set$ = 72
d2$ = 104
x2$ = 144
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_convert_dfp_ext_to_fix64_reg PROC

; 3261 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3262 : int             r1, r2;                 /* Values of R fields        */
; 3263 : int             m3;                     /* Values of M fields        */
; 3264 : S64             n1;                     /* Result value              */
; 3265 : decimal128      x2;                     /* Extended DFP value        */
; 3266 : decNumber       d2;                     /* Working decimal number    */
; 3267 : decContext      set;                    /* Working context           */
; 3268 : BYTE            dxc;                    /* Data exception code       */
; 3269 : 
; 3270 :     RRF_M(inst, regs, r1, r2, m3);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00062	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_conve
  00085	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_conve

; 3271 : 
; 3272 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3273 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_conve
  000bb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_conve
  000d2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000fa	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 3274 :     DFPREGPAIR_CHECK(r2, regs);

  00127	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0012b	83 e0 02	 and	 eax, 2
  0012e	85 c0		 test	 eax, eax
  00130	74 1b		 je	 SHORT $LN8@s370_conve
  00132	ba 06 00 00 00	 mov	 edx, 6
  00137	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00147	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 3275 : 
; 3276 :     /* Initialise the context for extended DFP */
; 3277 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0014d	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00152	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00157	e8 00 00 00 00	 call	 decContextDefault

; 3278 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  0015c	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00164	8b 54 24 38	 mov	 edx, DWORD PTR m3$[rsp]
  00168	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  0016d	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 3279 : 
; 3280 :     /* Load extended DFP value from FP register r2 */
; 3281 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00172	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017a	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  00182	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00186	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 3282 :     decimal128ToNumber(&x2, &d2);

  0018b	48 8d 54 24 68	 lea	 rdx, QWORD PTR d2$[rsp]
  00190	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  00198	e8 00 00 00 00	 call	 decimal128ToNumber

; 3283 : 
; 3284 :     /* Convert decimal number to 64-bit binary integer */
; 3285 :     n1 = dfp_number_to_fix64(&d2, &set);

  0019d	48 8d 54 24 48	 lea	 rdx, QWORD PTR set$[rsp]
  001a2	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d2$[rsp]
  001a7	e8 00 00 00 00	 call	 dfp_number_to_fix64
  001ac	48 89 44 24 40	 mov	 QWORD PTR n1$[rsp], rax

; 3286 : 
; 3287 :     /* Check for exception condition */
; 3288 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  001b1	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001b9	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001be	e8 00 00 00 00	 call	 s370_dfp_status_check
  001c3	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3289 : 
; 3290 :     /* Load result into general register r1 */
; 3291 :     regs->GR_G(r1) = n1;

  001c7	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001cc	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	48 8b 54 24 40	 mov	 rdx, QWORD PTR n1$[rsp]
  001d9	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3292 : 
; 3293 :     /* Set condition code */
; 3294 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  001e1	8b 44 24 5c	 mov	 eax, DWORD PTR set$[rsp+20]
  001e5	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  001ea	85 c0		 test	 eax, eax
  001ec	74 0a		 je	 SHORT $LN15@s370_conve
  001ee	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv174[rsp], 3
  001f6	eb 5f		 jmp	 SHORT $LN16@s370_conve
$LN15@s370_conve:
  001f8	b8 02 00 00 00	 mov	 eax, 2
  001fd	48 6b c0 00	 imul	 rax, rax, 0
  00201	0f b7 44 04 72	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  00206	85 c0		 test	 eax, eax
  00208	75 1d		 jne	 SHORT $LN11@s370_conve
  0020a	83 7c 24 68 01	 cmp	 DWORD PTR d2$[rsp], 1
  0020f	75 16		 jne	 SHORT $LN11@s370_conve
  00211	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00216	83 e0 70	 and	 eax, 112		; 00000070H
  00219	85 c0		 test	 eax, eax
  0021b	75 0a		 jne	 SHORT $LN11@s370_conve
  0021d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
  00225	eb 28		 jmp	 SHORT $LN14@s370_conve
$LN11@s370_conve:
  00227	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0022c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00231	85 c0		 test	 eax, eax
  00233	74 0a		 je	 SHORT $LN12@s370_conve
  00235	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv171[rsp], 1
  0023d	eb 08		 jmp	 SHORT $LN13@s370_conve
$LN12@s370_conve:
  0023f	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv171[rsp], 2
$LN13@s370_conve:
  00247	8b 44 24 2c	 mov	 eax, DWORD PTR tv171[rsp]
  0024b	89 44 24 30	 mov	 DWORD PTR tv172[rsp], eax
$LN14@s370_conve:
  0024f	8b 44 24 30	 mov	 eax, DWORD PTR tv172[rsp]
  00253	89 44 24 34	 mov	 DWORD PTR tv174[rsp], eax
$LN16@s370_conve:
  00257	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025f	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv174[rsp]
  00264	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3295 :                    decNumberIsZero(&d2) ? 0 :
; 3296 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3297 : 
; 3298 :     /* Raise data exception if error occurred */
; 3299 :     if (dxc != 0)

  00267	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0026c	85 c0		 test	 eax, eax
  0026e	74 25		 je	 SHORT $LN9@s370_conve

; 3300 :     {
; 3301 :         regs->dxc = dxc;

  00270	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00275	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027d	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3302 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00283	ba 07 00 00 00	 mov	 edx, 7
  00288	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00290	e8 00 00 00 00	 call	 s370_program_interrupt
$LN9@s370_conve:

; 3303 :     }
; 3304 : 
; 3305 : } /* end DEF_INST(convert_dfp_ext_to_fix64_reg) */

  00295	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0029d	48 33 cc	 xor	 rcx, rsp
  002a0	e8 00 00 00 00	 call	 __security_check_cookie
  002a5	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  002ac	c3		 ret	 0
s370_convert_dfp_ext_to_fix64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
i$1 = 36
r2$ = 40
scale$ = 44
r1$ = 48
$T2 = 56
dp$ = 64
x1$ = 72
set$ = 80
dwork$ = 112
pwork$ = 152
__$ArrayPad$ = 168
inst$ = 192
regs$ = 200
s370_convert_ubcd64_to_dfp_long_reg PROC

; 2768 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2769 : unsigned        i;                      /* Array subscript           */
; 2770 : int             r1, r2;                 /* Values of R fields        */
; 2771 : decimal64       x1;                     /* Long DFP values           */
; 2772 : decNumber       dwork, *dp;             /* Working decimal numbers   */
; 2773 : decContext      set;                    /* Working context           */
; 2774 : BYTE            pwork[9];               /* 17-digit packed work area */
; 2775 : int32_t         scale = 0;              /* Scaling factor            */

  00023	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR scale$[rsp], 0

; 2776 : 
; 2777 :     RRE(inst, regs, r1, r2);

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 03	 imul	 rax, rax, 3
  00034	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00040	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0004f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00053	c1 f8 04	 sar	 eax, 4
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_conve:
  0005d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00079	33 c0		 xor	 eax, eax
  0007b	83 f8 04	 cmp	 eax, 4
  0007e	74 0f		 je	 SHORT $LN8@s370_conve
  00080	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_conve:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 c8		 jne	 SHORT $LN4@s370_conve

; 2778 : 
; 2779 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2780 :     DFPINST_CHECK(regs);

  00095	b8 08 00 00 00	 mov	 eax, 8
  0009a	48 6b c0 01	 imul	 rax, rax, 1
  0009e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a6	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ad	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b2	85 c0		 test	 eax, eax
  000b4	74 3f		 je	 SHORT $LN10@s370_conve
  000b6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000be	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c4	d1 e8		 shr	 eax, 1
  000c6	83 e0 01	 and	 eax, 1
  000c9	85 c0		 test	 eax, eax
  000cb	74 55		 je	 SHORT $LN9@s370_conve
  000cd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000dc	b9 08 00 00 00	 mov	 ecx, 8
  000e1	48 6b c9 01	 imul	 rcx, rcx, 1
  000e5	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ec	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f1	85 c0		 test	 eax, eax
  000f3	75 2d		 jne	 SHORT $LN9@s370_conve
$LN10@s370_conve:
  000f5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00107	ba 07 00 00 00	 mov	 edx, 7
  0010c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_conve:

; 2781 : 
; 2782 :     /* Initialise the context for long DFP */
; 2783 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00122	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00127	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0012c	e8 00 00 00 00	 call	 decContextDefault

; 2784 : 
; 2785 :     /* Store general register in work area */
; 2786 :     pwork[0] = 0;

  00131	b8 01 00 00 00	 mov	 eax, 1
  00136	48 6b c0 00	 imul	 rax, rax, 0
  0013a	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  0013f	48 83 7c 24 38
	09		 cmp	 QWORD PTR $T2[rsp], 9
  00145	73 02		 jae	 SHORT $LN13@s370_conve
  00147	eb 05		 jmp	 SHORT $LN14@s370_conve
$LN13@s370_conve:
  00149	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN14@s370_conve:
  0014e	48 8b 44 24 38	 mov	 rax, QWORD PTR $T2[rsp]
  00153	c6 84 04 98 00
	00 00 00	 mov	 BYTE PTR pwork$[rsp+rax], 0

; 2787 :     STORE_DW(pwork+1, regs->GR_G(r2));

  0015b	48 63 44 24 28	 movsxd	 rax, DWORD PTR r2$[rsp]
  00160	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00168	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00170	e8 00 00 00 00	 call	 _byteswap_uint64
  00175	48 8d 8c 24 99
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp+1]
  0017d	48 8b d0	 mov	 rdx, rax
  00180	e8 00 00 00 00	 call	 store_dw_noswap

; 2788 : 
; 2789 :     /* Convert unsigned BCD to signed BCD */
; 2790 :     for (i = 0; i < sizeof(pwork)-1; i++)

  00185	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0018d	eb 0a		 jmp	 SHORT $LN7@s370_conve
$LN5@s370_conve:
  0018f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00193	ff c0		 inc	 eax
  00195	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_conve:
  00199	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0019d	48 83 f8 08	 cmp	 rax, 8
  001a1	73 34		 jae	 SHORT $LN6@s370_conve

; 2791 :         pwork[i] = ((pwork[i] & 0x0F) << 4) | (pwork[i+1] >> 4);

  001a3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001a7	0f b6 84 04 98
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  001af	83 e0 0f	 and	 eax, 15
  001b2	c1 e0 04	 shl	 eax, 4
  001b5	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  001b9	ff c1		 inc	 ecx
  001bb	8b c9		 mov	 ecx, ecx
  001bd	0f b6 8c 0c 98
	00 00 00	 movzx	 ecx, BYTE PTR pwork$[rsp+rcx]
  001c5	c1 f9 04	 sar	 ecx, 4
  001c8	0b c1		 or	 eax, ecx
  001ca	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  001ce	88 84 0c 98 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al
  001d5	eb b8		 jmp	 SHORT $LN5@s370_conve
$LN6@s370_conve:

; 2792 :     pwork[i] = ((pwork[i] & 0x0F) << 4) | 0x0F;

  001d7	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001db	0f b6 84 04 98
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  001e3	83 e0 0f	 and	 eax, 15
  001e6	c1 e0 04	 shl	 eax, 4
  001e9	83 c8 0f	 or	 eax, 15
  001ec	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  001f0	88 84 0c 98 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al

; 2793 : 
; 2794 :     /* Convert signed BCD to internal number format */
; 2795 :     dp = decPackedToNumber(pwork, sizeof(pwork), &scale, &dwork);

  001f7	4c 8d 4c 24 70	 lea	 r9, QWORD PTR dwork$[rsp]
  001fc	4c 8d 44 24 2c	 lea	 r8, QWORD PTR scale$[rsp]
  00201	ba 09 00 00 00	 mov	 edx, 9
  00206	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  0020e	e8 00 00 00 00	 call	 decPackedToNumber
  00213	48 89 44 24 40	 mov	 QWORD PTR dp$[rsp], rax

; 2796 : 
; 2797 :     /* Data exception if digits or sign was invalid */
; 2798 :     if (dp == NULL)

  00218	48 83 7c 24 40
	00		 cmp	 QWORD PTR dp$[rsp], 0
  0021e	75 24		 jne	 SHORT $LN11@s370_conve

; 2799 :     {
; 2800 :         regs->dxc = DXC_DECIMAL;

  00220	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00228	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 2801 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00232	ba 07 00 00 00	 mov	 edx, 7
  00237	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023f	e8 00 00 00 00	 call	 s370_program_interrupt
$LN11@s370_conve:

; 2802 :     }
; 2803 : 
; 2804 :     /* Convert internal number to DFP long format */
; 2805 :     decimal64FromNumber(&x1, &dwork, &set);

  00244	4c 8d 44 24 50	 lea	 r8, QWORD PTR set$[rsp]
  00249	48 8d 54 24 70	 lea	 rdx, QWORD PTR dwork$[rsp]
  0024e	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  00253	e8 00 00 00 00	 call	 decimal64FromNumber

; 2806 : 
; 2807 :     /* Load result into FP register r1 */
; 2808 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  00258	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00260	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  00265	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  00269	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64
$LN12@s370_conve:

; 2809 : 
; 2810 : } /* end DEF_INST(convert_ubcd64_to_dfp_long_reg) */

  0026e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00276	48 33 cc	 xor	 rcx, rsp
  00279	e8 00 00 00 00	 call	 __security_check_cookie
  0027e	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00285	c3		 ret	 0
s370_convert_ubcd64_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$ = 32
r2$ = 36
i$1 = 40
r1$ = 44
scale$ = 48
$T2 = 56
dp$ = 64
x1$ = 72
set$ = 88
dwork$ = 120
pwork$ = 160
__$ArrayPad$ = 184
inst$ = 208
regs$ = 216
s370_convert_ubcd128_to_dfp_ext_reg PROC

; 2716 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2717 : unsigned        i;                      /* Array subscript           */
; 2718 : int             r1, r2;                 /* Values of R fields        */
; 2719 : decimal128      x1;                     /* Extended DFP values       */
; 2720 : decNumber       dwork, *dp;             /* Working decimal numbers   */
; 2721 : decContext      set;                    /* Working context           */
; 2722 : BYTE            pwork[17];              /* 33-digit packed work area */
; 2723 : int32_t         scale = 0;              /* Scaling factor            */

  00023	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR scale$[rsp], 0

; 2724 : 
; 2725 :     RRE(inst, regs, r1, r2);

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 03	 imul	 rax, rax, 3
  00034	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00040	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00044	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0004f	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00053	c1 f8 04	 sar	 eax, 4
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_conve:
  0005d	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00079	33 c0		 xor	 eax, eax
  0007b	83 f8 04	 cmp	 eax, 4
  0007e	74 0f		 je	 SHORT $LN8@s370_conve
  00080	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@s370_conve:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 c8		 jne	 SHORT $LN4@s370_conve

; 2726 : 
; 2727 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2728 :     DFPINST_CHECK(regs);

  00095	b8 08 00 00 00	 mov	 eax, 8
  0009a	48 6b c0 01	 imul	 rax, rax, 1
  0009e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a6	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ad	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b2	85 c0		 test	 eax, eax
  000b4	74 3f		 je	 SHORT $LN10@s370_conve
  000b6	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000be	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c4	d1 e8		 shr	 eax, 1
  000c6	83 e0 01	 and	 eax, 1
  000c9	85 c0		 test	 eax, eax
  000cb	74 55		 je	 SHORT $LN9@s370_conve
  000cd	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000dc	b9 08 00 00 00	 mov	 ecx, 8
  000e1	48 6b c9 01	 imul	 rcx, rcx, 1
  000e5	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ec	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f1	85 c0		 test	 eax, eax
  000f3	75 2d		 jne	 SHORT $LN9@s370_conve
$LN10@s370_conve:
  000f5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00107	ba 07 00 00 00	 mov	 edx, 7
  0010c	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_conve:

; 2729 :     DFPREGPAIR_CHECK(r1, regs);

  00122	8b 44 24 2c	 mov	 eax, DWORD PTR r1$[rsp]
  00126	83 e0 02	 and	 eax, 2
  00129	85 c0		 test	 eax, eax
  0012b	74 1b		 je	 SHORT $LN11@s370_conve
  0012d	ba 06 00 00 00	 mov	 edx, 6
  00132	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013a	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00142	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_conve:

; 2730 :     ODD_CHECK(r2, regs);

  00148	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  0014c	83 e0 01	 and	 eax, 1
  0014f	85 c0		 test	 eax, eax
  00151	74 1b		 je	 SHORT $LN12@s370_conve
  00153	ba 06 00 00 00	 mov	 edx, 6
  00158	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00168	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s370_conve:

; 2731 : 
; 2732 :     /* Initialise the context for extended DFP */
; 2733 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0016e	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00173	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  00178	e8 00 00 00 00	 call	 decContextDefault

; 2734 : 
; 2735 :     /* Store general register pair in work area */
; 2736 :     pwork[0] = 0;

  0017d	b8 01 00 00 00	 mov	 eax, 1
  00182	48 6b c0 00	 imul	 rax, rax, 0
  00186	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  0018b	48 83 7c 24 38
	11		 cmp	 QWORD PTR $T2[rsp], 17
  00191	73 02		 jae	 SHORT $LN15@s370_conve
  00193	eb 05		 jmp	 SHORT $LN16@s370_conve
$LN15@s370_conve:
  00195	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN16@s370_conve:
  0019a	48 8b 44 24 38	 mov	 rax, QWORD PTR $T2[rsp]
  0019f	c6 84 04 a0 00
	00 00 00	 mov	 BYTE PTR pwork$[rsp+rax], 0

; 2737 :     STORE_DW(pwork+1, regs->GR_G(r2));

  001a7	48 63 44 24 24	 movsxd	 rax, DWORD PTR r2$[rsp]
  001ac	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b4	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  001bc	e8 00 00 00 00	 call	 _byteswap_uint64
  001c1	48 8d 8c 24 a1
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp+1]
  001c9	48 8b d0	 mov	 rdx, rax
  001cc	e8 00 00 00 00	 call	 store_dw_noswap

; 2738 :     STORE_DW(pwork+9, regs->GR_G(r2+1));

  001d1	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  001d5	ff c0		 inc	 eax
  001d7	48 98		 cdqe
  001d9	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e1	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  001e9	e8 00 00 00 00	 call	 _byteswap_uint64
  001ee	48 8d 8c 24 a9
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp+9]
  001f6	48 8b d0	 mov	 rdx, rax
  001f9	e8 00 00 00 00	 call	 store_dw_noswap

; 2739 : 
; 2740 :     /* Convert unsigned BCD to signed BCD */
; 2741 :     for (i = 0; i < sizeof(pwork)-1; i++)

  001fe	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00206	eb 0a		 jmp	 SHORT $LN7@s370_conve
$LN5@s370_conve:
  00208	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0020c	ff c0		 inc	 eax
  0020e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_conve:
  00212	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00216	48 83 f8 10	 cmp	 rax, 16
  0021a	73 34		 jae	 SHORT $LN6@s370_conve

; 2742 :         pwork[i] = ((pwork[i] & 0x0F) << 4) | (pwork[i+1] >> 4);

  0021c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00220	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  00228	83 e0 0f	 and	 eax, 15
  0022b	c1 e0 04	 shl	 eax, 4
  0022e	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00232	ff c1		 inc	 ecx
  00234	8b c9		 mov	 ecx, ecx
  00236	0f b6 8c 0c a0
	00 00 00	 movzx	 ecx, BYTE PTR pwork$[rsp+rcx]
  0023e	c1 f9 04	 sar	 ecx, 4
  00241	0b c1		 or	 eax, ecx
  00243	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00247	88 84 0c a0 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al
  0024e	eb b8		 jmp	 SHORT $LN5@s370_conve
$LN6@s370_conve:

; 2743 :     pwork[i] = ((pwork[i] & 0x0F) << 4) | 0x0F;

  00250	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00254	0f b6 84 04 a0
	00 00 00	 movzx	 eax, BYTE PTR pwork$[rsp+rax]
  0025c	83 e0 0f	 and	 eax, 15
  0025f	c1 e0 04	 shl	 eax, 4
  00262	83 c8 0f	 or	 eax, 15
  00265	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00269	88 84 0c a0 00
	00 00		 mov	 BYTE PTR pwork$[rsp+rcx], al

; 2744 : 
; 2745 :     /* Convert signed BCD to internal number format */
; 2746 :     dp = decPackedToNumber(pwork, sizeof(pwork), &scale, &dwork);

  00270	4c 8d 4c 24 78	 lea	 r9, QWORD PTR dwork$[rsp]
  00275	4c 8d 44 24 30	 lea	 r8, QWORD PTR scale$[rsp]
  0027a	ba 11 00 00 00	 mov	 edx, 17
  0027f	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  00287	e8 00 00 00 00	 call	 decPackedToNumber
  0028c	48 89 44 24 40	 mov	 QWORD PTR dp$[rsp], rax

; 2747 : 
; 2748 :     /* Data exception if digits invalid */
; 2749 :     if (dp == NULL)

  00291	48 83 7c 24 40
	00		 cmp	 QWORD PTR dp$[rsp], 0
  00297	75 24		 jne	 SHORT $LN13@s370_conve

; 2750 :     {
; 2751 :         regs->dxc = DXC_DECIMAL;

  00299	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a1	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 2752 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002ab	ba 07 00 00 00	 mov	 edx, 7
  002b0	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b8	e8 00 00 00 00	 call	 s370_program_interrupt
$LN13@s370_conve:

; 2753 :     }
; 2754 : 
; 2755 :     /* Convert internal number to DFP extended format */
; 2756 :     decimal128FromNumber(&x1, &dwork, &set);

  002bd	4c 8d 44 24 58	 lea	 r8, QWORD PTR set$[rsp]
  002c2	48 8d 54 24 78	 lea	 rdx, QWORD PTR dwork$[rsp]
  002c7	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x1$[rsp]
  002cc	e8 00 00 00 00	 call	 decimal128FromNumber

; 2757 : 
; 2758 :     /* Load result into FP register r1 */
; 2759 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  002d1	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002d9	48 8d 54 24 48	 lea	 rdx, QWORD PTR x1$[rsp]
  002de	8b 4c 24 2c	 mov	 ecx, DWORD PTR r1$[rsp]
  002e2	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128
$LN14@s370_conve:

; 2760 : 
; 2761 : } /* end DEF_INST(convert_ubcd128_to_dfp_ext_reg) */

  002e7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002ef	48 33 cc	 xor	 rcx, rsp
  002f2	e8 00 00 00 00	 call	 __security_check_cookie
  002f7	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  002fe	c3		 ret	 0
s370_convert_ubcd128_to_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
scale$ = 40
r1$ = 44
dp$ = 48
x1$ = 56
set$ = 64
dwork$ = 96
pwork$ = 136
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s370_convert_sbcd64_to_dfp_long_reg PROC

; 2674 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2675 : int             r1, r2;                 /* Values of R fields        */
; 2676 : decimal64       x1;                     /* Long DFP values           */
; 2677 : decNumber       dwork, *dp;             /* Working decimal numbers   */
; 2678 : decContext      set;                    /* Working context           */
; 2679 : BYTE            pwork[8];               /* 15-digit packed work area */
; 2680 : int32_t         scale = 0;              /* Scaling factor            */

  00023	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR scale$[rsp], 0

; 2681 : 
; 2682 :     RRE(inst, regs, r1, r2);

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 03	 imul	 rax, rax, 3
  00034	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00040	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00044	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0004f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00053	c1 f8 04	 sar	 eax, 4
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_conve:
  0005d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00079	33 c0		 xor	 eax, eax
  0007b	83 f8 04	 cmp	 eax, 4
  0007e	74 0f		 je	 SHORT $LN5@s370_conve
  00080	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 c8		 jne	 SHORT $LN4@s370_conve

; 2683 : 
; 2684 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2685 :     DFPINST_CHECK(regs);

  00095	b8 08 00 00 00	 mov	 eax, 8
  0009a	48 6b c0 01	 imul	 rax, rax, 1
  0009e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a6	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ad	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b2	85 c0		 test	 eax, eax
  000b4	74 3f		 je	 SHORT $LN7@s370_conve
  000b6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000be	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c4	d1 e8		 shr	 eax, 1
  000c6	83 e0 01	 and	 eax, 1
  000c9	85 c0		 test	 eax, eax
  000cb	74 55		 je	 SHORT $LN6@s370_conve
  000cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000dc	b9 08 00 00 00	 mov	 ecx, 8
  000e1	48 6b c9 01	 imul	 rcx, rcx, 1
  000e5	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ec	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f1	85 c0		 test	 eax, eax
  000f3	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00107	ba 07 00 00 00	 mov	 edx, 7
  0010c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2686 : 
; 2687 :     /* Initialise the context for long DFP */
; 2688 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00122	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00127	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  0012c	e8 00 00 00 00	 call	 decContextDefault

; 2689 : 
; 2690 :     /* Store general register in work area */
; 2691 :     STORE_DW(pwork, regs->GR_G(r2));

  00131	48 63 44 24 24	 movsxd	 rax, DWORD PTR r2$[rsp]
  00136	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013e	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00146	e8 00 00 00 00	 call	 _byteswap_uint64
  0014b	48 8b d0	 mov	 rdx, rax
  0014e	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  00156	e8 00 00 00 00	 call	 store_dw_noswap

; 2692 : 
; 2693 :     /* Convert signed BCD to internal number format */
; 2694 :     dp = decPackedToNumber(pwork, sizeof(pwork), &scale, &dwork);

  0015b	4c 8d 4c 24 60	 lea	 r9, QWORD PTR dwork$[rsp]
  00160	4c 8d 44 24 28	 lea	 r8, QWORD PTR scale$[rsp]
  00165	ba 08 00 00 00	 mov	 edx, 8
  0016a	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  00172	e8 00 00 00 00	 call	 decPackedToNumber
  00177	48 89 44 24 30	 mov	 QWORD PTR dp$[rsp], rax

; 2695 : 
; 2696 :     /* Data exception if digits or sign was invalid */
; 2697 :     if (dp == NULL)

  0017c	48 83 7c 24 30
	00		 cmp	 QWORD PTR dp$[rsp], 0
  00182	75 24		 jne	 SHORT $LN8@s370_conve

; 2698 :     {
; 2699 :         regs->dxc = DXC_DECIMAL;

  00184	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018c	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 2700 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00196	ba 07 00 00 00	 mov	 edx, 7
  0019b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a3	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_conve:

; 2701 :     }
; 2702 : 
; 2703 :     /* Convert internal number to DFP long format */
; 2704 :     decimal64FromNumber(&x1, &dwork, &set);

  001a8	4c 8d 44 24 40	 lea	 r8, QWORD PTR set$[rsp]
  001ad	48 8d 54 24 60	 lea	 rdx, QWORD PTR dwork$[rsp]
  001b2	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  001b7	e8 00 00 00 00	 call	 decimal64FromNumber

; 2705 : 
; 2706 :     /* Load result into FP register r1 */
; 2707 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  001bc	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001c4	48 8d 54 24 38	 lea	 rdx, QWORD PTR x1$[rsp]
  001c9	8b 4c 24 2c	 mov	 ecx, DWORD PTR r1$[rsp]
  001cd	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 2708 : 
; 2709 : } /* end DEF_INST(convert_sbcd64_to_dfp_long_reg) */

  001d2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001da	48 33 cc	 xor	 rcx, rsp
  001dd	e8 00 00 00 00	 call	 __security_check_cookie
  001e2	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001e9	c3		 ret	 0
s370_convert_sbcd64_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
r2$ = 32
i$1 = 36
r1$ = 40
scale$ = 44
dp$ = 48
x1$ = 56
set$ = 72
dwork$ = 104
pwork$ = 144
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_convert_sbcd128_to_dfp_ext_reg PROC

; 2629 : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2630 : int             r1, r2;                 /* Values of R fields        */
; 2631 : decimal128      x1;                     /* Extended DFP values       */
; 2632 : decNumber       dwork, *dp;             /* Working decimal numbers   */
; 2633 : decContext      set;                    /* Working context           */
; 2634 : BYTE            pwork[16];              /* 31-digit packed work area */
; 2635 : int32_t         scale = 0;              /* Scaling factor            */

  00023	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR scale$[rsp], 0

; 2636 : 
; 2637 :     RRE(inst, regs, r1, r2);

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	48 6b c0 03	 imul	 rax, rax, 3
  00034	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0003c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00040	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  00044	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00048	83 e0 0f	 and	 eax, 15
  0004b	89 44 24 20	 mov	 DWORD PTR r2$[rsp], eax
  0004f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00053	c1 f8 04	 sar	 eax, 4
  00056	83 e0 0f	 and	 eax, 15
  00059	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_conve:
  0005d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	48 83 c0 04	 add	 rax, 4
  0006d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00079	33 c0		 xor	 eax, eax
  0007b	83 f8 04	 cmp	 eax, 4
  0007e	74 0f		 je	 SHORT $LN5@s370_conve
  00080	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00088	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 c8		 jne	 SHORT $LN4@s370_conve

; 2638 : 
; 2639 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2640 :     DFPINST_CHECK(regs);

  00095	b8 08 00 00 00	 mov	 eax, 8
  0009a	48 6b c0 01	 imul	 rax, rax, 1
  0009e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a6	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ad	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b2	85 c0		 test	 eax, eax
  000b4	74 3f		 je	 SHORT $LN7@s370_conve
  000b6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000be	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c4	d1 e8		 shr	 eax, 1
  000c6	83 e0 01	 and	 eax, 1
  000c9	85 c0		 test	 eax, eax
  000cb	74 55		 je	 SHORT $LN6@s370_conve
  000cd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000dc	b9 08 00 00 00	 mov	 ecx, 8
  000e1	48 6b c9 01	 imul	 rcx, rcx, 1
  000e5	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ec	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f1	85 c0		 test	 eax, eax
  000f3	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000f5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00107	ba 07 00 00 00	 mov	 edx, 7
  0010c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2641 :     DFPREGPAIR_CHECK(r1, regs);

  00122	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00126	83 e0 02	 and	 eax, 2
  00129	85 c0		 test	 eax, eax
  0012b	74 1b		 je	 SHORT $LN8@s370_conve
  0012d	ba 06 00 00 00	 mov	 edx, 6
  00132	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00142	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 2642 :     ODD_CHECK(r2, regs);

  00148	8b 44 24 20	 mov	 eax, DWORD PTR r2$[rsp]
  0014c	83 e0 01	 and	 eax, 1
  0014f	85 c0		 test	 eax, eax
  00151	74 1b		 je	 SHORT $LN9@s370_conve
  00153	ba 06 00 00 00	 mov	 edx, 6
  00158	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00168	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_conve:

; 2643 : 
; 2644 :     /* Initialise the context for extended DFP */
; 2645 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0016e	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00173	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00178	e8 00 00 00 00	 call	 decContextDefault

; 2646 : 
; 2647 :     /* Store general register pair in work area */
; 2648 :     STORE_DW(pwork, regs->GR_G(r2));

  0017d	48 63 44 24 20	 movsxd	 rax, DWORD PTR r2$[rsp]
  00182	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00192	e8 00 00 00 00	 call	 _byteswap_uint64
  00197	48 8b d0	 mov	 rdx, rax
  0019a	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  001a2	e8 00 00 00 00	 call	 store_dw_noswap

; 2649 :     STORE_DW(pwork+8, regs->GR_G(r2+1));

  001a7	8b 44 24 20	 mov	 eax, DWORD PTR r2$[rsp]
  001ab	ff c0		 inc	 eax
  001ad	48 98		 cdqe
  001af	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b7	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  001bf	e8 00 00 00 00	 call	 _byteswap_uint64
  001c4	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp+8]
  001cc	48 8b d0	 mov	 rdx, rax
  001cf	e8 00 00 00 00	 call	 store_dw_noswap

; 2650 : 
; 2651 :     /* Convert signed BCD to internal number format */
; 2652 :     dp = decPackedToNumber(pwork, sizeof(pwork), &scale, &dwork);

  001d4	4c 8d 4c 24 68	 lea	 r9, QWORD PTR dwork$[rsp]
  001d9	4c 8d 44 24 2c	 lea	 r8, QWORD PTR scale$[rsp]
  001de	ba 10 00 00 00	 mov	 edx, 16
  001e3	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR pwork$[rsp]
  001eb	e8 00 00 00 00	 call	 decPackedToNumber
  001f0	48 89 44 24 30	 mov	 QWORD PTR dp$[rsp], rax

; 2653 : 
; 2654 :     /* Data exception if digits or sign was invalid */
; 2655 :     if (dp == NULL)

  001f5	48 83 7c 24 30
	00		 cmp	 QWORD PTR dp$[rsp], 0
  001fb	75 24		 jne	 SHORT $LN10@s370_conve

; 2656 :     {
; 2657 :         regs->dxc = DXC_DECIMAL;

  001fd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00205	c7 80 08 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1800], 0

; 2658 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0020f	ba 07 00 00 00	 mov	 edx, 7
  00214	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021c	e8 00 00 00 00	 call	 s370_program_interrupt
$LN10@s370_conve:

; 2659 :     }
; 2660 : 
; 2661 :     /* Convert internal number to DFP extended format */
; 2662 :     decimal128FromNumber(&x1, &dwork, &set);

  00221	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  00226	48 8d 54 24 68	 lea	 rdx, QWORD PTR dwork$[rsp]
  0022b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  00230	e8 00 00 00 00	 call	 decimal128FromNumber

; 2663 : 
; 2664 :     /* Load result into FP register r1 */
; 2665 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  00235	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0023d	48 8d 54 24 38	 lea	 rdx, QWORD PTR x1$[rsp]
  00242	8b 4c 24 28	 mov	 ecx, DWORD PTR r1$[rsp]
  00246	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 2666 : 
; 2667 : } /* end DEF_INST(convert_sbcd128_to_dfp_ext_reg) */

  0024b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00253	48 33 cc	 xor	 rcx, rsp
  00256	e8 00 00 00 00	 call	 __security_check_cookie
  0025b	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00262	c3		 ret	 0
s370_convert_sbcd128_to_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
r2$ = 40
r1$ = 44
n2$ = 48
x1$ = 56
set$ = 64
d1$ = 96
__$ArrayPad$ = 136
inst$ = 160
regs$ = 168
s370_convert_fix64_to_dfp_long_reg PROC

; 2510 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2511 : int             r1, r2;                 /* Values of R fields        */
; 2512 : S64             n2;                     /* Value of R2 register      */
; 2513 : decimal64       x1;                     /* Long DFP value            */
; 2514 : decNumber       d1;                     /* Working decimal number    */
; 2515 : decContext      set;                    /* Working context           */
; 2516 : BYTE            dxc;                    /* Data exception code       */
; 2517 : 
; 2518 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_conve:
  00055	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_conve
  00078	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_conve

; 2519 : 
; 2520 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2521 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_conve
  000ae	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_conve
  000c5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000ed	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2522 : 
; 2523 :     /* Initialise the context for long DFP */
; 2524 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0011a	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0011f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  00124	e8 00 00 00 00	 call	 decContextDefault

; 2525 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  00129	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00131	33 d2		 xor	 edx, edx
  00133	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  00138	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 2526 : 
; 2527 :     /* Load 64-bit binary integer value from r2 register */
; 2528 :     n2 = (S64)(regs->GR_G(r2));

  0013d	48 63 44 24 28	 movsxd	 rax, DWORD PTR r2$[rsp]
  00142	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00152	48 89 44 24 30	 mov	 QWORD PTR n2$[rsp], rax

; 2529 : 
; 2530 :     /* Convert binary integer to long DFP format */
; 2531 :     dfp_number_from_fix64(&d1, n2, &set);

  00157	4c 8d 44 24 40	 lea	 r8, QWORD PTR set$[rsp]
  0015c	48 8b 54 24 30	 mov	 rdx, QWORD PTR n2$[rsp]
  00161	48 8d 4c 24 60	 lea	 rcx, QWORD PTR d1$[rsp]
  00166	e8 00 00 00 00	 call	 dfp_number_from_fix64

; 2532 :     decimal64FromNumber(&x1, &d1, &set);

  0016b	4c 8d 44 24 40	 lea	 r8, QWORD PTR set$[rsp]
  00170	48 8d 54 24 60	 lea	 rdx, QWORD PTR d1$[rsp]
  00175	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x1$[rsp]
  0017a	e8 00 00 00 00	 call	 decimal64FromNumber

; 2533 : 
; 2534 :     /* Check for exception condition */
; 2535 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0017f	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00187	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  0018c	e8 00 00 00 00	 call	 s370_dfp_status_check
  00191	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2536 : 
; 2537 :     /* Load result into FP register r1 */
; 2538 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  00195	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0019d	48 8d 54 24 38	 lea	 rdx, QWORD PTR x1$[rsp]
  001a2	8b 4c 24 2c	 mov	 ecx, DWORD PTR r1$[rsp]
  001a6	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 2539 : 
; 2540 :     /* Raise data exception if error occurred */
; 2541 :     if (dxc != 0)

  001ab	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  001b0	85 c0		 test	 eax, eax
  001b2	74 25		 je	 SHORT $LN8@s370_conve

; 2542 :     {
; 2543 :         regs->dxc = dxc;

  001b4	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  001b9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c1	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2544 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  001c7	ba 07 00 00 00	 mov	 edx, 7
  001cc	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_conve:

; 2545 :     }
; 2546 : 
; 2547 : } /* end DEF_INST(convert_fix64_to_dfp_long_reg) */

  001d9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e1	48 33 cc	 xor	 rcx, rsp
  001e4	e8 00 00 00 00	 call	 __security_check_cookie
  001e9	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001f0	c3		 ret	 0
s370_convert_fix64_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
n2$ = 48
set$ = 56
x1$ = 88
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s370_convert_fix64_to_dfp_ext_reg PROC

; 2476 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2477 : int             r1, r2;                 /* Values of R fields        */
; 2478 : S64             n2;                     /* Value of R2 register      */
; 2479 : decimal128      x1;                     /* Extended DFP value        */
; 2480 : decNumber       d1;                     /* Working decimal number    */
; 2481 : decContext      set;                    /* Working context           */
; 2482 : 
; 2483 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_conve:
  00055	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_conve
  00078	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_conve

; 2484 : 
; 2485 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2486 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_conve
  000ae	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_conve
  000c5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  000ed	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2487 :     DFPREGPAIR_CHECK(r1, regs);

  0011a	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  0011e	83 e0 02	 and	 eax, 2
  00121	85 c0		 test	 eax, eax
  00123	74 1b		 je	 SHORT $LN8@s370_conve
  00125	ba 06 00 00 00	 mov	 edx, 6
  0012a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 2488 : 
; 2489 :     /* Initialise the context for extended DFP */
; 2490 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00140	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00145	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  0014a	e8 00 00 00 00	 call	 decContextDefault

; 2491 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  0014f	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00157	33 d2		 xor	 edx, edx
  00159	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  0015e	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 2492 : 
; 2493 :     /* Load 64-bit binary integer value from r2 register */
; 2494 :     n2 = (S64)(regs->GR_G(r2));

  00163	48 63 44 24 28	 movsxd	 rax, DWORD PTR r2$[rsp]
  00168	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00178	48 89 44 24 30	 mov	 QWORD PTR n2$[rsp], rax

; 2495 : 
; 2496 :     /* Convert binary integer to extended DFP format */
; 2497 :     dfp_number_from_fix64(&d1, n2, &set);

  0017d	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  00182	48 8b 54 24 30	 mov	 rdx, QWORD PTR n2$[rsp]
  00187	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  0018c	e8 00 00 00 00	 call	 dfp_number_from_fix64

; 2498 :     decimal128FromNumber(&x1, &d1, &set);

  00191	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  00196	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  0019b	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  001a0	e8 00 00 00 00	 call	 decimal128FromNumber

; 2499 : 
; 2500 :     /* Load result into FP register r1 */
; 2501 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  001a5	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001ad	48 8d 54 24 58	 lea	 rdx, QWORD PTR x1$[rsp]
  001b2	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  001b6	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 2502 : 
; 2503 : } /* end DEF_INST(convert_fix64_to_dfp_ext_reg) */

  001bb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c3	48 33 cc	 xor	 rcx, rsp
  001c6	e8 00 00 00 00	 call	 __security_check_cookie
  001cb	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001d2	c3		 ret	 0
s370_convert_fix64_to_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
x1$ = 48
x2$ = 56
d2$ = 64
d1$ = 104
set$ = 144
__$ArrayPad$ = 176
inst$ = 208
regs$ = 216
s370_compare_exponent_dfp_long_reg PROC

; 2298 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2299 : int             r1, r2;                 /* Values of R fields        */
; 2300 : decimal64       x1, x2;                 /* Long DFP values           */
; 2301 : decNumber       d1, d2;                 /* Working decimal numbers   */
; 2302 : decContext      set;                    /* Working context           */
; 2303 : 
; 2304 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00055	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_compa
  00078	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_compa:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_compa

; 2305 : 
; 2306 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2307 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_compa
  000ae	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_compa
  000c5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_compa
$LN7@s370_compa:
  000ed	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_compa:

; 2308 : 
; 2309 :     /* Initialise the context for long DFP */
; 2310 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0011a	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0011f	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00127	e8 00 00 00 00	 call	 decContextDefault

; 2311 : 
; 2312 :     /* Convert FP register values to numbers */
; 2313 :     ARCH_DEP(dfp_reg_to_decimal64)(r1, &x1, regs);

  0012c	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00134	48 8d 54 24 30	 lea	 rdx, QWORD PTR x1$[rsp]
  00139	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  0013d	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 2314 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  00142	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0014a	48 8d 54 24 38	 lea	 rdx, QWORD PTR x2$[rsp]
  0014f	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00153	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 2315 :     decimal64ToNumber(&x1, &d1);

  00158	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  0015d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR x1$[rsp]
  00162	e8 00 00 00 00	 call	 decimal64ToNumber

; 2316 :     decimal64ToNumber(&x2, &d2);

  00167	48 8d 54 24 40	 lea	 rdx, QWORD PTR d2$[rsp]
  0016c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR x2$[rsp]
  00171	e8 00 00 00 00	 call	 decimal64ToNumber

; 2317 : 
; 2318 :     /* Compare exponents and set condition code */
; 2319 :     regs->psw.cc = dfp_compare_exponent(&d1, &d2);

  00176	48 8d 54 24 40	 lea	 rdx, QWORD PTR d2$[rsp]
  0017b	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  00180	e8 00 00 00 00	 call	 dfp_compare_exponent
  00185	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2320 : 
; 2321 : } /* end DEF_INST(compare_exponent_dfp_long_reg) */

  00190	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00198	48 33 cc	 xor	 rcx, rsp
  0019b	e8 00 00 00 00	 call	 __security_check_cookie
  001a0	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  001a7	c3		 ret	 0
s370_compare_exponent_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
x1$ = 48
x2$ = 64
d2$ = 80
d1$ = 120
set$ = 160
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
s370_compare_exponent_dfp_ext_reg PROC

; 2267 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2268 : int             r1, r2;                 /* Values of R fields        */
; 2269 : decimal128      x1, x2;                 /* Extended DFP values       */
; 2270 : decNumber       d1, d2;                 /* Working decimal numbers   */
; 2271 : decContext      set;                    /* Working context           */
; 2272 : 
; 2273 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00055	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_compa
  00078	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_compa:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_compa

; 2274 : 
; 2275 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2276 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_compa
  000ae	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_compa
  000c5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_compa
$LN7@s370_compa:
  000ed	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_compa:

; 2277 :     DFPREGPAIR2_CHECK(r1, r2, regs);

  0011a	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  0011e	83 e0 02	 and	 eax, 2
  00121	85 c0		 test	 eax, eax
  00123	75 0b		 jne	 SHORT $LN9@s370_compa
  00125	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00129	83 e0 02	 and	 eax, 2
  0012c	85 c0		 test	 eax, eax
  0012e	74 1b		 je	 SHORT $LN8@s370_compa
$LN9@s370_compa:
  00130	ba 06 00 00 00	 mov	 edx, 6
  00135	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_compa:

; 2278 : 
; 2279 :     /* Initialise the context for extended DFP */
; 2280 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0014b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00150	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00158	e8 00 00 00 00	 call	 decContextDefault

; 2281 : 
; 2282 :     /* Convert FP register values to numbers */
; 2283 :     ARCH_DEP(dfp_reg_to_decimal128)(r1, &x1, regs);

  0015d	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00165	48 8d 54 24 30	 lea	 rdx, QWORD PTR x1$[rsp]
  0016a	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  0016e	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 2284 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00173	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017b	48 8d 54 24 40	 lea	 rdx, QWORD PTR x2$[rsp]
  00180	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00184	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 2285 :     decimal128ToNumber(&x1, &d1);

  00189	48 8d 54 24 78	 lea	 rdx, QWORD PTR d1$[rsp]
  0018e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR x1$[rsp]
  00193	e8 00 00 00 00	 call	 decimal128ToNumber

; 2286 :     decimal128ToNumber(&x2, &d2);

  00198	48 8d 54 24 50	 lea	 rdx, QWORD PTR d2$[rsp]
  0019d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x2$[rsp]
  001a2	e8 00 00 00 00	 call	 decimal128ToNumber

; 2287 : 
; 2288 :     /* Compare exponents and set condition code */
; 2289 :     regs->psw.cc = dfp_compare_exponent(&d1, &d2);

  001a7	48 8d 54 24 50	 lea	 rdx, QWORD PTR d2$[rsp]
  001ac	48 8d 4c 24 78	 lea	 rcx, QWORD PTR d1$[rsp]
  001b1	e8 00 00 00 00	 call	 dfp_compare_exponent
  001b6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001be	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 2290 : 
; 2291 : } /* end DEF_INST(compare_exponent_dfp_ext_reg) */

  001c1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c9	48 33 cc	 xor	 rcx, rsp
  001cc	e8 00 00 00 00	 call	 __security_check_cookie
  001d1	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  001d8	c3		 ret	 0
s370_compare_exponent_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
tv167 = 40
tv168 = 44
tv169 = 48
r1$ = 52
r2$ = 56
x1$ = 64
x2$ = 72
dr$ = 80
set$ = 120
d2$ = 152
d1$ = 192
__$ArrayPad$ = 232
inst$ = 256
regs$ = 264
s370_compare_and_signal_dfp_long_reg PROC

; 2219 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2220 : int             r1, r2;                 /* Values of R fields        */
; 2221 : decimal64       x1, x2;                 /* Long DFP values           */
; 2222 : decNumber       d1, d2, dr;             /* Working decimal numbers   */
; 2223 : decContext      set;                    /* Working context           */
; 2224 : BYTE            dxc;                    /* Data exception code       */
; 2225 : 
; 2226 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00055	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_compa
  00078	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_compa:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_compa

; 2227 : 
; 2228 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2229 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_compa
  000ae	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_compa
  000c5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_compa
$LN7@s370_compa:
  000ed	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_compa:

; 2230 : 
; 2231 :     /* Initialise the context for long DFP */
; 2232 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0011a	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0011f	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  00124	e8 00 00 00 00	 call	 decContextDefault

; 2233 : 
; 2234 :     /* Compare FP register r1 with FP register r2 */
; 2235 :     ARCH_DEP(dfp_reg_to_decimal64)(r1, &x1, regs);

  00129	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00131	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  00136	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  0013a	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 2236 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  0013f	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00147	48 8d 54 24 48	 lea	 rdx, QWORD PTR x2$[rsp]
  0014c	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  00150	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 2237 :     decimal64ToNumber(&x1, &d1);

  00155	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0015d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00162	e8 00 00 00 00	 call	 decimal64ToNumber

; 2238 :     decimal64ToNumber(&x2, &d2);

  00167	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0016f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  00174	e8 00 00 00 00	 call	 decimal64ToNumber

; 2239 :     decNumberCompare(&dr, &d1, &d2, &set);

  00179	4c 8d 4c 24 78	 lea	 r9, QWORD PTR set$[rsp]
  0017e	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR d2$[rsp]
  00186	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0018e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR dr$[rsp]
  00193	e8 00 00 00 00	 call	 decNumberCompare

; 2240 : 
; 2241 :     /* Force signaling condition if result is a NaN */
; 2242 :     if (decNumberIsNaN(&dr))

  00198	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  0019d	83 e0 30	 and	 eax, 48			; 00000030H
  001a0	85 c0		 test	 eax, eax
  001a2	74 13		 je	 SHORT $LN8@s370_compa

; 2243 :         set.status |= DEC_IEEE_854_Invalid_operation;

  001a4	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR set$[rsp+20]
  001ab	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  001b0	89 84 24 8c 00
	00 00		 mov	 DWORD PTR set$[rsp+20], eax
$LN8@s370_compa:

; 2244 : 
; 2245 :     /* Check for exception condition */
; 2246 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  001b7	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001bf	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  001c4	e8 00 00 00 00	 call	 s370_dfp_status_check
  001c9	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2247 : 
; 2248 :     /* Set condition code */
; 2249 :     regs->psw.cc = decNumberIsNaN(&dr) ? 3 :

  001cd	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  001d2	83 e0 30	 and	 eax, 48			; 00000030H
  001d5	85 c0		 test	 eax, eax
  001d7	74 0a		 je	 SHORT $LN15@s370_compa
  001d9	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv169[rsp], 3
  001e1	eb 5f		 jmp	 SHORT $LN16@s370_compa
$LN15@s370_compa:
  001e3	b8 02 00 00 00	 mov	 eax, 2
  001e8	48 6b c0 00	 imul	 rax, rax, 0
  001ec	0f b7 44 04 5a	 movzx	 eax, WORD PTR dr$[rsp+rax+10]
  001f1	85 c0		 test	 eax, eax
  001f3	75 1d		 jne	 SHORT $LN11@s370_compa
  001f5	83 7c 24 50 01	 cmp	 DWORD PTR dr$[rsp], 1
  001fa	75 16		 jne	 SHORT $LN11@s370_compa
  001fc	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  00201	83 e0 70	 and	 eax, 112		; 00000070H
  00204	85 c0		 test	 eax, eax
  00206	75 0a		 jne	 SHORT $LN11@s370_compa
  00208	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv168[rsp], 0
  00210	eb 28		 jmp	 SHORT $LN14@s370_compa
$LN11@s370_compa:
  00212	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  00217	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0021c	85 c0		 test	 eax, eax
  0021e	74 0a		 je	 SHORT $LN12@s370_compa
  00220	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv167[rsp], 1
  00228	eb 08		 jmp	 SHORT $LN13@s370_compa
$LN12@s370_compa:
  0022a	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv167[rsp], 2
$LN13@s370_compa:
  00232	8b 44 24 28	 mov	 eax, DWORD PTR tv167[rsp]
  00236	89 44 24 2c	 mov	 DWORD PTR tv168[rsp], eax
$LN14@s370_compa:
  0023a	8b 44 24 2c	 mov	 eax, DWORD PTR tv168[rsp]
  0023e	89 44 24 30	 mov	 DWORD PTR tv169[rsp], eax
$LN16@s370_compa:
  00242	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024a	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv169[rsp]
  0024f	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2250 :                    decNumberIsZero(&dr) ? 0 :
; 2251 :                    decNumberIsNegative(&dr) ? 1 : 2;
; 2252 : 
; 2253 :     /* Raise data exception if error occurred */
; 2254 :     if (dxc != 0)

  00252	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00257	85 c0		 test	 eax, eax
  00259	74 25		 je	 SHORT $LN9@s370_compa

; 2255 :     {
; 2256 :         regs->dxc = dxc;

  0025b	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00260	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2257 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0026e	ba 07 00 00 00	 mov	 edx, 7
  00273	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027b	e8 00 00 00 00	 call	 s370_program_interrupt
$LN9@s370_compa:

; 2258 :     }
; 2259 : 
; 2260 : } /* end DEF_INST(compare_and_signal_dfp_long_reg) */

  00280	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00288	48 33 cc	 xor	 rcx, rsp
  0028b	e8 00 00 00 00	 call	 __security_check_cookie
  00290	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00297	c3		 ret	 0
s370_compare_and_signal_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
tv174 = 48
tv175 = 52
tv176 = 56
dr$ = 64
set$ = 104
x1$ = 136
x2$ = 152
d2$ = 168
d1$ = 208
__$ArrayPad$ = 248
inst$ = 272
regs$ = 280
s370_compare_and_signal_dfp_ext_reg PROC

; 2170 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2171 : int             r1, r2;                 /* Values of R fields        */
; 2172 : decimal128      x1, x2;                 /* Extended DFP values       */
; 2173 : decNumber       d1, d2, dr;             /* Working decimal numbers   */
; 2174 : decContext      set;                    /* Working context           */
; 2175 : BYTE            dxc;                    /* Data exception code       */
; 2176 : 
; 2177 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00055	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_compa
  00078	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_compa:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_compa

; 2178 : 
; 2179 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2180 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_compa
  000ae	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_compa
  000c5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_compa
$LN7@s370_compa:
  000ed	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_compa:

; 2181 :     DFPREGPAIR2_CHECK(r1, r2, regs);

  0011a	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0011e	83 e0 02	 and	 eax, 2
  00121	85 c0		 test	 eax, eax
  00123	75 0b		 jne	 SHORT $LN9@s370_compa
  00125	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00129	83 e0 02	 and	 eax, 2
  0012c	85 c0		 test	 eax, eax
  0012e	74 1b		 je	 SHORT $LN8@s370_compa
$LN9@s370_compa:
  00130	ba 06 00 00 00	 mov	 edx, 6
  00135	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_compa:

; 2182 : 
; 2183 :     /* Initialise the context for extended DFP */
; 2184 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0014b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00150	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00155	e8 00 00 00 00	 call	 decContextDefault

; 2185 : 
; 2186 :     /* Compare FP register r1 with FP register r2 */
; 2187 :     ARCH_DEP(dfp_reg_to_decimal128)(r1, &x1, regs);

  0015a	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00162	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR x1$[rsp]
  0016a	8b 4c 24 28	 mov	 ecx, DWORD PTR r1$[rsp]
  0016e	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 2188 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00173	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017b	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  00183	8b 4c 24 2c	 mov	 ecx, DWORD PTR r2$[rsp]
  00187	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 2189 :     decimal128ToNumber(&x1, &d1);

  0018c	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00194	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR x1$[rsp]
  0019c	e8 00 00 00 00	 call	 decimal128ToNumber

; 2190 :     decimal128ToNumber(&x2, &d2);

  001a1	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001a9	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  001b1	e8 00 00 00 00	 call	 decimal128ToNumber

; 2191 :     decNumberCompare(&dr, &d1, &d2, &set);

  001b6	4c 8d 4c 24 68	 lea	 r9, QWORD PTR set$[rsp]
  001bb	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR d2$[rsp]
  001c3	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  001cb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR dr$[rsp]
  001d0	e8 00 00 00 00	 call	 decNumberCompare

; 2192 : 
; 2193 :     /* Force signaling condition if result is a NaN */
; 2194 :     if (decNumberIsNaN(&dr))

  001d5	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  001da	83 e0 30	 and	 eax, 48			; 00000030H
  001dd	85 c0		 test	 eax, eax
  001df	74 0d		 je	 SHORT $LN10@s370_compa

; 2195 :         set.status |= DEC_IEEE_854_Invalid_operation;

  001e1	8b 44 24 7c	 mov	 eax, DWORD PTR set$[rsp+20]
  001e5	0d dd 00 00 00	 or	 eax, 221		; 000000ddH
  001ea	89 44 24 7c	 mov	 DWORD PTR set$[rsp+20], eax
$LN10@s370_compa:

; 2196 : 
; 2197 :     /* Check for exception condition */
; 2198 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  001ee	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001f6	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  001fb	e8 00 00 00 00	 call	 s370_dfp_status_check
  00200	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2199 : 
; 2200 :     /* Set condition code */
; 2201 :     regs->psw.cc = decNumberIsNaN(&dr) ? 3 :

  00204	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  00209	83 e0 30	 and	 eax, 48			; 00000030H
  0020c	85 c0		 test	 eax, eax
  0020e	74 0a		 je	 SHORT $LN17@s370_compa
  00210	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv176[rsp], 3
  00218	eb 5f		 jmp	 SHORT $LN18@s370_compa
$LN17@s370_compa:
  0021a	b8 02 00 00 00	 mov	 eax, 2
  0021f	48 6b c0 00	 imul	 rax, rax, 0
  00223	0f b7 44 04 4a	 movzx	 eax, WORD PTR dr$[rsp+rax+10]
  00228	85 c0		 test	 eax, eax
  0022a	75 1d		 jne	 SHORT $LN13@s370_compa
  0022c	83 7c 24 40 01	 cmp	 DWORD PTR dr$[rsp], 1
  00231	75 16		 jne	 SHORT $LN13@s370_compa
  00233	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  00238	83 e0 70	 and	 eax, 112		; 00000070H
  0023b	85 c0		 test	 eax, eax
  0023d	75 0a		 jne	 SHORT $LN13@s370_compa
  0023f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
  00247	eb 28		 jmp	 SHORT $LN16@s370_compa
$LN13@s370_compa:
  00249	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  0024e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00253	85 c0		 test	 eax, eax
  00255	74 0a		 je	 SHORT $LN14@s370_compa
  00257	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  0025f	eb 08		 jmp	 SHORT $LN15@s370_compa
$LN14@s370_compa:
  00261	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv174[rsp], 2
$LN15@s370_compa:
  00269	8b 44 24 30	 mov	 eax, DWORD PTR tv174[rsp]
  0026d	89 44 24 34	 mov	 DWORD PTR tv175[rsp], eax
$LN16@s370_compa:
  00271	8b 44 24 34	 mov	 eax, DWORD PTR tv175[rsp]
  00275	89 44 24 38	 mov	 DWORD PTR tv176[rsp], eax
$LN18@s370_compa:
  00279	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00281	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv176[rsp]
  00286	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2202 :                    decNumberIsZero(&dr) ? 0 :
; 2203 :                    decNumberIsNegative(&dr) ? 1 : 2;
; 2204 : 
; 2205 :     /* Raise data exception if error occurred */
; 2206 :     if (dxc != 0)

  00289	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0028e	85 c0		 test	 eax, eax
  00290	74 25		 je	 SHORT $LN11@s370_compa

; 2207 :     {
; 2208 :         regs->dxc = dxc;

  00292	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00297	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029f	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2209 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002a5	ba 07 00 00 00	 mov	 edx, 7
  002aa	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b2	e8 00 00 00 00	 call	 s370_program_interrupt
$LN11@s370_compa:

; 2210 :     }
; 2211 : 
; 2212 : } /* end DEF_INST(compare_and_signal_dfp_ext_reg) */

  002b7	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002bf	48 33 cc	 xor	 rcx, rsp
  002c2	e8 00 00 00 00	 call	 __security_check_cookie
  002c7	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  002ce	c3		 ret	 0
s370_compare_and_signal_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
tv163 = 40
tv164 = 44
tv165 = 48
r1$ = 52
r2$ = 56
x1$ = 64
x2$ = 72
dr$ = 80
set$ = 120
d2$ = 152
d1$ = 192
__$ArrayPad$ = 232
inst$ = 256
regs$ = 264
s370_compare_dfp_long_reg PROC

; 2126 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2127 : int             r1, r2;                 /* Values of R fields        */
; 2128 : decimal64       x1, x2;                 /* Long DFP values           */
; 2129 : decNumber       d1, d2, dr;             /* Working decimal numbers   */
; 2130 : decContext      set;                    /* Working context           */
; 2131 : BYTE            dxc;                    /* Data exception code       */
; 2132 : 
; 2133 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00055	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_compa
  00078	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_compa:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_compa

; 2134 : 
; 2135 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2136 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_compa
  000ae	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_compa
  000c5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_compa
$LN7@s370_compa:
  000ed	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_compa:

; 2137 : 
; 2138 :     /* Initialise the context for long DFP */
; 2139 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  0011a	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0011f	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  00124	e8 00 00 00 00	 call	 decContextDefault

; 2140 : 
; 2141 :     /* Compare FP register r1 with FP register r2 */
; 2142 :     ARCH_DEP(dfp_reg_to_decimal64)(r1, &x1, regs);

  00129	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00131	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  00136	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  0013a	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 2143 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  0013f	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00147	48 8d 54 24 48	 lea	 rdx, QWORD PTR x2$[rsp]
  0014c	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  00150	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 2144 :     decimal64ToNumber(&x1, &d1);

  00155	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0015d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00162	e8 00 00 00 00	 call	 decimal64ToNumber

; 2145 :     decimal64ToNumber(&x2, &d2);

  00167	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  0016f	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  00174	e8 00 00 00 00	 call	 decimal64ToNumber

; 2146 :     decNumberCompare(&dr, &d1, &d2, &set);

  00179	4c 8d 4c 24 78	 lea	 r9, QWORD PTR set$[rsp]
  0017e	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR d2$[rsp]
  00186	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  0018e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR dr$[rsp]
  00193	e8 00 00 00 00	 call	 decNumberCompare

; 2147 : 
; 2148 :     /* Check for exception condition */
; 2149 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00198	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001a0	48 8d 4c 24 78	 lea	 rcx, QWORD PTR set$[rsp]
  001a5	e8 00 00 00 00	 call	 s370_dfp_status_check
  001aa	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2150 : 
; 2151 :     /* Set condition code */
; 2152 :     regs->psw.cc = decNumberIsNaN(&dr) ? 3 :

  001ae	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  001b3	83 e0 30	 and	 eax, 48			; 00000030H
  001b6	85 c0		 test	 eax, eax
  001b8	74 0a		 je	 SHORT $LN14@s370_compa
  001ba	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv165[rsp], 3
  001c2	eb 5f		 jmp	 SHORT $LN15@s370_compa
$LN14@s370_compa:
  001c4	b8 02 00 00 00	 mov	 eax, 2
  001c9	48 6b c0 00	 imul	 rax, rax, 0
  001cd	0f b7 44 04 5a	 movzx	 eax, WORD PTR dr$[rsp+rax+10]
  001d2	85 c0		 test	 eax, eax
  001d4	75 1d		 jne	 SHORT $LN10@s370_compa
  001d6	83 7c 24 50 01	 cmp	 DWORD PTR dr$[rsp], 1
  001db	75 16		 jne	 SHORT $LN10@s370_compa
  001dd	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  001e2	83 e0 70	 and	 eax, 112		; 00000070H
  001e5	85 c0		 test	 eax, eax
  001e7	75 0a		 jne	 SHORT $LN10@s370_compa
  001e9	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv164[rsp], 0
  001f1	eb 28		 jmp	 SHORT $LN13@s370_compa
$LN10@s370_compa:
  001f3	0f b6 44 24 58	 movzx	 eax, BYTE PTR dr$[rsp+8]
  001f8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001fd	85 c0		 test	 eax, eax
  001ff	74 0a		 je	 SHORT $LN11@s370_compa
  00201	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv163[rsp], 1
  00209	eb 08		 jmp	 SHORT $LN12@s370_compa
$LN11@s370_compa:
  0020b	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv163[rsp], 2
$LN12@s370_compa:
  00213	8b 44 24 28	 mov	 eax, DWORD PTR tv163[rsp]
  00217	89 44 24 2c	 mov	 DWORD PTR tv164[rsp], eax
$LN13@s370_compa:
  0021b	8b 44 24 2c	 mov	 eax, DWORD PTR tv164[rsp]
  0021f	89 44 24 30	 mov	 DWORD PTR tv165[rsp], eax
$LN15@s370_compa:
  00223	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022b	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv165[rsp]
  00230	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2153 :                    decNumberIsZero(&dr) ? 0 :
; 2154 :                    decNumberIsNegative(&dr) ? 1 : 2;
; 2155 : 
; 2156 :     /* Raise data exception if error occurred */
; 2157 :     if (dxc != 0)

  00233	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00238	85 c0		 test	 eax, eax
  0023a	74 25		 je	 SHORT $LN8@s370_compa

; 2158 :     {
; 2159 :         regs->dxc = dxc;

  0023c	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00241	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00249	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2160 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0024f	ba 07 00 00 00	 mov	 edx, 7
  00254	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025c	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_compa:

; 2161 :     }
; 2162 : 
; 2163 : } /* end DEF_INST(compare_dfp_long_reg) */

  00261	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00269	48 33 cc	 xor	 rcx, rsp
  0026c	e8 00 00 00 00	 call	 __security_check_cookie
  00271	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00278	c3		 ret	 0
s370_compare_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
i$1 = 36
r1$ = 40
r2$ = 44
tv170 = 48
tv171 = 52
tv172 = 56
dr$ = 64
x1$ = 104
x2$ = 120
set$ = 136
d2$ = 168
d1$ = 208
__$ArrayPad$ = 248
inst$ = 272
regs$ = 280
s370_compare_dfp_ext_reg PROC

; 2081 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2082 : int             r1, r2;                 /* Values of R fields        */
; 2083 : decimal128      x1, x2;                 /* Extended DFP values       */
; 2084 : decNumber       d1, d2, dr;             /* Working decimal numbers   */
; 2085 : decContext      set;                    /* Working context           */
; 2086 : BYTE            dxc;                    /* Data exception code       */
; 2087 : 
; 2088 :     RRE(inst, regs, r1, r2);

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_compa:
  00055	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN5@s370_compa
  00078	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_compa:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@s370_compa

; 2089 : 
; 2090 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2091 :     DFPINST_CHECK(regs);

  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 01	 imul	 rax, rax, 1
  00096	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000aa	85 c0		 test	 eax, eax
  000ac	74 3f		 je	 SHORT $LN7@s370_compa
  000ae	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000bc	d1 e8		 shr	 eax, 1
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 55		 je	 SHORT $LN6@s370_compa
  000c5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000d4	b9 08 00 00 00	 mov	 ecx, 8
  000d9	48 6b c9 01	 imul	 rcx, rcx, 1
  000dd	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000e9	85 c0		 test	 eax, eax
  000eb	75 2d		 jne	 SHORT $LN6@s370_compa
$LN7@s370_compa:
  000ed	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000ff	ba 07 00 00 00	 mov	 edx, 7
  00104	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_compa:

; 2092 :     DFPREGPAIR2_CHECK(r1, r2, regs);

  0011a	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  0011e	83 e0 02	 and	 eax, 2
  00121	85 c0		 test	 eax, eax
  00123	75 0b		 jne	 SHORT $LN9@s370_compa
  00125	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  00129	83 e0 02	 and	 eax, 2
  0012c	85 c0		 test	 eax, eax
  0012e	74 1b		 je	 SHORT $LN8@s370_compa
$LN9@s370_compa:
  00130	ba 06 00 00 00	 mov	 edx, 6
  00135	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_compa:

; 2093 : 
; 2094 :     /* Initialise the context for extended DFP */
; 2095 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0014b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00150	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00158	e8 00 00 00 00	 call	 decContextDefault

; 2096 : 
; 2097 :     /* Compare FP register r1 with FP register r2 */
; 2098 :     ARCH_DEP(dfp_reg_to_decimal128)(r1, &x1, regs);

  0015d	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00165	48 8d 54 24 68	 lea	 rdx, QWORD PTR x1$[rsp]
  0016a	8b 4c 24 28	 mov	 ecx, DWORD PTR r1$[rsp]
  0016e	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 2099 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00173	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017b	48 8d 54 24 78	 lea	 rdx, QWORD PTR x2$[rsp]
  00180	8b 4c 24 2c	 mov	 ecx, DWORD PTR r2$[rsp]
  00184	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 2100 :     decimal128ToNumber(&x1, &d1);

  00189	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  00191	48 8d 4c 24 68	 lea	 rcx, QWORD PTR x1$[rsp]
  00196	e8 00 00 00 00	 call	 decimal128ToNumber

; 2101 :     decimal128ToNumber(&x2, &d2);

  0019b	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001a3	48 8d 4c 24 78	 lea	 rcx, QWORD PTR x2$[rsp]
  001a8	e8 00 00 00 00	 call	 decimal128ToNumber

; 2102 :     decNumberCompare(&dr, &d1, &d2, &set);

  001ad	4c 8d 8c 24 88
	00 00 00	 lea	 r9, QWORD PTR set$[rsp]
  001b5	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR d2$[rsp]
  001bd	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR d1$[rsp]
  001c5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR dr$[rsp]
  001ca	e8 00 00 00 00	 call	 decNumberCompare

; 2103 : 
; 2104 :     /* Check for exception condition */
; 2105 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  001cf	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001d7	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001df	e8 00 00 00 00	 call	 s370_dfp_status_check
  001e4	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2106 : 
; 2107 :     /* Set condition code */
; 2108 :     regs->psw.cc = decNumberIsNaN(&dr) ? 3 :

  001e8	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  001ed	83 e0 30	 and	 eax, 48			; 00000030H
  001f0	85 c0		 test	 eax, eax
  001f2	74 0a		 je	 SHORT $LN16@s370_compa
  001f4	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv172[rsp], 3
  001fc	eb 5f		 jmp	 SHORT $LN17@s370_compa
$LN16@s370_compa:
  001fe	b8 02 00 00 00	 mov	 eax, 2
  00203	48 6b c0 00	 imul	 rax, rax, 0
  00207	0f b7 44 04 4a	 movzx	 eax, WORD PTR dr$[rsp+rax+10]
  0020c	85 c0		 test	 eax, eax
  0020e	75 1d		 jne	 SHORT $LN12@s370_compa
  00210	83 7c 24 40 01	 cmp	 DWORD PTR dr$[rsp], 1
  00215	75 16		 jne	 SHORT $LN12@s370_compa
  00217	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  0021c	83 e0 70	 and	 eax, 112		; 00000070H
  0021f	85 c0		 test	 eax, eax
  00221	75 0a		 jne	 SHORT $LN12@s370_compa
  00223	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
  0022b	eb 28		 jmp	 SHORT $LN15@s370_compa
$LN12@s370_compa:
  0022d	0f b6 44 24 48	 movzx	 eax, BYTE PTR dr$[rsp+8]
  00232	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00237	85 c0		 test	 eax, eax
  00239	74 0a		 je	 SHORT $LN13@s370_compa
  0023b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv170[rsp], 1
  00243	eb 08		 jmp	 SHORT $LN14@s370_compa
$LN13@s370_compa:
  00245	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR tv170[rsp], 2
$LN14@s370_compa:
  0024d	8b 44 24 30	 mov	 eax, DWORD PTR tv170[rsp]
  00251	89 44 24 34	 mov	 DWORD PTR tv171[rsp], eax
$LN15@s370_compa:
  00255	8b 44 24 34	 mov	 eax, DWORD PTR tv171[rsp]
  00259	89 44 24 38	 mov	 DWORD PTR tv172[rsp], eax
$LN17@s370_compa:
  0025d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00265	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR tv172[rsp]
  0026a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2109 :                    decNumberIsZero(&dr) ? 0 :
; 2110 :                    decNumberIsNegative(&dr) ? 1 : 2;
; 2111 : 
; 2112 :     /* Raise data exception if error occurred */
; 2113 :     if (dxc != 0)

  0026d	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00272	85 c0		 test	 eax, eax
  00274	74 25		 je	 SHORT $LN10@s370_compa

; 2114 :     {
; 2115 :         regs->dxc = dxc;

  00276	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0027b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00283	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2116 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00289	ba 07 00 00 00	 mov	 edx, 7
  0028e	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00296	e8 00 00 00 00	 call	 s370_program_interrupt
$LN10@s370_compa:

; 2117 :     }
; 2118 : 
; 2119 : } /* end DEF_INST(compare_dfp_ext_reg) */

  0029b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a3	48 33 cc	 xor	 rcx, rsp
  002a6	e8 00 00 00 00	 call	 __security_check_cookie
  002ab	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  002b2	c3		 ret	 0
s370_compare_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv175 = 40
tv176 = 44
tv177 = 48
r2$ = 52
r3$ = 56
r1$ = 60
x2$ = 64
x3$ = 72
x1$ = 80
d1$ = 88
set$ = 128
d3$ = 160
d2$ = 200
__$ArrayPad$ = 240
inst$ = 272
regs$ = 280
s370_add_dfp_long_reg PROC

; 2032 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2033 : int             r1, r2, r3;             /* Values of R fields        */
; 2034 : decimal64       x1, x2, x3;             /* Long DFP values           */
; 2035 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 2036 : decContext      set;                    /* Working context           */
; 2037 : BYTE            dxc;                    /* Data exception code       */
; 2038 : 
; 2039 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 38	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_add_d:
  00062	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_add_d
  00085	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_add_d:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_add_d

; 2040 : 
; 2041 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2042 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_add_d
  000bb	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_add_d
  000d2	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_add_d
$LN7@s370_add_d:
  000fa	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_add_d:

; 2043 : 
; 2044 :     /* Initialise the context for long DFP */
; 2045 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00127	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0012c	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  00134	e8 00 00 00 00	 call	 decContextDefault

; 2046 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  00139	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00141	33 d2		 xor	 edx, edx
  00143	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  0014b	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 2047 : 
; 2048 :     /* Add FP register r3 to FP register r2 */
; 2049 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  00150	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00158	48 8d 54 24 40	 lea	 rdx, QWORD PTR x2$[rsp]
  0015d	8b 4c 24 34	 mov	 ecx, DWORD PTR r2$[rsp]
  00161	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 2050 :     ARCH_DEP(dfp_reg_to_decimal64)(r3, &x3, regs);

  00166	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0016e	48 8d 54 24 48	 lea	 rdx, QWORD PTR x3$[rsp]
  00173	8b 4c 24 38	 mov	 ecx, DWORD PTR r3$[rsp]
  00177	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 2051 :     decimal64ToNumber(&x2, &d2);

  0017c	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  00184	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x2$[rsp]
  00189	e8 00 00 00 00	 call	 decimal64ToNumber

; 2052 :     decimal64ToNumber(&x3, &d3);

  0018e	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  00196	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x3$[rsp]
  0019b	e8 00 00 00 00	 call	 decimal64ToNumber

; 2053 :     decNumberAdd(&d1, &d2, &d3, &set);

  001a0	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR set$[rsp]
  001a8	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  001b0	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001b8	48 8d 4c 24 58	 lea	 rcx, QWORD PTR d1$[rsp]
  001bd	e8 00 00 00 00	 call	 decNumberAdd

; 2054 :     decimal64FromNumber(&x1, &d1, &set);

  001c2	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR set$[rsp]
  001ca	48 8d 54 24 58	 lea	 rdx, QWORD PTR d1$[rsp]
  001cf	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x1$[rsp]
  001d4	e8 00 00 00 00	 call	 decimal64FromNumber

; 2055 : 
; 2056 :     /* Check for exception condition */
; 2057 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  001d9	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001e1	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR set$[rsp]
  001e9	e8 00 00 00 00	 call	 s370_dfp_status_check
  001ee	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2058 : 
; 2059 :     /* Load result into FP register r1 */
; 2060 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  001f2	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001fa	48 8d 54 24 50	 lea	 rdx, QWORD PTR x1$[rsp]
  001ff	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  00203	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 2061 : 
; 2062 :     /* Set condition code */
; 2063 :     regs->psw.cc = decNumberIsNaN(&d1) ? 3 :

  00208	0f b6 44 24 60	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0020d	83 e0 30	 and	 eax, 48			; 00000030H
  00210	85 c0		 test	 eax, eax
  00212	74 0a		 je	 SHORT $LN14@s370_add_d
  00214	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv177[rsp], 3
  0021c	eb 5f		 jmp	 SHORT $LN15@s370_add_d
$LN14@s370_add_d:
  0021e	b8 02 00 00 00	 mov	 eax, 2
  00223	48 6b c0 00	 imul	 rax, rax, 0
  00227	0f b7 44 04 62	 movzx	 eax, WORD PTR d1$[rsp+rax+10]
  0022c	85 c0		 test	 eax, eax
  0022e	75 1d		 jne	 SHORT $LN10@s370_add_d
  00230	83 7c 24 58 01	 cmp	 DWORD PTR d1$[rsp], 1
  00235	75 16		 jne	 SHORT $LN10@s370_add_d
  00237	0f b6 44 24 60	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0023c	83 e0 70	 and	 eax, 112		; 00000070H
  0023f	85 c0		 test	 eax, eax
  00241	75 0a		 jne	 SHORT $LN10@s370_add_d
  00243	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
  0024b	eb 28		 jmp	 SHORT $LN13@s370_add_d
$LN10@s370_add_d:
  0024d	0f b6 44 24 60	 movzx	 eax, BYTE PTR d1$[rsp+8]
  00252	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00257	85 c0		 test	 eax, eax
  00259	74 0a		 je	 SHORT $LN11@s370_add_d
  0025b	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv175[rsp], 1
  00263	eb 08		 jmp	 SHORT $LN12@s370_add_d
$LN11@s370_add_d:
  00265	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv175[rsp], 2
$LN12@s370_add_d:
  0026d	8b 44 24 28	 mov	 eax, DWORD PTR tv175[rsp]
  00271	89 44 24 2c	 mov	 DWORD PTR tv176[rsp], eax
$LN13@s370_add_d:
  00275	8b 44 24 2c	 mov	 eax, DWORD PTR tv176[rsp]
  00279	89 44 24 30	 mov	 DWORD PTR tv177[rsp], eax
$LN15@s370_add_d:
  0027d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00285	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv177[rsp]
  0028a	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2064 :                    decNumberIsZero(&d1) ? 0 :
; 2065 :                    decNumberIsNegative(&d1) ? 1 : 2;
; 2066 : 
; 2067 :     /* Raise data exception if error occurred */
; 2068 :     if (dxc != 0)

  0028d	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00292	85 c0		 test	 eax, eax
  00294	74 25		 je	 SHORT $LN8@s370_add_d

; 2069 :     {
; 2070 :         regs->dxc = dxc;

  00296	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0029b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a3	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2071 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002a9	ba 07 00 00 00	 mov	 edx, 7
  002ae	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b6	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_add_d:

; 2072 :     }
; 2073 : 
; 2074 : } /* end DEF_INST(add_dfp_long_reg) */

  002bb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002c3	48 33 cc	 xor	 rcx, rsp
  002c6	e8 00 00 00 00	 call	 __security_check_cookie
  002cb	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  002d2	c3		 ret	 0
s370_add_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
r3$ = 44
r1$ = 48
tv184 = 52
tv185 = 56
tv186 = 60
d1$ = 64
set$ = 104
x2$ = 136
x3$ = 152
x1$ = 168
d3$ = 184
d2$ = 224
__$ArrayPad$ = 264
inst$ = 288
regs$ = 296
s370_add_dfp_ext_reg PROC

; 1982 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1983 : int             r1, r2, r3;             /* Values of R fields        */
; 1984 : decimal128      x1, x2, x3;             /* Extended DFP values       */
; 1985 : decNumber       d1, d2, d3;             /* Working decimal numbers   */
; 1986 : decContext      set;                    /* Working context           */
; 1987 : BYTE            dxc;                    /* Data exception code       */
; 1988 : 
; 1989 :     RRR(inst, regs, r1, r2, r3);

  00023	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 0c	 shr	 eax, 12
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 2c	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_add_d:
  00062	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006e	48 83 c0 04	 add	 rax, 4
  00072	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 04	 cmp	 eax, 4
  00083	74 0f		 je	 SHORT $LN5@s370_add_d
  00085	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_add_d:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 c8		 jne	 SHORT $LN4@s370_add_d

; 1990 : 
; 1991 :     TXF_FLOAT_INSTR_CHECK( regs );
; 1992 :     DFPINST_CHECK(regs);

  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 01	 imul	 rax, rax, 1
  000a3	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b2	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b7	85 c0		 test	 eax, eax
  000b9	74 3f		 je	 SHORT $LN7@s370_add_d
  000bb	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c9	d1 e8		 shr	 eax, 1
  000cb	83 e0 01	 and	 eax, 1
  000ce	85 c0		 test	 eax, eax
  000d0	74 55		 je	 SHORT $LN6@s370_add_d
  000d2	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e1	b9 08 00 00 00	 mov	 ecx, 8
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000f1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f6	85 c0		 test	 eax, eax
  000f8	75 2d		 jne	 SHORT $LN6@s370_add_d
$LN7@s370_add_d:
  000fa	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0010c	ba 07 00 00 00	 mov	 edx, 7
  00111	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_add_d:

; 1993 :     DFPREGPAIR3_CHECK(r1, r2, r3, regs);

  00127	8b 44 24 30	 mov	 eax, DWORD PTR r1$[rsp]
  0012b	83 e0 02	 and	 eax, 2
  0012e	85 c0		 test	 eax, eax
  00130	75 16		 jne	 SHORT $LN9@s370_add_d
  00132	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00136	83 e0 02	 and	 eax, 2
  00139	85 c0		 test	 eax, eax
  0013b	75 0b		 jne	 SHORT $LN9@s370_add_d
  0013d	8b 44 24 2c	 mov	 eax, DWORD PTR r3$[rsp]
  00141	83 e0 02	 and	 eax, 2
  00144	85 c0		 test	 eax, eax
  00146	74 1b		 je	 SHORT $LN8@s370_add_d
$LN9@s370_add_d:
  00148	ba 06 00 00 00	 mov	 edx, 6
  0014d	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00155	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_add_d:

; 1994 : 
; 1995 :     /* Initialise the context for extended DFP */
; 1996 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  00163	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00168	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  0016d	e8 00 00 00 00	 call	 decContextDefault

; 1997 :     ARCH_DEP(dfp_rounding_mode)(&set, 0, regs);

  00172	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017a	33 d2		 xor	 edx, edx
  0017c	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00181	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 1998 : 
; 1999 :     /* Add FP register r3 to FP register r2 */
; 2000 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00186	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0018e	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  00196	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  0019a	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 2001 :     ARCH_DEP(dfp_reg_to_decimal128)(r3, &x3, regs);

  0019f	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001a7	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR x3$[rsp]
  001af	8b 4c 24 2c	 mov	 ecx, DWORD PTR r3$[rsp]
  001b3	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 2002 :     decimal128ToNumber(&x2, &d2);

  001b8	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001c0	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  001c8	e8 00 00 00 00	 call	 decimal128ToNumber

; 2003 :     decimal128ToNumber(&x3, &d3);

  001cd	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR d3$[rsp]
  001d5	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR x3$[rsp]
  001dd	e8 00 00 00 00	 call	 decimal128ToNumber

; 2004 :     decNumberAdd(&d1, &d2, &d3, &set);

  001e2	4c 8d 4c 24 68	 lea	 r9, QWORD PTR set$[rsp]
  001e7	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR d3$[rsp]
  001ef	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR d2$[rsp]
  001f7	48 8d 4c 24 40	 lea	 rcx, QWORD PTR d1$[rsp]
  001fc	e8 00 00 00 00	 call	 decNumberAdd

; 2005 :     decimal128FromNumber(&x1, &d1, &set);

  00201	4c 8d 44 24 68	 lea	 r8, QWORD PTR set$[rsp]
  00206	48 8d 54 24 40	 lea	 rdx, QWORD PTR d1$[rsp]
  0020b	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR x1$[rsp]
  00213	e8 00 00 00 00	 call	 decimal128FromNumber

; 2006 : 
; 2007 :     /* Check for exception condition */
; 2008 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00218	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00220	48 8d 4c 24 68	 lea	 rcx, QWORD PTR set$[rsp]
  00225	e8 00 00 00 00	 call	 s370_dfp_status_check
  0022a	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 2009 : 
; 2010 :     /* Load result into FP register r1 */
; 2011 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  0022e	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00236	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR x1$[rsp]
  0023e	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  00242	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 2012 : 
; 2013 :     /* Set condition code */
; 2014 :     regs->psw.cc = decNumberIsNaN(&d1) ? 3 :

  00247	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0024c	83 e0 30	 and	 eax, 48			; 00000030H
  0024f	85 c0		 test	 eax, eax
  00251	74 0a		 je	 SHORT $LN16@s370_add_d
  00253	c7 44 24 3c 03
	00 00 00	 mov	 DWORD PTR tv186[rsp], 3
  0025b	eb 5f		 jmp	 SHORT $LN17@s370_add_d
$LN16@s370_add_d:
  0025d	b8 02 00 00 00	 mov	 eax, 2
  00262	48 6b c0 00	 imul	 rax, rax, 0
  00266	0f b7 44 04 4a	 movzx	 eax, WORD PTR d1$[rsp+rax+10]
  0026b	85 c0		 test	 eax, eax
  0026d	75 1d		 jne	 SHORT $LN12@s370_add_d
  0026f	83 7c 24 40 01	 cmp	 DWORD PTR d1$[rsp], 1
  00274	75 16		 jne	 SHORT $LN12@s370_add_d
  00276	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  0027b	83 e0 70	 and	 eax, 112		; 00000070H
  0027e	85 c0		 test	 eax, eax
  00280	75 0a		 jne	 SHORT $LN12@s370_add_d
  00282	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
  0028a	eb 28		 jmp	 SHORT $LN15@s370_add_d
$LN12@s370_add_d:
  0028c	0f b6 44 24 48	 movzx	 eax, BYTE PTR d1$[rsp+8]
  00291	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00296	85 c0		 test	 eax, eax
  00298	74 0a		 je	 SHORT $LN13@s370_add_d
  0029a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv184[rsp], 1
  002a2	eb 08		 jmp	 SHORT $LN14@s370_add_d
$LN13@s370_add_d:
  002a4	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv184[rsp], 2
$LN14@s370_add_d:
  002ac	8b 44 24 34	 mov	 eax, DWORD PTR tv184[rsp]
  002b0	89 44 24 38	 mov	 DWORD PTR tv185[rsp], eax
$LN15@s370_add_d:
  002b4	8b 44 24 38	 mov	 eax, DWORD PTR tv185[rsp]
  002b8	89 44 24 3c	 mov	 DWORD PTR tv186[rsp], eax
$LN17@s370_add_d:
  002bc	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c4	0f b6 4c 24 3c	 movzx	 ecx, BYTE PTR tv186[rsp]
  002c9	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 2015 :                    decNumberIsZero(&d1) ? 0 :
; 2016 :                    decNumberIsNegative(&d1) ? 1 : 2;
; 2017 : 
; 2018 :     /* Raise data exception if error occurred */
; 2019 :     if (dxc != 0)

  002cc	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002d1	85 c0		 test	 eax, eax
  002d3	74 25		 je	 SHORT $LN10@s370_add_d

; 2020 :     {
; 2021 :         regs->dxc = dxc;

  002d5	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  002da	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 2022 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  002e8	ba 07 00 00 00	 mov	 edx, 7
  002ed	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f5	e8 00 00 00 00	 call	 s370_program_interrupt
$LN10@s370_add_d:

; 2023 :     }
; 2024 : 
; 2025 : } /* end DEF_INST(add_dfp_ext_reg) */

  002fa	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00302	48 33 cc	 xor	 rcx, rsp
  00305	e8 00 00 00 00	 call	 __security_check_cookie
  0030a	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00311	c3		 ret	 0
s370_add_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
src_fpc$ = 36
i$1 = 40
new_fpc$ = 44
r1$ = 48
r2$ = 52
inst$ = 80
regs$ = 88
s370_set_fpc_and_signal PROC

; 332  : {

$LN12:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 333  : int             r1, r2;                 /* Values of R fields        */
; 334  : U32             src_fpc, new_fpc;       /* New value for FPC         */
; 335  : BYTE            dxc;                    /* Data exception code       */
; 336  : 
; 337  :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_set_f:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN5@s370_set_f
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_set_f:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_set_f

; 338  : 
; 339  :     TXFC_INSTR_CHECK( regs );
; 340  :     DFPINST_CHECK( regs );

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN7@s370_set_f
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 49		 je	 SHORT $LN6@s370_set_f
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 24		 jne	 SHORT $LN6@s370_set_f
$LN7@s370_set_f:
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  000d2	ba 07 00 00 00	 mov	 edx, 7
  000d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_set_f:

; 341  : 
; 342  :     /* Load new FPC register contents from R1 register bits 32-63 */
; 343  :     src_fpc = regs->GR_L(r1);

  000e7	48 63 44 24 30	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ec	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000f8	89 44 24 24	 mov	 DWORD PTR src_fpc$[rsp], eax

; 344  : 
; 345  :     /* Program check if reserved bits are non-zero */
; 346  :     FPC_CHECK( src_fpc, regs );

  000fc	8b 54 24 24	 mov	 edx, DWORD PTR src_fpc$[rsp]
  00100	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00105	e8 00 00 00 00	 call	 s370_FPC_check

; 347  : 
; 348  :     /* OR the flags from the current FPC register */
; 349  : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 350  :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0010a	b8 01 00 00 00	 mov	 eax, 1
  0010f	48 6b c0 04	 imul	 rax, rax, 4
  00113	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00118	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00120	83 e0 04	 and	 eax, 4
  00123	85 c0		 test	 eax, eax
  00125	74 1e		 je	 SHORT $LN8@s370_set_f

; 351  :         new_fpc = src_fpc | (regs->fpc & FPC_FPX_FLAGS);

  00127	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00132	25 00 00 fc 00	 and	 eax, 16515072		; 00fc0000H
  00137	8b 4c 24 24	 mov	 ecx, DWORD PTR src_fpc$[rsp]
  0013b	0b c8		 or	 ecx, eax
  0013d	8b c1		 mov	 eax, ecx
  0013f	89 44 24 2c	 mov	 DWORD PTR new_fpc$[rsp], eax
  00143	eb 1c		 jmp	 SHORT $LN9@s370_set_f
$LN8@s370_set_f:

; 352  :     else
; 353  : #endif
; 354  :         new_fpc = src_fpc | (regs->fpc & FPC_FLAGS);

  00145	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00150	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00155	8b 4c 24 24	 mov	 ecx, DWORD PTR src_fpc$[rsp]
  00159	0b c8		 or	 ecx, eax
  0015b	8b c1		 mov	 eax, ecx
  0015d	89 44 24 2c	 mov	 DWORD PTR new_fpc$[rsp], eax
$LN9@s370_set_f:

; 355  : 
; 356  :     /* Determine whether an event is to be signaled */
; 357  :     dxc = fpc_signal_check(regs->fpc, src_fpc);

  00161	8b 54 24 24	 mov	 edx, DWORD PTR src_fpc$[rsp]
  00165	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 88 c0 03 00
	00		 mov	 ecx, DWORD PTR [rax+960]
  00170	e8 00 00 00 00	 call	 fpc_signal_check
  00175	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 358  : 
; 359  :     /* Update the FPC register */
; 360  :     regs->fpc = new_fpc;

  00179	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0017e	8b 4c 24 2c	 mov	 ecx, DWORD PTR new_fpc$[rsp]
  00182	89 88 c0 03 00
	00		 mov	 DWORD PTR [rax+960], ecx

; 361  : 
; 362  :     /* Signal a simulated-IEEE-exception event if needed */
; 363  :     if (dxc != 0)

  00188	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0018d	85 c0		 test	 eax, eax
  0018f	74 1f		 je	 SHORT $LN10@s370_set_f

; 364  :     {
; 365  :         regs->dxc = dxc;

  00191	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00196	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0019b	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 366  :         ARCH_DEP( program_interrupt )( regs, PGM_DATA_EXCEPTION );

  001a1	ba 07 00 00 00	 mov	 edx, 7
  001a6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	e8 00 00 00 00	 call	 s370_program_interrupt
$LN10@s370_set_f:

; 367  :     }
; 368  : 
; 369  : } /* end DEF_INST(set_fpc_and_signal) */

  001b0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001b4	c3		 ret	 0
s370_set_fpc_and_signal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
effective_addr2$ = 36
src_fpc$ = 40
b2$ = 44
temp$1 = 48
new_fpc$ = 52
inst$ = 80
regs$ = 88
s370_load_fpc_and_signal PROC

; 286  : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 287  : int             b2;                     /* Base of effective addr    */
; 288  : VADR            effective_addr2;        /* Effective address         */
; 289  : U32             src_fpc, new_fpc;       /* New value for FPC         */
; 290  : BYTE            dxc;                    /* Data exception code       */
; 291  : 
; 292  :     S( inst, regs, b2, effective_addr2 );

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 2c	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 2c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 2a		 je	 SHORT $LN5@s370_load_
  00045	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00066	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0006b	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_load_:
$LN4@s370_load_:
  0006f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00085	33 c0		 xor	 eax, eax
  00087	83 f8 04	 cmp	 eax, 4
  0008a	74 0c		 je	 SHORT $LN6@s370_load_
  0008c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00091	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN6@s370_load_:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 d1		 jne	 SHORT $LN4@s370_load_

; 293  :     PER_ZEROADDR_XCHECK( regs, b2 );
; 294  : 
; 295  :     TXFC_INSTR_CHECK( regs );
; 296  :     DFPINST_CHECK( regs );

  0009e	b8 08 00 00 00	 mov	 eax, 8
  000a3	48 6b c0 01	 imul	 rax, rax, 1
  000a7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b8	85 c0		 test	 eax, eax
  000ba	74 39		 je	 SHORT $LN8@s370_load_
  000bc	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c7	d1 e8		 shr	 eax, 1
  000c9	83 e0 01	 and	 eax, 1
  000cc	85 c0		 test	 eax, eax
  000ce	74 49		 je	 SHORT $LN7@s370_load_
  000d0	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000dc	b9 08 00 00 00	 mov	 ecx, 8
  000e1	48 6b c9 01	 imul	 rcx, rcx, 1
  000e5	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ec	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f1	85 c0		 test	 eax, eax
  000f3	75 24		 jne	 SHORT $LN7@s370_load_
$LN8@s370_load_:
  000f5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000fa	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00104	ba 07 00 00 00	 mov	 edx, 7
  00109	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00113	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN7@s370_load_:

; 297  : 
; 298  :     /* Load new FPC register contents from operand location */
; 299  :     src_fpc = ARCH_DEP( vfetch4 )( effective_addr2, b2, regs );

  00119	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  0011e	8b 54 24 2c	 mov	 edx, DWORD PTR b2$[rsp]
  00122	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00126	e8 00 00 00 00	 call	 s370_vfetch4
  0012b	89 44 24 28	 mov	 DWORD PTR src_fpc$[rsp], eax

; 300  : 
; 301  :     /* Program check if reserved bits are non-zero */
; 302  :     FPC_CHECK( src_fpc, regs );

  0012f	8b 54 24 28	 mov	 edx, DWORD PTR src_fpc$[rsp]
  00133	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00138	e8 00 00 00 00	 call	 s370_FPC_check

; 303  : 
; 304  :     /* OR the flags from the current FPC register */
; 305  : #if defined( FEATURE_037_FP_EXTENSION_FACILITY )
; 306  :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0013d	b8 01 00 00 00	 mov	 eax, 1
  00142	48 6b c0 04	 imul	 rax, rax, 4
  00146	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014b	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00153	83 e0 04	 and	 eax, 4
  00156	85 c0		 test	 eax, eax
  00158	74 1e		 je	 SHORT $LN9@s370_load_

; 307  :         new_fpc = src_fpc | (regs->fpc & FPC_FPX_FLAGS);

  0015a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0015f	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00165	25 00 00 fc 00	 and	 eax, 16515072		; 00fc0000H
  0016a	8b 4c 24 28	 mov	 ecx, DWORD PTR src_fpc$[rsp]
  0016e	0b c8		 or	 ecx, eax
  00170	8b c1		 mov	 eax, ecx
  00172	89 44 24 34	 mov	 DWORD PTR new_fpc$[rsp], eax
  00176	eb 1c		 jmp	 SHORT $LN10@s370_load_
$LN9@s370_load_:

; 308  :     else
; 309  : #endif
; 310  :         new_fpc = src_fpc | (regs->fpc & FPC_FLAGS);

  00178	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0017d	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00183	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00188	8b 4c 24 28	 mov	 ecx, DWORD PTR src_fpc$[rsp]
  0018c	0b c8		 or	 ecx, eax
  0018e	8b c1		 mov	 eax, ecx
  00190	89 44 24 34	 mov	 DWORD PTR new_fpc$[rsp], eax
$LN10@s370_load_:

; 311  : 
; 312  :     /* Determine whether an event is to be signaled */
; 313  :     dxc = fpc_signal_check(regs->fpc, src_fpc);

  00194	8b 54 24 28	 mov	 edx, DWORD PTR src_fpc$[rsp]
  00198	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0019d	8b 88 c0 03 00
	00		 mov	 ecx, DWORD PTR [rax+960]
  001a3	e8 00 00 00 00	 call	 fpc_signal_check
  001a8	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 314  : 
; 315  :     /* Update the FPC register */
; 316  :     regs->fpc = new_fpc;

  001ac	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  001b1	8b 4c 24 34	 mov	 ecx, DWORD PTR new_fpc$[rsp]
  001b5	89 88 c0 03 00
	00		 mov	 DWORD PTR [rax+960], ecx

; 317  : 
; 318  :     /* Signal a simulated-IEEE-exception event if needed */
; 319  :     if (dxc != 0)

  001bb	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  001c0	85 c0		 test	 eax, eax
  001c2	74 1f		 je	 SHORT $LN11@s370_load_

; 320  :     {
; 321  :         regs->dxc = dxc;

  001c4	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  001c9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 322  :         ARCH_DEP( program_interrupt )( regs, PGM_DATA_EXCEPTION );

  001d4	ba 07 00 00 00	 mov	 edx, 7
  001d9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001de	e8 00 00 00 00	 call	 s370_program_interrupt
$LN11@s370_load_:

; 323  :     }
; 324  : 
; 325  : } /* end DEF_INST(load_fpc_and_signal) */

  001e3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001e7	c3		 ret	 0
s370_load_fpc_and_signal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
i2$ = 44
i1$ = 48
inst$ = 80
regs$ = 88
s370_load_positive_fpr_long_reg PROC

; 46   : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 47   : int     r1, r2;                         /* Values of R fields        */
; 48   : int     i1, i2;                         /* FP register subscripts    */
; 49   : 
; 50   :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN5@s370_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 51   : 
; 52   :     TXFC_INSTR_CHECK( regs );
; 53   :     HFPREG2_CHECK(r1, r2, regs);

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN7@s370_load_
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 5f		 je	 SHORT $LN6@s370_load_
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 3a		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000c3	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  000c7	83 e0 09	 and	 eax, 9
  000ca	85 c0		 test	 eax, eax
  000cc	75 0b		 jne	 SHORT $LN9@s370_load_
  000ce	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  000d2	83 e0 09	 and	 eax, 9
  000d5	85 c0		 test	 eax, eax
  000d7	74 24		 je	 SHORT $LN8@s370_load_
$LN9@s370_load_:
  000d9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000de	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  000e8	ba 07 00 00 00	 mov	 edx, 7
  000ed	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:
$LN6@s370_load_:

; 54   : 
; 55   :     i1 = FPR2I(r1);

  000fd	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00101	d1 e0		 shl	 eax, 1
  00103	89 44 24 30	 mov	 DWORD PTR i1$[rsp], eax

; 56   :     i2 = FPR2I(r2);

  00107	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0010b	d1 e0		 shl	 eax, 1
  0010d	89 44 24 2c	 mov	 DWORD PTR i2$[rsp], eax

; 57   : 
; 58   :     /* Copy register contents, clear the sign bit */
; 59   :     regs->fpr[i1] = regs->fpr[i2] & 0x7FFFFFFF;

  00111	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i2$[rsp]
  00116	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	8b 84 81 40 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+832]
  00122	0f ba f0 1f	 btr	 eax, 31
  00126	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i1$[rsp]
  0012b	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00130	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 60   :     regs->fpr[i1+1] = regs->fpr[i2+1];

  00137	8b 44 24 2c	 mov	 eax, DWORD PTR i2$[rsp]
  0013b	ff c0		 inc	 eax
  0013d	48 98		 cdqe
  0013f	8b 4c 24 30	 mov	 ecx, DWORD PTR i1$[rsp]
  00143	ff c1		 inc	 ecx
  00145	48 63 c9	 movsxd	 rcx, ecx
  00148	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0014d	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00152	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  0015a	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 61   : 
; 62   : } /* end DEF_INST(load_positive_fpr_long_reg) */

  00161	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00165	c3		 ret	 0
s370_load_positive_fpr_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
i2$ = 44
i1$ = 48
inst$ = 80
regs$ = 88
s370_load_negative_fpr_long_reg PROC

; 69   : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 70   : int     r1, r2;                         /* Values of R fields        */
; 71   : int     i1, i2;                         /* FP register subscripts    */
; 72   : 
; 73   :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN5@s370_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 74   : 
; 75   :     TXFC_INSTR_CHECK( regs );
; 76   :     HFPREG2_CHECK(r1, r2, regs);

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN7@s370_load_
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 5f		 je	 SHORT $LN6@s370_load_
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 3a		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000c3	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  000c7	83 e0 09	 and	 eax, 9
  000ca	85 c0		 test	 eax, eax
  000cc	75 0b		 jne	 SHORT $LN9@s370_load_
  000ce	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  000d2	83 e0 09	 and	 eax, 9
  000d5	85 c0		 test	 eax, eax
  000d7	74 24		 je	 SHORT $LN8@s370_load_
$LN9@s370_load_:
  000d9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000de	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  000e8	ba 07 00 00 00	 mov	 edx, 7
  000ed	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:
$LN6@s370_load_:

; 77   : 
; 78   :     i1 = FPR2I(r1);

  000fd	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00101	d1 e0		 shl	 eax, 1
  00103	89 44 24 30	 mov	 DWORD PTR i1$[rsp], eax

; 79   :     i2 = FPR2I(r2);

  00107	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0010b	d1 e0		 shl	 eax, 1
  0010d	89 44 24 2c	 mov	 DWORD PTR i2$[rsp], eax

; 80   : 
; 81   :     /* Copy register contents, set the sign bit */
; 82   :     regs->fpr[i1] = regs->fpr[i2] | 0x80000000;

  00111	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i2$[rsp]
  00116	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	8b 84 81 40 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+832]
  00122	0f ba e8 1f	 bts	 eax, 31
  00126	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i1$[rsp]
  0012b	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00130	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 83   :     regs->fpr[i1+1] = regs->fpr[i2+1];

  00137	8b 44 24 2c	 mov	 eax, DWORD PTR i2$[rsp]
  0013b	ff c0		 inc	 eax
  0013d	48 98		 cdqe
  0013f	8b 4c 24 30	 mov	 ecx, DWORD PTR i1$[rsp]
  00143	ff c1		 inc	 ecx
  00145	48 63 c9	 movsxd	 rcx, ecx
  00148	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0014d	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00152	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  0015a	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 84   : 
; 85   : } /* end DEF_INST(load_negative_fpr_long_reg) */

  00161	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00165	c3		 ret	 0
s370_load_negative_fpr_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
i2$ = 44
i1$ = 48
inst$ = 80
regs$ = 88
s370_load_complement_fpr_long_reg PROC

; 125  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 126  : int     r1, r2;                         /* Values of R fields        */
; 127  : int     i1, i2;                         /* FP register subscripts    */
; 128  : 
; 129  :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN5@s370_load_
  0005a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 130  : 
; 131  :     TXFC_INSTR_CHECK( regs );
; 132  :     HFPREG2_CHECK(r1, r2, regs);

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN7@s370_load_
  0008a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 5f		 je	 SHORT $LN6@s370_load_
  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 3a		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000c3	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  000c7	83 e0 09	 and	 eax, 9
  000ca	85 c0		 test	 eax, eax
  000cc	75 0b		 jne	 SHORT $LN9@s370_load_
  000ce	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  000d2	83 e0 09	 and	 eax, 9
  000d5	85 c0		 test	 eax, eax
  000d7	74 24		 je	 SHORT $LN8@s370_load_
$LN9@s370_load_:
  000d9	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000de	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  000e8	ba 07 00 00 00	 mov	 edx, 7
  000ed	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:
$LN6@s370_load_:

; 133  : 
; 134  :     i1 = FPR2I(r1);

  000fd	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00101	d1 e0		 shl	 eax, 1
  00103	89 44 24 30	 mov	 DWORD PTR i1$[rsp], eax

; 135  :     i2 = FPR2I(r2);

  00107	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  0010b	d1 e0		 shl	 eax, 1
  0010d	89 44 24 2c	 mov	 DWORD PTR i2$[rsp], eax

; 136  : 
; 137  :     /* Copy register contents, invert sign bit */
; 138  :     regs->fpr[i1] = regs->fpr[i2] ^ 0x80000000;

  00111	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i2$[rsp]
  00116	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	8b 84 81 40 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+832]
  00122	0f ba f8 1f	 btc	 eax, 31
  00126	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i1$[rsp]
  0012b	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00130	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 139  :     regs->fpr[i1+1] = regs->fpr[i2+1];

  00137	8b 44 24 2c	 mov	 eax, DWORD PTR i2$[rsp]
  0013b	ff c0		 inc	 eax
  0013d	48 98		 cdqe
  0013f	8b 4c 24 30	 mov	 ecx, DWORD PTR i1$[rsp]
  00143	ff c1		 inc	 ecx
  00145	48 63 c9	 movsxd	 rcx, ecx
  00148	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0014d	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00152	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  0015a	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 140  : 
; 141  : } /* end DEF_INST(load_complement_fpr_long_reg) */

  00161	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00165	c3		 ret	 0
s370_load_complement_fpr_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i1$ = 32
temp$1 = 36
r1$ = 40
r2$ = 44
r3$ = 48
i2$ = 52
i3$ = 56
sign$ = 60
inst$ = 80
regs$ = 88
s370_copy_sign_fpr_long_reg PROC

; 92   : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 93   : int     r1, r2, r3;                     /* Values of R fields        */
; 94   : int     i1, i2, i3;                     /* FP register subscripts    */
; 95   : U32     sign;                           /* Work area for sign bit    */
; 96   : 
; 97   :     RRF_M(inst, regs, r1, r2, r3);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 30	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_copy_:
  0004a	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN5@s370_copy_
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_copy_:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@s370_copy_

; 98   : 
; 99   :     TXFC_INSTR_CHECK( regs );
; 100  :     HFPREG2_CHECK(r1, r2, regs);

  00079	b8 08 00 00 00	 mov	 eax, 8
  0007e	48 6b c0 01	 imul	 rax, rax, 1
  00082	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0008e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00093	85 c0		 test	 eax, eax
  00095	74 39		 je	 SHORT $LN7@s370_copy_
  00097	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000a2	d1 e8		 shr	 eax, 1
  000a4	83 e0 01	 and	 eax, 1
  000a7	85 c0		 test	 eax, eax
  000a9	74 5f		 je	 SHORT $LN6@s370_copy_
  000ab	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000b0	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b7	b9 08 00 00 00	 mov	 ecx, 8
  000bc	48 6b c9 01	 imul	 rcx, rcx, 1
  000c0	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000c7	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000cc	85 c0		 test	 eax, eax
  000ce	75 3a		 jne	 SHORT $LN6@s370_copy_
$LN7@s370_copy_:
  000d0	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  000d4	83 e0 09	 and	 eax, 9
  000d7	85 c0		 test	 eax, eax
  000d9	75 0b		 jne	 SHORT $LN9@s370_copy_
  000db	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  000df	83 e0 09	 and	 eax, 9
  000e2	85 c0		 test	 eax, eax
  000e4	74 24		 je	 SHORT $LN8@s370_copy_
$LN9@s370_copy_:
  000e6	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000eb	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  000f5	ba 07 00 00 00	 mov	 edx, 7
  000fa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00104	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_copy_:
$LN6@s370_copy_:

; 101  :     HFPREG_CHECK(r3, regs);

  0010a	b8 08 00 00 00	 mov	 eax, 8
  0010f	48 6b c0 01	 imul	 rax, rax, 1
  00113	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00118	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0011f	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00124	85 c0		 test	 eax, eax
  00126	74 39		 je	 SHORT $LN11@s370_copy_
  00128	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0012d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00133	d1 e8		 shr	 eax, 1
  00135	83 e0 01	 and	 eax, 1
  00138	85 c0		 test	 eax, eax
  0013a	74 54		 je	 SHORT $LN10@s370_copy_
  0013c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00141	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00148	b9 08 00 00 00	 mov	 ecx, 8
  0014d	48 6b c9 01	 imul	 rcx, rcx, 1
  00151	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00158	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0015d	85 c0		 test	 eax, eax
  0015f	75 2f		 jne	 SHORT $LN10@s370_copy_
$LN11@s370_copy_:
  00161	8b 44 24 30	 mov	 eax, DWORD PTR r3$[rsp]
  00165	83 e0 09	 and	 eax, 9
  00168	85 c0		 test	 eax, eax
  0016a	74 24		 je	 SHORT $LN12@s370_copy_
  0016c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00171	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  0017b	ba 07 00 00 00	 mov	 edx, 7
  00180	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00185	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0018a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s370_copy_:
$LN10@s370_copy_:

; 102  : 
; 103  :     i1 = FPR2I(r1);

  00190	8b 44 24 28	 mov	 eax, DWORD PTR r1$[rsp]
  00194	d1 e0		 shl	 eax, 1
  00196	89 44 24 20	 mov	 DWORD PTR i1$[rsp], eax

; 104  :     i2 = FPR2I(r2);

  0019a	8b 44 24 2c	 mov	 eax, DWORD PTR r2$[rsp]
  0019e	d1 e0		 shl	 eax, 1
  001a0	89 44 24 34	 mov	 DWORD PTR i2$[rsp], eax

; 105  :     i3 = FPR2I(r3);

  001a4	8b 44 24 30	 mov	 eax, DWORD PTR r3$[rsp]
  001a8	d1 e0		 shl	 eax, 1
  001aa	89 44 24 38	 mov	 DWORD PTR i3$[rsp], eax

; 106  : 
; 107  :     /* Copy the sign bit from r3 register */
; 108  :     sign = regs->fpr[i3] & 0x80000000;

  001ae	48 63 44 24 38	 movsxd	 rax, DWORD PTR i3$[rsp]
  001b3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001b8	8b 84 81 40 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+832]
  001bf	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  001c4	89 44 24 3c	 mov	 DWORD PTR sign$[rsp], eax

; 109  : 
; 110  :     /* Copy r2 register contents to r1 register */
; 111  :     regs->fpr[i1] = regs->fpr[i2];

  001c8	48 63 44 24 34	 movsxd	 rax, DWORD PTR i2$[rsp]
  001cd	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i1$[rsp]
  001d2	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  001d7	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  001dc	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  001e4	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 112  :     regs->fpr[i1+1] = regs->fpr[i2+1];

  001eb	8b 44 24 34	 mov	 eax, DWORD PTR i2$[rsp]
  001ef	ff c0		 inc	 eax
  001f1	48 98		 cdqe
  001f3	8b 4c 24 20	 mov	 ecx, DWORD PTR i1$[rsp]
  001f7	ff c1		 inc	 ecx
  001f9	48 63 c9	 movsxd	 rcx, ecx
  001fc	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00201	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00206	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  0020e	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 113  : 
; 114  :     /* Insert the sign bit into r1 register */
; 115  :     regs->fpr[i1] &= 0x7FFFFFFF;

  00215	48 63 44 24 20	 movsxd	 rax, DWORD PTR i1$[rsp]
  0021a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0021f	8b 84 81 40 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+832]
  00226	0f ba f0 1f	 btr	 eax, 31
  0022a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i1$[rsp]
  0022f	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00234	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 116  :     regs->fpr[i1] |= sign;

  0023b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i1$[rsp]
  00240	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00245	8b 54 24 3c	 mov	 edx, DWORD PTR sign$[rsp]
  00249	8b 84 81 40 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+832]
  00250	0b c2		 or	 eax, edx
  00252	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i1$[rsp]
  00257	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0025c	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 117  : 
; 118  : } /* end DEF_INST(copy_sign_fpr_long_reg) */

  00263	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00267	c3		 ret	 0
s370_copy_sign_fpr_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
i2$ = 40
r1$ = 44
inst$ = 64
regs$ = 72
s370_load_gr_from_fpr_long_reg PROC

; 172  : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 173  : int     r1, r2;                         /* Values of R fields        */
; 174  : int     i2;                             /* FP register subscript     */
; 175  : 
; 176  :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 2c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN5@s370_load_
  0005a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 177  : 
; 178  :     TXFC_INSTR_CHECK( regs );
; 179  :     HFPREG_CHECK(r2, regs);

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN7@s370_load_
  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 54		 je	 SHORT $LN6@s370_load_
  0009e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 2f		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000c3	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  000c7	83 e0 09	 and	 eax, 9
  000ca	85 c0		 test	 eax, eax
  000cc	74 24		 je	 SHORT $LN8@s370_load_
  000ce	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000d3	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  000dd	ba 07 00 00 00	 mov	 edx, 7
  000e2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000ec	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:
$LN6@s370_load_:

; 180  : 
; 181  :     i2 = FPR2I(r2);

  000f2	8b 44 24 24	 mov	 eax, DWORD PTR r2$[rsp]
  000f6	d1 e0		 shl	 eax, 1
  000f8	89 44 24 28	 mov	 DWORD PTR i2$[rsp], eax

; 182  : 
; 183  :     /* Load general register contents from FP register */
; 184  :     regs->GR_H(r1) = regs->fpr[i2];

  000fc	48 63 44 24 28	 movsxd	 rax, DWORD PTR i2$[rsp]
  00101	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00106	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  0010b	4c 8b 44 24 48	 mov	 r8, QWORD PTR regs$[rsp]
  00110	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  00118	89 84 ca 84 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+644], eax

; 185  :     regs->GR_L(r1) = regs->fpr[i2+1];

  0011f	8b 44 24 28	 mov	 eax, DWORD PTR i2$[rsp]
  00123	ff c0		 inc	 eax
  00125	48 98		 cdqe
  00127	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0012c	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  00131	4c 8b 44 24 48	 mov	 r8, QWORD PTR regs$[rsp]
  00136	41 8b 84 80 40
	03 00 00	 mov	 eax, DWORD PTR [r8+rax*4+832]
  0013e	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 186  : 
; 187  : } /* end DEF_INST(load_gr_from_fpr_long_reg) */

  00145	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00149	c3		 ret	 0
s370_load_gr_from_fpr_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
i$1 = 32
r1$ = 36
r2$ = 40
i1$ = 44
inst$ = 64
regs$ = 72
s370_load_fpr_from_gr_long_reg PROC

; 150  : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 151  : int     r1, r2;                         /* Values of R fields        */
; 152  : int     i1;                             /* FP register subscript     */
; 153  : 
; 154  :     RRE(inst, regs, r1, r2);

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_load_:
  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN5@s370_load_
  0005a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_load_:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@s370_load_

; 155  : 
; 156  :     TXFC_INSTR_CHECK( regs );
; 157  :     HFPREG_CHECK(r1, regs);

  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00081	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00086	85 c0		 test	 eax, eax
  00088	74 39		 je	 SHORT $LN7@s370_load_
  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00095	d1 e8		 shr	 eax, 1
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 54		 je	 SHORT $LN6@s370_load_
  0009e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000aa	b9 08 00 00 00	 mov	 ecx, 8
  000af	48 6b c9 01	 imul	 rcx, rcx, 1
  000b3	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ba	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000bf	85 c0		 test	 eax, eax
  000c1	75 2f		 jne	 SHORT $LN6@s370_load_
$LN7@s370_load_:
  000c3	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  000c7	83 e0 09	 and	 eax, 9
  000ca	85 c0		 test	 eax, eax
  000cc	74 24		 je	 SHORT $LN8@s370_load_
  000ce	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000d3	c7 80 08 07 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1800], 1
  000dd	ba 07 00 00 00	 mov	 edx, 7
  000e2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000ec	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_load_:
$LN6@s370_load_:

; 158  : 
; 159  :     i1 = FPR2I(r1);

  000f2	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  000f6	d1 e0		 shl	 eax, 1
  000f8	89 44 24 2c	 mov	 DWORD PTR i1$[rsp], eax

; 160  : 
; 161  :     /* Load FP register contents from general register */
; 162  :     regs->fpr[i1] = regs->GR_H(r2);

  000fc	48 63 44 24 28	 movsxd	 rax, DWORD PTR r2$[rsp]
  00101	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR i1$[rsp]
  00106	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  0010b	4c 8b 44 24 48	 mov	 r8, QWORD PTR regs$[rsp]
  00110	41 8b 84 c0 84
	02 00 00	 mov	 eax, DWORD PTR [r8+rax*8+644]
  00118	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 163  :     regs->fpr[i1+1] = regs->GR_L(r2);

  0011f	48 63 44 24 28	 movsxd	 rax, DWORD PTR r2$[rsp]
  00124	8b 4c 24 2c	 mov	 ecx, DWORD PTR i1$[rsp]
  00128	ff c1		 inc	 ecx
  0012a	48 63 c9	 movsxd	 rcx, ecx
  0012d	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  00132	4c 8b 44 24 48	 mov	 r8, QWORD PTR regs$[rsp]
  00137	41 8b 84 c0 80
	02 00 00	 mov	 eax, DWORD PTR [r8+rax*8+640]
  0013f	89 84 8a 40 03
	00 00		 mov	 DWORD PTR [rdx+rcx*4+832], eax

; 164  : 
; 165  : } /* end DEF_INST(load_fpr_from_gr_long_reg) */

  00146	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0014a	c3		 ret	 0
s370_load_fpr_from_gr_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
b2$ = 40
inst$ = 64
regs$ = 72
s370_set_dfp_rounding_mode PROC

; 196  : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 197  : int             b2;                     /* Base of effective addr    */
; 198  : VADR            effective_addr2;        /* Effective address         */
; 199  : 
; 200  :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 28	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 28 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 2a		 je	 SHORT $LN5@s370_set_d
  00045	48 63 44 24 28	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00066	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0006b	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN5@s370_set_d:
$LN4@s370_set_d:
  0006f	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00085	33 c0		 xor	 eax, eax
  00087	83 f8 04	 cmp	 eax, 4
  0008a	74 0c		 je	 SHORT $LN6@s370_set_d
  0008c	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00091	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN6@s370_set_d:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 d1		 jne	 SHORT $LN4@s370_set_d

; 201  : 
; 202  :     TXFC_INSTR_CHECK( regs );
; 203  :     DFPINST_CHECK(regs);

  0009e	b8 08 00 00 00	 mov	 eax, 8
  000a3	48 6b c0 01	 imul	 rax, rax, 1
  000a7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b3	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b8	85 c0		 test	 eax, eax
  000ba	74 39		 je	 SHORT $LN8@s370_set_d
  000bc	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000c7	d1 e8		 shr	 eax, 1
  000c9	83 e0 01	 and	 eax, 1
  000cc	85 c0		 test	 eax, eax
  000ce	74 49		 je	 SHORT $LN7@s370_set_d
  000d0	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000dc	b9 08 00 00 00	 mov	 ecx, 8
  000e1	48 6b c9 01	 imul	 rcx, rcx, 1
  000e5	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ec	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000f1	85 c0		 test	 eax, eax
  000f3	75 24		 jne	 SHORT $LN7@s370_set_d
$LN8@s370_set_d:
  000f5	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000fa	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  00104	ba 07 00 00 00	 mov	 edx, 7
  00109	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00113	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN7@s370_set_d:

; 204  : 
; 205  :     /* Set DFP rounding mode in FPC register from address bits 61-63 */
; 206  :     regs->fpc &= ~(FPC_DRM);

  00119	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0011e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00124	83 e0 8f	 and	 eax, -113		; ffffff8fH
  00127	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0012c	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 207  :     regs->fpc |= ((effective_addr2 << FPC_DRM_SHIFT) & FPC_DRM);

  00132	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00136	c1 e0 04	 shl	 eax, 4
  00139	83 e0 70	 and	 eax, 112		; 00000070H
  0013c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  00147	0b c8		 or	 ecx, eax
  00149	8b c1		 mov	 eax, ecx
  0014b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 208  : 
; 209  : } /* end DEF_INST(set_dfp_rounding_mode) */

  00156	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0015a	c3		 ret	 0
s370_set_dfp_rounding_mode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv168 = 40
tv169 = 44
tv171 = 48
m3$ = 52
r2$ = 56
r1$ = 60
m4$ = 64
n1$ = 72
x2$ = 80
set$ = 88
d2$ = 120
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_convert_dfp_long_to_u64_reg PROC

; 3414 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3415 : int             r1, r2;                 /* Values of R fields        */
; 3416 : int             m3, m4;                 /* Values of M fields        */
; 3417 : U64             n1;                     /* Result value              */
; 3418 : decimal64       x2;                     /* Long DFP value            */
; 3419 : decNumber       d2;                     /* Working decimal number    */
; 3420 : decContext      set;                    /* Working context           */
; 3421 : BYTE            dxc;                    /* Data exception code       */
; 3422 : 
; 3423 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 40	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 34	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00070	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_conve
  00093	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_conve

; 3424 : 
; 3425 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3426 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_conve
  000c9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_conve
  000e0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00108	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 3427 : 
; 3428 :     /* Initialise the context for long DFP */
; 3429 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00135	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0013a	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  0013f	e8 00 00 00 00	 call	 decContextDefault

; 3430 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00144	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0014c	8b 54 24 34	 mov	 edx, DWORD PTR m3$[rsp]
  00150	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  00155	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 3431 : 
; 3432 :     /* Load long DFP value from FP register r2 */
; 3433 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  0015a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00162	48 8d 54 24 50	 lea	 rdx, QWORD PTR x2$[rsp]
  00167	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  0016b	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 3434 :     decimal64ToNumber(&x2, &d2);

  00170	48 8d 54 24 78	 lea	 rdx, QWORD PTR d2$[rsp]
  00175	48 8d 4c 24 50	 lea	 rcx, QWORD PTR x2$[rsp]
  0017a	e8 00 00 00 00	 call	 decimal64ToNumber

; 3435 : 
; 3436 :     /* Convert decimal number to 64-bit unsigned integer */
; 3437 :     n1 = dfp_number_to_u64(&d2, &set);

  0017f	48 8d 54 24 58	 lea	 rdx, QWORD PTR set$[rsp]
  00184	48 8d 4c 24 78	 lea	 rcx, QWORD PTR d2$[rsp]
  00189	e8 00 00 00 00	 call	 dfp_number_to_u64
  0018e	48 89 44 24 48	 mov	 QWORD PTR n1$[rsp], rax

; 3438 : 
; 3439 :     /* Check for exception condition */
; 3440 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00193	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0019b	48 8d 4c 24 58	 lea	 rcx, QWORD PTR set$[rsp]
  001a0	e8 00 00 00 00	 call	 s370_dfp_status_check
  001a5	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3441 : 
; 3442 :     /* Load result into general register r1 */
; 3443 :     regs->GR_G(r1) = n1;

  001a9	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001ae	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b6	48 8b 54 24 48	 mov	 rdx, QWORD PTR n1$[rsp]
  001bb	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3444 : 
; 3445 :     /* Set condition code */
; 3446 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  001c3	8b 44 24 6c	 mov	 eax, DWORD PTR set$[rsp+20]
  001c7	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  001cc	85 c0		 test	 eax, eax
  001ce	74 0a		 je	 SHORT $LN14@s370_conve
  001d0	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv171[rsp], 3
  001d8	eb 68		 jmp	 SHORT $LN15@s370_conve
$LN14@s370_conve:
  001da	b8 02 00 00 00	 mov	 eax, 2
  001df	48 6b c0 00	 imul	 rax, rax, 0
  001e3	0f b7 84 04 82
	00 00 00	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  001eb	85 c0		 test	 eax, eax
  001ed	75 20		 jne	 SHORT $LN10@s370_conve
  001ef	83 7c 24 78 01	 cmp	 DWORD PTR d2$[rsp], 1
  001f4	75 19		 jne	 SHORT $LN10@s370_conve
  001f6	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001fe	83 e0 70	 and	 eax, 112		; 00000070H
  00201	85 c0		 test	 eax, eax
  00203	75 0a		 jne	 SHORT $LN10@s370_conve
  00205	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
  0020d	eb 2b		 jmp	 SHORT $LN13@s370_conve
$LN10@s370_conve:
  0020f	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00217	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0021c	85 c0		 test	 eax, eax
  0021e	74 0a		 je	 SHORT $LN11@s370_conve
  00220	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv168[rsp], 1
  00228	eb 08		 jmp	 SHORT $LN12@s370_conve
$LN11@s370_conve:
  0022a	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv168[rsp], 2
$LN12@s370_conve:
  00232	8b 44 24 28	 mov	 eax, DWORD PTR tv168[rsp]
  00236	89 44 24 2c	 mov	 DWORD PTR tv169[rsp], eax
$LN13@s370_conve:
  0023a	8b 44 24 2c	 mov	 eax, DWORD PTR tv169[rsp]
  0023e	89 44 24 30	 mov	 DWORD PTR tv171[rsp], eax
$LN15@s370_conve:
  00242	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024a	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv171[rsp]
  0024f	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3447 :                    decNumberIsZero(&d2) ? 0 :
; 3448 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3449 : 
; 3450 :     /* Raise data exception if error occurred */
; 3451 :     if (dxc != 0)

  00252	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00257	85 c0		 test	 eax, eax
  00259	74 25		 je	 SHORT $LN8@s370_conve

; 3452 :     {
; 3453 :         regs->dxc = dxc;

  0025b	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00260	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3454 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0026e	ba 07 00 00 00	 mov	 edx, 7
  00273	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027b	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_conve:

; 3455 :     }
; 3456 : 
; 3457 : } /* end DEF_INST(convert_dfp_long_to_u64_reg) */

  00280	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00288	48 33 cc	 xor	 rcx, rsp
  0028b	e8 00 00 00 00	 call	 __security_check_cookie
  00290	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00297	c3		 ret	 0
s370_convert_dfp_long_to_u64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
tv173 = 44
tv174 = 48
tv176 = 52
m3$ = 56
r1$ = 60
m4$ = 64
n1$ = 72
set$ = 80
d2$ = 112
x2$ = 152
__$ArrayPad$ = 168
inst$ = 192
regs$ = 200
s370_convert_dfp_ext_to_u64_reg PROC

; 3363 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3364 : int             r1, r2;                 /* Values of R fields        */
; 3365 : int             m3, m4;                 /* Values of M fields        */
; 3366 : U64             n1;                     /* Result value              */
; 3367 : decimal128      x2;                     /* Extended DFP value        */
; 3368 : decNumber       d2;                     /* Working decimal number    */
; 3369 : decContext      set;                    /* Working context           */
; 3370 : BYTE            dxc;                    /* Data exception code       */
; 3371 : 
; 3372 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 40	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00070	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_conve
  00093	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_conve

; 3373 : 
; 3374 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3375 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_conve
  000c9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_conve
  000e0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00108	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 3376 :     DFPREGPAIR_CHECK(r2, regs);

  00135	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00139	83 e0 02	 and	 eax, 2
  0013c	85 c0		 test	 eax, eax
  0013e	74 1b		 je	 SHORT $LN8@s370_conve
  00140	ba 06 00 00 00	 mov	 edx, 6
  00145	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 3377 : 
; 3378 :     /* Initialise the context for extended DFP */
; 3379 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0015b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00160	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00165	e8 00 00 00 00	 call	 decContextDefault

; 3380 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  0016a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00172	8b 54 24 38	 mov	 edx, DWORD PTR m3$[rsp]
  00176	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0017b	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 3381 : 
; 3382 :     /* Load extended DFP value from FP register r2 */
; 3383 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00180	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00188	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  00190	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00194	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 3384 :     decimal128ToNumber(&x2, &d2);

  00199	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  0019e	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  001a6	e8 00 00 00 00	 call	 decimal128ToNumber

; 3385 : 
; 3386 :     /* Convert decimal number to 64-bit unsigned integer */
; 3387 :     n1 = dfp_number_to_u64(&d2, &set);

  001ab	48 8d 54 24 50	 lea	 rdx, QWORD PTR set$[rsp]
  001b0	48 8d 4c 24 70	 lea	 rcx, QWORD PTR d2$[rsp]
  001b5	e8 00 00 00 00	 call	 dfp_number_to_u64
  001ba	48 89 44 24 48	 mov	 QWORD PTR n1$[rsp], rax

; 3388 : 
; 3389 :     /* Check for exception condition */
; 3390 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  001bf	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  001cc	e8 00 00 00 00	 call	 s370_dfp_status_check
  001d1	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3391 : 
; 3392 :     /* Load result into general register r1 */
; 3393 :     regs->GR_G(r1) = n1;

  001d5	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001da	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e2	48 8b 54 24 48	 mov	 rdx, QWORD PTR n1$[rsp]
  001e7	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 3394 : 
; 3395 :     /* Set condition code */
; 3396 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  001ef	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  001f3	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  001f8	85 c0		 test	 eax, eax
  001fa	74 0a		 je	 SHORT $LN15@s370_conve
  001fc	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv176[rsp], 3
  00204	eb 5f		 jmp	 SHORT $LN16@s370_conve
$LN15@s370_conve:
  00206	b8 02 00 00 00	 mov	 eax, 2
  0020b	48 6b c0 00	 imul	 rax, rax, 0
  0020f	0f b7 44 04 7a	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  00214	85 c0		 test	 eax, eax
  00216	75 1d		 jne	 SHORT $LN11@s370_conve
  00218	83 7c 24 70 01	 cmp	 DWORD PTR d2$[rsp], 1
  0021d	75 16		 jne	 SHORT $LN11@s370_conve
  0021f	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00224	83 e0 70	 and	 eax, 112		; 00000070H
  00227	85 c0		 test	 eax, eax
  00229	75 0a		 jne	 SHORT $LN11@s370_conve
  0022b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
  00233	eb 28		 jmp	 SHORT $LN14@s370_conve
$LN11@s370_conve:
  00235	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0023a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0023f	85 c0		 test	 eax, eax
  00241	74 0a		 je	 SHORT $LN12@s370_conve
  00243	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv173[rsp], 1
  0024b	eb 08		 jmp	 SHORT $LN13@s370_conve
$LN12@s370_conve:
  0024d	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv173[rsp], 2
$LN13@s370_conve:
  00255	8b 44 24 2c	 mov	 eax, DWORD PTR tv173[rsp]
  00259	89 44 24 30	 mov	 DWORD PTR tv174[rsp], eax
$LN14@s370_conve:
  0025d	8b 44 24 30	 mov	 eax, DWORD PTR tv174[rsp]
  00261	89 44 24 34	 mov	 DWORD PTR tv176[rsp], eax
$LN16@s370_conve:
  00265	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026d	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv176[rsp]
  00272	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3397 :                    decNumberIsZero(&d2) ? 0 :
; 3398 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3399 : 
; 3400 :     /* Raise data exception if error occurred */
; 3401 :     if (dxc != 0)

  00275	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0027a	85 c0		 test	 eax, eax
  0027c	74 25		 je	 SHORT $LN9@s370_conve

; 3402 :     {
; 3403 :         regs->dxc = dxc;

  0027e	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00283	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028b	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3404 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00291	ba 07 00 00 00	 mov	 edx, 7
  00296	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029e	e8 00 00 00 00	 call	 s370_program_interrupt
$LN9@s370_conve:

; 3405 :     }
; 3406 : 
; 3407 : } /* end DEF_INST(convert_dfp_ext_to_u64_reg) */

  002a3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002ab	48 33 cc	 xor	 rcx, rsp
  002ae	e8 00 00 00 00	 call	 __security_check_cookie
  002b3	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  002ba	c3		 ret	 0
s370_convert_dfp_ext_to_u64_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv168 = 40
tv169 = 44
tv171 = 48
m3$ = 52
r2$ = 56
r1$ = 60
n1$ = 64
m4$ = 68
x2$ = 72
set$ = 80
d2$ = 112
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
s370_convert_dfp_long_to_u32_reg PROC

; 3210 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3211 : int             r1, r2;                 /* Values of R fields        */
; 3212 : int             m3, m4;                 /* Values of M fields        */
; 3213 : U32             n1;                     /* Result value              */
; 3214 : decimal64       x2;                     /* Long DFP value            */
; 3215 : decNumber       d2;                     /* Working decimal number    */
; 3216 : decContext      set;                    /* Working context           */
; 3217 : BYTE            dxc;                    /* Data exception code       */
; 3218 : 
; 3219 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 44	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 34	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_conve

; 3220 : 
; 3221 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3222 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_conve
  000c9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_conve
  000e0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00108	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 3223 : 
; 3224 :     /* Initialise the context for long DFP */
; 3225 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00135	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0013a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0013f	e8 00 00 00 00	 call	 decContextDefault

; 3226 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00144	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0014c	8b 54 24 34	 mov	 edx, DWORD PTR m3$[rsp]
  00150	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00155	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 3227 : 
; 3228 :     /* Load long DFP value from FP register r2 */
; 3229 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  0015a	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00162	48 8d 54 24 48	 lea	 rdx, QWORD PTR x2$[rsp]
  00167	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  0016b	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 3230 :     decimal64ToNumber(&x2, &d2);

  00170	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  00175	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  0017a	e8 00 00 00 00	 call	 decimal64ToNumber

; 3231 : 
; 3232 :     /* Convert decimal number to 32-bit unsigned integer */
; 3233 :     n1 = dfp_number_to_u32(&d2, &set);

  0017f	48 8d 54 24 50	 lea	 rdx, QWORD PTR set$[rsp]
  00184	48 8d 4c 24 70	 lea	 rcx, QWORD PTR d2$[rsp]
  00189	e8 00 00 00 00	 call	 dfp_number_to_u32
  0018e	89 44 24 40	 mov	 DWORD PTR n1$[rsp], eax

; 3234 : 
; 3235 :     /* Check for exception condition */
; 3236 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00192	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0019a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0019f	e8 00 00 00 00	 call	 s370_dfp_status_check
  001a4	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3237 : 
; 3238 :     /* Load result into general register r1 */
; 3239 :     regs->GR_L(r1) = n1;

  001a8	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	8b 54 24 40	 mov	 edx, DWORD PTR n1$[rsp]
  001b9	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3240 : 
; 3241 :     /* Set condition code */
; 3242 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  001c0	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  001c4	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  001c9	85 c0		 test	 eax, eax
  001cb	74 0a		 je	 SHORT $LN14@s370_conve
  001cd	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv171[rsp], 3
  001d5	eb 5f		 jmp	 SHORT $LN15@s370_conve
$LN14@s370_conve:
  001d7	b8 02 00 00 00	 mov	 eax, 2
  001dc	48 6b c0 00	 imul	 rax, rax, 0
  001e0	0f b7 44 04 7a	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  001e5	85 c0		 test	 eax, eax
  001e7	75 1d		 jne	 SHORT $LN10@s370_conve
  001e9	83 7c 24 70 01	 cmp	 DWORD PTR d2$[rsp], 1
  001ee	75 16		 jne	 SHORT $LN10@s370_conve
  001f0	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001f5	83 e0 70	 and	 eax, 112		; 00000070H
  001f8	85 c0		 test	 eax, eax
  001fa	75 0a		 jne	 SHORT $LN10@s370_conve
  001fc	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
  00204	eb 28		 jmp	 SHORT $LN13@s370_conve
$LN10@s370_conve:
  00206	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0020b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00210	85 c0		 test	 eax, eax
  00212	74 0a		 je	 SHORT $LN11@s370_conve
  00214	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv168[rsp], 1
  0021c	eb 08		 jmp	 SHORT $LN12@s370_conve
$LN11@s370_conve:
  0021e	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv168[rsp], 2
$LN12@s370_conve:
  00226	8b 44 24 28	 mov	 eax, DWORD PTR tv168[rsp]
  0022a	89 44 24 2c	 mov	 DWORD PTR tv169[rsp], eax
$LN13@s370_conve:
  0022e	8b 44 24 2c	 mov	 eax, DWORD PTR tv169[rsp]
  00232	89 44 24 30	 mov	 DWORD PTR tv171[rsp], eax
$LN15@s370_conve:
  00236	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023e	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv171[rsp]
  00243	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3243 :                    decNumberIsZero(&d2) ? 0 :
; 3244 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3245 : 
; 3246 :     /* Raise data exception if error occurred */
; 3247 :     if (dxc != 0)

  00246	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0024b	85 c0		 test	 eax, eax
  0024d	74 25		 je	 SHORT $LN8@s370_conve

; 3248 :     {
; 3249 :         regs->dxc = dxc;

  0024f	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00254	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025c	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3250 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00262	ba 07 00 00 00	 mov	 edx, 7
  00267	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026f	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_conve:

; 3251 :     }
; 3252 : 
; 3253 : } /* end DEF_INST(convert_dfp_long_to_u32_reg) */

  00274	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0027c	48 33 cc	 xor	 rcx, rsp
  0027f	e8 00 00 00 00	 call	 __security_check_cookie
  00284	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0028b	c3		 ret	 0
s370_convert_dfp_long_to_u32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
tv173 = 44
tv174 = 48
tv176 = 52
m3$ = 56
r1$ = 60
n1$ = 64
m4$ = 68
set$ = 72
d2$ = 104
x2$ = 144
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_convert_dfp_ext_to_u32_reg PROC

; 3159 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3160 : int             r1, r2;                 /* Values of R fields        */
; 3161 : int             m3, m4;                 /* Values of M fields        */
; 3162 : U32             n1;                     /* Result value              */
; 3163 : decimal128      x2;                     /* Extended DFP value        */
; 3164 : decNumber       d2;                     /* Working decimal number    */
; 3165 : decContext      set;                    /* Working context           */
; 3166 : BYTE            dxc;                    /* Data exception code       */
; 3167 : 
; 3168 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 44	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00070	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_conve
  00093	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_conve

; 3169 : 
; 3170 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3171 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_conve
  000c9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_conve
  000e0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00108	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 3172 :     DFPREGPAIR_CHECK(r2, regs);

  00135	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00139	83 e0 02	 and	 eax, 2
  0013c	85 c0		 test	 eax, eax
  0013e	74 1b		 je	 SHORT $LN8@s370_conve
  00140	ba 06 00 00 00	 mov	 edx, 6
  00145	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 3173 : 
; 3174 :     /* Initialise the context for extended DFP */
; 3175 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0015b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00160	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00165	e8 00 00 00 00	 call	 decContextDefault

; 3176 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  0016a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00172	8b 54 24 38	 mov	 edx, DWORD PTR m3$[rsp]
  00176	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  0017b	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 3177 : 
; 3178 :     /* Load extended DFP value from FP register r2 */
; 3179 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00180	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00188	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  00190	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00194	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 3180 :     decimal128ToNumber(&x2, &d2);

  00199	48 8d 54 24 68	 lea	 rdx, QWORD PTR d2$[rsp]
  0019e	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  001a6	e8 00 00 00 00	 call	 decimal128ToNumber

; 3181 : 
; 3182 :     /* Convert decimal number to 32-bit unsigned integer */
; 3183 :     n1 = dfp_number_to_u32(&d2, &set);

  001ab	48 8d 54 24 48	 lea	 rdx, QWORD PTR set$[rsp]
  001b0	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d2$[rsp]
  001b5	e8 00 00 00 00	 call	 dfp_number_to_u32
  001ba	89 44 24 40	 mov	 DWORD PTR n1$[rsp], eax

; 3184 : 
; 3185 :     /* Check for exception condition */
; 3186 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  001be	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c6	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001cb	e8 00 00 00 00	 call	 s370_dfp_status_check
  001d0	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3187 : 
; 3188 :     /* Load result into general register r1 */
; 3189 :     regs->GR_L(r1) = n1;

  001d4	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001d9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e1	8b 54 24 40	 mov	 edx, DWORD PTR n1$[rsp]
  001e5	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3190 : 
; 3191 :     /* Set condition code */
; 3192 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  001ec	8b 44 24 5c	 mov	 eax, DWORD PTR set$[rsp+20]
  001f0	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  001f5	85 c0		 test	 eax, eax
  001f7	74 0a		 je	 SHORT $LN15@s370_conve
  001f9	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv176[rsp], 3
  00201	eb 5f		 jmp	 SHORT $LN16@s370_conve
$LN15@s370_conve:
  00203	b8 02 00 00 00	 mov	 eax, 2
  00208	48 6b c0 00	 imul	 rax, rax, 0
  0020c	0f b7 44 04 72	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  00211	85 c0		 test	 eax, eax
  00213	75 1d		 jne	 SHORT $LN11@s370_conve
  00215	83 7c 24 68 01	 cmp	 DWORD PTR d2$[rsp], 1
  0021a	75 16		 jne	 SHORT $LN11@s370_conve
  0021c	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00221	83 e0 70	 and	 eax, 112		; 00000070H
  00224	85 c0		 test	 eax, eax
  00226	75 0a		 jne	 SHORT $LN11@s370_conve
  00228	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
  00230	eb 28		 jmp	 SHORT $LN14@s370_conve
$LN11@s370_conve:
  00232	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00237	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0023c	85 c0		 test	 eax, eax
  0023e	74 0a		 je	 SHORT $LN12@s370_conve
  00240	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv173[rsp], 1
  00248	eb 08		 jmp	 SHORT $LN13@s370_conve
$LN12@s370_conve:
  0024a	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv173[rsp], 2
$LN13@s370_conve:
  00252	8b 44 24 2c	 mov	 eax, DWORD PTR tv173[rsp]
  00256	89 44 24 30	 mov	 DWORD PTR tv174[rsp], eax
$LN14@s370_conve:
  0025a	8b 44 24 30	 mov	 eax, DWORD PTR tv174[rsp]
  0025e	89 44 24 34	 mov	 DWORD PTR tv176[rsp], eax
$LN16@s370_conve:
  00262	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026a	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv176[rsp]
  0026f	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3193 :                    decNumberIsZero(&d2) ? 0 :
; 3194 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3195 : 
; 3196 :     /* Raise data exception if error occurred */
; 3197 :     if (dxc != 0)

  00272	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00277	85 c0		 test	 eax, eax
  00279	74 25		 je	 SHORT $LN9@s370_conve

; 3198 :     {
; 3199 :         regs->dxc = dxc;

  0027b	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00280	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00288	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3200 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0028e	ba 07 00 00 00	 mov	 edx, 7
  00293	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029b	e8 00 00 00 00	 call	 s370_program_interrupt
$LN9@s370_conve:

; 3201 :     }
; 3202 : 
; 3203 : } /* end DEF_INST(convert_dfp_ext_to_u32_reg) */

  002a0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a8	48 33 cc	 xor	 rcx, rsp
  002ab	e8 00 00 00 00	 call	 __security_check_cookie
  002b0	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  002b7	c3		 ret	 0
s370_convert_dfp_ext_to_u32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
tv168 = 40
tv169 = 44
tv171 = 48
m3$ = 52
r2$ = 56
r1$ = 60
n1$ = 64
m4$ = 68
x2$ = 72
set$ = 80
d2$ = 112
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
s370_convert_dfp_long_to_fix32_reg PROC

; 3109 : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3110 : int             r1, r2;                 /* Values of R fields        */
; 3111 : int             m3, m4;                 /* Values of M fields        */
; 3112 : S32             n1;                     /* Result value              */
; 3113 : decimal64       x2;                     /* Long DFP value            */
; 3114 : decNumber       d2;                     /* Working decimal number    */
; 3115 : decContext      set;                    /* Working context           */
; 3116 : BYTE            dxc;                    /* Data exception code       */
; 3117 : 
; 3118 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 44	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 34	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_conve

; 3119 : 
; 3120 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3121 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_conve
  000c9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_conve
  000e0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00108	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 3122 : 
; 3123 :     /* Initialise the context for long DFP */
; 3124 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00135	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0013a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0013f	e8 00 00 00 00	 call	 decContextDefault

; 3125 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00144	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0014c	8b 54 24 34	 mov	 edx, DWORD PTR m3$[rsp]
  00150	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  00155	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 3126 : 
; 3127 :     /* Load long DFP value from FP register r2 */
; 3128 :     ARCH_DEP(dfp_reg_to_decimal64)(r2, &x2, regs);

  0015a	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00162	48 8d 54 24 48	 lea	 rdx, QWORD PTR x2$[rsp]
  00167	8b 4c 24 38	 mov	 ecx, DWORD PTR r2$[rsp]
  0016b	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal64

; 3129 :     decimal64ToNumber(&x2, &d2);

  00170	48 8d 54 24 70	 lea	 rdx, QWORD PTR d2$[rsp]
  00175	48 8d 4c 24 48	 lea	 rcx, QWORD PTR x2$[rsp]
  0017a	e8 00 00 00 00	 call	 decimal64ToNumber

; 3130 : 
; 3131 :     /* Convert decimal number to 32-bit binary integer */
; 3132 :     n1 = dfp_number_to_fix32(&d2, &set);

  0017f	48 8d 54 24 50	 lea	 rdx, QWORD PTR set$[rsp]
  00184	48 8d 4c 24 70	 lea	 rcx, QWORD PTR d2$[rsp]
  00189	e8 00 00 00 00	 call	 dfp_number_to_fix32
  0018e	89 44 24 40	 mov	 DWORD PTR n1$[rsp], eax

; 3133 : 
; 3134 :     /* Check for exception condition */
; 3135 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00192	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0019a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR set$[rsp]
  0019f	e8 00 00 00 00	 call	 s370_dfp_status_check
  001a4	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3136 : 
; 3137 :     /* Load result into general register r1 */
; 3138 :     regs->GR_L(r1) = n1;

  001a8	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	8b 54 24 40	 mov	 edx, DWORD PTR n1$[rsp]
  001b9	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3139 : 
; 3140 :     /* Set condition code */
; 3141 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  001c0	8b 44 24 64	 mov	 eax, DWORD PTR set$[rsp+20]
  001c4	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  001c9	85 c0		 test	 eax, eax
  001cb	74 0a		 je	 SHORT $LN14@s370_conve
  001cd	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR tv171[rsp], 3
  001d5	eb 5f		 jmp	 SHORT $LN15@s370_conve
$LN14@s370_conve:
  001d7	b8 02 00 00 00	 mov	 eax, 2
  001dc	48 6b c0 00	 imul	 rax, rax, 0
  001e0	0f b7 44 04 7a	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  001e5	85 c0		 test	 eax, eax
  001e7	75 1d		 jne	 SHORT $LN10@s370_conve
  001e9	83 7c 24 70 01	 cmp	 DWORD PTR d2$[rsp], 1
  001ee	75 16		 jne	 SHORT $LN10@s370_conve
  001f0	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  001f5	83 e0 70	 and	 eax, 112		; 00000070H
  001f8	85 c0		 test	 eax, eax
  001fa	75 0a		 jne	 SHORT $LN10@s370_conve
  001fc	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
  00204	eb 28		 jmp	 SHORT $LN13@s370_conve
$LN10@s370_conve:
  00206	0f b6 44 24 78	 movzx	 eax, BYTE PTR d2$[rsp+8]
  0020b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00210	85 c0		 test	 eax, eax
  00212	74 0a		 je	 SHORT $LN11@s370_conve
  00214	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv168[rsp], 1
  0021c	eb 08		 jmp	 SHORT $LN12@s370_conve
$LN11@s370_conve:
  0021e	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv168[rsp], 2
$LN12@s370_conve:
  00226	8b 44 24 28	 mov	 eax, DWORD PTR tv168[rsp]
  0022a	89 44 24 2c	 mov	 DWORD PTR tv169[rsp], eax
$LN13@s370_conve:
  0022e	8b 44 24 2c	 mov	 eax, DWORD PTR tv169[rsp]
  00232	89 44 24 30	 mov	 DWORD PTR tv171[rsp], eax
$LN15@s370_conve:
  00236	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023e	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR tv171[rsp]
  00243	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3142 :                    decNumberIsZero(&d2) ? 0 :
; 3143 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3144 : 
; 3145 :     /* Raise data exception if error occurred */
; 3146 :     if (dxc != 0)

  00246	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  0024b	85 c0		 test	 eax, eax
  0024d	74 25		 je	 SHORT $LN8@s370_conve

; 3147 :     {
; 3148 :         regs->dxc = dxc;

  0024f	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00254	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025c	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3149 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  00262	ba 07 00 00 00	 mov	 edx, 7
  00267	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026f	e8 00 00 00 00	 call	 s370_program_interrupt
$LN8@s370_conve:

; 3150 :     }
; 3151 : 
; 3152 : } /* end DEF_INST(convert_dfp_long_to_fix32_reg) */

  00274	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0027c	48 33 cc	 xor	 rcx, rsp
  0027f	e8 00 00 00 00	 call	 __security_check_cookie
  00284	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0028b	c3		 ret	 0
s370_convert_dfp_long_to_fix32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
dxc$ = 32
temp$1 = 36
r2$ = 40
tv173 = 44
tv174 = 48
tv176 = 52
m3$ = 56
r1$ = 60
n1$ = 64
m4$ = 68
set$ = 72
d2$ = 104
x2$ = 144
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_convert_dfp_ext_to_fix32_reg PROC

; 3058 : {

$LN17:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3059 : int             r1, r2;                 /* Values of R fields        */
; 3060 : int             m3, m4;                 /* Values of M fields        */
; 3061 : S32             n1;                     /* Result value              */
; 3062 : decimal128      x2;                     /* Extended DFP value        */
; 3063 : decNumber       d2;                     /* Working decimal number    */
; 3064 : decContext      set;                    /* Working context           */
; 3065 : BYTE            dxc;                    /* Data exception code       */
; 3066 : 
; 3067 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 28	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 44	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 38	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00070	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_conve
  00093	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_conve

; 3068 : 
; 3069 :     TXF_FLOAT_INSTR_CHECK( regs );
; 3070 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_conve
  000c9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_conve
  000e0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00108	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 3071 :     DFPREGPAIR_CHECK(r2, regs);

  00135	8b 44 24 28	 mov	 eax, DWORD PTR r2$[rsp]
  00139	83 e0 02	 and	 eax, 2
  0013c	85 c0		 test	 eax, eax
  0013e	74 1b		 je	 SHORT $LN8@s370_conve
  00140	ba 06 00 00 00	 mov	 edx, 6
  00145	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 3072 : 
; 3073 :     /* Initialise the context for extended DFP */
; 3074 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0015b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00160	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00165	e8 00 00 00 00	 call	 decContextDefault

; 3075 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  0016a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00172	8b 54 24 38	 mov	 edx, DWORD PTR m3$[rsp]
  00176	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  0017b	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 3076 : 
; 3077 :     /* Load extended DFP value from FP register r2 */
; 3078 :     ARCH_DEP(dfp_reg_to_decimal128)(r2, &x2, regs);

  00180	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00188	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR x2$[rsp]
  00190	8b 4c 24 28	 mov	 ecx, DWORD PTR r2$[rsp]
  00194	e8 00 00 00 00	 call	 s370_dfp_reg_to_decimal128

; 3079 :     decimal128ToNumber(&x2, &d2);

  00199	48 8d 54 24 68	 lea	 rdx, QWORD PTR d2$[rsp]
  0019e	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR x2$[rsp]
  001a6	e8 00 00 00 00	 call	 decimal128ToNumber

; 3080 : 
; 3081 :     /* Convert decimal number to 32-bit binary integer */
; 3082 :     n1 = dfp_number_to_fix32(&d2, &set);

  001ab	48 8d 54 24 48	 lea	 rdx, QWORD PTR set$[rsp]
  001b0	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d2$[rsp]
  001b5	e8 00 00 00 00	 call	 dfp_number_to_fix32
  001ba	89 44 24 40	 mov	 DWORD PTR n1$[rsp], eax

; 3083 : 
; 3084 :     /* Check for exception condition */
; 3085 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  001be	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c6	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001cb	e8 00 00 00 00	 call	 s370_dfp_status_check
  001d0	88 44 24 20	 mov	 BYTE PTR dxc$[rsp], al

; 3086 : 
; 3087 :     /* Load result into general register r1 */
; 3088 :     regs->GR_L(r1) = n1;

  001d4	48 63 44 24 3c	 movsxd	 rax, DWORD PTR r1$[rsp]
  001d9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e1	8b 54 24 40	 mov	 edx, DWORD PTR n1$[rsp]
  001e5	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 3089 : 
; 3090 :     /* Set condition code */
; 3091 :     regs->psw.cc = (set.status & DEC_IEEE_854_Invalid_operation) ? 3 :

  001ec	8b 44 24 5c	 mov	 eax, DWORD PTR set$[rsp+20]
  001f0	25 dd 00 00 00	 and	 eax, 221		; 000000ddH
  001f5	85 c0		 test	 eax, eax
  001f7	74 0a		 je	 SHORT $LN15@s370_conve
  001f9	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv176[rsp], 3
  00201	eb 5f		 jmp	 SHORT $LN16@s370_conve
$LN15@s370_conve:
  00203	b8 02 00 00 00	 mov	 eax, 2
  00208	48 6b c0 00	 imul	 rax, rax, 0
  0020c	0f b7 44 04 72	 movzx	 eax, WORD PTR d2$[rsp+rax+10]
  00211	85 c0		 test	 eax, eax
  00213	75 1d		 jne	 SHORT $LN11@s370_conve
  00215	83 7c 24 68 01	 cmp	 DWORD PTR d2$[rsp], 1
  0021a	75 16		 jne	 SHORT $LN11@s370_conve
  0021c	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00221	83 e0 70	 and	 eax, 112		; 00000070H
  00224	85 c0		 test	 eax, eax
  00226	75 0a		 jne	 SHORT $LN11@s370_conve
  00228	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
  00230	eb 28		 jmp	 SHORT $LN14@s370_conve
$LN11@s370_conve:
  00232	0f b6 44 24 70	 movzx	 eax, BYTE PTR d2$[rsp+8]
  00237	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0023c	85 c0		 test	 eax, eax
  0023e	74 0a		 je	 SHORT $LN12@s370_conve
  00240	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv173[rsp], 1
  00248	eb 08		 jmp	 SHORT $LN13@s370_conve
$LN12@s370_conve:
  0024a	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv173[rsp], 2
$LN13@s370_conve:
  00252	8b 44 24 2c	 mov	 eax, DWORD PTR tv173[rsp]
  00256	89 44 24 30	 mov	 DWORD PTR tv174[rsp], eax
$LN14@s370_conve:
  0025a	8b 44 24 30	 mov	 eax, DWORD PTR tv174[rsp]
  0025e	89 44 24 34	 mov	 DWORD PTR tv176[rsp], eax
$LN16@s370_conve:
  00262	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026a	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv176[rsp]
  0026f	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 3092 :                    decNumberIsZero(&d2) ? 0 :
; 3093 :                    decNumberIsNegative(&d2) ? 1 : 2;
; 3094 : 
; 3095 :     /* Raise data exception if error occurred */
; 3096 :     if (dxc != 0)

  00272	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00277	85 c0		 test	 eax, eax
  00279	74 25		 je	 SHORT $LN9@s370_conve

; 3097 :     {
; 3098 :         regs->dxc = dxc;

  0027b	0f b6 44 24 20	 movzx	 eax, BYTE PTR dxc$[rsp]
  00280	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00288	89 81 08 07 00
	00		 mov	 DWORD PTR [rcx+1800], eax

; 3099 :         ARCH_DEP(program_interrupt) (regs, PGM_DATA_EXCEPTION);

  0028e	ba 07 00 00 00	 mov	 edx, 7
  00293	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029b	e8 00 00 00 00	 call	 s370_program_interrupt
$LN9@s370_conve:

; 3100 :     }
; 3101 : 
; 3102 : } /* end DEF_INST(convert_dfp_ext_to_fix32_reg) */

  002a0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a8	48 33 cc	 xor	 rcx, rsp
  002ab	e8 00 00 00 00	 call	 __security_check_cookie
  002b0	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  002b7	c3		 ret	 0
s370_convert_dfp_ext_to_fix32_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
dxc$ = 36
m3$ = 40
r2$ = 44
r1$ = 48
m4$ = 52
n2$ = 56
x1$ = 64
set$ = 72
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s370_convert_u64_to_dfp_long_reg PROC

; 2590 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2591 : int             r1, r2;                 /* Values of R fields        */
; 2592 : int             m3, m4;                 /* Values of M fields        */
; 2593 : U64             n2;                     /* Value of R2 register      */
; 2594 : decimal64       x1;                     /* Long DFP value            */
; 2595 : decNumber       d1;                     /* Working decimal number    */
; 2596 : decContext      set;                    /* Working context           */
; 2597 : BYTE            dxc;                    /* Data exception code       */
; 2598 : 
; 2599 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 30	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_conve

; 2600 : 
; 2601 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2602 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_conve
  000c9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_conve
  000e0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00108	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2603 : 
; 2604 :     /* Initialise the context for long DFP */
; 2605 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00135	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0013a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  0013f	e8 00 00 00 00	 call	 decContextDefault

; 2606 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00144	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0014c	8b 54 24 28	 mov	 edx, DWORD PTR m3$[rsp]
  00150	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00155	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 2607 : 
; 2608 :     /* Load 64-bit unsigned value from r2 register */
; 2609 :     n2 = regs->GR_G(r2);

  0015a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0015f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00167	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0016f	48 89 44 24 38	 mov	 QWORD PTR n2$[rsp], rax

; 2610 : 
; 2611 :     /* Convert unsigned binary integer to long DFP format */
; 2612 :     dfp_number_from_u64(&d1, n2, &set);

  00174	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  00179	48 8b 54 24 38	 mov	 rdx, QWORD PTR n2$[rsp]
  0017e	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  00183	e8 00 00 00 00	 call	 dfp_number_from_u64

; 2613 :     decimal64FromNumber(&x1, &d1, &set);

  00188	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  0018d	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  00192	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00197	e8 00 00 00 00	 call	 decimal64FromNumber

; 2614 : 
; 2615 :     /* Check for exception condition */
; 2616 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  0019c	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001a4	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001a9	e8 00 00 00 00	 call	 s370_dfp_status_check
  001ae	88 44 24 24	 mov	 BYTE PTR dxc$[rsp], al

; 2617 : 
; 2618 :     /* Load result into FP register r1 */
; 2619 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  001b2	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001ba	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  001bf	8b 4c 24 30	 mov	 ecx, DWORD PTR r1$[rsp]
  001c3	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 2620 : 
; 2621 : } /* end DEF_INST(convert_u64_to_dfp_long_reg) */

  001c8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d0	48 33 cc	 xor	 rcx, rsp
  001d3	e8 00 00 00 00	 call	 __security_check_cookie
  001d8	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001df	c3		 ret	 0
s370_convert_u64_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
m3$ = 40
r2$ = 44
m4$ = 48
n2$ = 56
set$ = 64
x1$ = 96
d1$ = 112
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
s370_convert_u64_to_dfp_ext_reg PROC

; 2555 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2556 : int             r1, r2;                 /* Values of R fields        */
; 2557 : int             m3, m4;                 /* Values of M fields        */
; 2558 : U64             n2;                     /* Value of R2 register      */
; 2559 : decimal128      x1;                     /* Extended DFP value        */
; 2560 : decNumber       d1;                     /* Working decimal number    */
; 2561 : decContext      set;                    /* Working context           */
; 2562 : 
; 2563 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 30	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_conve

; 2564 : 
; 2565 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2566 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_conve
  000c9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_conve
  000e0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00108	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2567 :     DFPREGPAIR_CHECK(r1, regs);

  00135	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00139	83 e0 02	 and	 eax, 2
  0013c	85 c0		 test	 eax, eax
  0013e	74 1b		 je	 SHORT $LN8@s370_conve
  00140	ba 06 00 00 00	 mov	 edx, 6
  00145	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 2568 : 
; 2569 :     /* Initialise the context for extended DFP */
; 2570 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0015b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00160	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  00165	e8 00 00 00 00	 call	 decContextDefault

; 2571 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  0016a	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00172	8b 54 24 28	 mov	 edx, DWORD PTR m3$[rsp]
  00176	48 8d 4c 24 40	 lea	 rcx, QWORD PTR set$[rsp]
  0017b	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 2572 : 
; 2573 :     /* Load 64-bit unsigned value from r2 register */
; 2574 :     n2 = regs->GR_G(r2);

  00180	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  00185	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00195	48 89 44 24 38	 mov	 QWORD PTR n2$[rsp], rax

; 2575 : 
; 2576 :     /* Convert unsigned binary integer to extended DFP format */
; 2577 :     dfp_number_from_u64(&d1, n2, &set);

  0019a	4c 8d 44 24 40	 lea	 r8, QWORD PTR set$[rsp]
  0019f	48 8b 54 24 38	 mov	 rdx, QWORD PTR n2$[rsp]
  001a4	48 8d 4c 24 70	 lea	 rcx, QWORD PTR d1$[rsp]
  001a9	e8 00 00 00 00	 call	 dfp_number_from_u64

; 2578 :     decimal128FromNumber(&x1, &d1, &set);

  001ae	4c 8d 44 24 40	 lea	 r8, QWORD PTR set$[rsp]
  001b3	48 8d 54 24 70	 lea	 rdx, QWORD PTR d1$[rsp]
  001b8	48 8d 4c 24 60	 lea	 rcx, QWORD PTR x1$[rsp]
  001bd	e8 00 00 00 00	 call	 decimal128FromNumber

; 2579 : 
; 2580 :     /* Load result into FP register r1 */
; 2581 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  001c2	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	48 8d 54 24 60	 lea	 rdx, QWORD PTR x1$[rsp]
  001cf	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  001d3	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 2582 : 
; 2583 : } /* end DEF_INST(convert_u64_to_dfp_ext_reg) */

  001d8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e0	48 33 cc	 xor	 rcx, rsp
  001e3	e8 00 00 00 00	 call	 __security_check_cookie
  001e8	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001ef	c3		 ret	 0
s370_convert_u64_to_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
dxc$ = 36
m3$ = 40
r2$ = 44
n2$ = 48
r1$ = 52
m4$ = 56
x1$ = 64
set$ = 72
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s370_convert_u32_to_dfp_long_reg PROC

; 2437 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2438 : int             r1, r2;                 /* Values of R fields        */
; 2439 : int             m3, m4;                 /* Values of M fields        */
; 2440 : U32             n2;                     /* Value of R2 register      */
; 2441 : decimal64       x1;                     /* Long DFP value            */
; 2442 : decNumber       d1;                     /* Working decimal number    */
; 2443 : decContext      set;                    /* Working context           */
; 2444 : BYTE            dxc;                    /* Data exception code       */
; 2445 : 
; 2446 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 38	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_conve

; 2447 : 
; 2448 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2449 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_conve
  000c9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_conve
  000e0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00108	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2450 : 
; 2451 :     /* Initialise the context for long DFP */
; 2452 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00135	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0013a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  0013f	e8 00 00 00 00	 call	 decContextDefault

; 2453 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00144	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0014c	8b 54 24 28	 mov	 edx, DWORD PTR m3$[rsp]
  00150	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00155	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 2454 : 
; 2455 :     /* Load 32-bit unsigned value from r2 register */
; 2456 :     n2 = regs->GR_L(r2);

  0015a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0015f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00167	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0016e	89 44 24 30	 mov	 DWORD PTR n2$[rsp], eax

; 2457 : 
; 2458 :     /* Convert unsigned binary integer to long DFP format */
; 2459 :     dfp_number_from_u32(&d1, n2, &set);

  00172	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  00177	8b 54 24 30	 mov	 edx, DWORD PTR n2$[rsp]
  0017b	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  00180	e8 00 00 00 00	 call	 dfp_number_from_u32

; 2460 :     decimal64FromNumber(&x1, &d1, &set);

  00185	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  0018a	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  0018f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00194	e8 00 00 00 00	 call	 decimal64FromNumber

; 2461 : 
; 2462 :     /* Check for exception condition */
; 2463 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00199	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001a1	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001a6	e8 00 00 00 00	 call	 s370_dfp_status_check
  001ab	88 44 24 24	 mov	 BYTE PTR dxc$[rsp], al

; 2464 : 
; 2465 :     /* Load result into FP register r1 */
; 2466 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  001af	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001b7	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  001bc	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  001c0	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 2467 : 
; 2468 : } /* end DEF_INST(convert_u32_to_dfp_long_reg) */

  001c5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001cd	48 33 cc	 xor	 rcx, rsp
  001d0	e8 00 00 00 00	 call	 __security_check_cookie
  001d5	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001dc	c3		 ret	 0
s370_convert_u32_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
m3$ = 40
r2$ = 44
n2$ = 48
m4$ = 52
set$ = 56
x1$ = 88
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s370_convert_u32_to_dfp_ext_reg PROC

; 2402 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2403 : int             r1, r2;                 /* Values of R fields        */
; 2404 : int             m3, m4;                 /* Values of M fields        */
; 2405 : U32             n2;                     /* Value of R2 register      */
; 2406 : decimal128      x1;                     /* Extended DFP value        */
; 2407 : decNumber       d1;                     /* Working decimal number    */
; 2408 : decContext      set;                    /* Working context           */
; 2409 : 
; 2410 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_conve

; 2411 : 
; 2412 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2413 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_conve
  000c9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_conve
  000e0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00108	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2414 :     DFPREGPAIR_CHECK(r1, regs);

  00135	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00139	83 e0 02	 and	 eax, 2
  0013c	85 c0		 test	 eax, eax
  0013e	74 1b		 je	 SHORT $LN8@s370_conve
  00140	ba 06 00 00 00	 mov	 edx, 6
  00145	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 2415 : 
; 2416 :     /* Initialise the context for extended DFP */
; 2417 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0015b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00160	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  00165	e8 00 00 00 00	 call	 decContextDefault

; 2418 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  0016a	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00172	8b 54 24 28	 mov	 edx, DWORD PTR m3$[rsp]
  00176	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  0017b	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 2419 : 
; 2420 :     /* Load 32-bit unsigned value from r2 register */
; 2421 :     n2 = regs->GR_L(r2);

  00180	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  00185	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00194	89 44 24 30	 mov	 DWORD PTR n2$[rsp], eax

; 2422 : 
; 2423 :     /* Convert unsigned binary integer to extended DFP format */
; 2424 :     dfp_number_from_u32(&d1, n2, &set);

  00198	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  0019d	8b 54 24 30	 mov	 edx, DWORD PTR n2$[rsp]
  001a1	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  001a6	e8 00 00 00 00	 call	 dfp_number_from_u32

; 2425 :     decimal128FromNumber(&x1, &d1, &set);

  001ab	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  001b0	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  001b5	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  001ba	e8 00 00 00 00	 call	 decimal128FromNumber

; 2426 : 
; 2427 :     /* Load result into FP register r1 */
; 2428 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  001bf	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001c7	48 8d 54 24 58	 lea	 rdx, QWORD PTR x1$[rsp]
  001cc	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  001d0	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 2429 : 
; 2430 : } /* end DEF_INST(convert_u32_to_dfp_ext_reg) */

  001d5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001dd	48 33 cc	 xor	 rcx, rsp
  001e0	e8 00 00 00 00	 call	 __security_check_cookie
  001e5	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001ec	c3		 ret	 0
s370_convert_u32_to_dfp_ext_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
dxc$ = 36
m3$ = 40
r2$ = 44
n2$ = 48
r1$ = 52
m4$ = 56
x1$ = 64
set$ = 72
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s370_convert_fix32_to_dfp_long_reg PROC

; 2364 : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2365 : int             r1, r2;                 /* Values of R fields        */
; 2366 : int             m3, m4;                 /* Values of M fields        */
; 2367 : S32             n2;                     /* Value of R2 register      */
; 2368 : decimal64       x1;                     /* Long DFP value            */
; 2369 : decNumber       d1;                     /* Working decimal number    */
; 2370 : decContext      set;                    /* Working context           */
; 2371 : BYTE            dxc;                    /* Data exception code       */
; 2372 : 
; 2373 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 38	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_conve

; 2374 : 
; 2375 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2376 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_conve
  000c9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_conve
  000e0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00108	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2377 : 
; 2378 :     /* Initialise the context for long DFP */
; 2379 :     decContextDefault(&set, DEC_INIT_DECIMAL64);

  00135	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0013a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  0013f	e8 00 00 00 00	 call	 decContextDefault

; 2380 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  00144	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0014c	8b 54 24 28	 mov	 edx, DWORD PTR m3$[rsp]
  00150	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  00155	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 2381 : 
; 2382 :     /* Load 32-bit binary integer value from r2 register */
; 2383 :     n2 = (S32)(regs->GR_L(r2));

  0015a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0015f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00167	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0016e	89 44 24 30	 mov	 DWORD PTR n2$[rsp], eax

; 2384 : 
; 2385 :     /* Convert binary integer to long DFP format */
; 2386 :     dfp_number_from_fix32(&d1, n2, &set);

  00172	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  00177	8b 54 24 30	 mov	 edx, DWORD PTR n2$[rsp]
  0017b	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  00180	e8 00 00 00 00	 call	 dfp_number_from_fix32

; 2387 :     decimal64FromNumber(&x1, &d1, &set);

  00185	4c 8d 44 24 48	 lea	 r8, QWORD PTR set$[rsp]
  0018a	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  0018f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR x1$[rsp]
  00194	e8 00 00 00 00	 call	 decimal64FromNumber

; 2388 : 
; 2389 :     /* Check for exception condition */
; 2390 :     dxc = ARCH_DEP(dfp_status_check)(&set, regs);

  00199	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001a1	48 8d 4c 24 48	 lea	 rcx, QWORD PTR set$[rsp]
  001a6	e8 00 00 00 00	 call	 s370_dfp_status_check
  001ab	88 44 24 24	 mov	 BYTE PTR dxc$[rsp], al

; 2391 : 
; 2392 :     /* Load result into FP register r1 */
; 2393 :     ARCH_DEP(dfp_reg_from_decimal64)(r1, &x1, regs);

  001af	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001b7	48 8d 54 24 40	 lea	 rdx, QWORD PTR x1$[rsp]
  001bc	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  001c0	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal64

; 2394 : 
; 2395 : } /* end DEF_INST(convert_fix32_to_dfp_long_reg) */

  001c5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001cd	48 33 cc	 xor	 rcx, rsp
  001d0	e8 00 00 00 00	 call	 __security_check_cookie
  001d5	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001dc	c3		 ret	 0
s370_convert_fix32_to_dfp_long_reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dfp.c
_TEXT	SEGMENT
temp$1 = 32
r1$ = 36
m3$ = 40
r2$ = 44
n2$ = 48
m4$ = 52
set$ = 56
x1$ = 88
d1$ = 104
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s370_convert_fix32_to_dfp_ext_reg PROC

; 2329 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2330 : int             r1, r2;                 /* Values of R fields        */
; 2331 : int             m3, m4;                 /* Values of M fields        */
; 2332 : S32             n2;                     /* Value of R2 register      */
; 2333 : decimal128      x1;                     /* Extended DFP value        */
; 2334 : decNumber       d1;                     /* Working decimal number    */
; 2335 : decContext      set;                    /* Working context           */
; 2336 : 
; 2337 :     RRF_MM(inst, regs, r1, r2, m3, m4);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	83 e0 0f	 and	 eax, 15
  00042	89 44 24 2c	 mov	 DWORD PTR r2$[rsp], eax
  00046	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 04	 shr	 eax, 4
  0004d	83 e0 0f	 and	 eax, 15
  00050	89 44 24 24	 mov	 DWORD PTR r1$[rsp], eax
  00054	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00058	c1 e8 08	 shr	 eax, 8
  0005b	83 e0 0f	 and	 eax, 15
  0005e	89 44 24 34	 mov	 DWORD PTR m4$[rsp], eax
  00062	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00066	c1 e8 0c	 shr	 eax, 12
  00069	83 e0 0f	 and	 eax, 15
  0006c	89 44 24 28	 mov	 DWORD PTR m3$[rsp], eax
$LN4@s370_conve:
  00070	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007c	48 83 c0 04	 add	 rax, 4
  00080	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008c	33 c0		 xor	 eax, eax
  0008e	83 f8 04	 cmp	 eax, 4
  00091	74 0f		 je	 SHORT $LN5@s370_conve
  00093	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN5@s370_conve:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 c8		 jne	 SHORT $LN4@s370_conve

; 2338 : 
; 2339 :     TXF_FLOAT_INSTR_CHECK( regs );
; 2340 :     DFPINST_CHECK(regs);

  000a8	b8 08 00 00 00	 mov	 eax, 8
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000c0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000c5	85 c0		 test	 eax, eax
  000c7	74 3f		 je	 SHORT $LN7@s370_conve
  000c9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 55		 je	 SHORT $LN6@s370_conve
  000e0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	b9 08 00 00 00	 mov	 ecx, 8
  000f4	48 6b c9 01	 imul	 rcx, rcx, 1
  000f8	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  000ff	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00104	85 c0		 test	 eax, eax
  00106	75 2d		 jne	 SHORT $LN6@s370_conve
$LN7@s370_conve:
  00108	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	c7 80 08 07 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+1800], 3
  0011a	ba 07 00 00 00	 mov	 edx, 7
  0011f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_conve:

; 2341 :     DFPREGPAIR_CHECK(r1, regs);

  00135	8b 44 24 24	 mov	 eax, DWORD PTR r1$[rsp]
  00139	83 e0 02	 and	 eax, 2
  0013c	85 c0		 test	 eax, eax
  0013e	74 1b		 je	 SHORT $LN8@s370_conve
  00140	ba 06 00 00 00	 mov	 edx, 6
  00145	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00155	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s370_conve:

; 2342 : 
; 2343 :     /* Initialise the context for extended DFP */
; 2344 :     decContextDefault(&set, DEC_INIT_DECIMAL128);

  0015b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00160	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  00165	e8 00 00 00 00	 call	 decContextDefault

; 2345 :     ARCH_DEP(dfp_rounding_mode)(&set, m3, regs);

  0016a	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00172	8b 54 24 28	 mov	 edx, DWORD PTR m3$[rsp]
  00176	48 8d 4c 24 38	 lea	 rcx, QWORD PTR set$[rsp]
  0017b	e8 00 00 00 00	 call	 s370_dfp_rounding_mode

; 2346 : 
; 2347 :     /* Load 32-bit binary integer value from r2 register */
; 2348 :     n2 = (S32)(regs->GR_L(r2));

  00180	48 63 44 24 2c	 movsxd	 rax, DWORD PTR r2$[rsp]
  00185	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00194	89 44 24 30	 mov	 DWORD PTR n2$[rsp], eax

; 2349 : 
; 2350 :     /* Convert binary integer to extended DFP format */
; 2351 :     dfp_number_from_fix32(&d1, n2, &set);

  00198	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  0019d	8b 54 24 30	 mov	 edx, DWORD PTR n2$[rsp]
  001a1	48 8d 4c 24 68	 lea	 rcx, QWORD PTR d1$[rsp]
  001a6	e8 00 00 00 00	 call	 dfp_number_from_fix32

; 2352 :     decimal128FromNumber(&x1, &d1, &set);

  001ab	4c 8d 44 24 38	 lea	 r8, QWORD PTR set$[rsp]
  001b0	48 8d 54 24 68	 lea	 rdx, QWORD PTR d1$[rsp]
  001b5	48 8d 4c 24 58	 lea	 rcx, QWORD PTR x1$[rsp]
  001ba	e8 00 00 00 00	 call	 decimal128FromNumber

; 2353 : 
; 2354 :     /* Load result into FP register r1 */
; 2355 :     ARCH_DEP(dfp_reg_from_decimal128)(r1, &x1, regs);

  001bf	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001c7	48 8d 54 24 58	 lea	 rdx, QWORD PTR x1$[rsp]
  001cc	8b 4c 24 24	 mov	 ecx, DWORD PTR r1$[rsp]
  001d0	e8 00 00 00 00	 call	 s370_dfp_reg_from_decimal128

; 2356 : 
; 2357 : } /* end DEF_INST(convert_fix32_to_dfp_ext_reg) */

  001d5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001dd	48 33 cc	 xor	 rcx, rsp
  001e0	e8 00 00 00 00	 call	 __security_check_cookie
  001e5	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001ec	c3		 ret	 0
s370_convert_fix32_to_dfp_ext_reg ENDP
_TEXT	ENDS
END
