; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	opterr
PUBLIC	optind
PUBLIC	optopt
_DATA	SEGMENT
COMM	optreset:DWORD
COMM	optarg:QWORD
_DATA	ENDS
_BSS	SEGMENT
EMSG	DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
opterr	DD	01H
optind	DD	01H
optopt	DD	03fH
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
recargchar DB	'option requires an argument -- %c', 00H
	ORG $+6
recargstring DB	'option requires an argument -- %s', 00H
	ORG $+6
ambig	DB	'ambiguous option -- %.*s', 00H
	ORG $+7
noarg	DB	'option doesn''t take an argument -- %.*s', 00H
illoptchar DB	'unknown option -- %c', 00H
	ORG $+3
illoptstring DB	'unknown option -- %s', 00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	vfprintf
PUBLIC	getopt
PUBLIC	getopt_long
EXTRN	strchr:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp___p___argv:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	get_symbol:PROC
EXTRN	w32_fprintf:PROC
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vfprintf DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$vfprintf
pdata	ENDS
pdata	SEGMENT
$pdata$getopt DD imagerel $LN11
	DD	imagerel $LN11+183
	DD	imagerel $unwind$getopt
$pdata$getopt_long DD imagerel $LN60
	DD	imagerel $LN60+1511
	DD	imagerel $unwind$getopt_long
$pdata$getopt_internal DD imagerel getopt_internal
	DD	imagerel getopt_internal+1782
	DD	imagerel $unwind$getopt_internal
$pdata$gcd DD	imagerel gcd
	DD	imagerel gcd+72
	DD	imagerel $unwind$gcd
$pdata$permute_args DD imagerel permute_args
	DD	imagerel permute_args+311
	DD	imagerel $unwind$permute_args
$pdata$_vwarnx DD imagerel _vwarnx
	DD	imagerel _vwarnx+150
	DD	imagerel $unwind$_vwarnx
$pdata$warnx DD	imagerel warnx
	DD	imagerel warnx+63
	DD	imagerel $unwind$warnx
pdata	ENDS
_DATA	SEGMENT
nonopt_start DD	0ffffffffH
place	DQ	FLAT:EMSG
nonopt_end DD	0ffffffffH
$SG159083 DB	'%s: ', 00H
	ORG $+3
$SG159085 DB	0aH, 00H
	ORG $+2
$SG159168 DB	'POSIXLY_CORRECT', 00H
$SG159169 DB	'POSIXLY_CORRECT', 00H
$SG159173 DB	'POSIXLY_CORRECT', 00H
$SG159174 DB	'POSIXLY_CORRECT', 00H
_DATA	ENDS
xdata	SEGMENT
$unwind$getopt DD 011201H
	DD	06212H
$unwind$getopt_long DD 011701H
	DD	0a217H
$unwind$getopt_internal DD 011201H
	DD	08212H
$unwind$gcd DD	010c01H
	DD	0220cH
$unwind$permute_args DD 011601H
	DD	0a216H
$unwind$_vwarnx DD 010e01H
	DD	0620eH
$unwind$warnx DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vfprintf DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\getopt.c
_TEXT	SEGMENT
ap$ = 32
fmt$ = 64
warnx	PROC

; 141  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 142  :   va_list ap;
; 143  :   va_start(ap, fmt);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0001d	48 89 44 24 20	 mov	 QWORD PTR ap$[rsp], rax

; 144  :   _vwarnx(fmt, ap);

  00022	48 8b 54 24 20	 mov	 rdx, QWORD PTR ap$[rsp]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fmt$[rsp]
  0002c	e8 00 00 00 00	 call	 _vwarnx

; 145  :   va_end(ap);

  00031	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR ap$[rsp], 0

; 146  : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
warnx	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\getopt.c
_TEXT	SEGMENT
tv73 = 32
tv66 = 40
fmt$ = 64
ap$ = 72
_vwarnx	PROC

; 132  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 133  :   (void)fprintf(stderr, "%s: ", __progname);

  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___p___argv
  00014	b9 08 00 00 00	 mov	 ecx, 8
  00019	48 6b c9 00	 imul	 rcx, rcx, 0
  0001d	48 89 4c 24 28	 mov	 QWORD PTR tv66[rsp], rcx
  00022	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00025	48 89 44 24 20	 mov	 QWORD PTR tv73[rsp], rax
  0002a	b9 02 00 00 00	 mov	 ecx, 2
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv73[rsp]
  0003a	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv66[rsp]
  0003f	4c 8b 04 11	 mov	 r8, QWORD PTR [rcx+rdx]
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159083
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	e8 00 00 00 00	 call	 w32_fprintf

; 134  :   if (fmt != NULL)

  00052	48 83 7c 24 40
	00		 cmp	 QWORD PTR fmt$[rsp], 0
  00058	74 1d		 je	 SHORT $LN2@vwarnx

; 135  :     (void)vfprintf(stderr, fmt, ap);

  0005a	b9 02 00 00 00	 mov	 ecx, 2
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00065	4c 8b 44 24 48	 mov	 r8, QWORD PTR ap$[rsp]
  0006a	48 8b 54 24 40	 mov	 rdx, QWORD PTR fmt$[rsp]
  0006f	48 8b c8	 mov	 rcx, rax
  00072	e8 00 00 00 00	 call	 vfprintf
$LN2@vwarnx:

; 136  :   (void)fprintf(stderr, "\n");

  00077	b9 02 00 00 00	 mov	 ecx, 2
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159085
  00089	48 8b c8	 mov	 rcx, rax
  0008c	e8 00 00 00 00	 call	 w32_fprintf

; 137  : }

  00091	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00095	c3		 ret	 0
_vwarnx	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\getopt.c
_TEXT	SEGMENT
pos$ = 32
i$ = 36
j$ = 40
cstart$ = 44
ncycle$ = 48
nnonopts$ = 52
nopts$ = 56
cyclelen$ = 60
swap$ = 64
panonopt_start$ = 96
panonopt_end$ = 104
opt_end$ = 112
nargv$ = 120
permute_args PROC

; 179  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@permute_ar:

; 180  :         int cstart, cyclelen, i, j, ncycle, nnonopts, nopts, pos;
; 181  :         char *swap;
; 182  : 
; 183  :         _DIAGASSERT(nargv != NULL);

  00016	33 c0		 xor	 eax, eax
  00018	85 c0		 test	 eax, eax
  0001a	75 fa		 jne	 SHORT $LN4@permute_ar

; 184  : 
; 185  :         /*
; 186  :          * compute lengths of blocks and number and size of cycles
; 187  :          */
; 188  :         nnonopts = panonopt_end - panonopt_start;

  0001c	8b 44 24 60	 mov	 eax, DWORD PTR panonopt_start$[rsp]
  00020	8b 4c 24 68	 mov	 ecx, DWORD PTR panonopt_end$[rsp]
  00024	2b c8		 sub	 ecx, eax
  00026	8b c1		 mov	 eax, ecx
  00028	89 44 24 34	 mov	 DWORD PTR nnonopts$[rsp], eax

; 189  :         nopts = opt_end - panonopt_end;

  0002c	8b 44 24 68	 mov	 eax, DWORD PTR panonopt_end$[rsp]
  00030	8b 4c 24 70	 mov	 ecx, DWORD PTR opt_end$[rsp]
  00034	2b c8		 sub	 ecx, eax
  00036	8b c1		 mov	 eax, ecx
  00038	89 44 24 38	 mov	 DWORD PTR nopts$[rsp], eax

; 190  :         ncycle = gcd(nnonopts, nopts);

  0003c	8b 54 24 38	 mov	 edx, DWORD PTR nopts$[rsp]
  00040	8b 4c 24 34	 mov	 ecx, DWORD PTR nnonopts$[rsp]
  00044	e8 00 00 00 00	 call	 gcd
  00049	89 44 24 30	 mov	 DWORD PTR ncycle$[rsp], eax

; 191  :         cyclelen = (opt_end - panonopt_start) / ncycle;

  0004d	8b 44 24 60	 mov	 eax, DWORD PTR panonopt_start$[rsp]
  00051	8b 4c 24 70	 mov	 ecx, DWORD PTR opt_end$[rsp]
  00055	2b c8		 sub	 ecx, eax
  00057	8b c1		 mov	 eax, ecx
  00059	99		 cdq
  0005a	f7 7c 24 30	 idiv	 DWORD PTR ncycle$[rsp]
  0005e	89 44 24 3c	 mov	 DWORD PTR cyclelen$[rsp], eax

; 192  : 
; 193  :         for (i = 0; i < ncycle; i++) {

  00062	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006a	eb 0a		 jmp	 SHORT $LN7@permute_ar
$LN5@permute_ar:
  0006c	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00070	ff c0		 inc	 eax
  00072	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@permute_ar:
  00076	8b 44 24 30	 mov	 eax, DWORD PTR ncycle$[rsp]
  0007a	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0007e	0f 8d ae 00 00
	00		 jge	 $LN6@permute_ar

; 194  :                 cstart = panonopt_end+i;

  00084	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00088	8b 4c 24 68	 mov	 ecx, DWORD PTR panonopt_end$[rsp]
  0008c	03 c8		 add	 ecx, eax
  0008e	8b c1		 mov	 eax, ecx
  00090	89 44 24 2c	 mov	 DWORD PTR cstart$[rsp], eax

; 195  :                 pos = cstart;

  00094	8b 44 24 2c	 mov	 eax, DWORD PTR cstart$[rsp]
  00098	89 44 24 20	 mov	 DWORD PTR pos$[rsp], eax

; 196  :                 for (j = 0; j < cyclelen; j++) {

  0009c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  000a4	eb 0a		 jmp	 SHORT $LN10@permute_ar
$LN8@permute_ar:
  000a6	8b 44 24 28	 mov	 eax, DWORD PTR j$[rsp]
  000aa	ff c0		 inc	 eax
  000ac	89 44 24 28	 mov	 DWORD PTR j$[rsp], eax
$LN10@permute_ar:
  000b0	8b 44 24 3c	 mov	 eax, DWORD PTR cyclelen$[rsp]
  000b4	39 44 24 28	 cmp	 DWORD PTR j$[rsp], eax
  000b8	7d 73		 jge	 SHORT $LN9@permute_ar

; 197  :                         if (pos >= panonopt_end)

  000ba	8b 44 24 68	 mov	 eax, DWORD PTR panonopt_end$[rsp]
  000be	39 44 24 20	 cmp	 DWORD PTR pos$[rsp], eax
  000c2	7c 12		 jl	 SHORT $LN11@permute_ar

; 198  :                                 pos -= nnonopts;

  000c4	8b 44 24 34	 mov	 eax, DWORD PTR nnonopts$[rsp]
  000c8	8b 4c 24 20	 mov	 ecx, DWORD PTR pos$[rsp]
  000cc	2b c8		 sub	 ecx, eax
  000ce	8b c1		 mov	 eax, ecx
  000d0	89 44 24 20	 mov	 DWORD PTR pos$[rsp], eax
  000d4	eb 10		 jmp	 SHORT $LN12@permute_ar
$LN11@permute_ar:

; 199  :                         else
; 200  :                                 pos += nopts;

  000d6	8b 44 24 38	 mov	 eax, DWORD PTR nopts$[rsp]
  000da	8b 4c 24 20	 mov	 ecx, DWORD PTR pos$[rsp]
  000de	03 c8		 add	 ecx, eax
  000e0	8b c1		 mov	 eax, ecx
  000e2	89 44 24 20	 mov	 DWORD PTR pos$[rsp], eax
$LN12@permute_ar:

; 201  :                         swap = nargv[pos];

  000e6	48 63 44 24 20	 movsxd	 rax, DWORD PTR pos$[rsp]
  000eb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR nargv$[rsp]
  000f0	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000f4	48 89 44 24 40	 mov	 QWORD PTR swap$[rsp], rax

; 202  :                         /* LINTED const cast */
; 203  :                         ((char **) nargv)[pos] = nargv[cstart];

  000f9	48 63 44 24 2c	 movsxd	 rax, DWORD PTR cstart$[rsp]
  000fe	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR pos$[rsp]
  00103	48 8b 54 24 78	 mov	 rdx, QWORD PTR nargv$[rsp]
  00108	4c 8b 44 24 78	 mov	 r8, QWORD PTR nargv$[rsp]
  0010d	49 8b 04 c0	 mov	 rax, QWORD PTR [r8+rax*8]
  00111	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 204  :                         /* LINTED const cast */
; 205  :                         ((char **)nargv)[cstart] = swap;

  00115	48 63 44 24 2c	 movsxd	 rax, DWORD PTR cstart$[rsp]
  0011a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR nargv$[rsp]
  0011f	48 8b 54 24 40	 mov	 rdx, QWORD PTR swap$[rsp]
  00124	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 206  :                 }

  00128	e9 79 ff ff ff	 jmp	 $LN8@permute_ar
$LN9@permute_ar:

; 207  :         }

  0012d	e9 3a ff ff ff	 jmp	 $LN5@permute_ar
$LN6@permute_ar:

; 208  : }

  00132	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00136	c3		 ret	 0
permute_args ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\getopt.c
_TEXT	SEGMENT
c$ = 0
a$ = 32
b$ = 40
gcd	PROC

; 155  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 156  :         int c;
; 157  : 
; 158  :         c = a % b;

  0000c	8b 44 24 20	 mov	 eax, DWORD PTR a$[rsp]
  00010	99		 cdq
  00011	f7 7c 24 28	 idiv	 DWORD PTR b$[rsp]
  00015	8b c2		 mov	 eax, edx
  00017	89 04 24	 mov	 DWORD PTR c$[rsp], eax
$LN2@gcd:

; 159  :         while (c != 0) {

  0001a	83 3c 24 00	 cmp	 DWORD PTR c$[rsp], 0
  0001e	74 1f		 je	 SHORT $LN3@gcd

; 160  :                 a = b;

  00020	8b 44 24 28	 mov	 eax, DWORD PTR b$[rsp]
  00024	89 44 24 20	 mov	 DWORD PTR a$[rsp], eax

; 161  :                 b = c;

  00028	8b 04 24	 mov	 eax, DWORD PTR c$[rsp]
  0002b	89 44 24 28	 mov	 DWORD PTR b$[rsp], eax

; 162  :                 c = a % b;

  0002f	8b 44 24 20	 mov	 eax, DWORD PTR a$[rsp]
  00033	99		 cdq
  00034	f7 7c 24 28	 idiv	 DWORD PTR b$[rsp]
  00038	8b c2		 mov	 eax, edx
  0003a	89 04 24	 mov	 DWORD PTR c$[rsp], eax

; 163  :         }

  0003d	eb db		 jmp	 SHORT $LN2@gcd
$LN3@gcd:

; 164  : 
; 165  :         return b;

  0003f	8b 44 24 28	 mov	 eax, DWORD PTR b$[rsp]

; 166  : }

  00043	48 83 c4 18	 add	 rsp, 24
  00047	c3		 ret	 0
gcd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\getopt.c
_TEXT	SEGMENT
optchar$ = 32
tv174 = 36
tv227 = 40
tv268 = 44
tv167 = 48
oli$ = 56
nargc$ = 80
nargv$ = 88
options$ = 96
getopt_internal PROC

; 220  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@getopt_int:

; 221  :         char *oli;                              /* option letter list index */
; 222  :         int optchar;
; 223  : 
; 224  :         _DIAGASSERT(nargv != NULL);

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@getopt_int
$LN7@getopt_int:

; 225  :         _DIAGASSERT(options != NULL);

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN7@getopt_int

; 226  : 
; 227  :         optarg = NULL;

  0001e	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR optarg, 0

; 228  : 
; 229  :         /*
; 230  :          * XXX Some programs (like rsyncd) expect to be able to
; 231  :          * XXX re-initialize optind to 0 and have getopt_long(3)
; 232  :          * XXX properly function again.  Work around this braindamage.
; 233  :          */
; 234  :         if (optind == 0)

  00029	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR optind, 0
  00030	75 0a		 jne	 SHORT $LN8@getopt_int

; 235  :                 optind = 1;

  00032	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR optind, 1
$LN8@getopt_int:

; 236  : 
; 237  :         if (optreset)

  0003c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR optreset, 0
  00043	74 16		 je	 SHORT $LN9@getopt_int

; 238  :                 nonopt_start = nonopt_end = -1;

  00045	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR nonopt_end, -1
  0004f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nonopt_end
  00055	89 05 00 00 00
	00		 mov	 DWORD PTR nonopt_start, eax
$LN9@getopt_int:
$start$64:

; 239  : start:
; 240  :         if (optreset || !*place) {              /* update scanning pointer */

  0005b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR optreset, 0
  00062	75 12		 jne	 SHORT $LN11@getopt_int
  00064	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR place
  0006b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0006e	85 c0		 test	 eax, eax
  00070	0f 85 88 02 00
	00		 jne	 $LN10@getopt_int
$LN11@getopt_int:

; 241  :                 optreset = 0;

  00076	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR optreset, 0

; 242  :                 if (optind >= nargc) {          /* end of argument vector */

  00080	8b 44 24 50	 mov	 eax, DWORD PTR nargc$[rsp]
  00084	39 05 00 00 00
	00		 cmp	 DWORD PTR optind, eax
  0008a	0f 8c 8b 00 00
	00		 jl	 $LN12@getopt_int

; 243  :                         place = EMSG;

  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:EMSG
  00097	48 89 05 00 00
	00 00		 mov	 QWORD PTR place, rax

; 244  :                         if (nonopt_end != -1) {

  0009e	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR nonopt_end, -1
  000a5	74 3f		 je	 SHORT $LN13@getopt_int

; 245  :                                 /* do permutation, if we have to */
; 246  :                                 permute_args(nonopt_start, nonopt_end,

  000a7	4c 8b 4c 24 58	 mov	 r9, QWORD PTR nargv$[rsp]
  000ac	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR optind
  000b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR nonopt_end
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR nonopt_start
  000bf	e8 00 00 00 00	 call	 permute_args

; 247  :                                     optind, nargv);
; 248  :                                 optind -= nonopt_end - nonopt_start;

  000c4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nonopt_start
  000ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR nonopt_end
  000d0	2b c8		 sub	 ecx, eax
  000d2	8b c1		 mov	 eax, ecx
  000d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR optind
  000da	2b c8		 sub	 ecx, eax
  000dc	8b c1		 mov	 eax, ecx
  000de	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax

; 249  :                         }

  000e4	eb 15		 jmp	 SHORT $LN14@getopt_int
$LN13@getopt_int:

; 250  :                         else if (nonopt_start != -1) {

  000e6	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR nonopt_start, -1
  000ed	74 0c		 je	 SHORT $LN15@getopt_int

; 251  :                                 /*
; 252  :                                  * If we skipped non-options, set optind
; 253  :                                  * to the first of them.
; 254  :                                  */
; 255  :                                 optind = nonopt_start;

  000ef	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nonopt_start
  000f5	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax
$LN15@getopt_int:
$LN14@getopt_int:

; 256  :                         }
; 257  :                         nonopt_start = nonopt_end = -1;

  000fb	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR nonopt_end, -1
  00105	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nonopt_end
  0010b	89 05 00 00 00
	00		 mov	 DWORD PTR nonopt_start, eax

; 258  :                         return -1;

  00111	b8 ff ff ff ff	 mov	 eax, -1
  00116	e9 d6 05 00 00	 jmp	 $LN1@getopt_int
$LN12@getopt_int:

; 259  :                 }
; 260  :                 if ((*(place = nargv[optind]) != '-')
; 261  :                     || (place[1] == '\0')) {    /* found non-option */

  0011b	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR optind
  00122	48 8b 4c 24 58	 mov	 rcx, QWORD PTR nargv$[rsp]
  00127	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0012b	48 89 05 00 00
	00 00		 mov	 QWORD PTR place, rax
  00132	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR place
  00139	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0013c	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0013f	75 1c		 jne	 SHORT $LN17@getopt_int
  00141	b8 01 00 00 00	 mov	 eax, 1
  00146	48 6b c0 01	 imul	 rax, rax, 1
  0014a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR place
  00151	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00155	85 c0		 test	 eax, eax
  00157	0f 85 30 01 00
	00		 jne	 $LN16@getopt_int
$LN17@getopt_int:

; 262  :                         place = EMSG;

  0015d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:EMSG
  00164	48 89 05 00 00
	00 00		 mov	 QWORD PTR place, rax

; 263  :                         if (IN_ORDER) {

  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159168
  00172	e8 00 00 00 00	 call	 get_symbol
  00177	48 85 c0	 test	 rax, rax
  0017a	74 13		 je	 SHORT $LN19@getopt_int
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159169
  00183	e8 00 00 00 00	 call	 get_symbol
  00188	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0018b	85 c0		 test	 eax, eax
  0018d	75 3c		 jne	 SHORT $LN18@getopt_int
$LN19@getopt_int:
  0018f	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  00194	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00197	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0019a	75 2f		 jne	 SHORT $LN18@getopt_int

; 264  :                                 /*
; 265  :                                  * GNU extension:
; 266  :                                  * return non-option as argument to option 1
; 267  :                                  */
; 268  :                                 optarg = nargv[optind++];

  0019c	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR optind
  001a3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR nargv$[rsp]
  001a8	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  001ac	48 89 05 00 00
	00 00		 mov	 QWORD PTR optarg, rax
  001b3	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR optind
  001b9	ff c0		 inc	 eax
  001bb	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax

; 269  :                                 return INORDER;

  001c1	b8 01 00 00 00	 mov	 eax, 1
  001c6	e9 26 05 00 00	 jmp	 $LN1@getopt_int
$LN18@getopt_int:

; 270  :                         }
; 271  :                         if (!PERMUTE) {

  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159173
  001d2	e8 00 00 00 00	 call	 get_symbol
  001d7	48 85 c0	 test	 rax, rax
  001da	74 13		 je	 SHORT $LN22@getopt_int
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159174
  001e3	e8 00 00 00 00	 call	 get_symbol
  001e8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001eb	85 c0		 test	 eax, eax
  001ed	75 1a		 jne	 SHORT $LN21@getopt_int
$LN22@getopt_int:
  001ef	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  001f4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001f7	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001fa	74 0d		 je	 SHORT $LN23@getopt_int
  001fc	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  00201	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00204	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00207	75 0a		 jne	 SHORT $LN20@getopt_int
$LN23@getopt_int:
$LN21@getopt_int:

; 272  :                                 /*
; 273  :                                  * if no permutation wanted, stop parsing
; 274  :                                  * at first non-option
; 275  :                                  */
; 276  :                                 return -1;

  00209	b8 ff ff ff ff	 mov	 eax, -1
  0020e	e9 de 04 00 00	 jmp	 $LN1@getopt_int
$LN20@getopt_int:

; 277  :                         }
; 278  :                         /* do permutation */
; 279  :                         if (nonopt_start == -1)

  00213	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR nonopt_start, -1
  0021a	75 0e		 jne	 SHORT $LN24@getopt_int

; 280  :                                 nonopt_start = optind;

  0021c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR optind
  00222	89 05 00 00 00
	00		 mov	 DWORD PTR nonopt_start, eax
  00228	eb 50		 jmp	 SHORT $LN25@getopt_int
$LN24@getopt_int:

; 281  :                         else if (nonopt_end != -1) {

  0022a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR nonopt_end, -1
  00231	74 47		 je	 SHORT $LN26@getopt_int

; 282  :                                 permute_args(nonopt_start, nonopt_end,

  00233	4c 8b 4c 24 58	 mov	 r9, QWORD PTR nargv$[rsp]
  00238	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR optind
  0023f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR nonopt_end
  00245	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR nonopt_start
  0024b	e8 00 00 00 00	 call	 permute_args

; 283  :                                     optind, nargv);
; 284  :                                 nonopt_start = optind -

  00250	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nonopt_start
  00256	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR nonopt_end
  0025c	2b c8		 sub	 ecx, eax
  0025e	8b c1		 mov	 eax, ecx
  00260	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR optind
  00266	2b c8		 sub	 ecx, eax
  00268	8b c1		 mov	 eax, ecx
  0026a	89 05 00 00 00
	00		 mov	 DWORD PTR nonopt_start, eax

; 285  :                                     (nonopt_end - nonopt_start);
; 286  :                                 nonopt_end = -1;

  00270	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR nonopt_end, -1
$LN26@getopt_int:
$LN25@getopt_int:

; 287  :                         }
; 288  :                         optind++;

  0027a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR optind
  00280	ff c0		 inc	 eax
  00282	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax

; 289  :                         /* process next argument */
; 290  :                         goto start;

  00288	e9 ce fd ff ff	 jmp	 $start$64
$LN16@getopt_int:

; 291  :                 }
; 292  :                 if (nonopt_start != -1 && nonopt_end == -1)

  0028d	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR nonopt_start, -1
  00294	74 15		 je	 SHORT $LN27@getopt_int
  00296	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR nonopt_end, -1
  0029d	75 0c		 jne	 SHORT $LN27@getopt_int

; 293  :                         nonopt_end = optind;

  0029f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR optind
  002a5	89 05 00 00 00
	00		 mov	 DWORD PTR nonopt_end, eax
$LN27@getopt_int:

; 294  :                 if (place[1] && *++place == '-') {      /* found "--" */

  002ab	b8 01 00 00 00	 mov	 eax, 1
  002b0	48 6b c0 01	 imul	 rax, rax, 1
  002b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR place
  002bb	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  002bf	85 c0		 test	 eax, eax
  002c1	74 3b		 je	 SHORT $LN28@getopt_int
  002c3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR place
  002ca	48 ff c0	 inc	 rax
  002cd	48 89 05 00 00
	00 00		 mov	 QWORD PTR place, rax
  002d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR place
  002db	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002de	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  002e1	75 1b		 jne	 SHORT $LN28@getopt_int

; 295  :                         place++;

  002e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR place
  002ea	48 ff c0	 inc	 rax
  002ed	48 89 05 00 00
	00 00		 mov	 QWORD PTR place, rax

; 296  :                         return -2;

  002f4	b8 fe ff ff ff	 mov	 eax, -2
  002f9	e9 f3 03 00 00	 jmp	 $LN1@getopt_int
$LN28@getopt_int:
$LN10@getopt_int:

; 297  :                 }
; 298  :         }
; 299  :         if ((optchar = (int)*place++) == (int)':' ||

  002fe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR place
  00305	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00308	89 44 24 20	 mov	 DWORD PTR optchar$[rsp], eax
  0030c	8b 44 24 20	 mov	 eax, DWORD PTR optchar$[rsp]
  00310	89 44 24 30	 mov	 DWORD PTR tv167[rsp], eax
  00314	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR place
  0031b	48 ff c0	 inc	 rax
  0031e	48 89 05 00 00
	00 00		 mov	 QWORD PTR place, rax
  00325	83 7c 24 30 3a	 cmp	 DWORD PTR tv167[rsp], 58 ; 0000003aH
  0032a	74 59		 je	 SHORT $LN30@getopt_int
  0032c	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  00331	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00334	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00337	74 17		 je	 SHORT $LN54@getopt_int
  00339	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  0033e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00341	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00344	74 0a		 je	 SHORT $LN54@getopt_int
  00346	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
  0034e	eb 08		 jmp	 SHORT $LN55@getopt_int
$LN54@getopt_int:
  00350	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
$LN55@getopt_int:
  00358	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv174[rsp]
  0035d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR options$[rsp]
  00362	48 03 c8	 add	 rcx, rax
  00365	48 8b c1	 mov	 rax, rcx
  00368	8b 54 24 20	 mov	 edx, DWORD PTR optchar$[rsp]
  0036c	48 8b c8	 mov	 rcx, rax
  0036f	e8 00 00 00 00	 call	 strchr
  00374	48 89 44 24 38	 mov	 QWORD PTR oli$[rsp], rax
  00379	48 83 7c 24 38
	00		 cmp	 QWORD PTR oli$[rsp], 0
  0037f	0f 85 87 00 00
	00		 jne	 $LN29@getopt_int
$LN30@getopt_int:

; 300  :             (oli = strchr(options + (IGNORE_FIRST ? 1 : 0), optchar)) == NULL) {
; 301  :                 /* option letter unknown or ':' */
; 302  :                 if (!*place)

  00385	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR place
  0038c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0038f	85 c0		 test	 eax, eax
  00391	75 0e		 jne	 SHORT $LN31@getopt_int

; 303  :                         ++optind;

  00393	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR optind
  00399	ff c0		 inc	 eax
  0039b	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax
$LN31@getopt_int:

; 304  :                 if (PRINT_ERROR)

  003a1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR opterr, 0
  003a8	74 4e		 je	 SHORT $LN32@getopt_int
  003aa	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  003af	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003b2	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  003b5	75 31		 jne	 SHORT $LN33@getopt_int
  003b7	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  003bc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003bf	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  003c2	74 0d		 je	 SHORT $LN34@getopt_int
  003c4	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  003c9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003cc	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  003cf	75 27		 jne	 SHORT $LN32@getopt_int
$LN34@getopt_int:
  003d1	b8 01 00 00 00	 mov	 eax, 1
  003d6	48 6b c0 01	 imul	 rax, rax, 1
  003da	48 8b 4c 24 60	 mov	 rcx, QWORD PTR options$[rsp]
  003df	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  003e3	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  003e6	74 10		 je	 SHORT $LN32@getopt_int
$LN33@getopt_int:

; 305  :                         warnx(illoptchar, optchar);

  003e8	8b 54 24 20	 mov	 edx, DWORD PTR optchar$[rsp]
  003ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:illoptchar
  003f3	e8 00 00 00 00	 call	 warnx
$LN32@getopt_int:

; 306  :                 optopt = optchar;

  003f8	8b 44 24 20	 mov	 eax, DWORD PTR optchar$[rsp]
  003fc	89 05 00 00 00
	00		 mov	 DWORD PTR optopt, eax

; 307  :                 return BADCH;

  00402	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00407	e9 e5 02 00 00	 jmp	 $LN1@getopt_int
$LN29@getopt_int:

; 308  :         }
; 309  :         if (optchar == 'W' && oli[1] == ';') {          /* -W long-option */

  0040c	83 7c 24 20 57	 cmp	 DWORD PTR optchar$[rsp], 87 ; 00000057H
  00411	0f 85 3c 01 00
	00		 jne	 $LN35@getopt_int
  00417	b8 01 00 00 00	 mov	 eax, 1
  0041c	48 6b c0 01	 imul	 rax, rax, 1
  00420	48 8b 4c 24 38	 mov	 rcx, QWORD PTR oli$[rsp]
  00425	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00429	83 f8 3b	 cmp	 eax, 59			; 0000003bH
  0042c	0f 85 21 01 00
	00		 jne	 $LN35@getopt_int

; 310  :                 /* XXX: what if no long options provided (called by getopt)? */
; 311  :                 if (*place)

  00432	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR place
  00439	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0043c	85 c0		 test	 eax, eax
  0043e	74 0a		 je	 SHORT $LN36@getopt_int

; 312  :                         return -2;

  00440	b8 fe ff ff ff	 mov	 eax, -2
  00445	e9 a7 02 00 00	 jmp	 $LN1@getopt_int
$LN36@getopt_int:

; 313  : 
; 314  :                 if (++optind >= nargc) {        /* no arg */

  0044a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR optind
  00450	ff c0		 inc	 eax
  00452	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax
  00458	8b 44 24 50	 mov	 eax, DWORD PTR nargc$[rsp]
  0045c	39 05 00 00 00
	00		 cmp	 DWORD PTR optind, eax
  00462	0f 8c ca 00 00
	00		 jl	 $LN37@getopt_int

; 315  :                         place = EMSG;

  00468	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:EMSG
  0046f	48 89 05 00 00
	00 00		 mov	 QWORD PTR place, rax

; 316  :                         if (PRINT_ERROR)

  00476	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR opterr, 0
  0047d	74 4e		 je	 SHORT $LN39@getopt_int
  0047f	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  00484	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00487	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  0048a	75 31		 jne	 SHORT $LN40@getopt_int
  0048c	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  00491	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00494	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00497	74 0d		 je	 SHORT $LN41@getopt_int
  00499	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  0049e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  004a1	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  004a4	75 27		 jne	 SHORT $LN39@getopt_int
$LN41@getopt_int:
  004a6	b8 01 00 00 00	 mov	 eax, 1
  004ab	48 6b c0 01	 imul	 rax, rax, 1
  004af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR options$[rsp]
  004b4	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  004b8	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  004bb	74 10		 je	 SHORT $LN39@getopt_int
$LN40@getopt_int:

; 317  :                                 warnx(recargchar, optchar);

  004bd	8b 54 24 20	 mov	 edx, DWORD PTR optchar$[rsp]
  004c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recargchar
  004c8	e8 00 00 00 00	 call	 warnx
$LN39@getopt_int:

; 318  :                         optopt = optchar;

  004cd	8b 44 24 20	 mov	 eax, DWORD PTR optchar$[rsp]
  004d1	89 05 00 00 00
	00		 mov	 DWORD PTR optopt, eax

; 319  :                         return BADARG;

  004d7	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  004dc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  004df	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  004e2	74 0d		 je	 SHORT $LN56@getopt_int
  004e4	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  004e9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  004ec	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  004ef	75 17		 jne	 SHORT $LN57@getopt_int
$LN56@getopt_int:
  004f1	b8 01 00 00 00	 mov	 eax, 1
  004f6	48 6b c0 01	 imul	 rax, rax, 1
  004fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR options$[rsp]
  004ff	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00503	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00506	74 17		 je	 SHORT $LN58@getopt_int
$LN57@getopt_int:
  00508	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  0050d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00510	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00513	74 0a		 je	 SHORT $LN58@getopt_int
  00515	c7 44 24 28 3f
	00 00 00	 mov	 DWORD PTR tv227[rsp], 63 ; 0000003fH
  0051d	eb 08		 jmp	 SHORT $LN59@getopt_int
$LN58@getopt_int:
  0051f	c7 44 24 28 3a
	00 00 00	 mov	 DWORD PTR tv227[rsp], 58 ; 0000003aH
$LN59@getopt_int:
  00527	8b 44 24 28	 mov	 eax, DWORD PTR tv227[rsp]
  0052b	e9 c1 01 00 00	 jmp	 $LN1@getopt_int

; 320  :                 } else                          /* white space */

  00530	eb 17		 jmp	 SHORT $LN38@getopt_int
$LN37@getopt_int:

; 321  :                         place = nargv[optind];

  00532	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR optind
  00539	48 8b 4c 24 58	 mov	 rcx, QWORD PTR nargv$[rsp]
  0053e	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00542	48 89 05 00 00
	00 00		 mov	 QWORD PTR place, rax
$LN38@getopt_int:

; 322  :                 /*
; 323  :                  * Handle -W arg the same as --arg (which causes getopt to
; 324  :                  * stop parsing).
; 325  :                  */
; 326  :                 return -2;

  00549	b8 fe ff ff ff	 mov	 eax, -2
  0054e	e9 9e 01 00 00	 jmp	 $LN1@getopt_int
$LN35@getopt_int:

; 327  :         }
; 328  :         if (*++oli != ':') {                    /* doesn't take argument */

  00553	48 8b 44 24 38	 mov	 rax, QWORD PTR oli$[rsp]
  00558	48 ff c0	 inc	 rax
  0055b	48 89 44 24 38	 mov	 QWORD PTR oli$[rsp], rax
  00560	48 8b 44 24 38	 mov	 rax, QWORD PTR oli$[rsp]
  00565	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00568	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  0056b	74 21		 je	 SHORT $LN42@getopt_int

; 329  :                 if (!*place)

  0056d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR place
  00574	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00577	85 c0		 test	 eax, eax
  00579	75 0e		 jne	 SHORT $LN44@getopt_int

; 330  :                         ++optind;

  0057b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR optind
  00581	ff c0		 inc	 eax
  00583	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax
$LN44@getopt_int:

; 331  :         } else {                                /* takes (optional) argument */

  00589	e9 5f 01 00 00	 jmp	 $LN43@getopt_int
$LN42@getopt_int:

; 332  :                 optarg = NULL;

  0058e	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR optarg, 0

; 333  :                 if (*place)                     /* no white space */

  00599	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR place
  005a0	0f be 00	 movsx	 eax, BYTE PTR [rax]
  005a3	85 c0		 test	 eax, eax
  005a5	74 13		 je	 SHORT $LN45@getopt_int

; 334  :                         optarg = place;

  005a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR place
  005ae	48 89 05 00 00
	00 00		 mov	 QWORD PTR optarg, rax
  005b5	e9 17 01 00 00	 jmp	 $LN46@getopt_int
$LN45@getopt_int:

; 335  :                 /* XXX: disable test for :: if PC? (GNU doesn't) */
; 336  :                 else if (oli[1] != ':') {       /* arg not optional */

  005ba	b8 01 00 00 00	 mov	 eax, 1
  005bf	48 6b c0 01	 imul	 rax, rax, 1
  005c3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR oli$[rsp]
  005c8	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  005cc	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  005cf	0f 84 fc 00 00
	00		 je	 $LN47@getopt_int

; 337  :                         if (++optind >= nargc) {        /* no arg */

  005d5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR optind
  005db	ff c0		 inc	 eax
  005dd	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax
  005e3	8b 44 24 50	 mov	 eax, DWORD PTR nargc$[rsp]
  005e7	39 05 00 00 00
	00		 cmp	 DWORD PTR optind, eax
  005ed	0f 8c c7 00 00
	00		 jl	 $LN48@getopt_int

; 338  :                                 place = EMSG;

  005f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:EMSG
  005fa	48 89 05 00 00
	00 00		 mov	 QWORD PTR place, rax

; 339  :                                 if (PRINT_ERROR)

  00601	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR opterr, 0
  00608	74 4e		 je	 SHORT $LN50@getopt_int
  0060a	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  0060f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00612	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00615	75 31		 jne	 SHORT $LN51@getopt_int
  00617	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  0061c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0061f	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00622	74 0d		 je	 SHORT $LN52@getopt_int
  00624	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  00629	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0062c	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0062f	75 27		 jne	 SHORT $LN50@getopt_int
$LN52@getopt_int:
  00631	b8 01 00 00 00	 mov	 eax, 1
  00636	48 6b c0 01	 imul	 rax, rax, 1
  0063a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR options$[rsp]
  0063f	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00643	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00646	74 10		 je	 SHORT $LN50@getopt_int
$LN51@getopt_int:

; 340  :                                         warnx(recargchar, optchar);

  00648	8b 54 24 20	 mov	 edx, DWORD PTR optchar$[rsp]
  0064c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recargchar
  00653	e8 00 00 00 00	 call	 warnx
$LN50@getopt_int:

; 341  :                                 optopt = optchar;

  00658	8b 44 24 20	 mov	 eax, DWORD PTR optchar$[rsp]
  0065c	89 05 00 00 00
	00		 mov	 DWORD PTR optopt, eax

; 342  :                                 return BADARG;

  00662	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  00667	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0066a	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0066d	74 0d		 je	 SHORT $LN60@getopt_int
  0066f	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  00674	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00677	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0067a	75 17		 jne	 SHORT $LN61@getopt_int
$LN60@getopt_int:
  0067c	b8 01 00 00 00	 mov	 eax, 1
  00681	48 6b c0 01	 imul	 rax, rax, 1
  00685	48 8b 4c 24 60	 mov	 rcx, QWORD PTR options$[rsp]
  0068a	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0068e	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00691	74 17		 je	 SHORT $LN62@getopt_int
$LN61@getopt_int:
  00693	48 8b 44 24 60	 mov	 rax, QWORD PTR options$[rsp]
  00698	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0069b	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  0069e	74 0a		 je	 SHORT $LN62@getopt_int
  006a0	c7 44 24 2c 3f
	00 00 00	 mov	 DWORD PTR tv268[rsp], 63 ; 0000003fH
  006a8	eb 08		 jmp	 SHORT $LN63@getopt_int
$LN62@getopt_int:
  006aa	c7 44 24 2c 3a
	00 00 00	 mov	 DWORD PTR tv268[rsp], 58 ; 0000003aH
$LN63@getopt_int:
  006b2	8b 44 24 2c	 mov	 eax, DWORD PTR tv268[rsp]
  006b6	eb 39		 jmp	 SHORT $LN1@getopt_int

; 343  :                         } else

  006b8	eb 17		 jmp	 SHORT $LN49@getopt_int
$LN48@getopt_int:

; 344  :                                 optarg = nargv[optind];

  006ba	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR optind
  006c1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR nargv$[rsp]
  006c6	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  006ca	48 89 05 00 00
	00 00		 mov	 QWORD PTR optarg, rax
$LN49@getopt_int:
$LN47@getopt_int:
$LN46@getopt_int:

; 345  :                 }
; 346  :                 place = EMSG;

  006d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:EMSG
  006d8	48 89 05 00 00
	00 00		 mov	 QWORD PTR place, rax

; 347  :                 ++optind;

  006df	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR optind
  006e5	ff c0		 inc	 eax
  006e7	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax
$LN43@getopt_int:

; 348  :         }
; 349  :         /* dump back option letter */
; 350  :         return optchar;

  006ed	8b 44 24 20	 mov	 eax, DWORD PTR optchar$[rsp]
$LN1@getopt_int:

; 351  : }

  006f1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  006f5	c3		 ret	 0
getopt_internal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\getopt.c
_TEXT	SEGMENT
match$1 = 32
i$2 = 36
retval$ = 40
tv200 = 44
tv260 = 48
current_argv$3 = 56
has_equal$4 = 64
current_argv_len$5 = 72
nargc$ = 96
nargv$ = 104
options$ = 112
long_options$ = 120
idx$ = 128
getopt_long PROC

; 400  : {

$LN60:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@getopt_lon:

; 401  :         int retval;
; 402  : 
; 403  :         _DIAGASSERT(nargv != NULL);

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@getopt_lon
$LN7@getopt_lon:

; 404  :         _DIAGASSERT(options != NULL);

  0001d	33 c0		 xor	 eax, eax
  0001f	85 c0		 test	 eax, eax
  00021	75 fa		 jne	 SHORT $LN7@getopt_lon
$LN10@getopt_lon:

; 405  :         _DIAGASSERT(long_options != NULL);

  00023	33 c0		 xor	 eax, eax
  00025	85 c0		 test	 eax, eax
  00027	75 fa		 jne	 SHORT $LN10@getopt_lon

; 406  :         /* idx may be NULL */
; 407  : 
; 408  :         if ((retval = getopt_internal(nargc, nargv, options)) == -2) {

  00029	4c 8b 44 24 70	 mov	 r8, QWORD PTR options$[rsp]
  0002e	48 8b 54 24 68	 mov	 rdx, QWORD PTR nargv$[rsp]
  00033	8b 4c 24 60	 mov	 ecx, DWORD PTR nargc$[rsp]
  00037	e8 00 00 00 00	 call	 getopt_internal
  0003c	89 44 24 28	 mov	 DWORD PTR retval$[rsp], eax
  00040	83 7c 24 28 fe	 cmp	 DWORD PTR retval$[rsp], -2
  00045	0f 85 93 05 00
	00		 jne	 $LN14@getopt_lon

; 409  :                 char *current_argv, *has_equal;
; 410  :                 size_t current_argv_len;
; 411  :                 int i, match;
; 412  : 
; 413  :                 current_argv = place;

  0004b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR place
  00052	48 89 44 24 38	 mov	 QWORD PTR current_argv$3[rsp], rax

; 414  :                 match = -1;

  00057	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR match$1[rsp], -1

; 415  : 
; 416  :                 optind++;

  0005f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR optind
  00065	ff c0		 inc	 eax
  00067	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax

; 417  :                 place = EMSG;

  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:EMSG
  00074	48 89 05 00 00
	00 00		 mov	 QWORD PTR place, rax

; 418  : 
; 419  :                 if (*current_argv == '\0') {            /* found "--" */

  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR current_argv$3[rsp]
  00080	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00083	85 c0		 test	 eax, eax
  00085	75 66		 jne	 SHORT $LN15@getopt_lon

; 420  :                         /*
; 421  :                          * We found an option (--), so if we skipped
; 422  :                          * non-options, we have to permute.
; 423  :                          */
; 424  :                         if (nonopt_end != -1) {

  00087	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR nonopt_end, -1
  0008e	74 3d		 je	 SHORT $LN16@getopt_lon

; 425  :                                 permute_args(nonopt_start, nonopt_end,

  00090	4c 8b 4c 24 68	 mov	 r9, QWORD PTR nargv$[rsp]
  00095	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR optind
  0009c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR nonopt_end
  000a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR nonopt_start
  000a8	e8 00 00 00 00	 call	 permute_args

; 426  :                                     optind, nargv);
; 427  :                                 optind -= nonopt_end - nonopt_start;

  000ad	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nonopt_start
  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR nonopt_end
  000b9	2b c8		 sub	 ecx, eax
  000bb	8b c1		 mov	 eax, ecx
  000bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR optind
  000c3	2b c8		 sub	 ecx, eax
  000c5	8b c1		 mov	 eax, ecx
  000c7	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax
$LN16@getopt_lon:

; 428  :                         }
; 429  :                         nonopt_start = nonopt_end = -1;

  000cd	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR nonopt_end, -1
  000d7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nonopt_end
  000dd	89 05 00 00 00
	00		 mov	 DWORD PTR nonopt_start, eax

; 430  :                         return -1;

  000e3	b8 ff ff ff ff	 mov	 eax, -1
  000e8	e9 f5 04 00 00	 jmp	 $LN1@getopt_lon
$LN15@getopt_lon:

; 431  :                 }
; 432  :                 if ((has_equal = strchr(current_argv, '=')) != NULL) {

  000ed	ba 3d 00 00 00	 mov	 edx, 61			; 0000003dH
  000f2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current_argv$3[rsp]
  000f7	e8 00 00 00 00	 call	 strchr
  000fc	48 89 44 24 40	 mov	 QWORD PTR has_equal$4[rsp], rax
  00101	48 83 7c 24 40
	00		 cmp	 QWORD PTR has_equal$4[rsp], 0
  00107	74 24		 je	 SHORT $LN17@getopt_lon

; 433  :                         /* argument found (--option=arg) */
; 434  :                         current_argv_len = has_equal - current_argv;

  00109	48 8b 44 24 38	 mov	 rax, QWORD PTR current_argv$3[rsp]
  0010e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR has_equal$4[rsp]
  00113	48 2b c8	 sub	 rcx, rax
  00116	48 8b c1	 mov	 rax, rcx
  00119	48 89 44 24 48	 mov	 QWORD PTR current_argv_len$5[rsp], rax

; 435  :                         has_equal++;

  0011e	48 8b 44 24 40	 mov	 rax, QWORD PTR has_equal$4[rsp]
  00123	48 ff c0	 inc	 rax
  00126	48 89 44 24 40	 mov	 QWORD PTR has_equal$4[rsp], rax

; 436  :                 } else

  0012b	eb 0f		 jmp	 SHORT $LN18@getopt_lon
$LN17@getopt_lon:

; 437  :                         current_argv_len = strlen(current_argv);

  0012d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current_argv$3[rsp]
  00132	e8 00 00 00 00	 call	 strlen
  00137	48 89 44 24 48	 mov	 QWORD PTR current_argv_len$5[rsp], rax
$LN18@getopt_lon:

; 438  : 
; 439  :                 for (i = 0; long_options[i].name; i++) {

  0013c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00144	eb 0a		 jmp	 SHORT $LN13@getopt_lon
$LN11@getopt_lon:
  00146	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  0014a	ff c0		 inc	 eax
  0014c	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN13@getopt_lon:
  00150	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$2[rsp]
  00155	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00159	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  0015e	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00163	0f 84 db 00 00
	00		 je	 $LN12@getopt_lon

; 440  :                         /* find matching long option */
; 441  :                         if (strncmp(current_argv, long_options[i].name,

  00169	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$2[rsp]
  0016e	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00172	4c 8b 44 24 48	 mov	 r8, QWORD PTR current_argv_len$5[rsp]
  00177	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  0017c	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00180	48 8b 4c 24 38	 mov	 rcx, QWORD PTR current_argv$3[rsp]
  00185	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0018b	85 c0		 test	 eax, eax
  0018d	74 02		 je	 SHORT $LN19@getopt_lon

; 442  :                             current_argv_len))
; 443  :                                 continue;

  0018f	eb b5		 jmp	 SHORT $LN11@getopt_lon
$LN19@getopt_lon:

; 444  : 
; 445  :                         if (strlen(long_options[i].name) ==

  00191	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$2[rsp]
  00196	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0019a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  0019f	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  001a3	e8 00 00 00 00	 call	 strlen
  001a8	8b 4c 24 48	 mov	 ecx, DWORD PTR current_argv_len$5[rsp]
  001ac	48 3b c1	 cmp	 rax, rcx
  001af	75 0d		 jne	 SHORT $LN20@getopt_lon

; 446  :                             (unsigned)current_argv_len) {
; 447  :                                 /* exact match */
; 448  :                                 match = i;

  001b1	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  001b5	89 44 24 20	 mov	 DWORD PTR match$1[rsp], eax

; 449  :                                 break;

  001b9	e9 86 00 00 00	 jmp	 $LN12@getopt_lon
$LN20@getopt_lon:

; 450  :                         }
; 451  :                         if (match == -1)                /* partial match */

  001be	83 7c 24 20 ff	 cmp	 DWORD PTR match$1[rsp], -1
  001c3	75 0a		 jne	 SHORT $LN21@getopt_lon

; 452  :                                 match = i;

  001c5	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  001c9	89 44 24 20	 mov	 DWORD PTR match$1[rsp], eax
  001cd	eb 70		 jmp	 SHORT $LN22@getopt_lon
$LN21@getopt_lon:

; 453  :                         else {
; 454  :                                 /* ambiguous abbreviation */
; 455  :                                 if (PRINT_ERROR)

  001cf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR opterr, 0
  001d6	74 53		 je	 SHORT $LN23@getopt_lon
  001d8	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  001dd	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001e0	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  001e3	75 31		 jne	 SHORT $LN24@getopt_lon
  001e5	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  001ea	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001ed	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  001f0	74 0d		 je	 SHORT $LN25@getopt_lon
  001f2	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  001f7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001fa	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  001fd	75 2c		 jne	 SHORT $LN23@getopt_lon
$LN25@getopt_lon:
  001ff	b8 01 00 00 00	 mov	 eax, 1
  00204	48 6b c0 01	 imul	 rax, rax, 1
  00208	48 8b 4c 24 70	 mov	 rcx, QWORD PTR options$[rsp]
  0020d	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00211	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00214	74 15		 je	 SHORT $LN23@getopt_lon
$LN24@getopt_lon:

; 456  :                                         warnx(ambig, (int)current_argv_len,

  00216	4c 8b 44 24 38	 mov	 r8, QWORD PTR current_argv$3[rsp]
  0021b	8b 54 24 48	 mov	 edx, DWORD PTR current_argv_len$5[rsp]
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ambig
  00226	e8 00 00 00 00	 call	 warnx
$LN23@getopt_lon:

; 457  :                                              current_argv);
; 458  :                                 optopt = 0;

  0022b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR optopt, 0

; 459  :                                 return BADCH;

  00235	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  0023a	e9 a3 03 00 00	 jmp	 $LN1@getopt_lon
$LN22@getopt_lon:

; 460  :                         }
; 461  :                 }

  0023f	e9 02 ff ff ff	 jmp	 $LN11@getopt_lon
$LN12@getopt_lon:

; 462  :                 if (match != -1) {                      /* option found */

  00244	83 7c 24 20 ff	 cmp	 DWORD PTR match$1[rsp], -1
  00249	0f 84 b0 02 00
	00		 je	 $LN26@getopt_lon

; 463  :                         if (long_options[match].has_arg == no_argument
; 464  :                             && has_equal) {

  0024f	48 63 44 24 20	 movsxd	 rax, DWORD PTR match$1[rsp]
  00254	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00258	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  0025d	83 7c 01 08 00	 cmp	 DWORD PTR [rcx+rax+8], 0
  00262	0f 85 fb 00 00
	00		 jne	 $LN28@getopt_lon
  00268	48 83 7c 24 40
	00		 cmp	 QWORD PTR has_equal$4[rsp], 0
  0026e	0f 84 ef 00 00
	00		 je	 $LN28@getopt_lon

; 465  :                                 if (PRINT_ERROR)

  00274	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR opterr, 0
  0027b	74 53		 je	 SHORT $LN29@getopt_lon
  0027d	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  00282	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00285	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00288	75 31		 jne	 SHORT $LN30@getopt_lon
  0028a	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  0028f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00292	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00295	74 0d		 je	 SHORT $LN31@getopt_lon
  00297	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  0029c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0029f	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  002a2	75 2c		 jne	 SHORT $LN29@getopt_lon
$LN31@getopt_lon:
  002a4	b8 01 00 00 00	 mov	 eax, 1
  002a9	48 6b c0 01	 imul	 rax, rax, 1
  002ad	48 8b 4c 24 70	 mov	 rcx, QWORD PTR options$[rsp]
  002b2	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  002b6	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  002b9	74 15		 je	 SHORT $LN29@getopt_lon
$LN30@getopt_lon:

; 466  :                                         warnx(noarg, (int)current_argv_len,

  002bb	4c 8b 44 24 38	 mov	 r8, QWORD PTR current_argv$3[rsp]
  002c0	8b 54 24 48	 mov	 edx, DWORD PTR current_argv_len$5[rsp]
  002c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:noarg
  002cb	e8 00 00 00 00	 call	 warnx
$LN29@getopt_lon:

; 467  :                                              current_argv);
; 468  :                                 /*
; 469  :                                  * XXX: GNU sets optopt to val regardless of
; 470  :                                  * flag
; 471  :                                  */
; 472  :                                 if (long_options[match].flag == NULL)

  002d0	48 63 44 24 20	 movsxd	 rax, DWORD PTR match$1[rsp]
  002d5	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  002d9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  002de	48 83 7c 01 10
	00		 cmp	 QWORD PTR [rcx+rax+16], 0
  002e4	75 1a		 jne	 SHORT $LN32@getopt_lon

; 473  :                                         optopt = long_options[match].val;

  002e6	48 63 44 24 20	 movsxd	 rax, DWORD PTR match$1[rsp]
  002eb	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  002ef	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  002f4	8b 44 01 18	 mov	 eax, DWORD PTR [rcx+rax+24]
  002f8	89 05 00 00 00
	00		 mov	 DWORD PTR optopt, eax
  002fe	eb 0a		 jmp	 SHORT $LN33@getopt_lon
$LN32@getopt_lon:

; 474  :                                 else
; 475  :                                         optopt = 0;

  00300	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR optopt, 0
$LN33@getopt_lon:

; 476  :                                 return BADARG;

  0030a	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  0030f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00312	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00315	74 0d		 je	 SHORT $LN52@getopt_lon
  00317	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  0031c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0031f	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00322	75 17		 jne	 SHORT $LN53@getopt_lon
$LN52@getopt_lon:
  00324	b8 01 00 00 00	 mov	 eax, 1
  00329	48 6b c0 01	 imul	 rax, rax, 1
  0032d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR options$[rsp]
  00332	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00336	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00339	74 17		 je	 SHORT $LN54@getopt_lon
$LN53@getopt_lon:
  0033b	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  00340	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00343	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00346	74 0a		 je	 SHORT $LN54@getopt_lon
  00348	c7 44 24 2c 3f
	00 00 00	 mov	 DWORD PTR tv200[rsp], 63 ; 0000003fH
  00350	eb 08		 jmp	 SHORT $LN55@getopt_lon
$LN54@getopt_lon:
  00352	c7 44 24 2c 3a
	00 00 00	 mov	 DWORD PTR tv200[rsp], 58 ; 0000003aH
$LN55@getopt_lon:
  0035a	8b 44 24 2c	 mov	 eax, DWORD PTR tv200[rsp]
  0035e	e9 7f 02 00 00	 jmp	 $LN1@getopt_lon
$LN28@getopt_lon:

; 477  :                         }
; 478  :                         if (long_options[match].has_arg == required_argument ||

  00363	48 63 44 24 20	 movsxd	 rax, DWORD PTR match$1[rsp]
  00368	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0036c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  00371	83 7c 01 08 01	 cmp	 DWORD PTR [rcx+rax+8], 1
  00376	74 15		 je	 SHORT $LN35@getopt_lon
  00378	48 63 44 24 20	 movsxd	 rax, DWORD PTR match$1[rsp]
  0037d	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00381	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  00386	83 7c 01 08 02	 cmp	 DWORD PTR [rcx+rax+8], 2
  0038b	75 50		 jne	 SHORT $LN34@getopt_lon
$LN35@getopt_lon:

; 479  :                             long_options[match].has_arg == optional_argument) {
; 480  :                                 if (has_equal)

  0038d	48 83 7c 24 40
	00		 cmp	 QWORD PTR has_equal$4[rsp], 0
  00393	74 0e		 je	 SHORT $LN36@getopt_lon

; 481  :                                         optarg = has_equal;

  00395	48 8b 44 24 40	 mov	 rax, QWORD PTR has_equal$4[rsp]
  0039a	48 89 05 00 00
	00 00		 mov	 QWORD PTR optarg, rax
  003a1	eb 3a		 jmp	 SHORT $LN37@getopt_lon
$LN36@getopt_lon:

; 482  :                                 else if (long_options[match].has_arg ==

  003a3	48 63 44 24 20	 movsxd	 rax, DWORD PTR match$1[rsp]
  003a8	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  003ac	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  003b1	83 7c 01 08 01	 cmp	 DWORD PTR [rcx+rax+8], 1
  003b6	75 25		 jne	 SHORT $LN38@getopt_lon

; 483  :                                     required_argument) {
; 484  :                                         /*
; 485  :                                          * optional argument doesn't use
; 486  :                                          * next nargv
; 487  :                                          */
; 488  :                                         optarg = nargv[optind++];

  003b8	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR optind
  003bf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR nargv$[rsp]
  003c4	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  003c8	48 89 05 00 00
	00 00		 mov	 QWORD PTR optarg, rax
  003cf	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR optind
  003d5	ff c0		 inc	 eax
  003d7	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax
$LN38@getopt_lon:
$LN37@getopt_lon:
$LN34@getopt_lon:

; 489  :                                 }
; 490  :                         }
; 491  :                         if ((long_options[match].has_arg == required_argument)
; 492  :                             && (optarg == NULL)) {

  003dd	48 63 44 24 20	 movsxd	 rax, DWORD PTR match$1[rsp]
  003e2	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  003e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  003eb	83 7c 01 08 01	 cmp	 DWORD PTR [rcx+rax+8], 1
  003f0	0f 85 07 01 00
	00		 jne	 $LN39@getopt_lon
  003f6	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR optarg, 0
  003fe	0f 85 f9 00 00
	00		 jne	 $LN39@getopt_lon

; 493  :                                 /*
; 494  :                                  * Missing argument; leading ':'
; 495  :                                  * indicates no error should be generated
; 496  :                                  */
; 497  :                                 if (PRINT_ERROR)

  00404	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR opterr, 0
  0040b	74 4f		 je	 SHORT $LN40@getopt_lon
  0040d	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  00412	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00415	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00418	75 31		 jne	 SHORT $LN41@getopt_lon
  0041a	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  0041f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00422	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00425	74 0d		 je	 SHORT $LN42@getopt_lon
  00427	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  0042c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0042f	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00432	75 28		 jne	 SHORT $LN40@getopt_lon
$LN42@getopt_lon:
  00434	b8 01 00 00 00	 mov	 eax, 1
  00439	48 6b c0 01	 imul	 rax, rax, 1
  0043d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR options$[rsp]
  00442	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00446	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00449	74 11		 je	 SHORT $LN40@getopt_lon
$LN41@getopt_lon:

; 498  :                                         warnx(recargstring, current_argv);

  0044b	48 8b 54 24 38	 mov	 rdx, QWORD PTR current_argv$3[rsp]
  00450	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:recargstring
  00457	e8 00 00 00 00	 call	 warnx
$LN40@getopt_lon:

; 499  :                                 /*
; 500  :                                  * XXX: GNU sets optopt to val regardless
; 501  :                                  * of flag
; 502  :                                  */
; 503  :                                 if (long_options[match].flag == NULL)

  0045c	48 63 44 24 20	 movsxd	 rax, DWORD PTR match$1[rsp]
  00461	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00465	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  0046a	48 83 7c 01 10
	00		 cmp	 QWORD PTR [rcx+rax+16], 0
  00470	75 1a		 jne	 SHORT $LN43@getopt_lon

; 504  :                                         optopt = long_options[match].val;

  00472	48 63 44 24 20	 movsxd	 rax, DWORD PTR match$1[rsp]
  00477	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0047b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  00480	8b 44 01 18	 mov	 eax, DWORD PTR [rcx+rax+24]
  00484	89 05 00 00 00
	00		 mov	 DWORD PTR optopt, eax
  0048a	eb 0a		 jmp	 SHORT $LN44@getopt_lon
$LN43@getopt_lon:

; 505  :                                 else
; 506  :                                         optopt = 0;

  0048c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR optopt, 0
$LN44@getopt_lon:

; 507  :                                 --optind;

  00496	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR optind
  0049c	ff c8		 dec	 eax
  0049e	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax

; 508  :                                 return BADARG;

  004a4	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  004a9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  004ac	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  004af	74 0d		 je	 SHORT $LN56@getopt_lon
  004b1	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  004b6	0f be 00	 movsx	 eax, BYTE PTR [rax]
  004b9	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  004bc	75 17		 jne	 SHORT $LN57@getopt_lon
$LN56@getopt_lon:
  004be	b8 01 00 00 00	 mov	 eax, 1
  004c3	48 6b c0 01	 imul	 rax, rax, 1
  004c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR options$[rsp]
  004cc	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  004d0	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  004d3	74 17		 je	 SHORT $LN58@getopt_lon
$LN57@getopt_lon:
  004d5	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  004da	0f be 00	 movsx	 eax, BYTE PTR [rax]
  004dd	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  004e0	74 0a		 je	 SHORT $LN58@getopt_lon
  004e2	c7 44 24 30 3f
	00 00 00	 mov	 DWORD PTR tv260[rsp], 63 ; 0000003fH
  004ea	eb 08		 jmp	 SHORT $LN59@getopt_lon
$LN58@getopt_lon:
  004ec	c7 44 24 30 3a
	00 00 00	 mov	 DWORD PTR tv260[rsp], 58 ; 0000003aH
$LN59@getopt_lon:
  004f4	8b 44 24 30	 mov	 eax, DWORD PTR tv260[rsp]
  004f8	e9 e5 00 00 00	 jmp	 $LN1@getopt_lon
$LN39@getopt_lon:

; 509  :                         }
; 510  :                 } else {                        /* unknown option */

  004fd	eb 69		 jmp	 SHORT $LN27@getopt_lon
$LN26@getopt_lon:

; 511  :                         if (PRINT_ERROR)

  004ff	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR opterr, 0
  00506	74 4f		 je	 SHORT $LN45@getopt_lon
  00508	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  0050d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00510	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00513	75 31		 jne	 SHORT $LN46@getopt_lon
  00515	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  0051a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0051d	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00520	74 0d		 je	 SHORT $LN47@getopt_lon
  00522	48 8b 44 24 70	 mov	 rax, QWORD PTR options$[rsp]
  00527	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0052a	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0052d	75 28		 jne	 SHORT $LN45@getopt_lon
$LN47@getopt_lon:
  0052f	b8 01 00 00 00	 mov	 eax, 1
  00534	48 6b c0 01	 imul	 rax, rax, 1
  00538	48 8b 4c 24 70	 mov	 rcx, QWORD PTR options$[rsp]
  0053d	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00541	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00544	74 11		 je	 SHORT $LN45@getopt_lon
$LN46@getopt_lon:

; 512  :                                 warnx(illoptstring, current_argv);

  00546	48 8b 54 24 38	 mov	 rdx, QWORD PTR current_argv$3[rsp]
  0054b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:illoptstring
  00552	e8 00 00 00 00	 call	 warnx
$LN45@getopt_lon:

; 513  :                         optopt = 0;

  00557	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR optopt, 0

; 514  :                         return BADCH;

  00561	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00566	eb 7a		 jmp	 SHORT $LN1@getopt_lon
$LN27@getopt_lon:

; 515  :                 }
; 516  :                 if (long_options[match].flag) {

  00568	48 63 44 24 20	 movsxd	 rax, DWORD PTR match$1[rsp]
  0056d	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00571	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  00576	48 83 7c 01 10
	00		 cmp	 QWORD PTR [rcx+rax+16], 0
  0057c	74 31		 je	 SHORT $LN48@getopt_lon

; 517  :                         *long_options[match].flag = long_options[match].val;

  0057e	48 63 44 24 20	 movsxd	 rax, DWORD PTR match$1[rsp]
  00583	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00587	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR match$1[rsp]
  0058c	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00590	48 8b 54 24 78	 mov	 rdx, QWORD PTR long_options$[rsp]
  00595	48 8b 4c 0a 10	 mov	 rcx, QWORD PTR [rdx+rcx+16]
  0059a	48 8b 54 24 78	 mov	 rdx, QWORD PTR long_options$[rsp]
  0059f	8b 44 02 18	 mov	 eax, DWORD PTR [rdx+rax+24]
  005a3	89 01		 mov	 DWORD PTR [rcx], eax

; 518  :                         retval = 0;

  005a5	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR retval$[rsp], 0

; 519  :                 } else

  005ad	eb 16		 jmp	 SHORT $LN49@getopt_lon
$LN48@getopt_lon:

; 520  :                         retval = long_options[match].val;

  005af	48 63 44 24 20	 movsxd	 rax, DWORD PTR match$1[rsp]
  005b4	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  005b8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR long_options$[rsp]
  005bd	8b 44 01 18	 mov	 eax, DWORD PTR [rcx+rax+24]
  005c1	89 44 24 28	 mov	 DWORD PTR retval$[rsp], eax
$LN49@getopt_lon:

; 521  :                 if (idx)

  005c5	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR idx$[rsp], 0
  005ce	74 0e		 je	 SHORT $LN50@getopt_lon

; 522  :                         *idx = match;

  005d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR idx$[rsp]
  005d8	8b 4c 24 20	 mov	 ecx, DWORD PTR match$1[rsp]
  005dc	89 08		 mov	 DWORD PTR [rax], ecx
$LN50@getopt_lon:
$LN14@getopt_lon:

; 523  :         }
; 524  :         return retval;

  005de	8b 44 24 28	 mov	 eax, DWORD PTR retval$[rsp]
$LN1@getopt_lon:

; 525  : }

  005e2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  005e6	c3		 ret	 0
getopt_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\getopt.c
_TEXT	SEGMENT
retval$ = 32
nargc$ = 64
nargv$ = 72
options$ = 80
getopt	PROC

; 365  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@getopt:

; 366  :         int retval;
; 367  : 
; 368  :         _DIAGASSERT(nargv != NULL);

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@getopt
$LN7@getopt:

; 369  :         _DIAGASSERT(options != NULL);

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN7@getopt

; 370  : 
; 371  :         if ((retval = getopt_internal(nargc, nargv, options)) == -2) {

  0001e	4c 8b 44 24 50	 mov	 r8, QWORD PTR options$[rsp]
  00023	48 8b 54 24 48	 mov	 rdx, QWORD PTR nargv$[rsp]
  00028	8b 4c 24 40	 mov	 ecx, DWORD PTR nargc$[rsp]
  0002c	e8 00 00 00 00	 call	 getopt_internal
  00031	89 44 24 20	 mov	 DWORD PTR retval$[rsp], eax
  00035	83 7c 24 20 fe	 cmp	 DWORD PTR retval$[rsp], -2
  0003a	75 72		 jne	 SHORT $LN8@getopt

; 372  :                 ++optind;

  0003c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR optind
  00042	ff c0		 inc	 eax
  00044	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax

; 373  :                 /*
; 374  :                  * We found an option (--), so if we skipped non-options,
; 375  :                  * we have to permute.
; 376  :                  */
; 377  :                 if (nonopt_end != -1) {

  0004a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR nonopt_end, -1
  00051	74 3d		 je	 SHORT $LN9@getopt

; 378  :                         permute_args(nonopt_start, nonopt_end, optind,

  00053	4c 8b 4c 24 48	 mov	 r9, QWORD PTR nargv$[rsp]
  00058	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR optind
  0005f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR nonopt_end
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR nonopt_start
  0006b	e8 00 00 00 00	 call	 permute_args

; 379  :                                        nargv);
; 380  :                         optind -= nonopt_end - nonopt_start;

  00070	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nonopt_start
  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR nonopt_end
  0007c	2b c8		 sub	 ecx, eax
  0007e	8b c1		 mov	 eax, ecx
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR optind
  00086	2b c8		 sub	 ecx, eax
  00088	8b c1		 mov	 eax, ecx
  0008a	89 05 00 00 00
	00		 mov	 DWORD PTR optind, eax
$LN9@getopt:

; 381  :                 }
; 382  :                 nonopt_start = nonopt_end = -1;

  00090	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR nonopt_end, -1
  0009a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR nonopt_end
  000a0	89 05 00 00 00
	00		 mov	 DWORD PTR nonopt_start, eax

; 383  :                 retval = -1;

  000a6	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR retval$[rsp], -1
$LN8@getopt:

; 384  :         }
; 385  :         return retval;

  000ae	8b 44 24 20	 mov	 eax, DWORD PTR retval$[rsp]

; 386  : }

  000b2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b6	c3		 ret	 0
getopt	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT vfprintf
_TEXT	SEGMENT
_Stream$ = 48
_Format$ = 56
_ArgList$ = 64
vfprintf PROC						; COMDAT

; 658  :     {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 659  :         return _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00013	4c 8b 4c 24 40	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00018	45 33 c0	 xor	 r8d, r8d
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Format$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00025	e8 00 00 00 00	 call	 _vfprintf_l

; 660  :     }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
vfprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
