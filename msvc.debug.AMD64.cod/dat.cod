; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	s370_invalidate_aia
PUBLIC	s390_invalidate_aia
PUBLIC	z900_invalidate_aia
PUBLIC	s370_set_ic_mask
PUBLIC	s390_set_ic_mask
PUBLIC	z900_set_ic_mask
PUBLIC	s370_set_aea_mode
PUBLIC	s390_set_aea_mode
PUBLIC	z900_set_aea_mode
PUBLIC	s370_invalidate_guest_aia
PUBLIC	s390_invalidate_guest_aia
PUBLIC	z900_invalidate_guest_aia
PUBLIC	s370_set_guest_ic_mask
PUBLIC	s390_set_guest_ic_mask
PUBLIC	z900_set_guest_ic_mask
PUBLIC	s370_set_guest_aea_mode
PUBLIC	s390_set_guest_aea_mode
PUBLIC	z900_set_guest_aea_mode
PUBLIC	s370_set_aea_common
PUBLIC	s390_set_aea_common
PUBLIC	z900_set_aea_common
PUBLIC	s370_set_guest_aea_common
PUBLIC	s390_set_guest_aea_common
PUBLIC	z900_set_guest_aea_common
PUBLIC	s370_do_purge_tlb
PUBLIC	s390_do_purge_tlb
PUBLIC	z900_do_purge_tlb
PUBLIC	s370_purge_tlb
PUBLIC	s390_purge_tlb
PUBLIC	z900_purge_tlb
PUBLIC	s390_do_purge_alb
PUBLIC	z900_do_purge_alb
PUBLIC	s390_purge_alb
PUBLIC	z900_purge_alb
PUBLIC	s370_do_invalidate_tlb
PUBLIC	s390_do_invalidate_tlb
PUBLIC	z900_do_invalidate_tlb
PUBLIC	s370_is_tlbe_match
PUBLIC	s390_is_tlbe_match
PUBLIC	z900_is_tlbe_match
PUBLIC	s370_do_purge_tlbe
PUBLIC	s390_do_purge_tlbe
PUBLIC	z900_do_purge_tlbe
PUBLIC	s370_purge_tlbe
PUBLIC	s390_purge_tlbe
PUBLIC	z900_purge_tlbe
PUBLIC	s370_do_invalidate_tlbe
PUBLIC	s390_do_invalidate_tlbe
PUBLIC	z900_do_invalidate_tlbe
PUBLIC	s370_invalidate_tlbe
PUBLIC	s390_invalidate_tlbe
PUBLIC	z900_invalidate_tlbe
PUBLIC	apply_host_prefixing
PUBLIC	s370_update_psw_ia
PUBLIC	s390_update_psw_ia
PUBLIC	z900_update_psw_ia
PUBLIC	s370_update_guest_psw_ia
PUBLIC	s390_update_guest_psw_ia
PUBLIC	z900_update_guest_psw_ia
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s370__get_storage_key
PUBLIC	s370__or_storage_key
PUBLIC	s370_get_ptr_to_2K_storekey
PUBLIC	s370_get_2K_storage_key
PUBLIC	s370_or_2K_storage_key
PUBLIC	s370_or_storage_key
PUBLIC	s370_get_ptr_to_storekey
PUBLIC	s370_get_storekey_by_ptr
PUBLIC	s370_or_storage_key_by_ptr
PUBLIC	s370_logical_to_main_l
PUBLIC	s390_logical_to_main_l
PUBLIC	z900_logical_to_main_l
PUBLIC	s370_is_fetch_protected
PUBLIC	s370_is_low_address_protected
PUBLIC	s370_is_store_protected
PUBLIC	s370_fetch_main_absolute
PUBLIC	s370_fetch_fullword_absolute
PUBLIC	s370_fetch_halfword_absolute
PUBLIC	s370_invalidate_tlb
PUBLIC	s370_invalidate_pte
PUBLIC	s370_translate_asn
PUBLIC	s370_translate_addr
PUBLIC	s390_translate_addr
PUBLIC	z900_translate_addr
PUBLIC	s370_purge_tlb_all
PUBLIC	s370_purge_tlbe_all
PUBLIC	s370_authorize_asn
PUBLIC	s370_maddr_l
PUBLIC	s370_vstore2_full
PUBLIC	s370_vfetch2_full
PUBLIC	s370_vstore2
PUBLIC	s370_vfetch2
PUBLIC	s370_load_address_space_designator
PUBLIC	s390__get_storage_key
PUBLIC	s390__or_storage_key
PUBLIC	s390_get_ptr_to_4K_storekey
PUBLIC	s390_get_4K_storage_key
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_or_storage_key
PUBLIC	s390_get_ptr_to_storekey
PUBLIC	s390_get_storekey_by_ptr
PUBLIC	s390_or_storage_key_by_ptr
PUBLIC	s390_is_fetch_protected
PUBLIC	s390_is_low_address_protected
PUBLIC	s390_is_store_protected
PUBLIC	s390_fetch_main_absolute
PUBLIC	s390_fetch_fullword_absolute
PUBLIC	s390_invalidate_tlb
PUBLIC	s390_invalidate_pte
PUBLIC	s390_translate_alet
PUBLIC	s390_translate_asn
PUBLIC	s390_purge_tlb_all
PUBLIC	s390_purge_tlbe_all
PUBLIC	s390_purge_alb_all
PUBLIC	s390_authorize_asn
PUBLIC	s390_maddr_l
PUBLIC	s390_vstore4_full
PUBLIC	s390_vfetch4_full
PUBLIC	s390_vstore4
PUBLIC	s390_vfetch4
PUBLIC	s390_load_address_space_designator
PUBLIC	z900__get_storage_key
PUBLIC	z900__or_storage_key
PUBLIC	z900_get_ptr_to_4K_storekey
PUBLIC	z900_get_4K_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_or_storage_key
PUBLIC	z900_get_ptr_to_storekey
PUBLIC	z900_get_storekey_by_ptr
PUBLIC	z900_or_storage_key_by_ptr
PUBLIC	z900_is_fetch_protected
PUBLIC	z900_is_low_address_protected
PUBLIC	z900_is_store_protected
PUBLIC	z900_fetch_main_absolute
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_fetch_doubleword_absolute
PUBLIC	z900_fetch_fullword_absolute
PUBLIC	z900_invalidate_tlb
PUBLIC	z900_invalidate_pte
PUBLIC	z900_translate_alet
PUBLIC	z900_translate_asn
PUBLIC	z900_purge_tlb_all
PUBLIC	z900_purge_tlbe_all
PUBLIC	z900_purge_alb_all
PUBLIC	z900_authorize_asn
PUBLIC	z900_maddr_l
PUBLIC	z900_vstore8_full
PUBLIC	z900_vfetch8_full
PUBLIC	z900_vstore8
PUBLIC	z900_vfetch8
PUBLIC	z900_load_address_space_designator
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	s370_fetch_int_timer:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$s370_set_ic_mask DD imagerel $LN33
	DD	imagerel $LN33+714
	DD	imagerel $unwind$s370_set_ic_mask
$pdata$s390_set_ic_mask DD imagerel $LN25
	DD	imagerel $LN25+568
	DD	imagerel $unwind$s390_set_ic_mask
$pdata$z900_set_ic_mask DD imagerel $LN25
	DD	imagerel $LN25+589
	DD	imagerel $unwind$z900_set_ic_mask
$pdata$s370_set_aea_mode DD imagerel $LN43
	DD	imagerel $LN43+881
	DD	imagerel $unwind$s370_set_aea_mode
$pdata$s390_set_aea_mode DD imagerel $LN56
	DD	imagerel $LN56+1123
	DD	imagerel $unwind$s390_set_aea_mode
$pdata$z900_set_aea_mode DD imagerel $LN56
	DD	imagerel $LN56+1129
	DD	imagerel $unwind$z900_set_aea_mode
$pdata$s370_invalidate_guest_aia DD imagerel $LN12
	DD	imagerel $LN12+136
	DD	imagerel $unwind$s370_invalidate_guest_aia
$pdata$s390_invalidate_guest_aia DD imagerel $LN12
	DD	imagerel $LN12+136
	DD	imagerel $unwind$s390_invalidate_guest_aia
$pdata$z900_invalidate_guest_aia DD imagerel $LN12
	DD	imagerel $LN12+136
	DD	imagerel $unwind$z900_invalidate_guest_aia
$pdata$s370_set_guest_ic_mask DD imagerel $LN12
	DD	imagerel $LN12+136
	DD	imagerel $unwind$s370_set_guest_ic_mask
$pdata$s390_set_guest_ic_mask DD imagerel $LN12
	DD	imagerel $LN12+136
	DD	imagerel $unwind$s390_set_guest_ic_mask
$pdata$z900_set_guest_ic_mask DD imagerel $LN12
	DD	imagerel $LN12+136
	DD	imagerel $unwind$z900_set_guest_ic_mask
$pdata$s370_set_guest_aea_mode DD imagerel $LN12
	DD	imagerel $LN12+136
	DD	imagerel $unwind$s370_set_guest_aea_mode
$pdata$s390_set_guest_aea_mode DD imagerel $LN12
	DD	imagerel $LN12+136
	DD	imagerel $unwind$s390_set_guest_aea_mode
$pdata$z900_set_guest_aea_mode DD imagerel $LN12
	DD	imagerel $LN12+136
	DD	imagerel $unwind$z900_set_guest_aea_mode
$pdata$s370_set_aea_common DD imagerel $LN10
	DD	imagerel $LN10+165
	DD	imagerel $unwind$s370_set_aea_common
$pdata$s390_set_aea_common DD imagerel $LN12
	DD	imagerel $LN12+243
	DD	imagerel $unwind$s390_set_aea_common
$pdata$z900_set_aea_common DD imagerel $LN12
	DD	imagerel $LN12+252
	DD	imagerel $unwind$z900_set_aea_common
$pdata$s370_set_guest_aea_common DD imagerel $LN12
	DD	imagerel $LN12+136
	DD	imagerel $unwind$s370_set_guest_aea_common
$pdata$s390_set_guest_aea_common DD imagerel $LN12
	DD	imagerel $LN12+136
	DD	imagerel $unwind$s390_set_guest_aea_common
$pdata$z900_set_guest_aea_common DD imagerel $LN12
	DD	imagerel $LN12+136
	DD	imagerel $unwind$z900_set_guest_aea_common
$pdata$s370_do_purge_tlb DD imagerel $LN8
	DD	imagerel $LN8+188
	DD	imagerel $unwind$s370_do_purge_tlb
$pdata$s390_do_purge_tlb DD imagerel $LN8
	DD	imagerel $LN8+196
	DD	imagerel $unwind$s390_do_purge_tlb
$pdata$z900_do_purge_tlb DD imagerel $LN8
	DD	imagerel $LN8+201
	DD	imagerel $unwind$z900_do_purge_tlb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_purge_tlb DD imagerel $LN13
	DD	imagerel $LN13+186
	DD	imagerel $unwind$s370_purge_tlb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_purge_tlb DD imagerel $LN13
	DD	imagerel $LN13+186
	DD	imagerel $unwind$s390_purge_tlb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_purge_tlb DD imagerel $LN13
	DD	imagerel $LN13+186
	DD	imagerel $unwind$z900_purge_tlb
pdata	ENDS
pdata	SEGMENT
$pdata$s390_do_purge_alb DD imagerel $LN7
	DD	imagerel $LN7+86
	DD	imagerel $unwind$s390_do_purge_alb
$pdata$z900_do_purge_alb DD imagerel $LN7
	DD	imagerel $LN7+86
	DD	imagerel $unwind$z900_do_purge_alb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_purge_alb DD imagerel $LN13
	DD	imagerel $LN13+165
	DD	imagerel $unwind$s390_purge_alb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_purge_alb DD imagerel $LN13
	DD	imagerel $LN13+165
	DD	imagerel $unwind$z900_purge_alb
pdata	ENDS
pdata	SEGMENT
$pdata$s370_do_invalidate_tlb DD imagerel $LN13
	DD	imagerel $LN13+248
	DD	imagerel $unwind$s370_do_invalidate_tlb
$pdata$s390_do_invalidate_tlb DD imagerel $LN13
	DD	imagerel $LN13+256
	DD	imagerel $unwind$s390_do_invalidate_tlb
$pdata$z900_do_invalidate_tlb DD imagerel $LN13
	DD	imagerel $LN13+264
	DD	imagerel $unwind$z900_do_invalidate_tlb
$pdata$s370_is_tlbe_match DD imagerel $LN18
	DD	imagerel $LN18+324
	DD	imagerel $unwind$s370_is_tlbe_match
$pdata$s390_is_tlbe_match DD imagerel $LN16
	DD	imagerel $LN16+268
	DD	imagerel $unwind$s390_is_tlbe_match
$pdata$z900_is_tlbe_match DD imagerel $LN16
	DD	imagerel $LN16+272
	DD	imagerel $unwind$z900_is_tlbe_match
$pdata$s370_do_purge_tlbe DD imagerel $LN11
	DD	imagerel $LN11+219
	DD	imagerel $unwind$s370_do_purge_tlbe
$pdata$s390_do_purge_tlbe DD imagerel $LN11
	DD	imagerel $LN11+227
	DD	imagerel $unwind$s390_do_purge_tlbe
$pdata$z900_do_purge_tlbe DD imagerel $LN11
	DD	imagerel $LN11+233
	DD	imagerel $unwind$z900_do_purge_tlbe
$pdata$s370_purge_tlbe DD imagerel $LN24
	DD	imagerel $LN24+405
	DD	imagerel $unwind$s370_purge_tlbe
$pdata$s390_purge_tlbe DD imagerel $LN24
	DD	imagerel $LN24+405
	DD	imagerel $unwind$s390_purge_tlbe
$pdata$z900_purge_tlbe DD imagerel $LN24
	DD	imagerel $LN24+405
	DD	imagerel $unwind$z900_purge_tlbe
$pdata$s370_do_invalidate_tlbe DD imagerel $LN15
	DD	imagerel $LN15+414
	DD	imagerel $unwind$s370_do_invalidate_tlbe
$pdata$s390_do_invalidate_tlbe DD imagerel $LN14
	DD	imagerel $LN14+360
	DD	imagerel $unwind$s390_do_invalidate_tlbe
$pdata$z900_do_invalidate_tlbe DD imagerel $LN14
	DD	imagerel $LN14+366
	DD	imagerel $unwind$z900_do_invalidate_tlbe
$pdata$s370_invalidate_tlbe DD imagerel $LN24
	DD	imagerel $LN24+382
	DD	imagerel $unwind$s370_invalidate_tlbe
$pdata$s390_invalidate_tlbe DD imagerel $LN24
	DD	imagerel $LN24+382
	DD	imagerel $unwind$s390_invalidate_tlbe
$pdata$z900_invalidate_tlbe DD imagerel $LN24
	DD	imagerel $LN24+382
	DD	imagerel $unwind$z900_invalidate_tlbe
$pdata$apply_host_prefixing DD imagerel $LN18
	DD	imagerel $LN18+403
	DD	imagerel $unwind$apply_host_prefixing
$pdata$s370_update_psw_ia DD imagerel $LN7
	DD	imagerel $LN7+181
	DD	imagerel $unwind$s370_update_psw_ia
$pdata$s390_update_psw_ia DD imagerel $LN7
	DD	imagerel $LN7+189
	DD	imagerel $unwind$s390_update_psw_ia
$pdata$z900_update_psw_ia DD imagerel $LN7
	DD	imagerel $LN7+194
	DD	imagerel $unwind$z900_update_psw_ia
$pdata$s370_update_guest_psw_ia DD imagerel $LN12
	DD	imagerel $LN12+152
	DD	imagerel $unwind$s370_update_guest_psw_ia
$pdata$s390_update_guest_psw_ia DD imagerel $LN12
	DD	imagerel $LN12+152
	DD	imagerel $unwind$s390_update_guest_psw_ia
$pdata$z900_update_guest_psw_ia DD imagerel $LN12
	DD	imagerel $LN12+152
	DD	imagerel $unwind$z900_update_guest_psw_ia
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__get_storage_key DD imagerel $LN8
	DD	imagerel $LN8+118
	DD	imagerel $unwind$s370__get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+170
	DD	imagerel $unwind$s370__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_get_ptr_to_2K_storekey DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$s370_get_ptr_to_2K_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_get_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$s370_get_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s370_or_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s370_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_get_ptr_to_storekey DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$s370_get_ptr_to_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_get_storekey_by_ptr DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$s370_get_storekey_by_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_storage_key_by_ptr DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$s370_or_storage_key_by_ptr
pdata	ENDS
pdata	SEGMENT
$pdata$s370_logical_to_main_l DD imagerel $LN71
	DD	imagerel $LN71+3831
	DD	imagerel $unwind$s370_logical_to_main_l
$pdata$s390_logical_to_main_l DD imagerel $LN87
	DD	imagerel $LN87+4433
	DD	imagerel $unwind$s390_logical_to_main_l
$pdata$z900_logical_to_main_l DD imagerel $LN84
	DD	imagerel $LN84+4327
	DD	imagerel $unwind$z900_logical_to_main_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_is_fetch_protected DD imagerel $LN14
	DD	imagerel $LN14+114
	DD	imagerel $unwind$s370_is_fetch_protected
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_is_store_protected DD imagerel $LN8
	DD	imagerel $LN8+166
	DD	imagerel $unwind$s370_is_store_protected
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_fetch_main_absolute DD imagerel $LN7
	DD	imagerel $LN7+184
	DD	imagerel $unwind$s370_fetch_main_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_fetch_fullword_absolute DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$s370_fetch_fullword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_fetch_halfword_absolute DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$s370_fetch_halfword_absolute
pdata	ENDS
pdata	SEGMENT
$pdata$s370_invalidate_tlb DD imagerel $LN24
	DD	imagerel $LN24+381
	DD	imagerel $unwind$s370_invalidate_tlb
$pdata$s370_invalidate_pte DD imagerel $LN21
	DD	imagerel $LN21+690
	DD	imagerel $unwind$s370_invalidate_pte
$pdata$s370_translate_asn DD imagerel $LN24
	DD	imagerel $LN24+824
	DD	imagerel $unwind$s370_translate_asn
$pdata$s370_translate_addr DD imagerel $LN63
	DD	imagerel $LN63+3566
	DD	imagerel $unwind$s370_translate_addr
$pdata$s390_translate_addr DD imagerel $LN51
	DD	imagerel $LN51+2692
	DD	imagerel $unwind$s390_translate_addr
$pdata$z900_translate_addr DD imagerel $LN99
	DD	imagerel $LN99+5226
	DD	imagerel $unwind$z900_translate_addr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_purge_tlb_all DD imagerel $LN21
	DD	imagerel $LN21+432
	DD	imagerel $unwind$s370_purge_tlb_all
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_purge_tlbe_all DD imagerel $LN21
	DD	imagerel $LN21+453
	DD	imagerel $unwind$s370_purge_tlbe_all
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_authorize_asn DD imagerel $LN12
	DD	imagerel $LN12+492
	DD	imagerel $unwind$s370_authorize_asn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore2_full DD imagerel $LN3
	DD	imagerel $LN3+204
	DD	imagerel $unwind$s370_vstore2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch2_full DD imagerel $LN3
	DD	imagerel $LN3+174
	DD	imagerel $unwind$s370_vfetch2_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore2 DD imagerel $LN24
	DD	imagerel $LN24+267
	DD	imagerel $unwind$s370_vstore2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch2 DD imagerel $LN26
	DD	imagerel $LN26+275
	DD	imagerel $unwind$s370_vfetch2
pdata	ENDS
pdata	SEGMENT
$pdata$s370_load_address_space_designator DD imagerel $LN19
	DD	imagerel $LN19+516
	DD	imagerel $unwind$s370_load_address_space_designator
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__get_storage_key DD imagerel $LN8
	DD	imagerel $LN8+107
	DD	imagerel $unwind$s390__get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_ptr_to_4K_storekey DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$s390_get_ptr_to_4K_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$s390_get_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_ptr_to_storekey DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$s390_get_ptr_to_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_storekey_by_ptr DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$s390_get_storekey_by_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key_by_ptr DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$s390_or_storage_key_by_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_is_fetch_protected DD imagerel $LN16
	DD	imagerel $LN16+244
	DD	imagerel $unwind$s390_is_fetch_protected
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_is_store_protected DD imagerel $LN9
	DD	imagerel $LN9+230
	DD	imagerel $unwind$s390_is_store_protected
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_fetch_main_absolute DD imagerel $LN9
	DD	imagerel $LN9+284
	DD	imagerel $unwind$s390_fetch_main_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_fetch_fullword_absolute DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$s390_fetch_fullword_absolute
pdata	ENDS
pdata	SEGMENT
$pdata$s390_invalidate_tlb DD imagerel $LN24
	DD	imagerel $LN24+381
	DD	imagerel $unwind$s390_invalidate_tlb
$pdata$s390_invalidate_pte DD imagerel $LN11
	DD	imagerel $LN11+302
	DD	imagerel $unwind$s390_invalidate_pte
$pdata$s390_translate_alet DD imagerel $LN33
	DD	imagerel $LN33+1645
	DD	imagerel $unwind$s390_translate_alet
$pdata$s390_translate_asn DD imagerel $LN24
	DD	imagerel $LN24+900
	DD	imagerel $unwind$s390_translate_asn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_purge_tlb_all DD imagerel $LN21
	DD	imagerel $LN21+432
	DD	imagerel $unwind$s390_purge_tlb_all
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_purge_tlbe_all DD imagerel $LN21
	DD	imagerel $LN21+453
	DD	imagerel $unwind$s390_purge_tlbe_all
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_purge_alb_all DD imagerel $LN19
	DD	imagerel $LN19+319
	DD	imagerel $unwind$s390_purge_alb_all
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_authorize_asn DD imagerel $LN14
	DD	imagerel $LN14+589
	DD	imagerel $unwind$s390_authorize_asn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+321
	DD	imagerel $unwind$s390_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+296
	DD	imagerel $unwind$s390_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore4 DD imagerel $LN12
	DD	imagerel $LN12+200
	DD	imagerel $unwind$s390_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+186
	DD	imagerel $unwind$s390_vfetch4
pdata	ENDS
pdata	SEGMENT
$pdata$s390_load_address_space_designator DD imagerel $LN33
	DD	imagerel $LN33+1636
	DD	imagerel $unwind$s390_load_address_space_designator
$pdata$s390_check_sa_per2 DD imagerel s390_check_sa_per2
	DD	imagerel s390_check_sa_per2+166
	DD	imagerel $unwind$s390_check_sa_per2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__get_storage_key DD imagerel $LN8
	DD	imagerel $LN8+107
	DD	imagerel $unwind$z900__get_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_ptr_to_4K_storekey DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$z900_get_ptr_to_4K_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$z900_get_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_ptr_to_storekey DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$z900_get_ptr_to_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_storekey_by_ptr DD imagerel $LN3
	DD	imagerel $LN3+58
	DD	imagerel $unwind$z900_get_storekey_by_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key_by_ptr DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$z900_or_storage_key_by_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_is_fetch_protected DD imagerel $LN16
	DD	imagerel $LN16+252
	DD	imagerel $unwind$z900_is_fetch_protected
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_is_store_protected DD imagerel $LN9
	DD	imagerel $LN9+235
	DD	imagerel $unwind$z900_is_store_protected
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_fetch_main_absolute DD imagerel $LN7
	DD	imagerel $LN7+185
	DD	imagerel $unwind$z900_fetch_main_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_fetch_doubleword_absolute DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$z900_fetch_doubleword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_fetch_fullword_absolute DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$z900_fetch_fullword_absolute
pdata	ENDS
pdata	SEGMENT
$pdata$z900_invalidate_tlb DD imagerel $LN24
	DD	imagerel $LN24+381
	DD	imagerel $unwind$z900_invalidate_tlb
$pdata$z900_invalidate_pte DD imagerel $LN10
	DD	imagerel $LN10+244
	DD	imagerel $unwind$z900_invalidate_pte
$pdata$z900_translate_alet DD imagerel $LN31
	DD	imagerel $LN31+1495
	DD	imagerel $unwind$z900_translate_alet
$pdata$z900_translate_asn DD imagerel $LN18
	DD	imagerel $LN18+694
	DD	imagerel $unwind$z900_translate_asn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_purge_tlb_all DD imagerel $LN21
	DD	imagerel $LN21+432
	DD	imagerel $unwind$z900_purge_tlb_all
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_purge_tlbe_all DD imagerel $LN21
	DD	imagerel $LN21+453
	DD	imagerel $unwind$z900_purge_tlbe_all
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_purge_alb_all DD imagerel $LN19
	DD	imagerel $LN19+319
	DD	imagerel $unwind$z900_purge_alb_all
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_authorize_asn DD imagerel $LN12
	DD	imagerel $LN12+495
	DD	imagerel $unwind$z900_authorize_asn
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8_full DD imagerel $LN3
	DD	imagerel $LN3+375
	DD	imagerel $unwind$z900_vstore8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch8_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8 DD imagerel $LN9
	DD	imagerel $LN9+174
	DD	imagerel $unwind$z900_vstore8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch8 DD imagerel $LN8
	DD	imagerel $LN8+157
	DD	imagerel $unwind$z900_vfetch8
pdata	ENDS
pdata	SEGMENT
$pdata$z900_load_address_space_designator DD imagerel $LN33
	DD	imagerel $LN33+1667
	DD	imagerel $unwind$z900_load_address_space_designator
$pdata$z900_check_sa_per2 DD imagerel z900_check_sa_per2
	DD	imagerel z900_check_sa_per2+169
	DD	imagerel $unwind$z900_check_sa_per2
pdata	ENDS
_DATA	SEGMENT
$SG169583 DB	'dat.c:73', 00H
	ORG $+7
$SG169584 DB	'PGM IA+-sie', 00H
	ORG $+4
$SG180312 DB	'C:\papa\MyGit\hyperion-zvector\dat.c:73', 00H
$SG180313 DB	'PGM IA+-sie', 00H
	ORG $+4
$SG194037 DB	'C:\papa\MyGit\hyperion-zvector\dat.c:73', 00H
$SG194038 DB	'PGM IA+-sie', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch8 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8 DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch8_full DD 032319H
	DD	07010c214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	0163H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8_full DD 032919H
	DD	07016c21aH
	DD	06015H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_authorize_asn DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_purge_alb_all DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_purge_tlbe_all DD 011401H
	DD	08214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_purge_tlb_all DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_fetch_fullword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_fetch_doubleword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_fetch_main_absolute DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_is_store_protected DD 011701H
	DD	04217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_is_fetch_protected DD 011701H
	DD	02217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key_by_ptr DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_storekey_by_ptr DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_ptr_to_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_4K_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_ptr_to_4K_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__get_storage_key DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4 DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore4 DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	0114H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore4_full DD 031801H
	DD	07014a218H
	DD	06013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_authorize_asn DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_purge_alb_all DD 010901H
	DD	08209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_purge_tlbe_all DD 011401H
	DD	08214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_purge_tlb_all DD 010e01H
	DD	0820eH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_address_space_designator
	DD	01fH
	DD	066bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_translate_alet
	DD	024H
	DD	05c2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_address_space_designator
	DD	01fH
	DD	064cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_translate_alet
	DD	021H
	DD	065bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_fetch_fullword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_fetch_main_absolute DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_is_store_protected DD 011601H
	DD	04216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_is_fetch_protected DD 011601H
	DD	02216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key_by_ptr DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_storekey_by_ptr DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_ptr_to_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_4K_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_ptr_to_4K_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__get_storage_key DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch2 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore2 DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch2_full DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore2_full DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_authorize_asn DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_purge_tlbe_all DD 011401H
	DD	08214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_purge_tlb_all DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_fetch_halfword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_fetch_fullword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_fetch_main_absolute DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_is_store_protected DD 011601H
	DD	04216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_is_fetch_protected DD 011601H
	DD	02216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_storage_key_by_ptr DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_get_storekey_by_ptr DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_get_ptr_to_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_2K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_get_2K_storage_key DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_get_ptr_to_2K_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__get_storage_key DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_purge_alb DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_purge_alb DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_purge_tlb DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_purge_tlb DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_purge_tlb DD 010901H
	DD	06209H
xdata	ENDS
xdata	SEGMENT
$unwind$s370_set_ic_mask DD 010901H
	DD	06209H
$unwind$s390_set_ic_mask DD 010901H
	DD	04209H
$unwind$z900_set_ic_mask DD 010901H
	DD	06209H
$unwind$s370_set_aea_mode DD 010901H
	DD	08209H
$unwind$s390_set_aea_mode DD 010901H
	DD	08209H
$unwind$z900_set_aea_mode DD 010901H
	DD	08209H
$unwind$s370_invalidate_guest_aia DD 010901H
	DD	06209H
$unwind$s390_invalidate_guest_aia DD 010901H
	DD	06209H
$unwind$z900_invalidate_guest_aia DD 010901H
	DD	06209H
$unwind$s370_set_guest_ic_mask DD 010901H
	DD	06209H
$unwind$s390_set_guest_ic_mask DD 010901H
	DD	06209H
$unwind$z900_set_guest_ic_mask DD 010901H
	DD	06209H
$unwind$s370_set_guest_aea_mode DD 010901H
	DD	06209H
$unwind$s390_set_guest_aea_mode DD 010901H
	DD	06209H
$unwind$z900_set_guest_aea_mode DD 010901H
	DD	06209H
$unwind$s370_set_aea_common DD 010901H
	DD	02209H
$unwind$s390_set_aea_common DD 010901H
	DD	02209H
$unwind$z900_set_aea_common DD 010901H
	DD	02209H
$unwind$s370_set_guest_aea_common DD 010901H
	DD	06209H
$unwind$s390_set_guest_aea_common DD 010901H
	DD	06209H
$unwind$z900_set_guest_aea_common DD 010901H
	DD	06209H
$unwind$s370_do_purge_tlb DD 020a01H
	DD	07006120aH
$unwind$s390_do_purge_tlb DD 020a01H
	DD	07006120aH
$unwind$z900_do_purge_tlb DD 020a01H
	DD	07006120aH
$unwind$s390_do_purge_alb DD 010901H
	DD	02209H
$unwind$z900_do_purge_alb DD 010901H
	DD	02209H
$unwind$s370_do_invalidate_tlb DD 020e01H
	DD	0700a120eH
$unwind$s390_do_invalidate_tlb DD 020e01H
	DD	0700a120eH
$unwind$z900_do_invalidate_tlb DD 020e01H
	DD	0700a120eH
$unwind$s370_is_tlbe_match DD 011801H
	DD	0a218H
$unwind$s390_is_tlbe_match DD 011801H
	DD	08218H
$unwind$z900_is_tlbe_match DD 011801H
	DD	08218H
$unwind$s370_do_purge_tlbe DD 011301H
	DD	06213H
$unwind$s390_do_purge_tlbe DD 011301H
	DD	06213H
$unwind$z900_do_purge_tlbe DD 011301H
	DD	06213H
$unwind$s370_purge_tlbe DD 010e01H
	DD	0820eH
$unwind$s390_purge_tlbe DD 010e01H
	DD	0820eH
$unwind$z900_purge_tlbe DD 010e01H
	DD	0820eH
$unwind$s370_do_invalidate_tlbe DD 010e01H
	DD	0820eH
$unwind$s390_do_invalidate_tlbe DD 010e01H
	DD	0820eH
$unwind$z900_do_invalidate_tlbe DD 010e01H
	DD	0820eH
$unwind$s370_invalidate_tlbe DD 010e01H
	DD	0820eH
$unwind$s390_invalidate_tlbe DD 010e01H
	DD	0820eH
$unwind$z900_invalidate_tlbe DD 010e01H
	DD	0820eH
$unwind$apply_host_prefixing DD 010e01H
	DD	0620eH
$unwind$s370_update_psw_ia DD 010d01H
	DD	0820dH
$unwind$s390_update_psw_ia DD 010d01H
	DD	0820dH
$unwind$z900_update_psw_ia DD 010d01H
	DD	0820dH
$unwind$s370_update_guest_psw_ia DD 010d01H
	DD	0620dH
$unwind$s390_update_guest_psw_ia DD 010d01H
	DD	0620dH
$unwind$z900_update_guest_psw_ia DD 010d01H
	DD	0620dH
$unwind$s370_logical_to_main_l DD 021901H
	DD	0110119H
$unwind$s390_logical_to_main_l DD 021901H
	DD	0130119H
$unwind$z900_logical_to_main_l DD 021a01H
	DD	013011aH
$unwind$s370_invalidate_tlb DD 010d01H
	DD	0820dH
$unwind$s370_invalidate_pte DD 011701H
	DD	0a217H
$unwind$s370_translate_asn DD 011801H
	DD	0a218H
$unwind$s370_translate_addr DD 021901H
	DD	0110119H
$unwind$s390_translate_addr DD 011601H
	DD	0e216H
$unwind$z900_translate_addr DD 021a01H
	DD	013011aH
$unwind$s370_load_address_space_designator DD 011201H
	DD	02212H
$unwind$s390_invalidate_tlb DD 010d01H
	DD	0820dH
$unwind$s390_invalidate_pte DD 011701H
	DD	08217H
$unwind$s390_translate_alet DD 012619H
	DD	0e217H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$s390_translate_asn DD 011801H
	DD	0a218H
$unwind$s390_load_address_space_designator DD 022719H
	DD	0150115H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s390_check_sa_per2 DD 011101H
	DD	02211H
$unwind$z900_invalidate_tlb DD 010d01H
	DD	0820dH
$unwind$z900_invalidate_pte DD 011701H
	DD	08217H
$unwind$z900_translate_alet DD 022919H
	DD	011011aH
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$z900_translate_asn DD 011801H
	DD	0a218H
$unwind$z900_load_address_space_designator DD 022719H
	DD	0150115H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$z900_check_sa_per2 DD 011101H
	DD	02211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv77 = 0
arn$ = 32
acctype$ = 40
regs$ = 48
z900_check_sa_per2 PROC

; 2302 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 18	 sub	 rsp, 24
$LN4@z900_check:

; 2303 :     UNREFERENCED( acctype );

  00011	33 c0		 xor	 eax, eax
  00013	85 c0		 test	 eax, eax
  00015	75 fa		 jne	 SHORT $LN4@z900_check

; 2304 : 
; 2305 :     if (0
; 2306 :         || (regs->dat.asd & SAEVENT_BIT)
; 2307 :         || !(regs->CR(9) & CR9_SAC)

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 38		 jne	 SHORT $LN6@z900_check
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00022	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00029	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0002f	48 85 c0	 test	 rax, rax
  00032	75 21		 jne	 SHORT $LN6@z900_check
  00034	b8 08 00 00 00	 mov	 eax, 8
  00039	48 6b c0 0a	 imul	 rax, rax, 10
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0004a	48 25 00 00 20
	00		 and	 rax, 2097152		; 00200000H
  00050	48 85 c0	 test	 rax, rax
  00053	75 4d		 jne	 SHORT $LN5@z900_check
$LN6@z900_check:

; 2308 :     )
; 2309 :     {
; 2310 :         regs->peraid = arn > 0 ? arn : 0;

  00055	83 7c 24 20 00	 cmp	 DWORD PTR arn$[rsp], 0
  0005a	7e 09		 jle	 SHORT $LN8@z900_check
  0005c	8b 44 24 20	 mov	 eax, DWORD PTR arn$[rsp]
  00060	89 04 24	 mov	 DWORD PTR tv77[rsp], eax
  00063	eb 07		 jmp	 SHORT $LN9@z900_check
$LN8@z900_check:
  00065	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv77[rsp], 0
$LN9@z900_check:
  0006c	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00071	0f b6 0c 24	 movzx	 ecx, BYTE PTR tv77[rsp]
  00075	88 88 e0 08 00
	00		 mov	 BYTE PTR [rax+2272], cl

; 2311 :         regs->perc |= regs->dat.stid;

  0007b	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00080	0f b7 80 d0 08
	00 00		 movzx	 eax, WORD PTR [rax+2256]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0008c	0b 81 20 08 00
	00		 or	 eax, DWORD PTR [rcx+2080]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 2312 :         return true;

  0009e	b0 01		 mov	 al, 1
  000a0	eb 02		 jmp	 SHORT $LN1@z900_check
$LN5@z900_check:

; 2313 :     }
; 2314 :     return false;

  000a2	32 c0		 xor	 al, al
$LN1@z900_check:

; 2315 : }

  000a4	48 83 c4 18	 add	 rsp, 24
  000a8	c3		 ret	 0
z900_check_sa_per2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv64 = 48
eax$ = 52
tv68 = 56
tv147 = 60
tv148 = 64
alet$ = 68
tv249 = 72
asteo$ = 76
aste$ = 80
__$ArrayPad$ = 144
arn$ = 176
regs$ = 184
acctype$ = 192
z900_load_address_space_designator PROC

; 670  : {

$LN33:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 671  : #if defined( FEATURE_ACCESS_REGISTERS )
; 672  : U32     alet;                           /* Access list entry token   */
; 673  : U32     asteo;                          /* Real address of ASTE      */
; 674  : U32     aste[16];                       /* ASN second table entry    */
; 675  : U16     eax;                            /* Authorization index       */
; 676  : #else
; 677  :     UNREFERENCED( acctype );
; 678  : #endif
; 679  : 
; 680  :     switch(arn) {

  00027	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  0002e	89 44 24 30	 mov	 DWORD PTR tv64[rsp], eax
  00032	83 7c 24 30 fb	 cmp	 DWORD PTR tv64[rsp], -5
  00037	0f 84 51 01 00
	00		 je	 $LN14@z900_load_
  0003d	83 7c 24 30 fc	 cmp	 DWORD PTR tv64[rsp], -4
  00042	0f 84 07 01 00
	00		 je	 $LN13@z900_load_
  00048	83 7c 24 30 fd	 cmp	 DWORD PTR tv64[rsp], -3
  0004d	0f 84 bd 00 00
	00		 je	 $LN12@z900_load_
  00053	83 7c 24 30 fe	 cmp	 DWORD PTR tv64[rsp], -2
  00058	0f 84 6f 01 00
	00		 je	 $LN15@z900_load_
  0005e	83 7c 24 30 ff	 cmp	 DWORD PTR tv64[rsp], -1
  00063	74 05		 je	 SHORT $LN8@z900_load_
  00065	e9 8d 01 00 00	 jmp	 $LN16@z900_load_
$LN8@z900_load_:

; 681  : 
; 682  :     case USE_INST_SPACE:
; 683  :         switch(regs->AEA_AR(USE_INST_SPACE)) {

  0006a	b8 04 00 00 00	 mov	 eax, 4
  0006f	48 6b c0 04	 imul	 rax, rax, 4
  00073	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00082	89 44 24 38	 mov	 DWORD PTR tv68[rsp], eax
  00086	83 7c 24 38 01	 cmp	 DWORD PTR tv68[rsp], 1
  0008b	74 09		 je	 SHORT $LN9@z900_load_
  0008d	83 7c 24 38 0d	 cmp	 DWORD PTR tv68[rsp], 13
  00092	74 16		 je	 SHORT $LN10@z900_load_
  00094	eb 28		 jmp	 SHORT $LN11@z900_load_
$LN9@z900_load_:

; 684  : 
; 685  :         case 1:
; 686  :             regs->dat.stid = TEA_ST_PRIMARY;

  00096	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 687  :             break;

  000a8	eb 26		 jmp	 SHORT $LN4@z900_load_
$LN10@z900_load_:

; 688  : #if defined( FEATURE_LINKAGE_STACK )
; 689  :         case 13:
; 690  :             regs->dat.stid = TEA_ST_HOME;

  000aa	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	c7 80 20 08 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+2080], 3

; 691  :             break;

  000bc	eb 12		 jmp	 SHORT $LN4@z900_load_
$LN11@z900_load_:

; 692  : #endif
; 693  :         default:
; 694  :             regs->dat.stid = 0;

  000be	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0
$LN4@z900_load_:

; 695  :         } /* end switch(regs->AEA_AR(USE_INST_SPACE)) */
; 696  : 
; 697  :         regs->dat.asd = regs->CR(regs->AEA_AR(USE_INST_SPACE));

  000d0	b8 04 00 00 00	 mov	 eax, 4
  000d5	48 6b c0 04	 imul	 rax, rax, 4
  000d9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  000e8	ff c0		 inc	 eax
  000ea	48 98		 cdqe
  000ec	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000fc	48 8b 84 c2 00
	06 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+1536]
  00104	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 698  :         break;

  0010b	e9 59 05 00 00	 jmp	 $LN2@z900_load_
$LN12@z900_load_:

; 699  : 
; 700  :     case USE_PRIMARY_SPACE:
; 701  :         regs->dat.stid = TEA_ST_PRIMARY;

  00110	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00118	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 702  :         regs->dat.asd = regs->CR(1);

  00122	b8 08 00 00 00	 mov	 eax, 8
  00127	48 6b c0 02	 imul	 rax, rax, 2
  0012b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00133	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013b	48 8b 84 02 00
	06 00 00	 mov	 rax, QWORD PTR [rdx+rax+1536]
  00143	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 703  :         break;

  0014a	e9 1a 05 00 00	 jmp	 $LN2@z900_load_
$LN13@z900_load_:

; 704  : 
; 705  :     case USE_SECONDARY_SPACE:
; 706  :         regs->dat.stid = TEA_ST_SECNDRY;

  0014f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	c7 80 20 08 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+2080], 2

; 707  :         regs->dat.asd = regs->CR(7);

  00161	b8 08 00 00 00	 mov	 eax, 8
  00166	48 6b c0 08	 imul	 rax, rax, 8
  0016a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00172	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0017a	48 8b 84 02 00
	06 00 00	 mov	 rax, QWORD PTR [rdx+rax+1536]
  00182	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 708  :         break;

  00189	e9 db 04 00 00	 jmp	 $LN2@z900_load_
$LN14@z900_load_:

; 709  : 
; 710  :     case USE_HOME_SPACE:
; 711  :         regs->dat.stid = TEA_ST_HOME;

  0018e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00196	c7 80 20 08 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+2080], 3

; 712  :         regs->dat.asd = regs->CR(13);

  001a0	b8 08 00 00 00	 mov	 eax, 8
  001a5	48 6b c0 0e	 imul	 rax, rax, 14
  001a9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b1	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001b9	48 8b 84 02 00
	06 00 00	 mov	 rax, QWORD PTR [rdx+rax+1536]
  001c1	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 713  :         break;

  001c8	e9 9c 04 00 00	 jmp	 $LN2@z900_load_
$LN15@z900_load_:

; 714  : 
; 715  :     case USE_REAL_ADDR:
; 716  :         regs->dat.stid = 0;

  001cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d5	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 717  :         regs->dat.asd = TLB_REAL_ASD;

  001df	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e7	48 c7 80 18 08
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+2072], -1

; 718  :         break;

  001f2	e9 72 04 00 00	 jmp	 $LN2@z900_load_
$LN16@z900_load_:

; 719  : 
; 720  :     default:
; 721  : 
; 722  : #if defined( FEATURE_ACCESS_REGISTERS )
; 723  :         if (ACCESS_REGISTER_MODE(&regs->psw)
; 724  :          || (SIE_ACTIVE(regs) && MULTIPLE_CONTROLLED_DATA_SPACE(GUESTREGS))
; 725  :          || (arn >= USE_ARMODE)

  001f7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ff	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00203	83 f8 40	 cmp	 eax, 64			; 00000040H
  00206	74 14		 je	 SHORT $LN18@z900_load_
  00208	33 c0		 xor	 eax, eax
  0020a	85 c0		 test	 eax, eax
  0020c	75 0e		 jne	 SHORT $LN18@z900_load_
  0020e	83 bc 24 b0 00
	00 00 10	 cmp	 DWORD PTR arn$[rsp], 16
  00216	0f 8c 72 03 00
	00		 jl	 $LN17@z900_load_
$LN18@z900_load_:

; 726  :            )
; 727  :         {
; 728  :             /* Remove flags giving access register number 0-15 */
; 729  :             arn &= 0xF;

  0021c	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00223	83 e0 0f	 and	 eax, 15
  00226	89 84 24 b0 00
	00 00		 mov	 DWORD PTR arn$[rsp], eax

; 730  : 
; 731  :             /* [5.8.4.1] Select the access-list-entry token */
; 732  :             alet = (arn == 0) ? 0 :

  0022d	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  00235	75 0a		 jne	 SHORT $LN29@z900_load_
  00237	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
  0023f	eb 1b		 jmp	 SHORT $LN30@z900_load_
$LN29@z900_load_:
  00241	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR arn$[rsp]
  00249	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	8b 84 81 00 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+768]
  00258	89 44 24 3c	 mov	 DWORD PTR tv147[rsp], eax
$LN30@z900_load_:
  0025c	8b 44 24 3c	 mov	 eax, DWORD PTR tv147[rsp]
  00260	89 44 24 44	 mov	 DWORD PTR alet$[rsp], eax

; 733  :                    /* Guest ALET if XC guest in AR mode */
; 734  :                    (SIE_ACTIVE(regs) && MULTIPLE_CONTROLLED_DATA_SPACE(GUESTREGS))
; 735  :                    ? GUESTREGS->AR(arn) :
; 736  :                    /* If SIE host but not XC guest in AR mode then alet is 0 */
; 737  :                    SIE_ACTIVE(regs) ? 0 :
; 738  :                    /* Otherwise alet is in the access register */
; 739  :                    regs->AR(arn);
; 740  : 
; 741  :             /* Use the ALET to determine the segment table origin */
; 742  :             switch (alet) {

  00264	8b 44 24 44	 mov	 eax, DWORD PTR alet$[rsp]
  00268	89 44 24 40	 mov	 DWORD PTR tv148[rsp], eax
  0026c	83 7c 24 40 00	 cmp	 DWORD PTR tv148[rsp], 0
  00271	74 09		 je	 SHORT $LN19@z900_load_
  00273	83 7c 24 40 01	 cmp	 DWORD PTR tv148[rsp], 1
  00278	74 41		 je	 SHORT $LN20@z900_load_
  0027a	eb 7e		 jmp	 SHORT $LN21@z900_load_
$LN19@z900_load_:

; 743  : 
; 744  :             case ALET_PRIMARY:
; 745  :                 /* [5.8.4.2] Obtain primary segment table designation */
; 746  :                 regs->dat.stid = TEA_ST_PRIMARY;

  0027c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00284	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 747  :                 regs->dat.asd = regs->CR(1);

  0028e	b8 08 00 00 00	 mov	 eax, 8
  00293	48 6b c0 02	 imul	 rax, rax, 2
  00297	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029f	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002a7	48 8b 84 02 00
	06 00 00	 mov	 rax, QWORD PTR [rdx+rax+1536]
  002af	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 748  :                 break;

  002b6	e9 ce 02 00 00	 jmp	 $LN6@z900_load_
$LN20@z900_load_:

; 749  : 
; 750  :             case ALET_SECONDARY:
; 751  :                 /* [5.8.4.2] Obtain secondary segment table designation */
; 752  :                 regs->dat.stid = TEA_ST_SECNDRY;

  002bb	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c3	c7 80 20 08 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+2080], 2

; 753  :                 regs->dat.asd = regs->CR(7);

  002cd	b8 08 00 00 00	 mov	 eax, 8
  002d2	48 6b c0 08	 imul	 rax, rax, 8
  002d6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002de	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002e6	48 8b 84 02 00
	06 00 00	 mov	 rax, QWORD PTR [rdx+rax+1536]
  002ee	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 754  :                 break;

  002f5	e9 8f 02 00 00	 jmp	 $LN6@z900_load_
$LN21@z900_load_:

; 755  : 
; 756  :             default:
; 757  :                 /* ALB Lookup */
; 758  :                 if(regs->AEA_AR(arn) >= CR_ALB_OFFSET)

  002fa	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00301	83 c0 05	 add	 eax, 5
  00304	48 98		 cdqe
  00306	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030e	83 bc 81 94 0c
	00 00 10	 cmp	 DWORD PTR [rcx+rax*4+3220], 16
  00316	0f 8c 95 00 00
	00		 jl	 $LN22@z900_load_

; 759  :                 {
; 760  :                     regs->dat.asd = regs->CR(regs->AEA_AR(arn));

  0031c	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00323	83 c0 05	 add	 eax, 5
  00326	48 98		 cdqe
  00328	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00330	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  00337	ff c0		 inc	 eax
  00339	48 98		 cdqe
  0033b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00343	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0034b	48 8b 84 c2 00
	06 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+1536]
  00353	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 761  :                     regs->dat.protect = regs->aea_aleprot[arn];

  0035a	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR arn$[rsp]
  00362	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036a	0f b6 84 01 09
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3337]
  00372	83 e0 03	 and	 eax, 3
  00375	d1 e0		 shl	 eax, 1
  00377	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037f	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  00385	83 e1 f9	 and	 ecx, -7			; fffffff9H
  00388	0b c8		 or	 ecx, eax
  0038a	8b c1		 mov	 eax, ecx
  0038c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00394	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 762  :                     regs->dat.stid = TEA_ST_ARMODE;

  0039a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a2	c7 80 20 08 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+2080], 1

; 763  :                 }

  003ac	e9 d8 01 00 00	 jmp	 $LN23@z900_load_
$LN22@z900_load_:

; 764  :                 else
; 765  :                 {
; 766  :                     /* Extract the extended AX from CR8 bits 0-15 (32-47) */
; 767  :                     eax = regs->CR_LHH(8);

  003b1	b8 08 00 00 00	 mov	 eax, 8
  003b6	48 6b c0 09	 imul	 rax, rax, 9
  003ba	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c2	0f b7 84 01 02
	06 00 00	 movzx	 eax, WORD PTR [rcx+rax+1538]
  003ca	66 89 44 24 34	 mov	 WORD PTR eax$[rsp], ax

; 768  : 
; 769  :                     /* [5.8.4.3] Perform ALET translation to obtain ASTE */
; 770  :                     if (ARCH_DEP(translate_alet) (alet, eax, acctype,

  003cf	48 8d 44 24 50	 lea	 rax, QWORD PTR aste$[rsp]
  003d4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003d9	48 8d 44 24 4c	 lea	 rax, QWORD PTR asteo$[rsp]
  003de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e3	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003eb	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR acctype$[rsp]
  003f3	0f b7 54 24 34	 movzx	 edx, WORD PTR eax$[rsp]
  003f8	8b 4c 24 44	 mov	 ecx, DWORD PTR alet$[rsp]
  003fc	e8 00 00 00 00	 call	 z900_translate_alet
  00401	0f b7 c0	 movzx	 eax, ax
  00404	85 c0		 test	 eax, eax
  00406	74 14		 je	 SHORT $LN24@z900_load_

; 771  :                                                   regs, &asteo, aste))
; 772  :                         /* Exit if ALET translation error */
; 773  :                         return regs->dat.xcode;

  00408	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00410	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00417	e9 4f 02 00 00	 jmp	 $LN1@z900_load_
$LN24@z900_load_:

; 774  : 
; 775  :                     /* [5.8.4.9] Obtain the STD or ASCE from the ASTE */
; 776  :                     regs->dat.asd = ASTE_AS_DESIGNATOR(aste);

  0041c	b8 04 00 00 00	 mov	 eax, 4
  00421	48 6b c0 02	 imul	 rax, rax, 2
  00425	8b 44 04 50	 mov	 eax, DWORD PTR aste$[rsp+rax]
  00429	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0042d	b9 04 00 00 00	 mov	 ecx, 4
  00432	48 6b c9 03	 imul	 rcx, rcx, 3
  00436	8b 4c 0c 50	 mov	 ecx, DWORD PTR aste$[rsp+rcx]
  0043a	48 0b c1	 or	 rax, rcx
  0043d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00445	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 777  :                     regs->dat.stid = TEA_ST_ARMODE;

  0044c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00454	c7 80 20 08 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+2080], 1

; 778  : 
; 779  :                     if (regs->dat.protect & 2)

  0045e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00466	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0046c	d1 e8		 shr	 eax, 1
  0046e	83 e0 03	 and	 eax, 3
  00471	83 e0 02	 and	 eax, 2
  00474	85 c0		 test	 eax, eax
  00476	74 47		 je	 SHORT $LN25@z900_load_

; 780  :                     {
; 781  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 782  :                        regs->dat.asd ^= ASCE_RESV;

  00478	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00480	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00487	48 35 10 0c 00
	00		 xor	 rax, 3088		; 00000c10H
  0048d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00495	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 783  :                        regs->dat.asd |= ASCE_P;

  0049c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004a4	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  004ab	48 0f ba e8 08	 bts	 rax, 8
  004b0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b8	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax
$LN25@z900_load_:

; 784  : #else
; 785  :                        regs->dat.asd ^= STD_RESV;
; 786  :                        regs->dat.asd |= STD_PRIVATE;
; 787  : #endif
; 788  :                     }
; 789  : 
; 790  :                     /* Update ALB */
; 791  :                     regs->CR(CR_ALB_OFFSET + arn) = regs->dat.asd;

  004bf	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  004c6	83 c0 11	 add	 eax, 17
  004c9	48 98		 cdqe
  004cb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d3	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004db	48 8b 92 18 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2072]
  004e2	48 89 94 c1 00
	06 00 00	 mov	 QWORD PTR [rcx+rax*8+1536], rdx

; 792  :                     regs->AEA_AR(arn) = CR_ALB_OFFSET + arn;

  004ea	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  004f1	83 c0 10	 add	 eax, 16
  004f4	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR arn$[rsp]
  004fb	83 c1 05	 add	 ecx, 5
  004fe	48 63 c9	 movsxd	 rcx, ecx
  00501	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00509	89 84 8a 94 0c
	00 00		 mov	 DWORD PTR [rdx+rcx*4+3220], eax

; 793  :                     regs->AEA_COMMON(CR_ALB_OFFSET + arn) = (regs->dat.asd & ASD_PRIVATE) == 0;

  00510	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00518	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  0051f	48 25 20 01 00
	00		 and	 rax, 288		; 00000120H
  00525	48 85 c0	 test	 rax, rax
  00528	75 0a		 jne	 SHORT $LN31@z900_load_
  0052a	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv249[rsp], 1
  00532	eb 08		 jmp	 SHORT $LN32@z900_load_
$LN31@z900_load_:
  00534	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv249[rsp], 0
$LN32@z900_load_:
  0053c	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00543	83 c0 11	 add	 eax, 17
  00546	48 98		 cdqe
  00548	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00550	0f b6 54 24 48	 movzx	 edx, BYTE PTR tv249[rsp]
  00555	88 94 01 e8 0c
	00 00		 mov	 BYTE PTR [rcx+rax+3304], dl

; 794  :                     regs->aea_aleprot[arn] = regs->dat.protect & 2;

  0055c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00564	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0056a	d1 e8		 shr	 eax, 1
  0056c	83 e0 03	 and	 eax, 3
  0056f	83 e0 02	 and	 eax, 2
  00572	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR arn$[rsp]
  0057a	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00582	88 84 0a 09 0d
	00 00		 mov	 BYTE PTR [rdx+rcx+3337], al
$LN23@z900_load_:
$LN6@z900_load_:

; 795  :                 }
; 796  : 
; 797  :             } /* end switch(alet) */
; 798  : 
; 799  :             break;

  00589	e9 db 00 00 00	 jmp	 $LN2@z900_load_
$LN17@z900_load_:

; 800  : 
; 801  :         } /* end if(ACCESS_REGISTER_MODE) */
; 802  : #endif /* defined( FEATURE_ACCESS_REGISTERS ) */
; 803  : 
; 804  : #if defined( FEATURE_DUAL_ADDRESS_SPACE )
; 805  :         if (SECONDARY_SPACE_MODE(&regs->psw))

  0058e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00596	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0059a	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0059f	75 3f		 jne	 SHORT $LN26@z900_load_

; 806  :         {
; 807  :             regs->dat.stid = TEA_ST_SECNDRY;

  005a1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a9	c7 80 20 08 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+2080], 2

; 808  :             regs->dat.asd = regs->CR(7);

  005b3	b8 08 00 00 00	 mov	 eax, 8
  005b8	48 6b c0 08	 imul	 rax, rax, 8
  005bc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c4	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005cc	48 8b 84 02 00
	06 00 00	 mov	 rax, QWORD PTR [rdx+rax+1536]
  005d4	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 809  :             break;

  005db	e9 89 00 00 00	 jmp	 $LN2@z900_load_
$LN26@z900_load_:

; 810  :         }
; 811  : #endif
; 812  : 
; 813  : #if defined( FEATURE_LINKAGE_STACK )
; 814  :         if (HOME_SPACE_MODE(&regs->psw))

  005e0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e8	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  005ec	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  005f1	75 3c		 jne	 SHORT $LN27@z900_load_

; 815  :         {
; 816  :             regs->dat.stid = TEA_ST_HOME;

  005f3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005fb	c7 80 20 08 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+2080], 3

; 817  :             regs->dat.asd = regs->CR(13);

  00605	b8 08 00 00 00	 mov	 eax, 8
  0060a	48 6b c0 0e	 imul	 rax, rax, 14
  0060e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00616	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0061e	48 8b 84 02 00
	06 00 00	 mov	 rax, QWORD PTR [rdx+rax+1536]
  00626	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 818  :             break;

  0062d	eb 3a		 jmp	 SHORT $LN2@z900_load_
$LN27@z900_load_:

; 819  :         }
; 820  : #endif
; 821  : 
; 822  :         /* Primary space mode */
; 823  :         regs->dat.stid = TEA_ST_PRIMARY;

  0062f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00637	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 824  :         regs->dat.asd = regs->CR(1);

  00641	b8 08 00 00 00	 mov	 eax, 8
  00646	48 6b c0 02	 imul	 rax, rax, 2
  0064a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00652	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0065a	48 8b 84 02 00
	06 00 00	 mov	 rax, QWORD PTR [rdx+rax+1536]
  00662	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax
$LN2@z900_load_:

; 825  :         break;
; 826  : 
; 827  :     } /* switch(arn) */
; 828  : 
; 829  :     return 0;

  00669	33 c0		 xor	 eax, eax
$LN1@z900_load_:

; 830  : 
; 831  : } /* end function load_address_space_designator */

  0066b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00673	48 33 cc	 xor	 rcx, rsp
  00676	e8 00 00 00 00	 call	 __security_check_cookie
  0067b	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00682	c3		 ret	 0
z900_load_address_space_designator ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch8 PROC					; COMDAT

; 711  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 712  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 713  :     if(likely(!((VADR_L)addr & 0x07)))
; 714  :     {
; 715  :         /* doubleword aligned fetch */
; 716  :         U64 *mn;
; 717  :         ITIMER_SYNC( addr, 8-1, regs );
; 718  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 719  :         if (regs->cpubit == regs->sysblk->started_mask)
; 720  :             return CSWAP64( *mn );
; 721  :         return fetch_dw( mn );
; 722  :     }
; 723  :     else
; 724  : #endif
; 725  :     {
; 726  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0001d	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00023	77 0a		 ja	 SHORT $LN6@z900_vfetc
  00025	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0002d	eb 08		 jmp	 SHORT $LN7@z900_vfetc
$LN6@z900_vfetc:
  0002f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN7@z900_vfetc:
  00037	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  0003c	74 47		 je	 SHORT $LN2@z900_vfetc

; 727  :         {
; 728  :             /* unaligned, non-crossing doubleword fetch */
; 729  :             BYTE *mn;
; 730  :             ITIMER_SYNC( addr, 8-1, regs );
; 731  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00043	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00047	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0004b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00053	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00058	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0005d	ba 08 00 00 00	 mov	 edx, 8
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00067	e8 00 00 00 00	 call	 z900_maddr_l
  0006c	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 732  :             return fetch_dw( mn );

  00071	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00076	e8 00 00 00 00	 call	 fetch_dw_noswap
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	e8 00 00 00 00	 call	 _byteswap_uint64
  00083	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 733  :         }
; 734  :     }
; 735  :     /* page crossing doubleword fetch */
; 736  :     return ARCH_DEP( vfetch8_full )( addr, arn, regs );

  00085	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  0008a	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  0008e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00093	e8 00 00 00 00	 call	 z900_vfetch8_full
$LN1@z900_vfetc:

; 737  : }

  00098	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009c	c3		 ret	 0
z900_vfetch8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore8 PROC					; COMDAT

; 577  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 578  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 579  :     /* Check alignement. If aligned then we are guaranteed
; 580  :        not to cross a page boundary */
; 581  :     if (likely(!((VADR_L)addr & 0x07)))
; 582  :     {
; 583  :         /* Most common case : Aligned */
; 584  :         U64 *mn;
; 585  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );
; 586  :         if (regs->cpubit == regs->sysblk->started_mask)
; 587  :             *mn = CSWAP64( value );
; 588  :         else
; 589  :             STORE_DW( mn, value );
; 590  :     }
; 591  :     else
; 592  : #endif
; 593  :     {
; 594  :         /* We're not aligned. So we have to check whether we are
; 595  :            crossing a page boundary. This cannot be the same
; 596  :            code as above because casting U64* to a non aligned
; 597  :            pointer may break on those architectures mandating
; 598  :            strict alignement */
; 599  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00023	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00029	77 0a		 ja	 SHORT $LN7@z900_vstor
  0002b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00033	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00035	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN8@z900_vstor:
  0003d	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00042	74 4c		 je	 SHORT $LN2@z900_vstor

; 600  :         {
; 601  :             /* Non aligned but not crossing page boundary */
; 602  :             BYTE *mn;
; 603  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00044	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00049	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0004d	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00051	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00059	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0005e	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00063	ba 08 00 00 00	 mov	 edx, 8
  00068	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  0006d	e8 00 00 00 00	 call	 z900_maddr_l
  00072	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 604  :             /* invoking STORE_DW ensures endianness correctness */
; 605  :             STORE_DW( mn, value );

  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  0007c	e8 00 00 00 00	 call	 _byteswap_uint64
  00081	48 8b d0	 mov	 rdx, rax
  00084	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00089	e8 00 00 00 00	 call	 store_dw_noswap

; 606  :         }

  0008e	eb 19		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 607  :         else
; 608  :             /* Crossing page boundary */
; 609  :             ARCH_DEP( vstore8_full )( value, addr, arn, regs );

  00090	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  0009a	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  000a4	e8 00 00 00 00	 call	 z900_vstore8_full
$LN3@z900_vstor:

; 610  :     }
; 611  :     ITIMER_UPDATE( addr, 8-1, regs );
; 612  : }

  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
z900_vstore8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch8_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 80
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetch8_full PROC					; COMDAT

; 457  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 458  : BYTE   *mn;                             /* Main storage addresses    */
; 459  : int     len;                            /* Length to end of page     */
; 460  : BYTE    temp[16];                       /* Copy destination          */
; 461  : 
; 462  :     /* Get absolute address of first byte of operand */
; 463  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  0002b	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00031	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00036	48 2b c8	 sub	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 464  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00040	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00045	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004d	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00051	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00055	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005d	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00065	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00078	e8 00 00 00 00	 call	 z900_maddr_l
  0007d	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 465  :     memcpy( temp, mn, len);

  00082	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00087	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0008c	48 8b f9	 mov	 rdi, rcx
  0008f	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00094	48 8b c8	 mov	 rcx, rax
  00097	f3 a4		 rep movsb

; 466  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8 - len, arn, regs,

  00099	b8 08 00 00 00	 mov	 eax, 8
  0009e	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000a2	48 98		 cdqe
  000a4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a9	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000b1	48 03 d1	 add	 rdx, rcx
  000b4	48 8b ca	 mov	 rcx, rdx
  000b7	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000bf	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000c6	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ce	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000d2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000d6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000de	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e6	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ee	48 8b d0	 mov	 rdx, rax
  000f1	e8 00 00 00 00	 call	 z900_maddr_l
  000f6	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 467  :                  ACCTYPE_READ, regs->psw.pkey );
; 468  :     memcpy( temp+len, mn, 8 );

  000fb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00100	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$[rsp]
  00105	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00108	48 89 4c 04 40	 mov	 QWORD PTR temp$[rsp+rax], rcx

; 469  :     return fetch_dw( temp );

  0010d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00112	e8 00 00 00 00	 call	 fetch_dw_noswap
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 _byteswap_uint64

; 470  : }

  0011f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8_full
_TEXT	SEGMENT
len$ = 48
sk$ = 56
main1$ = 64
main2$ = 72
temp$ = 80
__$ArrayPad$ = 88
value$ = 128
addr$ = 136
arn$ = 144
regs$ = 152
z900_vstore8_full PROC					; COMDAT

; 369  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 371  : BYTE   *sk;                             /* Storage key addresses     */
; 372  : int     len;                            /* Length to end of page     */
; 373  : BYTE    temp[8];                        /* Copied value              */
; 374  : 
; 375  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00029	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00031	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00037	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0003c	48 2b c8	 sub	 rcx, rax
  0003f	48 8b c1	 mov	 rax, rcx
  00042	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 376  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00046	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0004b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00057	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0005b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00063	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0006b	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00073	48 8b d0	 mov	 rdx, rax
  00076	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0007e	e8 00 00 00 00	 call	 z900_maddr_l
  00083	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 377  :     sk = regs->dat.storkey;

  00088	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00097	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 378  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8-len, arn, regs,

  0009c	b8 08 00 00 00	 mov	 eax, 8
  000a1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000a5	48 98		 cdqe
  000a7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000ac	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000b4	48 03 d1	 add	 rdx, rcx
  000b7	48 8b ca	 mov	 rcx, rdx
  000ba	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000c9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000d1	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000d5	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000d9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000e1	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e9	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f1	48 8b d0	 mov	 rdx, rax
  000f4	e8 00 00 00 00	 call	 z900_maddr_l
  000f9	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 379  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 380  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000fe	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00103	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00106	83 c8 06	 or	 eax, 6
  00109	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  0010e	88 01		 mov	 BYTE PTR [rcx], al

; 381  :     STORE_DW( temp, value );

  00110	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  00118	e8 00 00 00 00	 call	 _byteswap_uint64
  0011d	48 8b d0	 mov	 rdx, rax
  00120	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00125	e8 00 00 00 00	 call	 store_dw_noswap

; 382  :     memcpy( main1, temp,       len );

  0012a	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0012f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00134	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00139	48 8b f1	 mov	 rsi, rcx
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	f3 a4		 rep movsb

; 383  :     memcpy( main2, temp+len, 8-len );

  00141	b8 08 00 00 00	 mov	 eax, 8
  00146	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0014a	48 98		 cdqe
  0014c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00151	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00156	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0015b	48 8b f1	 mov	 rsi, rcx
  0015e	48 8b c8	 mov	 rcx, rax
  00161	f3 a4		 rep movsb

; 384  : }

  00163	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00168	48 33 cc	 xor	 rcx, rsp
  0016b	e8 00 00 00 00	 call	 __security_check_cookie
  00170	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00174	5f		 pop	 rdi
  00175	5e		 pop	 rsi
  00176	c3		 ret	 0
z900_vstore8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_authorize_asn
_TEXT	SEGMENT
ate$ = 48
atl$ = 52
ato$ = 56
tv88 = 64
ax$ = 96
aste$ = 104
atemask$ = 112
regs$ = 120
z900_authorize_asn PROC					; COMDAT

; 192  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 193  : RADR    ato;                            /* Authority table origin    */
; 194  : int     atl;                            /* Authority table length    */
; 195  : BYTE    ate;                            /* Authority table entry     */
; 196  : 
; 197  :     /* [3.10.3.1] Authority table lookup */
; 198  : 
; 199  :     /* Isolate the authority table origin and length */
; 200  :     ato = aste[0] & ASTE0_ATO;

  00018	b8 04 00 00 00	 mov	 eax, 4
  0001d	48 6b c0 00	 imul	 rax, rax, 0
  00021	48 8b 4c 24 68	 mov	 rcx, QWORD PTR aste$[rsp]
  00026	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00029	25 fc ff ff 7f	 and	 eax, 2147483644		; 7ffffffcH
  0002e	8b c0		 mov	 eax, eax
  00030	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax

; 201  :     atl = aste[1] & ASTE1_ATL;

  00035	b8 04 00 00 00	 mov	 eax, 4
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR aste$[rsp]
  00043	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00046	25 f0 ff 00 00	 and	 eax, 65520		; 0000fff0H
  0004b	89 44 24 34	 mov	 DWORD PTR atl$[rsp], eax

; 202  : 
; 203  :     /* Authorization fails if AX is outside table */
; 204  :     if ((ax & 0xFFF0) > atl)

  0004f	0f b7 44 24 60	 movzx	 eax, WORD PTR ax$[rsp]
  00054	25 f0 ff 00 00	 and	 eax, 65520		; 0000fff0H
  00059	3b 44 24 34	 cmp	 eax, DWORD PTR atl$[rsp]
  0005d	7e 07		 jle	 SHORT $LN5@z900_autho

; 205  :         return true;

  0005f	b0 01		 mov	 al, 1
  00061	e9 84 01 00 00	 jmp	 $LN1@z900_autho
$LN5@z900_autho:

; 206  : 
; 207  :     /* Calculate the address of the byte in the authority
; 208  :        table which contains the 2 bit entry for this AX */
; 209  :     ato += (ax >> 2);

  00066	0f b7 44 24 60	 movzx	 eax, WORD PTR ax$[rsp]
  0006b	c1 f8 02	 sar	 eax, 2
  0006e	48 98		 cdqe
  00070	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ato$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax

; 210  : 
; 211  :     /* Ignore carry into bit position 0 */
; 212  :     ato &= 0x7FFFFFFF;

  00080	48 8b 44 24 38	 mov	 rax, QWORD PTR ato$[rsp]
  00085	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  0008b	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax

; 213  : 
; 214  :     /* Addressing exception if ATE is outside main storage */
; 215  :     if (ato > regs->mainlim)

  00090	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00095	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0009c	48 39 44 24 38	 cmp	 QWORD PTR ato$[rsp], rax
  000a1	76 05		 jbe	 SHORT $LN6@z900_autho

; 216  :         goto auth_addr_excp;

  000a3	e9 2d 01 00 00	 jmp	 $auth_addr_excp$13
$LN6@z900_autho:

; 217  : 
; 218  :     /* Load the byte containing the authority table entry
; 219  :        and shift the entry into the leftmost 2 bits */
; 220  :     ato = APPLY_PREFIXING( ato, regs->PX );

  000a8	48 8b 44 24 38	 mov	 rax, QWORD PTR ato$[rsp]
  000ad	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  000b3	48 85 c0	 test	 rax, rax
  000b6	74 22		 je	 SHORT $LN10@z900_autho
  000b8	48 8b 44 24 38	 mov	 rax, QWORD PTR ato$[rsp]
  000bd	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  000c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  000cc	74 0c		 je	 SHORT $LN10@z900_autho
  000ce	48 8b 44 24 38	 mov	 rax, QWORD PTR ato$[rsp]
  000d3	48 89 44 24 40	 mov	 QWORD PTR tv88[rsp], rax
  000d8	eb 19		 jmp	 SHORT $LN11@z900_autho
$LN10@z900_autho:
  000da	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000df	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000e3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ato$[rsp]
  000e8	48 33 c8	 xor	 rcx, rax
  000eb	48 8b c1	 mov	 rax, rcx
  000ee	48 89 44 24 40	 mov	 QWORD PTR tv88[rsp], rax
$LN11@z900_autho:
  000f3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv88[rsp]
  000f8	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax
$LN4@z900_autho:

; 221  : 
; 222  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 223  :        is treated as a no-operation if SIE_MODE not active */
; 224  :     SIE_TRANSLATE( &ato, ACCTYPE_SIE, regs );

  000fd	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00102	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00108	d1 e8		 shr	 eax, 1
  0010a	83 e0 01	 and	 eax, 1
  0010d	85 c0		 test	 eax, eax
  0010f	74 68		 je	 SHORT $LN7@z900_autho
  00111	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00116	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011c	c1 e8 02	 shr	 eax, 2
  0011f	83 e0 01	 and	 eax, 1
  00122	85 c0		 test	 eax, eax
  00124	75 53		 jne	 SHORT $LN7@z900_autho
  00126	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00132	48 03 44 24 38	 add	 rax, QWORD PTR ato$[rsp]
  00137	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00140	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00145	45 33 c9	 xor	 r9d, r9d
  00148	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0014d	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00154	ba fd ff ff ff	 mov	 edx, -3
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 z900_logical_to_main_l
  00161	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016d	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  00174	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax
$LN7@z900_autho:
  00179	33 c0		 xor	 eax, eax
  0017b	85 c0		 test	 eax, eax
  0017d	0f 85 7a ff ff
	ff		 jne	 $LN4@z900_autho

; 225  : 
; 226  :     ate = regs->mainstor[ato];

  00183	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00188	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0018f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ato$[rsp]
  00194	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00198	88 44 24 30	 mov	 BYTE PTR ate$[rsp], al

; 227  :     ate <<= ((ax & 0x03)*2);

  0019c	0f b7 44 24 60	 movzx	 eax, WORD PTR ax$[rsp]
  001a1	83 e0 03	 and	 eax, 3
  001a4	d1 e0		 shl	 eax, 1
  001a6	0f b6 c8	 movzx	 ecx, al
  001a9	0f b6 44 24 30	 movzx	 eax, BYTE PTR ate$[rsp]
  001ae	d2 e0		 shl	 al, cl
  001b0	88 44 24 30	 mov	 BYTE PTR ate$[rsp], al

; 228  : 
; 229  :     /* Set the main storage reference bit */
; 230  :     ARCH_DEP( or_storage_key )( ato, STORKEY_REF );

  001b4	b2 04		 mov	 dl, 4
  001b6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ato$[rsp]
  001bb	e8 00 00 00 00	 call	 z900_or_storage_key

; 231  : 
; 232  :     /* Authorization fails if the specified bit (either X'80' or
; 233  :        X'40' of the 2 bit authority table entry) is zero */
; 234  :     if ((ate & atemask) == 0)

  001c0	0f b6 44 24 30	 movzx	 eax, BYTE PTR ate$[rsp]
  001c5	23 44 24 70	 and	 eax, DWORD PTR atemask$[rsp]
  001c9	85 c0		 test	 eax, eax
  001cb	75 04		 jne	 SHORT $LN8@z900_autho

; 235  :         return true;

  001cd	b0 01		 mov	 al, 1
  001cf	eb 19		 jmp	 SHORT $LN1@z900_autho
$LN8@z900_autho:

; 236  : 
; 237  :     /* Exit with successful return code */
; 238  :     return false;

  001d1	32 c0		 xor	 al, al
  001d3	eb 15		 jmp	 SHORT $LN1@z900_autho
$auth_addr_excp$13:

; 239  : 
; 240  : /* Conditions which always cause program check */
; 241  : auth_addr_excp:
; 242  :     regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );

  001d5	ba 05 00 00 00	 mov	 edx, 5
  001da	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001df	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e4	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN1@z900_autho:
$LN9@z900_autho:

; 243  :     UNREACHABLE_CODE( return false );
; 244  : }

  001ea	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ee	c3		 ret	 0
z900_authorize_asn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_purge_alb_all
_TEXT	SEGMENT
cpu$ = 32
tv92 = 36
p$1 = 40
p$2 = 48
regs$ = 80
z900_purge_alb_all PROC					; COMDAT

; 136  : {

$LN19:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 137  :     int  cpu;
; 138  : 
; 139  :     if (!IS_INTLOCK_HELD( regs ))   // (sanity check)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0001c	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00023	3b c1		 cmp	 eax, ecx
  00025	74 17		 je	 SHORT $LN13@z900_purge
$LN4@z900_purge:

; 140  :         CRASH();                    // (logic error!)

  00027	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00030	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00035	c6 00 00	 mov	 BYTE PTR [rax], 0
  00038	33 c0		 xor	 eax, eax
  0003a	85 c0		 test	 eax, eax
  0003c	75 e9		 jne	 SHORT $LN4@z900_purge
$LN13@z900_purge:

; 141  : 
; 142  :     for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  0003e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  00046	eb 0a		 jmp	 SHORT $LN7@z900_purge
$LN5@z900_purge:
  00048	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN7@z900_purge:
  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0005f	39 44 24 20	 cmp	 DWORD PTR cpu$[rsp], eax
  00063	0f 8d d1 00 00
	00		 jge	 $LN6@z900_purge

; 143  :     {
; 144  :         if (1
; 145  :             && IS_CPU_ONLINE(cpu)
; 146  :             && (sysblk.regs[ cpu ]->cpubit & sysblk.started_mask)

  00069	33 c0		 xor	 eax, eax
  0006b	83 f8 01	 cmp	 eax, 1
  0006e	0f 84 c1 00 00
	00		 je	 $LN14@z900_purge
  00074	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00079	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00080	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00089	0f 84 a6 00 00
	00		 je	 $LN14@z900_purge
  0008f	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00094	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0009b	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000aa	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  000b1	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000b5	48 23 c1	 and	 rax, rcx
  000b8	48 85 c0	 test	 rax, rax
  000bb	74 78		 je	 SHORT $LN14@z900_purge

; 147  :         )
; 148  :         {
; 149  :             switch (sysblk.regs[ cpu ]->arch_mode)

  000bd	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c9	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000d1	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  000d4	89 44 24 24	 mov	 DWORD PTR tv92[rsp], eax
  000d8	83 7c 24 24 01	 cmp	 DWORD PTR tv92[rsp], 1
  000dd	74 09		 je	 SHORT $LN15@z900_purge
  000df	83 7c 24 24 02	 cmp	 DWORD PTR tv92[rsp], 2
  000e4	74 1d		 je	 SHORT $LN16@z900_purge
  000e6	eb 36		 jmp	 SHORT $LN17@z900_purge
$LN15@z900_purge:

; 150  :             {
; 151  :             case ARCH_390_IDX: s390_purge_alb( sysblk.regs[ cpu ]); break;

  000e8	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000ed	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000f4	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  000fc	e8 00 00 00 00	 call	 s390_purge_alb
  00101	eb 32		 jmp	 SHORT $LN8@z900_purge
$LN16@z900_purge:

; 152  :             case ARCH_900_IDX: z900_purge_alb( sysblk.regs[ cpu ]); break;

  00103	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00108	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0010f	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  00117	e8 00 00 00 00	 call	 z900_purge_alb
  0011c	eb 17		 jmp	 SHORT $LN8@z900_purge
$LN17@z900_purge:
$LN12@z900_purge:

; 153  :             default: CRASH(); // (370 doesn't have access registers)

  0011e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  00127	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  0012c	c6 00 00	 mov	 BYTE PTR [rax], 0
  0012f	33 c0		 xor	 eax, eax
  00131	85 c0		 test	 eax, eax
  00133	75 e9		 jne	 SHORT $LN12@z900_purge
$LN8@z900_purge:
$LN14@z900_purge:

; 154  :             }
; 155  :         }
; 156  :     }

  00135	e9 0e ff ff ff	 jmp	 $LN5@z900_purge
$LN6@z900_purge:

; 157  : }

  0013a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013e	c3		 ret	 0
z900_purge_alb_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_purge_tlbe_all
_TEXT	SEGMENT
cpu$ = 32
tv137 = 36
p$1 = 40
p$2 = 48
regs$ = 80
pfra$ = 88
cpuad$ = 96
z900_purge_tlbe_all PROC				; COMDAT

; 102  : {

$LN21:
  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 103  :     int  cpu;
; 104  : 
; 105  :     if (0xFFFF == cpuad && !IS_INTLOCK_HELD( regs ))  // (sanity check)

  00014	0f b7 44 24 60	 movzx	 eax, WORD PTR cpuad$[rsp]
  00019	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0001e	75 35		 jne	 SHORT $LN13@z900_purge
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00027	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  0002e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00033	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0003a	3b c1		 cmp	 eax, ecx
  0003c	74 17		 je	 SHORT $LN13@z900_purge
$LN4@z900_purge:

; 106  :         CRASH();                                      // (logic error!)

  0003e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00047	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0004c	c6 00 00	 mov	 BYTE PTR [rax], 0
  0004f	33 c0		 xor	 eax, eax
  00051	85 c0		 test	 eax, eax
  00053	75 e9		 jne	 SHORT $LN4@z900_purge
$LN13@z900_purge:

; 107  : 
; 108  :     for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  00055	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  0005d	eb 0a		 jmp	 SHORT $LN7@z900_purge
$LN5@z900_purge:
  0005f	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  00063	ff c0		 inc	 eax
  00065	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN7@z900_purge:
  00069	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00070	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00076	39 44 24 20	 cmp	 DWORD PTR cpu$[rsp], eax
  0007a	0f 8d 40 01 00
	00		 jge	 $LN6@z900_purge

; 109  :     {
; 110  :         if (1
; 111  :             && IS_CPU_ONLINE(cpu)
; 112  :             && (sysblk.regs[ cpu ]->cpubit & sysblk.started_mask)
; 113  :             && (0

  00080	33 c0		 xor	 eax, eax
  00082	83 f8 01	 cmp	 eax, 1
  00085	0f 84 30 01 00
	00		 je	 $LN14@z900_purge
  0008b	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00090	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00097	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  000a0	0f 84 15 01 00
	00		 je	 $LN14@z900_purge
  000a6	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b2	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000ba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c1	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  000c8	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000cc	48 23 c1	 and	 rax, rcx
  000cf	48 85 c0	 test	 rax, rax
  000d2	0f 84 e3 00 00
	00		 je	 $LN14@z900_purge
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 34		 jne	 SHORT $LN15@z900_purge
  000de	0f b7 44 24 60	 movzx	 eax, WORD PTR cpuad$[rsp]
  000e3	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  000e8	74 28		 je	 SHORT $LN15@z900_purge
  000ea	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000f6	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000fe	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00105	0f b7 4c 24 60	 movzx	 ecx, WORD PTR cpuad$[rsp]
  0010a	3b c1		 cmp	 eax, ecx
  0010c	0f 85 a9 00 00
	00		 jne	 $LN14@z900_purge
$LN15@z900_purge:

; 114  :                 || 0xFFFF == cpuad
; 115  :                 || sysblk.regs[ cpu ]->cpuad == cpuad
; 116  :                )
; 117  :         )
; 118  :         {
; 119  :             switch (sysblk.regs[ cpu ]->arch_mode)

  00112	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00117	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0011e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00126	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00129	89 44 24 24	 mov	 DWORD PTR tv137[rsp], eax
  0012d	83 7c 24 24 00	 cmp	 DWORD PTR tv137[rsp], 0
  00132	74 10		 je	 SHORT $LN16@z900_purge
  00134	83 7c 24 24 01	 cmp	 DWORD PTR tv137[rsp], 1
  00139	74 29		 je	 SHORT $LN17@z900_purge
  0013b	83 7c 24 24 02	 cmp	 DWORD PTR tv137[rsp], 2
  00140	74 42		 je	 SHORT $LN18@z900_purge
  00142	eb 60		 jmp	 SHORT $LN19@z900_purge
$LN16@z900_purge:

; 120  :             {
; 121  :             case ARCH_370_IDX: s370_purge_tlbe( sysblk.regs[ cpu ], pfra ); break;

  00144	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00149	48 8b 54 24 58	 mov	 rdx, QWORD PTR pfra$[rsp]
  0014e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00155	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0015d	e8 00 00 00 00	 call	 s370_purge_tlbe
  00162	eb 57		 jmp	 SHORT $LN8@z900_purge
$LN17@z900_purge:

; 122  :             case ARCH_390_IDX: s390_purge_tlbe( sysblk.regs[ cpu ], pfra ); break;

  00164	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00169	48 8b 54 24 58	 mov	 rdx, QWORD PTR pfra$[rsp]
  0016e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00175	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0017d	e8 00 00 00 00	 call	 s390_purge_tlbe
  00182	eb 37		 jmp	 SHORT $LN8@z900_purge
$LN18@z900_purge:

; 123  :             case ARCH_900_IDX: z900_purge_tlbe( sysblk.regs[ cpu ], pfra ); break;

  00184	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00189	48 8b 54 24 58	 mov	 rdx, QWORD PTR pfra$[rsp]
  0018e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00195	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0019d	e8 00 00 00 00	 call	 z900_purge_tlbe
  001a2	eb 17		 jmp	 SHORT $LN8@z900_purge
$LN19@z900_purge:
$LN12@z900_purge:

; 124  :             default: CRASH();

  001a4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  001ad	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  001b2	c6 00 00	 mov	 BYTE PTR [rax], 0
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 e9		 jne	 SHORT $LN12@z900_purge
$LN8@z900_purge:
$LN14@z900_purge:

; 125  :             }
; 126  :         }
; 127  :     }

  001bb	e9 9f fe ff ff	 jmp	 $LN5@z900_purge
$LN6@z900_purge:

; 128  : }

  001c0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c4	c3		 ret	 0
z900_purge_tlbe_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_purge_tlb_all
_TEXT	SEGMENT
cpu$ = 32
tv137 = 36
p$1 = 40
p$2 = 48
regs$ = 80
cpuad$ = 88
z900_purge_tlb_all PROC					; COMDAT

; 69   : {

$LN21:
  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 70   :     int  cpu;
; 71   : 
; 72   :     if (0xFFFF == cpuad && !IS_INTLOCK_HELD( regs ))  // (sanity check)

  0000e	0f b7 44 24 58	 movzx	 eax, WORD PTR cpuad$[rsp]
  00013	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00018	75 35		 jne	 SHORT $LN13@z900_purge
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00034	3b c1		 cmp	 eax, ecx
  00036	74 17		 je	 SHORT $LN13@z900_purge
$LN4@z900_purge:

; 73   :         CRASH();                                      // (logic error!)

  00038	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00041	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00046	c6 00 00	 mov	 BYTE PTR [rax], 0
  00049	33 c0		 xor	 eax, eax
  0004b	85 c0		 test	 eax, eax
  0004d	75 e9		 jne	 SHORT $LN4@z900_purge
$LN13@z900_purge:

; 74   : 
; 75   :     for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  0004f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  00057	eb 0a		 jmp	 SHORT $LN7@z900_purge
$LN5@z900_purge:
  00059	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN7@z900_purge:
  00063	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00070	39 44 24 20	 cmp	 DWORD PTR cpu$[rsp], eax
  00074	0f 8d 31 01 00
	00		 jge	 $LN6@z900_purge

; 76   :     {
; 77   :         if (1
; 78   :             && IS_CPU_ONLINE(cpu)
; 79   :             && (sysblk.regs[ cpu ]->cpubit & sysblk.started_mask)
; 80   :             && (0

  0007a	33 c0		 xor	 eax, eax
  0007c	83 f8 01	 cmp	 eax, 1
  0007f	0f 84 21 01 00
	00		 je	 $LN14@z900_purge
  00085	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00091	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0009a	0f 84 06 01 00
	00		 je	 $LN14@z900_purge
  000a0	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ac	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000bb	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  000c2	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000c6	48 23 c1	 and	 rax, rcx
  000c9	48 85 c0	 test	 rax, rax
  000cc	0f 84 d4 00 00
	00		 je	 $LN14@z900_purge
  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 34		 jne	 SHORT $LN15@z900_purge
  000d8	0f b7 44 24 58	 movzx	 eax, WORD PTR cpuad$[rsp]
  000dd	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  000e2	74 28		 je	 SHORT $LN15@z900_purge
  000e4	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000f0	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000f8	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ff	0f b7 4c 24 58	 movzx	 ecx, WORD PTR cpuad$[rsp]
  00104	3b c1		 cmp	 eax, ecx
  00106	0f 85 9a 00 00
	00		 jne	 $LN14@z900_purge
$LN15@z900_purge:

; 81   :                 || 0xFFFF == cpuad
; 82   :                 || sysblk.regs[ cpu ]->cpuad == cpuad
; 83   :                )
; 84   :         )
; 85   :         {
; 86   :             switch (sysblk.regs[ cpu ]->arch_mode)

  0010c	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00111	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00118	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00120	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00123	89 44 24 24	 mov	 DWORD PTR tv137[rsp], eax
  00127	83 7c 24 24 00	 cmp	 DWORD PTR tv137[rsp], 0
  0012c	74 10		 je	 SHORT $LN16@z900_purge
  0012e	83 7c 24 24 01	 cmp	 DWORD PTR tv137[rsp], 1
  00133	74 24		 je	 SHORT $LN17@z900_purge
  00135	83 7c 24 24 02	 cmp	 DWORD PTR tv137[rsp], 2
  0013a	74 38		 je	 SHORT $LN18@z900_purge
  0013c	eb 51		 jmp	 SHORT $LN19@z900_purge
$LN16@z900_purge:

; 87   :             {
; 88   :             case ARCH_370_IDX: s370_purge_tlb( sysblk.regs[ cpu ]); break;

  0013e	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00143	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0014a	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  00152	e8 00 00 00 00	 call	 s370_purge_tlb
  00157	eb 4d		 jmp	 SHORT $LN8@z900_purge
$LN17@z900_purge:

; 89   :             case ARCH_390_IDX: s390_purge_tlb( sysblk.regs[ cpu ]); break;

  00159	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0015e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00165	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0016d	e8 00 00 00 00	 call	 s390_purge_tlb
  00172	eb 32		 jmp	 SHORT $LN8@z900_purge
$LN18@z900_purge:

; 90   :             case ARCH_900_IDX: z900_purge_tlb( sysblk.regs[ cpu ]); break;

  00174	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00179	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00180	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  00188	e8 00 00 00 00	 call	 z900_purge_tlb
  0018d	eb 17		 jmp	 SHORT $LN8@z900_purge
$LN19@z900_purge:
$LN12@z900_purge:

; 91   :             default: CRASH();

  0018f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  00198	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  0019d	c6 00 00	 mov	 BYTE PTR [rax], 0
  001a0	33 c0		 xor	 eax, eax
  001a2	85 c0		 test	 eax, eax
  001a4	75 e9		 jne	 SHORT $LN12@z900_purge
$LN8@z900_purge:
$LN14@z900_purge:

; 92   :             }
; 93   :         }
; 94   :     }

  001a6	e9 ae fe ff ff	 jmp	 $LN5@z900_purge
$LN6@z900_purge:

; 95   : }

  001ab	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001af	c3		 ret	 0
z900_purge_tlb_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
aste_addr$ = 32
afte_addr$ = 36
i$ = 40
code$ = 44
afte$ = 48
numwords$ = 52
aste_main$ = 56
tv89 = 64
tv155 = 72
asn$ = 96
regs$ = 104
asteo$ = 112
aste$ = 120
z900_translate_asn PROC

; 281  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 282  : U32     afte_addr;                      /* Address of AFTE           */
; 283  : U32     afte;                           /* ASN first table entry     */
; 284  : U32     aste_addr;                      /* Address of ASTE           */
; 285  : BYTE   *aste_main;                      /* ASTE mainstor address     */
; 286  : int     code;                           /* Exception code            */
; 287  : int     numwords;                       /* ASTE size (4 or 16 words) */
; 288  : int     i;                              /* Array subscript           */
; 289  : 
; 290  :     /* [3.9.3.1] Use the AFX to obtain the real address of the AFTE */
; 291  :     afte_addr = (regs->CR(14) & CR14_AFTO) << 12;

  00018	b8 08 00 00 00	 mov	 eax, 8
  0001d	48 6b c0 0f	 imul	 rax, rax, 15
  00021	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00026	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0002e	48 25 ff ff 07
	00		 and	 rax, 524287		; 0007ffffH
  00034	48 c1 e0 0c	 shl	 rax, 12
  00038	89 44 24 24	 mov	 DWORD PTR afte_addr$[rsp], eax

; 292  :     afte_addr += (asn & ASN_AFX) >> 4;

  0003c	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  00041	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00046	c1 f8 04	 sar	 eax, 4
  00049	8b 4c 24 24	 mov	 ecx, DWORD PTR afte_addr$[rsp]
  0004d	03 c8		 add	 ecx, eax
  0004f	8b c1		 mov	 eax, ecx
  00051	89 44 24 24	 mov	 DWORD PTR afte_addr$[rsp], eax

; 293  : 
; 294  :     /* Addressing exception if AFTE is outside main storage */
; 295  :     if (afte_addr > regs->mainlim)

  00055	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  00059	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  00065	76 05		 jbe	 SHORT $LN7@z900_trans

; 296  :         goto asn_addr_excp;

  00067	e9 eb 01 00 00	 jmp	 $asn_addr_excp$19
$LN7@z900_trans:

; 297  : 
; 298  :     /* Load the AFTE from main storage. All four bytes must be
; 299  :        fetched concurrently as observed by other CPUs */
; 300  :     afte_addr = APPLY_PREFIXING (afte_addr, regs->PX);

  0006c	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  00070	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00076	48 85 c0	 test	 rax, rax
  00079	74 20		 je	 SHORT $LN14@z900_trans
  0007b	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  0007f	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00085	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008a	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  0008e	74 0b		 je	 SHORT $LN14@z900_trans
  00090	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  00094	48 89 44 24 40	 mov	 QWORD PTR tv89[rsp], rax
  00099	eb 12		 jmp	 SHORT $LN15@z900_trans
$LN14@z900_trans:
  0009b	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  0009f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000a4	48 33 41 70	 xor	 rax, QWORD PTR [rcx+112]
  000a8	48 89 44 24 40	 mov	 QWORD PTR tv89[rsp], rax
$LN15@z900_trans:
  000ad	8b 44 24 40	 mov	 eax, DWORD PTR tv89[rsp]
  000b1	89 44 24 24	 mov	 DWORD PTR afte_addr$[rsp], eax

; 301  :     afte = ARCH_DEP(fetch_fullword_absolute) (afte_addr, regs);

  000b5	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  000b9	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000be	8b c8		 mov	 ecx, eax
  000c0	e8 00 00 00 00	 call	 z900_fetch_fullword_absolute
  000c5	89 44 24 30	 mov	 DWORD PTR afte$[rsp], eax

; 302  : 
; 303  :     /* AFX translation exception if AFTE invalid bit is set */
; 304  :     if (afte & AFTE_INVALID)

  000c9	8b 44 24 30	 mov	 eax, DWORD PTR afte$[rsp]
  000cd	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  000d2	85 c0		 test	 eax, eax
  000d4	74 05		 je	 SHORT $LN8@z900_trans

; 305  :         goto asn_afx_tran_excp;

  000d6	e9 98 01 00 00	 jmp	 $asn_afx_tran_excp$20
$LN8@z900_trans:

; 306  : 
; 307  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 308  :     /* ASN translation specification exception if reserved bits set */
; 309  :     if (!ASF_ENABLED(regs)) {
; 310  :         if (afte & AFTE_RESV_0)
; 311  :               goto asn_asn_tran_spec_excp;
; 312  :     } else {
; 313  :         if (afte & AFTE_RESV_1)
; 314  :               goto asn_asn_tran_spec_excp;
; 315  :     }
; 316  : #endif
; 317  : 
; 318  :     /* [3.9.3.2] Use AFTE and ASX to obtain real address of ASTE */
; 319  :     if (!ASF_ENABLED(regs)) {

  000db	33 c0		 xor	 eax, eax
  000dd	85 c0		 test	 eax, eax
  000df	74 2e		 je	 SHORT $LN9@z900_trans

; 320  :         aste_addr = afte & AFTE_ASTO_0;

  000e1	8b 44 24 30	 mov	 eax, DWORD PTR afte$[rsp]
  000e5	25 f0 ff ff 7f	 and	 eax, 2147483632		; 7ffffff0H
  000ea	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 321  :         aste_addr += (asn & ASN_ASX) << 4;

  000ee	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  000f3	83 e0 3f	 and	 eax, 63			; 0000003fH
  000f6	c1 e0 04	 shl	 eax, 4
  000f9	8b 4c 24 20	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  000fd	03 c8		 add	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 322  :         numwords = 4;

  00105	c7 44 24 34 04
	00 00 00	 mov	 DWORD PTR numwords$[rsp], 4

; 323  :     } else {

  0010d	eb 2c		 jmp	 SHORT $LN10@z900_trans
$LN9@z900_trans:

; 324  :         aste_addr = afte & AFTE_ASTO_1;

  0010f	8b 44 24 30	 mov	 eax, DWORD PTR afte$[rsp]
  00113	25 c0 ff ff 7f	 and	 eax, 2147483584		; 7fffffc0H
  00118	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 325  :         aste_addr += (asn & ASN_ASX) << 6;

  0011c	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  00121	83 e0 3f	 and	 eax, 63			; 0000003fH
  00124	c1 e0 06	 shl	 eax, 6
  00127	8b 4c 24 20	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  0012b	03 c8		 add	 ecx, eax
  0012d	8b c1		 mov	 eax, ecx
  0012f	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 326  :         numwords = 16;

  00133	c7 44 24 34 10
	00 00 00	 mov	 DWORD PTR numwords$[rsp], 16
$LN10@z900_trans:

; 327  :     }
; 328  : 
; 329  :     /* Ignore carry into bit position 0 of ASTO */
; 330  :     aste_addr &= 0x7FFFFFFF;

  0013b	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  0013f	0f ba f0 1f	 btr	 eax, 31
  00143	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 331  : 
; 332  :     /* Addressing exception if ASTE is outside main storage */
; 333  :     if (aste_addr > regs->mainlim)

  00147	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  0014b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00150	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  00157	76 05		 jbe	 SHORT $LN11@z900_trans

; 334  :         goto asn_addr_excp;

  00159	e9 f9 00 00 00	 jmp	 $asn_addr_excp$19
$LN11@z900_trans:

; 335  : 
; 336  :     /* Return the real address of the ASTE */
; 337  :     *asteo = aste_addr;

  0015e	48 8b 44 24 70	 mov	 rax, QWORD PTR asteo$[rsp]
  00163	8b 4c 24 20	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  00167	89 08		 mov	 DWORD PTR [rax], ecx

; 338  : 
; 339  :     /* Fetch the 16- or 64-byte ASN second table entry from real
; 340  :        storage.  Each fullword of the ASTE must be fetched
; 341  :        concurrently as observed by other CPUs */
; 342  :     aste_addr = APPLY_PREFIXING (aste_addr, regs->PX);

  00169	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  0016d	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00173	48 85 c0	 test	 rax, rax
  00176	74 20		 je	 SHORT $LN16@z900_trans
  00178	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  0017c	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00182	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  0018b	74 0b		 je	 SHORT $LN16@z900_trans
  0018d	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  00191	48 89 44 24 48	 mov	 QWORD PTR tv155[rsp], rax
  00196	eb 12		 jmp	 SHORT $LN17@z900_trans
$LN16@z900_trans:
  00198	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  0019c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a1	48 33 41 70	 xor	 rax, QWORD PTR [rcx+112]
  001a5	48 89 44 24 48	 mov	 QWORD PTR tv155[rsp], rax
$LN17@z900_trans:
  001aa	8b 44 24 48	 mov	 eax, DWORD PTR tv155[rsp]
  001ae	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 343  :     aste_main = FETCH_MAIN_ABSOLUTE(aste_addr, regs, numwords * 4);

  001b2	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  001b6	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  001bb	8b c8		 mov	 ecx, eax
  001bd	e8 00 00 00 00	 call	 z900_fetch_main_absolute
  001c2	48 89 44 24 38	 mov	 QWORD PTR aste_main$[rsp], rax

; 344  :     for (i = 0; i < numwords; i++)

  001c7	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001cf	eb 0a		 jmp	 SHORT $LN4@z900_trans
$LN2@z900_trans:
  001d1	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001d5	ff c0		 inc	 eax
  001d7	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_trans:
  001db	8b 44 24 34	 mov	 eax, DWORD PTR numwords$[rsp]
  001df	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  001e3	7d 2e		 jge	 SHORT $LN3@z900_trans

; 345  :     {
; 346  :         aste[i] = fetch_fw(aste_main);

  001e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR aste_main$[rsp]
  001ea	e8 00 00 00 00	 call	 fetch_fw_noswap
  001ef	8b c8		 mov	 ecx, eax
  001f1	e8 00 00 00 00	 call	 _byteswap_ulong
  001f6	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR i$[rsp]
  001fb	48 8b 54 24 78	 mov	 rdx, QWORD PTR aste$[rsp]
  00200	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 347  :         aste_main += 4;

  00203	48 8b 44 24 38	 mov	 rax, QWORD PTR aste_main$[rsp]
  00208	48 83 c0 04	 add	 rax, 4
  0020c	48 89 44 24 38	 mov	 QWORD PTR aste_main$[rsp], rax

; 348  :     }

  00211	eb be		 jmp	 SHORT $LN2@z900_trans
$LN3@z900_trans:
$LN5@z900_trans:

; 349  :     /* Clear remaining words if fewer than 16 words were loaded */
; 350  :     while (i < 16) aste[i++] = 0;

  00213	83 7c 24 28 10	 cmp	 DWORD PTR i$[rsp], 16
  00218	7d 1d		 jge	 SHORT $LN6@z900_trans
  0021a	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0021f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR aste$[rsp]
  00224	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0
  0022b	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0022f	ff c0		 inc	 eax
  00231	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  00235	eb dc		 jmp	 SHORT $LN5@z900_trans
$LN6@z900_trans:

; 351  : 
; 352  : 
; 353  :     /* Check the ASX invalid bit in the ASTE */
; 354  :     if (aste[0] & ASTE0_INVALID)

  00237	b8 04 00 00 00	 mov	 eax, 4
  0023c	48 6b c0 00	 imul	 rax, rax, 0
  00240	48 8b 4c 24 78	 mov	 rcx, QWORD PTR aste$[rsp]
  00245	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00248	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0024d	85 c0		 test	 eax, eax
  0024f	74 02		 je	 SHORT $LN12@z900_trans

; 355  :         goto asn_asx_tran_excp;

  00251	eb 40		 jmp	 SHORT $asn_asx_tran_excp$21
$LN12@z900_trans:

; 356  : 
; 357  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 358  :     /* Check the reserved bits in first two words of ASTE */
; 359  :     if ((aste[0] & ASTE0_RESV) || (aste[1] & ASTE1_RESV)
; 360  :         || ((aste[0] & ASTE0_BASE)
; 361  : #ifdef FEATURE_SUBSPACE_GROUP
; 362  :             && !ASF_ENABLED(regs)
; 363  : #endif
; 364  :             ))
; 365  :         goto asn_asn_tran_spec_excp;
; 366  : #endif
; 367  : 
; 368  :     return 0;

  00253	33 c0		 xor	 eax, eax
  00255	eb 5a		 jmp	 SHORT $LN1@z900_trans
$asn_addr_excp$19:

; 369  : 
; 370  : /* Conditions which always cause program check */
; 371  : asn_addr_excp:
; 372  :     code = PGM_ADDRESSING_EXCEPTION;

  00257	c7 44 24 2c 05
	00 00 00	 mov	 DWORD PTR code$[rsp], 5
$asn_prog_check$22:

; 373  :     goto asn_prog_check;
; 374  : 
; 375  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 376  : asn_asn_tran_spec_excp:
; 377  :     code = PGM_ASN_TRANSLATION_SPECIFICATION_EXCEPTION;
; 378  :     goto asn_prog_check;
; 379  : #endif
; 380  : 
; 381  : asn_prog_check:
; 382  :     regs->program_interrupt (regs, code);

  0025f	8b 54 24 2c	 mov	 edx, DWORD PTR code$[rsp]
  00263	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0026d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$asn_afx_tran_excp$20:

; 383  : 
; 384  : /* Conditions which the caller may or may not program check */
; 385  : asn_afx_tran_excp:
; 386  :     regs->TEA = asn;

  00273	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  00278	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0027d	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax

; 387  :     code = PGM_AFX_TRANSLATION_EXCEPTION;

  00284	c7 44 24 2c 20
	00 00 00	 mov	 DWORD PTR code$[rsp], 32 ; 00000020H

; 388  :     return code;

  0028c	0f b7 44 24 2c	 movzx	 eax, WORD PTR code$[rsp]
  00291	eb 1e		 jmp	 SHORT $LN1@z900_trans
$asn_asx_tran_excp$21:

; 389  : 
; 390  : asn_asx_tran_excp:
; 391  :     regs->TEA = asn;

  00293	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  00298	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0029d	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax

; 392  :     code = PGM_ASX_TRANSLATION_EXCEPTION;

  002a4	c7 44 24 2c 21
	00 00 00	 mov	 DWORD PTR code$[rsp], 33 ; 00000021H

; 393  :     return code;

  002ac	0f b7 44 24 2c	 movzx	 eax, WORD PTR code$[rsp]
$LN1@z900_trans:

; 394  : 
; 395  : } /* end function translate_asn */

  002b1	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002b5	c3		 ret	 0
z900_translate_asn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
alo$ = 32
i$ = 36
cb$ = 40
aste_addr$ = 44
mn$ = 48
ald$ = 56
abs$ = 60
all$ = 64
tv81 = 72
tv129 = 80
tv158 = 88
tv199 = 96
ale$ = 104
__$ArrayPad$ = 120
alet$ = 144
eax$ = 152
acctype$ = 160
regs$ = 168
asteo$ = 176
aste$ = 184
z900_translate_alet PROC

; 440  : {

$LN31:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 441  : U32     cb;                             /* DUCT or PASTE address     */
; 442  : U32     ald;                            /* Access-list designation   */
; 443  : U32     alo;                            /* Access-list origin        */
; 444  : U32     all;                            /* Access-list length        */
; 445  : U32     ale[4];                         /* Access-list entry         */
; 446  : U32     aste_addr;                      /* Real address of ASTE      */
; 447  : U32     abs;                            /* Absolute address          */
; 448  : BYTE   *mn;                             /* Mainstor address          */
; 449  : int     i;                              /* Array subscript           */
; 450  : 
; 451  :     regs->dat.protect = 0;

  00029	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00031	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00037	83 e0 f9	 and	 eax, -7			; fffffff9H
  0003a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 452  : 
; 453  :     /* [5.8.4.3] Check the reserved bits in the ALET */
; 454  :     if ( alet & ALET_RESV )

  00048	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR alet$[rsp]
  0004f	25 00 00 00 fe	 and	 eax, -33554432		; fe000000H
  00054	85 c0		 test	 eax, eax
  00056	74 05		 je	 SHORT $LN8@z900_trans

; 455  :         goto alet_spec_excp;

  00058	e9 83 04 00 00	 jmp	 $alet_spec_excp$32
$LN8@z900_trans:

; 456  : 
; 457  :     /* [5.8.4.4] Obtain the effective access-list designation */
; 458  : 
; 459  :     /* Obtain the real address of the control block containing
; 460  :        the effective access-list designation.  This is either
; 461  :        the Primary ASTE or the DUCT */
; 462  :     cb = (alet & ALET_PRI_LIST) ?

  0005d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR alet$[rsp]
  00064	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00069	85 c0		 test	 eax, eax
  0006b	74 26		 je	 SHORT $LN23@z900_trans
  0006d	b8 08 00 00 00	 mov	 eax, 8
  00072	48 6b c0 06	 imul	 rax, rax, 6
  00076	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007e	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00086	48 25 c0 ff ff
	7f		 and	 rax, 2147483584		; 7fffffc0H
  0008c	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
  00091	eb 24		 jmp	 SHORT $LN24@z900_trans
$LN23@z900_trans:
  00093	b8 08 00 00 00	 mov	 eax, 8
  00098	48 6b c0 03	 imul	 rax, rax, 3
  0009c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a4	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000ac	48 25 c0 ff ff
	7f		 and	 rax, 2147483584		; 7fffffc0H
  000b2	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
$LN24@z900_trans:
  000b7	8b 44 24 48	 mov	 eax, DWORD PTR tv81[rsp]
  000bb	89 44 24 28	 mov	 DWORD PTR cb$[rsp], eax

; 463  :             regs->CR(5) & CR5_PASTEO :
; 464  :             regs->CR(2) & CR2_DUCTO;
; 465  : 
; 466  :     /* Addressing exception if outside main storage */
; 467  :     if (cb > regs->mainlim)

  000bf	8b 44 24 28	 mov	 eax, DWORD PTR cb$[rsp]
  000c3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  000d2	76 05		 jbe	 SHORT $LN9@z900_trans

; 468  :         goto alet_addr_excp;

  000d4	e9 cc 03 00 00	 jmp	 $alet_addr_excp$33
$LN9@z900_trans:

; 469  : 
; 470  :     /* Load the effective access-list designation (ALD) from
; 471  :        offset 16 in the control block.  All four bytes must be
; 472  :        fetched concurrently as observed by other CPUs.  Note
; 473  :        that the DUCT and the PASTE cannot cross a page boundary */
; 474  :     cb = APPLY_PREFIXING (cb, regs->PX);

  000d9	8b 44 24 28	 mov	 eax, DWORD PTR cb$[rsp]
  000dd	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  000e3	48 85 c0	 test	 rax, rax
  000e6	74 23		 je	 SHORT $LN25@z900_trans
  000e8	8b 44 24 28	 mov	 eax, DWORD PTR cb$[rsp]
  000ec	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  000f2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  000fe	74 0b		 je	 SHORT $LN25@z900_trans
  00100	8b 44 24 28	 mov	 eax, DWORD PTR cb$[rsp]
  00104	48 89 44 24 50	 mov	 QWORD PTR tv129[rsp], rax
  00109	eb 15		 jmp	 SHORT $LN26@z900_trans
$LN25@z900_trans:
  0010b	8b 44 24 28	 mov	 eax, DWORD PTR cb$[rsp]
  0010f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00117	48 33 41 70	 xor	 rax, QWORD PTR [rcx+112]
  0011b	48 89 44 24 50	 mov	 QWORD PTR tv129[rsp], rax
$LN26@z900_trans:
  00120	8b 44 24 50	 mov	 eax, DWORD PTR tv129[rsp]
  00124	89 44 24 28	 mov	 DWORD PTR cb$[rsp], eax

; 475  :     ald = ARCH_DEP(fetch_fullword_absolute) (cb+16, regs);

  00128	8b 44 24 28	 mov	 eax, DWORD PTR cb$[rsp]
  0012c	83 c0 10	 add	 eax, 16
  0012f	8b c0		 mov	 eax, eax
  00131	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00139	8b c8		 mov	 ecx, eax
  0013b	e8 00 00 00 00	 call	 z900_fetch_fullword_absolute
  00140	89 44 24 38	 mov	 DWORD PTR ald$[rsp], eax

; 476  : 
; 477  :     /* [5.8.4.5] Access-list lookup */
; 478  : 
; 479  :     /* Isolate the access-list origin and access-list length */
; 480  :     alo = ald & ALD_ALO;

  00144	8b 44 24 38	 mov	 eax, DWORD PTR ald$[rsp]
  00148	25 80 ff ff 7f	 and	 eax, 2147483520		; 7fffff80H
  0014d	89 44 24 20	 mov	 DWORD PTR alo$[rsp], eax

; 481  :     all = ald & ALD_ALL;

  00151	8b 44 24 38	 mov	 eax, DWORD PTR ald$[rsp]
  00155	83 e0 7f	 and	 eax, 127		; 0000007fH
  00158	89 44 24 40	 mov	 DWORD PTR all$[rsp], eax

; 482  : 
; 483  :     /* Check that the ALEN does not exceed the ALL */
; 484  :     if (((alet & ALET_ALEN) >> ALD_ALL_SHIFT) > all)

  0015c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR alet$[rsp]
  00163	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00168	c1 e8 03	 shr	 eax, 3
  0016b	3b 44 24 40	 cmp	 eax, DWORD PTR all$[rsp]
  0016f	76 05		 jbe	 SHORT $LN10@z900_trans

; 485  :         goto alen_tran_excp;

  00171	e9 92 03 00 00	 jmp	 $alen_tran_excp$34
$LN10@z900_trans:

; 486  : 
; 487  :     /* Add the ALEN x 16 to the access list origin */
; 488  :     alo += (alet & ALET_ALEN) << 4;

  00176	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR alet$[rsp]
  0017d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00182	c1 e0 04	 shl	 eax, 4
  00185	8b 4c 24 20	 mov	 ecx, DWORD PTR alo$[rsp]
  00189	03 c8		 add	 ecx, eax
  0018b	8b c1		 mov	 eax, ecx
  0018d	89 44 24 20	 mov	 DWORD PTR alo$[rsp], eax

; 489  : 
; 490  :     /* Addressing exception if outside main storage */
; 491  :     if (alo > regs->mainlim)

  00191	8b 44 24 20	 mov	 eax, DWORD PTR alo$[rsp]
  00195	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019d	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  001a4	76 05		 jbe	 SHORT $LN11@z900_trans

; 492  :         goto alet_addr_excp;

  001a6	e9 fa 02 00 00	 jmp	 $alet_addr_excp$33
$LN11@z900_trans:

; 493  : 
; 494  :     /* Fetch the 16-byte access list entry from absolute storage.
; 495  :        Each fullword of the ALE must be fetched concurrently as
; 496  :        observed by other CPUs */
; 497  :     alo = APPLY_PREFIXING (alo, regs->PX);

  001ab	8b 44 24 20	 mov	 eax, DWORD PTR alo$[rsp]
  001af	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  001b5	48 85 c0	 test	 rax, rax
  001b8	74 23		 je	 SHORT $LN27@z900_trans
  001ba	8b 44 24 20	 mov	 eax, DWORD PTR alo$[rsp]
  001be	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  001c4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cc	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  001d0	74 0b		 je	 SHORT $LN27@z900_trans
  001d2	8b 44 24 20	 mov	 eax, DWORD PTR alo$[rsp]
  001d6	48 89 44 24 58	 mov	 QWORD PTR tv158[rsp], rax
  001db	eb 15		 jmp	 SHORT $LN28@z900_trans
$LN27@z900_trans:
  001dd	8b 44 24 20	 mov	 eax, DWORD PTR alo$[rsp]
  001e1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	48 33 41 70	 xor	 rax, QWORD PTR [rcx+112]
  001ed	48 89 44 24 58	 mov	 QWORD PTR tv158[rsp], rax
$LN28@z900_trans:
  001f2	8b 44 24 58	 mov	 eax, DWORD PTR tv158[rsp]
  001f6	89 44 24 20	 mov	 DWORD PTR alo$[rsp], eax

; 498  :     mn = FETCH_MAIN_ABSOLUTE(alo, regs, 16);

  001fa	8b 44 24 20	 mov	 eax, DWORD PTR alo$[rsp]
  001fe	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00206	8b c8		 mov	 ecx, eax
  00208	e8 00 00 00 00	 call	 z900_fetch_main_absolute
  0020d	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 499  :     for (i = 0; i < 4; i++)

  00212	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0021a	eb 0a		 jmp	 SHORT $LN4@z900_trans
$LN2@z900_trans:
  0021c	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00220	ff c0		 inc	 eax
  00222	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_trans:
  00226	83 7c 24 24 04	 cmp	 DWORD PTR i$[rsp], 4
  0022b	7d 2a		 jge	 SHORT $LN3@z900_trans

; 500  :     {
; 501  :         ale[i] = fetch_fw (mn);

  0022d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mn$[rsp]
  00232	e8 00 00 00 00	 call	 fetch_fw_noswap
  00237	8b c8		 mov	 ecx, eax
  00239	e8 00 00 00 00	 call	 _byteswap_ulong
  0023e	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00243	89 44 8c 68	 mov	 DWORD PTR ale$[rsp+rcx*4], eax

; 502  :         mn += 4;

  00247	48 8b 44 24 30	 mov	 rax, QWORD PTR mn$[rsp]
  0024c	48 83 c0 04	 add	 rax, 4
  00250	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 503  :     }

  00255	eb c5		 jmp	 SHORT $LN2@z900_trans
$LN3@z900_trans:

; 504  : 
; 505  :     /* Check the ALEN invalid bit in the ALE */
; 506  :     if (ale[0] & ALE0_INVALID)

  00257	b8 04 00 00 00	 mov	 eax, 4
  0025c	48 6b c0 00	 imul	 rax, rax, 0
  00260	8b 44 04 68	 mov	 eax, DWORD PTR ale$[rsp+rax]
  00264	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00269	85 c0		 test	 eax, eax
  0026b	74 05		 je	 SHORT $LN12@z900_trans

; 507  :         goto alen_tran_excp;

  0026d	e9 96 02 00 00	 jmp	 $alen_tran_excp$34
$LN12@z900_trans:

; 508  : 
; 509  :     /* For ordinary ART (but not for special ART),
; 510  :        compare the ALE sequence number with the ALET */
; 511  :     if (!(acctype & ACC_SPECIAL_ART)
; 512  :         && (ale[0] & ALE0_ALESN) != (alet & ALET_ALESN))

  00272	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00279	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0027e	85 c0		 test	 eax, eax
  00280	75 28		 jne	 SHORT $LN13@z900_trans
  00282	b8 04 00 00 00	 mov	 eax, 4
  00287	48 6b c0 00	 imul	 rax, rax, 0
  0028b	8b 44 04 68	 mov	 eax, DWORD PTR ale$[rsp+rax]
  0028f	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00294	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR alet$[rsp]
  0029b	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  002a1	3b c1		 cmp	 eax, ecx
  002a3	74 05		 je	 SHORT $LN13@z900_trans

; 513  :         goto ale_seq_excp;

  002a5	e9 86 02 00 00	 jmp	 $ale_seq_excp$35
$LN13@z900_trans:

; 514  : 
; 515  :     /* [5.8.4.6] Locate the ASN-second-table entry */
; 516  :     aste_addr = ale[2] & ALE2_ASTE;

  002aa	b8 04 00 00 00	 mov	 eax, 4
  002af	48 6b c0 02	 imul	 rax, rax, 2
  002b3	8b 44 04 68	 mov	 eax, DWORD PTR ale$[rsp+rax]
  002b7	25 c0 ff ff 7f	 and	 eax, 2147483584		; 7fffffc0H
  002bc	89 44 24 2c	 mov	 DWORD PTR aste_addr$[rsp], eax

; 517  : 
; 518  :     /* Addressing exception if ASTE is outside main storage */
; 519  :     abs = APPLY_PREFIXING (aste_addr, regs->PX);

  002c0	8b 44 24 2c	 mov	 eax, DWORD PTR aste_addr$[rsp]
  002c4	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  002ca	48 85 c0	 test	 rax, rax
  002cd	74 23		 je	 SHORT $LN29@z900_trans
  002cf	8b 44 24 2c	 mov	 eax, DWORD PTR aste_addr$[rsp]
  002d3	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  002d9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e1	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  002e5	74 0b		 je	 SHORT $LN29@z900_trans
  002e7	8b 44 24 2c	 mov	 eax, DWORD PTR aste_addr$[rsp]
  002eb	48 89 44 24 60	 mov	 QWORD PTR tv199[rsp], rax
  002f0	eb 15		 jmp	 SHORT $LN30@z900_trans
$LN29@z900_trans:
  002f2	8b 44 24 2c	 mov	 eax, DWORD PTR aste_addr$[rsp]
  002f6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fe	48 33 41 70	 xor	 rax, QWORD PTR [rcx+112]
  00302	48 89 44 24 60	 mov	 QWORD PTR tv199[rsp], rax
$LN30@z900_trans:
  00307	8b 44 24 60	 mov	 eax, DWORD PTR tv199[rsp]
  0030b	89 44 24 3c	 mov	 DWORD PTR abs$[rsp], eax

; 520  :     if (abs > regs->mainlim)

  0030f	8b 44 24 3c	 mov	 eax, DWORD PTR abs$[rsp]
  00313	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031b	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  00322	76 05		 jbe	 SHORT $LN14@z900_trans

; 521  :         goto alet_addr_excp;

  00324	e9 7c 01 00 00	 jmp	 $alet_addr_excp$33
$LN14@z900_trans:

; 522  :     mn = FETCH_MAIN_ABSOLUTE(abs, regs, 64);

  00329	8b 44 24 3c	 mov	 eax, DWORD PTR abs$[rsp]
  0032d	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00335	8b c8		 mov	 ecx, eax
  00337	e8 00 00 00 00	 call	 z900_fetch_main_absolute
  0033c	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 523  : 
; 524  :     /* Fetch the 64-byte ASN second table entry from real storage.
; 525  :        Each fullword of the ASTE must be fetched concurrently as
; 526  :        observed by other CPUs.  ASTE cannot cross a page boundary */
; 527  :     for (i = 0; i < 16; i++)

  00341	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00349	eb 0a		 jmp	 SHORT $LN7@z900_trans
$LN5@z900_trans:
  0034b	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0034f	ff c0		 inc	 eax
  00351	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_trans:
  00355	83 7c 24 24 10	 cmp	 DWORD PTR i$[rsp], 16
  0035a	7d 31		 jge	 SHORT $LN6@z900_trans

; 528  :     {
; 529  :         aste[i] = fetch_fw(mn);

  0035c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mn$[rsp]
  00361	e8 00 00 00 00	 call	 fetch_fw_noswap
  00366	8b c8		 mov	 ecx, eax
  00368	e8 00 00 00 00	 call	 _byteswap_ulong
  0036d	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00372	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR aste$[rsp]
  0037a	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 530  :         mn += 4;

  0037d	48 8b 44 24 30	 mov	 rax, QWORD PTR mn$[rsp]
  00382	48 83 c0 04	 add	 rax, 4
  00386	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 531  :     }

  0038b	eb be		 jmp	 SHORT $LN5@z900_trans
$LN6@z900_trans:

; 532  : 
; 533  :     /* Check the ASX invalid bit in the ASTE */
; 534  :     if (aste[0] & ASTE0_INVALID)

  0038d	b8 04 00 00 00	 mov	 eax, 4
  00392	48 6b c0 00	 imul	 rax, rax, 0
  00396	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR aste$[rsp]
  0039e	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  003a1	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003a6	85 c0		 test	 eax, eax
  003a8	74 05		 je	 SHORT $LN15@z900_trans

; 535  :         goto aste_vald_excp;

  003aa	e9 a6 01 00 00	 jmp	 $aste_vald_excp$36
$LN15@z900_trans:

; 536  : 
; 537  :     /* Compare the ASTE sequence number with the ALE */
; 538  :     if ((aste[5] & ASTE5_ASTESN) != (ale[3] & ALE3_ASTESN))

  003af	b8 04 00 00 00	 mov	 eax, 4
  003b4	48 6b c0 05	 imul	 rax, rax, 5
  003b8	b9 04 00 00 00	 mov	 ecx, 4
  003bd	48 6b c9 03	 imul	 rcx, rcx, 3
  003c1	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR aste$[rsp]
  003c9	8b 4c 0c 68	 mov	 ecx, DWORD PTR ale$[rsp+rcx]
  003cd	39 0c 02	 cmp	 DWORD PTR [rdx+rax], ecx
  003d0	74 05		 je	 SHORT $LN16@z900_trans

; 539  :         goto aste_seq_excp;

  003d2	e9 a3 01 00 00	 jmp	 $aste_seq_excp$37
$LN16@z900_trans:

; 540  : 
; 541  :     /* [5.8.4.7] For ordinary ART (but not for special ART),
; 542  :        authorize the use of the access-list entry */
; 543  :     if (!(acctype & ACC_SPECIAL_ART))

  003d7	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  003de	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  003e3	85 c0		 test	 eax, eax
  003e5	75 63		 jne	 SHORT $LN17@z900_trans

; 544  :     {
; 545  :         /* If ALE private bit is zero, or the ALE AX equals the
; 546  :            EAX, then authorization succeeds.  Otherwise perform
; 547  :            the extended authorization process. */
; 548  :         if ((ale[0] & ALE0_PRIVATE)
; 549  :                 && (ale[0] & ALE0_ALEAX) != eax)

  003e7	b8 04 00 00 00	 mov	 eax, 4
  003ec	48 6b c0 00	 imul	 rax, rax, 0
  003f0	8b 44 04 68	 mov	 eax, DWORD PTR ale$[rsp+rax]
  003f4	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  003f9	85 c0		 test	 eax, eax
  003fb	74 4d		 je	 SHORT $LN18@z900_trans
  003fd	b8 04 00 00 00	 mov	 eax, 4
  00402	48 6b c0 00	 imul	 rax, rax, 0
  00406	8b 44 04 68	 mov	 eax, DWORD PTR ale$[rsp+rax]
  0040a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0040f	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR eax$[rsp]
  00417	3b c1		 cmp	 eax, ecx
  00419	74 2f		 je	 SHORT $LN18@z900_trans

; 550  :         {
; 551  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 552  :             /* Check the reserved bits in first two words of ASTE */
; 553  :             if ((aste[0] & ASTE0_RESV) || (aste[1] & ASTE1_RESV)
; 554  :                 || ((aste[0] & ASTE0_BASE)
; 555  : #ifdef FEATURE_SUBSPACE_GROUP
; 556  :                         && !ASF_ENABLED(regs)
; 557  : #endif
; 558  :                    ))
; 559  :                 goto alet_asn_tran_spec_excp;
; 560  : #endif
; 561  : 
; 562  :             /* Perform extended authorization */
; 563  :             if (ARCH_DEP(authorize_asn)(eax, aste, ATE_SECONDARY, regs) != 0)

  0041b	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00423	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00429	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR aste$[rsp]
  00431	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR eax$[rsp]
  00439	e8 00 00 00 00	 call	 z900_authorize_asn
  0043e	0f b6 c0	 movzx	 eax, al
  00441	85 c0		 test	 eax, eax
  00443	74 05		 je	 SHORT $LN19@z900_trans

; 564  :                 goto ext_auth_excp;

  00445	e9 55 01 00 00	 jmp	 $ext_auth_excp$38
$LN19@z900_trans:
$LN18@z900_trans:
$LN17@z900_trans:

; 565  :         }
; 566  : 
; 567  :     } /* end if(!ACC_SPECIAL_ART) */
; 568  : 
; 569  :     /* [5.8.4.8] Check for access-list controlled protection */
; 570  :     if (ale[0] & ALE0_FETCHONLY)

  0044a	b8 04 00 00 00	 mov	 eax, 4
  0044f	48 6b c0 00	 imul	 rax, rax, 0
  00453	8b 44 04 68	 mov	 eax, DWORD PTR ale$[rsp+rax]
  00457	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0045c	85 c0		 test	 eax, eax
  0045e	74 30		 je	 SHORT $LN20@z900_trans

; 571  :     {
; 572  :         if (acctype & (ACC_WRITE|ACC_CHECK))

  00460	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00467	83 e0 03	 and	 eax, 3
  0046a	85 c0		 test	 eax, eax
  0046c	74 22		 je	 SHORT $LN21@z900_trans

; 573  :             regs->dat.protect = 2;

  0046e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00476	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0047c	83 e0 f9	 and	 eax, -7			; fffffff9H
  0047f	83 c8 04	 or	 eax, 4
  00482	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0048a	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN21@z900_trans:
$LN20@z900_trans:

; 574  :     }
; 575  : 
; 576  :     /* Return the ASTE origin address */
; 577  :     *asteo = aste_addr;

  00490	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR asteo$[rsp]
  00498	8b 4c 24 2c	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  0049c	89 08		 mov	 DWORD PTR [rax], ecx

; 578  :     return 0;

  0049e	33 c0		 xor	 eax, eax
  004a0	e9 1d 01 00 00	 jmp	 $LN1@z900_trans
$alet_addr_excp$33:

; 579  : 
; 580  : /* Conditions which always cause program check, except
; 581  :    when performing translation for the control panel */
; 582  : alet_addr_excp:
; 583  :     regs->dat.xcode = PGM_ADDRESSING_EXCEPTION;

  004a5	b8 05 00 00 00	 mov	 eax, 5
  004aa	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b2	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax
$alet_prog_check$39:

; 584  :     goto alet_prog_check;
; 585  : 
; 586  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 587  : alet_asn_tran_spec_excp:
; 588  :     regs->dat.xcode = PGM_ASN_TRANSLATION_SPECIFICATION_EXCEPTION;
; 589  :     goto alet_prog_check;
; 590  : #endif
; 591  : 
; 592  : alet_prog_check:
; 593  :     regs->program_interrupt (regs, regs->dat.xcode);

  004b9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c1	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  004c8	8b d0		 mov	 edx, eax
  004ca	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d2	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004da	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$alet_spec_excp$32:

; 594  : 
; 595  : /* Conditions which the caller may or may not program check */
; 596  : alet_spec_excp:
; 597  :     regs->dat.xcode = PGM_ALET_SPECIFICATION_EXCEPTION;

  004e0	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  004e5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ed	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 598  :     return regs->dat.xcode;

  004f4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004fc	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00503	e9 ba 00 00 00	 jmp	 $LN1@z900_trans
$alen_tran_excp$34:

; 599  : 
; 600  : alen_tran_excp:
; 601  :     regs->dat.xcode = PGM_ALEN_TRANSLATION_EXCEPTION;

  00508	b8 29 00 00 00	 mov	 eax, 41			; 00000029H
  0050d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00515	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 602  :     return regs->dat.xcode;

  0051c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00524	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  0052b	e9 92 00 00 00	 jmp	 $LN1@z900_trans
$ale_seq_excp$35:

; 603  : 
; 604  : ale_seq_excp:
; 605  :     regs->dat.xcode = PGM_ALE_SEQUENCE_EXCEPTION;

  00530	b8 2a 00 00 00	 mov	 eax, 42			; 0000002aH
  00535	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0053d	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 606  :     return regs->dat.xcode;

  00544	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0054c	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00553	eb 6d		 jmp	 SHORT $LN1@z900_trans
$aste_vald_excp$36:

; 607  : 
; 608  : aste_vald_excp:
; 609  :     regs->dat.xcode = PGM_ASTE_VALIDITY_EXCEPTION;

  00555	b8 2b 00 00 00	 mov	 eax, 43			; 0000002bH
  0055a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00562	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 610  :     return regs->dat.xcode;

  00569	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00571	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00578	eb 48		 jmp	 SHORT $LN1@z900_trans
$aste_seq_excp$37:

; 611  : 
; 612  : aste_seq_excp:
; 613  :     regs->dat.xcode = PGM_ASTE_SEQUENCE_EXCEPTION;

  0057a	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  0057f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00587	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 614  :     return regs->dat.xcode;

  0058e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00596	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  0059d	eb 23		 jmp	 SHORT $LN1@z900_trans
$ext_auth_excp$38:

; 615  : 
; 616  : ext_auth_excp:
; 617  :     regs->dat.xcode = PGM_EXTENDED_AUTHORITY_EXCEPTION;

  0059f	b8 2d 00 00 00	 mov	 eax, 45			; 0000002dH
  005a4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ac	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 618  :     return regs->dat.xcode;

  005b3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005bb	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
$LN1@z900_trans:

; 619  : 
; 620  : } /* end function translate_alet */

  005c2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005c7	48 33 cc	 xor	 rcx, rsp
  005ca	e8 00 00 00 00	 call	 __security_check_cookie
  005cf	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  005d6	c3		 ret	 0
z900_translate_alet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv86 = 32
pte$ = 40
raddr$ = 48
pfra$ = 56
ibyte$ = 80
pto$ = 88
vaddr$ = 96
regs$ = 104
local$ = 112
z900_invalidate_pte PROC

; 2147 : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900_inval:

; 2148 : RADR    raddr;                          /* Addr of Page Table Entry  */
; 2149 : RADR    pte;                            /* Page Table Entry itself   */
; 2150 : RADR    pfra;                           /* Page Frame Real Address   */
; 2151 : 
; 2152 :     UNREFERENCED_370( ibyte );

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@z900_inval

; 2153 : 
; 2154 : #if !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 2155 :     {
; 2156 :         // SYSTEM/370...
; 2157 : 
; 2158 :         /* Program check if translation format is invalid */
; 2159 :         if (0
; 2160 :             || (((regs->CR(0) & CR0_PAGE_SIZE) != CR0_PAGE_SZ_2K) && ((regs->CR(0) & CR0_PAGE_SIZE) != CR0_PAGE_SZ_4K))
; 2161 :             || (((regs->CR(0) & CR0_SEG_SIZE)  != CR0_SEG_SZ_64K) && ((regs->CR(0) & CR0_SEG_SIZE)  != CR0_SEG_SZ_1M))
; 2162 :         )
; 2163 :             regs->program_interrupt( regs, PGM_TRANSLATION_SPECIFICATION_EXCEPTION );
; 2164 : 
; 2165 :         /* Add the vaddr's page table entry index to the Page Table
; 2166 :            Origin, ignoring any carry, to form the 24-bit real address
; 2167 :            of the Page Table Entry to be invalidated, taking into account
; 2168 :            that each Page Table Entry is 2 bytes wide (shift 1 less bit)
; 2169 :         */
; 2170 :         raddr = (pto & SEGTAB_370_PTO) +
; 2171 :         (
; 2172 :             ((regs->CR(0)  & CR0_SEG_SIZE)  == CR0_SEG_SZ_1M)
; 2173 :             ?
; 2174 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 2175 :             ((vaddr & 0x000FF000) >> (SHIFT_4K-1)) : ((vaddr & 0x000FF800) >> (SHIFT_2K-1)))
; 2176 :             :
; 2177 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 2178 :             ((vaddr & 0x0000F000) >> (SHIFT_4K-1)) : ((vaddr & 0x0000F800) >> (SHIFT_2K-1)))
; 2179 :         );
; 2180 :         raddr &= MAXADDRESS;
; 2181 : 
; 2182 :         /* Fetch the Page Table Entry from real storage,
; 2183 :            subject to normal storage protection mechanisms
; 2184 :         */
; 2185 :         pte = ARCH_DEP( vfetch2 )( raddr, USE_REAL_ADDR, regs );
; 2186 : 
; 2187 : #if 0 // debug 370 IPTE
; 2188 :         LOGMSG
; 2189 :         (
; 2190 :             "dat.c: IPTE issued for entry %4.4X at %8.8X...\n"
; 2191 :             "       pto %8.8X, vaddr %8.8X, cr0 %8.8X\n"
; 2192 : 
; 2193 :             , pte, raddr
; 2194 :             , pto, vaddr, regs->CR(0)
; 2195 :         );
; 2196 : #endif
; 2197 : 
; 2198 :         /* Set the invalid bit in the Page Table Entry just fetched */
; 2199 :         pte |= ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_2K)
; 2200 :                ? PAGETAB_INV_2K : PAGETAB_INV_4K;
; 2201 : 
; 2202 :         /* Store the now invalidated Page Table Entry back into
; 2203 :            real storage where we originally got it from, subject
; 2204 :            to the same storage protection mechanisms
; 2205 :         */
; 2206 :         ARCH_DEP( vstore2 )( pte, raddr, USE_REAL_ADDR, regs );
; 2207 : 
; 2208 :         /* Extract the Page Frame Address from the Page Table Entry */
; 2209 :         pfra = ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K)
; 2210 :             ?
; 2211 : #if defined( FEATURE_S370E_EXTENDED_ADDRESSING )
; 2212 :             (((U32)pte & PAGETAB_EA_4K) << 23) |
; 2213 : #endif
; 2214 :             (((U32)pte & PAGETAB_PFRA_4K) << 8)
; 2215 :             :
; 2216 :             (((U32)pte & PAGETAB_PFRA_2K) << 8);
; 2217 :     }
; 2218 : #elif defined( FEATURE_S390_DAT )
; 2219 :     {
; 2220 :         // SYSTEM/390...
; 2221 : 
; 2222 :         /* Program check if translation format is invalid */
; 2223 :         if ((regs->CR(0) & CR0_TRAN_FMT) != CR0_TRAN_ESA390)
; 2224 :             regs->program_interrupt( regs, PGM_TRANSLATION_SPECIFICATION_EXCEPTION );
; 2225 : 
; 2226 :         /* Add the vaddr's page table entry index to the Page Table
; 2227 :            Origin, ignoring any carry, to form the 31-bit real address
; 2228 :            of the Page Table Entry to be invalidated, taking into account
; 2229 :            that each Page Table Entry is 4 bytes wide (shift 2 fewer bits)
; 2230 :         */
; 2231 :         raddr = (pto & SEGTAB_PTO) + ((vaddr & 0x000FF000) >> (PAGEFRAME_PAGESHIFT-2));
; 2232 :         raddr &= MAXADDRESS;
; 2233 : 
; 2234 :         /* Fetch the Page Table Entry from real storage,
; 2235 :            subject to normal storage protection mechanisms */
; 2236 :         pte = ARCH_DEP( vfetch4 )( raddr, USE_REAL_ADDR, regs );
; 2237 : 
; 2238 :         /* Set the invalid bit in the Page Table Entry just fetched */
; 2239 : #if defined( FEATURE_MOVE_PAGE_FACILITY_2 ) && defined( FEATURE_EXPANDED_STORAGE )
; 2240 :         if (ibyte == 0x59) // (IESBE instruction?)
; 2241 :             pte &= ~PAGETAB_ESVALID;
; 2242 :         else
; 2243 : #endif
; 2244 :             pte |= PAGETAB_INVALID; // (no, IPTE instruction)
; 2245 : 
; 2246 :         /* Store the now invalidated Page Table Entry back into
; 2247 :            real storage where we originally got it from, subject
; 2248 :            to the same storage protection mechanisms
; 2249 :         */
; 2250 :         ARCH_DEP( vstore4 )( pte, raddr, USE_REAL_ADDR, regs );
; 2251 : 
; 2252 :         /* Extract the Page Frame Address from the Page Table Entry */
; 2253 :         pfra = pte & PAGETAB_PFRA;
; 2254 :     }
; 2255 : #else /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 2256 :     {
; 2257 :         // ESAME = z/Architecture...
; 2258 : 
; 2259 :         /* Add the vaddr's page table entry index to the Page Table
; 2260 :            Origin, ignoring any carry, to form the 64-bit real address
; 2261 :            of the Page Table Entry to be invalidated, taking into account
; 2262 :            that each Page Table Entry is 8 bytes wide (shift 3 fewer bits)
; 2263 :         */
; 2264 :         raddr = (pto & ZSEGTAB_PTO) + ((vaddr & 0x000FF000) >> (PAGEFRAME_PAGESHIFT-3));

  0001d	48 8b 44 24 58	 mov	 rax, QWORD PTR pto$[rsp]
  00022	48 25 00 f8 ff
	ff		 and	 rax, -2048		; fffffffffffff800H
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR vaddr$[rsp]
  0002d	48 81 e1 00 f0
	0f 00		 and	 rcx, 1044480		; 000ff000H
  00034	48 c1 e9 09	 shr	 rcx, 9
  00038	48 03 c1	 add	 rax, rcx
  0003b	48 89 44 24 30	 mov	 QWORD PTR raddr$[rsp], rax

; 2265 :         raddr &= MAXADDRESS;

  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR raddr$[rsp]
  00045	48 89 44 24 30	 mov	 QWORD PTR raddr$[rsp], rax

; 2266 : 
; 2267 :         /* Fetch the Page Table Entry from real storage,
; 2268 :            subject to normal storage protection mechanisms
; 2269 :         */
; 2270 :         pte = ARCH_DEP( vfetch8 )( raddr, USE_REAL_ADDR, regs );

  0004a	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0004f	ba fe ff ff ff	 mov	 edx, -2
  00054	48 8b 4c 24 30	 mov	 rcx, QWORD PTR raddr$[rsp]
  00059	e8 00 00 00 00	 call	 z900_vfetch8
  0005e	48 89 44 24 28	 mov	 QWORD PTR pte$[rsp], rax

; 2271 : 
; 2272 :         /* Set the invalid bit in the Page Table Entry just fetched */
; 2273 : #if defined( FEATURE_MOVE_PAGE_FACILITY_2 ) && defined( FEATURE_EXPANDED_STORAGE )
; 2274 :         if (ibyte == 0x59) // (IESBE instruction?)

  00063	0f b6 44 24 50	 movzx	 eax, BYTE PTR ibyte$[rsp]
  00068	83 f8 59	 cmp	 eax, 89			; 00000059H
  0006b	75 11		 jne	 SHORT $LN5@z900_inval

; 2275 :             pte &= ~ZPGETAB_ESVALID;

  0006d	48 8b 44 24 28	 mov	 rax, QWORD PTR pte$[rsp]
  00072	48 0f ba f0 08	 btr	 rax, 8
  00077	48 89 44 24 28	 mov	 QWORD PTR pte$[rsp], rax
  0007c	eb 0f		 jmp	 SHORT $LN6@z900_inval
$LN5@z900_inval:

; 2276 :         else
; 2277 : #endif
; 2278 :             pte |= ZPGETAB_I; // (no, IPTE instruction)

  0007e	48 8b 44 24 28	 mov	 rax, QWORD PTR pte$[rsp]
  00083	48 0f ba e8 0a	 bts	 rax, 10
  00088	48 89 44 24 28	 mov	 QWORD PTR pte$[rsp], rax
$LN6@z900_inval:

; 2279 : 
; 2280 :         /* Store the now invalidated Page Table Entry back into
; 2281 :            real storage where we originally got it from, subject
; 2282 :            to the same storage protection mechanisms
; 2283 :         */
; 2284 :         ARCH_DEP( vstore8 )( pte, raddr, USE_REAL_ADDR, regs );

  0008d	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00092	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  00098	48 8b 54 24 30	 mov	 rdx, QWORD PTR raddr$[rsp]
  0009d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pte$[rsp]
  000a2	e8 00 00 00 00	 call	 z900_vstore8

; 2285 : 
; 2286 :         /* Extract the Page Frame Address from the Page Table Entry */
; 2287 :         pfra = pte & ZPGETAB_PFRA;

  000a7	48 8b 44 24 28	 mov	 rax, QWORD PTR pte$[rsp]
  000ac	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000b2	48 89 44 24 38	 mov	 QWORD PTR pfra$[rsp], rax

; 2288 :     }
; 2289 : #endif /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 2290 : 
; 2291 :     /* Invalidate all TLB entries for this Page Frame Real Address */
; 2292 :     ARCH_DEP( purge_tlbe_all )( regs, pfra, local ? regs->cpuad : 0xFFFF );

  000b7	0f b6 44 24 70	 movzx	 eax, BYTE PTR local$[rsp]
  000bc	85 c0		 test	 eax, eax
  000be	74 12		 je	 SHORT $LN8@z900_inval
  000c0	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000cc	89 44 24 20	 mov	 DWORD PTR tv86[rsp], eax
  000d0	eb 08		 jmp	 SHORT $LN9@z900_inval
$LN8@z900_inval:
  000d2	c7 44 24 20 ff
	ff 00 00	 mov	 DWORD PTR tv86[rsp], 65535 ; 0000ffffH
$LN9@z900_inval:
  000da	44 0f b7 44 24
	20		 movzx	 r8d, WORD PTR tv86[rsp]
  000e0	48 8b 54 24 38	 mov	 rdx, QWORD PTR pfra$[rsp]
  000e5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000ea	e8 00 00 00 00	 call	 z900_purge_tlbe_all

; 2293 : 
; 2294 : } /* end function invalidate_pte */

  000ef	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f3	c3		 ret	 0
z900_invalidate_pte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv74 = 32
tv94 = 36
p$1 = 40
p$2 = 48
regs$ = 80
mask$ = 88
z900_invalidate_tlb PROC

; 1995 : {

$LN24:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1996 :     /* Do it for the current architecture first */
; 1997 :     ARCH_DEP( do_invalidate_tlb )( regs, mask );

  0000d	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  00012	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_do_invalidate_tlb

; 1998 : 
; 1999 : #if defined( _FEATURE_SIE )
; 2000 :     /* Also invalidate the GUEST registers in the SIE copy */
; 2001 :     if (regs->host && GUESTREGS)

  0001c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00021	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00027	c1 e8 07	 shr	 eax, 7
  0002a	83 e0 01	 and	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 a1 00 00
	00		 je	 $LN12@z900_inval
  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0003a	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00042	0f 84 8e 00 00
	00		 je	 $LN12@z900_inval

; 2002 :     {
; 2003 :         switch (GUESTREGS->arch_mode)

  00048	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0004d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00054	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00057	89 44 24 20	 mov	 DWORD PTR tv74[rsp], eax
  0005b	83 7c 24 20 00	 cmp	 DWORD PTR tv74[rsp], 0
  00060	74 10		 je	 SHORT $LN14@z900_inval
  00062	83 7c 24 20 01	 cmp	 DWORD PTR tv74[rsp], 1
  00067	74 21		 je	 SHORT $LN15@z900_inval
  00069	83 7c 24 20 02	 cmp	 DWORD PTR tv74[rsp], 2
  0006e	74 32		 je	 SHORT $LN16@z900_inval
  00070	eb 48		 jmp	 SHORT $LN17@z900_inval
$LN14@z900_inval:

; 2004 :         {
; 2005 :         case ARCH_370_IDX: s370_do_invalidate_tlb( GUESTREGS, mask ); break;

  00072	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  00077	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00083	e8 00 00 00 00	 call	 s370_do_invalidate_tlb
  00088	eb 47		 jmp	 SHORT $LN2@z900_inval
$LN15@z900_inval:

; 2006 :         case ARCH_390_IDX: s390_do_invalidate_tlb( GUESTREGS, mask ); break;

  0008a	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  0008f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00094	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0009b	e8 00 00 00 00	 call	 s390_do_invalidate_tlb
  000a0	eb 2f		 jmp	 SHORT $LN2@z900_inval
$LN16@z900_inval:

; 2007 :         case ARCH_900_IDX: z900_do_invalidate_tlb( GUESTREGS, mask ); break;

  000a2	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  000a7	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  000b3	e8 00 00 00 00	 call	 z900_do_invalidate_tlb
  000b8	eb 17		 jmp	 SHORT $LN2@z900_inval
$LN17@z900_inval:
$LN6@z900_inval:

; 2008 :         default: CRASH();

  000ba	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000c8	c6 00 00	 mov	 BYTE PTR [rax], 0
  000cb	33 c0		 xor	 eax, eax
  000cd	85 c0		 test	 eax, eax
  000cf	75 e9		 jne	 SHORT $LN6@z900_inval
$LN2@z900_inval:

; 2009 :         }
; 2010 :     }

  000d1	e9 a2 00 00 00	 jmp	 $LN13@z900_inval
$LN12@z900_inval:

; 2011 :     else if (regs->guest)  /* For guests, also clear HOST entries */

  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000db	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000e1	c1 e8 08	 shr	 eax, 8
  000e4	83 e0 01	 and	 eax, 1
  000e7	85 c0		 test	 eax, eax
  000e9	0f 84 89 00 00
	00		 je	 $LN18@z900_inval

; 2012 :     {
; 2013 :         switch (HOSTREGS->arch_mode)

  000ef	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000fb	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  000fe	89 44 24 24	 mov	 DWORD PTR tv94[rsp], eax
  00102	83 7c 24 24 00	 cmp	 DWORD PTR tv94[rsp], 0
  00107	74 10		 je	 SHORT $LN19@z900_inval
  00109	83 7c 24 24 01	 cmp	 DWORD PTR tv94[rsp], 1
  0010e	74 21		 je	 SHORT $LN20@z900_inval
  00110	83 7c 24 24 02	 cmp	 DWORD PTR tv94[rsp], 2
  00115	74 32		 je	 SHORT $LN21@z900_inval
  00117	eb 48		 jmp	 SHORT $LN22@z900_inval
$LN19@z900_inval:

; 2014 :         {
; 2015 :         case ARCH_370_IDX: s370_do_invalidate_tlb( HOSTREGS, mask ); break;

  00119	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  0011e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00123	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0012a	e8 00 00 00 00	 call	 s370_do_invalidate_tlb
  0012f	eb 47		 jmp	 SHORT $LN7@z900_inval
$LN20@z900_inval:

; 2016 :         case ARCH_390_IDX: s390_do_invalidate_tlb( HOSTREGS, mask ); break;

  00131	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  00136	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00142	e8 00 00 00 00	 call	 s390_do_invalidate_tlb
  00147	eb 2f		 jmp	 SHORT $LN7@z900_inval
$LN21@z900_inval:

; 2017 :         case ARCH_900_IDX: z900_do_invalidate_tlb( HOSTREGS, mask ); break;

  00149	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  0014e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00153	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0015a	e8 00 00 00 00	 call	 z900_do_invalidate_tlb
  0015f	eb 17		 jmp	 SHORT $LN7@z900_inval
$LN22@z900_inval:
$LN11@z900_inval:

; 2018 :         default: CRASH();

  00161	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  0016a	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  0016f	c6 00 00	 mov	 BYTE PTR [rax], 0
  00172	33 c0		 xor	 eax, eax
  00174	85 c0		 test	 eax, eax
  00176	75 e9		 jne	 SHORT $LN11@z900_inval
$LN7@z900_inval:
$LN18@z900_inval:
$LN13@z900_inval:

; 2019 :         }
; 2020 :     }
; 2021 : #endif /* defined( _FEATURE_SIE ) */
; 2022 : } /* end function invalidate_tlb */

  00178	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017c	c3		 ret	 0
z900_invalidate_tlb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_fetch_fullword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
z900_fetch_fullword_absolute PROC			; COMDAT

; 835  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 836  :     return fetch_fw( FETCH_MAIN_ABSOLUTE( addr, regs, 4 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 z900_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_fw_noswap
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 _byteswap_ulong

; 837  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
z900_fetch_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_fetch_doubleword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
z900_fetch_doubleword_absolute PROC			; COMDAT

; 815  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 816  :     // The change below affects 32 bit hosts that use something like
; 817  :     // cmpxchg8b to fetch the doubleword concurrently.
; 818  :     // This routine is mainly called by DAT in 64 bit guest mode
; 819  :     // to access DAT-related values.  In most `well-behaved' OS's,
; 820  :     // other CPUs should not be interfering with these values
; 821  : 
; 822  :     return fetch_dw( FETCH_MAIN_ABSOLUTE( addr, regs, 8 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 z900_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_dw_noswap
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 _byteswap_uint64

; 823  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
z900_fetch_doubleword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_fetch_main_absolute
_TEXT	SEGMENT
addr$ = 64
regs$ = 72
z900_fetch_main_absolute PROC				; COMDAT

; 524  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900_fetch:

; 525  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 526  :     if (addr > (regs->mainlim - len))
; 527  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 528  : #endif
; 529  : 
; 530  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 531  :        is treated as a no-operation if SIE_MODE not active */
; 532  :     SIE_TRANSLATE( &addr, ACCTYPE_READ, regs );

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00019	d1 e8		 shr	 eax, 1
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 6b		 je	 SHORT $LN5@z900_fetch
  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0002d	c1 e8 02	 shr	 eax, 2
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	75 56		 jne	 SHORT $LN5@z900_fetch
  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0003c	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00043	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]
  00048	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00051	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00056	41 b9 04 00 00
	00		 mov	 r9d, 4
  0005c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00068	ba fd ff ff ff	 mov	 edx, -3
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 z900_logical_to_main_l
  00075	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00081	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  00088	48 89 44 24 40	 mov	 QWORD PTR addr$[rsp], rax
$LN5@z900_fetch:
  0008d	33 c0		 xor	 eax, eax
  0008f	85 c0		 test	 eax, eax
  00091	0f 85 77 ff ff
	ff		 jne	 $LN4@z900_fetch

; 533  : 
; 534  :     /* Set the main storage reference bit */
; 535  :     ARCH_DEP( or_storage_key )( addr, STORKEY_REF );

  00097	b2 04		 mov	 dl, 4
  00099	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr$[rsp]
  0009e	e8 00 00 00 00	 call	 z900_or_storage_key

; 536  : 
; 537  :     /* Return absolute storage mainstor address */
; 538  :     return (regs->mainstor + addr);

  000a3	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000af	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]

; 539  : 
; 540  : } /* end function fetch_main_absolute */

  000b4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b8	c3		 ret	 0
z900_fetch_main_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_store_protected
_TEXT	SEGMENT
addr$ = 48
skey$ = 56
akey$ = 64
regs$ = 72
z900_is_store_protected PROC				; COMDAT

; 469  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 470  :     /* [3.4.4] Low-address protection prohibits stores into certain
; 471  :        locations in the prefixed storage area of non-private address
; 472  :        address spaces, if the low-address control bit in CR0 is set,
; 473  :        regardless of the access key and storage key */
; 474  :     if (ARCH_DEP( is_low_address_protected )( addr, regs ))

  00017	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00021	e8 00 00 00 00	 call	 z900_is_low_address_protected
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	74 07		 je	 SHORT $LN2@z900_is_st

; 475  :         return true;

  0002d	b0 01		 mov	 al, 1
  0002f	e9 b2 00 00 00	 jmp	 $LN1@z900_is_st
$LN2@z900_is_st:

; 476  : 
; 477  :     /* Access-list controlled protection prohibits all stores into
; 478  :        the address space, and page protection prohibits all stores
; 479  :        into the page, regardless of the access key and storage key */
; 480  :     if (regs->dat.protect)

  00034	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00039	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0003f	d1 e8		 shr	 eax, 1
  00041	83 e0 03	 and	 eax, 3
  00044	85 c0		 test	 eax, eax
  00046	74 07		 je	 SHORT $LN3@z900_is_st

; 481  :         return true;

  00048	b0 01		 mov	 al, 1
  0004a	e9 97 00 00 00	 jmp	 $LN1@z900_is_st
$LN3@z900_is_st:

; 482  : 
; 483  : #if defined( _FEATURE_SIE )
; 484  :     if (SIE_MODE( regs ) && HOSTREGS->dat.protect)

  0004f	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00054	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0005a	d1 e8		 shr	 eax, 1
  0005c	83 e0 01	 and	 eax, 1
  0005f	85 c0		 test	 eax, eax
  00061	74 1f		 je	 SHORT $LN4@z900_is_st
  00063	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00068	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0006f	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00075	d1 e8		 shr	 eax, 1
  00077	83 e0 03	 and	 eax, 3
  0007a	85 c0		 test	 eax, eax
  0007c	74 04		 je	 SHORT $LN4@z900_is_st

; 485  :         return true;

  0007e	b0 01		 mov	 al, 1
  00080	eb 64		 jmp	 SHORT $LN1@z900_is_st
$LN4@z900_is_st:

; 486  : #endif
; 487  : 
; 488  :     /* [3.4.1] Store is allowed if access key is zero, regardless
; 489  :        of the storage key */
; 490  :     if (akey == 0)

  00082	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey$[rsp]
  00087	85 c0		 test	 eax, eax
  00089	75 04		 jne	 SHORT $LN5@z900_is_st

; 491  :         return false;

  0008b	32 c0		 xor	 al, al
  0008d	eb 57		 jmp	 SHORT $LN1@z900_is_st
$LN5@z900_is_st:

; 492  : 
; 493  : #if defined( FEATURE_STORAGE_PROTECTION_OVERRIDE )
; 494  :     /* [3.4.1.1] Storage protection override allows access to
; 495  :        locations with storage key 9, regardless of the access key,
; 496  :        provided that CR0 bit 7 is set */
; 497  :     if (1
; 498  :         && (skey & STORKEY_KEY) == 0x90
; 499  :         && (regs->CR(0) & CR0_STORE_OVRD)

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 36		 je	 SHORT $LN6@z900_is_st
  00096	0f b6 44 24 38	 movzx	 eax, BYTE PTR skey$[rsp]
  0009b	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000a0	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  000a5	75 25		 jne	 SHORT $LN6@z900_is_st
  000a7	b8 08 00 00 00	 mov	 eax, 8
  000ac	48 6b c0 01	 imul	 rax, rax, 1
  000b0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000bd	48 25 00 00 00
	01		 and	 rax, 16777216		; 01000000H
  000c3	48 85 c0	 test	 rax, rax
  000c6	74 04		 je	 SHORT $LN6@z900_is_st

; 500  :     )
; 501  :         return false;

  000c8	32 c0		 xor	 al, al
  000ca	eb 1a		 jmp	 SHORT $LN1@z900_is_st
$LN6@z900_is_st:

; 502  : #endif
; 503  : 
; 504  :     /* [3.4.1] Store protection prohibits stores
; 505  :        if the access key does not match the storage key */
; 506  :     if (akey != (skey & STORKEY_KEY))

  000cc	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey$[rsp]
  000d1	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR skey$[rsp]
  000d6	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  000dc	3b c1		 cmp	 eax, ecx
  000de	74 04		 je	 SHORT $LN7@z900_is_st

; 507  :         return true;

  000e0	b0 01		 mov	 al, 1
  000e2	eb 02		 jmp	 SHORT $LN1@z900_is_st
$LN7@z900_is_st:

; 508  : 
; 509  :     return false;      // (location is *NOT* store protected)

  000e4	32 c0		 xor	 al, al
$LN1@z900_is_st:

; 510  : 
; 511  : } /* end function is_store_protected */

  000e6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ea	c3		 ret	 0
z900_is_store_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_low_address_protected
_TEXT	SEGMENT
addr$ = 8
regs$ = 16
z900_is_low_address_protected PROC			; COMDAT

; 419  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 420  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 421  :     /* For z/Arch, low-address protection applies to locations
; 422  :        0-511 (0000-01FF) and also 4096-4607 (1000-11FF) */
; 423  :     if (addr & 0xFFFFFFFFFFFFEE00ULL)

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR addr$[rsp]
  0000f	48 25 00 ee ff
	ff		 and	 rax, -4608		; ffffffffffffee00H
  00015	48 85 c0	 test	 rax, rax
  00018	74 04		 je	 SHORT $LN2@z900_is_lo

; 424  : #else
; 425  :     /* For S/370 and ESA/390, low-address protection applies
; 426  :        only to locations 0-511 */
; 427  :     if (addr > 511)
; 428  : #endif
; 429  :         return false;

  0001a	32 c0		 xor	 al, al
  0001c	eb 53		 jmp	 SHORT $LN1@z900_is_lo
$LN2@z900_is_lo:

; 430  : 
; 431  :     /* Low-address protection applies only if the low-address
; 432  :        protection control bit in control register 0 is set */
; 433  :     if (!(regs->CR(0) & CR0_LOW_PROT))

  0001e	b8 08 00 00 00	 mov	 eax, 8
  00023	48 6b c0 01	 imul	 rax, rax, 1
  00027	48 8b 4c 24 10	 mov	 rcx, QWORD PTR regs$[rsp]
  0002c	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00034	48 25 00 00 00
	10		 and	 rax, 268435456		; 10000000H
  0003a	48 85 c0	 test	 rax, rax
  0003d	75 04		 jne	 SHORT $LN3@z900_is_lo

; 434  :         return false;

  0003f	32 c0		 xor	 al, al
  00041	eb 2e		 jmp	 SHORT $LN1@z900_is_lo
$LN3@z900_is_lo:

; 435  : 
; 436  : #if defined( _FEATURE_SIE )
; 437  :     /* Host low-address protection is not applied to guest
; 438  :        references to guest storage */
; 439  :     if (regs->sie_active)

  00043	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  00048	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0004e	83 e0 01	 and	 eax, 1
  00051	85 c0		 test	 eax, eax
  00053	74 04		 je	 SHORT $LN4@z900_is_lo

; 440  :         return false;

  00055	32 c0		 xor	 al, al
  00057	eb 18		 jmp	 SHORT $LN1@z900_is_lo
$LN4@z900_is_lo:

; 441  : #endif
; 442  : 
; 443  :     /* Low-addr protection doesn't apply to private address spaces */
; 444  :     if (regs->dat.pvtaddr)

  00059	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00064	83 e0 01	 and	 eax, 1
  00067	85 c0		 test	 eax, eax
  00069	74 04		 je	 SHORT $LN5@z900_is_lo

; 445  :         return false;

  0006b	32 c0		 xor	 al, al
  0006d	eb 02		 jmp	 SHORT $LN1@z900_is_lo
$LN5@z900_is_lo:

; 446  : 
; 447  :     return true;      // (location *IS* low-address protected)

  0006f	b0 01		 mov	 al, 1
$LN1@z900_is_lo:

; 448  : 
; 449  : } /* end function is_low_address_protected */

  00071	c3		 ret	 0
z900_is_low_address_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_fetch_protected
_TEXT	SEGMENT
tv87 = 0
addr$ = 32
skey$ = 40
akey$ = 48
regs$ = 56
z900_is_fetch_protected PROC				; COMDAT

; 365  : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 18	 sub	 rsp, 24
$LN4@z900_is_fe:

; 366  :     UNREFERENCED_370( addr );

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@z900_is_fe
$LN7@z900_is_fe:

; 367  :     UNREFERENCED_370( regs );

  0001d	33 c0		 xor	 eax, eax
  0001f	85 c0		 test	 eax, eax
  00021	75 fa		 jne	 SHORT $LN7@z900_is_fe

; 368  : 
; 369  :     /* [3.4.1] Fetch is allowed if access key is zero, regardless
; 370  :        of the storage key and fetch protection bit */
; 371  :     /* [3.4.1] Fetch protection prohibits fetch if storage key fetch
; 372  :        protect bit is on and access key does not match storage key */
; 373  :     if (likely(0

  00023	33 c0		 xor	 eax, eax
  00025	85 c0		 test	 eax, eax
  00027	75 32		 jne	 SHORT $LN12@z900_is_fe
  00029	0f b6 44 24 30	 movzx	 eax, BYTE PTR akey$[rsp]
  0002e	85 c0		 test	 eax, eax
  00030	74 29		 je	 SHORT $LN12@z900_is_fe
  00032	0f b6 44 24 30	 movzx	 eax, BYTE PTR akey$[rsp]
  00037	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR skey$[rsp]
  0003c	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00042	3b c1		 cmp	 eax, ecx
  00044	74 15		 je	 SHORT $LN12@z900_is_fe
  00046	0f b6 44 24 28	 movzx	 eax, BYTE PTR skey$[rsp]
  0004b	83 e0 08	 and	 eax, 8
  0004e	85 c0		 test	 eax, eax
  00050	74 09		 je	 SHORT $LN12@z900_is_fe
  00052	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv87[rsp], 0
  00059	eb 07		 jmp	 SHORT $LN15@z900_is_fe
$LN12@z900_is_fe:
  0005b	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv87[rsp], 1
$LN15@z900_is_fe:
  00062	83 3c 24 00	 cmp	 DWORD PTR tv87[rsp], 0
  00066	74 07		 je	 SHORT $LN8@z900_is_fe

; 374  :                || akey == 0
; 375  :                || akey == (skey & STORKEY_KEY)
; 376  :                || !(skey & STORKEY_FETCH)
; 377  :               )
; 378  :     )
; 379  :         return false;

  00068	32 c0		 xor	 al, al
  0006a	e9 88 00 00 00	 jmp	 $LN1@z900_is_fe
$LN8@z900_is_fe:

; 380  : 
; 381  : #if defined( FEATURE_FETCH_PROTECTION_OVERRIDE )
; 382  :     /* [3.4.1.2] Fetch protection override allows fetch from first
; 383  :        2K of non-private address spaces if CR0 bit 6 is set */
; 384  :     if (1
; 385  :         && addr < 2048
; 386  :         && (regs->CR(0) & CR0_FETCH_OVRD)
; 387  :         && regs->dat.pvtaddr == 0

  0006f	33 c0		 xor	 eax, eax
  00071	83 f8 01	 cmp	 eax, 1
  00074	74 42		 je	 SHORT $LN9@z900_is_fe
  00076	48 81 7c 24 20
	00 08 00 00	 cmp	 QWORD PTR addr$[rsp], 2048 ; 00000800H
  0007f	73 37		 jae	 SHORT $LN9@z900_is_fe
  00081	b8 08 00 00 00	 mov	 eax, 8
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00097	48 25 00 00 00
	02		 and	 rax, 33554432		; 02000000H
  0009d	48 85 c0	 test	 rax, rax
  000a0	74 16		 je	 SHORT $LN9@z900_is_fe
  000a2	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  000ad	83 e0 01	 and	 eax, 1
  000b0	85 c0		 test	 eax, eax
  000b2	75 04		 jne	 SHORT $LN9@z900_is_fe

; 388  :     )
; 389  :         return false;

  000b4	32 c0		 xor	 al, al
  000b6	eb 3f		 jmp	 SHORT $LN1@z900_is_fe
$LN9@z900_is_fe:

; 390  : #endif
; 391  : 
; 392  : #if defined( FEATURE_STORAGE_PROTECTION_OVERRIDE )
; 393  :     /* [3.4.1.1] Storage protection override allows access to
; 394  :        locations with storage key 9, regardless of the access key,
; 395  :        provided that CR0 bit 7 is set */
; 396  :     if (1
; 397  :         && (skey & STORKEY_KEY) == 0x90
; 398  :         && (regs->CR(0) & CR0_STORE_OVRD)

  000b8	33 c0		 xor	 eax, eax
  000ba	83 f8 01	 cmp	 eax, 1
  000bd	74 36		 je	 SHORT $LN10@z900_is_fe
  000bf	0f b6 44 24 28	 movzx	 eax, BYTE PTR skey$[rsp]
  000c4	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000c9	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  000ce	75 25		 jne	 SHORT $LN10@z900_is_fe
  000d0	b8 08 00 00 00	 mov	 eax, 8
  000d5	48 6b c0 01	 imul	 rax, rax, 1
  000d9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  000de	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000e6	48 25 00 00 00
	01		 and	 rax, 16777216		; 01000000H
  000ec	48 85 c0	 test	 rax, rax
  000ef	74 04		 je	 SHORT $LN10@z900_is_fe

; 399  :     )
; 400  :         return false;

  000f1	32 c0		 xor	 al, al
  000f3	eb 02		 jmp	 SHORT $LN1@z900_is_fe
$LN10@z900_is_fe:

; 401  : #endif
; 402  : 
; 403  :     return true;    // (location *IS* fetch protected)

  000f5	b0 01		 mov	 al, 1
$LN1@z900_is_fe:

; 404  : 
; 405  : } /* end function is_fetch_protected */

  000f7	48 83 c4 18	 add	 rsp, 24
  000fb	c3		 ret	 0
z900_is_fetch_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key_by_ptr
_TEXT	SEGMENT
abs$ = 32
skey_ptr$ = 64
bits$ = 72
z900_or_storage_key_by_ptr PROC				; COMDAT

; 328  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 329  :     U64 abs = (skey_ptr - sysblk.storkeys) << _STORKEY_ARRAY_SHIFTAMT;

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00014	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR skey_ptr$[rsp]
  00020	48 2b c8	 sub	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx
  00026	48 c1 e0 0b	 shl	 rax, 11
  0002a	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 330  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 331  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 332  : #else
; 333  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0002f	0f b6 54 24 48	 movzx	 edx, BYTE PTR bits$[rsp]
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  00039	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 334  : #endif
; 335  : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
z900_or_storage_key_by_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_storekey_by_ptr
_TEXT	SEGMENT
abs$ = 32
skey_ptr$ = 64
z900_get_storekey_by_ptr PROC				; COMDAT

; 317  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 318  :     U64 abs = (skey_ptr - sysblk.storkeys) << _STORKEY_ARRAY_SHIFTAMT;

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR skey_ptr$[rsp]
  0001c	48 2b c8	 sub	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 c1 e0 0b	 shl	 rax, 11
  00026	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 319  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 320  :     return ARCH_DEP( get_2K_storage_key )( abs );
; 321  : #else
; 322  :     return ARCH_DEP( get_4K_storage_key )( abs );

  0002b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  00030	e8 00 00 00 00	 call	 z900_get_4K_storage_key

; 323  : #endif
; 324  : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
z900_get_storekey_by_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_ptr_to_storekey
_TEXT	SEGMENT
abs$ = 48
z900_get_ptr_to_storekey PROC				; COMDAT

; 308  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 309  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 310  :     return ARCH_DEP( get_ptr_to_2K_storekey )( abs );
; 311  : #else
; 312  :     return ARCH_DEP( get_ptr_to_4K_storekey )( abs );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0000e	e8 00 00 00 00	 call	 z900_get_ptr_to_4K_storekey

; 313  : #endif
; 314  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
z900_get_ptr_to_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
z900_get_4K_storage_key PROC				; COMDAT

; 239  :   inline BYTE  ARCH_DEP( get_4K_storage_key )     (              U64 abs            ) { return ARCH_DEP( _get_storage_key     )(      abs, 4 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 04		 mov	 dl, 4
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 z900__get_storage_key
  00015	0f b6 c0	 movzx	 eax, al
  00018	83 e0 fe	 and	 eax, -2
  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
z900_get_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_ptr_to_4K_storekey
_TEXT	SEGMENT
abs$ = 48
z900_get_ptr_to_4K_storekey PROC			; COMDAT

; 238  :   inline BYTE* ARCH_DEP( get_ptr_to_4K_storekey ) (              U64 abs            ) { return           _get_storekey_ptr     (      abs, 4 );                         }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 04		 mov	 dl, 4
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 _get_storekey_ptr
  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
z900_get_ptr_to_4K_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__get_storage_key
_TEXT	SEGMENT
skey$ = 32
abs$ = 64
K$ = 72
z900__get_storage_key PROC				; COMDAT

; 130  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900__get_:

; 131  :     BYTE skey;
; 132  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 fa		 jne	 SHORT $LN4@z900__get_

; 133  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	74 32		 je	 SHORT $LN5@z900__get_

; 134  :     {
; 135  :         skey  = *_get_storekey1_ptr( abs );

  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0001e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00023	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00026	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 136  :         skey |= *_get_storekey2_ptr( abs ) & ~(STORKEY_KEY);

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0002f	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00034	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00037	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  0003c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  00041	0b c8		 or	 ecx, eax
  00043	8b c1		 mov	 eax, ecx
  00045	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 137  :     }

  00049	eb 16		 jmp	 SHORT $LN6@z900__get_
$LN5@z900__get_:

; 138  :     else
; 139  :         skey  = *_get_storekey_ptr(  abs, K );

  0004b	0f b6 54 24 48	 movzx	 edx, BYTE PTR K$[rsp]
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00055	e8 00 00 00 00	 call	 _get_storekey_ptr
  0005a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005d	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@z900__get_:

; 140  :     return skey;

  00061	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 141  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
z900__get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv77 = 0
arn$ = 32
acctype$ = 40
regs$ = 48
s390_check_sa_per2 PROC

; 2302 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 18	 sub	 rsp, 24
$LN4@s390_check:

; 2303 :     UNREFERENCED( acctype );

  00011	33 c0		 xor	 eax, eax
  00013	85 c0		 test	 eax, eax
  00015	75 fa		 jne	 SHORT $LN4@s390_check

; 2304 : 
; 2305 :     if (0
; 2306 :         || (regs->dat.asd & SAEVENT_BIT)
; 2307 :         || !(regs->CR(9) & CR9_SAC)

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 35		 jne	 SHORT $LN6@s390_check
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00022	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00029	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0002f	48 85 c0	 test	 rax, rax
  00032	75 1e		 jne	 SHORT $LN6@s390_check
  00034	b8 08 00 00 00	 mov	 eax, 8
  00039	48 6b c0 0a	 imul	 rax, rax, 10
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00049	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  0004e	85 c0		 test	 eax, eax
  00050	75 4d		 jne	 SHORT $LN5@s390_check
$LN6@s390_check:

; 2308 :     )
; 2309 :     {
; 2310 :         regs->peraid = arn > 0 ? arn : 0;

  00052	83 7c 24 20 00	 cmp	 DWORD PTR arn$[rsp], 0
  00057	7e 09		 jle	 SHORT $LN8@s390_check
  00059	8b 44 24 20	 mov	 eax, DWORD PTR arn$[rsp]
  0005d	89 04 24	 mov	 DWORD PTR tv77[rsp], eax
  00060	eb 07		 jmp	 SHORT $LN9@s390_check
$LN8@s390_check:
  00062	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv77[rsp], 0
$LN9@s390_check:
  00069	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	0f b6 0c 24	 movzx	 ecx, BYTE PTR tv77[rsp]
  00072	88 88 e0 08 00
	00		 mov	 BYTE PTR [rax+2272], cl

; 2311 :         regs->perc |= regs->dat.stid;

  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	0f b7 80 d0 08
	00 00		 movzx	 eax, WORD PTR [rax+2256]
  00084	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00089	0b 81 20 08 00
	00		 or	 eax, DWORD PTR [rcx+2080]
  0008f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00094	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 2312 :         return true;

  0009b	b0 01		 mov	 al, 1
  0009d	eb 02		 jmp	 SHORT $LN1@s390_check
$LN5@s390_check:

; 2313 :     }
; 2314 :     return false;

  0009f	32 c0		 xor	 al, al
$LN1@s390_check:

; 2315 : }

  000a1	48 83 c4 18	 add	 rsp, 24
  000a5	c3		 ret	 0
s390_check_sa_per2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv64 = 48
eax$ = 52
tv68 = 56
tv151 = 60
tv152 = 64
alet$ = 68
tv251 = 72
asteo$ = 76
aste$ = 80
__$ArrayPad$ = 144
arn$ = 176
regs$ = 184
acctype$ = 192
s390_load_address_space_designator PROC

; 670  : {

$LN33:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 671  : #if defined( FEATURE_ACCESS_REGISTERS )
; 672  : U32     alet;                           /* Access list entry token   */
; 673  : U32     asteo;                          /* Real address of ASTE      */
; 674  : U32     aste[16];                       /* ASN second table entry    */
; 675  : U16     eax;                            /* Authorization index       */
; 676  : #else
; 677  :     UNREFERENCED( acctype );
; 678  : #endif
; 679  : 
; 680  :     switch(arn) {

  00027	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  0002e	89 44 24 30	 mov	 DWORD PTR tv64[rsp], eax
  00032	83 7c 24 30 fb	 cmp	 DWORD PTR tv64[rsp], -5
  00037	0f 84 4e 01 00
	00		 je	 $LN14@s390_load_
  0003d	83 7c 24 30 fc	 cmp	 DWORD PTR tv64[rsp], -4
  00042	0f 84 05 01 00
	00		 je	 $LN13@s390_load_
  00048	83 7c 24 30 fd	 cmp	 DWORD PTR tv64[rsp], -3
  0004d	0f 84 bc 00 00
	00		 je	 $LN12@s390_load_
  00053	83 7c 24 30 fe	 cmp	 DWORD PTR tv64[rsp], -2
  00058	0f 84 6b 01 00
	00		 je	 $LN15@s390_load_
  0005e	83 7c 24 30 ff	 cmp	 DWORD PTR tv64[rsp], -1
  00063	74 05		 je	 SHORT $LN8@s390_load_
  00065	e9 8a 01 00 00	 jmp	 $LN16@s390_load_
$LN8@s390_load_:

; 681  : 
; 682  :     case USE_INST_SPACE:
; 683  :         switch(regs->AEA_AR(USE_INST_SPACE)) {

  0006a	b8 04 00 00 00	 mov	 eax, 4
  0006f	48 6b c0 04	 imul	 rax, rax, 4
  00073	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00082	89 44 24 38	 mov	 DWORD PTR tv68[rsp], eax
  00086	83 7c 24 38 01	 cmp	 DWORD PTR tv68[rsp], 1
  0008b	74 09		 je	 SHORT $LN9@s390_load_
  0008d	83 7c 24 38 0d	 cmp	 DWORD PTR tv68[rsp], 13
  00092	74 16		 je	 SHORT $LN10@s390_load_
  00094	eb 28		 jmp	 SHORT $LN11@s390_load_
$LN9@s390_load_:

; 684  : 
; 685  :         case 1:
; 686  :             regs->dat.stid = TEA_ST_PRIMARY;

  00096	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 687  :             break;

  000a8	eb 26		 jmp	 SHORT $LN4@s390_load_
$LN10@s390_load_:

; 688  : #if defined( FEATURE_LINKAGE_STACK )
; 689  :         case 13:
; 690  :             regs->dat.stid = TEA_ST_HOME;

  000aa	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	c7 80 20 08 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+2080], 3

; 691  :             break;

  000bc	eb 12		 jmp	 SHORT $LN4@s390_load_
$LN11@s390_load_:

; 692  : #endif
; 693  :         default:
; 694  :             regs->dat.stid = 0;

  000be	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0
$LN4@s390_load_:

; 695  :         } /* end switch(regs->AEA_AR(USE_INST_SPACE)) */
; 696  : 
; 697  :         regs->dat.asd = regs->CR(regs->AEA_AR(USE_INST_SPACE));

  000d0	b8 04 00 00 00	 mov	 eax, 4
  000d5	48 6b c0 04	 imul	 rax, rax, 4
  000d9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  000e8	ff c0		 inc	 eax
  000ea	48 98		 cdqe
  000ec	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	8b 84 c1 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+1536]
  000fb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00103	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 698  :         break;

  0010a	e9 3b 05 00 00	 jmp	 $LN2@s390_load_
$LN12@s390_load_:

; 699  : 
; 700  :     case USE_PRIMARY_SPACE:
; 701  :         regs->dat.stid = TEA_ST_PRIMARY;

  0010f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00117	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 702  :         regs->dat.asd = regs->CR(1);

  00121	b8 08 00 00 00	 mov	 eax, 8
  00126	48 6b c0 02	 imul	 rax, rax, 2
  0012a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00139	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 703  :         break;

  00148	e9 fd 04 00 00	 jmp	 $LN2@s390_load_
$LN13@s390_load_:

; 704  : 
; 705  :     case USE_SECONDARY_SPACE:
; 706  :         regs->dat.stid = TEA_ST_SECNDRY;

  0014d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00155	c7 80 20 08 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+2080], 2

; 707  :         regs->dat.asd = regs->CR(7);

  0015f	b8 08 00 00 00	 mov	 eax, 8
  00164	48 6b c0 08	 imul	 rax, rax, 8
  00168	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00177	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 708  :         break;

  00186	e9 bf 04 00 00	 jmp	 $LN2@s390_load_
$LN14@s390_load_:

; 709  : 
; 710  :     case USE_HOME_SPACE:
; 711  :         regs->dat.stid = TEA_ST_HOME;

  0018b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00193	c7 80 20 08 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+2080], 3

; 712  :         regs->dat.asd = regs->CR(13);

  0019d	b8 08 00 00 00	 mov	 eax, 8
  001a2	48 6b c0 0e	 imul	 rax, rax, 14
  001a6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ae	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  001b5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bd	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 713  :         break;

  001c4	e9 81 04 00 00	 jmp	 $LN2@s390_load_
$LN15@s390_load_:

; 714  : 
; 715  :     case USE_REAL_ADDR:
; 716  :         regs->dat.stid = 0;

  001c9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d1	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 717  :         regs->dat.asd = TLB_REAL_ASD;

  001db	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e3	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  001e8	48 89 88 18 08
	00 00		 mov	 QWORD PTR [rax+2072], rcx

; 718  :         break;

  001ef	e9 56 04 00 00	 jmp	 $LN2@s390_load_
$LN16@s390_load_:

; 719  : 
; 720  :     default:
; 721  : 
; 722  : #if defined( FEATURE_ACCESS_REGISTERS )
; 723  :         if (ACCESS_REGISTER_MODE(&regs->psw)
; 724  :          || (SIE_ACTIVE(regs) && MULTIPLE_CONTROLLED_DATA_SPACE(GUESTREGS))
; 725  :          || (arn >= USE_ARMODE)

  001f4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00200	83 f8 40	 cmp	 eax, 64			; 00000040H
  00203	74 14		 je	 SHORT $LN18@s390_load_
  00205	33 c0		 xor	 eax, eax
  00207	85 c0		 test	 eax, eax
  00209	75 0e		 jne	 SHORT $LN18@s390_load_
  0020b	83 bc 24 b0 00
	00 00 10	 cmp	 DWORD PTR arn$[rsp], 16
  00213	0f 8c 59 03 00
	00		 jl	 $LN17@s390_load_
$LN18@s390_load_:

; 726  :            )
; 727  :         {
; 728  :             /* Remove flags giving access register number 0-15 */
; 729  :             arn &= 0xF;

  00219	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00220	83 e0 0f	 and	 eax, 15
  00223	89 84 24 b0 00
	00 00		 mov	 DWORD PTR arn$[rsp], eax

; 730  : 
; 731  :             /* [5.8.4.1] Select the access-list-entry token */
; 732  :             alet = (arn == 0) ? 0 :

  0022a	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  00232	75 0a		 jne	 SHORT $LN29@s390_load_
  00234	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
  0023c	eb 1b		 jmp	 SHORT $LN30@s390_load_
$LN29@s390_load_:
  0023e	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR arn$[rsp]
  00246	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0024e	8b 84 81 00 03
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+768]
  00255	89 44 24 3c	 mov	 DWORD PTR tv151[rsp], eax
$LN30@s390_load_:
  00259	8b 44 24 3c	 mov	 eax, DWORD PTR tv151[rsp]
  0025d	89 44 24 44	 mov	 DWORD PTR alet$[rsp], eax

; 733  :                    /* Guest ALET if XC guest in AR mode */
; 734  :                    (SIE_ACTIVE(regs) && MULTIPLE_CONTROLLED_DATA_SPACE(GUESTREGS))
; 735  :                    ? GUESTREGS->AR(arn) :
; 736  :                    /* If SIE host but not XC guest in AR mode then alet is 0 */
; 737  :                    SIE_ACTIVE(regs) ? 0 :
; 738  :                    /* Otherwise alet is in the access register */
; 739  :                    regs->AR(arn);
; 740  : 
; 741  :             /* Use the ALET to determine the segment table origin */
; 742  :             switch (alet) {

  00261	8b 44 24 44	 mov	 eax, DWORD PTR alet$[rsp]
  00265	89 44 24 40	 mov	 DWORD PTR tv152[rsp], eax
  00269	83 7c 24 40 00	 cmp	 DWORD PTR tv152[rsp], 0
  0026e	74 09		 je	 SHORT $LN19@s390_load_
  00270	83 7c 24 40 01	 cmp	 DWORD PTR tv152[rsp], 1
  00275	74 40		 je	 SHORT $LN20@s390_load_
  00277	eb 7c		 jmp	 SHORT $LN21@s390_load_
$LN19@s390_load_:

; 743  : 
; 744  :             case ALET_PRIMARY:
; 745  :                 /* [5.8.4.2] Obtain primary segment table designation */
; 746  :                 regs->dat.stid = TEA_ST_PRIMARY;

  00279	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00281	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 747  :                 regs->dat.asd = regs->CR(1);

  0028b	b8 08 00 00 00	 mov	 eax, 8
  00290	48 6b c0 02	 imul	 rax, rax, 2
  00294	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029c	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  002a3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ab	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 748  :                 break;

  002b2	e9 b6 02 00 00	 jmp	 $LN6@s390_load_
$LN20@s390_load_:

; 749  : 
; 750  :             case ALET_SECONDARY:
; 751  :                 /* [5.8.4.2] Obtain secondary segment table designation */
; 752  :                 regs->dat.stid = TEA_ST_SECNDRY;

  002b7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bf	c7 80 20 08 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+2080], 2

; 753  :                 regs->dat.asd = regs->CR(7);

  002c9	b8 08 00 00 00	 mov	 eax, 8
  002ce	48 6b c0 08	 imul	 rax, rax, 8
  002d2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002da	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  002e1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e9	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 754  :                 break;

  002f0	e9 78 02 00 00	 jmp	 $LN6@s390_load_
$LN21@s390_load_:

; 755  : 
; 756  :             default:
; 757  :                 /* ALB Lookup */
; 758  :                 if(regs->AEA_AR(arn) >= CR_ALB_OFFSET)

  002f5	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  002fc	83 c0 05	 add	 eax, 5
  002ff	48 98		 cdqe
  00301	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	83 bc 81 94 0c
	00 00 10	 cmp	 DWORD PTR [rcx+rax*4+3220], 16
  00311	0f 8c 94 00 00
	00		 jl	 $LN22@s390_load_

; 759  :                 {
; 760  :                     regs->dat.asd = regs->CR(regs->AEA_AR(arn));

  00317	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  0031e	83 c0 05	 add	 eax, 5
  00321	48 98		 cdqe
  00323	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032b	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  00332	ff c0		 inc	 eax
  00334	48 98		 cdqe
  00336	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033e	8b 84 c1 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+1536]
  00345	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034d	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 761  :                     regs->dat.protect = regs->aea_aleprot[arn];

  00354	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR arn$[rsp]
  0035c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00364	0f b6 84 01 09
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3337]
  0036c	83 e0 03	 and	 eax, 3
  0036f	d1 e0		 shl	 eax, 1
  00371	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00379	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  0037f	83 e1 f9	 and	 ecx, -7			; fffffff9H
  00382	0b c8		 or	 ecx, eax
  00384	8b c1		 mov	 eax, ecx
  00386	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038e	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 762  :                     regs->dat.stid = TEA_ST_ARMODE;

  00394	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039c	c7 80 20 08 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+2080], 1

; 763  :                 }

  003a6	e9 c2 01 00 00	 jmp	 $LN23@s390_load_
$LN22@s390_load_:

; 764  :                 else
; 765  :                 {
; 766  :                     /* Extract the extended AX from CR8 bits 0-15 (32-47) */
; 767  :                     eax = regs->CR_LHH(8);

  003ab	b8 08 00 00 00	 mov	 eax, 8
  003b0	48 6b c0 09	 imul	 rax, rax, 9
  003b4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003bc	0f b7 84 01 02
	06 00 00	 movzx	 eax, WORD PTR [rcx+rax+1538]
  003c4	66 89 44 24 34	 mov	 WORD PTR eax$[rsp], ax

; 768  : 
; 769  :                     /* [5.8.4.3] Perform ALET translation to obtain ASTE */
; 770  :                     if (ARCH_DEP(translate_alet) (alet, eax, acctype,

  003c9	48 8d 44 24 50	 lea	 rax, QWORD PTR aste$[rsp]
  003ce	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003d3	48 8d 44 24 4c	 lea	 rax, QWORD PTR asteo$[rsp]
  003d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003dd	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003e5	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR acctype$[rsp]
  003ed	0f b7 54 24 34	 movzx	 edx, WORD PTR eax$[rsp]
  003f2	8b 4c 24 44	 mov	 ecx, DWORD PTR alet$[rsp]
  003f6	e8 00 00 00 00	 call	 s390_translate_alet
  003fb	0f b7 c0	 movzx	 eax, ax
  003fe	85 c0		 test	 eax, eax
  00400	74 14		 je	 SHORT $LN24@s390_load_

; 771  :                                                   regs, &asteo, aste))
; 772  :                         /* Exit if ALET translation error */
; 773  :                         return regs->dat.xcode;

  00402	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040a	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00411	e9 36 02 00 00	 jmp	 $LN1@s390_load_
$LN24@s390_load_:

; 774  : 
; 775  :                     /* [5.8.4.9] Obtain the STD or ASCE from the ASTE */
; 776  :                     regs->dat.asd = ASTE_AS_DESIGNATOR(aste);

  00416	b8 04 00 00 00	 mov	 eax, 4
  0041b	48 6b c0 02	 imul	 rax, rax, 2
  0041f	8b 44 04 50	 mov	 eax, DWORD PTR aste$[rsp+rax]
  00423	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0042b	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 777  :                     regs->dat.stid = TEA_ST_ARMODE;

  00432	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0043a	c7 80 20 08 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+2080], 1

; 778  : 
; 779  :                     if (regs->dat.protect & 2)

  00444	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044c	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00452	d1 e8		 shr	 eax, 1
  00454	83 e0 03	 and	 eax, 3
  00457	83 e0 02	 and	 eax, 2
  0045a	85 c0		 test	 eax, eax
  0045c	74 47		 je	 SHORT $LN25@s390_load_

; 780  :                     {
; 781  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 782  :                        regs->dat.asd ^= ASCE_RESV;
; 783  :                        regs->dat.asd |= ASCE_P;
; 784  : #else
; 785  :                        regs->dat.asd ^= STD_RESV;

  0045e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00466	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  0046d	48 35 00 0c 00
	00		 xor	 rax, 3072		; 00000c00H
  00473	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047b	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 786  :                        regs->dat.asd |= STD_PRIVATE;

  00482	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0048a	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00491	48 0f ba e8 08	 bts	 rax, 8
  00496	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049e	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax
$LN25@s390_load_:

; 787  : #endif
; 788  :                     }
; 789  : 
; 790  :                     /* Update ALB */
; 791  :                     regs->CR(CR_ALB_OFFSET + arn) = regs->dat.asd;

  004a5	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  004ac	83 c0 11	 add	 eax, 17
  004af	48 98		 cdqe
  004b1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b9	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004c1	8b 92 18 08 00
	00		 mov	 edx, DWORD PTR [rdx+2072]
  004c7	89 94 c1 00 06
	00 00		 mov	 DWORD PTR [rcx+rax*8+1536], edx

; 792  :                     regs->AEA_AR(arn) = CR_ALB_OFFSET + arn;

  004ce	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  004d5	83 c0 10	 add	 eax, 16
  004d8	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR arn$[rsp]
  004df	83 c1 05	 add	 ecx, 5
  004e2	48 63 c9	 movsxd	 rcx, ecx
  004e5	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004ed	89 84 8a 94 0c
	00 00		 mov	 DWORD PTR [rdx+rcx*4+3220], eax

; 793  :                     regs->AEA_COMMON(CR_ALB_OFFSET + arn) = (regs->dat.asd & ASD_PRIVATE) == 0;

  004f4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004fc	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00503	48 25 00 01 00
	00		 and	 rax, 256		; 00000100H
  00509	48 85 c0	 test	 rax, rax
  0050c	75 0a		 jne	 SHORT $LN31@s390_load_
  0050e	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv251[rsp], 1
  00516	eb 08		 jmp	 SHORT $LN32@s390_load_
$LN31@s390_load_:
  00518	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv251[rsp], 0
$LN32@s390_load_:
  00520	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00527	83 c0 11	 add	 eax, 17
  0052a	48 98		 cdqe
  0052c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00534	0f b6 54 24 48	 movzx	 edx, BYTE PTR tv251[rsp]
  00539	88 94 01 e8 0c
	00 00		 mov	 BYTE PTR [rcx+rax+3304], dl

; 794  :                     regs->aea_aleprot[arn] = regs->dat.protect & 2;

  00540	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00548	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0054e	d1 e8		 shr	 eax, 1
  00550	83 e0 03	 and	 eax, 3
  00553	83 e0 02	 and	 eax, 2
  00556	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR arn$[rsp]
  0055e	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00566	88 84 0a 09 0d
	00 00		 mov	 BYTE PTR [rdx+rcx+3337], al
$LN23@s390_load_:
$LN6@s390_load_:

; 795  :                 }
; 796  : 
; 797  :             } /* end switch(alet) */
; 798  : 
; 799  :             break;

  0056d	e9 d8 00 00 00	 jmp	 $LN2@s390_load_
$LN17@s390_load_:

; 800  : 
; 801  :         } /* end if(ACCESS_REGISTER_MODE) */
; 802  : #endif /* defined( FEATURE_ACCESS_REGISTERS ) */
; 803  : 
; 804  : #if defined( FEATURE_DUAL_ADDRESS_SPACE )
; 805  :         if (SECONDARY_SPACE_MODE(&regs->psw))

  00572	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057a	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0057e	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00583	75 3e		 jne	 SHORT $LN26@s390_load_

; 806  :         {
; 807  :             regs->dat.stid = TEA_ST_SECNDRY;

  00585	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058d	c7 80 20 08 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+2080], 2

; 808  :             regs->dat.asd = regs->CR(7);

  00597	b8 08 00 00 00	 mov	 eax, 8
  0059c	48 6b c0 08	 imul	 rax, rax, 8
  005a0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a8	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  005af	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b7	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 809  :             break;

  005be	e9 87 00 00 00	 jmp	 $LN2@s390_load_
$LN26@s390_load_:

; 810  :         }
; 811  : #endif
; 812  : 
; 813  : #if defined( FEATURE_LINKAGE_STACK )
; 814  :         if (HOME_SPACE_MODE(&regs->psw))

  005c3	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005cb	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  005cf	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  005d4	75 3b		 jne	 SHORT $LN27@s390_load_

; 815  :         {
; 816  :             regs->dat.stid = TEA_ST_HOME;

  005d6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005de	c7 80 20 08 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+2080], 3

; 817  :             regs->dat.asd = regs->CR(13);

  005e8	b8 08 00 00 00	 mov	 eax, 8
  005ed	48 6b c0 0e	 imul	 rax, rax, 14
  005f1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00600	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00608	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 818  :             break;

  0060f	eb 39		 jmp	 SHORT $LN2@s390_load_
$LN27@s390_load_:

; 819  :         }
; 820  : #endif
; 821  : 
; 822  :         /* Primary space mode */
; 823  :         regs->dat.stid = TEA_ST_PRIMARY;

  00611	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00619	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 824  :         regs->dat.asd = regs->CR(1);

  00623	b8 08 00 00 00	 mov	 eax, 8
  00628	48 6b c0 02	 imul	 rax, rax, 2
  0062c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00634	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0063b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00643	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax
$LN2@s390_load_:

; 825  :         break;
; 826  : 
; 827  :     } /* switch(arn) */
; 828  : 
; 829  :     return 0;

  0064a	33 c0		 xor	 eax, eax
$LN1@s390_load_:

; 830  : 
; 831  : } /* end function load_address_space_designator */

  0064c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00654	48 33 cc	 xor	 rcx, rsp
  00657	e8 00 00 00 00	 call	 __security_check_cookie
  0065c	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00663	c3		 ret	 0
s390_load_address_space_designator ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN5@s390_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN6@s390_vfetc
$LN5@s390_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@s390_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN9@s390_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN10@s390_vfetc
$LN9@s390_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@s390_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 10		 jne	 SHORT $LN3@s390_vfetc
  0004e	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00057	3d fc 0f 00 00	 cmp	 eax, 4092		; 00000ffcH
  0005c	77 45		 ja	 SHORT $LN2@s390_vfetc
$LN3@s390_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00063	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00067	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00078	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0007d	ba 04 00 00 00	 mov	 edx, 4
  00082	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00086	e8 00 00 00 00	 call	 s390_maddr_l
  0008b	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00090	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00095	e8 00 00 00 00	 call	 fetch_fw_noswap
  0009a	8b c8		 mov	 ecx, eax
  0009c	e8 00 00 00 00	 call	 _byteswap_ulong
  000a1	eb 12		 jmp	 SHORT $LN1@s390_vfetc
$LN2@s390_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000a3	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000a8	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000ac	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000b0	e8 00 00 00 00	 call	 s390_vfetch4_full
$LN1@s390_vfetc:

; 705  : }

  000b5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b9	c3		 ret	 0
s390_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstore4 PROC					; COMDAT

; 559  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00016	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  0001a	83 e0 03	 and	 eax, 3
  0001d	85 c0		 test	 eax, eax
  0001f	75 0a		 jne	 SHORT $LN6@s390_vstor
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN7@s390_vstor
$LN6@s390_vstor:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN7@s390_vstor:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00038	74 0a		 je	 SHORT $LN10@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN11@s390_vstor
$LN10@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN11@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00051	75 10		 jne	 SHORT $LN4@s390_vstor
  00053	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  00057	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0005c	3d fc 0f 00 00	 cmp	 eax, 4092		; 00000ffcH
  00061	77 49		 ja	 SHORT $LN2@s390_vstor
$LN4@s390_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00063	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00068	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006c	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00070	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00078	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0007d	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00082	ba 04 00 00 00	 mov	 edx, 4
  00087	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  00095	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  00099	e8 00 00 00 00	 call	 _byteswap_ulong
  0009e	8b d0		 mov	 edx, eax
  000a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  000a5	e8 00 00 00 00	 call	 store_fw_noswap

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );
; 568  :     }

  000aa	eb 17		 jmp	 SHORT $LN3@s390_vstor
$LN2@s390_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  000ac	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000b1	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000b6	8b 54 24 58	 mov	 edx, DWORD PTR addr$[rsp]
  000ba	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000be	e8 00 00 00 00	 call	 s390_vstore4_full
$LN3@s390_vstor:

; 571  : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
s390_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s390_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002b	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s390_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a9	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000af	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b7	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bb	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000bf	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000c7	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000cf	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000d4	48 8b d0	 mov	 rdx, rax
  000d7	e8 00 00 00 00	 call	 s390_maddr_l
  000dc	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000e1	b8 04 00 00 00	 mov	 eax, 4
  000e6	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000ea	48 98		 cdqe
  000ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000f1	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000f6	48 8b f9	 mov	 rdi, rcx
  000f9	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000fe	48 8b c8	 mov	 rcx, rax
  00101	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  00103	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00108	e8 00 00 00 00	 call	 fetch_fw_noswap
  0010d	8b c8		 mov	 ecx, eax
  0010f	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  00114	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00119	48 33 cc	 xor	 rcx, rsp
  0011c	e8 00 00 00 00	 call	 __security_check_cookie
  00121	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00125	5f		 pop	 rdi
  00126	5e		 pop	 rsi
  00127	c3		 ret	 0
s390_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
s390_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00018	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  0001c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00021	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00026	2b c8		 sub	 ecx, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  0002e	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00033	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0003f	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00043	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0004b	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00053	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	8b 4c 24 78	 mov	 ecx, DWORD PTR addr$[rsp]
  00062	e8 00 00 00 00	 call	 s390_maddr_l
  00067	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  0006c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0007b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00089	48 98		 cdqe
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  0008f	8b 54 24 78	 mov	 edx, DWORD PTR addr$[rsp]
  00093	03 d1		 add	 edx, ecx
  00095	8b ca		 mov	 ecx, edx
  00097	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0009f	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000a5	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ad	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000b1	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000b5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000bd	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c5	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000cd	48 8b d0	 mov	 rdx, rax
  000d0	e8 00 00 00 00	 call	 s390_maddr_l
  000d5	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000da	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000df	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e2	83 c8 06	 or	 eax, 6
  000e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000ea	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000ec	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000f0	e8 00 00 00 00	 call	 _byteswap_ulong
  000f5	8b d0		 mov	 edx, eax
  000f7	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  000fc	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  00101	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00106	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  0010b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00110	48 8b f1	 mov	 rsi, rcx
  00113	48 8b c8	 mov	 rcx, rax
  00116	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00118	b8 04 00 00 00	 mov	 eax, 4
  0011d	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00121	48 98		 cdqe
  00123	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00128	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  0012d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  00132	48 8b f1	 mov	 rsi, rcx
  00135	48 8b c8	 mov	 rcx, rax
  00138	f3 a4		 rep movsb

; 350  : }

  0013a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0013e	5f		 pop	 rdi
  0013f	5e		 pop	 rsi
  00140	c3		 ret	 0
s390_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_authorize_asn
_TEXT	SEGMENT
ate$ = 48
atl$ = 52
ato$ = 56
tv92 = 64
tv157 = 72
ax$ = 96
aste$ = 104
atemask$ = 112
regs$ = 120
s390_authorize_asn PROC					; COMDAT

; 192  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 193  : RADR    ato;                            /* Authority table origin    */
; 194  : int     atl;                            /* Authority table length    */
; 195  : BYTE    ate;                            /* Authority table entry     */
; 196  : 
; 197  :     /* [3.10.3.1] Authority table lookup */
; 198  : 
; 199  :     /* Isolate the authority table origin and length */
; 200  :     ato = aste[0] & ASTE0_ATO;

  00018	b8 04 00 00 00	 mov	 eax, 4
  0001d	48 6b c0 00	 imul	 rax, rax, 0
  00021	48 8b 4c 24 68	 mov	 rcx, QWORD PTR aste$[rsp]
  00026	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00029	25 fc ff ff 7f	 and	 eax, 2147483644		; 7ffffffcH
  0002e	8b c0		 mov	 eax, eax
  00030	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax

; 201  :     atl = aste[1] & ASTE1_ATL;

  00035	b8 04 00 00 00	 mov	 eax, 4
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR aste$[rsp]
  00043	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00046	25 f0 ff 00 00	 and	 eax, 65520		; 0000fff0H
  0004b	89 44 24 34	 mov	 DWORD PTR atl$[rsp], eax

; 202  : 
; 203  :     /* Authorization fails if AX is outside table */
; 204  :     if ((ax & 0xFFF0) > atl)

  0004f	0f b7 44 24 60	 movzx	 eax, WORD PTR ax$[rsp]
  00054	25 f0 ff 00 00	 and	 eax, 65520		; 0000fff0H
  00059	3b 44 24 34	 cmp	 eax, DWORD PTR atl$[rsp]
  0005d	7e 07		 jle	 SHORT $LN5@s390_autho

; 205  :         return true;

  0005f	b0 01		 mov	 al, 1
  00061	e9 e2 01 00 00	 jmp	 $LN1@s390_autho
$LN5@s390_autho:

; 206  : 
; 207  :     /* Calculate the address of the byte in the authority
; 208  :        table which contains the 2 bit entry for this AX */
; 209  :     ato += (ax >> 2);

  00066	0f b7 44 24 60	 movzx	 eax, WORD PTR ax$[rsp]
  0006b	c1 f8 02	 sar	 eax, 2
  0006e	48 98		 cdqe
  00070	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ato$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax

; 210  : 
; 211  :     /* Ignore carry into bit position 0 */
; 212  :     ato &= 0x7FFFFFFF;

  00080	48 8b 44 24 38	 mov	 rax, QWORD PTR ato$[rsp]
  00085	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  0008b	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax

; 213  : 
; 214  :     /* Addressing exception if ATE is outside main storage */
; 215  :     if (ato > regs->mainlim)

  00090	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00095	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0009c	48 39 44 24 38	 cmp	 QWORD PTR ato$[rsp], rax
  000a1	76 05		 jbe	 SHORT $LN6@s390_autho

; 216  :         goto auth_addr_excp;

  000a3	e9 8b 01 00 00	 jmp	 $auth_addr_excp$15
$LN6@s390_autho:

; 217  : 
; 218  :     /* Load the byte containing the authority table entry
; 219  :        and shift the entry into the leftmost 2 bits */
; 220  :     ato = APPLY_PREFIXING( ato, regs->PX );

  000a8	8b 44 24 38	 mov	 eax, DWORD PTR ato$[rsp]
  000ac	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000b2	48 85 c0	 test	 rax, rax
  000b5	74 23		 je	 SHORT $LN10@s390_autho
  000b7	8b 44 24 38	 mov	 eax, DWORD PTR ato$[rsp]
  000bb	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000c1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  000c9	48 3b c1	 cmp	 rax, rcx
  000cc	74 0c		 je	 SHORT $LN10@s390_autho
  000ce	48 8b 44 24 38	 mov	 rax, QWORD PTR ato$[rsp]
  000d3	48 89 44 24 40	 mov	 QWORD PTR tv92[rsp], rax
  000d8	eb 17		 jmp	 SHORT $LN11@s390_autho
$LN10@s390_autho:
  000da	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000df	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000e2	8b 4c 24 38	 mov	 ecx, DWORD PTR ato$[rsp]
  000e6	33 c8		 xor	 ecx, eax
  000e8	8b c1		 mov	 eax, ecx
  000ea	8b c0		 mov	 eax, eax
  000ec	48 89 44 24 40	 mov	 QWORD PTR tv92[rsp], rax
$LN11@s390_autho:
  000f1	48 8b 44 24 40	 mov	 rax, QWORD PTR tv92[rsp]
  000f6	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax
$LN4@s390_autho:

; 221  : 
; 222  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 223  :        is treated as a no-operation if SIE_MODE not active */
; 224  :     SIE_TRANSLATE( &ato, ACCTYPE_SIE, regs );

  000fb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00100	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00106	d1 e8		 shr	 eax, 1
  00108	83 e0 01	 and	 eax, 1
  0010b	85 c0		 test	 eax, eax
  0010d	0f 84 c4 00 00
	00		 je	 $LN7@s390_autho
  00113	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00118	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011e	c1 e8 02	 shr	 eax, 2
  00121	83 e0 01	 and	 eax, 1
  00124	85 c0		 test	 eax, eax
  00126	0f 85 ab 00 00
	00		 jne	 $LN7@s390_autho
  0012c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00131	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00138	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  0013c	75 41		 jne	 SHORT $LN12@s390_autho
  0013e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00143	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  0014a	48 03 44 24 38	 add	 rax, QWORD PTR ato$[rsp]
  0014f	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00158	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0015d	45 33 c9	 xor	 r9d, r9d
  00160	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  0016c	ba fd ff ff ff	 mov	 edx, -3
  00171	8b c8		 mov	 ecx, eax
  00173	e8 00 00 00 00	 call	 s390_logical_to_main_l
  00178	48 89 44 24 48	 mov	 QWORD PTR tv157[rsp], rax
  0017d	eb 40		 jmp	 SHORT $LN13@s390_autho
$LN12@s390_autho:
  0017f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00184	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  0018b	48 03 44 24 38	 add	 rax, QWORD PTR ato$[rsp]
  00190	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00199	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0019e	45 33 c9	 xor	 r9d, r9d
  001a1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  001ad	ba fd ff ff ff	 mov	 edx, -3
  001b2	48 8b c8	 mov	 rcx, rax
  001b5	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001ba	48 89 44 24 48	 mov	 QWORD PTR tv157[rsp], rax
$LN13@s390_autho:
  001bf	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001cb	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  001d2	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax
$LN7@s390_autho:
  001d7	33 c0		 xor	 eax, eax
  001d9	85 c0		 test	 eax, eax
  001db	0f 85 1a ff ff
	ff		 jne	 $LN4@s390_autho

; 225  : 
; 226  :     ate = regs->mainstor[ato];

  001e1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e6	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  001ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ato$[rsp]
  001f2	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  001f6	88 44 24 30	 mov	 BYTE PTR ate$[rsp], al

; 227  :     ate <<= ((ax & 0x03)*2);

  001fa	0f b7 44 24 60	 movzx	 eax, WORD PTR ax$[rsp]
  001ff	83 e0 03	 and	 eax, 3
  00202	d1 e0		 shl	 eax, 1
  00204	0f b6 c8	 movzx	 ecx, al
  00207	0f b6 44 24 30	 movzx	 eax, BYTE PTR ate$[rsp]
  0020c	d2 e0		 shl	 al, cl
  0020e	88 44 24 30	 mov	 BYTE PTR ate$[rsp], al

; 228  : 
; 229  :     /* Set the main storage reference bit */
; 230  :     ARCH_DEP( or_storage_key )( ato, STORKEY_REF );

  00212	b2 04		 mov	 dl, 4
  00214	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ato$[rsp]
  00219	e8 00 00 00 00	 call	 s390_or_storage_key

; 231  : 
; 232  :     /* Authorization fails if the specified bit (either X'80' or
; 233  :        X'40' of the 2 bit authority table entry) is zero */
; 234  :     if ((ate & atemask) == 0)

  0021e	0f b6 44 24 30	 movzx	 eax, BYTE PTR ate$[rsp]
  00223	23 44 24 70	 and	 eax, DWORD PTR atemask$[rsp]
  00227	85 c0		 test	 eax, eax
  00229	75 04		 jne	 SHORT $LN8@s390_autho

; 235  :         return true;

  0022b	b0 01		 mov	 al, 1
  0022d	eb 19		 jmp	 SHORT $LN1@s390_autho
$LN8@s390_autho:

; 236  : 
; 237  :     /* Exit with successful return code */
; 238  :     return false;

  0022f	32 c0		 xor	 al, al
  00231	eb 15		 jmp	 SHORT $LN1@s390_autho
$auth_addr_excp$15:

; 239  : 
; 240  : /* Conditions which always cause program check */
; 241  : auth_addr_excp:
; 242  :     regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );

  00233	ba 05 00 00 00	 mov	 edx, 5
  00238	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0023d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00242	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN1@s390_autho:
$LN9@s390_autho:

; 243  :     UNREACHABLE_CODE( return false );
; 244  : }

  00248	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0024c	c3		 ret	 0
s390_authorize_asn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_purge_alb_all
_TEXT	SEGMENT
cpu$ = 32
tv92 = 36
p$1 = 40
p$2 = 48
regs$ = 80
s390_purge_alb_all PROC					; COMDAT

; 136  : {

$LN19:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 137  :     int  cpu;
; 138  : 
; 139  :     if (!IS_INTLOCK_HELD( regs ))   // (sanity check)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0001c	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00023	3b c1		 cmp	 eax, ecx
  00025	74 17		 je	 SHORT $LN13@s390_purge
$LN4@s390_purge:

; 140  :         CRASH();                    // (logic error!)

  00027	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00030	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00035	c6 00 00	 mov	 BYTE PTR [rax], 0
  00038	33 c0		 xor	 eax, eax
  0003a	85 c0		 test	 eax, eax
  0003c	75 e9		 jne	 SHORT $LN4@s390_purge
$LN13@s390_purge:

; 141  : 
; 142  :     for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  0003e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  00046	eb 0a		 jmp	 SHORT $LN7@s390_purge
$LN5@s390_purge:
  00048	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN7@s390_purge:
  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0005f	39 44 24 20	 cmp	 DWORD PTR cpu$[rsp], eax
  00063	0f 8d d1 00 00
	00		 jge	 $LN6@s390_purge

; 143  :     {
; 144  :         if (1
; 145  :             && IS_CPU_ONLINE(cpu)
; 146  :             && (sysblk.regs[ cpu ]->cpubit & sysblk.started_mask)

  00069	33 c0		 xor	 eax, eax
  0006b	83 f8 01	 cmp	 eax, 1
  0006e	0f 84 c1 00 00
	00		 je	 $LN14@s390_purge
  00074	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00079	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00080	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00089	0f 84 a6 00 00
	00		 je	 $LN14@s390_purge
  0008f	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00094	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0009b	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000aa	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  000b1	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000b5	48 23 c1	 and	 rax, rcx
  000b8	48 85 c0	 test	 rax, rax
  000bb	74 78		 je	 SHORT $LN14@s390_purge

; 147  :         )
; 148  :         {
; 149  :             switch (sysblk.regs[ cpu ]->arch_mode)

  000bd	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c9	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000d1	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  000d4	89 44 24 24	 mov	 DWORD PTR tv92[rsp], eax
  000d8	83 7c 24 24 01	 cmp	 DWORD PTR tv92[rsp], 1
  000dd	74 09		 je	 SHORT $LN15@s390_purge
  000df	83 7c 24 24 02	 cmp	 DWORD PTR tv92[rsp], 2
  000e4	74 1d		 je	 SHORT $LN16@s390_purge
  000e6	eb 36		 jmp	 SHORT $LN17@s390_purge
$LN15@s390_purge:

; 150  :             {
; 151  :             case ARCH_390_IDX: s390_purge_alb( sysblk.regs[ cpu ]); break;

  000e8	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000ed	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000f4	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  000fc	e8 00 00 00 00	 call	 s390_purge_alb
  00101	eb 32		 jmp	 SHORT $LN8@s390_purge
$LN16@s390_purge:

; 152  :             case ARCH_900_IDX: z900_purge_alb( sysblk.regs[ cpu ]); break;

  00103	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00108	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0010f	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  00117	e8 00 00 00 00	 call	 z900_purge_alb
  0011c	eb 17		 jmp	 SHORT $LN8@s390_purge
$LN17@s390_purge:
$LN12@s390_purge:

; 153  :             default: CRASH(); // (370 doesn't have access registers)

  0011e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  00127	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  0012c	c6 00 00	 mov	 BYTE PTR [rax], 0
  0012f	33 c0		 xor	 eax, eax
  00131	85 c0		 test	 eax, eax
  00133	75 e9		 jne	 SHORT $LN12@s390_purge
$LN8@s390_purge:
$LN14@s390_purge:

; 154  :             }
; 155  :         }
; 156  :     }

  00135	e9 0e ff ff ff	 jmp	 $LN5@s390_purge
$LN6@s390_purge:

; 157  : }

  0013a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013e	c3		 ret	 0
s390_purge_alb_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_purge_tlbe_all
_TEXT	SEGMENT
cpu$ = 32
tv137 = 36
p$1 = 40
p$2 = 48
regs$ = 80
pfra$ = 88
cpuad$ = 96
s390_purge_tlbe_all PROC				; COMDAT

; 102  : {

$LN21:
  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 103  :     int  cpu;
; 104  : 
; 105  :     if (0xFFFF == cpuad && !IS_INTLOCK_HELD( regs ))  // (sanity check)

  00014	0f b7 44 24 60	 movzx	 eax, WORD PTR cpuad$[rsp]
  00019	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0001e	75 35		 jne	 SHORT $LN13@s390_purge
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00027	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  0002e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00033	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0003a	3b c1		 cmp	 eax, ecx
  0003c	74 17		 je	 SHORT $LN13@s390_purge
$LN4@s390_purge:

; 106  :         CRASH();                                      // (logic error!)

  0003e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00047	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0004c	c6 00 00	 mov	 BYTE PTR [rax], 0
  0004f	33 c0		 xor	 eax, eax
  00051	85 c0		 test	 eax, eax
  00053	75 e9		 jne	 SHORT $LN4@s390_purge
$LN13@s390_purge:

; 107  : 
; 108  :     for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  00055	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  0005d	eb 0a		 jmp	 SHORT $LN7@s390_purge
$LN5@s390_purge:
  0005f	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  00063	ff c0		 inc	 eax
  00065	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN7@s390_purge:
  00069	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00070	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00076	39 44 24 20	 cmp	 DWORD PTR cpu$[rsp], eax
  0007a	0f 8d 40 01 00
	00		 jge	 $LN6@s390_purge

; 109  :     {
; 110  :         if (1
; 111  :             && IS_CPU_ONLINE(cpu)
; 112  :             && (sysblk.regs[ cpu ]->cpubit & sysblk.started_mask)
; 113  :             && (0

  00080	33 c0		 xor	 eax, eax
  00082	83 f8 01	 cmp	 eax, 1
  00085	0f 84 30 01 00
	00		 je	 $LN14@s390_purge
  0008b	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00090	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00097	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  000a0	0f 84 15 01 00
	00		 je	 $LN14@s390_purge
  000a6	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b2	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000ba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c1	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  000c8	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000cc	48 23 c1	 and	 rax, rcx
  000cf	48 85 c0	 test	 rax, rax
  000d2	0f 84 e3 00 00
	00		 je	 $LN14@s390_purge
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 34		 jne	 SHORT $LN15@s390_purge
  000de	0f b7 44 24 60	 movzx	 eax, WORD PTR cpuad$[rsp]
  000e3	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  000e8	74 28		 je	 SHORT $LN15@s390_purge
  000ea	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000f6	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000fe	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00105	0f b7 4c 24 60	 movzx	 ecx, WORD PTR cpuad$[rsp]
  0010a	3b c1		 cmp	 eax, ecx
  0010c	0f 85 a9 00 00
	00		 jne	 $LN14@s390_purge
$LN15@s390_purge:

; 114  :                 || 0xFFFF == cpuad
; 115  :                 || sysblk.regs[ cpu ]->cpuad == cpuad
; 116  :                )
; 117  :         )
; 118  :         {
; 119  :             switch (sysblk.regs[ cpu ]->arch_mode)

  00112	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00117	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0011e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00126	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00129	89 44 24 24	 mov	 DWORD PTR tv137[rsp], eax
  0012d	83 7c 24 24 00	 cmp	 DWORD PTR tv137[rsp], 0
  00132	74 10		 je	 SHORT $LN16@s390_purge
  00134	83 7c 24 24 01	 cmp	 DWORD PTR tv137[rsp], 1
  00139	74 29		 je	 SHORT $LN17@s390_purge
  0013b	83 7c 24 24 02	 cmp	 DWORD PTR tv137[rsp], 2
  00140	74 42		 je	 SHORT $LN18@s390_purge
  00142	eb 60		 jmp	 SHORT $LN19@s390_purge
$LN16@s390_purge:

; 120  :             {
; 121  :             case ARCH_370_IDX: s370_purge_tlbe( sysblk.regs[ cpu ], pfra ); break;

  00144	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00149	48 8b 54 24 58	 mov	 rdx, QWORD PTR pfra$[rsp]
  0014e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00155	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0015d	e8 00 00 00 00	 call	 s370_purge_tlbe
  00162	eb 57		 jmp	 SHORT $LN8@s390_purge
$LN17@s390_purge:

; 122  :             case ARCH_390_IDX: s390_purge_tlbe( sysblk.regs[ cpu ], pfra ); break;

  00164	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00169	48 8b 54 24 58	 mov	 rdx, QWORD PTR pfra$[rsp]
  0016e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00175	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0017d	e8 00 00 00 00	 call	 s390_purge_tlbe
  00182	eb 37		 jmp	 SHORT $LN8@s390_purge
$LN18@s390_purge:

; 123  :             case ARCH_900_IDX: z900_purge_tlbe( sysblk.regs[ cpu ], pfra ); break;

  00184	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00189	48 8b 54 24 58	 mov	 rdx, QWORD PTR pfra$[rsp]
  0018e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00195	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0019d	e8 00 00 00 00	 call	 z900_purge_tlbe
  001a2	eb 17		 jmp	 SHORT $LN8@s390_purge
$LN19@s390_purge:
$LN12@s390_purge:

; 124  :             default: CRASH();

  001a4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  001ad	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  001b2	c6 00 00	 mov	 BYTE PTR [rax], 0
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 e9		 jne	 SHORT $LN12@s390_purge
$LN8@s390_purge:
$LN14@s390_purge:

; 125  :             }
; 126  :         }
; 127  :     }

  001bb	e9 9f fe ff ff	 jmp	 $LN5@s390_purge
$LN6@s390_purge:

; 128  : }

  001c0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c4	c3		 ret	 0
s390_purge_tlbe_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_purge_tlb_all
_TEXT	SEGMENT
cpu$ = 32
tv137 = 36
p$1 = 40
p$2 = 48
regs$ = 80
cpuad$ = 88
s390_purge_tlb_all PROC					; COMDAT

; 69   : {

$LN21:
  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 70   :     int  cpu;
; 71   : 
; 72   :     if (0xFFFF == cpuad && !IS_INTLOCK_HELD( regs ))  // (sanity check)

  0000e	0f b7 44 24 58	 movzx	 eax, WORD PTR cpuad$[rsp]
  00013	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00018	75 35		 jne	 SHORT $LN13@s390_purge
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00034	3b c1		 cmp	 eax, ecx
  00036	74 17		 je	 SHORT $LN13@s390_purge
$LN4@s390_purge:

; 73   :         CRASH();                                      // (logic error!)

  00038	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00041	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00046	c6 00 00	 mov	 BYTE PTR [rax], 0
  00049	33 c0		 xor	 eax, eax
  0004b	85 c0		 test	 eax, eax
  0004d	75 e9		 jne	 SHORT $LN4@s390_purge
$LN13@s390_purge:

; 74   : 
; 75   :     for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  0004f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  00057	eb 0a		 jmp	 SHORT $LN7@s390_purge
$LN5@s390_purge:
  00059	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN7@s390_purge:
  00063	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00070	39 44 24 20	 cmp	 DWORD PTR cpu$[rsp], eax
  00074	0f 8d 31 01 00
	00		 jge	 $LN6@s390_purge

; 76   :     {
; 77   :         if (1
; 78   :             && IS_CPU_ONLINE(cpu)
; 79   :             && (sysblk.regs[ cpu ]->cpubit & sysblk.started_mask)
; 80   :             && (0

  0007a	33 c0		 xor	 eax, eax
  0007c	83 f8 01	 cmp	 eax, 1
  0007f	0f 84 21 01 00
	00		 je	 $LN14@s390_purge
  00085	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00091	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0009a	0f 84 06 01 00
	00		 je	 $LN14@s390_purge
  000a0	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ac	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000bb	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  000c2	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000c6	48 23 c1	 and	 rax, rcx
  000c9	48 85 c0	 test	 rax, rax
  000cc	0f 84 d4 00 00
	00		 je	 $LN14@s390_purge
  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 34		 jne	 SHORT $LN15@s390_purge
  000d8	0f b7 44 24 58	 movzx	 eax, WORD PTR cpuad$[rsp]
  000dd	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  000e2	74 28		 je	 SHORT $LN15@s390_purge
  000e4	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000f0	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000f8	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ff	0f b7 4c 24 58	 movzx	 ecx, WORD PTR cpuad$[rsp]
  00104	3b c1		 cmp	 eax, ecx
  00106	0f 85 9a 00 00
	00		 jne	 $LN14@s390_purge
$LN15@s390_purge:

; 81   :                 || 0xFFFF == cpuad
; 82   :                 || sysblk.regs[ cpu ]->cpuad == cpuad
; 83   :                )
; 84   :         )
; 85   :         {
; 86   :             switch (sysblk.regs[ cpu ]->arch_mode)

  0010c	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00111	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00118	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00120	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00123	89 44 24 24	 mov	 DWORD PTR tv137[rsp], eax
  00127	83 7c 24 24 00	 cmp	 DWORD PTR tv137[rsp], 0
  0012c	74 10		 je	 SHORT $LN16@s390_purge
  0012e	83 7c 24 24 01	 cmp	 DWORD PTR tv137[rsp], 1
  00133	74 24		 je	 SHORT $LN17@s390_purge
  00135	83 7c 24 24 02	 cmp	 DWORD PTR tv137[rsp], 2
  0013a	74 38		 je	 SHORT $LN18@s390_purge
  0013c	eb 51		 jmp	 SHORT $LN19@s390_purge
$LN16@s390_purge:

; 87   :             {
; 88   :             case ARCH_370_IDX: s370_purge_tlb( sysblk.regs[ cpu ]); break;

  0013e	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00143	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0014a	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  00152	e8 00 00 00 00	 call	 s370_purge_tlb
  00157	eb 4d		 jmp	 SHORT $LN8@s390_purge
$LN17@s390_purge:

; 89   :             case ARCH_390_IDX: s390_purge_tlb( sysblk.regs[ cpu ]); break;

  00159	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0015e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00165	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0016d	e8 00 00 00 00	 call	 s390_purge_tlb
  00172	eb 32		 jmp	 SHORT $LN8@s390_purge
$LN18@s390_purge:

; 90   :             case ARCH_900_IDX: z900_purge_tlb( sysblk.regs[ cpu ]); break;

  00174	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00179	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00180	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  00188	e8 00 00 00 00	 call	 z900_purge_tlb
  0018d	eb 17		 jmp	 SHORT $LN8@s390_purge
$LN19@s390_purge:
$LN12@s390_purge:

; 91   :             default: CRASH();

  0018f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  00198	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  0019d	c6 00 00	 mov	 BYTE PTR [rax], 0
  001a0	33 c0		 xor	 eax, eax
  001a2	85 c0		 test	 eax, eax
  001a4	75 e9		 jne	 SHORT $LN12@s390_purge
$LN8@s390_purge:
$LN14@s390_purge:

; 92   :             }
; 93   :         }
; 94   :     }

  001a6	e9 ae fe ff ff	 jmp	 $LN5@s390_purge
$LN6@s390_purge:

; 95   : }

  001ab	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001af	c3		 ret	 0
s390_purge_tlb_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
aste_addr$ = 32
afte_addr$ = 36
i$ = 40
code$ = 44
afte$ = 48
tv87 = 52
tv166 = 56
numwords$ = 60
aste_main$ = 64
asn$ = 96
regs$ = 104
asteo$ = 112
aste$ = 120
s390_translate_asn PROC

; 281  : {

$LN24:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 282  : U32     afte_addr;                      /* Address of AFTE           */
; 283  : U32     afte;                           /* ASN first table entry     */
; 284  : U32     aste_addr;                      /* Address of ASTE           */
; 285  : BYTE   *aste_main;                      /* ASTE mainstor address     */
; 286  : int     code;                           /* Exception code            */
; 287  : int     numwords;                       /* ASTE size (4 or 16 words) */
; 288  : int     i;                              /* Array subscript           */
; 289  : 
; 290  :     /* [3.9.3.1] Use the AFX to obtain the real address of the AFTE */
; 291  :     afte_addr = (regs->CR(14) & CR14_AFTO) << 12;

  00018	b8 08 00 00 00	 mov	 eax, 8
  0001d	48 6b c0 0f	 imul	 rax, rax, 15
  00021	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00026	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0002d	25 ff ff 07 00	 and	 eax, 524287		; 0007ffffH
  00032	c1 e0 0c	 shl	 eax, 12
  00035	89 44 24 24	 mov	 DWORD PTR afte_addr$[rsp], eax

; 292  :     afte_addr += (asn & ASN_AFX) >> 4;

  00039	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  0003e	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00043	c1 f8 04	 sar	 eax, 4
  00046	8b 4c 24 24	 mov	 ecx, DWORD PTR afte_addr$[rsp]
  0004a	03 c8		 add	 ecx, eax
  0004c	8b c1		 mov	 eax, ecx
  0004e	89 44 24 24	 mov	 DWORD PTR afte_addr$[rsp], eax

; 293  : 
; 294  :     /* Addressing exception if AFTE is outside main storage */
; 295  :     if (afte_addr > regs->mainlim)

  00052	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  00056	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  00062	76 05		 jbe	 SHORT $LN7@s390_trans

; 296  :         goto asn_addr_excp;

  00064	e9 b4 02 00 00	 jmp	 $asn_addr_excp$25
$LN7@s390_trans:

; 297  : 
; 298  :     /* Load the AFTE from main storage. All four bytes must be
; 299  :        fetched concurrently as observed by other CPUs */
; 300  :     afte_addr = APPLY_PREFIXING (afte_addr, regs->PX);

  00069	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  0006d	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00073	48 85 c0	 test	 rax, rax
  00076	74 21		 je	 SHORT $LN20@s390_trans
  00078	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  0007c	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00082	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0008a	48 3b c1	 cmp	 rax, rcx
  0008d	74 0a		 je	 SHORT $LN20@s390_trans
  0008f	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  00093	89 44 24 34	 mov	 DWORD PTR tv87[rsp], eax
  00097	eb 14		 jmp	 SHORT $LN21@s390_trans
$LN20@s390_trans:
  00099	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000a1	8b 4c 24 24	 mov	 ecx, DWORD PTR afte_addr$[rsp]
  000a5	33 c8		 xor	 ecx, eax
  000a7	8b c1		 mov	 eax, ecx
  000a9	89 44 24 34	 mov	 DWORD PTR tv87[rsp], eax
$LN21@s390_trans:
  000ad	8b 44 24 34	 mov	 eax, DWORD PTR tv87[rsp]
  000b1	89 44 24 24	 mov	 DWORD PTR afte_addr$[rsp], eax

; 301  :     afte = ARCH_DEP(fetch_fullword_absolute) (afte_addr, regs);

  000b5	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  000b9	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000be	8b c8		 mov	 ecx, eax
  000c0	e8 00 00 00 00	 call	 s390_fetch_fullword_absolute
  000c5	89 44 24 30	 mov	 DWORD PTR afte$[rsp], eax

; 302  : 
; 303  :     /* AFX translation exception if AFTE invalid bit is set */
; 304  :     if (afte & AFTE_INVALID)

  000c9	8b 44 24 30	 mov	 eax, DWORD PTR afte$[rsp]
  000cd	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  000d2	85 c0		 test	 eax, eax
  000d4	74 05		 je	 SHORT $LN8@s390_trans

; 305  :         goto asn_afx_tran_excp;

  000d6	e9 68 02 00 00	 jmp	 $asn_afx_tran_excp$26
$LN8@s390_trans:

; 306  : 
; 307  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 308  :     /* ASN translation specification exception if reserved bits set */
; 309  :     if (!ASF_ENABLED(regs)) {

  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 01	 imul	 rax, rax, 1
  000e4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000e9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000f0	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  000f5	85 c0		 test	 eax, eax
  000f7	75 12		 jne	 SHORT $LN9@s390_trans

; 310  :         if (afte & AFTE_RESV_0)

  000f9	8b 44 24 30	 mov	 eax, DWORD PTR afte$[rsp]
  000fd	83 e0 0f	 and	 eax, 15
  00100	85 c0		 test	 eax, eax
  00102	74 05		 je	 SHORT $LN11@s390_trans

; 311  :               goto asn_asn_tran_spec_excp;

  00104	e9 1e 02 00 00	 jmp	 $asn_asn_tran_spec_excp$27
$LN11@s390_trans:

; 312  :     } else {

  00109	eb 10		 jmp	 SHORT $LN10@s390_trans
$LN9@s390_trans:

; 313  :         if (afte & AFTE_RESV_1)

  0010b	8b 44 24 30	 mov	 eax, DWORD PTR afte$[rsp]
  0010f	83 e0 3f	 and	 eax, 63			; 0000003fH
  00112	85 c0		 test	 eax, eax
  00114	74 05		 je	 SHORT $LN12@s390_trans

; 314  :               goto asn_asn_tran_spec_excp;

  00116	e9 0c 02 00 00	 jmp	 $asn_asn_tran_spec_excp$27
$LN12@s390_trans:
$LN10@s390_trans:

; 315  :     }
; 316  : #endif
; 317  : 
; 318  :     /* [3.9.3.2] Use AFTE and ASX to obtain real address of ASTE */
; 319  :     if (!ASF_ENABLED(regs)) {

  0011b	b8 08 00 00 00	 mov	 eax, 8
  00120	48 6b c0 01	 imul	 rax, rax, 1
  00124	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00129	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00130	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00135	85 c0		 test	 eax, eax
  00137	75 2e		 jne	 SHORT $LN13@s390_trans

; 320  :         aste_addr = afte & AFTE_ASTO_0;

  00139	8b 44 24 30	 mov	 eax, DWORD PTR afte$[rsp]
  0013d	25 f0 ff ff 7f	 and	 eax, 2147483632		; 7ffffff0H
  00142	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 321  :         aste_addr += (asn & ASN_ASX) << 4;

  00146	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  0014b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0014e	c1 e0 04	 shl	 eax, 4
  00151	8b 4c 24 20	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  00155	03 c8		 add	 ecx, eax
  00157	8b c1		 mov	 eax, ecx
  00159	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 322  :         numwords = 4;

  0015d	c7 44 24 3c 04
	00 00 00	 mov	 DWORD PTR numwords$[rsp], 4

; 323  :     } else {

  00165	eb 2c		 jmp	 SHORT $LN14@s390_trans
$LN13@s390_trans:

; 324  :         aste_addr = afte & AFTE_ASTO_1;

  00167	8b 44 24 30	 mov	 eax, DWORD PTR afte$[rsp]
  0016b	25 c0 ff ff 7f	 and	 eax, 2147483584		; 7fffffc0H
  00170	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 325  :         aste_addr += (asn & ASN_ASX) << 6;

  00174	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  00179	83 e0 3f	 and	 eax, 63			; 0000003fH
  0017c	c1 e0 06	 shl	 eax, 6
  0017f	8b 4c 24 20	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  00183	03 c8		 add	 ecx, eax
  00185	8b c1		 mov	 eax, ecx
  00187	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 326  :         numwords = 16;

  0018b	c7 44 24 3c 10
	00 00 00	 mov	 DWORD PTR numwords$[rsp], 16
$LN14@s390_trans:

; 327  :     }
; 328  : 
; 329  :     /* Ignore carry into bit position 0 of ASTO */
; 330  :     aste_addr &= 0x7FFFFFFF;

  00193	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  00197	0f ba f0 1f	 btr	 eax, 31
  0019b	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 331  : 
; 332  :     /* Addressing exception if ASTE is outside main storage */
; 333  :     if (aste_addr > regs->mainlim)

  0019f	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  001a3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001a8	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  001af	76 05		 jbe	 SHORT $LN15@s390_trans

; 334  :         goto asn_addr_excp;

  001b1	e9 67 01 00 00	 jmp	 $asn_addr_excp$25
$LN15@s390_trans:

; 335  : 
; 336  :     /* Return the real address of the ASTE */
; 337  :     *asteo = aste_addr;

  001b6	48 8b 44 24 70	 mov	 rax, QWORD PTR asteo$[rsp]
  001bb	8b 4c 24 20	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  001bf	89 08		 mov	 DWORD PTR [rax], ecx

; 338  : 
; 339  :     /* Fetch the 16- or 64-byte ASN second table entry from real
; 340  :        storage.  Each fullword of the ASTE must be fetched
; 341  :        concurrently as observed by other CPUs */
; 342  :     aste_addr = APPLY_PREFIXING (aste_addr, regs->PX);

  001c1	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  001c5	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  001cb	48 85 c0	 test	 rax, rax
  001ce	74 21		 je	 SHORT $LN22@s390_trans
  001d0	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  001d4	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  001da	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001df	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  001e2	48 3b c1	 cmp	 rax, rcx
  001e5	74 0a		 je	 SHORT $LN22@s390_trans
  001e7	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  001eb	89 44 24 38	 mov	 DWORD PTR tv166[rsp], eax
  001ef	eb 14		 jmp	 SHORT $LN23@s390_trans
$LN22@s390_trans:
  001f1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001f6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001f9	8b 4c 24 20	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  001fd	33 c8		 xor	 ecx, eax
  001ff	8b c1		 mov	 eax, ecx
  00201	89 44 24 38	 mov	 DWORD PTR tv166[rsp], eax
$LN23@s390_trans:
  00205	8b 44 24 38	 mov	 eax, DWORD PTR tv166[rsp]
  00209	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 343  :     aste_main = FETCH_MAIN_ABSOLUTE(aste_addr, regs, numwords * 4);

  0020d	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  00211	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  00216	8b c8		 mov	 ecx, eax
  00218	e8 00 00 00 00	 call	 s390_fetch_main_absolute
  0021d	48 89 44 24 40	 mov	 QWORD PTR aste_main$[rsp], rax

; 344  :     for (i = 0; i < numwords; i++)

  00222	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0022a	eb 0a		 jmp	 SHORT $LN4@s390_trans
$LN2@s390_trans:
  0022c	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00230	ff c0		 inc	 eax
  00232	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_trans:
  00236	8b 44 24 3c	 mov	 eax, DWORD PTR numwords$[rsp]
  0023a	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  0023e	7d 2e		 jge	 SHORT $LN3@s390_trans

; 345  :     {
; 346  :         aste[i] = fetch_fw(aste_main);

  00240	48 8b 4c 24 40	 mov	 rcx, QWORD PTR aste_main$[rsp]
  00245	e8 00 00 00 00	 call	 fetch_fw_noswap
  0024a	8b c8		 mov	 ecx, eax
  0024c	e8 00 00 00 00	 call	 _byteswap_ulong
  00251	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR i$[rsp]
  00256	48 8b 54 24 78	 mov	 rdx, QWORD PTR aste$[rsp]
  0025b	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 347  :         aste_main += 4;

  0025e	48 8b 44 24 40	 mov	 rax, QWORD PTR aste_main$[rsp]
  00263	48 83 c0 04	 add	 rax, 4
  00267	48 89 44 24 40	 mov	 QWORD PTR aste_main$[rsp], rax

; 348  :     }

  0026c	eb be		 jmp	 SHORT $LN2@s390_trans
$LN3@s390_trans:
$LN5@s390_trans:

; 349  :     /* Clear remaining words if fewer than 16 words were loaded */
; 350  :     while (i < 16) aste[i++] = 0;

  0026e	83 7c 24 28 10	 cmp	 DWORD PTR i$[rsp], 16
  00273	7d 1d		 jge	 SHORT $LN6@s390_trans
  00275	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0027a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR aste$[rsp]
  0027f	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0
  00286	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0028a	ff c0		 inc	 eax
  0028c	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  00290	eb dc		 jmp	 SHORT $LN5@s390_trans
$LN6@s390_trans:

; 351  : 
; 352  : 
; 353  :     /* Check the ASX invalid bit in the ASTE */
; 354  :     if (aste[0] & ASTE0_INVALID)

  00292	b8 04 00 00 00	 mov	 eax, 4
  00297	48 6b c0 00	 imul	 rax, rax, 0
  0029b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR aste$[rsp]
  002a0	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  002a3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002a8	85 c0		 test	 eax, eax
  002aa	74 05		 je	 SHORT $LN16@s390_trans

; 355  :         goto asn_asx_tran_excp;

  002ac	e9 b1 00 00 00	 jmp	 $asn_asx_tran_excp$28
$LN16@s390_trans:

; 356  : 
; 357  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 358  :     /* Check the reserved bits in first two words of ASTE */
; 359  :     if ((aste[0] & ASTE0_RESV) || (aste[1] & ASTE1_RESV)
; 360  :         || ((aste[0] & ASTE0_BASE)

  002b1	b8 04 00 00 00	 mov	 eax, 4
  002b6	48 6b c0 00	 imul	 rax, rax, 0
  002ba	48 8b 4c 24 78	 mov	 rcx, QWORD PTR aste$[rsp]
  002bf	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  002c2	83 e0 02	 and	 eax, 2
  002c5	85 c0		 test	 eax, eax
  002c7	75 4e		 jne	 SHORT $LN18@s390_trans
  002c9	b8 04 00 00 00	 mov	 eax, 4
  002ce	48 6b c0 01	 imul	 rax, rax, 1
  002d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR aste$[rsp]
  002d7	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  002da	83 e0 0f	 and	 eax, 15
  002dd	85 c0		 test	 eax, eax
  002df	75 36		 jne	 SHORT $LN18@s390_trans
  002e1	b8 04 00 00 00	 mov	 eax, 4
  002e6	48 6b c0 00	 imul	 rax, rax, 0
  002ea	48 8b 4c 24 78	 mov	 rcx, QWORD PTR aste$[rsp]
  002ef	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  002f2	83 e0 01	 and	 eax, 1
  002f5	85 c0		 test	 eax, eax
  002f7	74 20		 je	 SHORT $LN17@s390_trans
  002f9	b8 08 00 00 00	 mov	 eax, 8
  002fe	48 6b c0 01	 imul	 rax, rax, 1
  00302	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00307	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0030e	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00313	85 c0		 test	 eax, eax
  00315	75 02		 jne	 SHORT $LN17@s390_trans
$LN18@s390_trans:

; 361  : #ifdef FEATURE_SUBSPACE_GROUP
; 362  :             && !ASF_ENABLED(regs)
; 363  : #endif
; 364  :             ))
; 365  :         goto asn_asn_tran_spec_excp;

  00317	eb 0e		 jmp	 SHORT $asn_asn_tran_spec_excp$27
$LN17@s390_trans:

; 366  : #endif
; 367  : 
; 368  :     return 0;

  00319	33 c0		 xor	 eax, eax
  0031b	eb 62		 jmp	 SHORT $LN1@s390_trans
$asn_addr_excp$25:

; 369  : 
; 370  : /* Conditions which always cause program check */
; 371  : asn_addr_excp:
; 372  :     code = PGM_ADDRESSING_EXCEPTION;

  0031d	c7 44 24 2c 05
	00 00 00	 mov	 DWORD PTR code$[rsp], 5

; 373  :     goto asn_prog_check;

  00325	eb 08		 jmp	 SHORT $asn_prog_check$29
$asn_asn_tran_spec_excp$27:

; 374  : 
; 375  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 376  : asn_asn_tran_spec_excp:
; 377  :     code = PGM_ASN_TRANSLATION_SPECIFICATION_EXCEPTION;

  00327	c7 44 24 2c 17
	00 00 00	 mov	 DWORD PTR code$[rsp], 23
$asn_prog_check$29:

; 378  :     goto asn_prog_check;
; 379  : #endif
; 380  : 
; 381  : asn_prog_check:
; 382  :     regs->program_interrupt (regs, code);

  0032f	8b 54 24 2c	 mov	 edx, DWORD PTR code$[rsp]
  00333	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00338	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0033d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$asn_afx_tran_excp$26:

; 383  : 
; 384  : /* Conditions which the caller may or may not program check */
; 385  : asn_afx_tran_excp:
; 386  :     regs->TEA = asn;

  00343	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  00348	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0034d	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 387  :     code = PGM_AFX_TRANSLATION_EXCEPTION;

  00353	c7 44 24 2c 20
	00 00 00	 mov	 DWORD PTR code$[rsp], 32 ; 00000020H

; 388  :     return code;

  0035b	0f b7 44 24 2c	 movzx	 eax, WORD PTR code$[rsp]
  00360	eb 1d		 jmp	 SHORT $LN1@s390_trans
$asn_asx_tran_excp$28:

; 389  : 
; 390  : asn_asx_tran_excp:
; 391  :     regs->TEA = asn;

  00362	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  00367	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0036c	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 392  :     code = PGM_ASX_TRANSLATION_EXCEPTION;

  00372	c7 44 24 2c 21
	00 00 00	 mov	 DWORD PTR code$[rsp], 33 ; 00000021H

; 393  :     return code;

  0037a	0f b7 44 24 2c	 movzx	 eax, WORD PTR code$[rsp]
$LN1@s390_trans:

; 394  : 
; 395  : } /* end function translate_asn */

  0037f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00383	c3		 ret	 0
s390_translate_asn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
alo$ = 32
i$ = 36
cb$ = 40
aste_addr$ = 44
mn$ = 48
tv81 = 56
tv95 = 60
ald$ = 64
tv154 = 68
tv193 = 72
abs$ = 76
all$ = 80
ale$ = 88
__$ArrayPad$ = 104
alet$ = 128
eax$ = 136
acctype$ = 144
regs$ = 152
asteo$ = 160
aste$ = 168
s390_translate_alet PROC

; 440  : {

$LN33:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 441  : U32     cb;                             /* DUCT or PASTE address     */
; 442  : U32     ald;                            /* Access-list designation   */
; 443  : U32     alo;                            /* Access-list origin        */
; 444  : U32     all;                            /* Access-list length        */
; 445  : U32     ale[4];                         /* Access-list entry         */
; 446  : U32     aste_addr;                      /* Real address of ASTE      */
; 447  : U32     abs;                            /* Absolute address          */
; 448  : BYTE   *mn;                             /* Mainstor address          */
; 449  : int     i;                              /* Array subscript           */
; 450  : 
; 451  :     regs->dat.protect = 0;

  00026	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00034	83 e0 f9	 and	 eax, -7			; fffffff9H
  00037	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003f	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 452  : 
; 453  :     /* [5.8.4.3] Check the reserved bits in the ALET */
; 454  :     if ( alet & ALET_RESV )

  00045	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR alet$[rsp]
  0004c	25 00 00 00 fe	 and	 eax, -33554432		; fe000000H
  00051	85 c0		 test	 eax, eax
  00053	74 05		 je	 SHORT $LN8@s390_trans

; 455  :         goto alet_spec_excp;

  00055	e9 1f 05 00 00	 jmp	 $alet_spec_excp$34
$LN8@s390_trans:

; 456  : 
; 457  :     /* [5.8.4.4] Obtain the effective access-list designation */
; 458  : 
; 459  :     /* Obtain the real address of the control block containing
; 460  :        the effective access-list designation.  This is either
; 461  :        the Primary ASTE or the DUCT */
; 462  :     cb = (alet & ALET_PRI_LIST) ?

  0005a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR alet$[rsp]
  00061	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00066	85 c0		 test	 eax, eax
  00068	74 23		 je	 SHORT $LN25@s390_trans
  0006a	b8 08 00 00 00	 mov	 eax, 8
  0006f	48 6b c0 06	 imul	 rax, rax, 6
  00073	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00082	25 c0 ff ff 7f	 and	 eax, 2147483584		; 7fffffc0H
  00087	89 44 24 38	 mov	 DWORD PTR tv81[rsp], eax
  0008b	eb 21		 jmp	 SHORT $LN26@s390_trans
$LN25@s390_trans:
  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 03	 imul	 rax, rax, 3
  00096	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000a5	25 c0 ff ff 7f	 and	 eax, 2147483584		; 7fffffc0H
  000aa	89 44 24 38	 mov	 DWORD PTR tv81[rsp], eax
$LN26@s390_trans:
  000ae	8b 44 24 38	 mov	 eax, DWORD PTR tv81[rsp]
  000b2	89 44 24 28	 mov	 DWORD PTR cb$[rsp], eax

; 463  :             regs->CR(5) & CR5_PASTEO :
; 464  :             regs->CR(2) & CR2_DUCTO;
; 465  : 
; 466  :     /* Addressing exception if outside main storage */
; 467  :     if (cb > regs->mainlim)

  000b6	8b 44 24 28	 mov	 eax, DWORD PTR cb$[rsp]
  000ba	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  000c9	76 05		 jbe	 SHORT $LN9@s390_trans

; 468  :         goto alet_addr_excp;

  000cb	e9 58 04 00 00	 jmp	 $alet_addr_excp$35
$LN9@s390_trans:

; 469  : 
; 470  :     /* Load the effective access-list designation (ALD) from
; 471  :        offset 16 in the control block.  All four bytes must be
; 472  :        fetched concurrently as observed by other CPUs.  Note
; 473  :        that the DUCT and the PASTE cannot cross a page boundary */
; 474  :     cb = APPLY_PREFIXING (cb, regs->PX);

  000d0	8b 44 24 28	 mov	 eax, DWORD PTR cb$[rsp]
  000d4	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000da	48 85 c0	 test	 rax, rax
  000dd	74 24		 je	 SHORT $LN27@s390_trans
  000df	8b 44 24 28	 mov	 eax, DWORD PTR cb$[rsp]
  000e3	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000e9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  000f4	48 3b c1	 cmp	 rax, rcx
  000f7	74 0a		 je	 SHORT $LN27@s390_trans
  000f9	8b 44 24 28	 mov	 eax, DWORD PTR cb$[rsp]
  000fd	89 44 24 3c	 mov	 DWORD PTR tv95[rsp], eax
  00101	eb 17		 jmp	 SHORT $LN28@s390_trans
$LN27@s390_trans:
  00103	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0010e	8b 4c 24 28	 mov	 ecx, DWORD PTR cb$[rsp]
  00112	33 c8		 xor	 ecx, eax
  00114	8b c1		 mov	 eax, ecx
  00116	89 44 24 3c	 mov	 DWORD PTR tv95[rsp], eax
$LN28@s390_trans:
  0011a	8b 44 24 3c	 mov	 eax, DWORD PTR tv95[rsp]
  0011e	89 44 24 28	 mov	 DWORD PTR cb$[rsp], eax

; 475  :     ald = ARCH_DEP(fetch_fullword_absolute) (cb+16, regs);

  00122	8b 44 24 28	 mov	 eax, DWORD PTR cb$[rsp]
  00126	83 c0 10	 add	 eax, 16
  00129	8b c0		 mov	 eax, eax
  0012b	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00133	8b c8		 mov	 ecx, eax
  00135	e8 00 00 00 00	 call	 s390_fetch_fullword_absolute
  0013a	89 44 24 40	 mov	 DWORD PTR ald$[rsp], eax

; 476  : 
; 477  :     /* [5.8.4.5] Access-list lookup */
; 478  : 
; 479  :     /* Isolate the access-list origin and access-list length */
; 480  :     alo = ald & ALD_ALO;

  0013e	8b 44 24 40	 mov	 eax, DWORD PTR ald$[rsp]
  00142	25 80 ff ff 7f	 and	 eax, 2147483520		; 7fffff80H
  00147	89 44 24 20	 mov	 DWORD PTR alo$[rsp], eax

; 481  :     all = ald & ALD_ALL;

  0014b	8b 44 24 40	 mov	 eax, DWORD PTR ald$[rsp]
  0014f	83 e0 7f	 and	 eax, 127		; 0000007fH
  00152	89 44 24 50	 mov	 DWORD PTR all$[rsp], eax

; 482  : 
; 483  :     /* Check that the ALEN does not exceed the ALL */
; 484  :     if (((alet & ALET_ALEN) >> ALD_ALL_SHIFT) > all)

  00156	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR alet$[rsp]
  0015d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00162	c1 e8 03	 shr	 eax, 3
  00165	3b 44 24 50	 cmp	 eax, DWORD PTR all$[rsp]
  00169	76 05		 jbe	 SHORT $LN10@s390_trans

; 485  :         goto alen_tran_excp;

  0016b	e9 31 04 00 00	 jmp	 $alen_tran_excp$36
$LN10@s390_trans:

; 486  : 
; 487  :     /* Add the ALEN x 16 to the access list origin */
; 488  :     alo += (alet & ALET_ALEN) << 4;

  00170	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR alet$[rsp]
  00177	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0017c	c1 e0 04	 shl	 eax, 4
  0017f	8b 4c 24 20	 mov	 ecx, DWORD PTR alo$[rsp]
  00183	03 c8		 add	 ecx, eax
  00185	8b c1		 mov	 eax, ecx
  00187	89 44 24 20	 mov	 DWORD PTR alo$[rsp], eax

; 489  : 
; 490  :     /* Addressing exception if outside main storage */
; 491  :     if (alo > regs->mainlim)

  0018b	8b 44 24 20	 mov	 eax, DWORD PTR alo$[rsp]
  0018f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00197	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  0019e	76 05		 jbe	 SHORT $LN11@s390_trans

; 492  :         goto alet_addr_excp;

  001a0	e9 83 03 00 00	 jmp	 $alet_addr_excp$35
$LN11@s390_trans:

; 493  : 
; 494  :     /* Fetch the 16-byte access list entry from absolute storage.
; 495  :        Each fullword of the ALE must be fetched concurrently as
; 496  :        observed by other CPUs */
; 497  :     alo = APPLY_PREFIXING (alo, regs->PX);

  001a5	8b 44 24 20	 mov	 eax, DWORD PTR alo$[rsp]
  001a9	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  001af	48 85 c0	 test	 rax, rax
  001b2	74 24		 je	 SHORT $LN29@s390_trans
  001b4	8b 44 24 20	 mov	 eax, DWORD PTR alo$[rsp]
  001b8	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  001be	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c6	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  001c9	48 3b c1	 cmp	 rax, rcx
  001cc	74 0a		 je	 SHORT $LN29@s390_trans
  001ce	8b 44 24 20	 mov	 eax, DWORD PTR alo$[rsp]
  001d2	89 44 24 44	 mov	 DWORD PTR tv154[rsp], eax
  001d6	eb 17		 jmp	 SHORT $LN30@s390_trans
$LN29@s390_trans:
  001d8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e0	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001e3	8b 4c 24 20	 mov	 ecx, DWORD PTR alo$[rsp]
  001e7	33 c8		 xor	 ecx, eax
  001e9	8b c1		 mov	 eax, ecx
  001eb	89 44 24 44	 mov	 DWORD PTR tv154[rsp], eax
$LN30@s390_trans:
  001ef	8b 44 24 44	 mov	 eax, DWORD PTR tv154[rsp]
  001f3	89 44 24 20	 mov	 DWORD PTR alo$[rsp], eax

; 498  :     mn = FETCH_MAIN_ABSOLUTE(alo, regs, 16);

  001f7	8b 44 24 20	 mov	 eax, DWORD PTR alo$[rsp]
  001fb	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00203	8b c8		 mov	 ecx, eax
  00205	e8 00 00 00 00	 call	 s390_fetch_main_absolute
  0020a	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 499  :     for (i = 0; i < 4; i++)

  0020f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00217	eb 0a		 jmp	 SHORT $LN4@s390_trans
$LN2@s390_trans:
  00219	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0021d	ff c0		 inc	 eax
  0021f	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_trans:
  00223	83 7c 24 24 04	 cmp	 DWORD PTR i$[rsp], 4
  00228	7d 2a		 jge	 SHORT $LN3@s390_trans

; 500  :     {
; 501  :         ale[i] = fetch_fw (mn);

  0022a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mn$[rsp]
  0022f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00234	8b c8		 mov	 ecx, eax
  00236	e8 00 00 00 00	 call	 _byteswap_ulong
  0023b	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00240	89 44 8c 58	 mov	 DWORD PTR ale$[rsp+rcx*4], eax

; 502  :         mn += 4;

  00244	48 8b 44 24 30	 mov	 rax, QWORD PTR mn$[rsp]
  00249	48 83 c0 04	 add	 rax, 4
  0024d	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 503  :     }

  00252	eb c5		 jmp	 SHORT $LN2@s390_trans
$LN3@s390_trans:

; 504  : 
; 505  :     /* Check the ALEN invalid bit in the ALE */
; 506  :     if (ale[0] & ALE0_INVALID)

  00254	b8 04 00 00 00	 mov	 eax, 4
  00259	48 6b c0 00	 imul	 rax, rax, 0
  0025d	8b 44 04 58	 mov	 eax, DWORD PTR ale$[rsp+rax]
  00261	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00266	85 c0		 test	 eax, eax
  00268	74 05		 je	 SHORT $LN12@s390_trans

; 507  :         goto alen_tran_excp;

  0026a	e9 32 03 00 00	 jmp	 $alen_tran_excp$36
$LN12@s390_trans:

; 508  : 
; 509  :     /* For ordinary ART (but not for special ART),
; 510  :        compare the ALE sequence number with the ALET */
; 511  :     if (!(acctype & ACC_SPECIAL_ART)
; 512  :         && (ale[0] & ALE0_ALESN) != (alet & ALET_ALESN))

  0026f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00276	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0027b	85 c0		 test	 eax, eax
  0027d	75 28		 jne	 SHORT $LN13@s390_trans
  0027f	b8 04 00 00 00	 mov	 eax, 4
  00284	48 6b c0 00	 imul	 rax, rax, 0
  00288	8b 44 04 58	 mov	 eax, DWORD PTR ale$[rsp+rax]
  0028c	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00291	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR alet$[rsp]
  00298	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0029e	3b c1		 cmp	 eax, ecx
  002a0	74 05		 je	 SHORT $LN13@s390_trans

; 513  :         goto ale_seq_excp;

  002a2	e9 22 03 00 00	 jmp	 $ale_seq_excp$37
$LN13@s390_trans:

; 514  : 
; 515  :     /* [5.8.4.6] Locate the ASN-second-table entry */
; 516  :     aste_addr = ale[2] & ALE2_ASTE;

  002a7	b8 04 00 00 00	 mov	 eax, 4
  002ac	48 6b c0 02	 imul	 rax, rax, 2
  002b0	8b 44 04 58	 mov	 eax, DWORD PTR ale$[rsp+rax]
  002b4	25 c0 ff ff 7f	 and	 eax, 2147483584		; 7fffffc0H
  002b9	89 44 24 2c	 mov	 DWORD PTR aste_addr$[rsp], eax

; 517  : 
; 518  :     /* Addressing exception if ASTE is outside main storage */
; 519  :     abs = APPLY_PREFIXING (aste_addr, regs->PX);

  002bd	8b 44 24 2c	 mov	 eax, DWORD PTR aste_addr$[rsp]
  002c1	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  002c7	48 85 c0	 test	 rax, rax
  002ca	74 24		 je	 SHORT $LN31@s390_trans
  002cc	8b 44 24 2c	 mov	 eax, DWORD PTR aste_addr$[rsp]
  002d0	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  002d6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002de	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  002e1	48 3b c1	 cmp	 rax, rcx
  002e4	74 0a		 je	 SHORT $LN31@s390_trans
  002e6	8b 44 24 2c	 mov	 eax, DWORD PTR aste_addr$[rsp]
  002ea	89 44 24 48	 mov	 DWORD PTR tv193[rsp], eax
  002ee	eb 17		 jmp	 SHORT $LN32@s390_trans
$LN31@s390_trans:
  002f0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002f8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  002fb	8b 4c 24 2c	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  002ff	33 c8		 xor	 ecx, eax
  00301	8b c1		 mov	 eax, ecx
  00303	89 44 24 48	 mov	 DWORD PTR tv193[rsp], eax
$LN32@s390_trans:
  00307	8b 44 24 48	 mov	 eax, DWORD PTR tv193[rsp]
  0030b	89 44 24 4c	 mov	 DWORD PTR abs$[rsp], eax

; 520  :     if (abs > regs->mainlim)

  0030f	8b 44 24 4c	 mov	 eax, DWORD PTR abs$[rsp]
  00313	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031b	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  00322	76 05		 jbe	 SHORT $LN14@s390_trans

; 521  :         goto alet_addr_excp;

  00324	e9 ff 01 00 00	 jmp	 $alet_addr_excp$35
$LN14@s390_trans:

; 522  :     mn = FETCH_MAIN_ABSOLUTE(abs, regs, 64);

  00329	8b 44 24 4c	 mov	 eax, DWORD PTR abs$[rsp]
  0032d	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00335	8b c8		 mov	 ecx, eax
  00337	e8 00 00 00 00	 call	 s390_fetch_main_absolute
  0033c	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 523  : 
; 524  :     /* Fetch the 64-byte ASN second table entry from real storage.
; 525  :        Each fullword of the ASTE must be fetched concurrently as
; 526  :        observed by other CPUs.  ASTE cannot cross a page boundary */
; 527  :     for (i = 0; i < 16; i++)

  00341	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00349	eb 0a		 jmp	 SHORT $LN7@s390_trans
$LN5@s390_trans:
  0034b	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0034f	ff c0		 inc	 eax
  00351	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_trans:
  00355	83 7c 24 24 10	 cmp	 DWORD PTR i$[rsp], 16
  0035a	7d 31		 jge	 SHORT $LN6@s390_trans

; 528  :     {
; 529  :         aste[i] = fetch_fw(mn);

  0035c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR mn$[rsp]
  00361	e8 00 00 00 00	 call	 fetch_fw_noswap
  00366	8b c8		 mov	 ecx, eax
  00368	e8 00 00 00 00	 call	 _byteswap_ulong
  0036d	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00372	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR aste$[rsp]
  0037a	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 530  :         mn += 4;

  0037d	48 8b 44 24 30	 mov	 rax, QWORD PTR mn$[rsp]
  00382	48 83 c0 04	 add	 rax, 4
  00386	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 531  :     }

  0038b	eb be		 jmp	 SHORT $LN5@s390_trans
$LN6@s390_trans:

; 532  : 
; 533  :     /* Check the ASX invalid bit in the ASTE */
; 534  :     if (aste[0] & ASTE0_INVALID)

  0038d	b8 04 00 00 00	 mov	 eax, 4
  00392	48 6b c0 00	 imul	 rax, rax, 0
  00396	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR aste$[rsp]
  0039e	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  003a1	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003a6	85 c0		 test	 eax, eax
  003a8	74 05		 je	 SHORT $LN15@s390_trans

; 535  :         goto aste_vald_excp;

  003aa	e9 3f 02 00 00	 jmp	 $aste_vald_excp$38
$LN15@s390_trans:

; 536  : 
; 537  :     /* Compare the ASTE sequence number with the ALE */
; 538  :     if ((aste[5] & ASTE5_ASTESN) != (ale[3] & ALE3_ASTESN))

  003af	b8 04 00 00 00	 mov	 eax, 4
  003b4	48 6b c0 05	 imul	 rax, rax, 5
  003b8	b9 04 00 00 00	 mov	 ecx, 4
  003bd	48 6b c9 03	 imul	 rcx, rcx, 3
  003c1	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR aste$[rsp]
  003c9	8b 4c 0c 58	 mov	 ecx, DWORD PTR ale$[rsp+rcx]
  003cd	39 0c 02	 cmp	 DWORD PTR [rdx+rax], ecx
  003d0	74 05		 je	 SHORT $LN16@s390_trans

; 539  :         goto aste_seq_excp;

  003d2	e9 3c 02 00 00	 jmp	 $aste_seq_excp$39
$LN16@s390_trans:

; 540  : 
; 541  :     /* [5.8.4.7] For ordinary ART (but not for special ART),
; 542  :        authorize the use of the access-list entry */
; 543  :     if (!(acctype & ACC_SPECIAL_ART))

  003d7	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  003de	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  003e3	85 c0		 test	 eax, eax
  003e5	0f 85 e2 00 00
	00		 jne	 $LN17@s390_trans

; 544  :     {
; 545  :         /* If ALE private bit is zero, or the ALE AX equals the
; 546  :            EAX, then authorization succeeds.  Otherwise perform
; 547  :            the extended authorization process. */
; 548  :         if ((ale[0] & ALE0_PRIVATE)
; 549  :                 && (ale[0] & ALE0_ALEAX) != eax)

  003eb	b8 04 00 00 00	 mov	 eax, 4
  003f0	48 6b c0 00	 imul	 rax, rax, 0
  003f4	8b 44 04 58	 mov	 eax, DWORD PTR ale$[rsp+rax]
  003f8	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  003fd	85 c0		 test	 eax, eax
  003ff	0f 84 c8 00 00
	00		 je	 $LN18@s390_trans
  00405	b8 04 00 00 00	 mov	 eax, 4
  0040a	48 6b c0 00	 imul	 rax, rax, 0
  0040e	8b 44 04 58	 mov	 eax, DWORD PTR ale$[rsp+rax]
  00412	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00417	0f b7 8c 24 88
	00 00 00	 movzx	 ecx, WORD PTR eax$[rsp]
  0041f	3b c1		 cmp	 eax, ecx
  00421	0f 84 a6 00 00
	00		 je	 $LN18@s390_trans

; 550  :         {
; 551  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 552  :             /* Check the reserved bits in first two words of ASTE */
; 553  :             if ((aste[0] & ASTE0_RESV) || (aste[1] & ASTE1_RESV)
; 554  :                 || ((aste[0] & ASTE0_BASE)

  00427	b8 04 00 00 00	 mov	 eax, 4
  0042c	48 6b c0 00	 imul	 rax, rax, 0
  00430	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR aste$[rsp]
  00438	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0043b	83 e0 02	 and	 eax, 2
  0043e	85 c0		 test	 eax, eax
  00440	75 57		 jne	 SHORT $LN20@s390_trans
  00442	b8 04 00 00 00	 mov	 eax, 4
  00447	48 6b c0 01	 imul	 rax, rax, 1
  0044b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR aste$[rsp]
  00453	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00456	83 e0 0f	 and	 eax, 15
  00459	85 c0		 test	 eax, eax
  0045b	75 3c		 jne	 SHORT $LN20@s390_trans
  0045d	b8 04 00 00 00	 mov	 eax, 4
  00462	48 6b c0 00	 imul	 rax, rax, 0
  00466	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR aste$[rsp]
  0046e	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00471	83 e0 01	 and	 eax, 1
  00474	85 c0		 test	 eax, eax
  00476	74 26		 je	 SHORT $LN19@s390_trans
  00478	b8 08 00 00 00	 mov	 eax, 8
  0047d	48 6b c0 01	 imul	 rax, rax, 1
  00481	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00489	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00490	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  00495	85 c0		 test	 eax, eax
  00497	75 05		 jne	 SHORT $LN19@s390_trans
$LN20@s390_trans:

; 555  : #ifdef FEATURE_SUBSPACE_GROUP
; 556  :                         && !ASF_ENABLED(regs)
; 557  : #endif
; 558  :                    ))
; 559  :                 goto alet_asn_tran_spec_excp;

  00499	e9 a0 00 00 00	 jmp	 $alet_asn_tran_spec_excp$40
$LN19@s390_trans:

; 560  : #endif
; 561  : 
; 562  :             /* Perform extended authorization */
; 563  :             if (ARCH_DEP(authorize_asn)(eax, aste, ATE_SECONDARY, regs) != 0)

  0049e	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  004a6	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  004ac	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR aste$[rsp]
  004b4	0f b7 8c 24 88
	00 00 00	 movzx	 ecx, WORD PTR eax$[rsp]
  004bc	e8 00 00 00 00	 call	 s390_authorize_asn
  004c1	0f b6 c0	 movzx	 eax, al
  004c4	85 c0		 test	 eax, eax
  004c6	74 05		 je	 SHORT $LN21@s390_trans

; 564  :                 goto ext_auth_excp;

  004c8	e9 6b 01 00 00	 jmp	 $ext_auth_excp$41
$LN21@s390_trans:
$LN18@s390_trans:
$LN17@s390_trans:

; 565  :         }
; 566  : 
; 567  :     } /* end if(!ACC_SPECIAL_ART) */
; 568  : 
; 569  :     /* [5.8.4.8] Check for access-list controlled protection */
; 570  :     if (ale[0] & ALE0_FETCHONLY)

  004cd	b8 04 00 00 00	 mov	 eax, 4
  004d2	48 6b c0 00	 imul	 rax, rax, 0
  004d6	8b 44 04 58	 mov	 eax, DWORD PTR ale$[rsp+rax]
  004da	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  004df	85 c0		 test	 eax, eax
  004e1	74 30		 je	 SHORT $LN22@s390_trans

; 571  :     {
; 572  :         if (acctype & (ACC_WRITE|ACC_CHECK))

  004e3	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  004ea	83 e0 03	 and	 eax, 3
  004ed	85 c0		 test	 eax, eax
  004ef	74 22		 je	 SHORT $LN23@s390_trans

; 573  :             regs->dat.protect = 2;

  004f1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f9	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  004ff	83 e0 f9	 and	 eax, -7			; fffffff9H
  00502	83 c8 04	 or	 eax, 4
  00505	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0050d	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN23@s390_trans:
$LN22@s390_trans:

; 574  :     }
; 575  : 
; 576  :     /* Return the ASTE origin address */
; 577  :     *asteo = aste_addr;

  00513	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR asteo$[rsp]
  0051b	8b 4c 24 2c	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  0051f	89 08		 mov	 DWORD PTR [rax], ecx

; 578  :     return 0;

  00521	33 c0		 xor	 eax, eax
  00523	e9 33 01 00 00	 jmp	 $LN1@s390_trans
$alet_addr_excp$35:

; 579  : 
; 580  : /* Conditions which always cause program check, except
; 581  :    when performing translation for the control panel */
; 582  : alet_addr_excp:
; 583  :     regs->dat.xcode = PGM_ADDRESSING_EXCEPTION;

  00528	b8 05 00 00 00	 mov	 eax, 5
  0052d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00535	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 584  :     goto alet_prog_check;

  0053c	eb 14		 jmp	 SHORT $alet_prog_check$42
$alet_asn_tran_spec_excp$40:

; 585  : 
; 586  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 587  : alet_asn_tran_spec_excp:
; 588  :     regs->dat.xcode = PGM_ASN_TRANSLATION_SPECIFICATION_EXCEPTION;

  0053e	b8 17 00 00 00	 mov	 eax, 23
  00543	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0054b	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax
$alet_prog_check$42:

; 589  :     goto alet_prog_check;
; 590  : #endif
; 591  : 
; 592  : alet_prog_check:
; 593  :     regs->program_interrupt (regs, regs->dat.xcode);

  00552	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0055a	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00561	8b d0		 mov	 edx, eax
  00563	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0056b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00573	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$alet_spec_excp$34:

; 594  : 
; 595  : /* Conditions which the caller may or may not program check */
; 596  : alet_spec_excp:
; 597  :     regs->dat.xcode = PGM_ALET_SPECIFICATION_EXCEPTION;

  00579	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  0057e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00586	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 598  :     return regs->dat.xcode;

  0058d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00595	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  0059c	e9 ba 00 00 00	 jmp	 $LN1@s390_trans
$alen_tran_excp$36:

; 599  : 
; 600  : alen_tran_excp:
; 601  :     regs->dat.xcode = PGM_ALEN_TRANSLATION_EXCEPTION;

  005a1	b8 29 00 00 00	 mov	 eax, 41			; 00000029H
  005a6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ae	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 602  :     return regs->dat.xcode;

  005b5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005bd	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  005c4	e9 92 00 00 00	 jmp	 $LN1@s390_trans
$ale_seq_excp$37:

; 603  : 
; 604  : ale_seq_excp:
; 605  :     regs->dat.xcode = PGM_ALE_SEQUENCE_EXCEPTION;

  005c9	b8 2a 00 00 00	 mov	 eax, 42			; 0000002aH
  005ce	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005d6	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 606  :     return regs->dat.xcode;

  005dd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e5	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  005ec	eb 6d		 jmp	 SHORT $LN1@s390_trans
$aste_vald_excp$38:

; 607  : 
; 608  : aste_vald_excp:
; 609  :     regs->dat.xcode = PGM_ASTE_VALIDITY_EXCEPTION;

  005ee	b8 2b 00 00 00	 mov	 eax, 43			; 0000002bH
  005f3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005fb	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 610  :     return regs->dat.xcode;

  00602	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0060a	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00611	eb 48		 jmp	 SHORT $LN1@s390_trans
$aste_seq_excp$39:

; 611  : 
; 612  : aste_seq_excp:
; 613  :     regs->dat.xcode = PGM_ASTE_SEQUENCE_EXCEPTION;

  00613	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  00618	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00620	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 614  :     return regs->dat.xcode;

  00627	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062f	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00636	eb 23		 jmp	 SHORT $LN1@s390_trans
$ext_auth_excp$41:

; 615  : 
; 616  : ext_auth_excp:
; 617  :     regs->dat.xcode = PGM_EXTENDED_AUTHORITY_EXCEPTION;

  00638	b8 2d 00 00 00	 mov	 eax, 45			; 0000002dH
  0063d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00645	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 618  :     return regs->dat.xcode;

  0064c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00654	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
$LN1@s390_trans:

; 619  : 
; 620  : } /* end function translate_alet */

  0065b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00660	48 33 cc	 xor	 rcx, rsp
  00663	e8 00 00 00 00	 call	 __security_check_cookie
  00668	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0066c	c3		 ret	 0
s390_translate_alet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv130 = 32
pte$ = 40
raddr$ = 48
pfra$ = 56
ibyte$ = 80
pto$ = 88
vaddr$ = 96
regs$ = 104
local$ = 112
s390_invalidate_pte PROC

; 2147 : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_inval:

; 2148 : RADR    raddr;                          /* Addr of Page Table Entry  */
; 2149 : RADR    pte;                            /* Page Table Entry itself   */
; 2150 : RADR    pfra;                           /* Page Frame Real Address   */
; 2151 : 
; 2152 :     UNREFERENCED_370( ibyte );

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@s390_inval

; 2153 : 
; 2154 : #if !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 2155 :     {
; 2156 :         // SYSTEM/370...
; 2157 : 
; 2158 :         /* Program check if translation format is invalid */
; 2159 :         if (0
; 2160 :             || (((regs->CR(0) & CR0_PAGE_SIZE) != CR0_PAGE_SZ_2K) && ((regs->CR(0) & CR0_PAGE_SIZE) != CR0_PAGE_SZ_4K))
; 2161 :             || (((regs->CR(0) & CR0_SEG_SIZE)  != CR0_SEG_SZ_64K) && ((regs->CR(0) & CR0_SEG_SIZE)  != CR0_SEG_SZ_1M))
; 2162 :         )
; 2163 :             regs->program_interrupt( regs, PGM_TRANSLATION_SPECIFICATION_EXCEPTION );
; 2164 : 
; 2165 :         /* Add the vaddr's page table entry index to the Page Table
; 2166 :            Origin, ignoring any carry, to form the 24-bit real address
; 2167 :            of the Page Table Entry to be invalidated, taking into account
; 2168 :            that each Page Table Entry is 2 bytes wide (shift 1 less bit)
; 2169 :         */
; 2170 :         raddr = (pto & SEGTAB_370_PTO) +
; 2171 :         (
; 2172 :             ((regs->CR(0)  & CR0_SEG_SIZE)  == CR0_SEG_SZ_1M)
; 2173 :             ?
; 2174 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 2175 :             ((vaddr & 0x000FF000) >> (SHIFT_4K-1)) : ((vaddr & 0x000FF800) >> (SHIFT_2K-1)))
; 2176 :             :
; 2177 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 2178 :             ((vaddr & 0x0000F000) >> (SHIFT_4K-1)) : ((vaddr & 0x0000F800) >> (SHIFT_2K-1)))
; 2179 :         );
; 2180 :         raddr &= MAXADDRESS;
; 2181 : 
; 2182 :         /* Fetch the Page Table Entry from real storage,
; 2183 :            subject to normal storage protection mechanisms
; 2184 :         */
; 2185 :         pte = ARCH_DEP( vfetch2 )( raddr, USE_REAL_ADDR, regs );
; 2186 : 
; 2187 : #if 0 // debug 370 IPTE
; 2188 :         LOGMSG
; 2189 :         (
; 2190 :             "dat.c: IPTE issued for entry %4.4X at %8.8X...\n"
; 2191 :             "       pto %8.8X, vaddr %8.8X, cr0 %8.8X\n"
; 2192 : 
; 2193 :             , pte, raddr
; 2194 :             , pto, vaddr, regs->CR(0)
; 2195 :         );
; 2196 : #endif
; 2197 : 
; 2198 :         /* Set the invalid bit in the Page Table Entry just fetched */
; 2199 :         pte |= ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_2K)
; 2200 :                ? PAGETAB_INV_2K : PAGETAB_INV_4K;
; 2201 : 
; 2202 :         /* Store the now invalidated Page Table Entry back into
; 2203 :            real storage where we originally got it from, subject
; 2204 :            to the same storage protection mechanisms
; 2205 :         */
; 2206 :         ARCH_DEP( vstore2 )( pte, raddr, USE_REAL_ADDR, regs );
; 2207 : 
; 2208 :         /* Extract the Page Frame Address from the Page Table Entry */
; 2209 :         pfra = ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K)
; 2210 :             ?
; 2211 : #if defined( FEATURE_S370E_EXTENDED_ADDRESSING )
; 2212 :             (((U32)pte & PAGETAB_EA_4K) << 23) |
; 2213 : #endif
; 2214 :             (((U32)pte & PAGETAB_PFRA_4K) << 8)
; 2215 :             :
; 2216 :             (((U32)pte & PAGETAB_PFRA_2K) << 8);
; 2217 :     }
; 2218 : #elif defined( FEATURE_S390_DAT )
; 2219 :     {
; 2220 :         // SYSTEM/390...
; 2221 : 
; 2222 :         /* Program check if translation format is invalid */
; 2223 :         if ((regs->CR(0) & CR0_TRAN_FMT) != CR0_TRAN_ESA390)

  0001d	b8 08 00 00 00	 mov	 eax, 8
  00022	48 6b c0 01	 imul	 rax, rax, 1
  00026	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0002b	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00032	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  00037	3d 00 00 b0 00	 cmp	 eax, 11534336		; 00b00000H
  0003c	74 15		 je	 SHORT $LN5@s390_inval

; 2224 :             regs->program_interrupt( regs, PGM_TRANSLATION_SPECIFICATION_EXCEPTION );

  0003e	ba 12 00 00 00	 mov	 edx, 18
  00043	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN5@s390_inval:

; 2225 : 
; 2226 :         /* Add the vaddr's page table entry index to the Page Table
; 2227 :            Origin, ignoring any carry, to form the 31-bit real address
; 2228 :            of the Page Table Entry to be invalidated, taking into account
; 2229 :            that each Page Table Entry is 4 bytes wide (shift 2 fewer bits)
; 2230 :         */
; 2231 :         raddr = (pto & SEGTAB_PTO) + ((vaddr & 0x000FF000) >> (PAGEFRAME_PAGESHIFT-2));

  00053	48 8b 44 24 58	 mov	 rax, QWORD PTR pto$[rsp]
  00058	48 25 c0 ff ff
	7f		 and	 rax, 2147483584		; 7fffffc0H
  0005e	8b 4c 24 60	 mov	 ecx, DWORD PTR vaddr$[rsp]
  00062	81 e1 00 f0 0f
	00		 and	 ecx, 1044480		; 000ff000H
  00068	c1 e9 0a	 shr	 ecx, 10
  0006b	8b c9		 mov	 ecx, ecx
  0006d	48 03 c1	 add	 rax, rcx
  00070	48 89 44 24 30	 mov	 QWORD PTR raddr$[rsp], rax

; 2232 :         raddr &= MAXADDRESS;

  00075	48 8b 44 24 30	 mov	 rax, QWORD PTR raddr$[rsp]
  0007a	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  00080	48 89 44 24 30	 mov	 QWORD PTR raddr$[rsp], rax

; 2233 : 
; 2234 :         /* Fetch the Page Table Entry from real storage,
; 2235 :            subject to normal storage protection mechanisms */
; 2236 :         pte = ARCH_DEP( vfetch4 )( raddr, USE_REAL_ADDR, regs );

  00085	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  0008a	ba fe ff ff ff	 mov	 edx, -2
  0008f	8b 4c 24 30	 mov	 ecx, DWORD PTR raddr$[rsp]
  00093	e8 00 00 00 00	 call	 s390_vfetch4
  00098	8b c0		 mov	 eax, eax
  0009a	48 89 44 24 28	 mov	 QWORD PTR pte$[rsp], rax

; 2237 : 
; 2238 :         /* Set the invalid bit in the Page Table Entry just fetched */
; 2239 : #if defined( FEATURE_MOVE_PAGE_FACILITY_2 ) && defined( FEATURE_EXPANDED_STORAGE )
; 2240 :         if (ibyte == 0x59) // (IESBE instruction?)

  0009f	0f b6 44 24 50	 movzx	 eax, BYTE PTR ibyte$[rsp]
  000a4	83 f8 59	 cmp	 eax, 89			; 00000059H
  000a7	75 11		 jne	 SHORT $LN6@s390_inval

; 2241 :             pte &= ~PAGETAB_ESVALID;

  000a9	48 8b 44 24 28	 mov	 rax, QWORD PTR pte$[rsp]
  000ae	48 0f ba f0 08	 btr	 rax, 8
  000b3	48 89 44 24 28	 mov	 QWORD PTR pte$[rsp], rax
  000b8	eb 0f		 jmp	 SHORT $LN7@s390_inval
$LN6@s390_inval:

; 2242 :         else
; 2243 : #endif
; 2244 :             pte |= PAGETAB_INVALID; // (no, IPTE instruction)

  000ba	48 8b 44 24 28	 mov	 rax, QWORD PTR pte$[rsp]
  000bf	48 0f ba e8 0a	 bts	 rax, 10
  000c4	48 89 44 24 28	 mov	 QWORD PTR pte$[rsp], rax
$LN7@s390_inval:

; 2245 : 
; 2246 :         /* Store the now invalidated Page Table Entry back into
; 2247 :            real storage where we originally got it from, subject
; 2248 :            to the same storage protection mechanisms
; 2249 :         */
; 2250 :         ARCH_DEP( vstore4 )( pte, raddr, USE_REAL_ADDR, regs );

  000c9	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000ce	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  000d4	8b 54 24 30	 mov	 edx, DWORD PTR raddr$[rsp]
  000d8	8b 4c 24 28	 mov	 ecx, DWORD PTR pte$[rsp]
  000dc	e8 00 00 00 00	 call	 s390_vstore4

; 2251 : 
; 2252 :         /* Extract the Page Frame Address from the Page Table Entry */
; 2253 :         pfra = pte & PAGETAB_PFRA;

  000e1	48 8b 44 24 28	 mov	 rax, QWORD PTR pte$[rsp]
  000e6	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  000ec	48 89 44 24 38	 mov	 QWORD PTR pfra$[rsp], rax

; 2254 :     }
; 2255 : #else /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 2256 :     {
; 2257 :         // ESAME = z/Architecture...
; 2258 : 
; 2259 :         /* Add the vaddr's page table entry index to the Page Table
; 2260 :            Origin, ignoring any carry, to form the 64-bit real address
; 2261 :            of the Page Table Entry to be invalidated, taking into account
; 2262 :            that each Page Table Entry is 8 bytes wide (shift 3 fewer bits)
; 2263 :         */
; 2264 :         raddr = (pto & ZSEGTAB_PTO) + ((vaddr & 0x000FF000) >> (PAGEFRAME_PAGESHIFT-3));
; 2265 :         raddr &= MAXADDRESS;
; 2266 : 
; 2267 :         /* Fetch the Page Table Entry from real storage,
; 2268 :            subject to normal storage protection mechanisms
; 2269 :         */
; 2270 :         pte = ARCH_DEP( vfetch8 )( raddr, USE_REAL_ADDR, regs );
; 2271 : 
; 2272 :         /* Set the invalid bit in the Page Table Entry just fetched */
; 2273 : #if defined( FEATURE_MOVE_PAGE_FACILITY_2 ) && defined( FEATURE_EXPANDED_STORAGE )
; 2274 :         if (ibyte == 0x59) // (IESBE instruction?)
; 2275 :             pte &= ~ZPGETAB_ESVALID;
; 2276 :         else
; 2277 : #endif
; 2278 :             pte |= ZPGETAB_I; // (no, IPTE instruction)
; 2279 : 
; 2280 :         /* Store the now invalidated Page Table Entry back into
; 2281 :            real storage where we originally got it from, subject
; 2282 :            to the same storage protection mechanisms
; 2283 :         */
; 2284 :         ARCH_DEP( vstore8 )( pte, raddr, USE_REAL_ADDR, regs );
; 2285 : 
; 2286 :         /* Extract the Page Frame Address from the Page Table Entry */
; 2287 :         pfra = pte & ZPGETAB_PFRA;
; 2288 :     }
; 2289 : #endif /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 2290 : 
; 2291 :     /* Invalidate all TLB entries for this Page Frame Real Address */
; 2292 :     ARCH_DEP( purge_tlbe_all )( regs, pfra, local ? regs->cpuad : 0xFFFF );

  000f1	0f b6 44 24 70	 movzx	 eax, BYTE PTR local$[rsp]
  000f6	85 c0		 test	 eax, eax
  000f8	74 12		 je	 SHORT $LN9@s390_inval
  000fa	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ff	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00106	89 44 24 20	 mov	 DWORD PTR tv130[rsp], eax
  0010a	eb 08		 jmp	 SHORT $LN10@s390_inval
$LN9@s390_inval:
  0010c	c7 44 24 20 ff
	ff 00 00	 mov	 DWORD PTR tv130[rsp], 65535 ; 0000ffffH
$LN10@s390_inval:
  00114	44 0f b7 44 24
	20		 movzx	 r8d, WORD PTR tv130[rsp]
  0011a	48 8b 54 24 38	 mov	 rdx, QWORD PTR pfra$[rsp]
  0011f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00124	e8 00 00 00 00	 call	 s390_purge_tlbe_all

; 2293 : 
; 2294 : } /* end function invalidate_pte */

  00129	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012d	c3		 ret	 0
s390_invalidate_pte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv74 = 32
tv94 = 36
p$1 = 40
p$2 = 48
regs$ = 80
mask$ = 88
s390_invalidate_tlb PROC

; 1995 : {

$LN24:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1996 :     /* Do it for the current architecture first */
; 1997 :     ARCH_DEP( do_invalidate_tlb )( regs, mask );

  0000d	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  00012	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_do_invalidate_tlb

; 1998 : 
; 1999 : #if defined( _FEATURE_SIE )
; 2000 :     /* Also invalidate the GUEST registers in the SIE copy */
; 2001 :     if (regs->host && GUESTREGS)

  0001c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00021	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00027	c1 e8 07	 shr	 eax, 7
  0002a	83 e0 01	 and	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 a1 00 00
	00		 je	 $LN12@s390_inval
  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0003a	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00042	0f 84 8e 00 00
	00		 je	 $LN12@s390_inval

; 2002 :     {
; 2003 :         switch (GUESTREGS->arch_mode)

  00048	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0004d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00054	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00057	89 44 24 20	 mov	 DWORD PTR tv74[rsp], eax
  0005b	83 7c 24 20 00	 cmp	 DWORD PTR tv74[rsp], 0
  00060	74 10		 je	 SHORT $LN14@s390_inval
  00062	83 7c 24 20 01	 cmp	 DWORD PTR tv74[rsp], 1
  00067	74 21		 je	 SHORT $LN15@s390_inval
  00069	83 7c 24 20 02	 cmp	 DWORD PTR tv74[rsp], 2
  0006e	74 32		 je	 SHORT $LN16@s390_inval
  00070	eb 48		 jmp	 SHORT $LN17@s390_inval
$LN14@s390_inval:

; 2004 :         {
; 2005 :         case ARCH_370_IDX: s370_do_invalidate_tlb( GUESTREGS, mask ); break;

  00072	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  00077	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00083	e8 00 00 00 00	 call	 s370_do_invalidate_tlb
  00088	eb 47		 jmp	 SHORT $LN2@s390_inval
$LN15@s390_inval:

; 2006 :         case ARCH_390_IDX: s390_do_invalidate_tlb( GUESTREGS, mask ); break;

  0008a	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  0008f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00094	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0009b	e8 00 00 00 00	 call	 s390_do_invalidate_tlb
  000a0	eb 2f		 jmp	 SHORT $LN2@s390_inval
$LN16@s390_inval:

; 2007 :         case ARCH_900_IDX: z900_do_invalidate_tlb( GUESTREGS, mask ); break;

  000a2	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  000a7	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  000b3	e8 00 00 00 00	 call	 z900_do_invalidate_tlb
  000b8	eb 17		 jmp	 SHORT $LN2@s390_inval
$LN17@s390_inval:
$LN6@s390_inval:

; 2008 :         default: CRASH();

  000ba	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000c8	c6 00 00	 mov	 BYTE PTR [rax], 0
  000cb	33 c0		 xor	 eax, eax
  000cd	85 c0		 test	 eax, eax
  000cf	75 e9		 jne	 SHORT $LN6@s390_inval
$LN2@s390_inval:

; 2009 :         }
; 2010 :     }

  000d1	e9 a2 00 00 00	 jmp	 $LN13@s390_inval
$LN12@s390_inval:

; 2011 :     else if (regs->guest)  /* For guests, also clear HOST entries */

  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000db	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000e1	c1 e8 08	 shr	 eax, 8
  000e4	83 e0 01	 and	 eax, 1
  000e7	85 c0		 test	 eax, eax
  000e9	0f 84 89 00 00
	00		 je	 $LN18@s390_inval

; 2012 :     {
; 2013 :         switch (HOSTREGS->arch_mode)

  000ef	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000fb	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  000fe	89 44 24 24	 mov	 DWORD PTR tv94[rsp], eax
  00102	83 7c 24 24 00	 cmp	 DWORD PTR tv94[rsp], 0
  00107	74 10		 je	 SHORT $LN19@s390_inval
  00109	83 7c 24 24 01	 cmp	 DWORD PTR tv94[rsp], 1
  0010e	74 21		 je	 SHORT $LN20@s390_inval
  00110	83 7c 24 24 02	 cmp	 DWORD PTR tv94[rsp], 2
  00115	74 32		 je	 SHORT $LN21@s390_inval
  00117	eb 48		 jmp	 SHORT $LN22@s390_inval
$LN19@s390_inval:

; 2014 :         {
; 2015 :         case ARCH_370_IDX: s370_do_invalidate_tlb( HOSTREGS, mask ); break;

  00119	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  0011e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00123	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0012a	e8 00 00 00 00	 call	 s370_do_invalidate_tlb
  0012f	eb 47		 jmp	 SHORT $LN7@s390_inval
$LN20@s390_inval:

; 2016 :         case ARCH_390_IDX: s390_do_invalidate_tlb( HOSTREGS, mask ); break;

  00131	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  00136	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00142	e8 00 00 00 00	 call	 s390_do_invalidate_tlb
  00147	eb 2f		 jmp	 SHORT $LN7@s390_inval
$LN21@s390_inval:

; 2017 :         case ARCH_900_IDX: z900_do_invalidate_tlb( HOSTREGS, mask ); break;

  00149	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  0014e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00153	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0015a	e8 00 00 00 00	 call	 z900_do_invalidate_tlb
  0015f	eb 17		 jmp	 SHORT $LN7@s390_inval
$LN22@s390_inval:
$LN11@s390_inval:

; 2018 :         default: CRASH();

  00161	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  0016a	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  0016f	c6 00 00	 mov	 BYTE PTR [rax], 0
  00172	33 c0		 xor	 eax, eax
  00174	85 c0		 test	 eax, eax
  00176	75 e9		 jne	 SHORT $LN11@s390_inval
$LN7@s390_inval:
$LN18@s390_inval:
$LN13@s390_inval:

; 2019 :         }
; 2020 :     }
; 2021 : #endif /* defined( _FEATURE_SIE ) */
; 2022 : } /* end function invalidate_tlb */

  00178	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017c	c3		 ret	 0
s390_invalidate_tlb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_fetch_fullword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
s390_fetch_fullword_absolute PROC			; COMDAT

; 835  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 836  :     return fetch_fw( FETCH_MAIN_ABSOLUTE( addr, regs, 4 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 s390_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_fw_noswap
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 _byteswap_ulong

; 837  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
s390_fetch_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_fetch_main_absolute
_TEXT	SEGMENT
tv128 = 48
addr$ = 80
regs$ = 88
s390_fetch_main_absolute PROC				; COMDAT

; 524  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_fetch:

; 525  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 526  :     if (addr > (regs->mainlim - len))
; 527  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 528  : #endif
; 529  : 
; 530  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 531  :        is treated as a no-operation if SIE_MODE not active */
; 532  :     SIE_TRANSLATE( &addr, ACCTYPE_READ, regs );

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00019	d1 e8		 shr	 eax, 1
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 ca 00 00
	00		 je	 $LN5@s390_fetch
  00026	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00031	c1 e8 02	 shr	 eax, 2
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	0f 85 b1 00 00
	00		 jne	 $LN5@s390_fetch
  0003f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00044	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0004b	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  0004f	75 44		 jne	 SHORT $LN7@s390_fetch
  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00056	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  0005d	48 03 44 24 50	 add	 rax, QWORD PTR addr$[rsp]
  00062	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  0006b	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00070	41 b9 04 00 00
	00		 mov	 r9d, 4
  00076	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00082	ba fd ff ff ff	 mov	 edx, -3
  00087	8b c8		 mov	 ecx, eax
  00089	e8 00 00 00 00	 call	 s390_logical_to_main_l
  0008e	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
  00093	eb 43		 jmp	 SHORT $LN8@s390_fetch
$LN7@s390_fetch:
  00095	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009a	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  000a1	48 03 44 24 50	 add	 rax, QWORD PTR addr$[rsp]
  000a6	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  000af	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  000b4	41 b9 04 00 00
	00		 mov	 r9d, 4
  000ba	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bf	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  000c6	ba fd ff ff ff	 mov	 edx, -3
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	e8 00 00 00 00	 call	 z900_logical_to_main_l
  000d3	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
$LN8@s390_fetch:
  000d8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e4	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  000eb	48 89 44 24 50	 mov	 QWORD PTR addr$[rsp], rax
$LN5@s390_fetch:
  000f0	33 c0		 xor	 eax, eax
  000f2	85 c0		 test	 eax, eax
  000f4	0f 85 14 ff ff
	ff		 jne	 $LN4@s390_fetch

; 533  : 
; 534  :     /* Set the main storage reference bit */
; 535  :     ARCH_DEP( or_storage_key )( addr, STORKEY_REF );

  000fa	b2 04		 mov	 dl, 4
  000fc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00101	e8 00 00 00 00	 call	 s390_or_storage_key

; 536  : 
; 537  :     /* Return absolute storage mainstor address */
; 538  :     return (regs->mainstor + addr);

  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00112	48 03 44 24 50	 add	 rax, QWORD PTR addr$[rsp]

; 539  : 
; 540  : } /* end function fetch_main_absolute */

  00117	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011b	c3		 ret	 0
s390_fetch_main_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_is_store_protected
_TEXT	SEGMENT
addr$ = 48
skey$ = 56
akey$ = 64
regs$ = 72
s390_is_store_protected PROC				; COMDAT

; 469  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 470  :     /* [3.4.4] Low-address protection prohibits stores into certain
; 471  :        locations in the prefixed storage area of non-private address
; 472  :        address spaces, if the low-address control bit in CR0 is set,
; 473  :        regardless of the access key and storage key */
; 474  :     if (ARCH_DEP( is_low_address_protected )( addr, regs ))

  00016	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  0001b	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  0001f	e8 00 00 00 00	 call	 s390_is_low_address_protected
  00024	0f b6 c0	 movzx	 eax, al
  00027	85 c0		 test	 eax, eax
  00029	74 07		 je	 SHORT $LN2@s390_is_st

; 475  :         return true;

  0002b	b0 01		 mov	 al, 1
  0002d	e9 af 00 00 00	 jmp	 $LN1@s390_is_st
$LN2@s390_is_st:

; 476  : 
; 477  :     /* Access-list controlled protection prohibits all stores into
; 478  :        the address space, and page protection prohibits all stores
; 479  :        into the page, regardless of the access key and storage key */
; 480  :     if (regs->dat.protect)

  00032	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00037	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0003d	d1 e8		 shr	 eax, 1
  0003f	83 e0 03	 and	 eax, 3
  00042	85 c0		 test	 eax, eax
  00044	74 07		 je	 SHORT $LN3@s390_is_st

; 481  :         return true;

  00046	b0 01		 mov	 al, 1
  00048	e9 94 00 00 00	 jmp	 $LN1@s390_is_st
$LN3@s390_is_st:

; 482  : 
; 483  : #if defined( _FEATURE_SIE )
; 484  :     if (SIE_MODE( regs ) && HOSTREGS->dat.protect)

  0004d	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00052	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00058	d1 e8		 shr	 eax, 1
  0005a	83 e0 01	 and	 eax, 1
  0005d	85 c0		 test	 eax, eax
  0005f	74 1f		 je	 SHORT $LN4@s390_is_st
  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00066	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0006d	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00073	d1 e8		 shr	 eax, 1
  00075	83 e0 03	 and	 eax, 3
  00078	85 c0		 test	 eax, eax
  0007a	74 04		 je	 SHORT $LN4@s390_is_st

; 485  :         return true;

  0007c	b0 01		 mov	 al, 1
  0007e	eb 61		 jmp	 SHORT $LN1@s390_is_st
$LN4@s390_is_st:

; 486  : #endif
; 487  : 
; 488  :     /* [3.4.1] Store is allowed if access key is zero, regardless
; 489  :        of the storage key */
; 490  :     if (akey == 0)

  00080	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey$[rsp]
  00085	85 c0		 test	 eax, eax
  00087	75 04		 jne	 SHORT $LN5@s390_is_st

; 491  :         return false;

  00089	32 c0		 xor	 al, al
  0008b	eb 54		 jmp	 SHORT $LN1@s390_is_st
$LN5@s390_is_st:

; 492  : 
; 493  : #if defined( FEATURE_STORAGE_PROTECTION_OVERRIDE )
; 494  :     /* [3.4.1.1] Storage protection override allows access to
; 495  :        locations with storage key 9, regardless of the access key,
; 496  :        provided that CR0 bit 7 is set */
; 497  :     if (1
; 498  :         && (skey & STORKEY_KEY) == 0x90
; 499  :         && (regs->CR(0) & CR0_STORE_OVRD)

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	74 33		 je	 SHORT $LN6@s390_is_st
  00094	0f b6 44 24 38	 movzx	 eax, BYTE PTR skey$[rsp]
  00099	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0009e	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  000a3	75 22		 jne	 SHORT $LN6@s390_is_st
  000a5	b8 08 00 00 00	 mov	 eax, 8
  000aa	48 6b c0 01	 imul	 rax, rax, 1
  000ae	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ba	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000bf	85 c0		 test	 eax, eax
  000c1	74 04		 je	 SHORT $LN6@s390_is_st

; 500  :     )
; 501  :         return false;

  000c3	32 c0		 xor	 al, al
  000c5	eb 1a		 jmp	 SHORT $LN1@s390_is_st
$LN6@s390_is_st:

; 502  : #endif
; 503  : 
; 504  :     /* [3.4.1] Store protection prohibits stores
; 505  :        if the access key does not match the storage key */
; 506  :     if (akey != (skey & STORKEY_KEY))

  000c7	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey$[rsp]
  000cc	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR skey$[rsp]
  000d1	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  000d7	3b c1		 cmp	 eax, ecx
  000d9	74 04		 je	 SHORT $LN7@s390_is_st

; 507  :         return true;

  000db	b0 01		 mov	 al, 1
  000dd	eb 02		 jmp	 SHORT $LN1@s390_is_st
$LN7@s390_is_st:

; 508  : 
; 509  :     return false;      // (location is *NOT* store protected)

  000df	32 c0		 xor	 al, al
$LN1@s390_is_st:

; 510  : 
; 511  : } /* end function is_store_protected */

  000e1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e5	c3		 ret	 0
s390_is_store_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_is_low_address_protected
_TEXT	SEGMENT
addr$ = 8
regs$ = 16
s390_is_low_address_protected PROC			; COMDAT

; 419  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 420  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 421  :     /* For z/Arch, low-address protection applies to locations
; 422  :        0-511 (0000-01FF) and also 4096-4607 (1000-11FF) */
; 423  :     if (addr & 0xFFFFFFFFFFFFEE00ULL)
; 424  : #else
; 425  :     /* For S/370 and ESA/390, low-address protection applies
; 426  :        only to locations 0-511 */
; 427  :     if (addr > 511)

  00009	81 7c 24 08 ff
	01 00 00	 cmp	 DWORD PTR addr$[rsp], 511 ; 000001ffH
  00011	76 04		 jbe	 SHORT $LN2@s390_is_lo

; 428  : #endif
; 429  :         return false;

  00013	32 c0		 xor	 al, al
  00015	eb 50		 jmp	 SHORT $LN1@s390_is_lo
$LN2@s390_is_lo:

; 430  : 
; 431  :     /* Low-address protection applies only if the low-address
; 432  :        protection control bit in control register 0 is set */
; 433  :     if (!(regs->CR(0) & CR0_LOW_PROT))

  00017	b8 08 00 00 00	 mov	 eax, 8
  0001c	48 6b c0 01	 imul	 rax, rax, 1
  00020	48 8b 4c 24 10	 mov	 rcx, QWORD PTR regs$[rsp]
  00025	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0002c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00031	85 c0		 test	 eax, eax
  00033	75 04		 jne	 SHORT $LN3@s390_is_lo

; 434  :         return false;

  00035	32 c0		 xor	 al, al
  00037	eb 2e		 jmp	 SHORT $LN1@s390_is_lo
$LN3@s390_is_lo:

; 435  : 
; 436  : #if defined( _FEATURE_SIE )
; 437  :     /* Host low-address protection is not applied to guest
; 438  :        references to guest storage */
; 439  :     if (regs->sie_active)

  00039	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  0003e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00044	83 e0 01	 and	 eax, 1
  00047	85 c0		 test	 eax, eax
  00049	74 04		 je	 SHORT $LN4@s390_is_lo

; 440  :         return false;

  0004b	32 c0		 xor	 al, al
  0004d	eb 18		 jmp	 SHORT $LN1@s390_is_lo
$LN4@s390_is_lo:

; 441  : #endif
; 442  : 
; 443  :     /* Low-addr protection doesn't apply to private address spaces */
; 444  :     if (regs->dat.pvtaddr)

  0004f	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  00054	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0005a	83 e0 01	 and	 eax, 1
  0005d	85 c0		 test	 eax, eax
  0005f	74 04		 je	 SHORT $LN5@s390_is_lo

; 445  :         return false;

  00061	32 c0		 xor	 al, al
  00063	eb 02		 jmp	 SHORT $LN1@s390_is_lo
$LN5@s390_is_lo:

; 446  : 
; 447  :     return true;      // (location *IS* low-address protected)

  00065	b0 01		 mov	 al, 1
$LN1@s390_is_lo:

; 448  : 
; 449  : } /* end function is_low_address_protected */

  00067	c3		 ret	 0
s390_is_low_address_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_is_fetch_protected
_TEXT	SEGMENT
tv87 = 0
addr$ = 32
skey$ = 40
akey$ = 48
regs$ = 56
s390_is_fetch_protected PROC				; COMDAT

; 365  : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 18	 sub	 rsp, 24
$LN4@s390_is_fe:

; 366  :     UNREFERENCED_370( addr );

  00016	33 c0		 xor	 eax, eax
  00018	85 c0		 test	 eax, eax
  0001a	75 fa		 jne	 SHORT $LN4@s390_is_fe
$LN7@s390_is_fe:

; 367  :     UNREFERENCED_370( regs );

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN7@s390_is_fe

; 368  : 
; 369  :     /* [3.4.1] Fetch is allowed if access key is zero, regardless
; 370  :        of the storage key and fetch protection bit */
; 371  :     /* [3.4.1] Fetch protection prohibits fetch if storage key fetch
; 372  :        protect bit is on and access key does not match storage key */
; 373  :     if (likely(0

  00022	33 c0		 xor	 eax, eax
  00024	85 c0		 test	 eax, eax
  00026	75 32		 jne	 SHORT $LN12@s390_is_fe
  00028	0f b6 44 24 30	 movzx	 eax, BYTE PTR akey$[rsp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 29		 je	 SHORT $LN12@s390_is_fe
  00031	0f b6 44 24 30	 movzx	 eax, BYTE PTR akey$[rsp]
  00036	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR skey$[rsp]
  0003b	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00041	3b c1		 cmp	 eax, ecx
  00043	74 15		 je	 SHORT $LN12@s390_is_fe
  00045	0f b6 44 24 28	 movzx	 eax, BYTE PTR skey$[rsp]
  0004a	83 e0 08	 and	 eax, 8
  0004d	85 c0		 test	 eax, eax
  0004f	74 09		 je	 SHORT $LN12@s390_is_fe
  00051	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv87[rsp], 0
  00058	eb 07		 jmp	 SHORT $LN15@s390_is_fe
$LN12@s390_is_fe:
  0005a	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv87[rsp], 1
$LN15@s390_is_fe:
  00061	83 3c 24 00	 cmp	 DWORD PTR tv87[rsp], 0
  00065	74 07		 je	 SHORT $LN8@s390_is_fe

; 374  :                || akey == 0
; 375  :                || akey == (skey & STORKEY_KEY)
; 376  :                || !(skey & STORKEY_FETCH)
; 377  :               )
; 378  :     )
; 379  :         return false;

  00067	32 c0		 xor	 al, al
  00069	e9 81 00 00 00	 jmp	 $LN1@s390_is_fe
$LN8@s390_is_fe:

; 380  : 
; 381  : #if defined( FEATURE_FETCH_PROTECTION_OVERRIDE )
; 382  :     /* [3.4.1.2] Fetch protection override allows fetch from first
; 383  :        2K of non-private address spaces if CR0 bit 6 is set */
; 384  :     if (1
; 385  :         && addr < 2048
; 386  :         && (regs->CR(0) & CR0_FETCH_OVRD)
; 387  :         && regs->dat.pvtaddr == 0

  0006e	33 c0		 xor	 eax, eax
  00070	83 f8 01	 cmp	 eax, 1
  00073	74 3e		 je	 SHORT $LN9@s390_is_fe
  00075	81 7c 24 20 00
	08 00 00	 cmp	 DWORD PTR addr$[rsp], 2048 ; 00000800H
  0007d	73 34		 jae	 SHORT $LN9@s390_is_fe
  0007f	b8 08 00 00 00	 mov	 eax, 8
  00084	48 6b c0 01	 imul	 rax, rax, 1
  00088	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0008d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00094	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00099	85 c0		 test	 eax, eax
  0009b	74 16		 je	 SHORT $LN9@s390_is_fe
  0009d	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000a2	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  000a8	83 e0 01	 and	 eax, 1
  000ab	85 c0		 test	 eax, eax
  000ad	75 04		 jne	 SHORT $LN9@s390_is_fe

; 388  :     )
; 389  :         return false;

  000af	32 c0		 xor	 al, al
  000b1	eb 3c		 jmp	 SHORT $LN1@s390_is_fe
$LN9@s390_is_fe:

; 390  : #endif
; 391  : 
; 392  : #if defined( FEATURE_STORAGE_PROTECTION_OVERRIDE )
; 393  :     /* [3.4.1.1] Storage protection override allows access to
; 394  :        locations with storage key 9, regardless of the access key,
; 395  :        provided that CR0 bit 7 is set */
; 396  :     if (1
; 397  :         && (skey & STORKEY_KEY) == 0x90
; 398  :         && (regs->CR(0) & CR0_STORE_OVRD)

  000b3	33 c0		 xor	 eax, eax
  000b5	83 f8 01	 cmp	 eax, 1
  000b8	74 33		 je	 SHORT $LN10@s390_is_fe
  000ba	0f b6 44 24 28	 movzx	 eax, BYTE PTR skey$[rsp]
  000bf	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000c4	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  000c9	75 22		 jne	 SHORT $LN10@s390_is_fe
  000cb	b8 08 00 00 00	 mov	 eax, 8
  000d0	48 6b c0 01	 imul	 rax, rax, 1
  000d4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  000d9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000e0	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 04		 je	 SHORT $LN10@s390_is_fe

; 399  :     )
; 400  :         return false;

  000e9	32 c0		 xor	 al, al
  000eb	eb 02		 jmp	 SHORT $LN1@s390_is_fe
$LN10@s390_is_fe:

; 401  : #endif
; 402  : 
; 403  :     return true;    // (location *IS* fetch protected)

  000ed	b0 01		 mov	 al, 1
$LN1@s390_is_fe:

; 404  : 
; 405  : } /* end function is_fetch_protected */

  000ef	48 83 c4 18	 add	 rsp, 24
  000f3	c3		 ret	 0
s390_is_fetch_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key_by_ptr
_TEXT	SEGMENT
abs$ = 32
skey_ptr$ = 64
bits$ = 72
s390_or_storage_key_by_ptr PROC				; COMDAT

; 328  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 329  :     U64 abs = (skey_ptr - sysblk.storkeys) << _STORKEY_ARRAY_SHIFTAMT;

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00014	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR skey_ptr$[rsp]
  00020	48 2b c8	 sub	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx
  00026	48 c1 e0 0b	 shl	 rax, 11
  0002a	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 330  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 331  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 332  : #else
; 333  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0002f	0f b6 54 24 48	 movzx	 edx, BYTE PTR bits$[rsp]
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  00039	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 334  : #endif
; 335  : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
s390_or_storage_key_by_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_storekey_by_ptr
_TEXT	SEGMENT
abs$ = 32
skey_ptr$ = 64
s390_get_storekey_by_ptr PROC				; COMDAT

; 317  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 318  :     U64 abs = (skey_ptr - sysblk.storkeys) << _STORKEY_ARRAY_SHIFTAMT;

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR skey_ptr$[rsp]
  0001c	48 2b c8	 sub	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 c1 e0 0b	 shl	 rax, 11
  00026	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 319  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 320  :     return ARCH_DEP( get_2K_storage_key )( abs );
; 321  : #else
; 322  :     return ARCH_DEP( get_4K_storage_key )( abs );

  0002b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  00030	e8 00 00 00 00	 call	 s390_get_4K_storage_key

; 323  : #endif
; 324  : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
s390_get_storekey_by_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_ptr_to_storekey
_TEXT	SEGMENT
abs$ = 48
s390_get_ptr_to_storekey PROC				; COMDAT

; 308  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 309  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 310  :     return ARCH_DEP( get_ptr_to_2K_storekey )( abs );
; 311  : #else
; 312  :     return ARCH_DEP( get_ptr_to_4K_storekey )( abs );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0000e	e8 00 00 00 00	 call	 s390_get_ptr_to_4K_storekey

; 313  : #endif
; 314  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
s390_get_ptr_to_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
s390_get_4K_storage_key PROC				; COMDAT

; 239  :   inline BYTE  ARCH_DEP( get_4K_storage_key )     (              U64 abs            ) { return ARCH_DEP( _get_storage_key     )(      abs, 4 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 04		 mov	 dl, 4
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 s390__get_storage_key
  00015	0f b6 c0	 movzx	 eax, al
  00018	83 e0 fe	 and	 eax, -2
  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
s390_get_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_ptr_to_4K_storekey
_TEXT	SEGMENT
abs$ = 48
s390_get_ptr_to_4K_storekey PROC			; COMDAT

; 238  :   inline BYTE* ARCH_DEP( get_ptr_to_4K_storekey ) (              U64 abs            ) { return           _get_storekey_ptr     (      abs, 4 );                         }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 04		 mov	 dl, 4
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 _get_storekey_ptr
  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
s390_get_ptr_to_4K_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__get_storage_key
_TEXT	SEGMENT
skey$ = 32
abs$ = 64
K$ = 72
s390__get_storage_key PROC				; COMDAT

; 130  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s390__get_:

; 131  :     BYTE skey;
; 132  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 fa		 jne	 SHORT $LN4@s390__get_

; 133  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	74 32		 je	 SHORT $LN5@s390__get_

; 134  :     {
; 135  :         skey  = *_get_storekey1_ptr( abs );

  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0001e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00023	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00026	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 136  :         skey |= *_get_storekey2_ptr( abs ) & ~(STORKEY_KEY);

  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0002f	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00034	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00037	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  0003c	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  00041	0b c8		 or	 ecx, eax
  00043	8b c1		 mov	 eax, ecx
  00045	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 137  :     }

  00049	eb 16		 jmp	 SHORT $LN6@s390__get_
$LN5@s390__get_:

; 138  :     else
; 139  :         skey  = *_get_storekey_ptr(  abs, K );

  0004b	0f b6 54 24 48	 movzx	 edx, BYTE PTR K$[rsp]
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00055	e8 00 00 00 00	 call	 _get_storekey_ptr
  0005a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005d	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@s390__get_:

; 140  :     return skey;

  00061	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 141  : }

  00066	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006a	c3		 ret	 0
s390__get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv65 = 0
tv69 = 4
arn$ = 32
regs$ = 40
acctype$ = 48
s370_load_address_space_designator PROC

; 670  : {

$LN19:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24
$LN4@s370_load_:

; 671  : #if defined( FEATURE_ACCESS_REGISTERS )
; 672  : U32     alet;                           /* Access list entry token   */
; 673  : U32     asteo;                          /* Real address of ASTE      */
; 674  : U32     aste[16];                       /* ASN second table entry    */
; 675  : U16     eax;                            /* Authorization index       */
; 676  : #else
; 677  :     UNREFERENCED( acctype );

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370_load_

; 678  : #endif
; 679  : 
; 680  :     switch(arn) {

  00018	8b 44 24 20	 mov	 eax, DWORD PTR arn$[rsp]
  0001c	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  0001f	83 3c 24 fb	 cmp	 DWORD PTR tv65[rsp], -5
  00023	0f 84 0b 01 00
	00		 je	 $LN14@s370_load_
  00029	83 3c 24 fc	 cmp	 DWORD PTR tv65[rsp], -4
  0002d	0f 84 cc 00 00
	00		 je	 $LN13@s370_load_
  00033	83 3c 24 fd	 cmp	 DWORD PTR tv65[rsp], -3
  00037	0f 84 8d 00 00
	00		 je	 $LN12@s370_load_
  0003d	83 3c 24 fe	 cmp	 DWORD PTR tv65[rsp], -2
  00041	0f 84 22 01 00
	00		 je	 $LN15@s370_load_
  00047	83 3c 24 ff	 cmp	 DWORD PTR tv65[rsp], -1
  0004b	74 05		 je	 SHORT $LN9@s370_load_
  0004d	e9 39 01 00 00	 jmp	 $LN16@s370_load_
$LN9@s370_load_:

; 681  : 
; 682  :     case USE_INST_SPACE:
; 683  :         switch(regs->AEA_AR(USE_INST_SPACE)) {

  00052	b8 04 00 00 00	 mov	 eax, 4
  00057	48 6b c0 04	 imul	 rax, rax, 4
  0005b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00067	89 44 24 04	 mov	 DWORD PTR tv69[rsp], eax
  0006b	83 7c 24 04 01	 cmp	 DWORD PTR tv69[rsp], 1
  00070	74 02		 je	 SHORT $LN10@s370_load_
  00072	eb 11		 jmp	 SHORT $LN11@s370_load_
$LN10@s370_load_:

; 684  : 
; 685  :         case 1:
; 686  :             regs->dat.stid = TEA_ST_PRIMARY;

  00074	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00079	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 687  :             break;

  00083	eb 0f		 jmp	 SHORT $LN7@s370_load_
$LN11@s370_load_:

; 688  : #if defined( FEATURE_LINKAGE_STACK )
; 689  :         case 13:
; 690  :             regs->dat.stid = TEA_ST_HOME;
; 691  :             break;
; 692  : #endif
; 693  :         default:
; 694  :             regs->dat.stid = 0;

  00085	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0
$LN7@s370_load_:

; 695  :         } /* end switch(regs->AEA_AR(USE_INST_SPACE)) */
; 696  : 
; 697  :         regs->dat.asd = regs->CR(regs->AEA_AR(USE_INST_SPACE));

  00094	b8 04 00 00 00	 mov	 eax, 4
  00099	48 6b c0 04	 imul	 rax, rax, 4
  0009d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000a2	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  000a9	ff c0		 inc	 eax
  000ab	48 98		 cdqe
  000ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000b2	8b 84 c1 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+1536]
  000b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000be	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 698  :         break;

  000c5	e9 33 01 00 00	 jmp	 $LN5@s370_load_
$LN12@s370_load_:

; 699  : 
; 700  :     case USE_PRIMARY_SPACE:
; 701  :         regs->dat.stid = TEA_ST_PRIMARY;

  000ca	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  000cf	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 702  :         regs->dat.asd = regs->CR(1);

  000d9	b8 08 00 00 00	 mov	 eax, 8
  000de	48 6b c0 02	 imul	 rax, rax, 2
  000e2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ee	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  000f3	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 703  :         break;

  000fa	e9 fe 00 00 00	 jmp	 $LN5@s370_load_
$LN13@s370_load_:

; 704  : 
; 705  :     case USE_SECONDARY_SPACE:
; 706  :         regs->dat.stid = TEA_ST_SECNDRY;

  000ff	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00104	c7 80 20 08 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+2080], 2

; 707  :         regs->dat.asd = regs->CR(7);

  0010e	b8 08 00 00 00	 mov	 eax, 8
  00113	48 6b c0 08	 imul	 rax, rax, 8
  00117	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  0011c	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00123	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  00128	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 708  :         break;

  0012f	e9 c9 00 00 00	 jmp	 $LN5@s370_load_
$LN14@s370_load_:

; 709  : 
; 710  :     case USE_HOME_SPACE:
; 711  :         regs->dat.stid = TEA_ST_HOME;

  00134	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00139	c7 80 20 08 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+2080], 3

; 712  :         regs->dat.asd = regs->CR(13);

  00143	b8 08 00 00 00	 mov	 eax, 8
  00148	48 6b c0 0e	 imul	 rax, rax, 14
  0014c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  00151	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00158	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  0015d	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 713  :         break;

  00164	e9 94 00 00 00	 jmp	 $LN5@s370_load_
$LN15@s370_load_:

; 714  : 
; 715  :     case USE_REAL_ADDR:
; 716  :         regs->dat.stid = 0;

  00169	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 717  :         regs->dat.asd = TLB_REAL_ASD;

  00178	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  0017d	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00182	48 89 88 18 08
	00 00		 mov	 QWORD PTR [rax+2072], rcx

; 718  :         break;

  00189	eb 72		 jmp	 SHORT $LN5@s370_load_
$LN16@s370_load_:

; 719  : 
; 720  :     default:
; 721  : 
; 722  : #if defined( FEATURE_ACCESS_REGISTERS )
; 723  :         if (ACCESS_REGISTER_MODE(&regs->psw)
; 724  :          || (SIE_ACTIVE(regs) && MULTIPLE_CONTROLLED_DATA_SPACE(GUESTREGS))
; 725  :          || (arn >= USE_ARMODE)
; 726  :            )
; 727  :         {
; 728  :             /* Remove flags giving access register number 0-15 */
; 729  :             arn &= 0xF;
; 730  : 
; 731  :             /* [5.8.4.1] Select the access-list-entry token */
; 732  :             alet = (arn == 0) ? 0 :
; 733  :                    /* Guest ALET if XC guest in AR mode */
; 734  :                    (SIE_ACTIVE(regs) && MULTIPLE_CONTROLLED_DATA_SPACE(GUESTREGS))
; 735  :                    ? GUESTREGS->AR(arn) :
; 736  :                    /* If SIE host but not XC guest in AR mode then alet is 0 */
; 737  :                    SIE_ACTIVE(regs) ? 0 :
; 738  :                    /* Otherwise alet is in the access register */
; 739  :                    regs->AR(arn);
; 740  : 
; 741  :             /* Use the ALET to determine the segment table origin */
; 742  :             switch (alet) {
; 743  : 
; 744  :             case ALET_PRIMARY:
; 745  :                 /* [5.8.4.2] Obtain primary segment table designation */
; 746  :                 regs->dat.stid = TEA_ST_PRIMARY;
; 747  :                 regs->dat.asd = regs->CR(1);
; 748  :                 break;
; 749  : 
; 750  :             case ALET_SECONDARY:
; 751  :                 /* [5.8.4.2] Obtain secondary segment table designation */
; 752  :                 regs->dat.stid = TEA_ST_SECNDRY;
; 753  :                 regs->dat.asd = regs->CR(7);
; 754  :                 break;
; 755  : 
; 756  :             default:
; 757  :                 /* ALB Lookup */
; 758  :                 if(regs->AEA_AR(arn) >= CR_ALB_OFFSET)
; 759  :                 {
; 760  :                     regs->dat.asd = regs->CR(regs->AEA_AR(arn));
; 761  :                     regs->dat.protect = regs->aea_aleprot[arn];
; 762  :                     regs->dat.stid = TEA_ST_ARMODE;
; 763  :                 }
; 764  :                 else
; 765  :                 {
; 766  :                     /* Extract the extended AX from CR8 bits 0-15 (32-47) */
; 767  :                     eax = regs->CR_LHH(8);
; 768  : 
; 769  :                     /* [5.8.4.3] Perform ALET translation to obtain ASTE */
; 770  :                     if (ARCH_DEP(translate_alet) (alet, eax, acctype,
; 771  :                                                   regs, &asteo, aste))
; 772  :                         /* Exit if ALET translation error */
; 773  :                         return regs->dat.xcode;
; 774  : 
; 775  :                     /* [5.8.4.9] Obtain the STD or ASCE from the ASTE */
; 776  :                     regs->dat.asd = ASTE_AS_DESIGNATOR(aste);
; 777  :                     regs->dat.stid = TEA_ST_ARMODE;
; 778  : 
; 779  :                     if (regs->dat.protect & 2)
; 780  :                     {
; 781  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 782  :                        regs->dat.asd ^= ASCE_RESV;
; 783  :                        regs->dat.asd |= ASCE_P;
; 784  : #else
; 785  :                        regs->dat.asd ^= STD_RESV;
; 786  :                        regs->dat.asd |= STD_PRIVATE;
; 787  : #endif
; 788  :                     }
; 789  : 
; 790  :                     /* Update ALB */
; 791  :                     regs->CR(CR_ALB_OFFSET + arn) = regs->dat.asd;
; 792  :                     regs->AEA_AR(arn) = CR_ALB_OFFSET + arn;
; 793  :                     regs->AEA_COMMON(CR_ALB_OFFSET + arn) = (regs->dat.asd & ASD_PRIVATE) == 0;
; 794  :                     regs->aea_aleprot[arn] = regs->dat.protect & 2;
; 795  :                 }
; 796  : 
; 797  :             } /* end switch(alet) */
; 798  : 
; 799  :             break;
; 800  : 
; 801  :         } /* end if(ACCESS_REGISTER_MODE) */
; 802  : #endif /* defined( FEATURE_ACCESS_REGISTERS ) */
; 803  : 
; 804  : #if defined( FEATURE_DUAL_ADDRESS_SPACE )
; 805  :         if (SECONDARY_SPACE_MODE(&regs->psw))

  0018b	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  00190	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00194	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00199	75 32		 jne	 SHORT $LN17@s370_load_

; 806  :         {
; 807  :             regs->dat.stid = TEA_ST_SECNDRY;

  0019b	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  001a0	c7 80 20 08 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+2080], 2

; 808  :             regs->dat.asd = regs->CR(7);

  001aa	b8 08 00 00 00	 mov	 eax, 8
  001af	48 6b c0 08	 imul	 rax, rax, 8
  001b3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  001b8	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  001bf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  001c4	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 809  :             break;

  001cb	eb 30		 jmp	 SHORT $LN5@s370_load_
$LN17@s370_load_:

; 810  :         }
; 811  : #endif
; 812  : 
; 813  : #if defined( FEATURE_LINKAGE_STACK )
; 814  :         if (HOME_SPACE_MODE(&regs->psw))
; 815  :         {
; 816  :             regs->dat.stid = TEA_ST_HOME;
; 817  :             regs->dat.asd = regs->CR(13);
; 818  :             break;
; 819  :         }
; 820  : #endif
; 821  : 
; 822  :         /* Primary space mode */
; 823  :         regs->dat.stid = TEA_ST_PRIMARY;

  001cd	48 8b 44 24 28	 mov	 rax, QWORD PTR regs$[rsp]
  001d2	c7 80 20 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+2080], 0

; 824  :         regs->dat.asd = regs->CR(1);

  001dc	b8 08 00 00 00	 mov	 eax, 8
  001e1	48 6b c0 02	 imul	 rax, rax, 2
  001e5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  001ea	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  001f1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR regs$[rsp]
  001f6	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax
$LN5@s370_load_:

; 825  :         break;
; 826  : 
; 827  :     } /* switch(arn) */
; 828  : 
; 829  :     return 0;

  001fd	33 c0		 xor	 eax, eax

; 830  : 
; 831  : } /* end function load_address_space_designator */

  001ff	48 83 c4 18	 add	 rsp, 24
  00203	c3		 ret	 0
s370_load_address_space_designator ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch2
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv80 = 56
tv92 = 60
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch2 PROC					; COMDAT

; 679  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 680  :     if (likely(!((VADR_L)addr & 0x01))
; 681  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK ))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 01	 and	 eax, 1
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN9@s370_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN10@s370_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN13@s370_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN14@s370_vfetc
$LN13@s370_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN14@s370_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 14		 jne	 SHORT $LN6@s370_vfetc
  0004e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00057	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  0005c	0f 84 9a 00 00
	00		 je	 $LN5@s370_vfetc
$LN6@s370_vfetc:
$LN4@s370_vfetc:

; 682  :     {
; 683  :         BYTE *mn;
; 684  :         ITIMER_SYNC( addr, 2-1, regs );

  00062	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00067	73 0a		 jae	 SHORT $LN17@s370_vfetc
  00069	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN18@s370_vfetc
$LN17@s370_vfetc:
  00073	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@s370_vfetc:
  0007b	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00080	74 15		 je	 SHORT $LN19@s370_vfetc
  00082	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00086	ff c0		 inc	 eax
  00088	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008b	72 0a		 jb	 SHORT $LN19@s370_vfetc
  0008d	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00095	eb 08		 jmp	 SHORT $LN25@s370_vfetc
$LN19@s370_vfetc:
  00097	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN25@s370_vfetc:
  0009f	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000a4	74 0a		 je	 SHORT $LN7@s370_vfetc
  000a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b0	33 c0		 xor	 eax, eax
  000b2	85 c0		 test	 eax, eax
  000b4	75 ac		 jne	 SHORT $LN4@s370_vfetc

; 685  :         mn = MADDRL( addr, 2,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b6	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000bb	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  000bf	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000c3	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cb	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000d0	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000d5	ba 02 00 00 00	 mov	 edx, 2
  000da	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000de	e8 00 00 00 00	 call	 s370_maddr_l
  000e3	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 686  :         return fetch_hw( mn );

  000e8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ed	e8 00 00 00 00	 call	 fetch_hw_noswap
  000f2	0f b7 c8	 movzx	 ecx, ax
  000f5	e8 00 00 00 00	 call	 _byteswap_ushort
  000fa	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 687  :     }
; 688  :     return ARCH_DEP( vfetch2_full )( addr, arn, regs );

  000fc	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00101	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00105	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  00109	e8 00 00 00 00	 call	 s370_vfetch2_full
$LN1@s370_vfetc:

; 689  : }

  0010e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00112	c3		 ret	 0
s370_vfetch2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore2
_TEXT	SEGMENT
tv73 = 48
tv91 = 52
tv135 = 56
mn$1 = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
s370_vstore2 PROC					; COMDAT

; 541  : {

$LN24:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 542  :     /* Most common case : Aligned & not crossing page boundary */
; 543  :     if (likely(!((VADR_L)addr & 1)

  00017	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 1a		 je	 SHORT $LN9@s370_vstor
  00022	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002b	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  00030	75 0a		 jne	 SHORT $LN9@s370_vstor
  00032	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  0003a	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN9@s370_vstor:
  0003c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
$LN12@s370_vstor:
  00044	83 7c 24 30 00	 cmp	 DWORD PTR tv73[rsp], 0
  00049	0f 84 9f 00 00
	00		 je	 $LN5@s370_vstor

; 544  :         || ((VADR_L)addr & PAGEFRAME_BYTEMASK) != PAGEFRAME_BYTEMASK))
; 545  :     {
; 546  :         BYTE* mn;
; 547  :         mn = MADDRL( addr, 2, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  0004f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00054	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00058	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0005c	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00064	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00069	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  0006e	ba 02 00 00 00	 mov	 edx, 2
  00073	8b 4c 24 68	 mov	 ecx, DWORD PTR addr$[rsp]
  00077	e8 00 00 00 00	 call	 s370_maddr_l
  0007c	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 548  :         STORE_HW( mn, value );

  00081	0f b7 4c 24 60	 movzx	 ecx, WORD PTR value$[rsp]
  00086	e8 00 00 00 00	 call	 _byteswap_ushort
  0008b	0f b7 d0	 movzx	 edx, ax
  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  00093	e8 00 00 00 00	 call	 store_hw_noswap
$LN4@s370_vstor:

; 549  :         ITIMER_UPDATE( addr, 2-1, regs );

  00098	83 7c 24 68 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  0009d	73 0a		 jae	 SHORT $LN15@s370_vstor
  0009f	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000a7	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000a9	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN16@s370_vstor:
  000b1	83 7c 24 34 00	 cmp	 DWORD PTR tv91[rsp], 0
  000b6	74 15		 je	 SHORT $LN17@s370_vstor
  000b8	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  000bc	ff c0		 inc	 eax
  000be	83 f8 50	 cmp	 eax, 80			; 00000050H
  000c1	72 0a		 jb	 SHORT $LN17@s370_vstor
  000c3	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  000cb	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  000cd	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN23@s370_vstor:
  000d5	83 7c 24 38 00	 cmp	 DWORD PTR tv135[rsp], 0
  000da	74 0a		 je	 SHORT $LN7@s370_vstor
  000dc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  000e6	33 c0		 xor	 eax, eax
  000e8	85 c0		 test	 eax, eax
  000ea	75 ac		 jne	 SHORT $LN4@s370_vstor

; 550  :     }

  000ec	eb 18		 jmp	 SHORT $LN6@s370_vstor
$LN5@s370_vstor:

; 551  :     else
; 552  :         ARCH_DEP( vstore2_full )( value, addr, arn, regs );

  000ee	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  000f3	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  000f8	8b 54 24 68	 mov	 edx, DWORD PTR addr$[rsp]
  000fc	0f b7 4c 24 60	 movzx	 ecx, WORD PTR value$[rsp]
  00101	e8 00 00 00 00	 call	 s370_vstore2_full
$LN6@s370_vstor:

; 553  : }

  00106	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0010a	c3		 ret	 0
s370_vstore2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch2_full
_TEXT	SEGMENT
value$ = 48
mn$ = 56
addr$ = 80
arn$ = 88
regs$ = 96
s370_vfetch2_full PROC					; COMDAT

; 401  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 402  : BYTE   *mn;                             /* Main storage addresses    */
; 403  : U16     value;
; 404  : 
; 405  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00016	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002b	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00039	e8 00 00 00 00	 call	 s370_maddr_l
  0003e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 406  :     value = *mn << 8;

  00043	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00048	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004b	c1 e0 08	 shl	 eax, 8
  0004e	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 407  :     mn = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  00053	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00057	ff c0		 inc	 eax
  00059	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0005e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00078	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0007d	ba 01 00 00 00	 mov	 edx, 1
  00082	8b c8		 mov	 ecx, eax
  00084	e8 00 00 00 00	 call	 s370_maddr_l
  00089	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 408  :                  ACCTYPE_READ, regs->psw.pkey );
; 409  :     value |= *mn;

  0008e	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00093	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00096	0f b7 4c 24 30	 movzx	 ecx, WORD PTR value$[rsp]
  0009b	0b c8		 or	 ecx, eax
  0009d	8b c1		 mov	 eax, ecx
  0009f	66 89 44 24 30	 mov	 WORD PTR value$[rsp], ax

; 410  :     return value;

  000a4	0f b7 44 24 30	 movzx	 eax, WORD PTR value$[rsp]

; 411  : }

  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
s370_vfetch2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore2_full
_TEXT	SEGMENT
sk$ = 48
main1$ = 56
main2$ = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
s370_vstore2_full PROC					; COMDAT

; 308  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 309  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 310  : BYTE   *sk;                             /* Storage key addresses     */
; 311  : 
; 312  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00017	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0002c	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	8b 4c 24 68	 mov	 ecx, DWORD PTR addr$[rsp]
  0003f	e8 00 00 00 00	 call	 s370_maddr_l
  00044	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 313  :     sk = regs->dat.storkey;

  00049	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00055	48 89 44 24 30	 mov	 QWORD PTR sk$[rsp], rax

; 314  :     main2 = MADDR( (addr + 1) & ADDRESS_MAXWRAP( regs ), arn, regs,

  0005a	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  0005e	ff c0		 inc	 eax
  00060	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00065	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0006e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00072	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 01 00 00 00	 mov	 edx, 1
  00089	8b c8		 mov	 ecx, eax
  0008b	e8 00 00 00 00	 call	 s370_maddr_l
  00090	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 315  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 316  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR sk$[rsp]
  0009a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0009d	83 c8 06	 or	 eax, 6
  000a0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sk$[rsp]
  000a5	88 01		 mov	 BYTE PTR [rcx], al

; 317  :     *main1 = value >> 8;

  000a7	0f b7 44 24 60	 movzx	 eax, WORD PTR value$[rsp]
  000ac	c1 f8 08	 sar	 eax, 8
  000af	48 8b 4c 24 38	 mov	 rcx, QWORD PTR main1$[rsp]
  000b4	88 01		 mov	 BYTE PTR [rcx], al

; 318  :     *main2 = value & 0xFF;

  000b6	0f b7 44 24 60	 movzx	 eax, WORD PTR value$[rsp]
  000bb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR main2$[rsp]
  000c5	88 01		 mov	 BYTE PTR [rcx], al

; 319  : }

  000c7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000cb	c3		 ret	 0
s370_vstore2_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_authorize_asn
_TEXT	SEGMENT
ate$ = 48
atl$ = 52
ato$ = 56
tv92 = 64
ax$ = 96
aste$ = 104
atemask$ = 112
regs$ = 120
s370_authorize_asn PROC					; COMDAT

; 192  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 193  : RADR    ato;                            /* Authority table origin    */
; 194  : int     atl;                            /* Authority table length    */
; 195  : BYTE    ate;                            /* Authority table entry     */
; 196  : 
; 197  :     /* [3.10.3.1] Authority table lookup */
; 198  : 
; 199  :     /* Isolate the authority table origin and length */
; 200  :     ato = aste[0] & ASTE0_ATO;

  00018	b8 04 00 00 00	 mov	 eax, 4
  0001d	48 6b c0 00	 imul	 rax, rax, 0
  00021	48 8b 4c 24 68	 mov	 rcx, QWORD PTR aste$[rsp]
  00026	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00029	25 fc ff ff 7f	 and	 eax, 2147483644		; 7ffffffcH
  0002e	8b c0		 mov	 eax, eax
  00030	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax

; 201  :     atl = aste[1] & ASTE1_ATL;

  00035	b8 04 00 00 00	 mov	 eax, 4
  0003a	48 6b c0 01	 imul	 rax, rax, 1
  0003e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR aste$[rsp]
  00043	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00046	25 f0 ff 00 00	 and	 eax, 65520		; 0000fff0H
  0004b	89 44 24 34	 mov	 DWORD PTR atl$[rsp], eax

; 202  : 
; 203  :     /* Authorization fails if AX is outside table */
; 204  :     if ((ax & 0xFFF0) > atl)

  0004f	0f b7 44 24 60	 movzx	 eax, WORD PTR ax$[rsp]
  00054	25 f0 ff 00 00	 and	 eax, 65520		; 0000fff0H
  00059	3b 44 24 34	 cmp	 eax, DWORD PTR atl$[rsp]
  0005d	7e 07		 jle	 SHORT $LN5@s370_autho

; 205  :         return true;

  0005f	b0 01		 mov	 al, 1
  00061	e9 81 01 00 00	 jmp	 $LN1@s370_autho
$LN5@s370_autho:

; 206  : 
; 207  :     /* Calculate the address of the byte in the authority
; 208  :        table which contains the 2 bit entry for this AX */
; 209  :     ato += (ax >> 2);

  00066	0f b7 44 24 60	 movzx	 eax, WORD PTR ax$[rsp]
  0006b	c1 f8 02	 sar	 eax, 2
  0006e	48 98		 cdqe
  00070	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ato$[rsp]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax

; 210  : 
; 211  :     /* Ignore carry into bit position 0 */
; 212  :     ato &= 0x7FFFFFFF;

  00080	48 8b 44 24 38	 mov	 rax, QWORD PTR ato$[rsp]
  00085	48 25 ff ff ff
	7f		 and	 rax, 2147483647		; 7fffffffH
  0008b	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax

; 213  : 
; 214  :     /* Addressing exception if ATE is outside main storage */
; 215  :     if (ato > regs->mainlim)

  00090	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00095	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0009c	48 39 44 24 38	 cmp	 QWORD PTR ato$[rsp], rax
  000a1	76 05		 jbe	 SHORT $LN6@s370_autho

; 216  :         goto auth_addr_excp;

  000a3	e9 2a 01 00 00	 jmp	 $auth_addr_excp$13
$LN6@s370_autho:

; 217  : 
; 218  :     /* Load the byte containing the authority table entry
; 219  :        and shift the entry into the leftmost 2 bits */
; 220  :     ato = APPLY_PREFIXING( ato, regs->PX );

  000a8	8b 44 24 38	 mov	 eax, DWORD PTR ato$[rsp]
  000ac	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000b2	48 85 c0	 test	 rax, rax
  000b5	74 23		 je	 SHORT $LN10@s370_autho
  000b7	8b 44 24 38	 mov	 eax, DWORD PTR ato$[rsp]
  000bb	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000c1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  000c9	48 3b c1	 cmp	 rax, rcx
  000cc	74 0c		 je	 SHORT $LN10@s370_autho
  000ce	48 8b 44 24 38	 mov	 rax, QWORD PTR ato$[rsp]
  000d3	48 89 44 24 40	 mov	 QWORD PTR tv92[rsp], rax
  000d8	eb 17		 jmp	 SHORT $LN11@s370_autho
$LN10@s370_autho:
  000da	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000df	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000e2	8b 4c 24 38	 mov	 ecx, DWORD PTR ato$[rsp]
  000e6	33 c8		 xor	 ecx, eax
  000e8	8b c1		 mov	 eax, ecx
  000ea	8b c0		 mov	 eax, eax
  000ec	48 89 44 24 40	 mov	 QWORD PTR tv92[rsp], rax
$LN11@s370_autho:
  000f1	48 8b 44 24 40	 mov	 rax, QWORD PTR tv92[rsp]
  000f6	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax
$LN4@s370_autho:

; 221  : 
; 222  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 223  :        is treated as a no-operation if SIE_MODE not active */
; 224  :     SIE_TRANSLATE( &ato, ACCTYPE_SIE, regs );

  000fb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00100	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00106	d1 e8		 shr	 eax, 1
  00108	83 e0 01	 and	 eax, 1
  0010b	85 c0		 test	 eax, eax
  0010d	74 67		 je	 SHORT $LN7@s370_autho
  0010f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00114	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0011a	c1 e8 02	 shr	 eax, 2
  0011d	83 e0 01	 and	 eax, 1
  00120	85 c0		 test	 eax, eax
  00122	75 52		 jne	 SHORT $LN7@s370_autho
  00124	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00129	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00130	48 03 44 24 38	 add	 rax, QWORD PTR ato$[rsp]
  00135	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  0013e	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00143	45 33 c9	 xor	 r9d, r9d
  00146	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0014b	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00152	ba fd ff ff ff	 mov	 edx, -3
  00157	8b c8		 mov	 ecx, eax
  00159	e8 00 00 00 00	 call	 s390_logical_to_main_l
  0015e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00163	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0016a	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  00171	48 89 44 24 38	 mov	 QWORD PTR ato$[rsp], rax
$LN7@s370_autho:
  00176	33 c0		 xor	 eax, eax
  00178	85 c0		 test	 eax, eax
  0017a	0f 85 7b ff ff
	ff		 jne	 $LN4@s370_autho

; 225  : 
; 226  :     ate = regs->mainstor[ato];

  00180	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00185	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0018c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ato$[rsp]
  00191	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00195	88 44 24 30	 mov	 BYTE PTR ate$[rsp], al

; 227  :     ate <<= ((ax & 0x03)*2);

  00199	0f b7 44 24 60	 movzx	 eax, WORD PTR ax$[rsp]
  0019e	83 e0 03	 and	 eax, 3
  001a1	d1 e0		 shl	 eax, 1
  001a3	0f b6 c8	 movzx	 ecx, al
  001a6	0f b6 44 24 30	 movzx	 eax, BYTE PTR ate$[rsp]
  001ab	d2 e0		 shl	 al, cl
  001ad	88 44 24 30	 mov	 BYTE PTR ate$[rsp], al

; 228  : 
; 229  :     /* Set the main storage reference bit */
; 230  :     ARCH_DEP( or_storage_key )( ato, STORKEY_REF );

  001b1	b2 04		 mov	 dl, 4
  001b3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ato$[rsp]
  001b8	e8 00 00 00 00	 call	 s370_or_storage_key

; 231  : 
; 232  :     /* Authorization fails if the specified bit (either X'80' or
; 233  :        X'40' of the 2 bit authority table entry) is zero */
; 234  :     if ((ate & atemask) == 0)

  001bd	0f b6 44 24 30	 movzx	 eax, BYTE PTR ate$[rsp]
  001c2	23 44 24 70	 and	 eax, DWORD PTR atemask$[rsp]
  001c6	85 c0		 test	 eax, eax
  001c8	75 04		 jne	 SHORT $LN8@s370_autho

; 235  :         return true;

  001ca	b0 01		 mov	 al, 1
  001cc	eb 19		 jmp	 SHORT $LN1@s370_autho
$LN8@s370_autho:

; 236  : 
; 237  :     /* Exit with successful return code */
; 238  :     return false;

  001ce	32 c0		 xor	 al, al
  001d0	eb 15		 jmp	 SHORT $LN1@s370_autho
$auth_addr_excp$13:

; 239  : 
; 240  : /* Conditions which always cause program check */
; 241  : auth_addr_excp:
; 242  :     regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );

  001d2	ba 05 00 00 00	 mov	 edx, 5
  001d7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001dc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN1@s370_autho:
$LN9@s370_autho:

; 243  :     UNREACHABLE_CODE( return false );
; 244  : }

  001e7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001eb	c3		 ret	 0
s370_authorize_asn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_purge_tlbe_all
_TEXT	SEGMENT
cpu$ = 32
tv137 = 36
p$1 = 40
p$2 = 48
regs$ = 80
pfra$ = 88
cpuad$ = 96
s370_purge_tlbe_all PROC				; COMDAT

; 102  : {

$LN21:
  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 103  :     int  cpu;
; 104  : 
; 105  :     if (0xFFFF == cpuad && !IS_INTLOCK_HELD( regs ))  // (sanity check)

  00014	0f b7 44 24 60	 movzx	 eax, WORD PTR cpuad$[rsp]
  00019	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0001e	75 35		 jne	 SHORT $LN13@s370_purge
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00027	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  0002e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00033	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0003a	3b c1		 cmp	 eax, ecx
  0003c	74 17		 je	 SHORT $LN13@s370_purge
$LN4@s370_purge:

; 106  :         CRASH();                                      // (logic error!)

  0003e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00047	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0004c	c6 00 00	 mov	 BYTE PTR [rax], 0
  0004f	33 c0		 xor	 eax, eax
  00051	85 c0		 test	 eax, eax
  00053	75 e9		 jne	 SHORT $LN4@s370_purge
$LN13@s370_purge:

; 107  : 
; 108  :     for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  00055	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  0005d	eb 0a		 jmp	 SHORT $LN7@s370_purge
$LN5@s370_purge:
  0005f	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  00063	ff c0		 inc	 eax
  00065	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN7@s370_purge:
  00069	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00070	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00076	39 44 24 20	 cmp	 DWORD PTR cpu$[rsp], eax
  0007a	0f 8d 40 01 00
	00		 jge	 $LN6@s370_purge

; 109  :     {
; 110  :         if (1
; 111  :             && IS_CPU_ONLINE(cpu)
; 112  :             && (sysblk.regs[ cpu ]->cpubit & sysblk.started_mask)
; 113  :             && (0

  00080	33 c0		 xor	 eax, eax
  00082	83 f8 01	 cmp	 eax, 1
  00085	0f 84 30 01 00
	00		 je	 $LN14@s370_purge
  0008b	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00090	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00097	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  000a0	0f 84 15 01 00
	00		 je	 $LN14@s370_purge
  000a6	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b2	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000ba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c1	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  000c8	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000cc	48 23 c1	 and	 rax, rcx
  000cf	48 85 c0	 test	 rax, rax
  000d2	0f 84 e3 00 00
	00		 je	 $LN14@s370_purge
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 34		 jne	 SHORT $LN15@s370_purge
  000de	0f b7 44 24 60	 movzx	 eax, WORD PTR cpuad$[rsp]
  000e3	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  000e8	74 28		 je	 SHORT $LN15@s370_purge
  000ea	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000f6	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000fe	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00105	0f b7 4c 24 60	 movzx	 ecx, WORD PTR cpuad$[rsp]
  0010a	3b c1		 cmp	 eax, ecx
  0010c	0f 85 a9 00 00
	00		 jne	 $LN14@s370_purge
$LN15@s370_purge:

; 114  :                 || 0xFFFF == cpuad
; 115  :                 || sysblk.regs[ cpu ]->cpuad == cpuad
; 116  :                )
; 117  :         )
; 118  :         {
; 119  :             switch (sysblk.regs[ cpu ]->arch_mode)

  00112	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00117	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0011e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00126	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00129	89 44 24 24	 mov	 DWORD PTR tv137[rsp], eax
  0012d	83 7c 24 24 00	 cmp	 DWORD PTR tv137[rsp], 0
  00132	74 10		 je	 SHORT $LN16@s370_purge
  00134	83 7c 24 24 01	 cmp	 DWORD PTR tv137[rsp], 1
  00139	74 29		 je	 SHORT $LN17@s370_purge
  0013b	83 7c 24 24 02	 cmp	 DWORD PTR tv137[rsp], 2
  00140	74 42		 je	 SHORT $LN18@s370_purge
  00142	eb 60		 jmp	 SHORT $LN19@s370_purge
$LN16@s370_purge:

; 120  :             {
; 121  :             case ARCH_370_IDX: s370_purge_tlbe( sysblk.regs[ cpu ], pfra ); break;

  00144	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00149	48 8b 54 24 58	 mov	 rdx, QWORD PTR pfra$[rsp]
  0014e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00155	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0015d	e8 00 00 00 00	 call	 s370_purge_tlbe
  00162	eb 57		 jmp	 SHORT $LN8@s370_purge
$LN17@s370_purge:

; 122  :             case ARCH_390_IDX: s390_purge_tlbe( sysblk.regs[ cpu ], pfra ); break;

  00164	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00169	48 8b 54 24 58	 mov	 rdx, QWORD PTR pfra$[rsp]
  0016e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00175	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0017d	e8 00 00 00 00	 call	 s390_purge_tlbe
  00182	eb 37		 jmp	 SHORT $LN8@s370_purge
$LN18@s370_purge:

; 123  :             case ARCH_900_IDX: z900_purge_tlbe( sysblk.regs[ cpu ], pfra ); break;

  00184	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00189	48 8b 54 24 58	 mov	 rdx, QWORD PTR pfra$[rsp]
  0018e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00195	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0019d	e8 00 00 00 00	 call	 z900_purge_tlbe
  001a2	eb 17		 jmp	 SHORT $LN8@s370_purge
$LN19@s370_purge:
$LN12@s370_purge:

; 124  :             default: CRASH();

  001a4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  001ad	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  001b2	c6 00 00	 mov	 BYTE PTR [rax], 0
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 e9		 jne	 SHORT $LN12@s370_purge
$LN8@s370_purge:
$LN14@s370_purge:

; 125  :             }
; 126  :         }
; 127  :     }

  001bb	e9 9f fe ff ff	 jmp	 $LN5@s370_purge
$LN6@s370_purge:

; 128  : }

  001c0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c4	c3		 ret	 0
s370_purge_tlbe_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_purge_tlb_all
_TEXT	SEGMENT
cpu$ = 32
tv137 = 36
p$1 = 40
p$2 = 48
regs$ = 80
cpuad$ = 88
s370_purge_tlb_all PROC					; COMDAT

; 69   : {

$LN21:
  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 70   :     int  cpu;
; 71   : 
; 72   :     if (0xFFFF == cpuad && !IS_INTLOCK_HELD( regs ))  // (sanity check)

  0000e	0f b7 44 24 58	 movzx	 eax, WORD PTR cpuad$[rsp]
  00013	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00018	75 35		 jne	 SHORT $LN13@s370_purge
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  00028	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00034	3b c1		 cmp	 eax, ecx
  00036	74 17		 je	 SHORT $LN13@s370_purge
$LN4@s370_purge:

; 73   :         CRASH();                                      // (logic error!)

  00038	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00041	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00046	c6 00 00	 mov	 BYTE PTR [rax], 0
  00049	33 c0		 xor	 eax, eax
  0004b	85 c0		 test	 eax, eax
  0004d	75 e9		 jne	 SHORT $LN4@s370_purge
$LN13@s370_purge:

; 74   : 
; 75   :     for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  0004f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  00057	eb 0a		 jmp	 SHORT $LN7@s370_purge
$LN5@s370_purge:
  00059	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN7@s370_purge:
  00063	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00070	39 44 24 20	 cmp	 DWORD PTR cpu$[rsp], eax
  00074	0f 8d 31 01 00
	00		 jge	 $LN6@s370_purge

; 76   :     {
; 77   :         if (1
; 78   :             && IS_CPU_ONLINE(cpu)
; 79   :             && (sysblk.regs[ cpu ]->cpubit & sysblk.started_mask)
; 80   :             && (0

  0007a	33 c0		 xor	 eax, eax
  0007c	83 f8 01	 cmp	 eax, 1
  0007f	0f 84 21 01 00
	00		 je	 $LN14@s370_purge
  00085	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00091	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0009a	0f 84 06 01 00
	00		 je	 $LN14@s370_purge
  000a0	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ac	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000bb	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  000c2	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000c6	48 23 c1	 and	 rax, rcx
  000c9	48 85 c0	 test	 rax, rax
  000cc	0f 84 d4 00 00
	00		 je	 $LN14@s370_purge
  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 34		 jne	 SHORT $LN15@s370_purge
  000d8	0f b7 44 24 58	 movzx	 eax, WORD PTR cpuad$[rsp]
  000dd	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  000e2	74 28		 je	 SHORT $LN15@s370_purge
  000e4	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000f0	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000f8	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ff	0f b7 4c 24 58	 movzx	 ecx, WORD PTR cpuad$[rsp]
  00104	3b c1		 cmp	 eax, ecx
  00106	0f 85 9a 00 00
	00		 jne	 $LN14@s370_purge
$LN15@s370_purge:

; 81   :                 || 0xFFFF == cpuad
; 82   :                 || sysblk.regs[ cpu ]->cpuad == cpuad
; 83   :                )
; 84   :         )
; 85   :         {
; 86   :             switch (sysblk.regs[ cpu ]->arch_mode)

  0010c	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00111	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00118	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00120	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00123	89 44 24 24	 mov	 DWORD PTR tv137[rsp], eax
  00127	83 7c 24 24 00	 cmp	 DWORD PTR tv137[rsp], 0
  0012c	74 10		 je	 SHORT $LN16@s370_purge
  0012e	83 7c 24 24 01	 cmp	 DWORD PTR tv137[rsp], 1
  00133	74 24		 je	 SHORT $LN17@s370_purge
  00135	83 7c 24 24 02	 cmp	 DWORD PTR tv137[rsp], 2
  0013a	74 38		 je	 SHORT $LN18@s370_purge
  0013c	eb 51		 jmp	 SHORT $LN19@s370_purge
$LN16@s370_purge:

; 87   :             {
; 88   :             case ARCH_370_IDX: s370_purge_tlb( sysblk.regs[ cpu ]); break;

  0013e	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00143	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0014a	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  00152	e8 00 00 00 00	 call	 s370_purge_tlb
  00157	eb 4d		 jmp	 SHORT $LN8@s370_purge
$LN17@s370_purge:

; 89   :             case ARCH_390_IDX: s390_purge_tlb( sysblk.regs[ cpu ]); break;

  00159	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0015e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00165	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0016d	e8 00 00 00 00	 call	 s390_purge_tlb
  00172	eb 32		 jmp	 SHORT $LN8@s370_purge
$LN18@s370_purge:

; 90   :             case ARCH_900_IDX: z900_purge_tlb( sysblk.regs[ cpu ]); break;

  00174	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00179	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00180	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  00188	e8 00 00 00 00	 call	 z900_purge_tlb
  0018d	eb 17		 jmp	 SHORT $LN8@s370_purge
$LN19@s370_purge:
$LN12@s370_purge:

; 91   :             default: CRASH();

  0018f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  00198	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  0019d	c6 00 00	 mov	 BYTE PTR [rax], 0
  001a0	33 c0		 xor	 eax, eax
  001a2	85 c0		 test	 eax, eax
  001a4	75 e9		 jne	 SHORT $LN12@s370_purge
$LN8@s370_purge:
$LN14@s370_purge:

; 92   :             }
; 93   :         }
; 94   :     }

  001a6	e9 ae fe ff ff	 jmp	 $LN5@s370_purge
$LN6@s370_purge:

; 95   : }

  001ab	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001af	c3		 ret	 0
s370_purge_tlb_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tl$ = 32
tf$ = 33
cc$ = 36
tlbix$ = 40
tt$ = 44
sto$ = 48
rte$ = 56
rsx$ = 64
rtx$ = 68
rfx$ = 72
sx$ = 76
ste$ = 80
pte$ = 88
pto$ = 96
px$ = 104
tv220 = 108
tv83 = 112
tv425 = 116
tv432 = 120
tv477 = 124
tv505 = 128
tv573 = 132
tv631 = 136
tv716 = 140
vaddr$ = 160
arn$ = 168
regs$ = 176
acctype$ = 184
z900_translate_addr PROC

; 935  : {

$LN99:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 936  : RADR    sto = 0;                        /* Segment table origin      */

  0001a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR sto$[rsp], 0

; 937  : RADR    pto = 0;                        /* Page table origin         */

  00023	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR pto$[rsp], 0

; 938  : int     cc;                             /* Condition code            */
; 939  : int     tlbix = TLBIX(vaddr);           /* TLB entry index           */

  0002c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR vaddr$[rsp]
  00034	48 c1 e8 0c	 shr	 rax, 12
  00038	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  0003e	89 44 24 28	 mov	 DWORD PTR tlbix$[rsp], eax

; 940  : 
; 941  : #if !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 942  : /*-----------------------------------*/
; 943  : /* S/370 Dynamic Address Translation */
; 944  : /*-----------------------------------*/
; 945  : U32     stl;                            /* Segment table length      */
; 946  : RADR    ste;                            /* Segment table entry       */
; 947  : U16     pte;                            /* Page table entry          */
; 948  : U32     ptl;                            /* Page table length         */
; 949  : 
; 950  :     regs->dat.pvtaddr = regs->dat.protect = 0;
; 951  : 
; 952  :     /* Load the effective segment table descriptor */
; 953  :     if (ARCH_DEP(load_address_space_designator) (arn, regs, acctype))
; 954  :         goto tran_alet_excp;
; 955  : 
; 956  :     /* Check the translation format bits in CR0 */
; 957  :     if ((((regs->CR(0) & CR0_PAGE_SIZE) != CR0_PAGE_SZ_2K) &&
; 958  :        ((regs->CR(0) & CR0_PAGE_SIZE) != CR0_PAGE_SZ_4K)) ||
; 959  :        (((regs->CR(0) & CR0_SEG_SIZE) != CR0_SEG_SZ_64K) &&
; 960  :        ((regs->CR(0) & CR0_SEG_SIZE) != CR0_SEG_SZ_1M)))
; 961  :        goto tran_spec_excp;
; 962  : 
; 963  :     /* Look up the address in the TLB */
; 964  :     if (   ((vaddr & TLBID_PAGEMASK) | regs->tlbID) == regs->tlb.TLB_VADDR(tlbix)
; 965  :         && (regs->tlb.common[tlbix] || regs->dat.asd == regs->tlb.TLB_ASD(tlbix))
; 966  :         && !(regs->tlb.common[tlbix] && regs->dat.pvtaddr)
; 967  :         && !(acctype & ACC_NOTLB) )
; 968  :     {
; 969  :         pte = regs->tlb.TLB_PTE(tlbix);
; 970  : 
; 971  : #if defined( FEATURE_SEGMENT_PROTECTION )
; 972  :         /* Set the protection indicator if segment is protected */
; 973  :         if (regs->tlb.protect[tlbix])
; 974  :             regs->dat.protect = regs->tlb.protect[tlbix];
; 975  : #endif
; 976  :     }
; 977  :     else
; 978  :     {
; 979  :         /* S/370 segment table lookup */
; 980  : 
; 981  :         /* Calculate the real address of the segment table entry */
; 982  :         sto = regs->dat.asd & STD_370_STO;
; 983  :         stl = regs->dat.asd & STD_370_STL;
; 984  :         sto += ((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_1M) ?
; 985  :             ((vaddr & 0x00F00000) >> 18) :
; 986  :             ((vaddr & 0x00FF0000) >> 14);
; 987  : 
; 988  :         /* Check that virtual address is within the segment table */
; 989  :         if (((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_64K) &&
; 990  :             ((vaddr << 4) & STD_370_STL) > stl)
; 991  :             goto seg_tran_length;
; 992  : 
; 993  :         /* Generate addressing exception if outside real storage */
; 994  :         if (sto > regs->mainlim)
; 995  :             goto address_excp;
; 996  : 
; 997  :         /* Fetch segment table entry from real storage.  All bytes
; 998  :            must be fetched concurrently as observed by other CPUs */
; 999  :         sto = APPLY_PREFIXING (sto, regs->PX);
; 1000 :         ste = ARCH_DEP(fetch_fullword_absolute) (sto, regs);
; 1001 : 
; 1002 :         /* Generate segment translation exception if segment invalid */
; 1003 :         if (ste & SEGTAB_370_INVL)
; 1004 :             goto seg_tran_invalid;
; 1005 : 
; 1006 :         /* Check that all the reserved bits in the STE are zero */
; 1007 :         if (ste & SEGTAB_370_RSV)
; 1008 :             goto tran_spec_excp;
; 1009 : 
; 1010 :         /* Isolate page table origin and length */
; 1011 :         pto = ste & SEGTAB_370_PTO;
; 1012 :         ptl = ste & SEGTAB_370_PTL;
; 1013 : 
; 1014 :         /* S/370 page table lookup */
; 1015 : 
; 1016 :         /* Calculate the real address of the page table entry */
; 1017 :         pto += ((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_1M) ?
; 1018 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 1019 :             ((vaddr & 0x000FF000) >> 11) :
; 1020 :             ((vaddr & 0x000FF800) >> 10)) :
; 1021 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 1022 :             ((vaddr & 0x0000F000) >> 11) :
; 1023 :             ((vaddr & 0x0000F800) >> 10));
; 1024 : 
; 1025 :         /* Generate addressing exception if outside real storage */
; 1026 :         if (pto > regs->mainlim)
; 1027 :             goto address_excp;
; 1028 : 
; 1029 :         /* Check that the virtual address is within the page table */
; 1030 :         if ((((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_1M) &&
; 1031 :             (((vaddr & 0x000F0000) >> 16) > ptl)) ||
; 1032 :             (((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_64K) &&
; 1033 :             (((vaddr & 0x0000F000) >> 12) > ptl)))
; 1034 :             goto page_tran_length;
; 1035 : 
; 1036 :         /* Fetch the page table entry from real storage.  All bytes
; 1037 :            must be fetched concurrently as observed by other CPUs */
; 1038 :         pto = APPLY_PREFIXING (pto, regs->PX);
; 1039 :         pte = ARCH_DEP(fetch_halfword_absolute) (pto, regs);
; 1040 : 
; 1041 :         /* Generate page translation exception if page invalid */
; 1042 :         if ((((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) &&
; 1043 :             (pte & PAGETAB_INV_4K)) ||
; 1044 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_2K) &&
; 1045 :             (pte & PAGETAB_INV_2K)))
; 1046 :             goto page_tran_invalid;
; 1047 : 
; 1048 :         /* Check that all the reserved bits in the PTE are zero */
; 1049 :         if (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_2K) &&
; 1050 :             (pte & PAGETAB_RSV_2K))
; 1051 :             goto tran_spec_excp;
; 1052 : 
; 1053 : #if defined( FEATURE_SEGMENT_PROTECTION )
; 1054 :         /* Set the protection indicator if segment is protected */
; 1055 :         if (ste & SEGTAB_370_PROT)
; 1056 :             regs->dat.protect |= 1;
; 1057 : #endif
; 1058 : 
; 1059 :         /* Place the translated address in the TLB */
; 1060 :         if (!(acctype & ACC_NOTLB))
; 1061 :         {
; 1062 :             regs->tlb.TLB_ASD(tlbix)   = regs->dat.asd;
; 1063 :             regs->tlb.TLB_VADDR(tlbix) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;
; 1064 :             regs->tlb.TLB_PTE(tlbix)   = pte;
; 1065 :             regs->tlb.common[tlbix]    = (ste & SEGTAB_370_CMN) ? 1 : 0;
; 1066 :             regs->tlb.protect[tlbix]   = regs->dat.protect;
; 1067 :             regs->tlb.acc[tlbix]       = 0;
; 1068 :             regs->tlb.main[tlbix]      = NULL;
; 1069 : 
; 1070 :             /* Set adjacent TLB entry if 4K page sizes */
; 1071 :             if ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K)
; 1072 :             {
; 1073 :                 regs->tlb.TLB_ASD(tlbix^1)   = regs->tlb.TLB_ASD(tlbix);
; 1074 :                 regs->tlb.TLB_VADDR(tlbix^1) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;
; 1075 :                 regs->tlb.TLB_PTE(tlbix^1)   = regs->tlb.TLB_PTE(tlbix);
; 1076 :                 regs->tlb.common[tlbix^1]    = regs->tlb.common[tlbix];
; 1077 :                 regs->tlb.protect[tlbix^1]   = regs->tlb.protect[tlbix];
; 1078 :                 regs->tlb.acc[tlbix^1]       = 0;
; 1079 :                 regs->tlb.main[tlbix^1]      = NULL;
; 1080 :             }
; 1081 :         }
; 1082 :     } /* end if(!TLB) */
; 1083 : 
; 1084 :     /* Combine the page frame real address with the byte
; 1085 :        index of the virtual address to form the real address */
; 1086 :     regs->dat.raddr = ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 1087 : #if defined( FEATURE_S370E_EXTENDED_ADDRESSING )
; 1088 :         (((U32)pte & PAGETAB_EA_4K) << 23) |
; 1089 : #endif
; 1090 :         (((U32)pte & PAGETAB_PFRA_4K) << 8) | (vaddr & 0xFFF) :
; 1091 :         (((U32)pte & PAGETAB_PFRA_2K) << 8) | (vaddr & 0x7FF);
; 1092 : 
; 1093 :     regs->dat.rpfra = regs->dat.raddr & PAGEFRAME_PAGEMASK;
; 1094 : #endif /* !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1095 : 
; 1096 : #if defined( FEATURE_S390_DAT )
; 1097 : /*-----------------------------------*/
; 1098 : /* S/390 Dynamic Address Translation */
; 1099 : /*-----------------------------------*/
; 1100 : U32     stl;                            /* Segment table length      */
; 1101 : RADR    ste;                            /* Segment table entry       */
; 1102 : RADR    pte;                            /* Page table entry          */
; 1103 : U32     ptl;                            /* Page table length         */
; 1104 : 
; 1105 :     regs->dat.pvtaddr = regs->dat.protect = 0;
; 1106 : 
; 1107 :     /* [3.11.3.1] Load the effective segment table descriptor */
; 1108 :     if (ARCH_DEP(load_address_space_designator) (arn, regs, acctype))
; 1109 :         goto tran_alet_excp;
; 1110 : 
; 1111 :     /* [3.11.3.2] Check the translation format bits in CR0 */
; 1112 :     if ((regs->CR(0) & CR0_TRAN_FMT) != CR0_TRAN_ESA390)
; 1113 :         goto tran_spec_excp;
; 1114 : 
; 1115 :     /* Extract the private space bit from segment table descriptor */
; 1116 :     regs->dat.pvtaddr = ((regs->dat.asd & STD_PRIVATE) != 0);
; 1117 : 
; 1118 :     /* [3.11.4] Look up the address in the TLB */
; 1119 :     if (   ((vaddr & TLBID_PAGEMASK) | regs->tlbID) == regs->tlb.TLB_VADDR(tlbix)
; 1120 :         && (regs->tlb.common[tlbix] || regs->dat.asd == regs->tlb.TLB_ASD(tlbix))
; 1121 :         && !(regs->tlb.common[tlbix] && regs->dat.pvtaddr)
; 1122 :         && !(acctype & ACC_NOTLB) )
; 1123 :     {
; 1124 :         pte = regs->tlb.TLB_PTE(tlbix);
; 1125 :         if (regs->tlb.protect[tlbix])
; 1126 :             regs->dat.protect = regs->tlb.protect[tlbix];
; 1127 :     }
; 1128 :     else
; 1129 :     {
; 1130 :         /* [3.11.3.3] Segment table lookup */
; 1131 : 
; 1132 :         /* Calculate the real address of the segment table entry */
; 1133 :         sto = regs->dat.asd & STD_STO;
; 1134 :         stl = regs->dat.asd & STD_STL;
; 1135 :         sto += (vaddr & 0x7FF00000) >> 18;
; 1136 : 
; 1137 :         /* Check that virtual address is within the segment table */
; 1138 :         if ((vaddr >> 24) > stl)
; 1139 :             goto seg_tran_length;
; 1140 : 
; 1141 :         /* Generate addressing exception if outside real storage */
; 1142 :         if (sto > regs->mainlim)
; 1143 :             goto address_excp;
; 1144 : 
; 1145 :         /* Fetch segment table entry from real storage.  All bytes
; 1146 :            must be fetched concurrently as observed by other CPUs */
; 1147 :         sto = APPLY_PREFIXING (sto, regs->PX);
; 1148 :         ste = ARCH_DEP(fetch_fullword_absolute) (sto, regs);
; 1149 : 
; 1150 :         /* Generate segment translation exception if segment invalid */
; 1151 :         if (ste & SEGTAB_INVALID)
; 1152 :             goto seg_tran_invalid;
; 1153 : 
; 1154 :         /* Check that all the reserved bits in the STE are zero */
; 1155 :         if (ste & SEGTAB_RESV)
; 1156 :             goto tran_spec_excp;
; 1157 : 
; 1158 :         /* If the segment table origin register indicates a private
; 1159 :            address space then STE must not indicate a common segment */
; 1160 :         if (regs->dat.pvtaddr && (ste & (SEGTAB_COMMON)))
; 1161 :             goto tran_spec_excp;
; 1162 : 
; 1163 :         /* Isolate page table origin and length */
; 1164 :         pto = ste & SEGTAB_PTO;
; 1165 :         ptl = ste & SEGTAB_PTL;
; 1166 : 
; 1167 :         /* [3.11.3.4] Page table lookup */
; 1168 : 
; 1169 :         /* Calculate the real address of the page table entry */
; 1170 :         pto += (vaddr & 0x000FF000) >> 10;
; 1171 : 
; 1172 :         /* Check that the virtual address is within the page table */
; 1173 :         if (((vaddr & 0x000FF000) >> 16) > ptl)
; 1174 :             goto page_tran_length;
; 1175 : 
; 1176 :         /* Generate addressing exception if outside real storage */
; 1177 :         if (pto > regs->mainlim)
; 1178 :             goto address_excp;
; 1179 : 
; 1180 :         /* Fetch the page table entry from real storage.  All bytes
; 1181 :            must be fetched concurrently as observed by other CPUs */
; 1182 :         pto = APPLY_PREFIXING (pto, regs->PX);
; 1183 :         pte = ARCH_DEP(fetch_fullword_absolute) (pto, regs);
; 1184 : 
; 1185 :         /* Generate page translation exception if page invalid */
; 1186 :         if (pte & PAGETAB_INVALID)
; 1187 :             goto page_tran_invalid;
; 1188 : 
; 1189 :         /* Check that all the reserved bits in the PTE are zero */
; 1190 :         if (pte & PAGETAB_RESV)
; 1191 :             goto tran_spec_excp;
; 1192 : 
; 1193 :         /* Set the protection indicator if page protection is active */
; 1194 :         if (pte & PAGETAB_PROT)
; 1195 :             regs->dat.protect |= 1;
; 1196 : 
; 1197 :         /* [3.11.4.2] Place the translated address in the TLB */
; 1198 :         if (!(acctype & ACC_NOTLB))
; 1199 :         {
; 1200 :             regs->tlb.TLB_ASD(tlbix)   = regs->dat.asd;
; 1201 :             regs->tlb.TLB_VADDR(tlbix) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;
; 1202 :             regs->tlb.TLB_PTE(tlbix)   = pte;
; 1203 :             regs->tlb.common[tlbix]    = (ste & SEGTAB_COMMON) ? 1 : 0;
; 1204 :             regs->tlb.acc[tlbix]       = 0;
; 1205 :             regs->tlb.protect[tlbix]   = regs->dat.protect;
; 1206 :             regs->tlb.main[tlbix]      = NULL;
; 1207 :         }
; 1208 :     } /* end if(!TLB) */
; 1209 : 
; 1210 :     if(!(acctype & ACC_PTE))
; 1211 :     {
; 1212 :     /* [3.11.3.5] Combine the page frame real address with the byte
; 1213 :        index of the virtual address to form the real address */
; 1214 :         regs->dat.raddr = (pte & PAGETAB_PFRA) | (vaddr & 0xFFF);
; 1215 :         regs->dat.rpfra = (pte & PAGETAB_PFRA);
; 1216 :     }
; 1217 :     else
; 1218 :     /* In the case of lock page, return the address of the
; 1219 :        pagetable entry */
; 1220 :         regs->dat.raddr = pto;
; 1221 : 
; 1222 : #endif /* defined( FEATURE_S390_DAT ) */
; 1223 : 
; 1224 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1225 : /*-----------------------------------*/
; 1226 : /* ESAME Dynamic Address Translation */
; 1227 : /*-----------------------------------*/
; 1228 : RADR    rte;                            /* Region table entry        */
; 1229 : #define rto     sto                     /* Region/seg table origin   */
; 1230 : RADR    ste = 0;                        /* Segment table entry       */

  00042	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR ste$[rsp], 0

; 1231 : RADR    pte = 0;                        /* Page table entry          */

  0004b	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR pte$[rsp], 0

; 1232 : BYTE    tt;                             /* Table type                */
; 1233 : BYTE    tl;                             /* Table length              */
; 1234 : BYTE    tf;                             /* Table offset              */
; 1235 : U16     rfx, rsx, rtx;                  /* Region first/second/third
; 1236 :                                            index + 3 low-order zeros */
; 1237 : U16     sx, px;                         /* Segment and page index,
; 1238 :                                            + 3 low-order zero bits   */
; 1239 : 
; 1240 :     regs->dat.pvtaddr = regs->dat.protect = 0;

  00054	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00062	83 e0 f9	 and	 eax, -7			; fffffff9H
  00065	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
  00073	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007b	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00081	83 e0 fe	 and	 eax, -2			; fffffffeH
  00084	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008c	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 1241 : 
; 1242 :     /* Load the address space control element */
; 1243 :     if (ARCH_DEP(load_address_space_designator) (arn, regs, acctype))

  00092	44 8b 84 24 b8
	00 00 00	 mov	 r8d, DWORD PTR acctype$[rsp]
  0009a	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a2	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR arn$[rsp]
  000a9	e8 00 00 00 00	 call	 z900_load_address_space_designator
  000ae	0f b7 c0	 movzx	 eax, ax
  000b1	85 c0		 test	 eax, eax
  000b3	74 05		 je	 SHORT $LN4@z900_trans

; 1244 :         goto tran_alet_excp;

  000b5	e9 9b 0f 00 00	 jmp	 $tran_alet_excp$100
$LN4@z900_trans:

; 1245 : 
; 1246 :     /* Extract the private space bit from the ASCE */
; 1247 :     regs->dat.pvtaddr = ((regs->dat.asd & (ASCE_P|ASCE_R)) != 0);

  000ba	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c2	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  000c9	48 25 20 01 00
	00		 and	 rax, 288		; 00000120H
  000cf	48 85 c0	 test	 rax, rax
  000d2	74 0a		 je	 SHORT $LN81@z900_trans
  000d4	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
  000dc	eb 08		 jmp	 SHORT $LN82@z900_trans
$LN81@z900_trans:
  000de	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN82@z900_trans:
  000e6	8b 44 24 70	 mov	 eax, DWORD PTR tv83[rsp]
  000ea	83 e0 01	 and	 eax, 1
  000ed	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f5	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  000fb	83 e1 fe	 and	 ecx, -2			; fffffffeH
  000fe	0b c8		 or	 ecx, eax
  00100	8b c1		 mov	 eax, ecx
  00102	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010a	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 1248 : 
; 1249 : //  LOGMSG("asce=%16.16"PRIX64"\n",regs->dat.asd);
; 1250 : 
; 1251 :     /* [3.11.4] Look up the address in the TLB */
; 1252 :     if (   ((vaddr & TLBID_PAGEMASK) | regs->tlbID) == regs->tlb.TLB_VADDR(tlbix)
; 1253 :         && (regs->tlb.common[tlbix] || regs->dat.asd == regs->tlb.TLB_ASD(tlbix))
; 1254 :         && !(regs->tlb.common[tlbix] && regs->dat.pvtaddr)
; 1255 :         && !(acctype & ACC_NOTLB) )

  00110	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR vaddr$[rsp]
  00118	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  0011e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0012c	48 0b c1	 or	 rax, rcx
  0012f	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR tlbix$[rsp]
  00134	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00144	0f 85 fa 00 00
	00		 jne	 $LN5@z900_trans
  0014a	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  0014f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	0f b6 84 01 60
	54 01 00	 movzx	 eax, BYTE PTR [rcx+rax+87136]
  0015f	85 c0		 test	 eax, eax
  00161	75 2a		 jne	 SHORT $LN7@z900_trans
  00163	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00168	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00178	48 8b 84 c2 60
	b0 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+45152]
  00180	48 39 81 18 08
	00 00		 cmp	 QWORD PTR [rcx+2072], rax
  00187	0f 85 b7 00 00
	00		 jne	 $LN5@z900_trans
$LN7@z900_trans:
  0018d	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00192	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019a	0f b6 84 01 60
	54 01 00	 movzx	 eax, BYTE PTR [rcx+rax+87136]
  001a2	85 c0		 test	 eax, eax
  001a4	74 19		 je	 SHORT $LN8@z900_trans
  001a6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ae	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  001b4	83 e0 01	 and	 eax, 1
  001b7	85 c0		 test	 eax, eax
  001b9	0f 85 85 00 00
	00		 jne	 $LN5@z900_trans
$LN8@z900_trans:
  001bf	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  001c6	25 00 01 00 00	 and	 eax, 256		; 00000100H
  001cb	85 c0		 test	 eax, eax
  001cd	75 75		 jne	 SHORT $LN5@z900_trans

; 1256 :     {
; 1257 :         pte = regs->tlb.TLB_PTE(tlbix);

  001cf	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  001d4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001dc	48 8b 84 c1 60
	f0 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+61536]
  001e4	48 89 44 24 58	 mov	 QWORD PTR pte$[rsp], rax

; 1258 :         if (regs->tlb.protect[tlbix])

  001e9	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  001ee	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f6	0f b6 84 01 60
	58 01 00	 movzx	 eax, BYTE PTR [rcx+rax+88160]
  001fe	85 c0		 test	 eax, eax
  00200	74 3d		 je	 SHORT $LN9@z900_trans

; 1259 :             regs->dat.protect = regs->tlb.protect[tlbix];

  00202	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00207	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	0f b6 84 01 60
	58 01 00	 movzx	 eax, BYTE PTR [rcx+rax+88160]
  00217	83 e0 03	 and	 eax, 3
  0021a	d1 e0		 shl	 eax, 1
  0021c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00224	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  0022a	83 e1 f9	 and	 ecx, -7			; fffffff9H
  0022d	0b c8		 or	 ecx, eax
  0022f	8b c1		 mov	 eax, ecx
  00231	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00239	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN9@z900_trans:

; 1260 :     }

  0023f	e9 fa 0b 00 00	 jmp	 $LN6@z900_trans
$LN5@z900_trans:

; 1261 :     else
; 1262 :     {
; 1263 :         /* If ASCE indicates a real-space then real addr = virtual addr */
; 1264 :         if (regs->dat.asd & ASCE_R)

  00244	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024c	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00253	48 83 e0 20	 and	 rax, 32			; 00000020H
  00257	48 85 c0	 test	 rax, rax
  0025a	74 42		 je	 SHORT $LN10@z900_trans

; 1265 :         {
; 1266 : //      LOGMSG("asce type = real\n");
; 1267 : 
; 1268 :             /* Translation specification exception if LKPG for a real-space */
; 1269 :             if(acctype & ACC_PTE)

  0025c	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00263	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00268	85 c0		 test	 eax, eax
  0026a	74 05		 je	 SHORT $LN12@z900_trans

; 1270 :                 goto tran_spec_excp;

  0026c	e9 67 0c 00 00	 jmp	 $tran_spec_excp$101
$LN12@z900_trans:

; 1271 : 
; 1272 :             /* Special operation exception if LPTEA for a real-space */
; 1273 :             if(acctype & ACC_LPTEA)

  00271	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00278	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0027d	85 c0		 test	 eax, eax
  0027f	74 05		 je	 SHORT $LN13@z900_trans

; 1274 :                 goto spec_oper_excp;

  00281	e9 68 0c 00 00	 jmp	 $spec_oper_excp$102
$LN13@z900_trans:

; 1275 : 
; 1276 :             /* Construct a fake page table entry for real = virtual */
; 1277 :             pte = vaddr & 0xFFFFFFFFFFFFF000ULL;

  00286	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR vaddr$[rsp]
  0028e	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00294	48 89 44 24 58	 mov	 QWORD PTR pte$[rsp], rax

; 1278 :         }

  00299	e9 25 0a 00 00	 jmp	 $LN11@z900_trans
$LN10@z900_trans:

; 1279 :         else
; 1280 :         {
; 1281 :             /* Extract the table origin, type, and length from the ASCE,
; 1282 :                and set the table offset to zero */
; 1283 :             rto = regs->dat.asd & ASCE_TO;

  0029e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a6	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  002ad	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  002b3	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 1284 :             tf = 0;

  002b8	c6 44 24 21 00	 mov	 BYTE PTR tf$[rsp], 0

; 1285 :             tt = regs->dat.asd & ASCE_DT;

  002bd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c5	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  002cc	48 83 e0 0c	 and	 rax, 12
  002d0	88 44 24 2c	 mov	 BYTE PTR tt$[rsp], al

; 1286 :             tl = regs->dat.asd & ASCE_TL;

  002d4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002dc	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  002e3	48 83 e0 03	 and	 rax, 3
  002e7	88 44 24 20	 mov	 BYTE PTR tl$[rsp], al

; 1287 : 
; 1288 :             /* Extract the 11-bit region first index, region second index,
; 1289 :                and region third index from the virtual address, and shift
; 1290 :                each index into bits 2-12 of a 16-bit integer, ready for
; 1291 :                addition to the appropriate region table origin */
; 1292 :             rfx = (vaddr >> 50) & 0x3FF8;

  002eb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR vaddr$[rsp]
  002f3	48 c1 e8 32	 shr	 rax, 50			; 00000032H
  002f7	48 25 f8 3f 00
	00		 and	 rax, 16376		; 00003ff8H
  002fd	66 89 44 24 48	 mov	 WORD PTR rfx$[rsp], ax

; 1293 :             rsx = (vaddr >> 39) & 0x3FF8;

  00302	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR vaddr$[rsp]
  0030a	48 c1 e8 27	 shr	 rax, 39			; 00000027H
  0030e	48 25 f8 3f 00
	00		 and	 rax, 16376		; 00003ff8H
  00314	66 89 44 24 40	 mov	 WORD PTR rsx$[rsp], ax

; 1294 :             rtx = (vaddr >> 28) & 0x3FF8;

  00319	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR vaddr$[rsp]
  00321	48 c1 e8 1c	 shr	 rax, 28
  00325	48 25 f8 3f 00
	00		 and	 rax, 16376		; 00003ff8H
  0032b	66 89 44 24 44	 mov	 WORD PTR rtx$[rsp], ax

; 1295 : 
; 1296 :             /* Extract the 11-bit segment index from the virtual address,
; 1297 :                and shift it into bits 2-12 of a 16-bit integer, ready
; 1298 :                for addition to the segment table origin */
; 1299 :             sx = (vaddr >> 17) & 0x3FF8;

  00330	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR vaddr$[rsp]
  00338	48 c1 e8 11	 shr	 rax, 17
  0033c	48 25 f8 3f 00
	00		 and	 rax, 16376		; 00003ff8H
  00342	66 89 44 24 4c	 mov	 WORD PTR sx$[rsp], ax

; 1300 : 
; 1301 :             /* Extract the 8-bit page index from the virtual address,
; 1302 :                and shift it into bits 2-12 of a 16-bit integer, ready
; 1303 :                for addition to the page table origin */
; 1304 :             px = (vaddr >> 9) & 0x07F8;

  00347	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR vaddr$[rsp]
  0034f	48 c1 e8 09	 shr	 rax, 9
  00353	48 25 f8 07 00
	00		 and	 rax, 2040		; 000007f8H
  00359	66 89 44 24 68	 mov	 WORD PTR px$[rsp], ax

; 1305 : 
; 1306 :             /* ASCE-type exception if the virtual address is too large
; 1307 :                for the table type designated by the ASCE */
; 1308 :             if ((rfx != 0 && tt < TT_R1TABL)
; 1309 :                 || (rsx != 0 && tt < TT_R2TABL)
; 1310 :                 || (rtx != 0 && tt < TT_R3TABL))

  0035e	0f b7 44 24 48	 movzx	 eax, WORD PTR rfx$[rsp]
  00363	85 c0		 test	 eax, eax
  00365	74 0a		 je	 SHORT $LN16@z900_trans
  00367	0f b6 44 24 2c	 movzx	 eax, BYTE PTR tt$[rsp]
  0036c	83 f8 0c	 cmp	 eax, 12
  0036f	7c 26		 jl	 SHORT $LN15@z900_trans
$LN16@z900_trans:
  00371	0f b7 44 24 40	 movzx	 eax, WORD PTR rsx$[rsp]
  00376	85 c0		 test	 eax, eax
  00378	74 0a		 je	 SHORT $LN17@z900_trans
  0037a	0f b6 44 24 2c	 movzx	 eax, BYTE PTR tt$[rsp]
  0037f	83 f8 08	 cmp	 eax, 8
  00382	7c 13		 jl	 SHORT $LN15@z900_trans
$LN17@z900_trans:
  00384	0f b7 44 24 44	 movzx	 eax, WORD PTR rtx$[rsp]
  00389	85 c0		 test	 eax, eax
  0038b	74 0f		 je	 SHORT $LN14@z900_trans
  0038d	0f b6 44 24 2c	 movzx	 eax, BYTE PTR tt$[rsp]
  00392	83 f8 04	 cmp	 eax, 4
  00395	7d 05		 jge	 SHORT $LN14@z900_trans
$LN15@z900_trans:

; 1311 :                 goto asce_type_excp;

  00397	e9 bf 0d 00 00	 jmp	 $asce_type_excp$103
$LN14@z900_trans:

; 1312 : 
; 1313 :             /* Perform region translation */
; 1314 :             switch (tt) {

  0039c	0f b6 44 24 2c	 movzx	 eax, BYTE PTR tt$[rsp]
  003a1	88 44 24 6c	 mov	 BYTE PTR tv220[rsp], al
  003a5	80 7c 24 6c 04	 cmp	 BYTE PTR tv220[rsp], 4
  003aa	0f 84 b7 02 00
	00		 je	 $LN31@z900_trans
  003b0	80 7c 24 6c 08	 cmp	 BYTE PTR tv220[rsp], 8
  003b5	0f 84 51 01 00
	00		 je	 $LN24@z900_trans
  003bb	80 7c 24 6c 0c	 cmp	 BYTE PTR tv220[rsp], 12
  003c0	74 05		 je	 SHORT $LN18@z900_trans
  003c2	e9 fb 03 00 00	 jmp	 $LN2@z900_trans
$LN18@z900_trans:

; 1315 : 
; 1316 :             /* Perform region-first translation */
; 1317 :             case TT_R1TABL:
; 1318 : 
; 1319 :                 /* Region-first translation exception if table length is
; 1320 :                    less than high-order 2 bits of region-first index */
; 1321 :                 if (tl < (rfx >> 12))

  003c7	0f b6 44 24 20	 movzx	 eax, BYTE PTR tl$[rsp]
  003cc	0f b7 4c 24 48	 movzx	 ecx, WORD PTR rfx$[rsp]
  003d1	c1 f9 0c	 sar	 ecx, 12
  003d4	3b c1		 cmp	 eax, ecx
  003d6	7d 05		 jge	 SHORT $LN19@z900_trans

; 1322 :                     goto reg_first_excp;

  003d8	e9 9c 0d 00 00	 jmp	 $reg_first_excp$104
$LN19@z900_trans:

; 1323 : 
; 1324 :                 /* Add the region-first index (with three low-order zeroes)
; 1325 :                    to the region-first table origin, giving the address of
; 1326 :                    the region-first table entry */
; 1327 :                 rto += rfx;

  003dd	0f b7 44 24 48	 movzx	 eax, WORD PTR rfx$[rsp]
  003e2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  003e7	48 03 c8	 add	 rcx, rax
  003ea	48 8b c1	 mov	 rax, rcx
  003ed	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 1328 : 
; 1329 :                 /* Addressing exception if outside main storage */
; 1330 :                 if (rto > regs->mainlim)

  003f2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003fa	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00401	48 39 44 24 30	 cmp	 QWORD PTR sto$[rsp], rax
  00406	76 05		 jbe	 SHORT $LN20@z900_trans

; 1331 :                     goto address_excp;

  00408	e9 b5 0a 00 00	 jmp	 $address_excp$105
$LN20@z900_trans:

; 1332 : 
; 1333 :                 /* Fetch region-first table entry from absolute storage.
; 1334 :                    All bytes must be fetched concurrently as observed by
; 1335 :                    other CPUs */
; 1336 :                 rte = ARCH_DEP(fetch_doubleword_absolute) (rto, regs);

  0040d	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00415	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  0041a	e8 00 00 00 00	 call	 z900_fetch_doubleword_absolute
  0041f	48 89 44 24 38	 mov	 QWORD PTR rte$[rsp], rax

; 1337 : //              LOGMSG("r1te:%16.16"PRIX64"=>%16.16"PRIX64"\n",rto,rte);
; 1338 : 
; 1339 :                 /* Region-first translation exception if the bit 58 of
; 1340 :                    the region-first table entry is set (region invalid) */
; 1341 :                 if (rte & REGTAB_I)

  00424	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  00429	48 83 e0 20	 and	 rax, 32			; 00000020H
  0042d	48 85 c0	 test	 rax, rax
  00430	74 05		 je	 SHORT $LN21@z900_trans

; 1342 :                     goto reg_first_invalid;

  00432	e9 70 0c 00 00	 jmp	 $reg_first_invalid$106
$LN21@z900_trans:

; 1343 : 
; 1344 :                 /* Translation specification exception if bits 60-61 of
; 1345 :                    the region-first table entry do not indicate the
; 1346 :                    correct type of region table */
; 1347 :                 if ((rte & REGTAB_TT) != TT_R1TABL)

  00437	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  0043c	48 83 e0 0c	 and	 rax, 12
  00440	48 83 f8 0c	 cmp	 rax, 12
  00444	74 05		 je	 SHORT $LN22@z900_trans

; 1348 :                     goto tran_spec_excp;

  00446	e9 8d 0a 00 00	 jmp	 $tran_spec_excp$101
$LN22@z900_trans:

; 1349 : 
; 1350 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1351 :                 if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1352 :                  && (regs->CR_L(0) & CR0_ED)
; 1353 :                  && (rte & REGTAB_P))

  0044b	b8 01 00 00 00	 mov	 eax, 1
  00450	48 6b c0 01	 imul	 rax, rax, 1
  00454	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045c	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00464	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00469	85 c0		 test	 eax, eax
  0046b	74 6f		 je	 SHORT $LN23@z900_trans
  0046d	b8 08 00 00 00	 mov	 eax, 8
  00472	48 6b c0 01	 imul	 rax, rax, 1
  00476	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00485	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  0048a	85 c0		 test	 eax, eax
  0048c	74 4e		 je	 SHORT $LN23@z900_trans
  0048e	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  00493	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00499	48 85 c0	 test	 rax, rax
  0049c	74 3e		 je	 SHORT $LN23@z900_trans

; 1354 :                     regs->dat.protect |= 1;

  0049e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004a6	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  004ac	d1 e8		 shr	 eax, 1
  004ae	83 e0 03	 and	 eax, 3
  004b1	83 c8 01	 or	 eax, 1
  004b4	83 e0 03	 and	 eax, 3
  004b7	d1 e0		 shl	 eax, 1
  004b9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c1	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  004c7	83 e1 f9	 and	 ecx, -7			; fffffff9H
  004ca	0b c8		 or	 ecx, eax
  004cc	8b c1		 mov	 eax, ecx
  004ce	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d6	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN23@z900_trans:

; 1355 : #endif
; 1356 :                 /* Extract the region-second table origin, offset, and
; 1357 :                    length from the region-first table entry */
; 1358 :                 rto = rte & REGTAB_TO;

  004dc	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  004e1	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  004e7	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 1359 :                 tf = (rte & REGTAB_TF) >> 6;

  004ec	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  004f1	48 25 c0 00 00
	00		 and	 rax, 192		; 000000c0H
  004f7	48 c1 e8 06	 shr	 rax, 6
  004fb	88 44 24 21	 mov	 BYTE PTR tf$[rsp], al

; 1360 :                 tl = rte & REGTAB_TL;

  004ff	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  00504	48 83 e0 03	 and	 rax, 3
  00508	88 44 24 20	 mov	 BYTE PTR tl$[rsp], al
$LN24@z900_trans:

; 1361 : 
; 1362 :                 /* Fall through to perform region-second translation */
; 1363 :                 /* FALLTHRU */
; 1364 : 
; 1365 :             /* Perform region-second translation */
; 1366 :             case TT_R2TABL:
; 1367 : 
; 1368 :                 /* Region-second translation exception if table offset is
; 1369 :                    greater than high-order 2 bits of region-second index */
; 1370 :                 if (tf > (rsx >> 12))

  0050c	0f b6 44 24 21	 movzx	 eax, BYTE PTR tf$[rsp]
  00511	0f b7 4c 24 40	 movzx	 ecx, WORD PTR rsx$[rsp]
  00516	c1 f9 0c	 sar	 ecx, 12
  00519	3b c1		 cmp	 eax, ecx
  0051b	7e 05		 jle	 SHORT $LN25@z900_trans

; 1371 :                     goto reg_second_excp;

  0051d	e9 75 0c 00 00	 jmp	 $reg_second_excp$107
$LN25@z900_trans:

; 1372 : 
; 1373 :                 /* Region-second translation exception if table length is
; 1374 :                    less than high-order 2 bits of region-second index */
; 1375 :                 if (tl < (rsx >> 12))

  00522	0f b6 44 24 20	 movzx	 eax, BYTE PTR tl$[rsp]
  00527	0f b7 4c 24 40	 movzx	 ecx, WORD PTR rsx$[rsp]
  0052c	c1 f9 0c	 sar	 ecx, 12
  0052f	3b c1		 cmp	 eax, ecx
  00531	7d 05		 jge	 SHORT $LN26@z900_trans

; 1376 :                     goto reg_second_excp;

  00533	e9 5f 0c 00 00	 jmp	 $reg_second_excp$107
$LN26@z900_trans:

; 1377 : 
; 1378 :                 /* Add the region-second index (with three low-order zeroes)
; 1379 :                    to the region-second table origin, giving the address of
; 1380 :                    the region-second table entry */
; 1381 :                 rto += rsx;

  00538	0f b7 44 24 40	 movzx	 eax, WORD PTR rsx$[rsp]
  0053d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  00542	48 03 c8	 add	 rcx, rax
  00545	48 8b c1	 mov	 rax, rcx
  00548	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 1382 : 
; 1383 :                 /* Addressing exception if outside main storage */
; 1384 :                 if (rto > regs->mainlim)

  0054d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00555	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0055c	48 39 44 24 30	 cmp	 QWORD PTR sto$[rsp], rax
  00561	76 05		 jbe	 SHORT $LN27@z900_trans

; 1385 :                     goto address_excp;

  00563	e9 5a 09 00 00	 jmp	 $address_excp$105
$LN27@z900_trans:

; 1386 : 
; 1387 :                 /* Fetch region-second table entry from absolute storage.
; 1388 :                    All bytes must be fetched concurrently as observed by
; 1389 :                    other CPUs */
; 1390 :                 rte = ARCH_DEP(fetch_doubleword_absolute) (rto, regs);

  00568	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00570	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  00575	e8 00 00 00 00	 call	 z900_fetch_doubleword_absolute
  0057a	48 89 44 24 38	 mov	 QWORD PTR rte$[rsp], rax

; 1391 : //              LOGMSG("r2te:%16.16"PRIX64"=>%16.16"PRIX64"\n",rto,rte);
; 1392 : 
; 1393 :                 /* Region-second translation exception if the bit 58 of
; 1394 :                    the region-second table entry is set (region invalid) */
; 1395 :                 if (rte & REGTAB_I)

  0057f	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  00584	48 83 e0 20	 and	 rax, 32			; 00000020H
  00588	48 85 c0	 test	 rax, rax
  0058b	74 05		 je	 SHORT $LN28@z900_trans

; 1396 :                     goto reg_second_invalid;

  0058d	e9 53 0b 00 00	 jmp	 $reg_second_invalid$108
$LN28@z900_trans:

; 1397 : 
; 1398 :                 /* Translation specification exception if bits 60-61 of
; 1399 :                    the region-second table entry do not indicate the
; 1400 :                    correct type of region table */
; 1401 :                 if ((rte & REGTAB_TT) != TT_R2TABL)

  00592	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  00597	48 83 e0 0c	 and	 rax, 12
  0059b	48 83 f8 08	 cmp	 rax, 8
  0059f	74 05		 je	 SHORT $LN29@z900_trans

; 1402 :                     goto tran_spec_excp;

  005a1	e9 32 09 00 00	 jmp	 $tran_spec_excp$101
$LN29@z900_trans:

; 1403 : 
; 1404 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1405 :                 if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1406 :                  && (regs->CR_L(0) & CR0_ED)
; 1407 :                  && (rte & REGTAB_P))

  005a6	b8 01 00 00 00	 mov	 eax, 1
  005ab	48 6b c0 01	 imul	 rax, rax, 1
  005af	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b7	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  005bf	25 80 00 00 00	 and	 eax, 128		; 00000080H
  005c4	85 c0		 test	 eax, eax
  005c6	74 6f		 je	 SHORT $LN30@z900_trans
  005c8	b8 08 00 00 00	 mov	 eax, 8
  005cd	48 6b c0 01	 imul	 rax, rax, 1
  005d1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005d9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  005e0	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  005e5	85 c0		 test	 eax, eax
  005e7	74 4e		 je	 SHORT $LN30@z900_trans
  005e9	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  005ee	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  005f4	48 85 c0	 test	 rax, rax
  005f7	74 3e		 je	 SHORT $LN30@z900_trans

; 1408 :                     regs->dat.protect |= 1;

  005f9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00601	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00607	d1 e8		 shr	 eax, 1
  00609	83 e0 03	 and	 eax, 3
  0060c	83 c8 01	 or	 eax, 1
  0060f	83 e0 03	 and	 eax, 3
  00612	d1 e0		 shl	 eax, 1
  00614	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0061c	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  00622	83 e1 f9	 and	 ecx, -7			; fffffff9H
  00625	0b c8		 or	 ecx, eax
  00627	8b c1		 mov	 eax, ecx
  00629	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00631	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN30@z900_trans:

; 1409 : #endif
; 1410 :                 /* Extract the region-third table origin, offset, and
; 1411 :                    length from the region-second table entry */
; 1412 :                 rto = rte & REGTAB_TO;

  00637	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  0063c	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00642	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 1413 :                 tf = (rte & REGTAB_TF) >> 6;

  00647	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  0064c	48 25 c0 00 00
	00		 and	 rax, 192		; 000000c0H
  00652	48 c1 e8 06	 shr	 rax, 6
  00656	88 44 24 21	 mov	 BYTE PTR tf$[rsp], al

; 1414 :                 tl = rte & REGTAB_TL;

  0065a	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  0065f	48 83 e0 03	 and	 rax, 3
  00663	88 44 24 20	 mov	 BYTE PTR tl$[rsp], al
$LN31@z900_trans:

; 1415 : 
; 1416 :                 /* Fall through to perform region-third translation */
; 1417 :                 /* FALLTHRU */
; 1418 : 
; 1419 :             /* Perform region-third translation */
; 1420 :             case TT_R3TABL:
; 1421 : 
; 1422 :                 /* Region-third translation exception if table offset is
; 1423 :                    greater than high-order 2 bits of region-third index */
; 1424 :                 if (tf > (rtx >> 12))

  00667	0f b6 44 24 21	 movzx	 eax, BYTE PTR tf$[rsp]
  0066c	0f b7 4c 24 44	 movzx	 ecx, WORD PTR rtx$[rsp]
  00671	c1 f9 0c	 sar	 ecx, 12
  00674	3b c1		 cmp	 eax, ecx
  00676	7e 05		 jle	 SHORT $LN32@z900_trans

; 1425 :                     goto reg_third_excp;

  00678	e9 38 0b 00 00	 jmp	 $reg_third_excp$109
$LN32@z900_trans:

; 1426 : 
; 1427 :                 /* Region-third translation exception if table length is
; 1428 :                    less than high-order 2 bits of region-third index */
; 1429 :                 if (tl < (rtx >> 12))

  0067d	0f b6 44 24 20	 movzx	 eax, BYTE PTR tl$[rsp]
  00682	0f b7 4c 24 44	 movzx	 ecx, WORD PTR rtx$[rsp]
  00687	c1 f9 0c	 sar	 ecx, 12
  0068a	3b c1		 cmp	 eax, ecx
  0068c	7d 05		 jge	 SHORT $LN33@z900_trans

; 1430 :                     goto reg_third_excp;

  0068e	e9 22 0b 00 00	 jmp	 $reg_third_excp$109
$LN33@z900_trans:

; 1431 : 
; 1432 :                 /* Add the region-third index (with three low-order zeroes)
; 1433 :                    to the region-third table origin, giving the address of
; 1434 :                    the region-third table entry */
; 1435 :                 rto += rtx;

  00693	0f b7 44 24 44	 movzx	 eax, WORD PTR rtx$[rsp]
  00698	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  0069d	48 03 c8	 add	 rcx, rax
  006a0	48 8b c1	 mov	 rax, rcx
  006a3	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 1436 : 
; 1437 :                 /* Addressing exception if outside main storage */
; 1438 :                 if (rto > regs->mainlim)

  006a8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006b0	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  006b7	48 39 44 24 30	 cmp	 QWORD PTR sto$[rsp], rax
  006bc	76 05		 jbe	 SHORT $LN34@z900_trans

; 1439 :                     goto address_excp;

  006be	e9 ff 07 00 00	 jmp	 $address_excp$105
$LN34@z900_trans:

; 1440 : 
; 1441 :                 /* Fetch region-third table entry from absolute storage.
; 1442 :                    All bytes must be fetched concurrently as observed by
; 1443 :                    other CPUs */
; 1444 :                 rte = ARCH_DEP(fetch_doubleword_absolute) (rto, regs);

  006c3	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006cb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  006d0	e8 00 00 00 00	 call	 z900_fetch_doubleword_absolute
  006d5	48 89 44 24 38	 mov	 QWORD PTR rte$[rsp], rax

; 1445 : //              LOGMSG("r3te:%16.16"PRIX64"=>%16.16"PRIX64"\n",rto,rte);
; 1446 : 
; 1447 :                 /* Region-third translation exception if the bit 58 of
; 1448 :                    the region-third table entry is set (region invalid) */
; 1449 :                 if (rte & REGTAB_I)

  006da	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  006df	48 83 e0 20	 and	 rax, 32			; 00000020H
  006e3	48 85 c0	 test	 rax, rax
  006e6	74 05		 je	 SHORT $LN35@z900_trans

; 1450 :                     goto reg_third_invalid;

  006e8	e9 33 0a 00 00	 jmp	 $reg_third_invalid$110
$LN35@z900_trans:

; 1451 : 
; 1452 :                 /* Translation specification exception if bits 60-61 of
; 1453 :                    the region-third table entry do not indicate the
; 1454 :                    correct type of region table */
; 1455 :                 if ((rte & REGTAB_TT) != TT_R3TABL)

  006ed	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  006f2	48 83 e0 0c	 and	 rax, 12
  006f6	48 83 f8 04	 cmp	 rax, 4
  006fa	74 05		 je	 SHORT $LN36@z900_trans

; 1456 :                     goto tran_spec_excp;

  006fc	e9 d7 07 00 00	 jmp	 $tran_spec_excp$101
$LN36@z900_trans:

; 1457 : 
; 1458 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1459 :                 if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1460 :                  && (regs->CR_L(0) & CR0_ED)
; 1461 :                  && (rte & REGTAB_P))

  00701	b8 01 00 00 00	 mov	 eax, 1
  00706	48 6b c0 01	 imul	 rax, rax, 1
  0070a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00712	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0071a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0071f	85 c0		 test	 eax, eax
  00721	74 6f		 je	 SHORT $LN37@z900_trans
  00723	b8 08 00 00 00	 mov	 eax, 8
  00728	48 6b c0 01	 imul	 rax, rax, 1
  0072c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00734	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0073b	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00740	85 c0		 test	 eax, eax
  00742	74 4e		 je	 SHORT $LN37@z900_trans
  00744	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  00749	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0074f	48 85 c0	 test	 rax, rax
  00752	74 3e		 je	 SHORT $LN37@z900_trans

; 1462 :                     regs->dat.protect |= 1;

  00754	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0075c	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00762	d1 e8		 shr	 eax, 1
  00764	83 e0 03	 and	 eax, 3
  00767	83 c8 01	 or	 eax, 1
  0076a	83 e0 03	 and	 eax, 3
  0076d	d1 e0		 shl	 eax, 1
  0076f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00777	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  0077d	83 e1 f9	 and	 ecx, -7			; fffffff9H
  00780	0b c8		 or	 ecx, eax
  00782	8b c1		 mov	 eax, ecx
  00784	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0078c	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN37@z900_trans:

; 1463 : #endif
; 1464 :                 /* Extract the segment table origin, offset, and
; 1465 :                    length from the region-third table entry */
; 1466 :                 sto = rte & REGTAB_TO;

  00792	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  00797	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0079d	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 1467 :                 tf = (rte & REGTAB_TF) >> 6;

  007a2	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  007a7	48 25 c0 00 00
	00		 and	 rax, 192		; 000000c0H
  007ad	48 c1 e8 06	 shr	 rax, 6
  007b1	88 44 24 21	 mov	 BYTE PTR tf$[rsp], al

; 1468 :                 tl = rte & REGTAB_TL;

  007b5	48 8b 44 24 38	 mov	 rax, QWORD PTR rte$[rsp]
  007ba	48 83 e0 03	 and	 rax, 3
  007be	88 44 24 20	 mov	 BYTE PTR tl$[rsp], al
$LN2@z900_trans:

; 1469 : 
; 1470 :                 /* Fall through to perform segment translation */
; 1471 :             } /* end switch(tt) */
; 1472 : 
; 1473 :             /* Perform ESAME segment translation */
; 1474 : 
; 1475 :             /* Add the segment index (with three low-order zeroes)
; 1476 :                to the segment table origin, giving the address of
; 1477 :                the segment table entry */
; 1478 :             sto += sx;

  007c2	0f b7 44 24 4c	 movzx	 eax, WORD PTR sx$[rsp]
  007c7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  007cc	48 03 c8	 add	 rcx, rax
  007cf	48 8b c1	 mov	 rax, rcx
  007d2	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 1479 : 
; 1480 :             /* Segment translation exception if table offset is
; 1481 :                greater than high-order 2 bits of segment index */
; 1482 :             if (tf > (sx >> 12))

  007d7	0f b6 44 24 21	 movzx	 eax, BYTE PTR tf$[rsp]
  007dc	0f b7 4c 24 4c	 movzx	 ecx, WORD PTR sx$[rsp]
  007e1	c1 f9 0c	 sar	 ecx, 12
  007e4	3b c1		 cmp	 eax, ecx
  007e6	7e 05		 jle	 SHORT $LN38@z900_trans

; 1483 :                 goto seg_tran_length;

  007e8	e9 33 08 00 00	 jmp	 $seg_tran_length$111
$LN38@z900_trans:

; 1484 : 
; 1485 :             /* Segment translation exception if table length is
; 1486 :                less than high-order 2 bits of segment index */
; 1487 :             if (tl < (sx >> 12))

  007ed	0f b6 44 24 20	 movzx	 eax, BYTE PTR tl$[rsp]
  007f2	0f b7 4c 24 4c	 movzx	 ecx, WORD PTR sx$[rsp]
  007f7	c1 f9 0c	 sar	 ecx, 12
  007fa	3b c1		 cmp	 eax, ecx
  007fc	7d 05		 jge	 SHORT $LN39@z900_trans

; 1488 :                 goto seg_tran_length;

  007fe	e9 1d 08 00 00	 jmp	 $seg_tran_length$111
$LN39@z900_trans:

; 1489 : 
; 1490 :             /* Addressing exception if outside real storage */
; 1491 :             if (sto > regs->mainlim)

  00803	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0080b	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00812	48 39 44 24 30	 cmp	 QWORD PTR sto$[rsp], rax
  00817	76 05		 jbe	 SHORT $LN40@z900_trans

; 1492 :                 goto address_excp;

  00819	e9 a4 06 00 00	 jmp	 $address_excp$105
$LN40@z900_trans:

; 1493 : 
; 1494 :             /* Fetch segment table entry from absolute storage.  All bytes
; 1495 :                must be fetched concurrently as observed by other CPUs */
; 1496 :             ste = ARCH_DEP(fetch_doubleword_absolute) (sto, regs);

  0081e	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00826	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  0082b	e8 00 00 00 00	 call	 z900_fetch_doubleword_absolute
  00830	48 89 44 24 50	 mov	 QWORD PTR ste$[rsp], rax

; 1497 : //          LOGMSG("ste:%16.16"PRIX64"=>%16.16"PRIX64"\n",sto,ste);
; 1498 : 
; 1499 :             /* Segment translation exception if segment invalid */
; 1500 :             if (ste & ZSEGTAB_I)

  00835	48 8b 44 24 50	 mov	 rax, QWORD PTR ste$[rsp]
  0083a	48 83 e0 20	 and	 rax, 32			; 00000020H
  0083e	48 85 c0	 test	 rax, rax
  00841	74 05		 je	 SHORT $LN41@z900_trans

; 1501 :                 goto seg_tran_invalid;

  00843	e9 22 07 00 00	 jmp	 $seg_tran_invalid$112
$LN41@z900_trans:

; 1502 : 
; 1503 :             /* Translation specification exception if bits 60-61 of
; 1504 :                the segment table entry do not indicate segment table */
; 1505 :             if ((ste & ZSEGTAB_TT) != TT_SEGTAB)

  00848	48 8b 44 24 50	 mov	 rax, QWORD PTR ste$[rsp]
  0084d	48 83 e0 0c	 and	 rax, 12
  00851	48 85 c0	 test	 rax, rax
  00854	74 05		 je	 SHORT $LN42@z900_trans

; 1506 :                 goto tran_spec_excp;

  00856	e9 7d 06 00 00	 jmp	 $tran_spec_excp$101
$LN42@z900_trans:

; 1507 : 
; 1508 :             /* Translation specification exception if the ASCE
; 1509 :                indicates a private space, and the segment table
; 1510 :                entry indicates a common segment */
; 1511 :             if (regs->dat.pvtaddr && (ste & ZSEGTAB_C))

  0085b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00863	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00869	83 e0 01	 and	 eax, 1
  0086c	85 c0		 test	 eax, eax
  0086e	74 13		 je	 SHORT $LN43@z900_trans
  00870	48 8b 44 24 50	 mov	 rax, QWORD PTR ste$[rsp]
  00875	48 83 e0 10	 and	 rax, 16
  00879	48 85 c0	 test	 rax, rax
  0087c	74 05		 je	 SHORT $LN43@z900_trans

; 1512 :                 goto tran_spec_excp;

  0087e	e9 55 06 00 00	 jmp	 $tran_spec_excp$101
$LN43@z900_trans:

; 1513 : 
; 1514 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1515 :             if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1516 :               && (regs->CR_L(0) & CR0_ED)
; 1517 :               && (ste & ZSEGTAB_FC))

  00883	b8 01 00 00 00	 mov	 eax, 1
  00888	48 6b c0 01	 imul	 rax, rax, 1
  0088c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00894	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0089c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  008a1	85 c0		 test	 eax, eax
  008a3	0f 84 c2 02 00
	00		 je	 $LN44@z900_trans
  008a9	b8 08 00 00 00	 mov	 eax, 8
  008ae	48 6b c0 01	 imul	 rax, rax, 1
  008b2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ba	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  008c1	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  008c6	85 c0		 test	 eax, eax
  008c8	0f 84 9d 02 00
	00		 je	 $LN44@z900_trans
  008ce	48 8b 44 24 50	 mov	 rax, QWORD PTR ste$[rsp]
  008d3	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  008d9	48 85 c0	 test	 rax, rax
  008dc	0f 84 89 02 00
	00		 je	 $LN44@z900_trans

; 1518 :             {
; 1519 :                 /* Set protection indicator if page protection is indicated */
; 1520 :                 if (ste & ZSEGTAB_P)

  008e2	48 8b 44 24 50	 mov	 rax, QWORD PTR ste$[rsp]
  008e7	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  008ed	48 85 c0	 test	 rax, rax
  008f0	74 3e		 je	 SHORT $LN45@z900_trans

; 1521 :                     regs->dat.protect |= 1;

  008f2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008fa	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00900	d1 e8		 shr	 eax, 1
  00902	83 e0 03	 and	 eax, 3
  00905	83 c8 01	 or	 eax, 1
  00908	83 e0 03	 and	 eax, 3
  0090b	d1 e0		 shl	 eax, 1
  0090d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00915	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  0091b	83 e1 f9	 and	 ecx, -7			; fffffff9H
  0091e	0b c8		 or	 ecx, eax
  00920	8b c1		 mov	 eax, ecx
  00922	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0092a	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN45@z900_trans:

; 1522 : 
; 1523 :                 /* For LPTEA instruction, return the address of the STE */
; 1524 :                 if (unlikely(acctype & ACC_LPTEA))

  00930	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00937	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0093c	85 c0		 test	 eax, eax
  0093e	74 0a		 je	 SHORT $LN85@z900_trans
  00940	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv425[rsp], 1
  00948	eb 08		 jmp	 SHORT $LN86@z900_trans
$LN85@z900_trans:
  0094a	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv425[rsp], 0
$LN86@z900_trans:
  00952	83 7c 24 74 00	 cmp	 DWORD PTR tv425[rsp], 0
  00957	74 6a		 je	 SHORT $LN46@z900_trans

; 1525 :                 {
; 1526 :                     regs->dat.raddr = sto | (regs->dat.protect ? 0x04 : 0);

  00959	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00961	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00967	d1 e8		 shr	 eax, 1
  00969	83 e0 03	 and	 eax, 3
  0096c	85 c0		 test	 eax, eax
  0096e	74 0a		 je	 SHORT $LN87@z900_trans
  00970	c7 44 24 78 04
	00 00 00	 mov	 DWORD PTR tv432[rsp], 4
  00978	eb 08		 jmp	 SHORT $LN88@z900_trans
$LN87@z900_trans:
  0097a	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv432[rsp], 0
$LN88@z900_trans:
  00982	48 63 44 24 78	 movsxd	 rax, DWORD PTR tv432[rsp]
  00987	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  0098c	48 0b c8	 or	 rcx, rax
  0098f	48 8b c1	 mov	 rax, rcx
  00992	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0099a	48 89 81 00 08
	00 00		 mov	 QWORD PTR [rcx+2048], rax

; 1527 : //                  LOGMSG("raddr:%16.16"PRIX64" cc=2\n",regs->dat.raddr);
; 1528 :                     regs->dat.xcode = 0;

  009a1	33 c0		 xor	 eax, eax
  009a3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009ab	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1529 :                     cc = 2;

  009b2	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1530 :                     return cc;

  009ba	8b 44 24 24	 mov	 eax, DWORD PTR cc$[rsp]
  009be	e9 9f 0a 00 00	 jmp	 $LN1@z900_trans
$LN46@z900_trans:

; 1531 :                 } /* end if(ACCTYPE_LPTEA) */
; 1532 : 
; 1533 :                 /* Combine the page frame real address with the byte index
; 1534 :                    of the virtual address to form the real address */
; 1535 :                 regs->dat.raddr = (ste & ZSEGTAB_SFAA) | (vaddr & ~ZSEGTAB_SFAA);

  009c3	48 8b 44 24 50	 mov	 rax, QWORD PTR ste$[rsp]
  009c8	48 25 00 00 f0
	ff		 and	 rax, -1048576		; fffffffffff00000H
  009ce	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR vaddr$[rsp]
  009d6	48 81 e1 ff ff
	0f 00		 and	 rcx, 1048575		; 000fffffH
  009dd	48 0b c1	 or	 rax, rcx
  009e0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009e8	48 89 81 00 08
	00 00		 mov	 QWORD PTR [rcx+2048], rax

; 1536 :                 /* Fake 4K PFRA for TLB purposes */
; 1537 :                 regs->dat.rpfra = ((ste & ZSEGTAB_SFAA) | (vaddr & ~ZSEGTAB_SFAA)) & PAGEFRAME_PAGEMASK;

  009ef	48 8b 44 24 50	 mov	 rax, QWORD PTR ste$[rsp]
  009f4	48 25 00 00 f0
	ff		 and	 rax, -1048576		; fffffffffff00000H
  009fa	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR vaddr$[rsp]
  00a02	48 81 e1 ff ff
	0f 00		 and	 rcx, 1048575		; 000fffffH
  00a09	48 0b c1	 or	 rax, rcx
  00a0c	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00a12	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a1a	48 89 81 10 08
	00 00		 mov	 QWORD PTR [rcx+2064], rax

; 1538 : 
; 1539 : //              LOGMSG("raddr:%16.16"PRIX64" cc=0\n",regs->dat.raddr);
; 1540 : 
; 1541 :                 /* [3.11.4.2] Place the translated address in the TLB */
; 1542 :                 if (!(acctype & ACC_NOTLB))

  00a21	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00a28	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00a2d	85 c0		 test	 eax, eax
  00a2f	0f 85 1e 01 00
	00		 jne	 $LN47@z900_trans

; 1543 :                 {
; 1544 :                     regs->tlb.TLB_ASD(tlbix)   = regs->dat.asd;

  00a35	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00a3a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a42	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a4a	48 8b 92 18 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2072]
  00a51	48 89 94 c1 60
	b0 00 00	 mov	 QWORD PTR [rcx+rax*8+45152], rdx

; 1545 :                     regs->tlb.TLB_VADDR(tlbix) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;

  00a59	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR vaddr$[rsp]
  00a61	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00a67	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a6f	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  00a75	48 0b c1	 or	 rax, rcx
  00a78	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR tlbix$[rsp]
  00a7d	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a85	48 89 84 ca 60
	d0 00 00	 mov	 QWORD PTR [rdx+rcx*8+53344], rax

; 1546 :                     /* Fake 4K PTE for TLB purposes */
; 1547 :                     regs->tlb.TLB_PTE(tlbix)   = ((ste & ZSEGTAB_SFAA) | (vaddr & ~ZSEGTAB_SFAA)) & PAGEFRAME_PAGEMASK;

  00a8d	48 8b 44 24 50	 mov	 rax, QWORD PTR ste$[rsp]
  00a92	48 25 00 00 f0
	ff		 and	 rax, -1048576		; fffffffffff00000H
  00a98	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR vaddr$[rsp]
  00aa0	48 81 e1 ff ff
	0f 00		 and	 rcx, 1048575		; 000fffffH
  00aa7	48 0b c1	 or	 rax, rcx
  00aaa	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00ab0	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR tlbix$[rsp]
  00ab5	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00abd	48 89 84 ca 60
	f0 00 00	 mov	 QWORD PTR [rdx+rcx*8+61536], rax

; 1548 :                     regs->tlb.common[tlbix]    = (ste & SEGTAB_COMMON) ? 1 : 0;

  00ac5	48 8b 44 24 50	 mov	 rax, QWORD PTR ste$[rsp]
  00aca	48 83 e0 10	 and	 rax, 16
  00ace	48 85 c0	 test	 rax, rax
  00ad1	74 0a		 je	 SHORT $LN89@z900_trans
  00ad3	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv477[rsp], 1
  00adb	eb 08		 jmp	 SHORT $LN90@z900_trans
$LN89@z900_trans:
  00add	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv477[rsp], 0
$LN90@z900_trans:
  00ae5	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00aea	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00af2	0f b6 54 24 7c	 movzx	 edx, BYTE PTR tv477[rsp]
  00af7	88 94 01 60 54
	01 00		 mov	 BYTE PTR [rcx+rax+87136], dl

; 1549 :                     regs->tlb.protect[tlbix]   = regs->dat.protect;

  00afe	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b06	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00b0c	d1 e8		 shr	 eax, 1
  00b0e	83 e0 03	 and	 eax, 3
  00b11	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR tlbix$[rsp]
  00b16	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b1e	88 84 0a 60 58
	01 00		 mov	 BYTE PTR [rdx+rcx+88160], al

; 1550 :                     regs->tlb.acc[tlbix]       = 0;

  00b25	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00b2a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b32	c6 84 01 60 5c
	01 00 00	 mov	 BYTE PTR [rcx+rax+89184], 0

; 1551 :                     regs->tlb.main[tlbix]      = NULL;

  00b3a	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00b3f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b47	48 c7 84 c1 60
	10 01 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax*8+69728], 0
$LN47@z900_trans:

; 1552 :                 }
; 1553 : 
; 1554 :                 /* Clear exception code and return with zero return code */
; 1555 :                 regs->dat.xcode = 0;

  00b53	33 c0		 xor	 eax, eax
  00b55	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b5d	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1556 :                 return 0;

  00b64	33 c0		 xor	 eax, eax
  00b66	e9 f7 08 00 00	 jmp	 $LN1@z900_trans
$LN44@z900_trans:

; 1557 : 
; 1558 :             }
; 1559 : #endif /* defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 ) */
; 1560 : 
; 1561 :             /* Extract the page table origin from segment table entry */
; 1562 :             pto = ste & ZSEGTAB_PTO;

  00b6b	48 8b 44 24 50	 mov	 rax, QWORD PTR ste$[rsp]
  00b70	48 25 00 f8 ff
	ff		 and	 rax, -2048		; fffffffffffff800H
  00b76	48 89 44 24 60	 mov	 QWORD PTR pto$[rsp], rax

; 1563 : 
; 1564 :             /* Perform ESAME page translation */
; 1565 : 
; 1566 :             /* Add the page index (with three low-order zeroes) to the
; 1567 :                page table origin, giving address of page table entry */
; 1568 :             pto += px;

  00b7b	0f b7 44 24 68	 movzx	 eax, WORD PTR px$[rsp]
  00b80	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pto$[rsp]
  00b85	48 03 c8	 add	 rcx, rax
  00b88	48 8b c1	 mov	 rax, rcx
  00b8b	48 89 44 24 60	 mov	 QWORD PTR pto$[rsp], rax

; 1569 : 
; 1570 :             /* For LPTEA instruction, return the address of the PTE */
; 1571 :             if (acctype & ACC_LPTEA)

  00b90	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00b97	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00b9c	85 c0		 test	 eax, eax
  00b9e	0f 84 c3 00 00
	00		 je	 $LN48@z900_trans

; 1572 :             {
; 1573 :                 regs->dat.raddr = pto;

  00ba4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bac	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pto$[rsp]
  00bb1	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1574 :                 regs->dat.xcode = 0;

  00bb8	33 c0		 xor	 eax, eax
  00bba	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bc2	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1575 :                 cc = (ste & ZSEGTAB_P) ? 1 : 0;

  00bc9	48 8b 44 24 50	 mov	 rax, QWORD PTR ste$[rsp]
  00bce	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00bd4	48 85 c0	 test	 rax, rax
  00bd7	74 0d		 je	 SHORT $LN91@z900_trans
  00bd9	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv505[rsp], 1
  00be4	eb 0b		 jmp	 SHORT $LN92@z900_trans
$LN91@z900_trans:
  00be6	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv505[rsp], 0
$LN92@z900_trans:
  00bf1	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv505[rsp]
  00bf8	89 44 24 24	 mov	 DWORD PTR cc$[rsp], eax

; 1576 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1577 :                 if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1578 :                   && (regs->CR_L(0) & CR0_ED)
; 1579 :                   && regs->dat.protect)

  00bfc	b8 01 00 00 00	 mov	 eax, 1
  00c01	48 6b c0 01	 imul	 rax, rax, 1
  00c05	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c0d	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00c15	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00c1a	85 c0		 test	 eax, eax
  00c1c	74 40		 je	 SHORT $LN49@z900_trans
  00c1e	b8 08 00 00 00	 mov	 eax, 8
  00c23	48 6b c0 01	 imul	 rax, rax, 1
  00c27	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c2f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00c36	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00c3b	85 c0		 test	 eax, eax
  00c3d	74 1f		 je	 SHORT $LN49@z900_trans
  00c3f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c47	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00c4d	d1 e8		 shr	 eax, 1
  00c4f	83 e0 03	 and	 eax, 3
  00c52	85 c0		 test	 eax, eax
  00c54	74 08		 je	 SHORT $LN49@z900_trans

; 1580 :                     cc = 1;

  00c56	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1
$LN49@z900_trans:

; 1581 : #endif
; 1582 :                 return cc;

  00c5e	8b 44 24 24	 mov	 eax, DWORD PTR cc$[rsp]
  00c62	e9 fb 07 00 00	 jmp	 $LN1@z900_trans
$LN48@z900_trans:

; 1583 :             } /* end if(ACCTYPE_LPTEA) */
; 1584 : 
; 1585 :             /* Addressing exception if outside real storage */
; 1586 :             if (pto > regs->mainlim)

  00c67	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c6f	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00c76	48 39 44 24 60	 cmp	 QWORD PTR pto$[rsp], rax
  00c7b	76 05		 jbe	 SHORT $LN50@z900_trans

; 1587 :                 goto address_excp;

  00c7d	e9 40 02 00 00	 jmp	 $address_excp$105
$LN50@z900_trans:

; 1588 : 
; 1589 :             /* Fetch the page table entry from absolute storage.  All bytes
; 1590 :                must be fetched concurrently as observed by other CPUs */
; 1591 :             pte = ARCH_DEP(fetch_doubleword_absolute) (pto, regs);

  00c82	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c8a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pto$[rsp]
  00c8f	e8 00 00 00 00	 call	 z900_fetch_doubleword_absolute
  00c94	48 89 44 24 58	 mov	 QWORD PTR pte$[rsp], rax

; 1592 : //          LOGMSG("pte:%16.16"PRIX64"=>%16.16"PRIX64"\n",pto,pte);
; 1593 : 
; 1594 :             /* Page translation exception if page invalid */
; 1595 :             if (pte & ZPGETAB_I)

  00c99	48 8b 44 24 58	 mov	 rax, QWORD PTR pte$[rsp]
  00c9e	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00ca4	48 85 c0	 test	 rax, rax
  00ca7	74 05		 je	 SHORT $LN51@z900_trans

; 1596 :                 goto page_tran_invalid;

  00ca9	e9 26 03 00 00	 jmp	 $page_tran_invalid$113
$LN51@z900_trans:

; 1597 : 
; 1598 :             /* Check that all the reserved bits in the PTE are zero */
; 1599 :             if (pte & ZPGETAB_RESV)

  00cae	48 8b 44 24 58	 mov	 rax, QWORD PTR pte$[rsp]
  00cb3	48 25 00 08 00
	00		 and	 rax, 2048		; 00000800H
  00cb9	48 85 c0	 test	 rax, rax
  00cbc	74 05		 je	 SHORT $LN52@z900_trans

; 1600 :                 goto tran_spec_excp;

  00cbe	e9 15 02 00 00	 jmp	 $tran_spec_excp$101
$LN52@z900_trans:
$LN11@z900_trans:

; 1601 : 
; 1602 :         } /* end else(ASCE_R) */
; 1603 : 
; 1604 :         /* Set protection indicator if page protection is indicated
; 1605 :            in either the segment table or the page table */
; 1606 :         if ((ste & ZSEGTAB_P) || (pte & ZPGETAB_P))

  00cc3	48 8b 44 24 50	 mov	 rax, QWORD PTR ste$[rsp]
  00cc8	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00cce	48 85 c0	 test	 rax, rax
  00cd1	75 10		 jne	 SHORT $LN54@z900_trans
  00cd3	48 8b 44 24 58	 mov	 rax, QWORD PTR pte$[rsp]
  00cd8	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00cde	48 85 c0	 test	 rax, rax
  00ce1	74 3e		 je	 SHORT $LN53@z900_trans
$LN54@z900_trans:

; 1607 :             regs->dat.protect |= 1;

  00ce3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ceb	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00cf1	d1 e8		 shr	 eax, 1
  00cf3	83 e0 03	 and	 eax, 3
  00cf6	83 c8 01	 or	 eax, 1
  00cf9	83 e0 03	 and	 eax, 3
  00cfc	d1 e0		 shl	 eax, 1
  00cfe	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d06	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  00d0c	83 e1 f9	 and	 ecx, -7			; fffffff9H
  00d0f	0b c8		 or	 ecx, eax
  00d11	8b c1		 mov	 eax, ecx
  00d13	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d1b	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN53@z900_trans:

; 1608 : 
; 1609 :         /* [3.11.4.2] Place the translated address in the TLB */
; 1610 :         if (!(acctype & ACC_NOTLB))

  00d21	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00d28	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00d2d	85 c0		 test	 eax, eax
  00d2f	0f 85 09 01 00
	00		 jne	 $LN55@z900_trans

; 1611 :         {
; 1612 :             regs->tlb.TLB_ASD(tlbix)   = regs->dat.asd;

  00d35	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00d3a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d42	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00d4a	48 8b 92 18 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2072]
  00d51	48 89 94 c1 60
	b0 00 00	 mov	 QWORD PTR [rcx+rax*8+45152], rdx

; 1613 :             regs->tlb.TLB_VADDR(tlbix) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;

  00d59	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR vaddr$[rsp]
  00d61	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00d67	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d6f	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  00d75	48 0b c1	 or	 rax, rcx
  00d78	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR tlbix$[rsp]
  00d7d	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00d85	48 89 84 ca 60
	d0 00 00	 mov	 QWORD PTR [rdx+rcx*8+53344], rax

; 1614 :             regs->tlb.TLB_PTE(tlbix)   = pte;

  00d8d	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00d92	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d9a	48 8b 54 24 58	 mov	 rdx, QWORD PTR pte$[rsp]
  00d9f	48 89 94 c1 60
	f0 00 00	 mov	 QWORD PTR [rcx+rax*8+61536], rdx

; 1615 :             regs->tlb.common[tlbix]    = (ste & SEGTAB_COMMON) ? 1 : 0;

  00da7	48 8b 44 24 50	 mov	 rax, QWORD PTR ste$[rsp]
  00dac	48 83 e0 10	 and	 rax, 16
  00db0	48 85 c0	 test	 rax, rax
  00db3	74 0d		 je	 SHORT $LN93@z900_trans
  00db5	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv573[rsp], 1
  00dc0	eb 0b		 jmp	 SHORT $LN94@z900_trans
$LN93@z900_trans:
  00dc2	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv573[rsp], 0
$LN94@z900_trans:
  00dcd	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00dd2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00dda	0f b6 94 24 84
	00 00 00	 movzx	 edx, BYTE PTR tv573[rsp]
  00de2	88 94 01 60 54
	01 00		 mov	 BYTE PTR [rcx+rax+87136], dl

; 1616 :             regs->tlb.protect[tlbix]   = regs->dat.protect;

  00de9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00df1	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00df7	d1 e8		 shr	 eax, 1
  00df9	83 e0 03	 and	 eax, 3
  00dfc	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR tlbix$[rsp]
  00e01	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00e09	88 84 0a 60 58
	01 00		 mov	 BYTE PTR [rdx+rcx+88160], al

; 1617 :             regs->tlb.acc[tlbix]       = 0;

  00e10	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00e15	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e1d	c6 84 01 60 5c
	01 00 00	 mov	 BYTE PTR [rcx+rax+89184], 0

; 1618 :             regs->tlb.main[tlbix]      = NULL;

  00e25	48 63 44 24 28	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00e2a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e32	48 c7 84 c1 60
	10 01 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax*8+69728], 0
$LN55@z900_trans:
$LN6@z900_trans:

; 1619 :         }
; 1620 :     }
; 1621 : 
; 1622 :     if(!(acctype & ACC_PTE))

  00e3e	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00e45	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00e4a	85 c0		 test	 eax, eax
  00e4c	75 48		 jne	 SHORT $LN56@z900_trans

; 1623 :     {
; 1624 :         /* Combine the page frame real address with the byte index
; 1625 :            of the virtual address to form the real address */
; 1626 :         regs->dat.raddr = (pte & ZPGETAB_PFRA) | (vaddr & 0xFFF);

  00e4e	48 8b 44 24 58	 mov	 rax, QWORD PTR pte$[rsp]
  00e53	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00e59	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR vaddr$[rsp]
  00e61	48 81 e1 ff 0f
	00 00		 and	 rcx, 4095		; 00000fffH
  00e68	48 0b c1	 or	 rax, rcx
  00e6b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e73	48 89 81 00 08
	00 00		 mov	 QWORD PTR [rcx+2048], rax

; 1627 :         regs->dat.rpfra = (pte & ZPGETAB_PFRA);

  00e7a	48 8b 44 24 58	 mov	 rax, QWORD PTR pte$[rsp]
  00e7f	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00e85	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e8d	48 89 81 10 08
	00 00		 mov	 QWORD PTR [rcx+2064], rax

; 1628 :     }

  00e94	eb 14		 jmp	 SHORT $LN57@z900_trans
$LN56@z900_trans:

; 1629 :     else
; 1630 :         regs->dat.raddr = pto;

  00e96	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e9e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pto$[rsp]
  00ea3	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx
$LN57@z900_trans:

; 1631 : #endif /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1632 : 
; 1633 :     /*-----------------------------------------------------------*/
; 1634 :     /* The following code is common to S/370, ESA/390, and ESAME */
; 1635 :     /*-----------------------------------------------------------*/
; 1636 : 
; 1637 :     /* Clear exception code and return with zero return code */
; 1638 :     regs->dat.xcode = 0;

  00eaa	33 c0		 xor	 eax, eax
  00eac	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00eb4	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1639 :     return 0;

  00ebb	33 c0		 xor	 eax, eax
  00ebd	e9 a0 05 00 00	 jmp	 $LN1@z900_trans
$address_excp$105:

; 1640 : 
; 1641 : /* Conditions which always cause program check, except
; 1642 :    when performing translation for the control panel */
; 1643 : address_excp:
; 1644 : //    LOGMSG("dat.c: addressing exception: %8.8X %8.8X %4.4X %8.8X\n",
; 1645 : //        regs->CR(0),regs->dat.asd,pte,vaddr);
; 1646 :     regs->dat.xcode = PGM_ADDRESSING_EXCEPTION;

  00ec2	b8 05 00 00 00	 mov	 eax, 5
  00ec7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ecf	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1647 :     goto tran_prog_check;

  00ed6	eb 2a		 jmp	 SHORT $tran_prog_check$114
$tran_spec_excp$101:

; 1648 : 
; 1649 : tran_spec_excp:
; 1650 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1651 : //    LOGMSG("dat.c: translation specification exception...\n");
; 1652 : //    LOGMSG("       pte = %16.16"PRIX64", ste = %16.16"PRIX64", rte=%16.16"PRIX64"\n",
; 1653 : //        pte, ste, rte);
; 1654 : #else
; 1655 : //    LOGMSG("dat.c: translation specification exception...\n");
; 1656 : //    LOGMSG("       cr0=%8.8X ste=%8.8X pte=%4.4X vaddr=%8.8X\n",
; 1657 : //        regs->CR(0),ste,pte,vaddr);
; 1658 : #endif
; 1659 :     regs->dat.xcode = PGM_TRANSLATION_SPECIFICATION_EXCEPTION;

  00ed8	b8 12 00 00 00	 mov	 eax, 18
  00edd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ee5	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1660 :     goto tran_prog_check;

  00eec	eb 14		 jmp	 SHORT $tran_prog_check$114
$spec_oper_excp$102:

; 1661 : 
; 1662 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1663 : spec_oper_excp:
; 1664 :     regs->dat.xcode = PGM_SPECIAL_OPERATION_EXCEPTION;

  00eee	b8 13 00 00 00	 mov	 eax, 19
  00ef3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00efb	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax
$tran_prog_check$114:

; 1665 :     goto tran_prog_check;
; 1666 : #endif
; 1667 : 
; 1668 : tran_prog_check:
; 1669 : #if defined( FEATURE_036_ENH_MONITOR_FACILITY )
; 1670 :     if (FACILITY_ENABLED( 036_ENH_MONITOR, regs ))

  00f02	b8 01 00 00 00	 mov	 eax, 1
  00f07	48 6b c0 04	 imul	 rax, rax, 4
  00f0b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f13	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00f1b	83 e0 08	 and	 eax, 8
  00f1e	85 c0		 test	 eax, eax
  00f20	74 21		 je	 SHORT $LN58@z900_trans

; 1671 :     {
; 1672 :         /* No program interrupt for enhanced MC */
; 1673 :         if (acctype & ACC_ENH_MC)

  00f22	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00f29	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  00f2e	85 c0		 test	 eax, eax
  00f30	74 11		 je	 SHORT $LN59@z900_trans

; 1674 :         {
; 1675 :             cc = 5;

  00f32	c7 44 24 24 05
	00 00 00	 mov	 DWORD PTR cc$[rsp], 5

; 1676 :             return cc;

  00f3a	8b 44 24 24	 mov	 eax, DWORD PTR cc$[rsp]
  00f3e	e9 1f 05 00 00	 jmp	 $LN1@z900_trans
$LN59@z900_trans:
$LN58@z900_trans:

; 1677 :         }
; 1678 :     }
; 1679 : #endif
; 1680 :     regs->program_interrupt( regs, regs->dat.xcode );

  00f43	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f4b	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00f52	8b d0		 mov	 edx, eax
  00f54	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f5c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f64	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$seg_tran_invalid$112:

; 1681 : 
; 1682 : /* Conditions which the caller may or may not program check */
; 1683 : seg_tran_invalid:
; 1684 :     /* For LPTEA, return segment table entry address with cc 2 */
; 1685 :     if (acctype & ACC_LPTEA)

  00f6a	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00f71	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00f76	85 c0		 test	 eax, eax
  00f78	74 25		 je	 SHORT $LN60@z900_trans

; 1686 :     {
; 1687 :         regs->dat.raddr = sto;

  00f7a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f82	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  00f87	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1688 :         cc = 2;

  00f8e	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1689 :         return cc;

  00f96	8b 44 24 24	 mov	 eax, DWORD PTR cc$[rsp]
  00f9a	e9 c3 04 00 00	 jmp	 $LN1@z900_trans
$LN60@z900_trans:

; 1690 :     } /* end if(ACCTYPE_LPTEA) */
; 1691 : 
; 1692 :     /* Otherwise set translation exception code */
; 1693 :     regs->dat.xcode = PGM_SEGMENT_TRANSLATION_EXCEPTION;

  00f9f	b8 10 00 00 00	 mov	 eax, 16
  00fa4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fac	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1694 :     regs->dat.raddr = sto;

  00fb3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fbb	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  00fc0	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1695 :     cc = 1;

  00fc7	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 1696 :     goto tran_excp_addr;

  00fcf	e9 fd 01 00 00	 jmp	 $tran_excp_addr$115
$page_tran_invalid$113:

; 1697 : 
; 1698 : page_tran_invalid:
; 1699 :     regs->dat.xcode = PGM_PAGE_TRANSLATION_EXCEPTION;

  00fd4	b8 11 00 00 00	 mov	 eax, 17
  00fd9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fe1	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1700 :     regs->dat.raddr = pto;

  00fe8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ff0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pto$[rsp]
  00ff5	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1701 :     if(acctype & ACC_PTE) return 0;

  00ffc	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  01003	25 00 02 00 00	 and	 eax, 512		; 00000200H
  01008	85 c0		 test	 eax, eax
  0100a	74 07		 je	 SHORT $LN61@z900_trans
  0100c	33 c0		 xor	 eax, eax
  0100e	e9 4f 04 00 00	 jmp	 $LN1@z900_trans
$LN61@z900_trans:

; 1702 :     cc = 2;

  01013	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1703 :     goto tran_excp_addr;

  0101b	e9 b1 01 00 00	 jmp	 $tran_excp_addr$115
$seg_tran_length$111:

; 1704 : 
; 1705 : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1706 : page_tran_length:
; 1707 :     regs->dat.xcode = PGM_PAGE_TRANSLATION_EXCEPTION;
; 1708 :     regs->dat.raddr = pto;
; 1709 :     cc = 3;
; 1710 :     goto tran_excp_addr;
; 1711 : #endif
; 1712 : 
; 1713 : seg_tran_length:
; 1714 : //  LOGMSG("dat.c: segment translation exception due to segment length\n");
; 1715 : //  LOGMSG("       cr0=" F_RADR " sto=" F_RADR "\n",regs->CR(0),sto);
; 1716 :     regs->dat.xcode = PGM_SEGMENT_TRANSLATION_EXCEPTION;

  01020	b8 10 00 00 00	 mov	 eax, 16
  01025	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0102d	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1717 :     regs->dat.raddr = sto;

  01034	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0103c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  01041	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1718 :     cc = 3;

  01048	c7 44 24 24 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3

; 1719 :     goto tran_excp_addr;

  01050	e9 7c 01 00 00	 jmp	 $tran_excp_addr$115
$tran_alet_excp$100:

; 1720 : 
; 1721 : tran_alet_excp:
; 1722 :     regs->excarid = arn;

  01055	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0105d	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR arn$[rsp]
  01065	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl

; 1723 :     cc = (acctype & ACC_LPTEA) ? 3 : 4;

  0106b	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  01072	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  01077	85 c0		 test	 eax, eax
  01079	74 0d		 je	 SHORT $LN95@z900_trans
  0107b	c7 84 24 88 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv631[rsp], 3
  01086	eb 0b		 jmp	 SHORT $LN96@z900_trans
$LN95@z900_trans:
  01088	c7 84 24 88 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv631[rsp], 4
$LN96@z900_trans:
  01093	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv631[rsp]
  0109a	89 44 24 24	 mov	 DWORD PTR cc$[rsp], eax

; 1724 :     return cc;

  0109e	8b 44 24 24	 mov	 eax, DWORD PTR cc$[rsp]
  010a2	e9 bb 03 00 00	 jmp	 $LN1@z900_trans
$reg_first_invalid$106:

; 1725 : 
; 1726 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1727 : reg_first_invalid:
; 1728 :     /* For LPTEA, return region table entry address with cc 2 */
; 1729 :     if (acctype & ACC_LPTEA)

  010a7	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  010ae	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  010b3	85 c0		 test	 eax, eax
  010b5	74 29		 je	 SHORT $LN62@z900_trans

; 1730 :     {
; 1731 :         regs->dat.raddr = rto | (TT_R1TABL >> 2);

  010b7	48 8b 44 24 30	 mov	 rax, QWORD PTR sto$[rsp]
  010bc	48 83 c8 03	 or	 rax, 3
  010c0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010c8	48 89 81 00 08
	00 00		 mov	 QWORD PTR [rcx+2048], rax

; 1732 :         cc = 2;

  010cf	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1733 :         return cc;

  010d7	8b 44 24 24	 mov	 eax, DWORD PTR cc$[rsp]
  010db	e9 82 03 00 00	 jmp	 $LN1@z900_trans
$LN62@z900_trans:

; 1734 :     } /* end if(ACCTYPE_LPTEA) */
; 1735 : 
; 1736 :     /* Otherwise set translation exception code */
; 1737 :     goto reg_first_excp;

  010e0	e9 94 00 00 00	 jmp	 $reg_first_excp$104
$reg_second_invalid$108:

; 1738 : 
; 1739 : reg_second_invalid:
; 1740 :     /* For LPTEA, return region table entry address with cc 2 */
; 1741 :     if (acctype & ACC_LPTEA)

  010e5	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  010ec	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  010f1	85 c0		 test	 eax, eax
  010f3	74 29		 je	 SHORT $LN63@z900_trans

; 1742 :     {
; 1743 :         regs->dat.raddr = rto | (TT_R2TABL >> 2);

  010f5	48 8b 44 24 30	 mov	 rax, QWORD PTR sto$[rsp]
  010fa	48 83 c8 02	 or	 rax, 2
  010fe	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01106	48 89 81 00 08
	00 00		 mov	 QWORD PTR [rcx+2048], rax

; 1744 :         cc = 2;

  0110d	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1745 :         return cc;

  01115	8b 44 24 24	 mov	 eax, DWORD PTR cc$[rsp]
  01119	e9 44 03 00 00	 jmp	 $LN1@z900_trans
$LN63@z900_trans:

; 1746 :     } /* end if(ACCTYPE_LPTEA) */
; 1747 : 
; 1748 :     /* Otherwise set translation exception code */
; 1749 :     goto reg_second_excp;

  0111e	eb 77		 jmp	 SHORT $reg_second_excp$107
$reg_third_invalid$110:

; 1750 : 
; 1751 : reg_third_invalid:
; 1752 :     /* For LPTEA, return region table entry address with cc 2 */
; 1753 :     if (acctype & ACC_LPTEA)

  01120	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  01127	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0112c	85 c0		 test	 eax, eax
  0112e	74 29		 je	 SHORT $LN64@z900_trans

; 1754 :     {
; 1755 :         regs->dat.raddr = rto | (TT_R3TABL >> 2);

  01130	48 8b 44 24 30	 mov	 rax, QWORD PTR sto$[rsp]
  01135	48 83 c8 01	 or	 rax, 1
  01139	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01141	48 89 81 00 08
	00 00		 mov	 QWORD PTR [rcx+2048], rax

; 1756 :         cc = 2;

  01148	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1757 :         return cc;

  01150	8b 44 24 24	 mov	 eax, DWORD PTR cc$[rsp]
  01154	e9 09 03 00 00	 jmp	 $LN1@z900_trans
$LN64@z900_trans:

; 1758 :     } /* end if(ACCTYPE_LPTEA) */
; 1759 : 
; 1760 :     /* Otherwise set translation exception code */
; 1761 :     goto reg_third_excp;

  01159	eb 5a		 jmp	 SHORT $reg_third_excp$109
$asce_type_excp$103:

; 1762 : 
; 1763 : asce_type_excp:
; 1764 : //  LOGMSG("rfx = %4.4X, rsx %4.4X, rtx = %4.4X, tt = %1.1X\n",
; 1765 : //      rfx, rsx, rtx, tt);
; 1766 :     regs->dat.xcode = PGM_ASCE_TYPE_EXCEPTION;

  0115b	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  01160	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01168	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1767 :     cc = 4;

  0116f	c7 44 24 24 04
	00 00 00	 mov	 DWORD PTR cc$[rsp], 4

; 1768 :     goto tran_excp_addr;

  01177	eb 58		 jmp	 SHORT $tran_excp_addr$115
$reg_first_excp$104:

; 1769 : 
; 1770 : reg_first_excp:
; 1771 :     regs->dat.xcode = PGM_REGION_FIRST_TRANSLATION_EXCEPTION;

  01179	b8 39 00 00 00	 mov	 eax, 57			; 00000039H
  0117e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01186	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1772 :     cc = 4;

  0118d	c7 44 24 24 04
	00 00 00	 mov	 DWORD PTR cc$[rsp], 4

; 1773 :     goto tran_excp_addr;

  01195	eb 3a		 jmp	 SHORT $tran_excp_addr$115
$reg_second_excp$107:

; 1774 : 
; 1775 : reg_second_excp:
; 1776 :     regs->dat.xcode = PGM_REGION_SECOND_TRANSLATION_EXCEPTION;

  01197	b8 3a 00 00 00	 mov	 eax, 58			; 0000003aH
  0119c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011a4	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1777 :     cc = 4;

  011ab	c7 44 24 24 04
	00 00 00	 mov	 DWORD PTR cc$[rsp], 4

; 1778 :     goto tran_excp_addr;

  011b3	eb 1c		 jmp	 SHORT $tran_excp_addr$115
$reg_third_excp$109:

; 1779 : 
; 1780 : reg_third_excp:
; 1781 :     regs->dat.xcode = PGM_REGION_THIRD_TRANSLATION_EXCEPTION;

  011b5	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  011ba	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011c2	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1782 :     cc = 4;

  011c9	c7 44 24 24 04
	00 00 00	 mov	 DWORD PTR cc$[rsp], 4
$tran_excp_addr$115:

; 1783 :     goto tran_excp_addr;
; 1784 : #endif /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1785 : 
; 1786 : tran_excp_addr:
; 1787 :     /* For LPTEA instruction, return xcode with cc = 3 */
; 1788 :     if (acctype & ACC_LPTEA)

  011d1	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  011d8	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  011dd	85 c0		 test	 eax, eax
  011df	74 0a		 je	 SHORT $LN65@z900_trans

; 1789 :         return 3;

  011e1	b8 03 00 00 00	 mov	 eax, 3
  011e6	e9 77 02 00 00	 jmp	 $LN1@z900_trans
$LN65@z900_trans:

; 1790 : 
; 1791 :     /* Set the translation exception address */
; 1792 :     regs->TEA = vaddr & PAGEFRAME_PAGEMASK;

  011eb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR vaddr$[rsp]
  011f3	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  011f9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01201	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax

; 1793 : 
; 1794 :     /* Set the address space indication in the exception address */
; 1795 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1796 :     if(regs->dat.stid == TEA_ST_ARMODE)

  01208	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01210	83 b8 20 08 00
	00 01		 cmp	 DWORD PTR [rax+2080], 1
  01217	0f 85 38 01 00
	00		 jne	 $LN66@z900_trans

; 1797 :     {
; 1798 :         if ((regs->dat.asd & ASCE_TO) == (regs->CR(1) & ASCE_TO))

  0121d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01225	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  0122c	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  01232	b9 08 00 00 00	 mov	 ecx, 8
  01237	48 6b c9 02	 imul	 rcx, rcx, 2
  0123b	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01243	48 8b 8c 0a 00
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx+1536]
  0124b	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  01252	48 3b c1	 cmp	 rax, rcx
  01255	75 1b		 jne	 SHORT $LN68@z900_trans

; 1799 :             regs->TEA |= TEA_ST_PRIMARY;

  01257	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0125f	48 8b 88 18 07
	00 00		 mov	 rcx, QWORD PTR [rax+1816]
  01266	48 89 88 18 07
	00 00		 mov	 QWORD PTR [rax+1816], rcx
  0126d	e9 e1 00 00 00	 jmp	 $LN69@z900_trans
$LN68@z900_trans:

; 1800 :         else if ((regs->dat.asd & ASCE_TO) == (regs->CR(7) & ASCE_TO))

  01272	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0127a	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  01281	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  01287	b9 08 00 00 00	 mov	 ecx, 8
  0128c	48 6b c9 08	 imul	 rcx, rcx, 8
  01290	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01298	48 8b 8c 0a 00
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx+1536]
  012a0	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  012a7	48 3b c1	 cmp	 rax, rcx
  012aa	75 27		 jne	 SHORT $LN70@z900_trans

; 1801 :             regs->TEA |= TEA_ST_SECNDRY;

  012ac	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012b4	48 8b 80 18 07
	00 00		 mov	 rax, QWORD PTR [rax+1816]
  012bb	48 83 c8 02	 or	 rax, 2
  012bf	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  012c7	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax
  012ce	e9 80 00 00 00	 jmp	 $LN71@z900_trans
$LN70@z900_trans:

; 1802 :         else if ((regs->dat.asd & ASCE_TO) == (regs->CR(13) & ASCE_TO))

  012d3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012db	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  012e2	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  012e8	b9 08 00 00 00	 mov	 ecx, 8
  012ed	48 6b c9 0e	 imul	 rcx, rcx, 14
  012f1	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  012f9	48 8b 8c 0a 00
	06 00 00	 mov	 rcx, QWORD PTR [rdx+rcx+1536]
  01301	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  01308	48 3b c1	 cmp	 rax, rcx
  0130b	75 24		 jne	 SHORT $LN72@z900_trans

; 1803 :             regs->TEA |= TEA_ST_HOME;

  0130d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01315	48 8b 80 18 07
	00 00		 mov	 rax, QWORD PTR [rax+1816]
  0131c	48 83 c8 03	 or	 rax, 3
  01320	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01328	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax
  0132f	eb 22		 jmp	 SHORT $LN73@z900_trans
$LN72@z900_trans:

; 1804 :         else
; 1805 :             regs->TEA |= TEA_ST_ARMODE;

  01331	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01339	48 8b 80 18 07
	00 00		 mov	 rax, QWORD PTR [rax+1816]
  01340	48 83 c8 01	 or	 rax, 1
  01344	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0134c	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax
$LN73@z900_trans:
$LN71@z900_trans:
$LN69@z900_trans:

; 1806 :     }

  01353	eb 33		 jmp	 SHORT $LN67@z900_trans
$LN66@z900_trans:

; 1807 :     else
; 1808 :         regs->TEA |= regs->dat.stid;

  01355	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0135d	48 63 80 20 08
	00 00		 movsxd	 rax, DWORD PTR [rax+2080]
  01364	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0136c	48 8b 89 18 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1816]
  01373	48 0b c8	 or	 rcx, rax
  01376	48 8b c1	 mov	 rax, rcx
  01379	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01381	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax
$LN67@z900_trans:

; 1809 : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1810 :     if(regs->dat.stid == TEA_ST_ARMODE)
; 1811 :     {
; 1812 :         if ((regs->dat.asd & STD_STO) == (regs->CR(1) & STD_STO))
; 1813 :             regs->TEA |= TEA_ST_PRIMARY;
; 1814 :         else if ((regs->dat.asd & STD_STO) == (regs->CR(7) & STD_STO))
; 1815 :             regs->TEA |= TEA_ST_SECNDRY;
; 1816 :         else if ((regs->dat.asd & STD_STO) == (regs->CR(13) & STD_STO))
; 1817 :             regs->TEA |= TEA_ST_HOME;
; 1818 :         else
; 1819 :             regs->TEA |= TEA_ST_ARMODE;
; 1820 :     }
; 1821 :     else
; 1822 :         if((regs->dat.stid == TEA_ST_SECNDRY)
; 1823 :           && (PRIMARY_SPACE_MODE(&regs->psw)
; 1824 :             || SECONDARY_SPACE_MODE(&regs->psw)))
; 1825 :             regs->TEA |= TEA_ST_SECNDRY | TEA_SECADDR;
; 1826 :         else
; 1827 :             regs->TEA |= regs->dat.stid;
; 1828 : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1829 : 
; 1830 : #if defined( FEATURE_075_ACC_EX_FS_INDIC_FACILITY )
; 1831 :     if (FACILITY_ENABLED( 075_ACC_EX_FS_INDIC, regs ))

  01388	b8 01 00 00 00	 mov	 eax, 1
  0138d	48 6b c0 09	 imul	 rax, rax, 9
  01391	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01399	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  013a1	83 e0 10	 and	 eax, 16
  013a4	85 c0		 test	 eax, eax
  013a6	74 64		 je	 SHORT $LN74@z900_trans

; 1832 :     {
; 1833 :         /* Set the fetch/store indication bits 52-53 in the TEA */
; 1834 :         if (acctype & ACC_READ)

  013a8	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  013af	83 e0 04	 and	 eax, 4
  013b2	85 c0		 test	 eax, eax
  013b4	74 25		 je	 SHORT $LN75@z900_trans

; 1835 :         {
; 1836 :             regs->TEA |= TEA_FETCH;

  013b6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013be	48 8b 80 18 07
	00 00		 mov	 rax, QWORD PTR [rax+1816]
  013c5	48 0f ba e8 0b	 bts	 rax, 11
  013ca	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  013d2	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax

; 1837 :         }

  013d9	eb 31		 jmp	 SHORT $LN76@z900_trans
$LN75@z900_trans:

; 1838 :         else if (acctype & (ACC_WRITE | ACC_CHECK))

  013db	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  013e2	83 e0 03	 and	 eax, 3
  013e5	85 c0		 test	 eax, eax
  013e7	74 23		 je	 SHORT $LN77@z900_trans

; 1839 :         {
; 1840 :             regs->TEA |= TEA_STORE;

  013e9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013f1	48 8b 80 18 07
	00 00		 mov	 rax, QWORD PTR [rax+1816]
  013f8	48 0f ba e8 0a	 bts	 rax, 10
  013fd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01405	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax
$LN77@z900_trans:
$LN76@z900_trans:
$LN74@z900_trans:

; 1841 :         }
; 1842 :     }
; 1843 : #endif
; 1844 :     /* Set the exception access identification */
; 1845 :     if (ACCESS_REGISTER_MODE(&regs->psw)
; 1846 :      || (SIE_ACTIVE(regs) && MULTIPLE_CONTROLLED_DATA_SPACE(GUESTREGS))

  0140c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01414	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  01418	83 f8 40	 cmp	 eax, 64			; 00000040H
  0141b	74 06		 je	 SHORT $LN79@z900_trans
  0141d	33 c0		 xor	 eax, eax
  0141f	85 c0		 test	 eax, eax
  01421	74 3b		 je	 SHORT $LN78@z900_trans
$LN79@z900_trans:

; 1847 :        )
; 1848 :        regs->excarid = arn < 0 ? 0 : arn;

  01423	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  0142b	7d 0d		 jge	 SHORT $LN97@z900_trans
  0142d	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv716[rsp], 0
  01438	eb 0e		 jmp	 SHORT $LN98@z900_trans
$LN97@z900_trans:
  0143a	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  01441	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv716[rsp], eax
$LN98@z900_trans:
  01448	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01450	0f b6 8c 24 8c
	00 00 00	 movzx	 ecx, BYTE PTR tv716[rsp]
  01458	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl
$LN78@z900_trans:

; 1849 : 
; 1850 :     /* Return condition code */
; 1851 :     return cc;

  0145e	8b 44 24 24	 mov	 eax, DWORD PTR cc$[rsp]
$LN1@z900_trans:

; 1852 : 
; 1853 : } /* end function translate_addr */

  01462	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  01469	c3		 ret	 0
z900_translate_addr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tlbix$ = 32
cc$ = 36
pto$ = 40
sto$ = 48
pte$ = 56
ste$ = 64
tv88 = 72
tv291 = 76
tv343 = 80
tv409 = 84
stl$ = 88
ptl$ = 92
tv206 = 96
tv243 = 104
vaddr$ = 128
arn$ = 136
regs$ = 144
acctype$ = 152
s390_translate_addr PROC

; 935  : {

$LN51:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 936  : RADR    sto = 0;                        /* Segment table origin      */

  00016	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR sto$[rsp], 0

; 937  : RADR    pto = 0;                        /* Page table origin         */

  0001f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR pto$[rsp], 0

; 938  : int     cc;                             /* Condition code            */
; 939  : int     tlbix = TLBIX(vaddr);           /* TLB entry index           */

  00028	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  0002f	c1 e8 0c	 shr	 eax, 12
  00032	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00037	89 44 24 20	 mov	 DWORD PTR tlbix$[rsp], eax

; 940  : 
; 941  : #if !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 942  : /*-----------------------------------*/
; 943  : /* S/370 Dynamic Address Translation */
; 944  : /*-----------------------------------*/
; 945  : U32     stl;                            /* Segment table length      */
; 946  : RADR    ste;                            /* Segment table entry       */
; 947  : U16     pte;                            /* Page table entry          */
; 948  : U32     ptl;                            /* Page table length         */
; 949  : 
; 950  :     regs->dat.pvtaddr = regs->dat.protect = 0;
; 951  : 
; 952  :     /* Load the effective segment table descriptor */
; 953  :     if (ARCH_DEP(load_address_space_designator) (arn, regs, acctype))
; 954  :         goto tran_alet_excp;
; 955  : 
; 956  :     /* Check the translation format bits in CR0 */
; 957  :     if ((((regs->CR(0) & CR0_PAGE_SIZE) != CR0_PAGE_SZ_2K) &&
; 958  :        ((regs->CR(0) & CR0_PAGE_SIZE) != CR0_PAGE_SZ_4K)) ||
; 959  :        (((regs->CR(0) & CR0_SEG_SIZE) != CR0_SEG_SZ_64K) &&
; 960  :        ((regs->CR(0) & CR0_SEG_SIZE) != CR0_SEG_SZ_1M)))
; 961  :        goto tran_spec_excp;
; 962  : 
; 963  :     /* Look up the address in the TLB */
; 964  :     if (   ((vaddr & TLBID_PAGEMASK) | regs->tlbID) == regs->tlb.TLB_VADDR(tlbix)
; 965  :         && (regs->tlb.common[tlbix] || regs->dat.asd == regs->tlb.TLB_ASD(tlbix))
; 966  :         && !(regs->tlb.common[tlbix] && regs->dat.pvtaddr)
; 967  :         && !(acctype & ACC_NOTLB) )
; 968  :     {
; 969  :         pte = regs->tlb.TLB_PTE(tlbix);
; 970  : 
; 971  : #if defined( FEATURE_SEGMENT_PROTECTION )
; 972  :         /* Set the protection indicator if segment is protected */
; 973  :         if (regs->tlb.protect[tlbix])
; 974  :             regs->dat.protect = regs->tlb.protect[tlbix];
; 975  : #endif
; 976  :     }
; 977  :     else
; 978  :     {
; 979  :         /* S/370 segment table lookup */
; 980  : 
; 981  :         /* Calculate the real address of the segment table entry */
; 982  :         sto = regs->dat.asd & STD_370_STO;
; 983  :         stl = regs->dat.asd & STD_370_STL;
; 984  :         sto += ((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_1M) ?
; 985  :             ((vaddr & 0x00F00000) >> 18) :
; 986  :             ((vaddr & 0x00FF0000) >> 14);
; 987  : 
; 988  :         /* Check that virtual address is within the segment table */
; 989  :         if (((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_64K) &&
; 990  :             ((vaddr << 4) & STD_370_STL) > stl)
; 991  :             goto seg_tran_length;
; 992  : 
; 993  :         /* Generate addressing exception if outside real storage */
; 994  :         if (sto > regs->mainlim)
; 995  :             goto address_excp;
; 996  : 
; 997  :         /* Fetch segment table entry from real storage.  All bytes
; 998  :            must be fetched concurrently as observed by other CPUs */
; 999  :         sto = APPLY_PREFIXING (sto, regs->PX);
; 1000 :         ste = ARCH_DEP(fetch_fullword_absolute) (sto, regs);
; 1001 : 
; 1002 :         /* Generate segment translation exception if segment invalid */
; 1003 :         if (ste & SEGTAB_370_INVL)
; 1004 :             goto seg_tran_invalid;
; 1005 : 
; 1006 :         /* Check that all the reserved bits in the STE are zero */
; 1007 :         if (ste & SEGTAB_370_RSV)
; 1008 :             goto tran_spec_excp;
; 1009 : 
; 1010 :         /* Isolate page table origin and length */
; 1011 :         pto = ste & SEGTAB_370_PTO;
; 1012 :         ptl = ste & SEGTAB_370_PTL;
; 1013 : 
; 1014 :         /* S/370 page table lookup */
; 1015 : 
; 1016 :         /* Calculate the real address of the page table entry */
; 1017 :         pto += ((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_1M) ?
; 1018 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 1019 :             ((vaddr & 0x000FF000) >> 11) :
; 1020 :             ((vaddr & 0x000FF800) >> 10)) :
; 1021 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 1022 :             ((vaddr & 0x0000F000) >> 11) :
; 1023 :             ((vaddr & 0x0000F800) >> 10));
; 1024 : 
; 1025 :         /* Generate addressing exception if outside real storage */
; 1026 :         if (pto > regs->mainlim)
; 1027 :             goto address_excp;
; 1028 : 
; 1029 :         /* Check that the virtual address is within the page table */
; 1030 :         if ((((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_1M) &&
; 1031 :             (((vaddr & 0x000F0000) >> 16) > ptl)) ||
; 1032 :             (((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_64K) &&
; 1033 :             (((vaddr & 0x0000F000) >> 12) > ptl)))
; 1034 :             goto page_tran_length;
; 1035 : 
; 1036 :         /* Fetch the page table entry from real storage.  All bytes
; 1037 :            must be fetched concurrently as observed by other CPUs */
; 1038 :         pto = APPLY_PREFIXING (pto, regs->PX);
; 1039 :         pte = ARCH_DEP(fetch_halfword_absolute) (pto, regs);
; 1040 : 
; 1041 :         /* Generate page translation exception if page invalid */
; 1042 :         if ((((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) &&
; 1043 :             (pte & PAGETAB_INV_4K)) ||
; 1044 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_2K) &&
; 1045 :             (pte & PAGETAB_INV_2K)))
; 1046 :             goto page_tran_invalid;
; 1047 : 
; 1048 :         /* Check that all the reserved bits in the PTE are zero */
; 1049 :         if (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_2K) &&
; 1050 :             (pte & PAGETAB_RSV_2K))
; 1051 :             goto tran_spec_excp;
; 1052 : 
; 1053 : #if defined( FEATURE_SEGMENT_PROTECTION )
; 1054 :         /* Set the protection indicator if segment is protected */
; 1055 :         if (ste & SEGTAB_370_PROT)
; 1056 :             regs->dat.protect |= 1;
; 1057 : #endif
; 1058 : 
; 1059 :         /* Place the translated address in the TLB */
; 1060 :         if (!(acctype & ACC_NOTLB))
; 1061 :         {
; 1062 :             regs->tlb.TLB_ASD(tlbix)   = regs->dat.asd;
; 1063 :             regs->tlb.TLB_VADDR(tlbix) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;
; 1064 :             regs->tlb.TLB_PTE(tlbix)   = pte;
; 1065 :             regs->tlb.common[tlbix]    = (ste & SEGTAB_370_CMN) ? 1 : 0;
; 1066 :             regs->tlb.protect[tlbix]   = regs->dat.protect;
; 1067 :             regs->tlb.acc[tlbix]       = 0;
; 1068 :             regs->tlb.main[tlbix]      = NULL;
; 1069 : 
; 1070 :             /* Set adjacent TLB entry if 4K page sizes */
; 1071 :             if ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K)
; 1072 :             {
; 1073 :                 regs->tlb.TLB_ASD(tlbix^1)   = regs->tlb.TLB_ASD(tlbix);
; 1074 :                 regs->tlb.TLB_VADDR(tlbix^1) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;
; 1075 :                 regs->tlb.TLB_PTE(tlbix^1)   = regs->tlb.TLB_PTE(tlbix);
; 1076 :                 regs->tlb.common[tlbix^1]    = regs->tlb.common[tlbix];
; 1077 :                 regs->tlb.protect[tlbix^1]   = regs->tlb.protect[tlbix];
; 1078 :                 regs->tlb.acc[tlbix^1]       = 0;
; 1079 :                 regs->tlb.main[tlbix^1]      = NULL;
; 1080 :             }
; 1081 :         }
; 1082 :     } /* end if(!TLB) */
; 1083 : 
; 1084 :     /* Combine the page frame real address with the byte
; 1085 :        index of the virtual address to form the real address */
; 1086 :     regs->dat.raddr = ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 1087 : #if defined( FEATURE_S370E_EXTENDED_ADDRESSING )
; 1088 :         (((U32)pte & PAGETAB_EA_4K) << 23) |
; 1089 : #endif
; 1090 :         (((U32)pte & PAGETAB_PFRA_4K) << 8) | (vaddr & 0xFFF) :
; 1091 :         (((U32)pte & PAGETAB_PFRA_2K) << 8) | (vaddr & 0x7FF);
; 1092 : 
; 1093 :     regs->dat.rpfra = regs->dat.raddr & PAGEFRAME_PAGEMASK;
; 1094 : #endif /* !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1095 : 
; 1096 : #if defined( FEATURE_S390_DAT )
; 1097 : /*-----------------------------------*/
; 1098 : /* S/390 Dynamic Address Translation */
; 1099 : /*-----------------------------------*/
; 1100 : U32     stl;                            /* Segment table length      */
; 1101 : RADR    ste;                            /* Segment table entry       */
; 1102 : RADR    pte;                            /* Page table entry          */
; 1103 : U32     ptl;                            /* Page table length         */
; 1104 : 
; 1105 :     regs->dat.pvtaddr = regs->dat.protect = 0;

  0003b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00043	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00049	83 e0 f9	 and	 eax, -7			; fffffff9H
  0004c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
  0005a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00062	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00068	83 e0 fe	 and	 eax, -2			; fffffffeH
  0006b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00073	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 1106 : 
; 1107 :     /* [3.11.3.1] Load the effective segment table descriptor */
; 1108 :     if (ARCH_DEP(load_address_space_designator) (arn, regs, acctype))

  00079	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR acctype$[rsp]
  00081	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00089	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR arn$[rsp]
  00090	e8 00 00 00 00	 call	 s390_load_address_space_designator
  00095	0f b7 c0	 movzx	 eax, ax
  00098	85 c0		 test	 eax, eax
  0009a	74 05		 je	 SHORT $LN2@s390_trans

; 1109 :         goto tran_alet_excp;

  0009c	e9 4f 07 00 00	 jmp	 $tran_alet_excp$52
$LN2@s390_trans:

; 1110 : 
; 1111 :     /* [3.11.3.2] Check the translation format bits in CR0 */
; 1112 :     if ((regs->CR(0) & CR0_TRAN_FMT) != CR0_TRAN_ESA390)

  000a1	b8 08 00 00 00	 mov	 eax, 8
  000a6	48 6b c0 01	 imul	 rax, rax, 1
  000aa	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b2	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000b9	25 00 00 f8 00	 and	 eax, 16252928		; 00f80000H
  000be	3d 00 00 b0 00	 cmp	 eax, 11534336		; 00b00000H
  000c3	74 05		 je	 SHORT $LN3@s390_trans

; 1113 :         goto tran_spec_excp;

  000c5	e9 d1 05 00 00	 jmp	 $tran_spec_excp$53
$LN3@s390_trans:

; 1114 : 
; 1115 :     /* Extract the private space bit from segment table descriptor */
; 1116 :     regs->dat.pvtaddr = ((regs->dat.asd & STD_PRIVATE) != 0);

  000ca	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  000d9	48 25 00 01 00
	00		 and	 rax, 256		; 00000100H
  000df	48 85 c0	 test	 rax, rax
  000e2	74 0a		 je	 SHORT $LN39@s390_trans
  000e4	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  000ec	eb 08		 jmp	 SHORT $LN40@s390_trans
$LN39@s390_trans:
  000ee	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN40@s390_trans:
  000f6	8b 44 24 48	 mov	 eax, DWORD PTR tv88[rsp]
  000fa	83 e0 01	 and	 eax, 1
  000fd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00105	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  0010b	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0010e	0b c8		 or	 ecx, eax
  00110	8b c1		 mov	 eax, ecx
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011a	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 1117 : 
; 1118 :     /* [3.11.4] Look up the address in the TLB */
; 1119 :     if (   ((vaddr & TLBID_PAGEMASK) | regs->tlbID) == regs->tlb.TLB_VADDR(tlbix)
; 1120 :         && (regs->tlb.common[tlbix] || regs->dat.asd == regs->tlb.TLB_ASD(tlbix))
; 1121 :         && !(regs->tlb.common[tlbix] && regs->dat.pvtaddr)
; 1122 :         && !(acctype & ACC_NOTLB) )

  00120	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  00127	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0012c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  0013a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR tlbix$[rsp]
  0013f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00147	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  0014e	0f 85 f8 00 00
	00		 jne	 $LN4@s390_trans
  00154	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00159	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	0f b6 84 01 60
	54 01 00	 movzx	 eax, BYTE PTR [rcx+rax+87136]
  00169	85 c0		 test	 eax, eax
  0016b	75 29		 jne	 SHORT $LN6@s390_trans
  0016d	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00172	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017a	8b 84 c1 60 b0
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+45152]
  00181	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00189	48 39 81 18 08
	00 00		 cmp	 QWORD PTR [rcx+2072], rax
  00190	0f 85 b6 00 00
	00		 jne	 $LN4@s390_trans
$LN6@s390_trans:
  00196	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  0019b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a3	0f b6 84 01 60
	54 01 00	 movzx	 eax, BYTE PTR [rcx+rax+87136]
  001ab	85 c0		 test	 eax, eax
  001ad	74 19		 je	 SHORT $LN7@s390_trans
  001af	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  001bd	83 e0 01	 and	 eax, 1
  001c0	85 c0		 test	 eax, eax
  001c2	0f 85 84 00 00
	00		 jne	 $LN4@s390_trans
$LN7@s390_trans:
  001c8	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  001cf	25 00 01 00 00	 and	 eax, 256		; 00000100H
  001d4	85 c0		 test	 eax, eax
  001d6	75 74		 jne	 SHORT $LN4@s390_trans

; 1123 :     {
; 1124 :         pte = regs->tlb.TLB_PTE(tlbix);

  001d8	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  001dd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e5	8b 84 c1 60 f0
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+61536]
  001ec	48 89 44 24 38	 mov	 QWORD PTR pte$[rsp], rax

; 1125 :         if (regs->tlb.protect[tlbix])

  001f1	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  001f6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fe	0f b6 84 01 60
	58 01 00	 movzx	 eax, BYTE PTR [rcx+rax+88160]
  00206	85 c0		 test	 eax, eax
  00208	74 3d		 je	 SHORT $LN8@s390_trans

; 1126 :             regs->dat.protect = regs->tlb.protect[tlbix];

  0020a	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  0020f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00217	0f b6 84 01 60
	58 01 00	 movzx	 eax, BYTE PTR [rcx+rax+88160]
  0021f	83 e0 03	 and	 eax, 3
  00222	d1 e0		 shl	 eax, 1
  00224	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0022c	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  00232	83 e1 f9	 and	 ecx, -7			; fffffff9H
  00235	0b c8		 or	 ecx, eax
  00237	8b c1		 mov	 eax, ecx
  00239	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00241	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN8@s390_trans:

; 1127 :     }

  00247	e9 b5 03 00 00	 jmp	 $LN5@s390_trans
$LN4@s390_trans:

; 1128 :     else
; 1129 :     {
; 1130 :         /* [3.11.3.3] Segment table lookup */
; 1131 : 
; 1132 :         /* Calculate the real address of the segment table entry */
; 1133 :         sto = regs->dat.asd & STD_STO;

  0024c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00254	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  0025b	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  00261	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 1134 :         stl = regs->dat.asd & STD_STL;

  00266	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026e	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00275	48 83 e0 7f	 and	 rax, 127		; 0000007fH
  00279	89 44 24 58	 mov	 DWORD PTR stl$[rsp], eax

; 1135 :         sto += (vaddr & 0x7FF00000) >> 18;

  0027d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  00284	25 00 00 f0 7f	 and	 eax, 2146435072		; 7ff00000H
  00289	c1 e8 12	 shr	 eax, 18
  0028c	8b c0		 mov	 eax, eax
  0028e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  00293	48 03 c8	 add	 rcx, rax
  00296	48 8b c1	 mov	 rax, rcx
  00299	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 1136 : 
; 1137 :         /* Check that virtual address is within the segment table */
; 1138 :         if ((vaddr >> 24) > stl)

  0029e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  002a5	c1 e8 18	 shr	 eax, 24
  002a8	3b 44 24 58	 cmp	 eax, DWORD PTR stl$[rsp]
  002ac	76 05		 jbe	 SHORT $LN9@s390_trans

; 1139 :             goto seg_tran_length;

  002ae	e9 0b 05 00 00	 jmp	 $seg_tran_length$54
$LN9@s390_trans:

; 1140 : 
; 1141 :         /* Generate addressing exception if outside real storage */
; 1142 :         if (sto > regs->mainlim)

  002b3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bb	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  002c2	48 39 44 24 30	 cmp	 QWORD PTR sto$[rsp], rax
  002c7	76 05		 jbe	 SHORT $LN10@s390_trans

; 1143 :             goto address_excp;

  002c9	e9 b7 03 00 00	 jmp	 $address_excp$55
$LN10@s390_trans:

; 1144 : 
; 1145 :         /* Fetch segment table entry from real storage.  All bytes
; 1146 :            must be fetched concurrently as observed by other CPUs */
; 1147 :         sto = APPLY_PREFIXING (sto, regs->PX);

  002ce	8b 44 24 30	 mov	 eax, DWORD PTR sto$[rsp]
  002d2	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  002d8	48 85 c0	 test	 rax, rax
  002db	74 26		 je	 SHORT $LN41@s390_trans
  002dd	8b 44 24 30	 mov	 eax, DWORD PTR sto$[rsp]
  002e1	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  002e7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ef	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  002f2	48 3b c1	 cmp	 rax, rcx
  002f5	74 0c		 je	 SHORT $LN41@s390_trans
  002f7	48 8b 44 24 30	 mov	 rax, QWORD PTR sto$[rsp]
  002fc	48 89 44 24 60	 mov	 QWORD PTR tv206[rsp], rax
  00301	eb 1a		 jmp	 SHORT $LN42@s390_trans
$LN41@s390_trans:
  00303	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0030e	8b 4c 24 30	 mov	 ecx, DWORD PTR sto$[rsp]
  00312	33 c8		 xor	 ecx, eax
  00314	8b c1		 mov	 eax, ecx
  00316	8b c0		 mov	 eax, eax
  00318	48 89 44 24 60	 mov	 QWORD PTR tv206[rsp], rax
$LN42@s390_trans:
  0031d	48 8b 44 24 60	 mov	 rax, QWORD PTR tv206[rsp]
  00322	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 1148 :         ste = ARCH_DEP(fetch_fullword_absolute) (sto, regs);

  00327	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0032f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  00334	e8 00 00 00 00	 call	 s390_fetch_fullword_absolute
  00339	8b c0		 mov	 eax, eax
  0033b	48 89 44 24 40	 mov	 QWORD PTR ste$[rsp], rax

; 1149 : 
; 1150 :         /* Generate segment translation exception if segment invalid */
; 1151 :         if (ste & SEGTAB_INVALID)

  00340	48 8b 44 24 40	 mov	 rax, QWORD PTR ste$[rsp]
  00345	48 83 e0 20	 and	 rax, 32			; 00000020H
  00349	48 85 c0	 test	 rax, rax
  0034c	74 05		 je	 SHORT $LN11@s390_trans

; 1152 :             goto seg_tran_invalid;

  0034e	e9 83 03 00 00	 jmp	 $seg_tran_invalid$56
$LN11@s390_trans:

; 1153 : 
; 1154 :         /* Check that all the reserved bits in the STE are zero */
; 1155 :         if (ste & SEGTAB_RESV)

  00353	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00358	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ste$[rsp]
  0035d	48 23 c8	 and	 rcx, rax
  00360	48 8b c1	 mov	 rax, rcx
  00363	48 85 c0	 test	 rax, rax
  00366	74 05		 je	 SHORT $LN12@s390_trans

; 1156 :             goto tran_spec_excp;

  00368	e9 2e 03 00 00	 jmp	 $tran_spec_excp$53
$LN12@s390_trans:

; 1157 : 
; 1158 :         /* If the segment table origin register indicates a private
; 1159 :            address space then STE must not indicate a common segment */
; 1160 :         if (regs->dat.pvtaddr && (ste & (SEGTAB_COMMON)))

  0036d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00375	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0037b	83 e0 01	 and	 eax, 1
  0037e	85 c0		 test	 eax, eax
  00380	74 13		 je	 SHORT $LN13@s390_trans
  00382	48 8b 44 24 40	 mov	 rax, QWORD PTR ste$[rsp]
  00387	48 83 e0 10	 and	 rax, 16
  0038b	48 85 c0	 test	 rax, rax
  0038e	74 05		 je	 SHORT $LN13@s390_trans

; 1161 :             goto tran_spec_excp;

  00390	e9 06 03 00 00	 jmp	 $tran_spec_excp$53
$LN13@s390_trans:

; 1162 : 
; 1163 :         /* Isolate page table origin and length */
; 1164 :         pto = ste & SEGTAB_PTO;

  00395	48 8b 44 24 40	 mov	 rax, QWORD PTR ste$[rsp]
  0039a	48 25 c0 ff ff
	7f		 and	 rax, 2147483584		; 7fffffc0H
  003a0	48 89 44 24 28	 mov	 QWORD PTR pto$[rsp], rax

; 1165 :         ptl = ste & SEGTAB_PTL;

  003a5	48 8b 44 24 40	 mov	 rax, QWORD PTR ste$[rsp]
  003aa	48 83 e0 0f	 and	 rax, 15
  003ae	89 44 24 5c	 mov	 DWORD PTR ptl$[rsp], eax

; 1166 : 
; 1167 :         /* [3.11.3.4] Page table lookup */
; 1168 : 
; 1169 :         /* Calculate the real address of the page table entry */
; 1170 :         pto += (vaddr & 0x000FF000) >> 10;

  003b2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  003b9	25 00 f0 0f 00	 and	 eax, 1044480		; 000ff000H
  003be	c1 e8 0a	 shr	 eax, 10
  003c1	8b c0		 mov	 eax, eax
  003c3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pto$[rsp]
  003c8	48 03 c8	 add	 rcx, rax
  003cb	48 8b c1	 mov	 rax, rcx
  003ce	48 89 44 24 28	 mov	 QWORD PTR pto$[rsp], rax

; 1171 : 
; 1172 :         /* Check that the virtual address is within the page table */
; 1173 :         if (((vaddr & 0x000FF000) >> 16) > ptl)

  003d3	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  003da	25 00 f0 0f 00	 and	 eax, 1044480		; 000ff000H
  003df	c1 e8 10	 shr	 eax, 16
  003e2	3b 44 24 5c	 cmp	 eax, DWORD PTR ptl$[rsp]
  003e6	76 05		 jbe	 SHORT $LN14@s390_trans

; 1174 :             goto page_tran_length;

  003e8	e9 9f 03 00 00	 jmp	 $page_tran_length$57
$LN14@s390_trans:

; 1175 : 
; 1176 :         /* Generate addressing exception if outside real storage */
; 1177 :         if (pto > regs->mainlim)

  003ed	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f5	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  003fc	48 39 44 24 28	 cmp	 QWORD PTR pto$[rsp], rax
  00401	76 05		 jbe	 SHORT $LN15@s390_trans

; 1178 :             goto address_excp;

  00403	e9 7d 02 00 00	 jmp	 $address_excp$55
$LN15@s390_trans:

; 1179 : 
; 1180 :         /* Fetch the page table entry from real storage.  All bytes
; 1181 :            must be fetched concurrently as observed by other CPUs */
; 1182 :         pto = APPLY_PREFIXING (pto, regs->PX);

  00408	8b 44 24 28	 mov	 eax, DWORD PTR pto$[rsp]
  0040c	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00412	48 85 c0	 test	 rax, rax
  00415	74 26		 je	 SHORT $LN43@s390_trans
  00417	8b 44 24 28	 mov	 eax, DWORD PTR pto$[rsp]
  0041b	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00421	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00429	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0042c	48 3b c1	 cmp	 rax, rcx
  0042f	74 0c		 je	 SHORT $LN43@s390_trans
  00431	48 8b 44 24 28	 mov	 rax, QWORD PTR pto$[rsp]
  00436	48 89 44 24 68	 mov	 QWORD PTR tv243[rsp], rax
  0043b	eb 1a		 jmp	 SHORT $LN44@s390_trans
$LN43@s390_trans:
  0043d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00445	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00448	8b 4c 24 28	 mov	 ecx, DWORD PTR pto$[rsp]
  0044c	33 c8		 xor	 ecx, eax
  0044e	8b c1		 mov	 eax, ecx
  00450	8b c0		 mov	 eax, eax
  00452	48 89 44 24 68	 mov	 QWORD PTR tv243[rsp], rax
$LN44@s390_trans:
  00457	48 8b 44 24 68	 mov	 rax, QWORD PTR tv243[rsp]
  0045c	48 89 44 24 28	 mov	 QWORD PTR pto$[rsp], rax

; 1183 :         pte = ARCH_DEP(fetch_fullword_absolute) (pto, regs);

  00461	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00469	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pto$[rsp]
  0046e	e8 00 00 00 00	 call	 s390_fetch_fullword_absolute
  00473	8b c0		 mov	 eax, eax
  00475	48 89 44 24 38	 mov	 QWORD PTR pte$[rsp], rax

; 1184 : 
; 1185 :         /* Generate page translation exception if page invalid */
; 1186 :         if (pte & PAGETAB_INVALID)

  0047a	48 8b 44 24 38	 mov	 rax, QWORD PTR pte$[rsp]
  0047f	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00485	48 85 c0	 test	 rax, rax
  00488	74 05		 je	 SHORT $LN16@s390_trans

; 1187 :             goto page_tran_invalid;

  0048a	e9 b1 02 00 00	 jmp	 $page_tran_invalid$58
$LN16@s390_trans:

; 1188 : 
; 1189 :         /* Check that all the reserved bits in the PTE are zero */
; 1190 :         if (pte & PAGETAB_RESV)

  0048f	b8 00 09 00 80	 mov	 eax, -2147481344	; 80000900H
  00494	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pte$[rsp]
  00499	48 23 c8	 and	 rcx, rax
  0049c	48 8b c1	 mov	 rax, rcx
  0049f	48 85 c0	 test	 rax, rax
  004a2	74 05		 je	 SHORT $LN17@s390_trans

; 1191 :             goto tran_spec_excp;

  004a4	e9 f2 01 00 00	 jmp	 $tran_spec_excp$53
$LN17@s390_trans:

; 1192 : 
; 1193 :         /* Set the protection indicator if page protection is active */
; 1194 :         if (pte & PAGETAB_PROT)

  004a9	48 8b 44 24 38	 mov	 rax, QWORD PTR pte$[rsp]
  004ae	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  004b4	48 85 c0	 test	 rax, rax
  004b7	74 3e		 je	 SHORT $LN18@s390_trans

; 1195 :             regs->dat.protect |= 1;

  004b9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c1	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  004c7	d1 e8		 shr	 eax, 1
  004c9	83 e0 03	 and	 eax, 3
  004cc	83 c8 01	 or	 eax, 1
  004cf	83 e0 03	 and	 eax, 3
  004d2	d1 e0		 shl	 eax, 1
  004d4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004dc	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  004e2	83 e1 f9	 and	 ecx, -7			; fffffff9H
  004e5	0b c8		 or	 ecx, eax
  004e7	8b c1		 mov	 eax, ecx
  004e9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f1	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN18@s390_trans:

; 1196 : 
; 1197 :         /* [3.11.4.2] Place the translated address in the TLB */
; 1198 :         if (!(acctype & ACC_NOTLB))

  004f7	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  004fe	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00503	85 c0		 test	 eax, eax
  00505	0f 85 f6 00 00
	00		 jne	 $LN19@s390_trans

; 1199 :         {
; 1200 :             regs->tlb.TLB_ASD(tlbix)   = regs->dat.asd;

  0050b	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00510	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00518	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00520	8b 92 18 08 00
	00		 mov	 edx, DWORD PTR [rdx+2072]
  00526	89 94 c1 60 b0
	00 00		 mov	 DWORD PTR [rcx+rax*8+45152], edx

; 1201 :             regs->tlb.TLB_VADDR(tlbix) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;

  0052d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  00534	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  00539	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00541	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00547	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR tlbix$[rsp]
  0054c	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00554	89 84 ca 60 d0
	00 00		 mov	 DWORD PTR [rdx+rcx*8+53344], eax

; 1202 :             regs->tlb.TLB_PTE(tlbix)   = pte;

  0055b	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00560	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00568	8b 54 24 38	 mov	 edx, DWORD PTR pte$[rsp]
  0056c	89 94 c1 60 f0
	00 00		 mov	 DWORD PTR [rcx+rax*8+61536], edx

; 1203 :             regs->tlb.common[tlbix]    = (ste & SEGTAB_COMMON) ? 1 : 0;

  00573	48 8b 44 24 40	 mov	 rax, QWORD PTR ste$[rsp]
  00578	48 83 e0 10	 and	 rax, 16
  0057c	48 85 c0	 test	 rax, rax
  0057f	74 0a		 je	 SHORT $LN45@s390_trans
  00581	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv291[rsp], 1
  00589	eb 08		 jmp	 SHORT $LN46@s390_trans
$LN45@s390_trans:
  0058b	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv291[rsp], 0
$LN46@s390_trans:
  00593	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00598	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a0	0f b6 54 24 4c	 movzx	 edx, BYTE PTR tv291[rsp]
  005a5	88 94 01 60 54
	01 00		 mov	 BYTE PTR [rcx+rax+87136], dl

; 1204 :             regs->tlb.acc[tlbix]       = 0;

  005ac	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  005b1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b9	c6 84 01 60 5c
	01 00 00	 mov	 BYTE PTR [rcx+rax+89184], 0

; 1205 :             regs->tlb.protect[tlbix]   = regs->dat.protect;

  005c1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c9	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  005cf	d1 e8		 shr	 eax, 1
  005d1	83 e0 03	 and	 eax, 3
  005d4	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR tlbix$[rsp]
  005d9	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005e1	88 84 0a 60 58
	01 00		 mov	 BYTE PTR [rdx+rcx+88160], al

; 1206 :             regs->tlb.main[tlbix]      = NULL;

  005e8	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  005ed	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f5	48 c7 84 c1 60
	10 01 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax*8+69728], 0
$LN19@s390_trans:
$LN5@s390_trans:

; 1207 :         }
; 1208 :     } /* end if(!TLB) */
; 1209 : 
; 1210 :     if(!(acctype & ACC_PTE))

  00601	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00608	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0060d	85 c0		 test	 eax, eax
  0060f	75 48		 jne	 SHORT $LN20@s390_trans

; 1211 :     {
; 1212 :     /* [3.11.3.5] Combine the page frame real address with the byte
; 1213 :        index of the virtual address to form the real address */
; 1214 :         regs->dat.raddr = (pte & PAGETAB_PFRA) | (vaddr & 0xFFF);

  00611	48 8b 44 24 38	 mov	 rax, QWORD PTR pte$[rsp]
  00616	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  0061c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR vaddr$[rsp]
  00623	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  00629	8b c9		 mov	 ecx, ecx
  0062b	48 0b c1	 or	 rax, rcx
  0062e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00636	48 89 81 00 08
	00 00		 mov	 QWORD PTR [rcx+2048], rax

; 1215 :         regs->dat.rpfra = (pte & PAGETAB_PFRA);

  0063d	48 8b 44 24 38	 mov	 rax, QWORD PTR pte$[rsp]
  00642	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  00648	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00650	48 89 81 10 08
	00 00		 mov	 QWORD PTR [rcx+2064], rax

; 1216 :     }

  00657	eb 14		 jmp	 SHORT $LN21@s390_trans
$LN20@s390_trans:

; 1217 :     else
; 1218 :     /* In the case of lock page, return the address of the
; 1219 :        pagetable entry */
; 1220 :         regs->dat.raddr = pto;

  00659	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00661	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pto$[rsp]
  00666	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx
$LN21@s390_trans:

; 1221 : 
; 1222 : #endif /* defined( FEATURE_S390_DAT ) */
; 1223 : 
; 1224 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1225 : /*-----------------------------------*/
; 1226 : /* ESAME Dynamic Address Translation */
; 1227 : /*-----------------------------------*/
; 1228 : RADR    rte;                            /* Region table entry        */
; 1229 : #define rto     sto                     /* Region/seg table origin   */
; 1230 : RADR    ste = 0;                        /* Segment table entry       */
; 1231 : RADR    pte = 0;                        /* Page table entry          */
; 1232 : BYTE    tt;                             /* Table type                */
; 1233 : BYTE    tl;                             /* Table length              */
; 1234 : BYTE    tf;                             /* Table offset              */
; 1235 : U16     rfx, rsx, rtx;                  /* Region first/second/third
; 1236 :                                            index + 3 low-order zeros */
; 1237 : U16     sx, px;                         /* Segment and page index,
; 1238 :                                            + 3 low-order zero bits   */
; 1239 : 
; 1240 :     regs->dat.pvtaddr = regs->dat.protect = 0;
; 1241 : 
; 1242 :     /* Load the address space control element */
; 1243 :     if (ARCH_DEP(load_address_space_designator) (arn, regs, acctype))
; 1244 :         goto tran_alet_excp;
; 1245 : 
; 1246 :     /* Extract the private space bit from the ASCE */
; 1247 :     regs->dat.pvtaddr = ((regs->dat.asd & (ASCE_P|ASCE_R)) != 0);
; 1248 : 
; 1249 : //  LOGMSG("asce=%16.16"PRIX64"\n",regs->dat.asd);
; 1250 : 
; 1251 :     /* [3.11.4] Look up the address in the TLB */
; 1252 :     if (   ((vaddr & TLBID_PAGEMASK) | regs->tlbID) == regs->tlb.TLB_VADDR(tlbix)
; 1253 :         && (regs->tlb.common[tlbix] || regs->dat.asd == regs->tlb.TLB_ASD(tlbix))
; 1254 :         && !(regs->tlb.common[tlbix] && regs->dat.pvtaddr)
; 1255 :         && !(acctype & ACC_NOTLB) )
; 1256 :     {
; 1257 :         pte = regs->tlb.TLB_PTE(tlbix);
; 1258 :         if (regs->tlb.protect[tlbix])
; 1259 :             regs->dat.protect = regs->tlb.protect[tlbix];
; 1260 :     }
; 1261 :     else
; 1262 :     {
; 1263 :         /* If ASCE indicates a real-space then real addr = virtual addr */
; 1264 :         if (regs->dat.asd & ASCE_R)
; 1265 :         {
; 1266 : //      LOGMSG("asce type = real\n");
; 1267 : 
; 1268 :             /* Translation specification exception if LKPG for a real-space */
; 1269 :             if(acctype & ACC_PTE)
; 1270 :                 goto tran_spec_excp;
; 1271 : 
; 1272 :             /* Special operation exception if LPTEA for a real-space */
; 1273 :             if(acctype & ACC_LPTEA)
; 1274 :                 goto spec_oper_excp;
; 1275 : 
; 1276 :             /* Construct a fake page table entry for real = virtual */
; 1277 :             pte = vaddr & 0xFFFFFFFFFFFFF000ULL;
; 1278 :         }
; 1279 :         else
; 1280 :         {
; 1281 :             /* Extract the table origin, type, and length from the ASCE,
; 1282 :                and set the table offset to zero */
; 1283 :             rto = regs->dat.asd & ASCE_TO;
; 1284 :             tf = 0;
; 1285 :             tt = regs->dat.asd & ASCE_DT;
; 1286 :             tl = regs->dat.asd & ASCE_TL;
; 1287 : 
; 1288 :             /* Extract the 11-bit region first index, region second index,
; 1289 :                and region third index from the virtual address, and shift
; 1290 :                each index into bits 2-12 of a 16-bit integer, ready for
; 1291 :                addition to the appropriate region table origin */
; 1292 :             rfx = (vaddr >> 50) & 0x3FF8;
; 1293 :             rsx = (vaddr >> 39) & 0x3FF8;
; 1294 :             rtx = (vaddr >> 28) & 0x3FF8;
; 1295 : 
; 1296 :             /* Extract the 11-bit segment index from the virtual address,
; 1297 :                and shift it into bits 2-12 of a 16-bit integer, ready
; 1298 :                for addition to the segment table origin */
; 1299 :             sx = (vaddr >> 17) & 0x3FF8;
; 1300 : 
; 1301 :             /* Extract the 8-bit page index from the virtual address,
; 1302 :                and shift it into bits 2-12 of a 16-bit integer, ready
; 1303 :                for addition to the page table origin */
; 1304 :             px = (vaddr >> 9) & 0x07F8;
; 1305 : 
; 1306 :             /* ASCE-type exception if the virtual address is too large
; 1307 :                for the table type designated by the ASCE */
; 1308 :             if ((rfx != 0 && tt < TT_R1TABL)
; 1309 :                 || (rsx != 0 && tt < TT_R2TABL)
; 1310 :                 || (rtx != 0 && tt < TT_R3TABL))
; 1311 :                 goto asce_type_excp;
; 1312 : 
; 1313 :             /* Perform region translation */
; 1314 :             switch (tt) {
; 1315 : 
; 1316 :             /* Perform region-first translation */
; 1317 :             case TT_R1TABL:
; 1318 : 
; 1319 :                 /* Region-first translation exception if table length is
; 1320 :                    less than high-order 2 bits of region-first index */
; 1321 :                 if (tl < (rfx >> 12))
; 1322 :                     goto reg_first_excp;
; 1323 : 
; 1324 :                 /* Add the region-first index (with three low-order zeroes)
; 1325 :                    to the region-first table origin, giving the address of
; 1326 :                    the region-first table entry */
; 1327 :                 rto += rfx;
; 1328 : 
; 1329 :                 /* Addressing exception if outside main storage */
; 1330 :                 if (rto > regs->mainlim)
; 1331 :                     goto address_excp;
; 1332 : 
; 1333 :                 /* Fetch region-first table entry from absolute storage.
; 1334 :                    All bytes must be fetched concurrently as observed by
; 1335 :                    other CPUs */
; 1336 :                 rte = ARCH_DEP(fetch_doubleword_absolute) (rto, regs);
; 1337 : //              LOGMSG("r1te:%16.16"PRIX64"=>%16.16"PRIX64"\n",rto,rte);
; 1338 : 
; 1339 :                 /* Region-first translation exception if the bit 58 of
; 1340 :                    the region-first table entry is set (region invalid) */
; 1341 :                 if (rte & REGTAB_I)
; 1342 :                     goto reg_first_invalid;
; 1343 : 
; 1344 :                 /* Translation specification exception if bits 60-61 of
; 1345 :                    the region-first table entry do not indicate the
; 1346 :                    correct type of region table */
; 1347 :                 if ((rte & REGTAB_TT) != TT_R1TABL)
; 1348 :                     goto tran_spec_excp;
; 1349 : 
; 1350 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1351 :                 if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1352 :                  && (regs->CR_L(0) & CR0_ED)
; 1353 :                  && (rte & REGTAB_P))
; 1354 :                     regs->dat.protect |= 1;
; 1355 : #endif
; 1356 :                 /* Extract the region-second table origin, offset, and
; 1357 :                    length from the region-first table entry */
; 1358 :                 rto = rte & REGTAB_TO;
; 1359 :                 tf = (rte & REGTAB_TF) >> 6;
; 1360 :                 tl = rte & REGTAB_TL;
; 1361 : 
; 1362 :                 /* Fall through to perform region-second translation */
; 1363 :                 /* FALLTHRU */
; 1364 : 
; 1365 :             /* Perform region-second translation */
; 1366 :             case TT_R2TABL:
; 1367 : 
; 1368 :                 /* Region-second translation exception if table offset is
; 1369 :                    greater than high-order 2 bits of region-second index */
; 1370 :                 if (tf > (rsx >> 12))
; 1371 :                     goto reg_second_excp;
; 1372 : 
; 1373 :                 /* Region-second translation exception if table length is
; 1374 :                    less than high-order 2 bits of region-second index */
; 1375 :                 if (tl < (rsx >> 12))
; 1376 :                     goto reg_second_excp;
; 1377 : 
; 1378 :                 /* Add the region-second index (with three low-order zeroes)
; 1379 :                    to the region-second table origin, giving the address of
; 1380 :                    the region-second table entry */
; 1381 :                 rto += rsx;
; 1382 : 
; 1383 :                 /* Addressing exception if outside main storage */
; 1384 :                 if (rto > regs->mainlim)
; 1385 :                     goto address_excp;
; 1386 : 
; 1387 :                 /* Fetch region-second table entry from absolute storage.
; 1388 :                    All bytes must be fetched concurrently as observed by
; 1389 :                    other CPUs */
; 1390 :                 rte = ARCH_DEP(fetch_doubleword_absolute) (rto, regs);
; 1391 : //              LOGMSG("r2te:%16.16"PRIX64"=>%16.16"PRIX64"\n",rto,rte);
; 1392 : 
; 1393 :                 /* Region-second translation exception if the bit 58 of
; 1394 :                    the region-second table entry is set (region invalid) */
; 1395 :                 if (rte & REGTAB_I)
; 1396 :                     goto reg_second_invalid;
; 1397 : 
; 1398 :                 /* Translation specification exception if bits 60-61 of
; 1399 :                    the region-second table entry do not indicate the
; 1400 :                    correct type of region table */
; 1401 :                 if ((rte & REGTAB_TT) != TT_R2TABL)
; 1402 :                     goto tran_spec_excp;
; 1403 : 
; 1404 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1405 :                 if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1406 :                  && (regs->CR_L(0) & CR0_ED)
; 1407 :                  && (rte & REGTAB_P))
; 1408 :                     regs->dat.protect |= 1;
; 1409 : #endif
; 1410 :                 /* Extract the region-third table origin, offset, and
; 1411 :                    length from the region-second table entry */
; 1412 :                 rto = rte & REGTAB_TO;
; 1413 :                 tf = (rte & REGTAB_TF) >> 6;
; 1414 :                 tl = rte & REGTAB_TL;
; 1415 : 
; 1416 :                 /* Fall through to perform region-third translation */
; 1417 :                 /* FALLTHRU */
; 1418 : 
; 1419 :             /* Perform region-third translation */
; 1420 :             case TT_R3TABL:
; 1421 : 
; 1422 :                 /* Region-third translation exception if table offset is
; 1423 :                    greater than high-order 2 bits of region-third index */
; 1424 :                 if (tf > (rtx >> 12))
; 1425 :                     goto reg_third_excp;
; 1426 : 
; 1427 :                 /* Region-third translation exception if table length is
; 1428 :                    less than high-order 2 bits of region-third index */
; 1429 :                 if (tl < (rtx >> 12))
; 1430 :                     goto reg_third_excp;
; 1431 : 
; 1432 :                 /* Add the region-third index (with three low-order zeroes)
; 1433 :                    to the region-third table origin, giving the address of
; 1434 :                    the region-third table entry */
; 1435 :                 rto += rtx;
; 1436 : 
; 1437 :                 /* Addressing exception if outside main storage */
; 1438 :                 if (rto > regs->mainlim)
; 1439 :                     goto address_excp;
; 1440 : 
; 1441 :                 /* Fetch region-third table entry from absolute storage.
; 1442 :                    All bytes must be fetched concurrently as observed by
; 1443 :                    other CPUs */
; 1444 :                 rte = ARCH_DEP(fetch_doubleword_absolute) (rto, regs);
; 1445 : //              LOGMSG("r3te:%16.16"PRIX64"=>%16.16"PRIX64"\n",rto,rte);
; 1446 : 
; 1447 :                 /* Region-third translation exception if the bit 58 of
; 1448 :                    the region-third table entry is set (region invalid) */
; 1449 :                 if (rte & REGTAB_I)
; 1450 :                     goto reg_third_invalid;
; 1451 : 
; 1452 :                 /* Translation specification exception if bits 60-61 of
; 1453 :                    the region-third table entry do not indicate the
; 1454 :                    correct type of region table */
; 1455 :                 if ((rte & REGTAB_TT) != TT_R3TABL)
; 1456 :                     goto tran_spec_excp;
; 1457 : 
; 1458 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1459 :                 if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1460 :                  && (regs->CR_L(0) & CR0_ED)
; 1461 :                  && (rte & REGTAB_P))
; 1462 :                     regs->dat.protect |= 1;
; 1463 : #endif
; 1464 :                 /* Extract the segment table origin, offset, and
; 1465 :                    length from the region-third table entry */
; 1466 :                 sto = rte & REGTAB_TO;
; 1467 :                 tf = (rte & REGTAB_TF) >> 6;
; 1468 :                 tl = rte & REGTAB_TL;
; 1469 : 
; 1470 :                 /* Fall through to perform segment translation */
; 1471 :             } /* end switch(tt) */
; 1472 : 
; 1473 :             /* Perform ESAME segment translation */
; 1474 : 
; 1475 :             /* Add the segment index (with three low-order zeroes)
; 1476 :                to the segment table origin, giving the address of
; 1477 :                the segment table entry */
; 1478 :             sto += sx;
; 1479 : 
; 1480 :             /* Segment translation exception if table offset is
; 1481 :                greater than high-order 2 bits of segment index */
; 1482 :             if (tf > (sx >> 12))
; 1483 :                 goto seg_tran_length;
; 1484 : 
; 1485 :             /* Segment translation exception if table length is
; 1486 :                less than high-order 2 bits of segment index */
; 1487 :             if (tl < (sx >> 12))
; 1488 :                 goto seg_tran_length;
; 1489 : 
; 1490 :             /* Addressing exception if outside real storage */
; 1491 :             if (sto > regs->mainlim)
; 1492 :                 goto address_excp;
; 1493 : 
; 1494 :             /* Fetch segment table entry from absolute storage.  All bytes
; 1495 :                must be fetched concurrently as observed by other CPUs */
; 1496 :             ste = ARCH_DEP(fetch_doubleword_absolute) (sto, regs);
; 1497 : //          LOGMSG("ste:%16.16"PRIX64"=>%16.16"PRIX64"\n",sto,ste);
; 1498 : 
; 1499 :             /* Segment translation exception if segment invalid */
; 1500 :             if (ste & ZSEGTAB_I)
; 1501 :                 goto seg_tran_invalid;
; 1502 : 
; 1503 :             /* Translation specification exception if bits 60-61 of
; 1504 :                the segment table entry do not indicate segment table */
; 1505 :             if ((ste & ZSEGTAB_TT) != TT_SEGTAB)
; 1506 :                 goto tran_spec_excp;
; 1507 : 
; 1508 :             /* Translation specification exception if the ASCE
; 1509 :                indicates a private space, and the segment table
; 1510 :                entry indicates a common segment */
; 1511 :             if (regs->dat.pvtaddr && (ste & ZSEGTAB_C))
; 1512 :                 goto tran_spec_excp;
; 1513 : 
; 1514 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1515 :             if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1516 :               && (regs->CR_L(0) & CR0_ED)
; 1517 :               && (ste & ZSEGTAB_FC))
; 1518 :             {
; 1519 :                 /* Set protection indicator if page protection is indicated */
; 1520 :                 if (ste & ZSEGTAB_P)
; 1521 :                     regs->dat.protect |= 1;
; 1522 : 
; 1523 :                 /* For LPTEA instruction, return the address of the STE */
; 1524 :                 if (unlikely(acctype & ACC_LPTEA))
; 1525 :                 {
; 1526 :                     regs->dat.raddr = sto | (regs->dat.protect ? 0x04 : 0);
; 1527 : //                  LOGMSG("raddr:%16.16"PRIX64" cc=2\n",regs->dat.raddr);
; 1528 :                     regs->dat.xcode = 0;
; 1529 :                     cc = 2;
; 1530 :                     return cc;
; 1531 :                 } /* end if(ACCTYPE_LPTEA) */
; 1532 : 
; 1533 :                 /* Combine the page frame real address with the byte index
; 1534 :                    of the virtual address to form the real address */
; 1535 :                 regs->dat.raddr = (ste & ZSEGTAB_SFAA) | (vaddr & ~ZSEGTAB_SFAA);
; 1536 :                 /* Fake 4K PFRA for TLB purposes */
; 1537 :                 regs->dat.rpfra = ((ste & ZSEGTAB_SFAA) | (vaddr & ~ZSEGTAB_SFAA)) & PAGEFRAME_PAGEMASK;
; 1538 : 
; 1539 : //              LOGMSG("raddr:%16.16"PRIX64" cc=0\n",regs->dat.raddr);
; 1540 : 
; 1541 :                 /* [3.11.4.2] Place the translated address in the TLB */
; 1542 :                 if (!(acctype & ACC_NOTLB))
; 1543 :                 {
; 1544 :                     regs->tlb.TLB_ASD(tlbix)   = regs->dat.asd;
; 1545 :                     regs->tlb.TLB_VADDR(tlbix) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;
; 1546 :                     /* Fake 4K PTE for TLB purposes */
; 1547 :                     regs->tlb.TLB_PTE(tlbix)   = ((ste & ZSEGTAB_SFAA) | (vaddr & ~ZSEGTAB_SFAA)) & PAGEFRAME_PAGEMASK;
; 1548 :                     regs->tlb.common[tlbix]    = (ste & SEGTAB_COMMON) ? 1 : 0;
; 1549 :                     regs->tlb.protect[tlbix]   = regs->dat.protect;
; 1550 :                     regs->tlb.acc[tlbix]       = 0;
; 1551 :                     regs->tlb.main[tlbix]      = NULL;
; 1552 :                 }
; 1553 : 
; 1554 :                 /* Clear exception code and return with zero return code */
; 1555 :                 regs->dat.xcode = 0;
; 1556 :                 return 0;
; 1557 : 
; 1558 :             }
; 1559 : #endif /* defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 ) */
; 1560 : 
; 1561 :             /* Extract the page table origin from segment table entry */
; 1562 :             pto = ste & ZSEGTAB_PTO;
; 1563 : 
; 1564 :             /* Perform ESAME page translation */
; 1565 : 
; 1566 :             /* Add the page index (with three low-order zeroes) to the
; 1567 :                page table origin, giving address of page table entry */
; 1568 :             pto += px;
; 1569 : 
; 1570 :             /* For LPTEA instruction, return the address of the PTE */
; 1571 :             if (acctype & ACC_LPTEA)
; 1572 :             {
; 1573 :                 regs->dat.raddr = pto;
; 1574 :                 regs->dat.xcode = 0;
; 1575 :                 cc = (ste & ZSEGTAB_P) ? 1 : 0;
; 1576 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1577 :                 if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1578 :                   && (regs->CR_L(0) & CR0_ED)
; 1579 :                   && regs->dat.protect)
; 1580 :                     cc = 1;
; 1581 : #endif
; 1582 :                 return cc;
; 1583 :             } /* end if(ACCTYPE_LPTEA) */
; 1584 : 
; 1585 :             /* Addressing exception if outside real storage */
; 1586 :             if (pto > regs->mainlim)
; 1587 :                 goto address_excp;
; 1588 : 
; 1589 :             /* Fetch the page table entry from absolute storage.  All bytes
; 1590 :                must be fetched concurrently as observed by other CPUs */
; 1591 :             pte = ARCH_DEP(fetch_doubleword_absolute) (pto, regs);
; 1592 : //          LOGMSG("pte:%16.16"PRIX64"=>%16.16"PRIX64"\n",pto,pte);
; 1593 : 
; 1594 :             /* Page translation exception if page invalid */
; 1595 :             if (pte & ZPGETAB_I)
; 1596 :                 goto page_tran_invalid;
; 1597 : 
; 1598 :             /* Check that all the reserved bits in the PTE are zero */
; 1599 :             if (pte & ZPGETAB_RESV)
; 1600 :                 goto tran_spec_excp;
; 1601 : 
; 1602 :         } /* end else(ASCE_R) */
; 1603 : 
; 1604 :         /* Set protection indicator if page protection is indicated
; 1605 :            in either the segment table or the page table */
; 1606 :         if ((ste & ZSEGTAB_P) || (pte & ZPGETAB_P))
; 1607 :             regs->dat.protect |= 1;
; 1608 : 
; 1609 :         /* [3.11.4.2] Place the translated address in the TLB */
; 1610 :         if (!(acctype & ACC_NOTLB))
; 1611 :         {
; 1612 :             regs->tlb.TLB_ASD(tlbix)   = regs->dat.asd;
; 1613 :             regs->tlb.TLB_VADDR(tlbix) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;
; 1614 :             regs->tlb.TLB_PTE(tlbix)   = pte;
; 1615 :             regs->tlb.common[tlbix]    = (ste & SEGTAB_COMMON) ? 1 : 0;
; 1616 :             regs->tlb.protect[tlbix]   = regs->dat.protect;
; 1617 :             regs->tlb.acc[tlbix]       = 0;
; 1618 :             regs->tlb.main[tlbix]      = NULL;
; 1619 :         }
; 1620 :     }
; 1621 : 
; 1622 :     if(!(acctype & ACC_PTE))
; 1623 :     {
; 1624 :         /* Combine the page frame real address with the byte index
; 1625 :            of the virtual address to form the real address */
; 1626 :         regs->dat.raddr = (pte & ZPGETAB_PFRA) | (vaddr & 0xFFF);
; 1627 :         regs->dat.rpfra = (pte & ZPGETAB_PFRA);
; 1628 :     }
; 1629 :     else
; 1630 :         regs->dat.raddr = pto;
; 1631 : #endif /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1632 : 
; 1633 :     /*-----------------------------------------------------------*/
; 1634 :     /* The following code is common to S/370, ESA/390, and ESAME */
; 1635 :     /*-----------------------------------------------------------*/
; 1636 : 
; 1637 :     /* Clear exception code and return with zero return code */
; 1638 :     regs->dat.xcode = 0;

  0066d	33 c0		 xor	 eax, eax
  0066f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00677	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1639 :     return 0;

  0067e	33 c0		 xor	 eax, eax
  00680	e9 fa 03 00 00	 jmp	 $LN1@s390_trans
$address_excp$55:

; 1640 : 
; 1641 : /* Conditions which always cause program check, except
; 1642 :    when performing translation for the control panel */
; 1643 : address_excp:
; 1644 : //    LOGMSG("dat.c: addressing exception: %8.8X %8.8X %4.4X %8.8X\n",
; 1645 : //        regs->CR(0),regs->dat.asd,pte,vaddr);
; 1646 :     regs->dat.xcode = PGM_ADDRESSING_EXCEPTION;

  00685	b8 05 00 00 00	 mov	 eax, 5
  0068a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00692	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1647 :     goto tran_prog_check;

  00699	eb 14		 jmp	 SHORT $tran_prog_check$59
$tran_spec_excp$53:

; 1648 : 
; 1649 : tran_spec_excp:
; 1650 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1651 : //    LOGMSG("dat.c: translation specification exception...\n");
; 1652 : //    LOGMSG("       pte = %16.16"PRIX64", ste = %16.16"PRIX64", rte=%16.16"PRIX64"\n",
; 1653 : //        pte, ste, rte);
; 1654 : #else
; 1655 : //    LOGMSG("dat.c: translation specification exception...\n");
; 1656 : //    LOGMSG("       cr0=%8.8X ste=%8.8X pte=%4.4X vaddr=%8.8X\n",
; 1657 : //        regs->CR(0),ste,pte,vaddr);
; 1658 : #endif
; 1659 :     regs->dat.xcode = PGM_TRANSLATION_SPECIFICATION_EXCEPTION;

  0069b	b8 12 00 00 00	 mov	 eax, 18
  006a0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a8	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax
$tran_prog_check$59:

; 1660 :     goto tran_prog_check;
; 1661 : 
; 1662 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1663 : spec_oper_excp:
; 1664 :     regs->dat.xcode = PGM_SPECIAL_OPERATION_EXCEPTION;
; 1665 :     goto tran_prog_check;
; 1666 : #endif
; 1667 : 
; 1668 : tran_prog_check:
; 1669 : #if defined( FEATURE_036_ENH_MONITOR_FACILITY )
; 1670 :     if (FACILITY_ENABLED( 036_ENH_MONITOR, regs ))
; 1671 :     {
; 1672 :         /* No program interrupt for enhanced MC */
; 1673 :         if (acctype & ACC_ENH_MC)
; 1674 :         {
; 1675 :             cc = 5;
; 1676 :             return cc;
; 1677 :         }
; 1678 :     }
; 1679 : #endif
; 1680 :     regs->program_interrupt( regs, regs->dat.xcode );

  006af	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006b7	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  006be	8b d0		 mov	 edx, eax
  006c0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006d0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$seg_tran_invalid$56:

; 1681 : 
; 1682 : /* Conditions which the caller may or may not program check */
; 1683 : seg_tran_invalid:
; 1684 :     /* For LPTEA, return segment table entry address with cc 2 */
; 1685 :     if (acctype & ACC_LPTEA)

  006d6	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  006dd	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  006e2	85 c0		 test	 eax, eax
  006e4	74 25		 je	 SHORT $LN22@s390_trans

; 1686 :     {
; 1687 :         regs->dat.raddr = sto;

  006e6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  006f3	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1688 :         cc = 2;

  006fa	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1689 :         return cc;

  00702	8b 44 24 24	 mov	 eax, DWORD PTR cc$[rsp]
  00706	e9 74 03 00 00	 jmp	 $LN1@s390_trans
$LN22@s390_trans:

; 1690 :     } /* end if(ACCTYPE_LPTEA) */
; 1691 : 
; 1692 :     /* Otherwise set translation exception code */
; 1693 :     regs->dat.xcode = PGM_SEGMENT_TRANSLATION_EXCEPTION;

  0070b	b8 10 00 00 00	 mov	 eax, 16
  00710	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00718	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1694 :     regs->dat.raddr = sto;

  0071f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00727	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  0072c	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1695 :     cc = 1;

  00733	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 1696 :     goto tran_excp_addr;

  0073b	e9 f9 00 00 00	 jmp	 $tran_excp_addr$60
$page_tran_invalid$58:

; 1697 : 
; 1698 : page_tran_invalid:
; 1699 :     regs->dat.xcode = PGM_PAGE_TRANSLATION_EXCEPTION;

  00740	b8 11 00 00 00	 mov	 eax, 17
  00745	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0074d	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1700 :     regs->dat.raddr = pto;

  00754	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0075c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pto$[rsp]
  00761	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1701 :     if(acctype & ACC_PTE) return 0;

  00768	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0076f	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00774	85 c0		 test	 eax, eax
  00776	74 07		 je	 SHORT $LN23@s390_trans
  00778	33 c0		 xor	 eax, eax
  0077a	e9 00 03 00 00	 jmp	 $LN1@s390_trans
$LN23@s390_trans:

; 1702 :     cc = 2;

  0077f	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1703 :     goto tran_excp_addr;

  00787	e9 ad 00 00 00	 jmp	 $tran_excp_addr$60
$page_tran_length$57:

; 1704 : 
; 1705 : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1706 : page_tran_length:
; 1707 :     regs->dat.xcode = PGM_PAGE_TRANSLATION_EXCEPTION;

  0078c	b8 11 00 00 00	 mov	 eax, 17
  00791	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00799	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1708 :     regs->dat.raddr = pto;

  007a0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pto$[rsp]
  007ad	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1709 :     cc = 3;

  007b4	c7 44 24 24 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3

; 1710 :     goto tran_excp_addr;

  007bc	eb 7b		 jmp	 SHORT $tran_excp_addr$60
$seg_tran_length$54:

; 1711 : #endif
; 1712 : 
; 1713 : seg_tran_length:
; 1714 : //  LOGMSG("dat.c: segment translation exception due to segment length\n");
; 1715 : //  LOGMSG("       cr0=" F_RADR " sto=" F_RADR "\n",regs->CR(0),sto);
; 1716 :     regs->dat.xcode = PGM_SEGMENT_TRANSLATION_EXCEPTION;

  007be	b8 10 00 00 00	 mov	 eax, 16
  007c3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007cb	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1717 :     regs->dat.raddr = sto;

  007d2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007da	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  007df	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1718 :     cc = 3;

  007e6	c7 44 24 24 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3

; 1719 :     goto tran_excp_addr;

  007ee	eb 49		 jmp	 SHORT $tran_excp_addr$60
$tran_alet_excp$52:

; 1720 : 
; 1721 : tran_alet_excp:
; 1722 :     regs->excarid = arn;

  007f0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007f8	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR arn$[rsp]
  00800	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl

; 1723 :     cc = (acctype & ACC_LPTEA) ? 3 : 4;

  00806	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0080d	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00812	85 c0		 test	 eax, eax
  00814	74 0a		 je	 SHORT $LN47@s390_trans
  00816	c7 44 24 50 03
	00 00 00	 mov	 DWORD PTR tv343[rsp], 3
  0081e	eb 08		 jmp	 SHORT $LN48@s390_trans
$LN47@s390_trans:
  00820	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR tv343[rsp], 4
$LN48@s390_trans:
  00828	8b 44 24 50	 mov	 eax, DWORD PTR tv343[rsp]
  0082c	89 44 24 24	 mov	 DWORD PTR cc$[rsp], eax

; 1724 :     return cc;

  00830	8b 44 24 24	 mov	 eax, DWORD PTR cc$[rsp]
  00834	e9 46 02 00 00	 jmp	 $LN1@s390_trans
$tran_excp_addr$60:

; 1725 : 
; 1726 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1727 : reg_first_invalid:
; 1728 :     /* For LPTEA, return region table entry address with cc 2 */
; 1729 :     if (acctype & ACC_LPTEA)
; 1730 :     {
; 1731 :         regs->dat.raddr = rto | (TT_R1TABL >> 2);
; 1732 :         cc = 2;
; 1733 :         return cc;
; 1734 :     } /* end if(ACCTYPE_LPTEA) */
; 1735 : 
; 1736 :     /* Otherwise set translation exception code */
; 1737 :     goto reg_first_excp;
; 1738 : 
; 1739 : reg_second_invalid:
; 1740 :     /* For LPTEA, return region table entry address with cc 2 */
; 1741 :     if (acctype & ACC_LPTEA)
; 1742 :     {
; 1743 :         regs->dat.raddr = rto | (TT_R2TABL >> 2);
; 1744 :         cc = 2;
; 1745 :         return cc;
; 1746 :     } /* end if(ACCTYPE_LPTEA) */
; 1747 : 
; 1748 :     /* Otherwise set translation exception code */
; 1749 :     goto reg_second_excp;
; 1750 : 
; 1751 : reg_third_invalid:
; 1752 :     /* For LPTEA, return region table entry address with cc 2 */
; 1753 :     if (acctype & ACC_LPTEA)
; 1754 :     {
; 1755 :         regs->dat.raddr = rto | (TT_R3TABL >> 2);
; 1756 :         cc = 2;
; 1757 :         return cc;
; 1758 :     } /* end if(ACCTYPE_LPTEA) */
; 1759 : 
; 1760 :     /* Otherwise set translation exception code */
; 1761 :     goto reg_third_excp;
; 1762 : 
; 1763 : asce_type_excp:
; 1764 : //  LOGMSG("rfx = %4.4X, rsx %4.4X, rtx = %4.4X, tt = %1.1X\n",
; 1765 : //      rfx, rsx, rtx, tt);
; 1766 :     regs->dat.xcode = PGM_ASCE_TYPE_EXCEPTION;
; 1767 :     cc = 4;
; 1768 :     goto tran_excp_addr;
; 1769 : 
; 1770 : reg_first_excp:
; 1771 :     regs->dat.xcode = PGM_REGION_FIRST_TRANSLATION_EXCEPTION;
; 1772 :     cc = 4;
; 1773 :     goto tran_excp_addr;
; 1774 : 
; 1775 : reg_second_excp:
; 1776 :     regs->dat.xcode = PGM_REGION_SECOND_TRANSLATION_EXCEPTION;
; 1777 :     cc = 4;
; 1778 :     goto tran_excp_addr;
; 1779 : 
; 1780 : reg_third_excp:
; 1781 :     regs->dat.xcode = PGM_REGION_THIRD_TRANSLATION_EXCEPTION;
; 1782 :     cc = 4;
; 1783 :     goto tran_excp_addr;
; 1784 : #endif /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1785 : 
; 1786 : tran_excp_addr:
; 1787 :     /* For LPTEA instruction, return xcode with cc = 3 */
; 1788 :     if (acctype & ACC_LPTEA)

  00839	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00840	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00845	85 c0		 test	 eax, eax
  00847	74 0a		 je	 SHORT $LN24@s390_trans

; 1789 :         return 3;

  00849	b8 03 00 00 00	 mov	 eax, 3
  0084e	e9 2c 02 00 00	 jmp	 $LN1@s390_trans
$LN24@s390_trans:

; 1790 : 
; 1791 :     /* Set the translation exception address */
; 1792 :     regs->TEA = vaddr & PAGEFRAME_PAGEMASK;

  00853	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  0085a	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  0085f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00867	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 1793 : 
; 1794 :     /* Set the address space indication in the exception address */
; 1795 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1796 :     if(regs->dat.stid == TEA_ST_ARMODE)
; 1797 :     {
; 1798 :         if ((regs->dat.asd & ASCE_TO) == (regs->CR(1) & ASCE_TO))
; 1799 :             regs->TEA |= TEA_ST_PRIMARY;
; 1800 :         else if ((regs->dat.asd & ASCE_TO) == (regs->CR(7) & ASCE_TO))
; 1801 :             regs->TEA |= TEA_ST_SECNDRY;
; 1802 :         else if ((regs->dat.asd & ASCE_TO) == (regs->CR(13) & ASCE_TO))
; 1803 :             regs->TEA |= TEA_ST_HOME;
; 1804 :         else
; 1805 :             regs->TEA |= TEA_ST_ARMODE;
; 1806 :     }
; 1807 :     else
; 1808 :         regs->TEA |= regs->dat.stid;
; 1809 : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1810 :     if(regs->dat.stid == TEA_ST_ARMODE)

  0086d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00875	83 b8 20 08 00
	00 01		 cmp	 DWORD PTR [rax+2080], 1
  0087c	0f 85 2d 01 00
	00		 jne	 $LN25@s390_trans

; 1811 :     {
; 1812 :         if ((regs->dat.asd & STD_STO) == (regs->CR(1) & STD_STO))

  00882	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0088a	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00891	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  00897	b9 08 00 00 00	 mov	 ecx, 8
  0089c	48 6b c9 02	 imul	 rcx, rcx, 2
  008a0	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008a8	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  008af	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  008b5	8b c9		 mov	 ecx, ecx
  008b7	48 3b c1	 cmp	 rax, rcx
  008ba	75 19		 jne	 SHORT $LN27@s390_trans

; 1813 :             regs->TEA |= TEA_ST_PRIMARY;

  008bc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008c4	8b 88 18 07 00
	00		 mov	 ecx, DWORD PTR [rax+1816]
  008ca	89 88 18 07 00
	00		 mov	 DWORD PTR [rax+1816], ecx
  008d0	e9 d5 00 00 00	 jmp	 $LN28@s390_trans
$LN27@s390_trans:

; 1814 :         else if ((regs->dat.asd & STD_STO) == (regs->CR(7) & STD_STO))

  008d5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008dd	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  008e4	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  008ea	b9 08 00 00 00	 mov	 ecx, 8
  008ef	48 6b c9 08	 imul	 rcx, rcx, 8
  008f3	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008fb	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00902	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00908	8b c9		 mov	 ecx, ecx
  0090a	48 3b c1	 cmp	 rax, rcx
  0090d	75 21		 jne	 SHORT $LN29@s390_trans

; 1815 :             regs->TEA |= TEA_ST_SECNDRY;

  0090f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00917	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  0091d	83 c8 02	 or	 eax, 2
  00920	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00928	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax
  0092e	eb 7a		 jmp	 SHORT $LN30@s390_trans
$LN29@s390_trans:

; 1816 :         else if ((regs->dat.asd & STD_STO) == (regs->CR(13) & STD_STO))

  00930	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00938	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  0093f	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  00945	b9 08 00 00 00	 mov	 ecx, 8
  0094a	48 6b c9 0e	 imul	 rcx, rcx, 14
  0094e	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00956	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  0095d	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00963	8b c9		 mov	 ecx, ecx
  00965	48 3b c1	 cmp	 rax, rcx
  00968	75 21		 jne	 SHORT $LN31@s390_trans

; 1817 :             regs->TEA |= TEA_ST_HOME;

  0096a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00972	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00978	83 c8 03	 or	 eax, 3
  0097b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00983	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax
  00989	eb 1f		 jmp	 SHORT $LN32@s390_trans
$LN31@s390_trans:

; 1818 :         else
; 1819 :             regs->TEA |= TEA_ST_ARMODE;

  0098b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00993	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00999	83 c8 01	 or	 eax, 1
  0099c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a4	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax
$LN32@s390_trans:
$LN30@s390_trans:
$LN28@s390_trans:

; 1820 :     }

  009aa	e9 83 00 00 00	 jmp	 $LN26@s390_trans
$LN25@s390_trans:

; 1821 :     else
; 1822 :         if((regs->dat.stid == TEA_ST_SECNDRY)
; 1823 :           && (PRIMARY_SPACE_MODE(&regs->psw)

  009af	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009b7	83 b8 20 08 00
	00 02		 cmp	 DWORD PTR [rax+2080], 2
  009be	75 46		 jne	 SHORT $LN33@s390_trans
  009c0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009c8	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  009cc	85 c0		 test	 eax, eax
  009ce	74 13		 je	 SHORT $LN35@s390_trans
  009d0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009d8	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  009dc	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  009e1	75 23		 jne	 SHORT $LN33@s390_trans
$LN35@s390_trans:

; 1824 :             || SECONDARY_SPACE_MODE(&regs->psw)))
; 1825 :             regs->TEA |= TEA_ST_SECNDRY | TEA_SECADDR;

  009e3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009eb	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  009f1	0d 02 00 00 80	 or	 eax, -2147483646	; 80000002H
  009f6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009fe	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax
  00a04	eb 2c		 jmp	 SHORT $LN34@s390_trans
$LN33@s390_trans:

; 1826 :         else
; 1827 :             regs->TEA |= regs->dat.stid;

  00a06	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a0e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a16	8b 89 20 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2080]
  00a1c	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00a22	0b c1		 or	 eax, ecx
  00a24	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a2c	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax
$LN34@s390_trans:
$LN26@s390_trans:

; 1828 : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1829 : 
; 1830 : #if defined( FEATURE_075_ACC_EX_FS_INDIC_FACILITY )
; 1831 :     if (FACILITY_ENABLED( 075_ACC_EX_FS_INDIC, regs ))
; 1832 :     {
; 1833 :         /* Set the fetch/store indication bits 52-53 in the TEA */
; 1834 :         if (acctype & ACC_READ)
; 1835 :         {
; 1836 :             regs->TEA |= TEA_FETCH;
; 1837 :         }
; 1838 :         else if (acctype & (ACC_WRITE | ACC_CHECK))
; 1839 :         {
; 1840 :             regs->TEA |= TEA_STORE;
; 1841 :         }
; 1842 :     }
; 1843 : #endif
; 1844 :     /* Set the exception access identification */
; 1845 :     if (ACCESS_REGISTER_MODE(&regs->psw)
; 1846 :      || (SIE_ACTIVE(regs) && MULTIPLE_CONTROLLED_DATA_SPACE(GUESTREGS))

  00a32	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a3a	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00a3e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00a41	74 06		 je	 SHORT $LN37@s390_trans
  00a43	33 c0		 xor	 eax, eax
  00a45	85 c0		 test	 eax, eax
  00a47	74 32		 je	 SHORT $LN36@s390_trans
$LN37@s390_trans:

; 1847 :        )
; 1848 :        regs->excarid = arn < 0 ? 0 : arn;

  00a49	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  00a51	7d 0a		 jge	 SHORT $LN49@s390_trans
  00a53	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv409[rsp], 0
  00a5b	eb 0b		 jmp	 SHORT $LN50@s390_trans
$LN49@s390_trans:
  00a5d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00a64	89 44 24 54	 mov	 DWORD PTR tv409[rsp], eax
$LN50@s390_trans:
  00a68	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a70	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR tv409[rsp]
  00a75	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl
$LN36@s390_trans:

; 1849 : 
; 1850 :     /* Return condition code */
; 1851 :     return cc;

  00a7b	8b 44 24 24	 mov	 eax, DWORD PTR cc$[rsp]
$LN1@s390_trans:

; 1852 : 
; 1853 : } /* end function translate_addr */

  00a7f	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00a83	c3		 ret	 0
s390_translate_addr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tlbix$ = 32
pte$ = 36
cc$ = 40
sto$ = 48
pto$ = 56
ste$ = 64
tv205 = 72
tv258 = 76
tv269 = 80
tv270 = 84
ptl$ = 88
tv375 = 92
tv479 = 96
tv508 = 100
tv574 = 104
stl$ = 108
tv230 = 112
tv304 = 120
vaddr$ = 144
arn$ = 152
regs$ = 160
acctype$ = 168
s370_translate_addr PROC

; 935  : {

$LN63:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 936  : RADR    sto = 0;                        /* Segment table origin      */

  00019	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR sto$[rsp], 0

; 937  : RADR    pto = 0;                        /* Page table origin         */

  00022	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR pto$[rsp], 0

; 938  : int     cc;                             /* Condition code            */
; 939  : int     tlbix = TLBIX(vaddr);           /* TLB entry index           */

  0002b	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  00032	c1 e8 0b	 shr	 eax, 11
  00035	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0003a	89 44 24 20	 mov	 DWORD PTR tlbix$[rsp], eax

; 940  : 
; 941  : #if !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 942  : /*-----------------------------------*/
; 943  : /* S/370 Dynamic Address Translation */
; 944  : /*-----------------------------------*/
; 945  : U32     stl;                            /* Segment table length      */
; 946  : RADR    ste;                            /* Segment table entry       */
; 947  : U16     pte;                            /* Page table entry          */
; 948  : U32     ptl;                            /* Page table length         */
; 949  : 
; 950  :     regs->dat.pvtaddr = regs->dat.protect = 0;

  0003e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00046	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0004c	83 e0 f9	 and	 eax, -7			; fffffff9H
  0004f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
  0005d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00065	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0006b	83 e0 fe	 and	 eax, -2			; fffffffeH
  0006e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00076	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 951  : 
; 952  :     /* Load the effective segment table descriptor */
; 953  :     if (ARCH_DEP(load_address_space_designator) (arn, regs, acctype))

  0007c	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR acctype$[rsp]
  00084	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0008c	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR arn$[rsp]
  00093	e8 00 00 00 00	 call	 s370_load_address_space_designator
  00098	0f b7 c0	 movzx	 eax, ax
  0009b	85 c0		 test	 eax, eax
  0009d	74 05		 je	 SHORT $LN2@s370_trans

; 954  :         goto tran_alet_excp;

  0009f	e9 b3 0a 00 00	 jmp	 $tran_alet_excp$64
$LN2@s370_trans:

; 955  : 
; 956  :     /* Check the translation format bits in CR0 */
; 957  :     if ((((regs->CR(0) & CR0_PAGE_SIZE) != CR0_PAGE_SZ_2K) &&
; 958  :        ((regs->CR(0) & CR0_PAGE_SIZE) != CR0_PAGE_SZ_4K)) ||

  000a4	b8 08 00 00 00	 mov	 eax, 8
  000a9	48 6b c0 01	 imul	 rax, rax, 1
  000ad	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000bc	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  000c1	3d 00 00 40 00	 cmp	 eax, 4194304		; 00400000H
  000c6	74 24		 je	 SHORT $LN5@s370_trans
  000c8	b8 08 00 00 00	 mov	 eax, 8
  000cd	48 6b c0 01	 imul	 rax, rax, 1
  000d1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000e0	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  000e5	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  000ea	75 45		 jne	 SHORT $LN4@s370_trans
$LN5@s370_trans:
  000ec	b8 08 00 00 00	 mov	 eax, 8
  000f1	48 6b c0 01	 imul	 rax, rax, 1
  000f5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fd	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00104	25 00 00 38 00	 and	 eax, 3670016		; 00380000H
  00109	85 c0		 test	 eax, eax
  0010b	74 29		 je	 SHORT $LN3@s370_trans
  0010d	b8 08 00 00 00	 mov	 eax, 8
  00112	48 6b c0 01	 imul	 rax, rax, 1
  00116	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00125	25 00 00 38 00	 and	 eax, 3670016		; 00380000H
  0012a	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  0012f	74 05		 je	 SHORT $LN3@s370_trans
$LN4@s370_trans:

; 959  :        (((regs->CR(0) & CR0_SEG_SIZE) != CR0_SEG_SZ_64K) &&
; 960  :        ((regs->CR(0) & CR0_SEG_SIZE) != CR0_SEG_SZ_1M)))
; 961  :        goto tran_spec_excp;

  00131	e9 cc 08 00 00	 jmp	 $tran_spec_excp$65
$LN3@s370_trans:

; 962  : 
; 963  :     /* Look up the address in the TLB */
; 964  :     if (   ((vaddr & TLBID_PAGEMASK) | regs->tlbID) == regs->tlb.TLB_VADDR(tlbix)
; 965  :         && (regs->tlb.common[tlbix] || regs->dat.asd == regs->tlb.TLB_ASD(tlbix))
; 966  :         && !(regs->tlb.common[tlbix] && regs->dat.pvtaddr)
; 967  :         && !(acctype & ACC_NOTLB) )

  00136	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  0013d	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  00142	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00150	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR tlbix$[rsp]
  00155	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0015d	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00164	0f 85 f9 00 00
	00		 jne	 $LN6@s370_trans
  0016a	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  0016f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	0f b6 84 01 60
	54 01 00	 movzx	 eax, BYTE PTR [rcx+rax+87136]
  0017f	85 c0		 test	 eax, eax
  00181	75 29		 jne	 SHORT $LN8@s370_trans
  00183	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00188	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00190	8b 84 c1 60 b0
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+45152]
  00197	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	48 39 81 18 08
	00 00		 cmp	 QWORD PTR [rcx+2072], rax
  001a6	0f 85 b7 00 00
	00		 jne	 $LN6@s370_trans
$LN8@s370_trans:
  001ac	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  001b1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b9	0f b6 84 01 60
	54 01 00	 movzx	 eax, BYTE PTR [rcx+rax+87136]
  001c1	85 c0		 test	 eax, eax
  001c3	74 19		 je	 SHORT $LN9@s370_trans
  001c5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cd	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  001d3	83 e0 01	 and	 eax, 1
  001d6	85 c0		 test	 eax, eax
  001d8	0f 85 85 00 00
	00		 jne	 $LN6@s370_trans
$LN9@s370_trans:
  001de	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  001e5	25 00 01 00 00	 and	 eax, 256		; 00000100H
  001ea	85 c0		 test	 eax, eax
  001ec	75 75		 jne	 SHORT $LN6@s370_trans

; 968  :     {
; 969  :         pte = regs->tlb.TLB_PTE(tlbix);

  001ee	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  001f3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fb	0f b7 84 c1 60
	f0 00 00	 movzx	 eax, WORD PTR [rcx+rax*8+61536]
  00203	66 89 44 24 24	 mov	 WORD PTR pte$[rsp], ax

; 970  : 
; 971  : #if defined( FEATURE_SEGMENT_PROTECTION )
; 972  :         /* Set the protection indicator if segment is protected */
; 973  :         if (regs->tlb.protect[tlbix])

  00208	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  0020d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00215	0f b6 84 01 60
	58 01 00	 movzx	 eax, BYTE PTR [rcx+rax+88160]
  0021d	85 c0		 test	 eax, eax
  0021f	74 3d		 je	 SHORT $LN10@s370_trans

; 974  :             regs->dat.protect = regs->tlb.protect[tlbix];

  00221	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00226	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0022e	0f b6 84 01 60
	58 01 00	 movzx	 eax, BYTE PTR [rcx+rax+88160]
  00236	83 e0 03	 and	 eax, 3
  00239	d1 e0		 shl	 eax, 1
  0023b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00243	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  00249	83 e1 f9	 and	 ecx, -7			; fffffff9H
  0024c	0b c8		 or	 ecx, eax
  0024e	8b c1		 mov	 eax, ecx
  00250	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00258	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN10@s370_trans:

; 975  : #endif
; 976  :     }

  0025e	e9 c6 06 00 00	 jmp	 $LN7@s370_trans
$LN6@s370_trans:

; 977  :     else
; 978  :     {
; 979  :         /* S/370 segment table lookup */
; 980  : 
; 981  :         /* Calculate the real address of the segment table entry */
; 982  :         sto = regs->dat.asd & STD_370_STO;

  00263	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026b	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00272	48 25 c0 ff ff
	00		 and	 rax, 16777152		; 00ffffc0H
  00278	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 983  :         stl = regs->dat.asd & STD_370_STL;

  0027d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00285	b9 00 00 00 ff	 mov	 ecx, -16777216		; ff000000H
  0028a	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00291	48 23 c1	 and	 rax, rcx
  00294	89 44 24 6c	 mov	 DWORD PTR stl$[rsp], eax

; 984  :         sto += ((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_1M) ?

  00298	b8 08 00 00 00	 mov	 eax, 8
  0029d	48 6b c0 01	 imul	 rax, rax, 1
  002a1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  002b0	25 00 00 38 00	 and	 eax, 3670016		; 00380000H
  002b5	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  002ba	75 15		 jne	 SHORT $LN43@s370_trans
  002bc	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  002c3	25 00 00 f0 00	 and	 eax, 15728640		; 00f00000H
  002c8	c1 e8 12	 shr	 eax, 18
  002cb	89 44 24 48	 mov	 DWORD PTR tv205[rsp], eax
  002cf	eb 13		 jmp	 SHORT $LN44@s370_trans
$LN43@s370_trans:
  002d1	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  002d8	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  002dd	c1 e8 0e	 shr	 eax, 14
  002e0	89 44 24 48	 mov	 DWORD PTR tv205[rsp], eax
$LN44@s370_trans:
  002e4	8b 44 24 48	 mov	 eax, DWORD PTR tv205[rsp]
  002e8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  002ed	48 03 c8	 add	 rcx, rax
  002f0	48 8b c1	 mov	 rax, rcx
  002f3	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 985  :             ((vaddr & 0x00F00000) >> 18) :
; 986  :             ((vaddr & 0x00FF0000) >> 14);
; 987  : 
; 988  :         /* Check that virtual address is within the segment table */
; 989  :         if (((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_64K) &&

  002f8	b8 08 00 00 00	 mov	 eax, 8
  002fd	48 6b c0 01	 imul	 rax, rax, 1
  00301	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00310	25 00 00 38 00	 and	 eax, 3670016		; 00380000H
  00315	85 c0		 test	 eax, eax
  00317	75 1a		 jne	 SHORT $LN11@s370_trans
  00319	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  00320	c1 e0 04	 shl	 eax, 4
  00323	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00328	3b 44 24 6c	 cmp	 eax, DWORD PTR stl$[rsp]
  0032c	76 05		 jbe	 SHORT $LN11@s370_trans

; 990  :             ((vaddr << 4) & STD_370_STL) > stl)
; 991  :             goto seg_tran_length;

  0032e	e9 f2 07 00 00	 jmp	 $seg_tran_length$66
$LN11@s370_trans:

; 992  : 
; 993  :         /* Generate addressing exception if outside real storage */
; 994  :         if (sto > regs->mainlim)

  00333	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0033b	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00342	48 39 44 24 30	 cmp	 QWORD PTR sto$[rsp], rax
  00347	76 05		 jbe	 SHORT $LN12@s370_trans

; 995  :             goto address_excp;

  00349	e9 9e 06 00 00	 jmp	 $address_excp$67
$LN12@s370_trans:

; 996  : 
; 997  :         /* Fetch segment table entry from real storage.  All bytes
; 998  :            must be fetched concurrently as observed by other CPUs */
; 999  :         sto = APPLY_PREFIXING (sto, regs->PX);

  0034e	8b 44 24 30	 mov	 eax, DWORD PTR sto$[rsp]
  00352	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00358	48 85 c0	 test	 rax, rax
  0035b	74 26		 je	 SHORT $LN45@s370_trans
  0035d	8b 44 24 30	 mov	 eax, DWORD PTR sto$[rsp]
  00361	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00367	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036f	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00372	48 3b c1	 cmp	 rax, rcx
  00375	74 0c		 je	 SHORT $LN45@s370_trans
  00377	48 8b 44 24 30	 mov	 rax, QWORD PTR sto$[rsp]
  0037c	48 89 44 24 70	 mov	 QWORD PTR tv230[rsp], rax
  00381	eb 1a		 jmp	 SHORT $LN46@s370_trans
$LN45@s370_trans:
  00383	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038b	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0038e	8b 4c 24 30	 mov	 ecx, DWORD PTR sto$[rsp]
  00392	33 c8		 xor	 ecx, eax
  00394	8b c1		 mov	 eax, ecx
  00396	8b c0		 mov	 eax, eax
  00398	48 89 44 24 70	 mov	 QWORD PTR tv230[rsp], rax
$LN46@s370_trans:
  0039d	48 8b 44 24 70	 mov	 rax, QWORD PTR tv230[rsp]
  003a2	48 89 44 24 30	 mov	 QWORD PTR sto$[rsp], rax

; 1000 :         ste = ARCH_DEP(fetch_fullword_absolute) (sto, regs);

  003a7	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  003b4	e8 00 00 00 00	 call	 s370_fetch_fullword_absolute
  003b9	8b c0		 mov	 eax, eax
  003bb	48 89 44 24 40	 mov	 QWORD PTR ste$[rsp], rax

; 1001 : 
; 1002 :         /* Generate segment translation exception if segment invalid */
; 1003 :         if (ste & SEGTAB_370_INVL)

  003c0	48 8b 44 24 40	 mov	 rax, QWORD PTR ste$[rsp]
  003c5	48 83 e0 01	 and	 rax, 1
  003c9	48 85 c0	 test	 rax, rax
  003cc	74 05		 je	 SHORT $LN13@s370_trans

; 1004 :             goto seg_tran_invalid;

  003ce	e9 6a 06 00 00	 jmp	 $seg_tran_invalid$68
$LN13@s370_trans:

; 1005 : 
; 1006 :         /* Check that all the reserved bits in the STE are zero */
; 1007 :         if (ste & SEGTAB_370_RSV)

  003d3	48 8b 44 24 40	 mov	 rax, QWORD PTR ste$[rsp]
  003d8	48 25 00 00 00
	0f		 and	 rax, 251658240		; 0f000000H
  003de	48 85 c0	 test	 rax, rax
  003e1	74 05		 je	 SHORT $LN14@s370_trans

; 1008 :             goto tran_spec_excp;

  003e3	e9 1a 06 00 00	 jmp	 $tran_spec_excp$65
$LN14@s370_trans:

; 1009 : 
; 1010 :         /* Isolate page table origin and length */
; 1011 :         pto = ste & SEGTAB_370_PTO;

  003e8	48 8b 44 24 40	 mov	 rax, QWORD PTR ste$[rsp]
  003ed	48 25 f8 ff ff
	00		 and	 rax, 16777208		; 00fffff8H
  003f3	48 89 44 24 38	 mov	 QWORD PTR pto$[rsp], rax

; 1012 :         ptl = ste & SEGTAB_370_PTL;

  003f8	b8 00 00 00 f0	 mov	 eax, -268435456		; f0000000H
  003fd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ste$[rsp]
  00402	48 23 c8	 and	 rcx, rax
  00405	48 8b c1	 mov	 rax, rcx
  00408	89 44 24 58	 mov	 DWORD PTR ptl$[rsp], eax

; 1013 : 
; 1014 :         /* S/370 page table lookup */
; 1015 : 
; 1016 :         /* Calculate the real address of the page table entry */
; 1017 :         pto += ((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_1M) ?

  0040c	b8 08 00 00 00	 mov	 eax, 8
  00411	48 6b c0 01	 imul	 rax, rax, 1
  00415	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00424	25 00 00 38 00	 and	 eax, 3670016		; 00380000H
  00429	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  0042e	75 56		 jne	 SHORT $LN51@s370_trans
  00430	b8 08 00 00 00	 mov	 eax, 8
  00435	48 6b c0 01	 imul	 rax, rax, 1
  00439	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00441	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00448	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  0044d	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  00452	75 15		 jne	 SHORT $LN47@s370_trans
  00454	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  0045b	25 00 f0 0f 00	 and	 eax, 1044480		; 000ff000H
  00460	c1 e8 0b	 shr	 eax, 11
  00463	89 44 24 4c	 mov	 DWORD PTR tv258[rsp], eax
  00467	eb 13		 jmp	 SHORT $LN48@s370_trans
$LN47@s370_trans:
  00469	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  00470	25 00 f8 0f 00	 and	 eax, 1046528		; 000ff800H
  00475	c1 e8 0a	 shr	 eax, 10
  00478	89 44 24 4c	 mov	 DWORD PTR tv258[rsp], eax
$LN48@s370_trans:
  0047c	8b 44 24 4c	 mov	 eax, DWORD PTR tv258[rsp]
  00480	89 44 24 54	 mov	 DWORD PTR tv270[rsp], eax
  00484	eb 54		 jmp	 SHORT $LN52@s370_trans
$LN51@s370_trans:
  00486	b8 08 00 00 00	 mov	 eax, 8
  0048b	48 6b c0 01	 imul	 rax, rax, 1
  0048f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00497	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0049e	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  004a3	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  004a8	75 15		 jne	 SHORT $LN49@s370_trans
  004aa	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  004b1	25 00 f0 00 00	 and	 eax, 61440		; 0000f000H
  004b6	c1 e8 0b	 shr	 eax, 11
  004b9	89 44 24 50	 mov	 DWORD PTR tv269[rsp], eax
  004bd	eb 13		 jmp	 SHORT $LN50@s370_trans
$LN49@s370_trans:
  004bf	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  004c6	25 00 f8 00 00	 and	 eax, 63488		; 0000f800H
  004cb	c1 e8 0a	 shr	 eax, 10
  004ce	89 44 24 50	 mov	 DWORD PTR tv269[rsp], eax
$LN50@s370_trans:
  004d2	8b 44 24 50	 mov	 eax, DWORD PTR tv269[rsp]
  004d6	89 44 24 54	 mov	 DWORD PTR tv270[rsp], eax
$LN52@s370_trans:
  004da	8b 44 24 54	 mov	 eax, DWORD PTR tv270[rsp]
  004de	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pto$[rsp]
  004e3	48 03 c8	 add	 rcx, rax
  004e6	48 8b c1	 mov	 rax, rcx
  004e9	48 89 44 24 38	 mov	 QWORD PTR pto$[rsp], rax

; 1018 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 1019 :             ((vaddr & 0x000FF000) >> 11) :
; 1020 :             ((vaddr & 0x000FF800) >> 10)) :
; 1021 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 1022 :             ((vaddr & 0x0000F000) >> 11) :
; 1023 :             ((vaddr & 0x0000F800) >> 10));
; 1024 : 
; 1025 :         /* Generate addressing exception if outside real storage */
; 1026 :         if (pto > regs->mainlim)

  004ee	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f6	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  004fd	48 39 44 24 38	 cmp	 QWORD PTR pto$[rsp], rax
  00502	76 05		 jbe	 SHORT $LN15@s370_trans

; 1027 :             goto address_excp;

  00504	e9 e3 04 00 00	 jmp	 $address_excp$67
$LN15@s370_trans:

; 1028 : 
; 1029 :         /* Check that the virtual address is within the page table */
; 1030 :         if ((((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_1M) &&
; 1031 :             (((vaddr & 0x000F0000) >> 16) > ptl)) ||

  00509	b8 08 00 00 00	 mov	 eax, 8
  0050e	48 6b c0 01	 imul	 rax, rax, 1
  00512	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0051a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00521	25 00 00 38 00	 and	 eax, 3670016		; 00380000H
  00526	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  0052b	75 15		 jne	 SHORT $LN18@s370_trans
  0052d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  00534	25 00 00 0f 00	 and	 eax, 983040		; 000f0000H
  00539	c1 e8 10	 shr	 eax, 16
  0053c	3b 44 24 58	 cmp	 eax, DWORD PTR ptl$[rsp]
  00540	77 36		 ja	 SHORT $LN17@s370_trans
$LN18@s370_trans:
  00542	b8 08 00 00 00	 mov	 eax, 8
  00547	48 6b c0 01	 imul	 rax, rax, 1
  0054b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00553	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0055a	25 00 00 38 00	 and	 eax, 3670016		; 00380000H
  0055f	85 c0		 test	 eax, eax
  00561	75 1a		 jne	 SHORT $LN16@s370_trans
  00563	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  0056a	25 00 f0 00 00	 and	 eax, 61440		; 0000f000H
  0056f	c1 e8 0c	 shr	 eax, 12
  00572	3b 44 24 58	 cmp	 eax, DWORD PTR ptl$[rsp]
  00576	76 05		 jbe	 SHORT $LN16@s370_trans
$LN17@s370_trans:

; 1032 :             (((regs->CR(0) & CR0_SEG_SIZE) == CR0_SEG_SZ_64K) &&
; 1033 :             (((vaddr & 0x0000F000) >> 12) > ptl)))
; 1034 :             goto page_tran_length;

  00578	e9 76 05 00 00	 jmp	 $page_tran_length$69
$LN16@s370_trans:

; 1035 : 
; 1036 :         /* Fetch the page table entry from real storage.  All bytes
; 1037 :            must be fetched concurrently as observed by other CPUs */
; 1038 :         pto = APPLY_PREFIXING (pto, regs->PX);

  0057d	8b 44 24 38	 mov	 eax, DWORD PTR pto$[rsp]
  00581	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00587	48 85 c0	 test	 rax, rax
  0058a	74 26		 je	 SHORT $LN53@s370_trans
  0058c	8b 44 24 38	 mov	 eax, DWORD PTR pto$[rsp]
  00590	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00596	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0059e	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  005a1	48 3b c1	 cmp	 rax, rcx
  005a4	74 0c		 je	 SHORT $LN53@s370_trans
  005a6	48 8b 44 24 38	 mov	 rax, QWORD PTR pto$[rsp]
  005ab	48 89 44 24 78	 mov	 QWORD PTR tv304[rsp], rax
  005b0	eb 1a		 jmp	 SHORT $LN54@s370_trans
$LN53@s370_trans:
  005b2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ba	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  005bd	8b 4c 24 38	 mov	 ecx, DWORD PTR pto$[rsp]
  005c1	33 c8		 xor	 ecx, eax
  005c3	8b c1		 mov	 eax, ecx
  005c5	8b c0		 mov	 eax, eax
  005c7	48 89 44 24 78	 mov	 QWORD PTR tv304[rsp], rax
$LN54@s370_trans:
  005cc	48 8b 44 24 78	 mov	 rax, QWORD PTR tv304[rsp]
  005d1	48 89 44 24 38	 mov	 QWORD PTR pto$[rsp], rax

; 1039 :         pte = ARCH_DEP(fetch_halfword_absolute) (pto, regs);

  005d6	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005de	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pto$[rsp]
  005e3	e8 00 00 00 00	 call	 s370_fetch_halfword_absolute
  005e8	66 89 44 24 24	 mov	 WORD PTR pte$[rsp], ax

; 1040 : 
; 1041 :         /* Generate page translation exception if page invalid */
; 1042 :         if ((((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) &&
; 1043 :             (pte & PAGETAB_INV_4K)) ||

  005ed	b8 08 00 00 00	 mov	 eax, 8
  005f2	48 6b c0 01	 imul	 rax, rax, 1
  005f6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005fe	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00605	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  0060a	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  0060f	75 0c		 jne	 SHORT $LN21@s370_trans
  00611	0f b7 44 24 24	 movzx	 eax, WORD PTR pte$[rsp]
  00616	83 e0 08	 and	 eax, 8
  00619	85 c0		 test	 eax, eax
  0061b	75 30		 jne	 SHORT $LN20@s370_trans
$LN21@s370_trans:
  0061d	b8 08 00 00 00	 mov	 eax, 8
  00622	48 6b c0 01	 imul	 rax, rax, 1
  00626	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0062e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00635	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  0063a	3d 00 00 40 00	 cmp	 eax, 4194304		; 00400000H
  0063f	75 11		 jne	 SHORT $LN19@s370_trans
  00641	0f b7 44 24 24	 movzx	 eax, WORD PTR pte$[rsp]
  00646	83 e0 04	 and	 eax, 4
  00649	85 c0		 test	 eax, eax
  0064b	74 05		 je	 SHORT $LN19@s370_trans
$LN20@s370_trans:

; 1044 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_2K) &&
; 1045 :             (pte & PAGETAB_INV_2K)))
; 1046 :             goto page_tran_invalid;

  0064d	e9 55 04 00 00	 jmp	 $page_tran_invalid$70
$LN19@s370_trans:

; 1047 : 
; 1048 :         /* Check that all the reserved bits in the PTE are zero */
; 1049 :         if (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_2K) &&

  00652	b8 08 00 00 00	 mov	 eax, 8
  00657	48 6b c0 01	 imul	 rax, rax, 1
  0065b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00663	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0066a	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  0066f	3d 00 00 40 00	 cmp	 eax, 4194304		; 00400000H
  00674	75 11		 jne	 SHORT $LN22@s370_trans
  00676	0f b7 44 24 24	 movzx	 eax, WORD PTR pte$[rsp]
  0067b	83 e0 02	 and	 eax, 2
  0067e	85 c0		 test	 eax, eax
  00680	74 05		 je	 SHORT $LN22@s370_trans

; 1050 :             (pte & PAGETAB_RSV_2K))
; 1051 :             goto tran_spec_excp;

  00682	e9 7b 03 00 00	 jmp	 $tran_spec_excp$65
$LN22@s370_trans:

; 1052 : 
; 1053 : #if defined( FEATURE_SEGMENT_PROTECTION )
; 1054 :         /* Set the protection indicator if segment is protected */
; 1055 :         if (ste & SEGTAB_370_PROT)

  00687	48 8b 44 24 40	 mov	 rax, QWORD PTR ste$[rsp]
  0068c	48 83 e0 04	 and	 rax, 4
  00690	48 85 c0	 test	 rax, rax
  00693	74 3e		 je	 SHORT $LN23@s370_trans

; 1056 :             regs->dat.protect |= 1;

  00695	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0069d	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  006a3	d1 e8		 shr	 eax, 1
  006a5	83 e0 03	 and	 eax, 3
  006a8	83 c8 01	 or	 eax, 1
  006ab	83 e0 03	 and	 eax, 3
  006ae	d1 e0		 shl	 eax, 1
  006b0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006b8	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  006be	83 e1 f9	 and	 ecx, -7			; fffffff9H
  006c1	0b c8		 or	 ecx, eax
  006c3	8b c1		 mov	 eax, ecx
  006c5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006cd	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN23@s370_trans:

; 1057 : #endif
; 1058 : 
; 1059 :         /* Place the translated address in the TLB */
; 1060 :         if (!(acctype & ACC_NOTLB))

  006d3	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  006da	25 00 01 00 00	 and	 eax, 256		; 00000100H
  006df	85 c0		 test	 eax, eax
  006e1	0f 85 42 02 00
	00		 jne	 $LN24@s370_trans

; 1061 :         {
; 1062 :             regs->tlb.TLB_ASD(tlbix)   = regs->dat.asd;

  006e7	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  006ec	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006f4	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006fc	8b 92 18 08 00
	00		 mov	 edx, DWORD PTR [rdx+2072]
  00702	89 94 c1 60 b0
	00 00		 mov	 DWORD PTR [rcx+rax*8+45152], edx

; 1063 :             regs->tlb.TLB_VADDR(tlbix) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;

  00709	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  00710	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  00715	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0071d	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00723	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR tlbix$[rsp]
  00728	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00730	89 84 ca 60 d0
	00 00		 mov	 DWORD PTR [rdx+rcx*8+53344], eax

; 1064 :             regs->tlb.TLB_PTE(tlbix)   = pte;

  00737	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  0073c	0f b7 4c 24 24	 movzx	 ecx, WORD PTR pte$[rsp]
  00741	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00749	89 8c c2 60 f0
	00 00		 mov	 DWORD PTR [rdx+rax*8+61536], ecx

; 1065 :             regs->tlb.common[tlbix]    = (ste & SEGTAB_370_CMN) ? 1 : 0;

  00750	48 8b 44 24 40	 mov	 rax, QWORD PTR ste$[rsp]
  00755	48 83 e0 02	 and	 rax, 2
  00759	48 85 c0	 test	 rax, rax
  0075c	74 0a		 je	 SHORT $LN55@s370_trans
  0075e	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv375[rsp], 1
  00766	eb 08		 jmp	 SHORT $LN56@s370_trans
$LN55@s370_trans:
  00768	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv375[rsp], 0
$LN56@s370_trans:
  00770	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  00775	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0077d	0f b6 54 24 5c	 movzx	 edx, BYTE PTR tv375[rsp]
  00782	88 94 01 60 54
	01 00		 mov	 BYTE PTR [rcx+rax+87136], dl

; 1066 :             regs->tlb.protect[tlbix]   = regs->dat.protect;

  00789	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00791	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00797	d1 e8		 shr	 eax, 1
  00799	83 e0 03	 and	 eax, 3
  0079c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR tlbix$[rsp]
  007a1	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007a9	88 84 0a 60 58
	01 00		 mov	 BYTE PTR [rdx+rcx+88160], al

; 1067 :             regs->tlb.acc[tlbix]       = 0;

  007b0	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  007b5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007bd	c6 84 01 60 5c
	01 00 00	 mov	 BYTE PTR [rcx+rax+89184], 0

; 1068 :             regs->tlb.main[tlbix]      = NULL;

  007c5	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  007ca	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007d2	48 c7 84 c1 60
	10 01 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax*8+69728], 0

; 1069 : 
; 1070 :             /* Set adjacent TLB entry if 4K page sizes */
; 1071 :             if ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K)

  007de	b8 08 00 00 00	 mov	 eax, 8
  007e3	48 6b c0 01	 imul	 rax, rax, 1
  007e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007ef	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  007f6	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  007fb	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  00800	0f 85 23 01 00
	00		 jne	 $LN25@s370_trans

; 1072 :             {
; 1073 :                 regs->tlb.TLB_ASD(tlbix^1)   = regs->tlb.TLB_ASD(tlbix);

  00806	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  0080b	8b 4c 24 20	 mov	 ecx, DWORD PTR tlbix$[rsp]
  0080f	83 f1 01	 xor	 ecx, 1
  00812	48 63 c9	 movsxd	 rcx, ecx
  00815	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0081d	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00825	41 8b 84 c0 60
	b0 00 00	 mov	 eax, DWORD PTR [r8+rax*8+45152]
  0082d	89 84 ca 60 b0
	00 00		 mov	 DWORD PTR [rdx+rcx*8+45152], eax

; 1074 :                 regs->tlb.TLB_VADDR(tlbix^1) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;

  00834	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  0083b	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  00840	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00848	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  0084e	8b 4c 24 20	 mov	 ecx, DWORD PTR tlbix$[rsp]
  00852	83 f1 01	 xor	 ecx, 1
  00855	48 63 c9	 movsxd	 rcx, ecx
  00858	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00860	89 84 ca 60 d0
	00 00		 mov	 DWORD PTR [rdx+rcx*8+53344], eax

; 1075 :                 regs->tlb.TLB_PTE(tlbix^1)   = regs->tlb.TLB_PTE(tlbix);

  00867	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  0086c	8b 4c 24 20	 mov	 ecx, DWORD PTR tlbix$[rsp]
  00870	83 f1 01	 xor	 ecx, 1
  00873	48 63 c9	 movsxd	 rcx, ecx
  00876	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0087e	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00886	41 8b 84 c0 60
	f0 00 00	 mov	 eax, DWORD PTR [r8+rax*8+61536]
  0088e	89 84 ca 60 f0
	00 00		 mov	 DWORD PTR [rdx+rcx*8+61536], eax

; 1076 :                 regs->tlb.common[tlbix^1]    = regs->tlb.common[tlbix];

  00895	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  0089a	8b 4c 24 20	 mov	 ecx, DWORD PTR tlbix$[rsp]
  0089e	83 f1 01	 xor	 ecx, 1
  008a1	48 63 c9	 movsxd	 rcx, ecx
  008a4	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008ac	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  008b4	41 0f b6 84 00
	60 54 01 00	 movzx	 eax, BYTE PTR [r8+rax+87136]
  008bd	88 84 0a 60 54
	01 00		 mov	 BYTE PTR [rdx+rcx+87136], al

; 1077 :                 regs->tlb.protect[tlbix^1]   = regs->tlb.protect[tlbix];

  008c4	48 63 44 24 20	 movsxd	 rax, DWORD PTR tlbix$[rsp]
  008c9	8b 4c 24 20	 mov	 ecx, DWORD PTR tlbix$[rsp]
  008cd	83 f1 01	 xor	 ecx, 1
  008d0	48 63 c9	 movsxd	 rcx, ecx
  008d3	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008db	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  008e3	41 0f b6 84 00
	60 58 01 00	 movzx	 eax, BYTE PTR [r8+rax+88160]
  008ec	88 84 0a 60 58
	01 00		 mov	 BYTE PTR [rdx+rcx+88160], al

; 1078 :                 regs->tlb.acc[tlbix^1]       = 0;

  008f3	8b 44 24 20	 mov	 eax, DWORD PTR tlbix$[rsp]
  008f7	83 f0 01	 xor	 eax, 1
  008fa	48 98		 cdqe
  008fc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00904	c6 84 01 60 5c
	01 00 00	 mov	 BYTE PTR [rcx+rax+89184], 0

; 1079 :                 regs->tlb.main[tlbix^1]      = NULL;

  0090c	8b 44 24 20	 mov	 eax, DWORD PTR tlbix$[rsp]
  00910	83 f0 01	 xor	 eax, 1
  00913	48 98		 cdqe
  00915	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0091d	48 c7 84 c1 60
	10 01 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax*8+69728], 0
$LN25@s370_trans:
$LN24@s370_trans:
$LN7@s370_trans:

; 1080 :             }
; 1081 :         }
; 1082 :     } /* end if(!TLB) */
; 1083 : 
; 1084 :     /* Combine the page frame real address with the byte
; 1085 :        index of the virtual address to form the real address */
; 1086 :     regs->dat.raddr = ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?

  00929	b8 08 00 00 00	 mov	 eax, 8
  0092e	48 6b c0 01	 imul	 rax, rax, 1
  00932	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0093a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00941	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  00946	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  0094b	75 30		 jne	 SHORT $LN57@s370_trans
  0094d	0f b7 44 24 24	 movzx	 eax, WORD PTR pte$[rsp]
  00952	83 e0 06	 and	 eax, 6
  00955	c1 e0 17	 shl	 eax, 23
  00958	0f b7 4c 24 24	 movzx	 ecx, WORD PTR pte$[rsp]
  0095d	81 e1 f0 ff 00
	00		 and	 ecx, 65520		; 0000fff0H
  00963	c1 e1 08	 shl	 ecx, 8
  00966	0b c1		 or	 eax, ecx
  00968	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR vaddr$[rsp]
  0096f	81 e1 ff 0f 00
	00		 and	 ecx, 4095		; 00000fffH
  00975	0b c1		 or	 eax, ecx
  00977	89 44 24 60	 mov	 DWORD PTR tv479[rsp], eax
  0097b	eb 20		 jmp	 SHORT $LN58@s370_trans
$LN57@s370_trans:
  0097d	0f b7 44 24 24	 movzx	 eax, WORD PTR pte$[rsp]
  00982	25 f8 ff 00 00	 and	 eax, 65528		; 0000fff8H
  00987	c1 e0 08	 shl	 eax, 8
  0098a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR vaddr$[rsp]
  00991	81 e1 ff 07 00
	00		 and	 ecx, 2047		; 000007ffH
  00997	0b c1		 or	 eax, ecx
  00999	89 44 24 60	 mov	 DWORD PTR tv479[rsp], eax
$LN58@s370_trans:
  0099d	8b 44 24 60	 mov	 eax, DWORD PTR tv479[rsp]
  009a1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a9	48 89 81 00 08
	00 00		 mov	 QWORD PTR [rcx+2048], rax

; 1087 : #if defined( FEATURE_S370E_EXTENDED_ADDRESSING )
; 1088 :         (((U32)pte & PAGETAB_EA_4K) << 23) |
; 1089 : #endif
; 1090 :         (((U32)pte & PAGETAB_PFRA_4K) << 8) | (vaddr & 0xFFF) :
; 1091 :         (((U32)pte & PAGETAB_PFRA_2K) << 8) | (vaddr & 0x7FF);
; 1092 : 
; 1093 :     regs->dat.rpfra = regs->dat.raddr & PAGEFRAME_PAGEMASK;

  009b0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009b8	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  009bf	48 25 00 f8 ff
	7f		 and	 rax, 2147481600		; 7ffff800H
  009c5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009cd	48 89 81 10 08
	00 00		 mov	 QWORD PTR [rcx+2064], rax

; 1094 : #endif /* !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1095 : 
; 1096 : #if defined( FEATURE_S390_DAT )
; 1097 : /*-----------------------------------*/
; 1098 : /* S/390 Dynamic Address Translation */
; 1099 : /*-----------------------------------*/
; 1100 : U32     stl;                            /* Segment table length      */
; 1101 : RADR    ste;                            /* Segment table entry       */
; 1102 : RADR    pte;                            /* Page table entry          */
; 1103 : U32     ptl;                            /* Page table length         */
; 1104 : 
; 1105 :     regs->dat.pvtaddr = regs->dat.protect = 0;
; 1106 : 
; 1107 :     /* [3.11.3.1] Load the effective segment table descriptor */
; 1108 :     if (ARCH_DEP(load_address_space_designator) (arn, regs, acctype))
; 1109 :         goto tran_alet_excp;
; 1110 : 
; 1111 :     /* [3.11.3.2] Check the translation format bits in CR0 */
; 1112 :     if ((regs->CR(0) & CR0_TRAN_FMT) != CR0_TRAN_ESA390)
; 1113 :         goto tran_spec_excp;
; 1114 : 
; 1115 :     /* Extract the private space bit from segment table descriptor */
; 1116 :     regs->dat.pvtaddr = ((regs->dat.asd & STD_PRIVATE) != 0);
; 1117 : 
; 1118 :     /* [3.11.4] Look up the address in the TLB */
; 1119 :     if (   ((vaddr & TLBID_PAGEMASK) | regs->tlbID) == regs->tlb.TLB_VADDR(tlbix)
; 1120 :         && (regs->tlb.common[tlbix] || regs->dat.asd == regs->tlb.TLB_ASD(tlbix))
; 1121 :         && !(regs->tlb.common[tlbix] && regs->dat.pvtaddr)
; 1122 :         && !(acctype & ACC_NOTLB) )
; 1123 :     {
; 1124 :         pte = regs->tlb.TLB_PTE(tlbix);
; 1125 :         if (regs->tlb.protect[tlbix])
; 1126 :             regs->dat.protect = regs->tlb.protect[tlbix];
; 1127 :     }
; 1128 :     else
; 1129 :     {
; 1130 :         /* [3.11.3.3] Segment table lookup */
; 1131 : 
; 1132 :         /* Calculate the real address of the segment table entry */
; 1133 :         sto = regs->dat.asd & STD_STO;
; 1134 :         stl = regs->dat.asd & STD_STL;
; 1135 :         sto += (vaddr & 0x7FF00000) >> 18;
; 1136 : 
; 1137 :         /* Check that virtual address is within the segment table */
; 1138 :         if ((vaddr >> 24) > stl)
; 1139 :             goto seg_tran_length;
; 1140 : 
; 1141 :         /* Generate addressing exception if outside real storage */
; 1142 :         if (sto > regs->mainlim)
; 1143 :             goto address_excp;
; 1144 : 
; 1145 :         /* Fetch segment table entry from real storage.  All bytes
; 1146 :            must be fetched concurrently as observed by other CPUs */
; 1147 :         sto = APPLY_PREFIXING (sto, regs->PX);
; 1148 :         ste = ARCH_DEP(fetch_fullword_absolute) (sto, regs);
; 1149 : 
; 1150 :         /* Generate segment translation exception if segment invalid */
; 1151 :         if (ste & SEGTAB_INVALID)
; 1152 :             goto seg_tran_invalid;
; 1153 : 
; 1154 :         /* Check that all the reserved bits in the STE are zero */
; 1155 :         if (ste & SEGTAB_RESV)
; 1156 :             goto tran_spec_excp;
; 1157 : 
; 1158 :         /* If the segment table origin register indicates a private
; 1159 :            address space then STE must not indicate a common segment */
; 1160 :         if (regs->dat.pvtaddr && (ste & (SEGTAB_COMMON)))
; 1161 :             goto tran_spec_excp;
; 1162 : 
; 1163 :         /* Isolate page table origin and length */
; 1164 :         pto = ste & SEGTAB_PTO;
; 1165 :         ptl = ste & SEGTAB_PTL;
; 1166 : 
; 1167 :         /* [3.11.3.4] Page table lookup */
; 1168 : 
; 1169 :         /* Calculate the real address of the page table entry */
; 1170 :         pto += (vaddr & 0x000FF000) >> 10;
; 1171 : 
; 1172 :         /* Check that the virtual address is within the page table */
; 1173 :         if (((vaddr & 0x000FF000) >> 16) > ptl)
; 1174 :             goto page_tran_length;
; 1175 : 
; 1176 :         /* Generate addressing exception if outside real storage */
; 1177 :         if (pto > regs->mainlim)
; 1178 :             goto address_excp;
; 1179 : 
; 1180 :         /* Fetch the page table entry from real storage.  All bytes
; 1181 :            must be fetched concurrently as observed by other CPUs */
; 1182 :         pto = APPLY_PREFIXING (pto, regs->PX);
; 1183 :         pte = ARCH_DEP(fetch_fullword_absolute) (pto, regs);
; 1184 : 
; 1185 :         /* Generate page translation exception if page invalid */
; 1186 :         if (pte & PAGETAB_INVALID)
; 1187 :             goto page_tran_invalid;
; 1188 : 
; 1189 :         /* Check that all the reserved bits in the PTE are zero */
; 1190 :         if (pte & PAGETAB_RESV)
; 1191 :             goto tran_spec_excp;
; 1192 : 
; 1193 :         /* Set the protection indicator if page protection is active */
; 1194 :         if (pte & PAGETAB_PROT)
; 1195 :             regs->dat.protect |= 1;
; 1196 : 
; 1197 :         /* [3.11.4.2] Place the translated address in the TLB */
; 1198 :         if (!(acctype & ACC_NOTLB))
; 1199 :         {
; 1200 :             regs->tlb.TLB_ASD(tlbix)   = regs->dat.asd;
; 1201 :             regs->tlb.TLB_VADDR(tlbix) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;
; 1202 :             regs->tlb.TLB_PTE(tlbix)   = pte;
; 1203 :             regs->tlb.common[tlbix]    = (ste & SEGTAB_COMMON) ? 1 : 0;
; 1204 :             regs->tlb.acc[tlbix]       = 0;
; 1205 :             regs->tlb.protect[tlbix]   = regs->dat.protect;
; 1206 :             regs->tlb.main[tlbix]      = NULL;
; 1207 :         }
; 1208 :     } /* end if(!TLB) */
; 1209 : 
; 1210 :     if(!(acctype & ACC_PTE))
; 1211 :     {
; 1212 :     /* [3.11.3.5] Combine the page frame real address with the byte
; 1213 :        index of the virtual address to form the real address */
; 1214 :         regs->dat.raddr = (pte & PAGETAB_PFRA) | (vaddr & 0xFFF);
; 1215 :         regs->dat.rpfra = (pte & PAGETAB_PFRA);
; 1216 :     }
; 1217 :     else
; 1218 :     /* In the case of lock page, return the address of the
; 1219 :        pagetable entry */
; 1220 :         regs->dat.raddr = pto;
; 1221 : 
; 1222 : #endif /* defined( FEATURE_S390_DAT ) */
; 1223 : 
; 1224 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1225 : /*-----------------------------------*/
; 1226 : /* ESAME Dynamic Address Translation */
; 1227 : /*-----------------------------------*/
; 1228 : RADR    rte;                            /* Region table entry        */
; 1229 : #define rto     sto                     /* Region/seg table origin   */
; 1230 : RADR    ste = 0;                        /* Segment table entry       */
; 1231 : RADR    pte = 0;                        /* Page table entry          */
; 1232 : BYTE    tt;                             /* Table type                */
; 1233 : BYTE    tl;                             /* Table length              */
; 1234 : BYTE    tf;                             /* Table offset              */
; 1235 : U16     rfx, rsx, rtx;                  /* Region first/second/third
; 1236 :                                            index + 3 low-order zeros */
; 1237 : U16     sx, px;                         /* Segment and page index,
; 1238 :                                            + 3 low-order zero bits   */
; 1239 : 
; 1240 :     regs->dat.pvtaddr = regs->dat.protect = 0;
; 1241 : 
; 1242 :     /* Load the address space control element */
; 1243 :     if (ARCH_DEP(load_address_space_designator) (arn, regs, acctype))
; 1244 :         goto tran_alet_excp;
; 1245 : 
; 1246 :     /* Extract the private space bit from the ASCE */
; 1247 :     regs->dat.pvtaddr = ((regs->dat.asd & (ASCE_P|ASCE_R)) != 0);
; 1248 : 
; 1249 : //  LOGMSG("asce=%16.16"PRIX64"\n",regs->dat.asd);
; 1250 : 
; 1251 :     /* [3.11.4] Look up the address in the TLB */
; 1252 :     if (   ((vaddr & TLBID_PAGEMASK) | regs->tlbID) == regs->tlb.TLB_VADDR(tlbix)
; 1253 :         && (regs->tlb.common[tlbix] || regs->dat.asd == regs->tlb.TLB_ASD(tlbix))
; 1254 :         && !(regs->tlb.common[tlbix] && regs->dat.pvtaddr)
; 1255 :         && !(acctype & ACC_NOTLB) )
; 1256 :     {
; 1257 :         pte = regs->tlb.TLB_PTE(tlbix);
; 1258 :         if (regs->tlb.protect[tlbix])
; 1259 :             regs->dat.protect = regs->tlb.protect[tlbix];
; 1260 :     }
; 1261 :     else
; 1262 :     {
; 1263 :         /* If ASCE indicates a real-space then real addr = virtual addr */
; 1264 :         if (regs->dat.asd & ASCE_R)
; 1265 :         {
; 1266 : //      LOGMSG("asce type = real\n");
; 1267 : 
; 1268 :             /* Translation specification exception if LKPG for a real-space */
; 1269 :             if(acctype & ACC_PTE)
; 1270 :                 goto tran_spec_excp;
; 1271 : 
; 1272 :             /* Special operation exception if LPTEA for a real-space */
; 1273 :             if(acctype & ACC_LPTEA)
; 1274 :                 goto spec_oper_excp;
; 1275 : 
; 1276 :             /* Construct a fake page table entry for real = virtual */
; 1277 :             pte = vaddr & 0xFFFFFFFFFFFFF000ULL;
; 1278 :         }
; 1279 :         else
; 1280 :         {
; 1281 :             /* Extract the table origin, type, and length from the ASCE,
; 1282 :                and set the table offset to zero */
; 1283 :             rto = regs->dat.asd & ASCE_TO;
; 1284 :             tf = 0;
; 1285 :             tt = regs->dat.asd & ASCE_DT;
; 1286 :             tl = regs->dat.asd & ASCE_TL;
; 1287 : 
; 1288 :             /* Extract the 11-bit region first index, region second index,
; 1289 :                and region third index from the virtual address, and shift
; 1290 :                each index into bits 2-12 of a 16-bit integer, ready for
; 1291 :                addition to the appropriate region table origin */
; 1292 :             rfx = (vaddr >> 50) & 0x3FF8;
; 1293 :             rsx = (vaddr >> 39) & 0x3FF8;
; 1294 :             rtx = (vaddr >> 28) & 0x3FF8;
; 1295 : 
; 1296 :             /* Extract the 11-bit segment index from the virtual address,
; 1297 :                and shift it into bits 2-12 of a 16-bit integer, ready
; 1298 :                for addition to the segment table origin */
; 1299 :             sx = (vaddr >> 17) & 0x3FF8;
; 1300 : 
; 1301 :             /* Extract the 8-bit page index from the virtual address,
; 1302 :                and shift it into bits 2-12 of a 16-bit integer, ready
; 1303 :                for addition to the page table origin */
; 1304 :             px = (vaddr >> 9) & 0x07F8;
; 1305 : 
; 1306 :             /* ASCE-type exception if the virtual address is too large
; 1307 :                for the table type designated by the ASCE */
; 1308 :             if ((rfx != 0 && tt < TT_R1TABL)
; 1309 :                 || (rsx != 0 && tt < TT_R2TABL)
; 1310 :                 || (rtx != 0 && tt < TT_R3TABL))
; 1311 :                 goto asce_type_excp;
; 1312 : 
; 1313 :             /* Perform region translation */
; 1314 :             switch (tt) {
; 1315 : 
; 1316 :             /* Perform region-first translation */
; 1317 :             case TT_R1TABL:
; 1318 : 
; 1319 :                 /* Region-first translation exception if table length is
; 1320 :                    less than high-order 2 bits of region-first index */
; 1321 :                 if (tl < (rfx >> 12))
; 1322 :                     goto reg_first_excp;
; 1323 : 
; 1324 :                 /* Add the region-first index (with three low-order zeroes)
; 1325 :                    to the region-first table origin, giving the address of
; 1326 :                    the region-first table entry */
; 1327 :                 rto += rfx;
; 1328 : 
; 1329 :                 /* Addressing exception if outside main storage */
; 1330 :                 if (rto > regs->mainlim)
; 1331 :                     goto address_excp;
; 1332 : 
; 1333 :                 /* Fetch region-first table entry from absolute storage.
; 1334 :                    All bytes must be fetched concurrently as observed by
; 1335 :                    other CPUs */
; 1336 :                 rte = ARCH_DEP(fetch_doubleword_absolute) (rto, regs);
; 1337 : //              LOGMSG("r1te:%16.16"PRIX64"=>%16.16"PRIX64"\n",rto,rte);
; 1338 : 
; 1339 :                 /* Region-first translation exception if the bit 58 of
; 1340 :                    the region-first table entry is set (region invalid) */
; 1341 :                 if (rte & REGTAB_I)
; 1342 :                     goto reg_first_invalid;
; 1343 : 
; 1344 :                 /* Translation specification exception if bits 60-61 of
; 1345 :                    the region-first table entry do not indicate the
; 1346 :                    correct type of region table */
; 1347 :                 if ((rte & REGTAB_TT) != TT_R1TABL)
; 1348 :                     goto tran_spec_excp;
; 1349 : 
; 1350 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1351 :                 if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1352 :                  && (regs->CR_L(0) & CR0_ED)
; 1353 :                  && (rte & REGTAB_P))
; 1354 :                     regs->dat.protect |= 1;
; 1355 : #endif
; 1356 :                 /* Extract the region-second table origin, offset, and
; 1357 :                    length from the region-first table entry */
; 1358 :                 rto = rte & REGTAB_TO;
; 1359 :                 tf = (rte & REGTAB_TF) >> 6;
; 1360 :                 tl = rte & REGTAB_TL;
; 1361 : 
; 1362 :                 /* Fall through to perform region-second translation */
; 1363 :                 /* FALLTHRU */
; 1364 : 
; 1365 :             /* Perform region-second translation */
; 1366 :             case TT_R2TABL:
; 1367 : 
; 1368 :                 /* Region-second translation exception if table offset is
; 1369 :                    greater than high-order 2 bits of region-second index */
; 1370 :                 if (tf > (rsx >> 12))
; 1371 :                     goto reg_second_excp;
; 1372 : 
; 1373 :                 /* Region-second translation exception if table length is
; 1374 :                    less than high-order 2 bits of region-second index */
; 1375 :                 if (tl < (rsx >> 12))
; 1376 :                     goto reg_second_excp;
; 1377 : 
; 1378 :                 /* Add the region-second index (with three low-order zeroes)
; 1379 :                    to the region-second table origin, giving the address of
; 1380 :                    the region-second table entry */
; 1381 :                 rto += rsx;
; 1382 : 
; 1383 :                 /* Addressing exception if outside main storage */
; 1384 :                 if (rto > regs->mainlim)
; 1385 :                     goto address_excp;
; 1386 : 
; 1387 :                 /* Fetch region-second table entry from absolute storage.
; 1388 :                    All bytes must be fetched concurrently as observed by
; 1389 :                    other CPUs */
; 1390 :                 rte = ARCH_DEP(fetch_doubleword_absolute) (rto, regs);
; 1391 : //              LOGMSG("r2te:%16.16"PRIX64"=>%16.16"PRIX64"\n",rto,rte);
; 1392 : 
; 1393 :                 /* Region-second translation exception if the bit 58 of
; 1394 :                    the region-second table entry is set (region invalid) */
; 1395 :                 if (rte & REGTAB_I)
; 1396 :                     goto reg_second_invalid;
; 1397 : 
; 1398 :                 /* Translation specification exception if bits 60-61 of
; 1399 :                    the region-second table entry do not indicate the
; 1400 :                    correct type of region table */
; 1401 :                 if ((rte & REGTAB_TT) != TT_R2TABL)
; 1402 :                     goto tran_spec_excp;
; 1403 : 
; 1404 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1405 :                 if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1406 :                  && (regs->CR_L(0) & CR0_ED)
; 1407 :                  && (rte & REGTAB_P))
; 1408 :                     regs->dat.protect |= 1;
; 1409 : #endif
; 1410 :                 /* Extract the region-third table origin, offset, and
; 1411 :                    length from the region-second table entry */
; 1412 :                 rto = rte & REGTAB_TO;
; 1413 :                 tf = (rte & REGTAB_TF) >> 6;
; 1414 :                 tl = rte & REGTAB_TL;
; 1415 : 
; 1416 :                 /* Fall through to perform region-third translation */
; 1417 :                 /* FALLTHRU */
; 1418 : 
; 1419 :             /* Perform region-third translation */
; 1420 :             case TT_R3TABL:
; 1421 : 
; 1422 :                 /* Region-third translation exception if table offset is
; 1423 :                    greater than high-order 2 bits of region-third index */
; 1424 :                 if (tf > (rtx >> 12))
; 1425 :                     goto reg_third_excp;
; 1426 : 
; 1427 :                 /* Region-third translation exception if table length is
; 1428 :                    less than high-order 2 bits of region-third index */
; 1429 :                 if (tl < (rtx >> 12))
; 1430 :                     goto reg_third_excp;
; 1431 : 
; 1432 :                 /* Add the region-third index (with three low-order zeroes)
; 1433 :                    to the region-third table origin, giving the address of
; 1434 :                    the region-third table entry */
; 1435 :                 rto += rtx;
; 1436 : 
; 1437 :                 /* Addressing exception if outside main storage */
; 1438 :                 if (rto > regs->mainlim)
; 1439 :                     goto address_excp;
; 1440 : 
; 1441 :                 /* Fetch region-third table entry from absolute storage.
; 1442 :                    All bytes must be fetched concurrently as observed by
; 1443 :                    other CPUs */
; 1444 :                 rte = ARCH_DEP(fetch_doubleword_absolute) (rto, regs);
; 1445 : //              LOGMSG("r3te:%16.16"PRIX64"=>%16.16"PRIX64"\n",rto,rte);
; 1446 : 
; 1447 :                 /* Region-third translation exception if the bit 58 of
; 1448 :                    the region-third table entry is set (region invalid) */
; 1449 :                 if (rte & REGTAB_I)
; 1450 :                     goto reg_third_invalid;
; 1451 : 
; 1452 :                 /* Translation specification exception if bits 60-61 of
; 1453 :                    the region-third table entry do not indicate the
; 1454 :                    correct type of region table */
; 1455 :                 if ((rte & REGTAB_TT) != TT_R3TABL)
; 1456 :                     goto tran_spec_excp;
; 1457 : 
; 1458 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1459 :                 if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1460 :                  && (regs->CR_L(0) & CR0_ED)
; 1461 :                  && (rte & REGTAB_P))
; 1462 :                     regs->dat.protect |= 1;
; 1463 : #endif
; 1464 :                 /* Extract the segment table origin, offset, and
; 1465 :                    length from the region-third table entry */
; 1466 :                 sto = rte & REGTAB_TO;
; 1467 :                 tf = (rte & REGTAB_TF) >> 6;
; 1468 :                 tl = rte & REGTAB_TL;
; 1469 : 
; 1470 :                 /* Fall through to perform segment translation */
; 1471 :             } /* end switch(tt) */
; 1472 : 
; 1473 :             /* Perform ESAME segment translation */
; 1474 : 
; 1475 :             /* Add the segment index (with three low-order zeroes)
; 1476 :                to the segment table origin, giving the address of
; 1477 :                the segment table entry */
; 1478 :             sto += sx;
; 1479 : 
; 1480 :             /* Segment translation exception if table offset is
; 1481 :                greater than high-order 2 bits of segment index */
; 1482 :             if (tf > (sx >> 12))
; 1483 :                 goto seg_tran_length;
; 1484 : 
; 1485 :             /* Segment translation exception if table length is
; 1486 :                less than high-order 2 bits of segment index */
; 1487 :             if (tl < (sx >> 12))
; 1488 :                 goto seg_tran_length;
; 1489 : 
; 1490 :             /* Addressing exception if outside real storage */
; 1491 :             if (sto > regs->mainlim)
; 1492 :                 goto address_excp;
; 1493 : 
; 1494 :             /* Fetch segment table entry from absolute storage.  All bytes
; 1495 :                must be fetched concurrently as observed by other CPUs */
; 1496 :             ste = ARCH_DEP(fetch_doubleword_absolute) (sto, regs);
; 1497 : //          LOGMSG("ste:%16.16"PRIX64"=>%16.16"PRIX64"\n",sto,ste);
; 1498 : 
; 1499 :             /* Segment translation exception if segment invalid */
; 1500 :             if (ste & ZSEGTAB_I)
; 1501 :                 goto seg_tran_invalid;
; 1502 : 
; 1503 :             /* Translation specification exception if bits 60-61 of
; 1504 :                the segment table entry do not indicate segment table */
; 1505 :             if ((ste & ZSEGTAB_TT) != TT_SEGTAB)
; 1506 :                 goto tran_spec_excp;
; 1507 : 
; 1508 :             /* Translation specification exception if the ASCE
; 1509 :                indicates a private space, and the segment table
; 1510 :                entry indicates a common segment */
; 1511 :             if (regs->dat.pvtaddr && (ste & ZSEGTAB_C))
; 1512 :                 goto tran_spec_excp;
; 1513 : 
; 1514 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1515 :             if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1516 :               && (regs->CR_L(0) & CR0_ED)
; 1517 :               && (ste & ZSEGTAB_FC))
; 1518 :             {
; 1519 :                 /* Set protection indicator if page protection is indicated */
; 1520 :                 if (ste & ZSEGTAB_P)
; 1521 :                     regs->dat.protect |= 1;
; 1522 : 
; 1523 :                 /* For LPTEA instruction, return the address of the STE */
; 1524 :                 if (unlikely(acctype & ACC_LPTEA))
; 1525 :                 {
; 1526 :                     regs->dat.raddr = sto | (regs->dat.protect ? 0x04 : 0);
; 1527 : //                  LOGMSG("raddr:%16.16"PRIX64" cc=2\n",regs->dat.raddr);
; 1528 :                     regs->dat.xcode = 0;
; 1529 :                     cc = 2;
; 1530 :                     return cc;
; 1531 :                 } /* end if(ACCTYPE_LPTEA) */
; 1532 : 
; 1533 :                 /* Combine the page frame real address with the byte index
; 1534 :                    of the virtual address to form the real address */
; 1535 :                 regs->dat.raddr = (ste & ZSEGTAB_SFAA) | (vaddr & ~ZSEGTAB_SFAA);
; 1536 :                 /* Fake 4K PFRA for TLB purposes */
; 1537 :                 regs->dat.rpfra = ((ste & ZSEGTAB_SFAA) | (vaddr & ~ZSEGTAB_SFAA)) & PAGEFRAME_PAGEMASK;
; 1538 : 
; 1539 : //              LOGMSG("raddr:%16.16"PRIX64" cc=0\n",regs->dat.raddr);
; 1540 : 
; 1541 :                 /* [3.11.4.2] Place the translated address in the TLB */
; 1542 :                 if (!(acctype & ACC_NOTLB))
; 1543 :                 {
; 1544 :                     regs->tlb.TLB_ASD(tlbix)   = regs->dat.asd;
; 1545 :                     regs->tlb.TLB_VADDR(tlbix) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;
; 1546 :                     /* Fake 4K PTE for TLB purposes */
; 1547 :                     regs->tlb.TLB_PTE(tlbix)   = ((ste & ZSEGTAB_SFAA) | (vaddr & ~ZSEGTAB_SFAA)) & PAGEFRAME_PAGEMASK;
; 1548 :                     regs->tlb.common[tlbix]    = (ste & SEGTAB_COMMON) ? 1 : 0;
; 1549 :                     regs->tlb.protect[tlbix]   = regs->dat.protect;
; 1550 :                     regs->tlb.acc[tlbix]       = 0;
; 1551 :                     regs->tlb.main[tlbix]      = NULL;
; 1552 :                 }
; 1553 : 
; 1554 :                 /* Clear exception code and return with zero return code */
; 1555 :                 regs->dat.xcode = 0;
; 1556 :                 return 0;
; 1557 : 
; 1558 :             }
; 1559 : #endif /* defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 ) */
; 1560 : 
; 1561 :             /* Extract the page table origin from segment table entry */
; 1562 :             pto = ste & ZSEGTAB_PTO;
; 1563 : 
; 1564 :             /* Perform ESAME page translation */
; 1565 : 
; 1566 :             /* Add the page index (with three low-order zeroes) to the
; 1567 :                page table origin, giving address of page table entry */
; 1568 :             pto += px;
; 1569 : 
; 1570 :             /* For LPTEA instruction, return the address of the PTE */
; 1571 :             if (acctype & ACC_LPTEA)
; 1572 :             {
; 1573 :                 regs->dat.raddr = pto;
; 1574 :                 regs->dat.xcode = 0;
; 1575 :                 cc = (ste & ZSEGTAB_P) ? 1 : 0;
; 1576 : #if defined( FEATURE_008_ENHANCED_DAT_FACILITY_1 )
; 1577 :                 if (FACILITY_ENABLED( 008_EDAT_1, regs )
; 1578 :                   && (regs->CR_L(0) & CR0_ED)
; 1579 :                   && regs->dat.protect)
; 1580 :                     cc = 1;
; 1581 : #endif
; 1582 :                 return cc;
; 1583 :             } /* end if(ACCTYPE_LPTEA) */
; 1584 : 
; 1585 :             /* Addressing exception if outside real storage */
; 1586 :             if (pto > regs->mainlim)
; 1587 :                 goto address_excp;
; 1588 : 
; 1589 :             /* Fetch the page table entry from absolute storage.  All bytes
; 1590 :                must be fetched concurrently as observed by other CPUs */
; 1591 :             pte = ARCH_DEP(fetch_doubleword_absolute) (pto, regs);
; 1592 : //          LOGMSG("pte:%16.16"PRIX64"=>%16.16"PRIX64"\n",pto,pte);
; 1593 : 
; 1594 :             /* Page translation exception if page invalid */
; 1595 :             if (pte & ZPGETAB_I)
; 1596 :                 goto page_tran_invalid;
; 1597 : 
; 1598 :             /* Check that all the reserved bits in the PTE are zero */
; 1599 :             if (pte & ZPGETAB_RESV)
; 1600 :                 goto tran_spec_excp;
; 1601 : 
; 1602 :         } /* end else(ASCE_R) */
; 1603 : 
; 1604 :         /* Set protection indicator if page protection is indicated
; 1605 :            in either the segment table or the page table */
; 1606 :         if ((ste & ZSEGTAB_P) || (pte & ZPGETAB_P))
; 1607 :             regs->dat.protect |= 1;
; 1608 : 
; 1609 :         /* [3.11.4.2] Place the translated address in the TLB */
; 1610 :         if (!(acctype & ACC_NOTLB))
; 1611 :         {
; 1612 :             regs->tlb.TLB_ASD(tlbix)   = regs->dat.asd;
; 1613 :             regs->tlb.TLB_VADDR(tlbix) = (vaddr & TLBID_PAGEMASK) | regs->tlbID;
; 1614 :             regs->tlb.TLB_PTE(tlbix)   = pte;
; 1615 :             regs->tlb.common[tlbix]    = (ste & SEGTAB_COMMON) ? 1 : 0;
; 1616 :             regs->tlb.protect[tlbix]   = regs->dat.protect;
; 1617 :             regs->tlb.acc[tlbix]       = 0;
; 1618 :             regs->tlb.main[tlbix]      = NULL;
; 1619 :         }
; 1620 :     }
; 1621 : 
; 1622 :     if(!(acctype & ACC_PTE))
; 1623 :     {
; 1624 :         /* Combine the page frame real address with the byte index
; 1625 :            of the virtual address to form the real address */
; 1626 :         regs->dat.raddr = (pte & ZPGETAB_PFRA) | (vaddr & 0xFFF);
; 1627 :         regs->dat.rpfra = (pte & ZPGETAB_PFRA);
; 1628 :     }
; 1629 :     else
; 1630 :         regs->dat.raddr = pto;
; 1631 : #endif /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1632 : 
; 1633 :     /*-----------------------------------------------------------*/
; 1634 :     /* The following code is common to S/370, ESA/390, and ESAME */
; 1635 :     /*-----------------------------------------------------------*/
; 1636 : 
; 1637 :     /* Clear exception code and return with zero return code */
; 1638 :     regs->dat.xcode = 0;

  009d4	33 c0		 xor	 eax, eax
  009d6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009de	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1639 :     return 0;

  009e5	33 c0		 xor	 eax, eax
  009e7	e9 fa 03 00 00	 jmp	 $LN1@s370_trans
$address_excp$67:

; 1640 : 
; 1641 : /* Conditions which always cause program check, except
; 1642 :    when performing translation for the control panel */
; 1643 : address_excp:
; 1644 : //    LOGMSG("dat.c: addressing exception: %8.8X %8.8X %4.4X %8.8X\n",
; 1645 : //        regs->CR(0),regs->dat.asd,pte,vaddr);
; 1646 :     regs->dat.xcode = PGM_ADDRESSING_EXCEPTION;

  009ec	b8 05 00 00 00	 mov	 eax, 5
  009f1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009f9	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1647 :     goto tran_prog_check;

  00a00	eb 14		 jmp	 SHORT $tran_prog_check$71
$tran_spec_excp$65:

; 1648 : 
; 1649 : tran_spec_excp:
; 1650 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1651 : //    LOGMSG("dat.c: translation specification exception...\n");
; 1652 : //    LOGMSG("       pte = %16.16"PRIX64", ste = %16.16"PRIX64", rte=%16.16"PRIX64"\n",
; 1653 : //        pte, ste, rte);
; 1654 : #else
; 1655 : //    LOGMSG("dat.c: translation specification exception...\n");
; 1656 : //    LOGMSG("       cr0=%8.8X ste=%8.8X pte=%4.4X vaddr=%8.8X\n",
; 1657 : //        regs->CR(0),ste,pte,vaddr);
; 1658 : #endif
; 1659 :     regs->dat.xcode = PGM_TRANSLATION_SPECIFICATION_EXCEPTION;

  00a02	b8 12 00 00 00	 mov	 eax, 18
  00a07	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a0f	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax
$tran_prog_check$71:

; 1660 :     goto tran_prog_check;
; 1661 : 
; 1662 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1663 : spec_oper_excp:
; 1664 :     regs->dat.xcode = PGM_SPECIAL_OPERATION_EXCEPTION;
; 1665 :     goto tran_prog_check;
; 1666 : #endif
; 1667 : 
; 1668 : tran_prog_check:
; 1669 : #if defined( FEATURE_036_ENH_MONITOR_FACILITY )
; 1670 :     if (FACILITY_ENABLED( 036_ENH_MONITOR, regs ))
; 1671 :     {
; 1672 :         /* No program interrupt for enhanced MC */
; 1673 :         if (acctype & ACC_ENH_MC)
; 1674 :         {
; 1675 :             cc = 5;
; 1676 :             return cc;
; 1677 :         }
; 1678 :     }
; 1679 : #endif
; 1680 :     regs->program_interrupt( regs, regs->dat.xcode );

  00a16	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a1e	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00a25	8b d0		 mov	 edx, eax
  00a27	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a2f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a37	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$seg_tran_invalid$68:

; 1681 : 
; 1682 : /* Conditions which the caller may or may not program check */
; 1683 : seg_tran_invalid:
; 1684 :     /* For LPTEA, return segment table entry address with cc 2 */
; 1685 :     if (acctype & ACC_LPTEA)

  00a3d	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00a44	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00a49	85 c0		 test	 eax, eax
  00a4b	74 25		 je	 SHORT $LN26@s370_trans

; 1686 :     {
; 1687 :         regs->dat.raddr = sto;

  00a4d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a55	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  00a5a	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1688 :         cc = 2;

  00a61	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1689 :         return cc;

  00a69	8b 44 24 28	 mov	 eax, DWORD PTR cc$[rsp]
  00a6d	e9 74 03 00 00	 jmp	 $LN1@s370_trans
$LN26@s370_trans:

; 1690 :     } /* end if(ACCTYPE_LPTEA) */
; 1691 : 
; 1692 :     /* Otherwise set translation exception code */
; 1693 :     regs->dat.xcode = PGM_SEGMENT_TRANSLATION_EXCEPTION;

  00a72	b8 10 00 00 00	 mov	 eax, 16
  00a77	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a7f	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1694 :     regs->dat.raddr = sto;

  00a86	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a8e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  00a93	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1695 :     cc = 1;

  00a9a	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR cc$[rsp], 1

; 1696 :     goto tran_excp_addr;

  00aa2	e9 f9 00 00 00	 jmp	 $tran_excp_addr$72
$page_tran_invalid$70:

; 1697 : 
; 1698 : page_tran_invalid:
; 1699 :     regs->dat.xcode = PGM_PAGE_TRANSLATION_EXCEPTION;

  00aa7	b8 11 00 00 00	 mov	 eax, 17
  00aac	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ab4	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1700 :     regs->dat.raddr = pto;

  00abb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ac3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pto$[rsp]
  00ac8	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1701 :     if(acctype & ACC_PTE) return 0;

  00acf	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00ad6	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00adb	85 c0		 test	 eax, eax
  00add	74 07		 je	 SHORT $LN27@s370_trans
  00adf	33 c0		 xor	 eax, eax
  00ae1	e9 00 03 00 00	 jmp	 $LN1@s370_trans
$LN27@s370_trans:

; 1702 :     cc = 2;

  00ae6	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR cc$[rsp], 2

; 1703 :     goto tran_excp_addr;

  00aee	e9 ad 00 00 00	 jmp	 $tran_excp_addr$72
$page_tran_length$69:

; 1704 : 
; 1705 : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1706 : page_tran_length:
; 1707 :     regs->dat.xcode = PGM_PAGE_TRANSLATION_EXCEPTION;

  00af3	b8 11 00 00 00	 mov	 eax, 17
  00af8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b00	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1708 :     regs->dat.raddr = pto;

  00b07	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b0f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pto$[rsp]
  00b14	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1709 :     cc = 3;

  00b1b	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3

; 1710 :     goto tran_excp_addr;

  00b23	eb 7b		 jmp	 SHORT $tran_excp_addr$72
$seg_tran_length$66:

; 1711 : #endif
; 1712 : 
; 1713 : seg_tran_length:
; 1714 : //  LOGMSG("dat.c: segment translation exception due to segment length\n");
; 1715 : //  LOGMSG("       cr0=" F_RADR " sto=" F_RADR "\n",regs->CR(0),sto);
; 1716 :     regs->dat.xcode = PGM_SEGMENT_TRANSLATION_EXCEPTION;

  00b25	b8 10 00 00 00	 mov	 eax, 16
  00b2a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b32	66 89 81 30 08
	00 00		 mov	 WORD PTR [rcx+2096], ax

; 1717 :     regs->dat.raddr = sto;

  00b39	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b41	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sto$[rsp]
  00b46	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 1718 :     cc = 3;

  00b4d	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR cc$[rsp], 3

; 1719 :     goto tran_excp_addr;

  00b55	eb 49		 jmp	 SHORT $tran_excp_addr$72
$tran_alet_excp$64:

; 1720 : 
; 1721 : tran_alet_excp:
; 1722 :     regs->excarid = arn;

  00b57	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b5f	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR arn$[rsp]
  00b67	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl

; 1723 :     cc = (acctype & ACC_LPTEA) ? 3 : 4;

  00b6d	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00b74	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00b79	85 c0		 test	 eax, eax
  00b7b	74 0a		 je	 SHORT $LN59@s370_trans
  00b7d	c7 44 24 64 03
	00 00 00	 mov	 DWORD PTR tv508[rsp], 3
  00b85	eb 08		 jmp	 SHORT $LN60@s370_trans
$LN59@s370_trans:
  00b87	c7 44 24 64 04
	00 00 00	 mov	 DWORD PTR tv508[rsp], 4
$LN60@s370_trans:
  00b8f	8b 44 24 64	 mov	 eax, DWORD PTR tv508[rsp]
  00b93	89 44 24 28	 mov	 DWORD PTR cc$[rsp], eax

; 1724 :     return cc;

  00b97	8b 44 24 28	 mov	 eax, DWORD PTR cc$[rsp]
  00b9b	e9 46 02 00 00	 jmp	 $LN1@s370_trans
$tran_excp_addr$72:

; 1725 : 
; 1726 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1727 : reg_first_invalid:
; 1728 :     /* For LPTEA, return region table entry address with cc 2 */
; 1729 :     if (acctype & ACC_LPTEA)
; 1730 :     {
; 1731 :         regs->dat.raddr = rto | (TT_R1TABL >> 2);
; 1732 :         cc = 2;
; 1733 :         return cc;
; 1734 :     } /* end if(ACCTYPE_LPTEA) */
; 1735 : 
; 1736 :     /* Otherwise set translation exception code */
; 1737 :     goto reg_first_excp;
; 1738 : 
; 1739 : reg_second_invalid:
; 1740 :     /* For LPTEA, return region table entry address with cc 2 */
; 1741 :     if (acctype & ACC_LPTEA)
; 1742 :     {
; 1743 :         regs->dat.raddr = rto | (TT_R2TABL >> 2);
; 1744 :         cc = 2;
; 1745 :         return cc;
; 1746 :     } /* end if(ACCTYPE_LPTEA) */
; 1747 : 
; 1748 :     /* Otherwise set translation exception code */
; 1749 :     goto reg_second_excp;
; 1750 : 
; 1751 : reg_third_invalid:
; 1752 :     /* For LPTEA, return region table entry address with cc 2 */
; 1753 :     if (acctype & ACC_LPTEA)
; 1754 :     {
; 1755 :         regs->dat.raddr = rto | (TT_R3TABL >> 2);
; 1756 :         cc = 2;
; 1757 :         return cc;
; 1758 :     } /* end if(ACCTYPE_LPTEA) */
; 1759 : 
; 1760 :     /* Otherwise set translation exception code */
; 1761 :     goto reg_third_excp;
; 1762 : 
; 1763 : asce_type_excp:
; 1764 : //  LOGMSG("rfx = %4.4X, rsx %4.4X, rtx = %4.4X, tt = %1.1X\n",
; 1765 : //      rfx, rsx, rtx, tt);
; 1766 :     regs->dat.xcode = PGM_ASCE_TYPE_EXCEPTION;
; 1767 :     cc = 4;
; 1768 :     goto tran_excp_addr;
; 1769 : 
; 1770 : reg_first_excp:
; 1771 :     regs->dat.xcode = PGM_REGION_FIRST_TRANSLATION_EXCEPTION;
; 1772 :     cc = 4;
; 1773 :     goto tran_excp_addr;
; 1774 : 
; 1775 : reg_second_excp:
; 1776 :     regs->dat.xcode = PGM_REGION_SECOND_TRANSLATION_EXCEPTION;
; 1777 :     cc = 4;
; 1778 :     goto tran_excp_addr;
; 1779 : 
; 1780 : reg_third_excp:
; 1781 :     regs->dat.xcode = PGM_REGION_THIRD_TRANSLATION_EXCEPTION;
; 1782 :     cc = 4;
; 1783 :     goto tran_excp_addr;
; 1784 : #endif /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1785 : 
; 1786 : tran_excp_addr:
; 1787 :     /* For LPTEA instruction, return xcode with cc = 3 */
; 1788 :     if (acctype & ACC_LPTEA)

  00ba0	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00ba7	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00bac	85 c0		 test	 eax, eax
  00bae	74 0a		 je	 SHORT $LN28@s370_trans

; 1789 :         return 3;

  00bb0	b8 03 00 00 00	 mov	 eax, 3
  00bb5	e9 2c 02 00 00	 jmp	 $LN1@s370_trans
$LN28@s370_trans:

; 1790 : 
; 1791 :     /* Set the translation exception address */
; 1792 :     regs->TEA = vaddr & PAGEFRAME_PAGEMASK;

  00bba	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR vaddr$[rsp]
  00bc1	25 00 f8 ff 7f	 and	 eax, 2147481600		; 7ffff800H
  00bc6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bce	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 1793 : 
; 1794 :     /* Set the address space indication in the exception address */
; 1795 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1796 :     if(regs->dat.stid == TEA_ST_ARMODE)
; 1797 :     {
; 1798 :         if ((regs->dat.asd & ASCE_TO) == (regs->CR(1) & ASCE_TO))
; 1799 :             regs->TEA |= TEA_ST_PRIMARY;
; 1800 :         else if ((regs->dat.asd & ASCE_TO) == (regs->CR(7) & ASCE_TO))
; 1801 :             regs->TEA |= TEA_ST_SECNDRY;
; 1802 :         else if ((regs->dat.asd & ASCE_TO) == (regs->CR(13) & ASCE_TO))
; 1803 :             regs->TEA |= TEA_ST_HOME;
; 1804 :         else
; 1805 :             regs->TEA |= TEA_ST_ARMODE;
; 1806 :     }
; 1807 :     else
; 1808 :         regs->TEA |= regs->dat.stid;
; 1809 : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1810 :     if(regs->dat.stid == TEA_ST_ARMODE)

  00bd4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bdc	83 b8 20 08 00
	00 01		 cmp	 DWORD PTR [rax+2080], 1
  00be3	0f 85 2d 01 00
	00		 jne	 $LN29@s370_trans

; 1811 :     {
; 1812 :         if ((regs->dat.asd & STD_STO) == (regs->CR(1) & STD_STO))

  00be9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bf1	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00bf8	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  00bfe	b9 08 00 00 00	 mov	 ecx, 8
  00c03	48 6b c9 02	 imul	 rcx, rcx, 2
  00c07	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c0f	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00c16	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00c1c	8b c9		 mov	 ecx, ecx
  00c1e	48 3b c1	 cmp	 rax, rcx
  00c21	75 19		 jne	 SHORT $LN31@s370_trans

; 1813 :             regs->TEA |= TEA_ST_PRIMARY;

  00c23	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c2b	8b 88 18 07 00
	00		 mov	 ecx, DWORD PTR [rax+1816]
  00c31	89 88 18 07 00
	00		 mov	 DWORD PTR [rax+1816], ecx
  00c37	e9 d5 00 00 00	 jmp	 $LN32@s370_trans
$LN31@s370_trans:

; 1814 :         else if ((regs->dat.asd & STD_STO) == (regs->CR(7) & STD_STO))

  00c3c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c44	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00c4b	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  00c51	b9 08 00 00 00	 mov	 ecx, 8
  00c56	48 6b c9 08	 imul	 rcx, rcx, 8
  00c5a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c62	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00c69	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00c6f	8b c9		 mov	 ecx, ecx
  00c71	48 3b c1	 cmp	 rax, rcx
  00c74	75 21		 jne	 SHORT $LN33@s370_trans

; 1815 :             regs->TEA |= TEA_ST_SECNDRY;

  00c76	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c7e	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00c84	83 c8 02	 or	 eax, 2
  00c87	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c8f	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax
  00c95	eb 7a		 jmp	 SHORT $LN34@s370_trans
$LN33@s370_trans:

; 1816 :         else if ((regs->dat.asd & STD_STO) == (regs->CR(13) & STD_STO))

  00c97	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c9f	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00ca6	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  00cac	b9 08 00 00 00	 mov	 ecx, 8
  00cb1	48 6b c9 0e	 imul	 rcx, rcx, 14
  00cb5	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00cbd	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00cc4	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00cca	8b c9		 mov	 ecx, ecx
  00ccc	48 3b c1	 cmp	 rax, rcx
  00ccf	75 21		 jne	 SHORT $LN35@s370_trans

; 1817 :             regs->TEA |= TEA_ST_HOME;

  00cd1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cd9	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00cdf	83 c8 03	 or	 eax, 3
  00ce2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cea	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax
  00cf0	eb 1f		 jmp	 SHORT $LN36@s370_trans
$LN35@s370_trans:

; 1818 :         else
; 1819 :             regs->TEA |= TEA_ST_ARMODE;

  00cf2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cfa	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00d00	83 c8 01	 or	 eax, 1
  00d03	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d0b	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax
$LN36@s370_trans:
$LN34@s370_trans:
$LN32@s370_trans:

; 1820 :     }

  00d11	e9 83 00 00 00	 jmp	 $LN30@s370_trans
$LN29@s370_trans:

; 1821 :     else
; 1822 :         if((regs->dat.stid == TEA_ST_SECNDRY)
; 1823 :           && (PRIMARY_SPACE_MODE(&regs->psw)

  00d16	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d1e	83 b8 20 08 00
	00 02		 cmp	 DWORD PTR [rax+2080], 2
  00d25	75 46		 jne	 SHORT $LN37@s370_trans
  00d27	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d2f	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00d33	85 c0		 test	 eax, eax
  00d35	74 13		 je	 SHORT $LN39@s370_trans
  00d37	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d3f	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00d43	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00d48	75 23		 jne	 SHORT $LN37@s370_trans
$LN39@s370_trans:

; 1824 :             || SECONDARY_SPACE_MODE(&regs->psw)))
; 1825 :             regs->TEA |= TEA_ST_SECNDRY | TEA_SECADDR;

  00d4a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d52	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00d58	0d 02 00 00 80	 or	 eax, -2147483646	; 80000002H
  00d5d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d65	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax
  00d6b	eb 2c		 jmp	 SHORT $LN38@s370_trans
$LN37@s370_trans:

; 1826 :         else
; 1827 :             regs->TEA |= regs->dat.stid;

  00d6d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d75	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d7d	8b 89 20 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2080]
  00d83	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00d89	0b c1		 or	 eax, ecx
  00d8b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d93	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax
$LN38@s370_trans:
$LN30@s370_trans:

; 1828 : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1829 : 
; 1830 : #if defined( FEATURE_075_ACC_EX_FS_INDIC_FACILITY )
; 1831 :     if (FACILITY_ENABLED( 075_ACC_EX_FS_INDIC, regs ))
; 1832 :     {
; 1833 :         /* Set the fetch/store indication bits 52-53 in the TEA */
; 1834 :         if (acctype & ACC_READ)
; 1835 :         {
; 1836 :             regs->TEA |= TEA_FETCH;
; 1837 :         }
; 1838 :         else if (acctype & (ACC_WRITE | ACC_CHECK))
; 1839 :         {
; 1840 :             regs->TEA |= TEA_STORE;
; 1841 :         }
; 1842 :     }
; 1843 : #endif
; 1844 :     /* Set the exception access identification */
; 1845 :     if (ACCESS_REGISTER_MODE(&regs->psw)
; 1846 :      || (SIE_ACTIVE(regs) && MULTIPLE_CONTROLLED_DATA_SPACE(GUESTREGS))

  00d99	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00da1	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00da5	83 f8 40	 cmp	 eax, 64			; 00000040H
  00da8	74 06		 je	 SHORT $LN41@s370_trans
  00daa	33 c0		 xor	 eax, eax
  00dac	85 c0		 test	 eax, eax
  00dae	74 32		 je	 SHORT $LN40@s370_trans
$LN41@s370_trans:

; 1847 :        )
; 1848 :        regs->excarid = arn < 0 ? 0 : arn;

  00db0	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  00db8	7d 0a		 jge	 SHORT $LN61@s370_trans
  00dba	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv574[rsp], 0
  00dc2	eb 0b		 jmp	 SHORT $LN62@s370_trans
$LN61@s370_trans:
  00dc4	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00dcb	89 44 24 68	 mov	 DWORD PTR tv574[rsp], eax
$LN62@s370_trans:
  00dcf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dd7	0f b6 4c 24 68	 movzx	 ecx, BYTE PTR tv574[rsp]
  00ddc	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl
$LN40@s370_trans:

; 1849 : 
; 1850 :     /* Return condition code */
; 1851 :     return cc;

  00de2	8b 44 24 28	 mov	 eax, DWORD PTR cc$[rsp]
$LN1@s370_trans:

; 1852 : 
; 1853 : } /* end function translate_addr */

  00de6	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00ded	c3		 ret	 0
s370_translate_addr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
aste_addr$ = 32
afte_addr$ = 36
i$ = 40
code$ = 44
afte$ = 48
tv87 = 52
tv156 = 56
numwords$ = 60
aste_main$ = 64
asn$ = 96
regs$ = 104
asteo$ = 112
aste$ = 120
s370_translate_asn PROC

; 281  : {

$LN24:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 282  : U32     afte_addr;                      /* Address of AFTE           */
; 283  : U32     afte;                           /* ASN first table entry     */
; 284  : U32     aste_addr;                      /* Address of ASTE           */
; 285  : BYTE   *aste_main;                      /* ASTE mainstor address     */
; 286  : int     code;                           /* Exception code            */
; 287  : int     numwords;                       /* ASTE size (4 or 16 words) */
; 288  : int     i;                              /* Array subscript           */
; 289  : 
; 290  :     /* [3.9.3.1] Use the AFX to obtain the real address of the AFTE */
; 291  :     afte_addr = (regs->CR(14) & CR14_AFTO) << 12;

  00018	b8 08 00 00 00	 mov	 eax, 8
  0001d	48 6b c0 0f	 imul	 rax, rax, 15
  00021	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00026	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0002d	25 ff ff 07 00	 and	 eax, 524287		; 0007ffffH
  00032	c1 e0 0c	 shl	 eax, 12
  00035	89 44 24 24	 mov	 DWORD PTR afte_addr$[rsp], eax

; 292  :     afte_addr += (asn & ASN_AFX) >> 4;

  00039	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  0003e	25 c0 ff 00 00	 and	 eax, 65472		; 0000ffc0H
  00043	c1 f8 04	 sar	 eax, 4
  00046	8b 4c 24 24	 mov	 ecx, DWORD PTR afte_addr$[rsp]
  0004a	03 c8		 add	 ecx, eax
  0004c	8b c1		 mov	 eax, ecx
  0004e	89 44 24 24	 mov	 DWORD PTR afte_addr$[rsp], eax

; 293  : 
; 294  :     /* Addressing exception if AFTE is outside main storage */
; 295  :     if (afte_addr > regs->mainlim)

  00052	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  00056	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  00062	76 05		 jbe	 SHORT $LN7@s370_trans

; 296  :         goto asn_addr_excp;

  00064	e9 68 02 00 00	 jmp	 $asn_addr_excp$25
$LN7@s370_trans:

; 297  : 
; 298  :     /* Load the AFTE from main storage. All four bytes must be
; 299  :        fetched concurrently as observed by other CPUs */
; 300  :     afte_addr = APPLY_PREFIXING (afte_addr, regs->PX);

  00069	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  0006d	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00073	48 85 c0	 test	 rax, rax
  00076	74 21		 je	 SHORT $LN20@s370_trans
  00078	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  0007c	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00082	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0008a	48 3b c1	 cmp	 rax, rcx
  0008d	74 0a		 je	 SHORT $LN20@s370_trans
  0008f	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  00093	89 44 24 34	 mov	 DWORD PTR tv87[rsp], eax
  00097	eb 14		 jmp	 SHORT $LN21@s370_trans
$LN20@s370_trans:
  00099	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000a1	8b 4c 24 24	 mov	 ecx, DWORD PTR afte_addr$[rsp]
  000a5	33 c8		 xor	 ecx, eax
  000a7	8b c1		 mov	 eax, ecx
  000a9	89 44 24 34	 mov	 DWORD PTR tv87[rsp], eax
$LN21@s370_trans:
  000ad	8b 44 24 34	 mov	 eax, DWORD PTR tv87[rsp]
  000b1	89 44 24 24	 mov	 DWORD PTR afte_addr$[rsp], eax

; 301  :     afte = ARCH_DEP(fetch_fullword_absolute) (afte_addr, regs);

  000b5	8b 44 24 24	 mov	 eax, DWORD PTR afte_addr$[rsp]
  000b9	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  000be	8b c8		 mov	 ecx, eax
  000c0	e8 00 00 00 00	 call	 s370_fetch_fullword_absolute
  000c5	89 44 24 30	 mov	 DWORD PTR afte$[rsp], eax

; 302  : 
; 303  :     /* AFX translation exception if AFTE invalid bit is set */
; 304  :     if (afte & AFTE_INVALID)

  000c9	8b 44 24 30	 mov	 eax, DWORD PTR afte$[rsp]
  000cd	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  000d2	85 c0		 test	 eax, eax
  000d4	74 05		 je	 SHORT $LN8@s370_trans

; 305  :         goto asn_afx_tran_excp;

  000d6	e9 1c 02 00 00	 jmp	 $asn_afx_tran_excp$26
$LN8@s370_trans:

; 306  : 
; 307  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 308  :     /* ASN translation specification exception if reserved bits set */
; 309  :     if (!ASF_ENABLED(regs)) {

  000db	33 c0		 xor	 eax, eax
  000dd	83 f8 01	 cmp	 eax, 1
  000e0	74 12		 je	 SHORT $LN9@s370_trans

; 310  :         if (afte & AFTE_RESV_0)

  000e2	8b 44 24 30	 mov	 eax, DWORD PTR afte$[rsp]
  000e6	83 e0 0f	 and	 eax, 15
  000e9	85 c0		 test	 eax, eax
  000eb	74 05		 je	 SHORT $LN11@s370_trans

; 311  :               goto asn_asn_tran_spec_excp;

  000ed	e9 e9 01 00 00	 jmp	 $asn_asn_tran_spec_excp$27
$LN11@s370_trans:

; 312  :     } else {

  000f2	eb 10		 jmp	 SHORT $LN10@s370_trans
$LN9@s370_trans:

; 313  :         if (afte & AFTE_RESV_1)

  000f4	8b 44 24 30	 mov	 eax, DWORD PTR afte$[rsp]
  000f8	83 e0 3f	 and	 eax, 63			; 0000003fH
  000fb	85 c0		 test	 eax, eax
  000fd	74 05		 je	 SHORT $LN12@s370_trans

; 314  :               goto asn_asn_tran_spec_excp;

  000ff	e9 d7 01 00 00	 jmp	 $asn_asn_tran_spec_excp$27
$LN12@s370_trans:
$LN10@s370_trans:

; 315  :     }
; 316  : #endif
; 317  : 
; 318  :     /* [3.9.3.2] Use AFTE and ASX to obtain real address of ASTE */
; 319  :     if (!ASF_ENABLED(regs)) {

  00104	33 c0		 xor	 eax, eax
  00106	83 f8 01	 cmp	 eax, 1
  00109	74 2e		 je	 SHORT $LN13@s370_trans

; 320  :         aste_addr = afte & AFTE_ASTO_0;

  0010b	8b 44 24 30	 mov	 eax, DWORD PTR afte$[rsp]
  0010f	25 f0 ff ff 7f	 and	 eax, 2147483632		; 7ffffff0H
  00114	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 321  :         aste_addr += (asn & ASN_ASX) << 4;

  00118	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  0011d	83 e0 3f	 and	 eax, 63			; 0000003fH
  00120	c1 e0 04	 shl	 eax, 4
  00123	8b 4c 24 20	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  00127	03 c8		 add	 ecx, eax
  00129	8b c1		 mov	 eax, ecx
  0012b	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 322  :         numwords = 4;

  0012f	c7 44 24 3c 04
	00 00 00	 mov	 DWORD PTR numwords$[rsp], 4

; 323  :     } else {

  00137	eb 2c		 jmp	 SHORT $LN14@s370_trans
$LN13@s370_trans:

; 324  :         aste_addr = afte & AFTE_ASTO_1;

  00139	8b 44 24 30	 mov	 eax, DWORD PTR afte$[rsp]
  0013d	25 c0 ff ff 7f	 and	 eax, 2147483584		; 7fffffc0H
  00142	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 325  :         aste_addr += (asn & ASN_ASX) << 6;

  00146	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  0014b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0014e	c1 e0 06	 shl	 eax, 6
  00151	8b 4c 24 20	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  00155	03 c8		 add	 ecx, eax
  00157	8b c1		 mov	 eax, ecx
  00159	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 326  :         numwords = 16;

  0015d	c7 44 24 3c 10
	00 00 00	 mov	 DWORD PTR numwords$[rsp], 16
$LN14@s370_trans:

; 327  :     }
; 328  : 
; 329  :     /* Ignore carry into bit position 0 of ASTO */
; 330  :     aste_addr &= 0x7FFFFFFF;

  00165	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  00169	0f ba f0 1f	 btr	 eax, 31
  0016d	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 331  : 
; 332  :     /* Addressing exception if ASTE is outside main storage */
; 333  :     if (aste_addr > regs->mainlim)

  00171	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  00175	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017a	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  00181	76 05		 jbe	 SHORT $LN15@s370_trans

; 334  :         goto asn_addr_excp;

  00183	e9 49 01 00 00	 jmp	 $asn_addr_excp$25
$LN15@s370_trans:

; 335  : 
; 336  :     /* Return the real address of the ASTE */
; 337  :     *asteo = aste_addr;

  00188	48 8b 44 24 70	 mov	 rax, QWORD PTR asteo$[rsp]
  0018d	8b 4c 24 20	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  00191	89 08		 mov	 DWORD PTR [rax], ecx

; 338  : 
; 339  :     /* Fetch the 16- or 64-byte ASN second table entry from real
; 340  :        storage.  Each fullword of the ASTE must be fetched
; 341  :        concurrently as observed by other CPUs */
; 342  :     aste_addr = APPLY_PREFIXING (aste_addr, regs->PX);

  00193	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  00197	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0019d	48 85 c0	 test	 rax, rax
  001a0	74 21		 je	 SHORT $LN22@s370_trans
  001a2	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  001a6	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  001ac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001b1	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  001b4	48 3b c1	 cmp	 rax, rcx
  001b7	74 0a		 je	 SHORT $LN22@s370_trans
  001b9	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  001bd	89 44 24 38	 mov	 DWORD PTR tv156[rsp], eax
  001c1	eb 14		 jmp	 SHORT $LN23@s370_trans
$LN22@s370_trans:
  001c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001c8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  001cb	8b 4c 24 20	 mov	 ecx, DWORD PTR aste_addr$[rsp]
  001cf	33 c8		 xor	 ecx, eax
  001d1	8b c1		 mov	 eax, ecx
  001d3	89 44 24 38	 mov	 DWORD PTR tv156[rsp], eax
$LN23@s370_trans:
  001d7	8b 44 24 38	 mov	 eax, DWORD PTR tv156[rsp]
  001db	89 44 24 20	 mov	 DWORD PTR aste_addr$[rsp], eax

; 343  :     aste_main = FETCH_MAIN_ABSOLUTE(aste_addr, regs, numwords * 4);

  001df	8b 44 24 20	 mov	 eax, DWORD PTR aste_addr$[rsp]
  001e3	48 8b 54 24 68	 mov	 rdx, QWORD PTR regs$[rsp]
  001e8	8b c8		 mov	 ecx, eax
  001ea	e8 00 00 00 00	 call	 s370_fetch_main_absolute
  001ef	48 89 44 24 40	 mov	 QWORD PTR aste_main$[rsp], rax

; 344  :     for (i = 0; i < numwords; i++)

  001f4	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001fc	eb 0a		 jmp	 SHORT $LN4@s370_trans
$LN2@s370_trans:
  001fe	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00202	ff c0		 inc	 eax
  00204	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@s370_trans:
  00208	8b 44 24 3c	 mov	 eax, DWORD PTR numwords$[rsp]
  0020c	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00210	7d 2e		 jge	 SHORT $LN3@s370_trans

; 345  :     {
; 346  :         aste[i] = fetch_fw(aste_main);

  00212	48 8b 4c 24 40	 mov	 rcx, QWORD PTR aste_main$[rsp]
  00217	e8 00 00 00 00	 call	 fetch_fw_noswap
  0021c	8b c8		 mov	 ecx, eax
  0021e	e8 00 00 00 00	 call	 _byteswap_ulong
  00223	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR i$[rsp]
  00228	48 8b 54 24 78	 mov	 rdx, QWORD PTR aste$[rsp]
  0022d	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 347  :         aste_main += 4;

  00230	48 8b 44 24 40	 mov	 rax, QWORD PTR aste_main$[rsp]
  00235	48 83 c0 04	 add	 rax, 4
  00239	48 89 44 24 40	 mov	 QWORD PTR aste_main$[rsp], rax

; 348  :     }

  0023e	eb be		 jmp	 SHORT $LN2@s370_trans
$LN3@s370_trans:
$LN5@s370_trans:

; 349  :     /* Clear remaining words if fewer than 16 words were loaded */
; 350  :     while (i < 16) aste[i++] = 0;

  00240	83 7c 24 28 10	 cmp	 DWORD PTR i$[rsp], 16
  00245	7d 1d		 jge	 SHORT $LN6@s370_trans
  00247	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0024c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR aste$[rsp]
  00251	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0
  00258	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0025c	ff c0		 inc	 eax
  0025e	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  00262	eb dc		 jmp	 SHORT $LN5@s370_trans
$LN6@s370_trans:

; 351  : 
; 352  : 
; 353  :     /* Check the ASX invalid bit in the ASTE */
; 354  :     if (aste[0] & ASTE0_INVALID)

  00264	b8 04 00 00 00	 mov	 eax, 4
  00269	48 6b c0 00	 imul	 rax, rax, 0
  0026d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR aste$[rsp]
  00272	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00275	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0027a	85 c0		 test	 eax, eax
  0027c	74 05		 je	 SHORT $LN16@s370_trans

; 355  :         goto asn_asx_tran_excp;

  0027e	e9 93 00 00 00	 jmp	 $asn_asx_tran_excp$28
$LN16@s370_trans:

; 356  : 
; 357  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 358  :     /* Check the reserved bits in first two words of ASTE */
; 359  :     if ((aste[0] & ASTE0_RESV) || (aste[1] & ASTE1_RESV)
; 360  :         || ((aste[0] & ASTE0_BASE)

  00283	b8 04 00 00 00	 mov	 eax, 4
  00288	48 6b c0 00	 imul	 rax, rax, 0
  0028c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR aste$[rsp]
  00291	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00294	83 e0 02	 and	 eax, 2
  00297	85 c0		 test	 eax, eax
  00299	75 30		 jne	 SHORT $LN18@s370_trans
  0029b	b8 04 00 00 00	 mov	 eax, 4
  002a0	48 6b c0 01	 imul	 rax, rax, 1
  002a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR aste$[rsp]
  002a9	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  002ac	83 e0 0f	 and	 eax, 15
  002af	85 c0		 test	 eax, eax
  002b1	75 18		 jne	 SHORT $LN18@s370_trans
  002b3	b8 04 00 00 00	 mov	 eax, 4
  002b8	48 6b c0 00	 imul	 rax, rax, 0
  002bc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR aste$[rsp]
  002c1	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  002c4	83 e0 01	 and	 eax, 1
  002c7	85 c0		 test	 eax, eax
  002c9	74 02		 je	 SHORT $LN17@s370_trans
$LN18@s370_trans:

; 361  : #ifdef FEATURE_SUBSPACE_GROUP
; 362  :             && !ASF_ENABLED(regs)
; 363  : #endif
; 364  :             ))
; 365  :         goto asn_asn_tran_spec_excp;

  002cb	eb 0e		 jmp	 SHORT $asn_asn_tran_spec_excp$27
$LN17@s370_trans:

; 366  : #endif
; 367  : 
; 368  :     return 0;

  002cd	33 c0		 xor	 eax, eax
  002cf	eb 62		 jmp	 SHORT $LN1@s370_trans
$asn_addr_excp$25:

; 369  : 
; 370  : /* Conditions which always cause program check */
; 371  : asn_addr_excp:
; 372  :     code = PGM_ADDRESSING_EXCEPTION;

  002d1	c7 44 24 2c 05
	00 00 00	 mov	 DWORD PTR code$[rsp], 5

; 373  :     goto asn_prog_check;

  002d9	eb 08		 jmp	 SHORT $asn_prog_check$29
$asn_asn_tran_spec_excp$27:

; 374  : 
; 375  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 376  : asn_asn_tran_spec_excp:
; 377  :     code = PGM_ASN_TRANSLATION_SPECIFICATION_EXCEPTION;

  002db	c7 44 24 2c 17
	00 00 00	 mov	 DWORD PTR code$[rsp], 23
$asn_prog_check$29:

; 378  :     goto asn_prog_check;
; 379  : #endif
; 380  : 
; 381  : asn_prog_check:
; 382  :     regs->program_interrupt (regs, code);

  002e3	8b 54 24 2c	 mov	 edx, DWORD PTR code$[rsp]
  002e7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  002ec	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002f1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$asn_afx_tran_excp$26:

; 383  : 
; 384  : /* Conditions which the caller may or may not program check */
; 385  : asn_afx_tran_excp:
; 386  :     regs->TEA = asn;

  002f7	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  002fc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00301	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 387  :     code = PGM_AFX_TRANSLATION_EXCEPTION;

  00307	c7 44 24 2c 20
	00 00 00	 mov	 DWORD PTR code$[rsp], 32 ; 00000020H

; 388  :     return code;

  0030f	0f b7 44 24 2c	 movzx	 eax, WORD PTR code$[rsp]
  00314	eb 1d		 jmp	 SHORT $LN1@s370_trans
$asn_asx_tran_excp$28:

; 389  : 
; 390  : asn_asx_tran_excp:
; 391  :     regs->TEA = asn;

  00316	0f b7 44 24 60	 movzx	 eax, WORD PTR asn$[rsp]
  0031b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00320	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 392  :     code = PGM_ASX_TRANSLATION_EXCEPTION;

  00326	c7 44 24 2c 21
	00 00 00	 mov	 DWORD PTR code$[rsp], 33 ; 00000021H

; 393  :     return code;

  0032e	0f b7 44 24 2c	 movzx	 eax, WORD PTR code$[rsp]
$LN1@s370_trans:

; 394  : 
; 395  : } /* end function translate_asn */

  00333	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00337	c3		 ret	 0
s370_translate_asn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
pte$ = 32
tv142 = 40
tv153 = 44
tv154 = 48
tv169 = 52
tv189 = 56
tv195 = 60
raddr$ = 64
pfra$ = 72
ibyte$ = 96
pto$ = 104
vaddr$ = 112
regs$ = 120
local$ = 128
s370_invalidate_pte PROC

; 2147 : {

$LN21:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@s370_inval:

; 2148 : RADR    raddr;                          /* Addr of Page Table Entry  */
; 2149 : RADR    pte;                            /* Page Table Entry itself   */
; 2150 : RADR    pfra;                           /* Page Frame Real Address   */
; 2151 : 
; 2152 :     UNREFERENCED_370( ibyte );

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@s370_inval

; 2153 : 
; 2154 : #if !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 2155 :     {
; 2156 :         // SYSTEM/370...
; 2157 : 
; 2158 :         /* Program check if translation format is invalid */
; 2159 :         if (0
; 2160 :             || (((regs->CR(0) & CR0_PAGE_SIZE) != CR0_PAGE_SZ_2K) && ((regs->CR(0) & CR0_PAGE_SIZE) != CR0_PAGE_SZ_4K))
; 2161 :             || (((regs->CR(0) & CR0_SEG_SIZE)  != CR0_SEG_SZ_64K) && ((regs->CR(0) & CR0_SEG_SIZE)  != CR0_SEG_SZ_1M))

  0001d	33 c0		 xor	 eax, eax
  0001f	85 c0		 test	 eax, eax
  00021	0f 85 81 00 00
	00		 jne	 $LN6@s370_inval
  00027	b8 08 00 00 00	 mov	 eax, 8
  0002c	48 6b c0 01	 imul	 rax, rax, 1
  00030	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00035	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0003c	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  00041	3d 00 00 40 00	 cmp	 eax, 4194304		; 00400000H
  00046	74 21		 je	 SHORT $LN7@s370_inval
  00048	b8 08 00 00 00	 mov	 eax, 8
  0004d	48 6b c0 01	 imul	 rax, rax, 1
  00051	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00056	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0005d	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  00062	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  00067	75 3f		 jne	 SHORT $LN6@s370_inval
$LN7@s370_inval:
  00069	b8 08 00 00 00	 mov	 eax, 8
  0006e	48 6b c0 01	 imul	 rax, rax, 1
  00072	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0007e	25 00 00 38 00	 and	 eax, 3670016		; 00380000H
  00083	85 c0		 test	 eax, eax
  00085	74 36		 je	 SHORT $LN5@s370_inval
  00087	b8 08 00 00 00	 mov	 eax, 8
  0008c	48 6b c0 01	 imul	 rax, rax, 1
  00090	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00095	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0009c	25 00 00 38 00	 and	 eax, 3670016		; 00380000H
  000a1	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  000a6	74 15		 je	 SHORT $LN5@s370_inval
$LN6@s370_inval:

; 2162 :         )
; 2163 :             regs->program_interrupt( regs, PGM_TRANSLATION_SPECIFICATION_EXCEPTION );

  000a8	ba 12 00 00 00	 mov	 edx, 18
  000ad	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000b7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN5@s370_inval:

; 2164 : 
; 2165 :         /* Add the vaddr's page table entry index to the Page Table
; 2166 :            Origin, ignoring any carry, to form the 24-bit real address
; 2167 :            of the Page Table Entry to be invalidated, taking into account
; 2168 :            that each Page Table Entry is 2 bytes wide (shift 1 less bit)
; 2169 :         */
; 2170 :         raddr = (pto & SEGTAB_370_PTO) +

  000bd	b8 08 00 00 00	 mov	 eax, 8
  000c2	48 6b c0 01	 imul	 rax, rax, 1
  000c6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000d2	25 00 00 38 00	 and	 eax, 3670016		; 00380000H
  000d7	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  000dc	75 4d		 jne	 SHORT $LN13@s370_inval
  000de	b8 08 00 00 00	 mov	 eax, 8
  000e3	48 6b c0 01	 imul	 rax, rax, 1
  000e7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000f3	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  000f8	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  000fd	75 12		 jne	 SHORT $LN9@s370_inval
  000ff	8b 44 24 70	 mov	 eax, DWORD PTR vaddr$[rsp]
  00103	25 00 f0 0f 00	 and	 eax, 1044480		; 000ff000H
  00108	c1 e8 0b	 shr	 eax, 11
  0010b	89 44 24 28	 mov	 DWORD PTR tv142[rsp], eax
  0010f	eb 10		 jmp	 SHORT $LN10@s370_inval
$LN9@s370_inval:
  00111	8b 44 24 70	 mov	 eax, DWORD PTR vaddr$[rsp]
  00115	25 00 f8 0f 00	 and	 eax, 1046528		; 000ff800H
  0011a	c1 e8 0a	 shr	 eax, 10
  0011d	89 44 24 28	 mov	 DWORD PTR tv142[rsp], eax
$LN10@s370_inval:
  00121	8b 44 24 28	 mov	 eax, DWORD PTR tv142[rsp]
  00125	89 44 24 30	 mov	 DWORD PTR tv154[rsp], eax
  00129	eb 4b		 jmp	 SHORT $LN14@s370_inval
$LN13@s370_inval:
  0012b	b8 08 00 00 00	 mov	 eax, 8
  00130	48 6b c0 01	 imul	 rax, rax, 1
  00134	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00140	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  00145	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  0014a	75 12		 jne	 SHORT $LN11@s370_inval
  0014c	8b 44 24 70	 mov	 eax, DWORD PTR vaddr$[rsp]
  00150	25 00 f0 00 00	 and	 eax, 61440		; 0000f000H
  00155	c1 e8 0b	 shr	 eax, 11
  00158	89 44 24 2c	 mov	 DWORD PTR tv153[rsp], eax
  0015c	eb 10		 jmp	 SHORT $LN12@s370_inval
$LN11@s370_inval:
  0015e	8b 44 24 70	 mov	 eax, DWORD PTR vaddr$[rsp]
  00162	25 00 f8 00 00	 and	 eax, 63488		; 0000f800H
  00167	c1 e8 0a	 shr	 eax, 10
  0016a	89 44 24 2c	 mov	 DWORD PTR tv153[rsp], eax
$LN12@s370_inval:
  0016e	8b 44 24 2c	 mov	 eax, DWORD PTR tv153[rsp]
  00172	89 44 24 30	 mov	 DWORD PTR tv154[rsp], eax
$LN14@s370_inval:
  00176	48 8b 44 24 68	 mov	 rax, QWORD PTR pto$[rsp]
  0017b	48 25 f8 ff ff
	00		 and	 rax, 16777208		; 00fffff8H
  00181	8b 4c 24 30	 mov	 ecx, DWORD PTR tv154[rsp]
  00185	48 03 c1	 add	 rax, rcx
  00188	48 89 44 24 40	 mov	 QWORD PTR raddr$[rsp], rax

; 2171 :         (
; 2172 :             ((regs->CR(0)  & CR0_SEG_SIZE)  == CR0_SEG_SZ_1M)
; 2173 :             ?
; 2174 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 2175 :             ((vaddr & 0x000FF000) >> (SHIFT_4K-1)) : ((vaddr & 0x000FF800) >> (SHIFT_2K-1)))
; 2176 :             :
; 2177 :             (((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 2178 :             ((vaddr & 0x0000F000) >> (SHIFT_4K-1)) : ((vaddr & 0x0000F800) >> (SHIFT_2K-1)))
; 2179 :         );
; 2180 :         raddr &= MAXADDRESS;

  0018d	48 8b 44 24 40	 mov	 rax, QWORD PTR raddr$[rsp]
  00192	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00198	48 89 44 24 40	 mov	 QWORD PTR raddr$[rsp], rax

; 2181 : 
; 2182 :         /* Fetch the Page Table Entry from real storage,
; 2183 :            subject to normal storage protection mechanisms
; 2184 :         */
; 2185 :         pte = ARCH_DEP( vfetch2 )( raddr, USE_REAL_ADDR, regs );

  0019d	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001a2	ba fe ff ff ff	 mov	 edx, -2
  001a7	8b 4c 24 40	 mov	 ecx, DWORD PTR raddr$[rsp]
  001ab	e8 00 00 00 00	 call	 s370_vfetch2
  001b0	0f b7 c0	 movzx	 eax, ax
  001b3	48 89 44 24 20	 mov	 QWORD PTR pte$[rsp], rax

; 2186 : 
; 2187 : #if 0 // debug 370 IPTE
; 2188 :         LOGMSG
; 2189 :         (
; 2190 :             "dat.c: IPTE issued for entry %4.4X at %8.8X...\n"
; 2191 :             "       pto %8.8X, vaddr %8.8X, cr0 %8.8X\n"
; 2192 : 
; 2193 :             , pte, raddr
; 2194 :             , pto, vaddr, regs->CR(0)
; 2195 :         );
; 2196 : #endif
; 2197 : 
; 2198 :         /* Set the invalid bit in the Page Table Entry just fetched */
; 2199 :         pte |= ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_2K)

  001b8	b8 08 00 00 00	 mov	 eax, 8
  001bd	48 6b c0 01	 imul	 rax, rax, 1
  001c1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001c6	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  001cd	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  001d2	3d 00 00 40 00	 cmp	 eax, 4194304		; 00400000H
  001d7	75 0a		 jne	 SHORT $LN15@s370_inval
  001d9	c7 44 24 34 04
	00 00 00	 mov	 DWORD PTR tv169[rsp], 4
  001e1	eb 08		 jmp	 SHORT $LN16@s370_inval
$LN15@s370_inval:
  001e3	c7 44 24 34 08
	00 00 00	 mov	 DWORD PTR tv169[rsp], 8
$LN16@s370_inval:
  001eb	48 63 44 24 34	 movsxd	 rax, DWORD PTR tv169[rsp]
  001f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pte$[rsp]
  001f5	48 0b c8	 or	 rcx, rax
  001f8	48 8b c1	 mov	 rax, rcx
  001fb	48 89 44 24 20	 mov	 QWORD PTR pte$[rsp], rax

; 2200 :                ? PAGETAB_INV_2K : PAGETAB_INV_4K;
; 2201 : 
; 2202 :         /* Store the now invalidated Page Table Entry back into
; 2203 :            real storage where we originally got it from, subject
; 2204 :            to the same storage protection mechanisms
; 2205 :         */
; 2206 :         ARCH_DEP( vstore2 )( pte, raddr, USE_REAL_ADDR, regs );

  00200	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00205	41 b8 fe ff ff
	ff		 mov	 r8d, -2
  0020b	8b 54 24 40	 mov	 edx, DWORD PTR raddr$[rsp]
  0020f	0f b7 4c 24 20	 movzx	 ecx, WORD PTR pte$[rsp]
  00214	e8 00 00 00 00	 call	 s370_vstore2

; 2207 : 
; 2208 :         /* Extract the Page Frame Address from the Page Table Entry */
; 2209 :         pfra = ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K)

  00219	b8 08 00 00 00	 mov	 eax, 8
  0021e	48 6b c0 01	 imul	 rax, rax, 1
  00222	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00227	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0022e	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  00233	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  00238	75 1f		 jne	 SHORT $LN17@s370_inval
  0023a	8b 44 24 20	 mov	 eax, DWORD PTR pte$[rsp]
  0023e	83 e0 06	 and	 eax, 6
  00241	c1 e0 17	 shl	 eax, 23
  00244	8b 4c 24 20	 mov	 ecx, DWORD PTR pte$[rsp]
  00248	81 e1 f0 ff 00
	00		 and	 ecx, 65520		; 0000fff0H
  0024e	c1 e1 08	 shl	 ecx, 8
  00251	0b c1		 or	 eax, ecx
  00253	89 44 24 38	 mov	 DWORD PTR tv189[rsp], eax
  00257	eb 10		 jmp	 SHORT $LN18@s370_inval
$LN17@s370_inval:
  00259	8b 44 24 20	 mov	 eax, DWORD PTR pte$[rsp]
  0025d	25 f8 ff 00 00	 and	 eax, 65528		; 0000fff8H
  00262	c1 e0 08	 shl	 eax, 8
  00265	89 44 24 38	 mov	 DWORD PTR tv189[rsp], eax
$LN18@s370_inval:
  00269	8b 44 24 38	 mov	 eax, DWORD PTR tv189[rsp]
  0026d	48 89 44 24 48	 mov	 QWORD PTR pfra$[rsp], rax

; 2210 :             ?
; 2211 : #if defined( FEATURE_S370E_EXTENDED_ADDRESSING )
; 2212 :             (((U32)pte & PAGETAB_EA_4K) << 23) |
; 2213 : #endif
; 2214 :             (((U32)pte & PAGETAB_PFRA_4K) << 8)
; 2215 :             :
; 2216 :             (((U32)pte & PAGETAB_PFRA_2K) << 8);
; 2217 :     }
; 2218 : #elif defined( FEATURE_S390_DAT )
; 2219 :     {
; 2220 :         // SYSTEM/390...
; 2221 : 
; 2222 :         /* Program check if translation format is invalid */
; 2223 :         if ((regs->CR(0) & CR0_TRAN_FMT) != CR0_TRAN_ESA390)
; 2224 :             regs->program_interrupt( regs, PGM_TRANSLATION_SPECIFICATION_EXCEPTION );
; 2225 : 
; 2226 :         /* Add the vaddr's page table entry index to the Page Table
; 2227 :            Origin, ignoring any carry, to form the 31-bit real address
; 2228 :            of the Page Table Entry to be invalidated, taking into account
; 2229 :            that each Page Table Entry is 4 bytes wide (shift 2 fewer bits)
; 2230 :         */
; 2231 :         raddr = (pto & SEGTAB_PTO) + ((vaddr & 0x000FF000) >> (PAGEFRAME_PAGESHIFT-2));
; 2232 :         raddr &= MAXADDRESS;
; 2233 : 
; 2234 :         /* Fetch the Page Table Entry from real storage,
; 2235 :            subject to normal storage protection mechanisms */
; 2236 :         pte = ARCH_DEP( vfetch4 )( raddr, USE_REAL_ADDR, regs );
; 2237 : 
; 2238 :         /* Set the invalid bit in the Page Table Entry just fetched */
; 2239 : #if defined( FEATURE_MOVE_PAGE_FACILITY_2 ) && defined( FEATURE_EXPANDED_STORAGE )
; 2240 :         if (ibyte == 0x59) // (IESBE instruction?)
; 2241 :             pte &= ~PAGETAB_ESVALID;
; 2242 :         else
; 2243 : #endif
; 2244 :             pte |= PAGETAB_INVALID; // (no, IPTE instruction)
; 2245 : 
; 2246 :         /* Store the now invalidated Page Table Entry back into
; 2247 :            real storage where we originally got it from, subject
; 2248 :            to the same storage protection mechanisms
; 2249 :         */
; 2250 :         ARCH_DEP( vstore4 )( pte, raddr, USE_REAL_ADDR, regs );
; 2251 : 
; 2252 :         /* Extract the Page Frame Address from the Page Table Entry */
; 2253 :         pfra = pte & PAGETAB_PFRA;
; 2254 :     }
; 2255 : #else /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 2256 :     {
; 2257 :         // ESAME = z/Architecture...
; 2258 : 
; 2259 :         /* Add the vaddr's page table entry index to the Page Table
; 2260 :            Origin, ignoring any carry, to form the 64-bit real address
; 2261 :            of the Page Table Entry to be invalidated, taking into account
; 2262 :            that each Page Table Entry is 8 bytes wide (shift 3 fewer bits)
; 2263 :         */
; 2264 :         raddr = (pto & ZSEGTAB_PTO) + ((vaddr & 0x000FF000) >> (PAGEFRAME_PAGESHIFT-3));
; 2265 :         raddr &= MAXADDRESS;
; 2266 : 
; 2267 :         /* Fetch the Page Table Entry from real storage,
; 2268 :            subject to normal storage protection mechanisms
; 2269 :         */
; 2270 :         pte = ARCH_DEP( vfetch8 )( raddr, USE_REAL_ADDR, regs );
; 2271 : 
; 2272 :         /* Set the invalid bit in the Page Table Entry just fetched */
; 2273 : #if defined( FEATURE_MOVE_PAGE_FACILITY_2 ) && defined( FEATURE_EXPANDED_STORAGE )
; 2274 :         if (ibyte == 0x59) // (IESBE instruction?)
; 2275 :             pte &= ~ZPGETAB_ESVALID;
; 2276 :         else
; 2277 : #endif
; 2278 :             pte |= ZPGETAB_I; // (no, IPTE instruction)
; 2279 : 
; 2280 :         /* Store the now invalidated Page Table Entry back into
; 2281 :            real storage where we originally got it from, subject
; 2282 :            to the same storage protection mechanisms
; 2283 :         */
; 2284 :         ARCH_DEP( vstore8 )( pte, raddr, USE_REAL_ADDR, regs );
; 2285 : 
; 2286 :         /* Extract the Page Frame Address from the Page Table Entry */
; 2287 :         pfra = pte & ZPGETAB_PFRA;
; 2288 :     }
; 2289 : #endif /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 2290 : 
; 2291 :     /* Invalidate all TLB entries for this Page Frame Real Address */
; 2292 :     ARCH_DEP( purge_tlbe_all )( regs, pfra, local ? regs->cpuad : 0xFFFF );

  00272	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR local$[rsp]
  0027a	85 c0		 test	 eax, eax
  0027c	74 12		 je	 SHORT $LN19@s370_inval
  0027e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00283	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0028a	89 44 24 3c	 mov	 DWORD PTR tv195[rsp], eax
  0028e	eb 08		 jmp	 SHORT $LN20@s370_inval
$LN19@s370_inval:
  00290	c7 44 24 3c ff
	ff 00 00	 mov	 DWORD PTR tv195[rsp], 65535 ; 0000ffffH
$LN20@s370_inval:
  00298	44 0f b7 44 24
	3c		 movzx	 r8d, WORD PTR tv195[rsp]
  0029e	48 8b 54 24 48	 mov	 rdx, QWORD PTR pfra$[rsp]
  002a3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002a8	e8 00 00 00 00	 call	 s370_purge_tlbe_all

; 2293 : 
; 2294 : } /* end function invalidate_pte */

  002ad	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002b1	c3		 ret	 0
s370_invalidate_pte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv74 = 32
tv94 = 36
p$1 = 40
p$2 = 48
regs$ = 80
mask$ = 88
s370_invalidate_tlb PROC

; 1995 : {

$LN24:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1996 :     /* Do it for the current architecture first */
; 1997 :     ARCH_DEP( do_invalidate_tlb )( regs, mask );

  0000d	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  00012	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	e8 00 00 00 00	 call	 s370_do_invalidate_tlb

; 1998 : 
; 1999 : #if defined( _FEATURE_SIE )
; 2000 :     /* Also invalidate the GUEST registers in the SIE copy */
; 2001 :     if (regs->host && GUESTREGS)

  0001c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00021	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00027	c1 e8 07	 shr	 eax, 7
  0002a	83 e0 01	 and	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	0f 84 a1 00 00
	00		 je	 $LN12@s370_inval
  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0003a	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00042	0f 84 8e 00 00
	00		 je	 $LN12@s370_inval

; 2002 :     {
; 2003 :         switch (GUESTREGS->arch_mode)

  00048	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0004d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00054	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00057	89 44 24 20	 mov	 DWORD PTR tv74[rsp], eax
  0005b	83 7c 24 20 00	 cmp	 DWORD PTR tv74[rsp], 0
  00060	74 10		 je	 SHORT $LN14@s370_inval
  00062	83 7c 24 20 01	 cmp	 DWORD PTR tv74[rsp], 1
  00067	74 21		 je	 SHORT $LN15@s370_inval
  00069	83 7c 24 20 02	 cmp	 DWORD PTR tv74[rsp], 2
  0006e	74 32		 je	 SHORT $LN16@s370_inval
  00070	eb 48		 jmp	 SHORT $LN17@s370_inval
$LN14@s370_inval:

; 2004 :         {
; 2005 :         case ARCH_370_IDX: s370_do_invalidate_tlb( GUESTREGS, mask ); break;

  00072	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  00077	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00083	e8 00 00 00 00	 call	 s370_do_invalidate_tlb
  00088	eb 47		 jmp	 SHORT $LN2@s370_inval
$LN15@s370_inval:

; 2006 :         case ARCH_390_IDX: s390_do_invalidate_tlb( GUESTREGS, mask ); break;

  0008a	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  0008f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00094	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0009b	e8 00 00 00 00	 call	 s390_do_invalidate_tlb
  000a0	eb 2f		 jmp	 SHORT $LN2@s370_inval
$LN16@s370_inval:

; 2007 :         case ARCH_900_IDX: z900_do_invalidate_tlb( GUESTREGS, mask ); break;

  000a2	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  000a7	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  000b3	e8 00 00 00 00	 call	 z900_do_invalidate_tlb
  000b8	eb 17		 jmp	 SHORT $LN2@s370_inval
$LN17@s370_inval:
$LN6@s370_inval:

; 2008 :         default: CRASH();

  000ba	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000c3	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000c8	c6 00 00	 mov	 BYTE PTR [rax], 0
  000cb	33 c0		 xor	 eax, eax
  000cd	85 c0		 test	 eax, eax
  000cf	75 e9		 jne	 SHORT $LN6@s370_inval
$LN2@s370_inval:

; 2009 :         }
; 2010 :     }

  000d1	e9 a2 00 00 00	 jmp	 $LN13@s370_inval
$LN12@s370_inval:

; 2011 :     else if (regs->guest)  /* For guests, also clear HOST entries */

  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000db	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000e1	c1 e8 08	 shr	 eax, 8
  000e4	83 e0 01	 and	 eax, 1
  000e7	85 c0		 test	 eax, eax
  000e9	0f 84 89 00 00
	00		 je	 $LN18@s370_inval

; 2012 :     {
; 2013 :         switch (HOSTREGS->arch_mode)

  000ef	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000fb	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  000fe	89 44 24 24	 mov	 DWORD PTR tv94[rsp], eax
  00102	83 7c 24 24 00	 cmp	 DWORD PTR tv94[rsp], 0
  00107	74 10		 je	 SHORT $LN19@s370_inval
  00109	83 7c 24 24 01	 cmp	 DWORD PTR tv94[rsp], 1
  0010e	74 21		 je	 SHORT $LN20@s370_inval
  00110	83 7c 24 24 02	 cmp	 DWORD PTR tv94[rsp], 2
  00115	74 32		 je	 SHORT $LN21@s370_inval
  00117	eb 48		 jmp	 SHORT $LN22@s370_inval
$LN19@s370_inval:

; 2014 :         {
; 2015 :         case ARCH_370_IDX: s370_do_invalidate_tlb( HOSTREGS, mask ); break;

  00119	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  0011e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00123	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0012a	e8 00 00 00 00	 call	 s370_do_invalidate_tlb
  0012f	eb 47		 jmp	 SHORT $LN7@s370_inval
$LN20@s370_inval:

; 2016 :         case ARCH_390_IDX: s390_do_invalidate_tlb( HOSTREGS, mask ); break;

  00131	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  00136	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00142	e8 00 00 00 00	 call	 s390_do_invalidate_tlb
  00147	eb 2f		 jmp	 SHORT $LN7@s370_inval
$LN21@s370_inval:

; 2017 :         case ARCH_900_IDX: z900_do_invalidate_tlb( HOSTREGS, mask ); break;

  00149	0f b6 54 24 58	 movzx	 edx, BYTE PTR mask$[rsp]
  0014e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00153	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0015a	e8 00 00 00 00	 call	 z900_do_invalidate_tlb
  0015f	eb 17		 jmp	 SHORT $LN7@s370_inval
$LN22@s370_inval:
$LN11@s370_inval:

; 2018 :         default: CRASH();

  00161	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  0016a	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  0016f	c6 00 00	 mov	 BYTE PTR [rax], 0
  00172	33 c0		 xor	 eax, eax
  00174	85 c0		 test	 eax, eax
  00176	75 e9		 jne	 SHORT $LN11@s370_inval
$LN7@s370_inval:
$LN18@s370_inval:
$LN13@s370_inval:

; 2019 :         }
; 2020 :     }
; 2021 : #endif /* defined( _FEATURE_SIE ) */
; 2022 : } /* end function invalidate_tlb */

  00178	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017c	c3		 ret	 0
s370_invalidate_tlb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_fetch_halfword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
s370_fetch_halfword_absolute PROC			; COMDAT

; 850  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 851  :     return fetch_hw( FETCH_MAIN_ABSOLUTE( addr, regs, 2 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 s370_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_hw_noswap
  00025	0f b7 c8	 movzx	 ecx, ax
  00028	e8 00 00 00 00	 call	 _byteswap_ushort

; 852  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
s370_fetch_halfword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_fetch_fullword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
s370_fetch_fullword_absolute PROC			; COMDAT

; 835  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 836  :     return fetch_fw( FETCH_MAIN_ABSOLUTE( addr, regs, 4 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 s370_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_fw_noswap
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 _byteswap_ulong

; 837  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
s370_fetch_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_fetch_main_absolute
_TEXT	SEGMENT
addr$ = 64
regs$ = 72
s370_fetch_main_absolute PROC				; COMDAT

; 524  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370_fetch:

; 525  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 526  :     if (addr > (regs->mainlim - len))
; 527  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 528  : #endif
; 529  : 
; 530  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 531  :        is treated as a no-operation if SIE_MODE not active */
; 532  :     SIE_TRANSLATE( &addr, ACCTYPE_READ, regs );

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00019	d1 e8		 shr	 eax, 1
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 6a		 je	 SHORT $LN5@s370_fetch
  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0002d	c1 e8 02	 shr	 eax, 2
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	75 55		 jne	 SHORT $LN5@s370_fetch
  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0003c	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00043	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]
  00048	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00051	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00056	41 b9 04 00 00
	00		 mov	 r9d, 4
  0005c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00068	ba fd ff ff ff	 mov	 edx, -3
  0006d	8b c8		 mov	 ecx, eax
  0006f	e8 00 00 00 00	 call	 s390_logical_to_main_l
  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00079	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00080	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  00087	48 89 44 24 40	 mov	 QWORD PTR addr$[rsp], rax
$LN5@s370_fetch:
  0008c	33 c0		 xor	 eax, eax
  0008e	85 c0		 test	 eax, eax
  00090	0f 85 78 ff ff
	ff		 jne	 $LN4@s370_fetch

; 533  : 
; 534  :     /* Set the main storage reference bit */
; 535  :     ARCH_DEP( or_storage_key )( addr, STORKEY_REF );

  00096	b2 04		 mov	 dl, 4
  00098	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr$[rsp]
  0009d	e8 00 00 00 00	 call	 s370_or_storage_key

; 536  : 
; 537  :     /* Return absolute storage mainstor address */
; 538  :     return (regs->mainstor + addr);

  000a2	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000ae	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]

; 539  : 
; 540  : } /* end function fetch_main_absolute */

  000b3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b7	c3		 ret	 0
s370_fetch_main_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_is_store_protected
_TEXT	SEGMENT
addr$ = 48
skey$ = 56
akey$ = 64
regs$ = 72
s370_is_store_protected PROC				; COMDAT

; 469  : {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 470  :     /* [3.4.4] Low-address protection prohibits stores into certain
; 471  :        locations in the prefixed storage area of non-private address
; 472  :        address spaces, if the low-address control bit in CR0 is set,
; 473  :        regardless of the access key and storage key */
; 474  :     if (ARCH_DEP( is_low_address_protected )( addr, regs ))

  00016	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  0001b	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  0001f	e8 00 00 00 00	 call	 s370_is_low_address_protected
  00024	0f b6 c0	 movzx	 eax, al
  00027	85 c0		 test	 eax, eax
  00029	74 04		 je	 SHORT $LN2@s370_is_st

; 475  :         return true;

  0002b	b0 01		 mov	 al, 1
  0002d	eb 72		 jmp	 SHORT $LN1@s370_is_st
$LN2@s370_is_st:

; 476  : 
; 477  :     /* Access-list controlled protection prohibits all stores into
; 478  :        the address space, and page protection prohibits all stores
; 479  :        into the page, regardless of the access key and storage key */
; 480  :     if (regs->dat.protect)

  0002f	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00034	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0003a	d1 e8		 shr	 eax, 1
  0003c	83 e0 03	 and	 eax, 3
  0003f	85 c0		 test	 eax, eax
  00041	74 04		 je	 SHORT $LN3@s370_is_st

; 481  :         return true;

  00043	b0 01		 mov	 al, 1
  00045	eb 5a		 jmp	 SHORT $LN1@s370_is_st
$LN3@s370_is_st:

; 482  : 
; 483  : #if defined( _FEATURE_SIE )
; 484  :     if (SIE_MODE( regs ) && HOSTREGS->dat.protect)

  00047	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0004c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00052	d1 e8		 shr	 eax, 1
  00054	83 e0 01	 and	 eax, 1
  00057	85 c0		 test	 eax, eax
  00059	74 1f		 je	 SHORT $LN4@s370_is_st
  0005b	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00060	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00067	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0006d	d1 e8		 shr	 eax, 1
  0006f	83 e0 03	 and	 eax, 3
  00072	85 c0		 test	 eax, eax
  00074	74 04		 je	 SHORT $LN4@s370_is_st

; 485  :         return true;

  00076	b0 01		 mov	 al, 1
  00078	eb 27		 jmp	 SHORT $LN1@s370_is_st
$LN4@s370_is_st:

; 486  : #endif
; 487  : 
; 488  :     /* [3.4.1] Store is allowed if access key is zero, regardless
; 489  :        of the storage key */
; 490  :     if (akey == 0)

  0007a	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey$[rsp]
  0007f	85 c0		 test	 eax, eax
  00081	75 04		 jne	 SHORT $LN5@s370_is_st

; 491  :         return false;

  00083	32 c0		 xor	 al, al
  00085	eb 1a		 jmp	 SHORT $LN1@s370_is_st
$LN5@s370_is_st:

; 492  : 
; 493  : #if defined( FEATURE_STORAGE_PROTECTION_OVERRIDE )
; 494  :     /* [3.4.1.1] Storage protection override allows access to
; 495  :        locations with storage key 9, regardless of the access key,
; 496  :        provided that CR0 bit 7 is set */
; 497  :     if (1
; 498  :         && (skey & STORKEY_KEY) == 0x90
; 499  :         && (regs->CR(0) & CR0_STORE_OVRD)
; 500  :     )
; 501  :         return false;
; 502  : #endif
; 503  : 
; 504  :     /* [3.4.1] Store protection prohibits stores
; 505  :        if the access key does not match the storage key */
; 506  :     if (akey != (skey & STORKEY_KEY))

  00087	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey$[rsp]
  0008c	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR skey$[rsp]
  00091	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00097	3b c1		 cmp	 eax, ecx
  00099	74 04		 je	 SHORT $LN6@s370_is_st

; 507  :         return true;

  0009b	b0 01		 mov	 al, 1
  0009d	eb 02		 jmp	 SHORT $LN1@s370_is_st
$LN6@s370_is_st:

; 508  : 
; 509  :     return false;      // (location is *NOT* store protected)

  0009f	32 c0		 xor	 al, al
$LN1@s370_is_st:

; 510  : 
; 511  : } /* end function is_store_protected */

  000a1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a5	c3		 ret	 0
s370_is_store_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_is_low_address_protected
_TEXT	SEGMENT
addr$ = 8
regs$ = 16
s370_is_low_address_protected PROC			; COMDAT

; 419  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 420  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 421  :     /* For z/Arch, low-address protection applies to locations
; 422  :        0-511 (0000-01FF) and also 4096-4607 (1000-11FF) */
; 423  :     if (addr & 0xFFFFFFFFFFFFEE00ULL)
; 424  : #else
; 425  :     /* For S/370 and ESA/390, low-address protection applies
; 426  :        only to locations 0-511 */
; 427  :     if (addr > 511)

  00009	81 7c 24 08 ff
	01 00 00	 cmp	 DWORD PTR addr$[rsp], 511 ; 000001ffH
  00011	76 04		 jbe	 SHORT $LN2@s370_is_lo

; 428  : #endif
; 429  :         return false;

  00013	32 c0		 xor	 al, al
  00015	eb 50		 jmp	 SHORT $LN1@s370_is_lo
$LN2@s370_is_lo:

; 430  : 
; 431  :     /* Low-address protection applies only if the low-address
; 432  :        protection control bit in control register 0 is set */
; 433  :     if (!(regs->CR(0) & CR0_LOW_PROT))

  00017	b8 08 00 00 00	 mov	 eax, 8
  0001c	48 6b c0 01	 imul	 rax, rax, 1
  00020	48 8b 4c 24 10	 mov	 rcx, QWORD PTR regs$[rsp]
  00025	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0002c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00031	85 c0		 test	 eax, eax
  00033	75 04		 jne	 SHORT $LN3@s370_is_lo

; 434  :         return false;

  00035	32 c0		 xor	 al, al
  00037	eb 2e		 jmp	 SHORT $LN1@s370_is_lo
$LN3@s370_is_lo:

; 435  : 
; 436  : #if defined( _FEATURE_SIE )
; 437  :     /* Host low-address protection is not applied to guest
; 438  :        references to guest storage */
; 439  :     if (regs->sie_active)

  00039	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  0003e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00044	83 e0 01	 and	 eax, 1
  00047	85 c0		 test	 eax, eax
  00049	74 04		 je	 SHORT $LN4@s370_is_lo

; 440  :         return false;

  0004b	32 c0		 xor	 al, al
  0004d	eb 18		 jmp	 SHORT $LN1@s370_is_lo
$LN4@s370_is_lo:

; 441  : #endif
; 442  : 
; 443  :     /* Low-addr protection doesn't apply to private address spaces */
; 444  :     if (regs->dat.pvtaddr)

  0004f	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  00054	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0005a	83 e0 01	 and	 eax, 1
  0005d	85 c0		 test	 eax, eax
  0005f	74 04		 je	 SHORT $LN5@s370_is_lo

; 445  :         return false;

  00061	32 c0		 xor	 al, al
  00063	eb 02		 jmp	 SHORT $LN1@s370_is_lo
$LN5@s370_is_lo:

; 446  : 
; 447  :     return true;      // (location *IS* low-address protected)

  00065	b0 01		 mov	 al, 1
$LN1@s370_is_lo:

; 448  : 
; 449  : } /* end function is_low_address_protected */

  00067	c3		 ret	 0
s370_is_low_address_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_is_fetch_protected
_TEXT	SEGMENT
tv87 = 0
addr$ = 32
skey$ = 40
akey$ = 48
regs$ = 56
s370_is_fetch_protected PROC				; COMDAT

; 365  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 18	 sub	 rsp, 24
$LN4@s370_is_fe:

; 366  :     UNREFERENCED_370( addr );

  00016	33 c0		 xor	 eax, eax
  00018	85 c0		 test	 eax, eax
  0001a	75 fa		 jne	 SHORT $LN4@s370_is_fe
$LN7@s370_is_fe:

; 367  :     UNREFERENCED_370( regs );

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN7@s370_is_fe

; 368  : 
; 369  :     /* [3.4.1] Fetch is allowed if access key is zero, regardless
; 370  :        of the storage key and fetch protection bit */
; 371  :     /* [3.4.1] Fetch protection prohibits fetch if storage key fetch
; 372  :        protect bit is on and access key does not match storage key */
; 373  :     if (likely(0

  00022	33 c0		 xor	 eax, eax
  00024	85 c0		 test	 eax, eax
  00026	75 32		 jne	 SHORT $LN10@s370_is_fe
  00028	0f b6 44 24 30	 movzx	 eax, BYTE PTR akey$[rsp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 29		 je	 SHORT $LN10@s370_is_fe
  00031	0f b6 44 24 30	 movzx	 eax, BYTE PTR akey$[rsp]
  00036	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR skey$[rsp]
  0003b	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00041	3b c1		 cmp	 eax, ecx
  00043	74 15		 je	 SHORT $LN10@s370_is_fe
  00045	0f b6 44 24 28	 movzx	 eax, BYTE PTR skey$[rsp]
  0004a	83 e0 08	 and	 eax, 8
  0004d	85 c0		 test	 eax, eax
  0004f	74 09		 je	 SHORT $LN10@s370_is_fe
  00051	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv87[rsp], 0
  00058	eb 07		 jmp	 SHORT $LN13@s370_is_fe
$LN10@s370_is_fe:
  0005a	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv87[rsp], 1
$LN13@s370_is_fe:
  00061	83 3c 24 00	 cmp	 DWORD PTR tv87[rsp], 0
  00065	74 04		 je	 SHORT $LN8@s370_is_fe

; 374  :                || akey == 0
; 375  :                || akey == (skey & STORKEY_KEY)
; 376  :                || !(skey & STORKEY_FETCH)
; 377  :               )
; 378  :     )
; 379  :         return false;

  00067	32 c0		 xor	 al, al
  00069	eb 02		 jmp	 SHORT $LN1@s370_is_fe
$LN8@s370_is_fe:

; 380  : 
; 381  : #if defined( FEATURE_FETCH_PROTECTION_OVERRIDE )
; 382  :     /* [3.4.1.2] Fetch protection override allows fetch from first
; 383  :        2K of non-private address spaces if CR0 bit 6 is set */
; 384  :     if (1
; 385  :         && addr < 2048
; 386  :         && (regs->CR(0) & CR0_FETCH_OVRD)
; 387  :         && regs->dat.pvtaddr == 0
; 388  :     )
; 389  :         return false;
; 390  : #endif
; 391  : 
; 392  : #if defined( FEATURE_STORAGE_PROTECTION_OVERRIDE )
; 393  :     /* [3.4.1.1] Storage protection override allows access to
; 394  :        locations with storage key 9, regardless of the access key,
; 395  :        provided that CR0 bit 7 is set */
; 396  :     if (1
; 397  :         && (skey & STORKEY_KEY) == 0x90
; 398  :         && (regs->CR(0) & CR0_STORE_OVRD)
; 399  :     )
; 400  :         return false;
; 401  : #endif
; 402  : 
; 403  :     return true;    // (location *IS* fetch protected)

  0006b	b0 01		 mov	 al, 1
$LN1@s370_is_fe:

; 404  : 
; 405  : } /* end function is_fetch_protected */

  0006d	48 83 c4 18	 add	 rsp, 24
  00071	c3		 ret	 0
s370_is_fetch_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
ix$ = 32
tv661 = 36
aaddr$ = 40
tv219 = 48
tv325 = 52
tv366 = 56
tv373 = 60
tv395 = 64
tv456 = 68
tv505 = 72
tv525 = 76
tv605 = 80
tv604 = 84
tv606 = 88
tv648 = 92
apfra$ = 96
tv172 = 104
tv184 = 112
tv719 = 120
p$1 = 128
addr$ = 160
arn$ = 168
regs$ = 176
acctype$ = 184
akey$ = 192
len$ = 200
z900_logical_to_main_l PROC

; 2362 : {

$LN84:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2363 : RADR    aaddr;                          /* Absolute address          */
; 2364 : RADR    apfra;                          /* Abs page frame address    */
; 2365 : int     ix = TLBIX(addr);               /* TLB index                 */

  0001a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00022	48 c1 e8 0c	 shr	 rax, 12
  00026	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  0002c	89 44 24 20	 mov	 DWORD PTR ix$[rsp], eax

; 2366 : 
; 2367 :     /* Convert logical address to real address */
; 2368 :     if ( (REAL_MODE(&regs->psw) || arn == USE_REAL_ADDR)
; 2369 : #if defined( FEATURE_SIE )
; 2370 :       /* Under SIE guest real is always host primary, regardless
; 2371 :          of the DAT mode */
; 2372 :       && !(regs->sie_active

  00030	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00038	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0003c	83 e0 04	 and	 eax, 4
  0003f	85 c0		 test	 eax, eax
  00041	74 0e		 je	 SHORT $LN12@z900_logic
  00043	83 bc 24 a8 00
	00 00 fe	 cmp	 DWORD PTR arn$[rsp], -2
  0004b	0f 85 3c 01 00
	00		 jne	 $LN10@z900_logic
$LN12@z900_logic:
  00051	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00059	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0005f	83 e0 01	 and	 eax, 1
  00062	85 c0		 test	 eax, eax
  00064	0f 85 23 01 00
	00		 jne	 $LN10@z900_logic

; 2373 : #if !defined( _FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 2374 :                             && arn == USE_PRIMARY_SPACE
; 2375 : #else
; 2376 : //                          && ( (arn == USE_PRIMARY_SPACE)
; 2377 : //                               || SIE_STATE_BIT_ON(GUESTREGS, MX, XC) )
; 2378 : #endif /* defined( _FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE ) */
; 2379 :           )
; 2380 : #endif /* defined( FEATURE_SIE ) */
; 2381 :        )
; 2382 :     {
; 2383 :         regs->dat.pvtaddr = regs->dat.protect = 0;

  0006a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00072	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00078	83 e0 f9	 and	 eax, -7			; fffffff9H
  0007b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
  00089	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00091	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00097	83 e0 fe	 and	 eax, -2			; fffffffeH
  0009a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a2	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 2384 :         regs->dat.raddr = addr;

  000a8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000b8	48 89 88 00 08
	00 00		 mov	 QWORD PTR [rax+2048], rcx

; 2385 :         regs->dat.rpfra = addr & PAGEFRAME_PAGEMASK;

  000bf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000c7	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000cd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d5	48 89 81 10 08
	00 00		 mov	 QWORD PTR [rcx+2064], rax

; 2386 : 
; 2387 :         /* Setup `real' TLB entry (for MADDR) */
; 2388 :         regs->tlb.TLB_ASD(ix)   = TLB_REAL_ASD;

  000dc	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  000e1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e9	48 c7 84 c1 60
	b0 00 00 ff ff
	ff ff		 mov	 QWORD PTR [rcx+rax*8+45152], -1

; 2389 :         regs->tlb.TLB_VADDR(ix) = (addr & TLBID_PAGEMASK) | regs->tlbID;

  000f5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000fd	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00103	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  00111	48 0b c1	 or	 rax, rcx
  00114	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00119	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00121	48 89 84 ca 60
	d0 00 00	 mov	 QWORD PTR [rdx+rcx*8+53344], rax

; 2390 :         regs->tlb.TLB_PTE(ix)   = addr & TLBID_PAGEMASK;

  00129	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00131	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00137	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0013c	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00144	48 89 84 ca 60
	f0 00 00	 mov	 QWORD PTR [rdx+rcx*8+61536], rax

; 2391 :         regs->tlb.acc[ix]       =

  0014c	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00151	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	c6 84 01 60 58
	01 00 00	 mov	 BYTE PTR [rcx+rax+88160], 0
  00161	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00166	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016e	c6 84 01 60 54
	01 00 00	 mov	 BYTE PTR [rcx+rax+87136], 0
  00176	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  0017b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	c6 84 01 60 5c
	01 00 00	 mov	 BYTE PTR [rcx+rax+89184], 0

; 2392 :         regs->tlb.common[ix]    =
; 2393 :         regs->tlb.protect[ix]   = 0;
; 2394 :     }

  0018b	eb 2d		 jmp	 SHORT $LN11@z900_logic
$LN10@z900_logic:

; 2395 :     else {
; 2396 :         if (ARCH_DEP(translate_addr) (addr, arn, regs, acctype))

  0018d	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  00195	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0019d	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR arn$[rsp]
  001a4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  001ac	e8 00 00 00 00	 call	 z900_translate_addr
  001b1	85 c0		 test	 eax, eax
  001b3	74 05		 je	 SHORT $LN13@z900_logic

; 2397 :             goto vabs_prog_check;

  001b5	e9 fc 0e 00 00	 jmp	 $vabs_prog_check$85
$LN13@z900_logic:
$LN11@z900_logic:

; 2398 :     }
; 2399 : 
; 2400 :     if (regs->dat.protect
; 2401 :      && (acctype & (ACC_WRITE|ACC_CHECK)))

  001ba	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c2	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  001c8	d1 e8		 shr	 eax, 1
  001ca	83 e0 03	 and	 eax, 3
  001cd	85 c0		 test	 eax, eax
  001cf	74 13		 je	 SHORT $LN14@z900_logic
  001d1	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  001d8	83 e0 03	 and	 eax, 3
  001db	85 c0		 test	 eax, eax
  001dd	74 05		 je	 SHORT $LN14@z900_logic

; 2402 :         goto vabs_prot_excp;

  001df	e9 6b 0c 00 00	 jmp	 $vabs_prot_excp$86
$LN14@z900_logic:

; 2403 : 
; 2404 :     /* Convert real address to absolute address */
; 2405 :     regs->dat.aaddr = aaddr = APPLY_PREFIXING (regs->dat.raddr, regs->PX);

  001e4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ec	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  001f3	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  001f9	48 85 c0	 test	 rax, rax
  001fc	74 39		 je	 SHORT $LN45@z900_logic
  001fe	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00206	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  0020d	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00213	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021b	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  0021f	74 16		 je	 SHORT $LN45@z900_logic
  00221	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00229	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  00230	48 89 44 24 68	 mov	 QWORD PTR tv172[rsp], rax
  00235	eb 23		 jmp	 SHORT $LN46@z900_logic
$LN45@z900_logic:
  00237	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00247	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0024b	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  00252	48 33 c1	 xor	 rax, rcx
  00255	48 89 44 24 68	 mov	 QWORD PTR tv172[rsp], rax
$LN46@z900_logic:
  0025a	48 8b 44 24 68	 mov	 rax, QWORD PTR tv172[rsp]
  0025f	48 89 44 24 28	 mov	 QWORD PTR aaddr$[rsp], rax
  00264	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00271	48 89 88 08 08
	00 00		 mov	 QWORD PTR [rax+2056], rcx

; 2406 :     apfra=APPLY_PREFIXING(regs->dat.rpfra,regs->PX);

  00278	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00280	48 8b 80 10 08
	00 00		 mov	 rax, QWORD PTR [rax+2064]
  00287	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  0028d	48 85 c0	 test	 rax, rax
  00290	74 39		 je	 SHORT $LN47@z900_logic
  00292	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0029a	48 8b 80 10 08
	00 00		 mov	 rax, QWORD PTR [rax+2064]
  002a1	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  002a7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002af	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  002b3	74 16		 je	 SHORT $LN47@z900_logic
  002b5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bd	48 8b 80 10 08
	00 00		 mov	 rax, QWORD PTR [rax+2064]
  002c4	48 89 44 24 70	 mov	 QWORD PTR tv184[rsp], rax
  002c9	eb 23		 jmp	 SHORT $LN48@z900_logic
$LN47@z900_logic:
  002cb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002db	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  002df	48 8b 80 10 08
	00 00		 mov	 rax, QWORD PTR [rax+2064]
  002e6	48 33 c1	 xor	 rax, rcx
  002e9	48 89 44 24 70	 mov	 QWORD PTR tv184[rsp], rax
$LN48@z900_logic:
  002ee	48 8b 44 24 70	 mov	 rax, QWORD PTR tv184[rsp]
  002f3	48 89 44 24 60	 mov	 QWORD PTR apfra$[rsp], rax

; 2407 : 
; 2408 :     /* Program check if absolute address is outside main storage */
; 2409 :     if (regs->dat.aaddr > regs->mainlim)

  002f8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00300	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00308	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  0030f	48 39 88 08 08
	00 00		 cmp	 QWORD PTR [rax+2056], rcx
  00316	76 05		 jbe	 SHORT $LN15@z900_logic

; 2410 :         goto vabs_addr_excp;

  00318	e9 17 0b 00 00	 jmp	 $vabs_addr_excp$87
$LN15@z900_logic:

; 2411 : 
; 2412 : #if defined( _FEATURE_SIE )
; 2413 :     if(SIE_MODE(regs)) HOSTREGS->dat.protect = 0;

  0031d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00325	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0032b	d1 e8		 shr	 eax, 1
  0032d	83 e0 01	 and	 eax, 1
  00330	85 c0		 test	 eax, eax
  00332	74 2d		 je	 SHORT $LN16@z900_logic
  00334	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0033c	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00343	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00349	83 e0 f9	 and	 eax, -7			; fffffff9H
  0034c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00354	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  0035b	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN16@z900_logic:

; 2414 :     if(SIE_MODE(regs)  && !regs->sie_pref)

  00361	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00369	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0036f	d1 e8		 shr	 eax, 1
  00371	83 e0 01	 and	 eax, 1
  00374	85 c0		 test	 eax, eax
  00376	0f 84 16 04 00
	00		 je	 $LN17@z900_logic
  0037c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00384	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0038a	c1 e8 02	 shr	 eax, 2
  0038d	83 e0 01	 and	 eax, 1
  00390	85 c0		 test	 eax, eax
  00392	0f 85 fa 03 00
	00		 jne	 $LN17@z900_logic

; 2415 :     {
; 2416 :         if (SIE_TRANSLATE_ADDR (regs->sie_mso + regs->dat.aaddr,

  00398	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  003a0	7e 3a		 jle	 SHORT $LN49@z900_logic
  003a2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003aa	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  003b1	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  003b5	83 e0 01	 and	 eax, 1
  003b8	85 c0		 test	 eax, eax
  003ba	74 20		 je	 SHORT $LN49@z900_logic
  003bc	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c4	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  003c8	83 e0 40	 and	 eax, 64			; 00000040H
  003cb	85 c0		 test	 eax, eax
  003cd	74 0d		 je	 SHORT $LN49@z900_logic
  003cf	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  003d6	89 44 24 30	 mov	 DWORD PTR tv219[rsp], eax
  003da	eb 08		 jmp	 SHORT $LN50@z900_logic
$LN49@z900_logic:
  003dc	c7 44 24 30 fd
	ff ff ff	 mov	 DWORD PTR tv219[rsp], -3
$LN50@z900_logic:
  003e4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ec	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  003f3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fb	48 03 81 08 08
	00 00		 add	 rax, QWORD PTR [rcx+2056]
  00402	45 33 c9	 xor	 r9d, r9d
  00405	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0040d	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00414	8b 54 24 30	 mov	 edx, DWORD PTR tv219[rsp]
  00418	48 8b c8	 mov	 rcx, rax
  0041b	e8 00 00 00 00	 call	 z900_translate_addr
  00420	85 c0		 test	 eax, eax
  00422	74 46		 je	 SHORT $LN18@z900_logic

; 2417 :                     (arn > 0 && MULTIPLE_CONTROLLED_DATA_SPACE(regs)) ? arn : USE_PRIMARY_SPACE,
; 2418 :                     HOSTREGS, ACCTYPE_SIE))
; 2419 :             (HOSTREGS->program_interrupt) (HOSTREGS, HOSTREGS->dat.xcode);

  00424	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0042c	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00433	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  0043a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00442	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00449	48 89 4c 24 78	 mov	 QWORD PTR tv719[rsp], rcx
  0044e	8b d0		 mov	 edx, eax
  00450	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00458	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0045f	48 8b 44 24 78	 mov	 rax, QWORD PTR tv719[rsp]
  00464	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN18@z900_logic:

; 2420 : 
; 2421 :         regs->dat.protect     |= HOSTREGS->dat.protect;

  0046a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00472	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00478	d1 e8		 shr	 eax, 1
  0047a	83 e0 03	 and	 eax, 3
  0047d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00485	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  0048c	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  00492	d1 e9		 shr	 ecx, 1
  00494	83 e1 03	 and	 ecx, 3
  00497	0b c1		 or	 eax, ecx
  00499	83 e0 03	 and	 eax, 3
  0049c	d1 e0		 shl	 eax, 1
  0049e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a6	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  004ac	83 e1 f9	 and	 ecx, -7			; fffffff9H
  004af	0b c8		 or	 ecx, eax
  004b1	8b c1		 mov	 eax, ecx
  004b3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004bb	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 2422 :         regs->tlb.protect[ix] |= HOSTREGS->dat.protect;

  004c1	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  004c6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ce	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  004d5	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  004db	d1 e9		 shr	 ecx, 1
  004dd	83 e1 03	 and	 ecx, 3
  004e0	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004e8	0f b6 84 02 60
	58 01 00	 movzx	 eax, BYTE PTR [rdx+rax+88160]
  004f0	0b c1		 or	 eax, ecx
  004f2	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  004f7	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004ff	88 84 0a 60 58
	01 00		 mov	 BYTE PTR [rdx+rcx+88160], al

; 2423 : 
; 2424 :         if ( REAL_MODE(&regs->psw) || (arn == USE_REAL_ADDR) )

  00506	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050e	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00512	83 e0 04	 and	 eax, 4
  00515	85 c0		 test	 eax, eax
  00517	74 0a		 je	 SHORT $LN20@z900_logic
  00519	83 bc 24 a8 00
	00 00 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00521	75 23		 jne	 SHORT $LN19@z900_logic
$LN20@z900_logic:

; 2425 :             regs->tlb.TLB_PTE(ix)   = addr & TLBID_PAGEMASK;

  00523	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  0052b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00531	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00536	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0053e	48 89 84 ca 60
	f0 00 00	 mov	 QWORD PTR [rdx+rcx*8+61536], rax
$LN19@z900_logic:

; 2426 : 
; 2427 :         /* Indicate a host real space entry for a XC dataspace */
; 2428 :         if (arn > 0 && MULTIPLE_CONTROLLED_DATA_SPACE(regs))

  00546	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  0054e	0f 8e 92 01 00
	00		 jle	 $LN21@z900_logic
  00554	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0055c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00563	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00567	83 e0 01	 and	 eax, 1
  0056a	85 c0		 test	 eax, eax
  0056c	0f 84 74 01 00
	00		 je	 $LN21@z900_logic
  00572	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057a	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0057e	83 e0 40	 and	 eax, 64			; 00000040H
  00581	85 c0		 test	 eax, eax
  00583	0f 84 5d 01 00
	00		 je	 $LN21@z900_logic

; 2429 :         {
; 2430 :             regs->tlb.TLB_ASD(ix) = regs->dat.asd;

  00589	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  0058e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00596	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0059e	48 8b 92 18 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2072]
  005a5	48 89 94 c1 60
	b0 00 00	 mov	 QWORD PTR [rcx+rax*8+45152], rdx

; 2431 :             /* Ensure that the private bit is percolated to the guest such that LAP is applied correctly */
; 2432 :             regs->dat.pvtaddr = HOSTREGS->dat.pvtaddr;

  005ad	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b5	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  005bc	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  005c2	83 e0 01	 and	 eax, 1
  005c5	83 e0 01	 and	 eax, 1
  005c8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005d0	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  005d6	83 e1 fe	 and	 ecx, -2			; fffffffeH
  005d9	0b c8		 or	 ecx, eax
  005db	8b c1		 mov	 eax, ecx
  005dd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e5	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 2433 : 
; 2434 :             /* Build tlb entry of XC dataspace */
; 2435 :             regs->dat.asd = HOSTREGS->dat.asd ^ TLB_HOST_ASD;

  005eb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005f3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  005fa	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00601	48 0f ba f8 0b	 btc	 rax, 11
  00606	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0060e	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 2436 :             regs->CR(CR_ALB_OFFSET + arn) = regs->dat.asd;

  00615	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  0061c	83 c0 11	 add	 eax, 17
  0061f	48 98		 cdqe
  00621	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00629	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00631	48 8b 92 18 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2072]
  00638	48 89 94 c1 00
	06 00 00	 mov	 QWORD PTR [rcx+rax*8+1536], rdx

; 2437 :             regs->AEA_AR(arn) = CR_ALB_OFFSET + arn;

  00640	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00647	83 c0 10	 add	 eax, 16
  0064a	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR arn$[rsp]
  00651	83 c1 05	 add	 ecx, 5
  00654	48 63 c9	 movsxd	 rcx, ecx
  00657	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0065f	89 84 8a 94 0c
	00 00		 mov	 DWORD PTR [rdx+rcx*4+3220], eax

; 2438 :             regs->AEA_COMMON(CR_ALB_OFFSET + arn) = (regs->dat.asd & ASD_PRIVATE) == 0;

  00666	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0066e	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00675	48 25 20 01 00
	00		 and	 rax, 288		; 00000120H
  0067b	48 85 c0	 test	 rax, rax
  0067e	75 0a		 jne	 SHORT $LN51@z900_logic
  00680	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv325[rsp], 1
  00688	eb 08		 jmp	 SHORT $LN52@z900_logic
$LN51@z900_logic:
  0068a	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv325[rsp], 0
$LN52@z900_logic:
  00692	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00699	83 c0 11	 add	 eax, 17
  0069c	48 98		 cdqe
  0069e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a6	0f b6 54 24 34	 movzx	 edx, BYTE PTR tv325[rsp]
  006ab	88 94 01 e8 0c
	00 00		 mov	 BYTE PTR [rcx+rax+3304], dl

; 2439 :             regs->aea_aleprot[arn] = HOSTREGS->dat.protect & 2;

  006b2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ba	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  006c1	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  006c7	d1 e8		 shr	 eax, 1
  006c9	83 e0 03	 and	 eax, 3
  006cc	83 e0 02	 and	 eax, 2
  006cf	48 63 8c 24 a8
	00 00 00	 movsxd	 rcx, DWORD PTR arn$[rsp]
  006d7	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006df	88 84 0a 09 0d
	00 00		 mov	 BYTE PTR [rdx+rcx+3337], al
$LN21@z900_logic:

; 2440 :         }
; 2441 : 
; 2442 :         /* Convert host real address to host absolute address.
; 2443 :            Use the Prefixing logic of the SIE host, not the guest!
; 2444 :                                                -- ISW 20181005
; 2445 :         */
; 2446 :         HOSTREGS->dat.aaddr =

  006e6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ee	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  006f5	48 8b 90 00 08
	00 00		 mov	 rdx, QWORD PTR [rax+2048]
  006fc	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00704	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0070b	e8 00 00 00 00	 call	 apply_host_prefixing
  00710	48 89 44 24 28	 mov	 QWORD PTR aaddr$[rsp], rax
  00715	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0071d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00724	48 8b 4c 24 28	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00729	48 89 88 08 08
	00 00		 mov	 QWORD PTR [rax+2056], rcx

; 2447 :         aaddr = apply_host_prefixing( HOSTREGS, HOSTREGS->dat.raddr );
; 2448 :         apfra = apply_host_prefixing( HOSTREGS, HOSTREGS->dat.rpfra );

  00730	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00738	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0073f	48 8b 90 10 08
	00 00		 mov	 rdx, QWORD PTR [rax+2064]
  00746	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0074e	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00755	e8 00 00 00 00	 call	 apply_host_prefixing
  0075a	48 89 44 24 60	 mov	 QWORD PTR apfra$[rsp], rax

; 2449 : 
; 2450 :         if (HOSTREGS->dat.aaddr > HOSTREGS->mainlim)

  0075f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00767	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0076e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00776	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  0077d	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  00784	48 39 88 08 08
	00 00		 cmp	 QWORD PTR [rax+2056], rcx
  0078b	76 05		 jbe	 SHORT $LN22@z900_logic

; 2451 :             goto vabs_addr_excp;

  0078d	e9 a2 06 00 00	 jmp	 $vabs_addr_excp$87
$LN22@z900_logic:
$LN17@z900_logic:

; 2452 : 
; 2453 :         /* Take into account SIE guests with a 2K page scheme
; 2454 :            because the SIE host may be operating with a 4K page
; 2455 :            system */
; 2456 : #if defined( FEATURE_2K_STORAGE_KEYS )
; 2457 :         if ((addr & PAGEFRAME_PAGEMASK) & 0x800)
; 2458 :             apfra |= 0x800;
; 2459 : #endif
; 2460 :     }
; 2461 : #endif /* defined( _FEATURE_SIE ) */
; 2462 : 
; 2463 :     /* Save ptr to storage key for this translated logical address */
; 2464 :     regs->dat.storkey = ARCH_DEP( get_ptr_to_storekey )( aaddr );

  00792	48 8b 4c 24 28	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00797	e8 00 00 00 00	 call	 z900_get_ptr_to_storekey
  0079c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007a4	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax

; 2465 : 
; 2466 : #if defined( _FEATURE_SIE )
; 2467 :     /* Do not apply host key access when SIE fetches/stores data */
; 2468 :     if (unlikely(SIE_ACTIVE(regs)))

  007ab	33 c0		 xor	 eax, eax
  007ad	85 c0		 test	 eax, eax
  007af	74 19		 je	 SHORT $LN23@z900_logic

; 2469 :         return regs->mainstor + aaddr;

  007b1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007b9	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  007c0	48 03 44 24 28	 add	 rax, QWORD PTR aaddr$[rsp]
  007c5	e9 15 09 00 00	 jmp	 $LN1@z900_logic
$LN23@z900_logic:

; 2470 : #endif
; 2471 : 
; 2472 :     /* Skip further processing if hardware access */
; 2473 :     if (unlikely( acctype == ACCTYPE_HW ))

  007ca	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR acctype$[rsp], 0
  007d2	75 0a		 jne	 SHORT $LN55@z900_logic
  007d4	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv366[rsp], 1
  007dc	eb 08		 jmp	 SHORT $LN56@z900_logic
$LN55@z900_logic:
  007de	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv366[rsp], 0
$LN56@z900_logic:
  007e6	83 7c 24 38 00	 cmp	 DWORD PTR tv366[rsp], 0
  007eb	74 19		 je	 SHORT $LN24@z900_logic

; 2474 :     {
; 2475 :         /* Return mainstor address */
; 2476 :         return regs->mainstor + aaddr;

  007ed	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007f5	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  007fc	48 03 44 24 28	 add	 rax, QWORD PTR aaddr$[rsp]
  00801	e9 d9 08 00 00	 jmp	 $LN1@z900_logic
$LN24@z900_logic:

; 2477 :     }
; 2478 : 
; 2479 :     /* Check protection and set reference and change bits */
; 2480 :     if (likely( acctype & ACC_READ ))

  00806	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0080d	83 e0 04	 and	 eax, 4
  00810	85 c0		 test	 eax, eax
  00812	74 0a		 je	 SHORT $LN57@z900_logic
  00814	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv373[rsp], 1
  0081c	eb 08		 jmp	 SHORT $LN58@z900_logic
$LN57@z900_logic:
  0081e	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv373[rsp], 0
$LN58@z900_logic:
  00826	83 7c 24 3c 00	 cmp	 DWORD PTR tv373[rsp], 0
  0082b	0f 84 58 01 00
	00		 je	 $LN25@z900_logic

; 2481 :     {
; 2482 :         /* Program check if fetch protected location */
; 2483 :         if (unlikely(ARCH_DEP(is_fetch_protected) (addr, *regs->dat.storkey, akey, regs)))

  00831	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00839	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00840	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00848	44 0f b6 84 24
	c0 00 00 00	 movzx	 r8d, BYTE PTR akey$[rsp]
  00851	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00854	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0085c	e8 00 00 00 00	 call	 z900_is_fetch_protected
  00861	0f b6 c0	 movzx	 eax, al
  00864	85 c0		 test	 eax, eax
  00866	74 0a		 je	 SHORT $LN61@z900_logic
  00868	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv395[rsp], 1
  00870	eb 08		 jmp	 SHORT $LN62@z900_logic
$LN61@z900_logic:
  00872	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv395[rsp], 0
$LN62@z900_logic:
  0087a	83 7c 24 40 00	 cmp	 DWORD PTR tv395[rsp], 0
  0087f	74 49		 je	 SHORT $LN27@z900_logic

; 2484 :         {
; 2485 :             if (SIE_MODE(regs)) HOSTREGS->dat.protect = 0;

  00881	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00889	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0088f	d1 e8		 shr	 eax, 1
  00891	83 e0 01	 and	 eax, 1
  00894	85 c0		 test	 eax, eax
  00896	74 2d		 je	 SHORT $LN28@z900_logic
  00898	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a0	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  008a7	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  008ad	83 e0 f9	 and	 eax, -7			; fffffff9H
  008b0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008b8	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  008bf	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN28@z900_logic:

; 2486 :             goto vabs_prot_excp;

  008c5	e9 85 05 00 00	 jmp	 $vabs_prot_excp$86
$LN27@z900_logic:

; 2487 :         }
; 2488 : 
; 2489 :         /* Set the reference bit in the storage key */
; 2490 :         ARCH_DEP( or_storage_key_by_ptr )( regs->dat.storkey, STORKEY_REF );

  008ca	b2 04		 mov	 dl, 4
  008cc	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008d4	48 8b 88 28 08
	00 00		 mov	 rcx, QWORD PTR [rax+2088]
  008db	e8 00 00 00 00	 call	 z900_or_storage_key_by_ptr

; 2491 : 
; 2492 :         /* Update accelerated lookup TLB fields */
; 2493 :         regs->tlb.storkey[ix]    = regs->dat.storkey;

  008e0	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  008e5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ed	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008f5	48 8b 92 28 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2088]
  008fc	48 89 94 c1 60
	30 01 00	 mov	 QWORD PTR [rcx+rax*8+77920], rdx

; 2494 :         regs->tlb.skey[ix]       = ARCH_DEP( get_storekey_by_ptr )( regs->dat.storkey ) & STORKEY_KEY;

  00904	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0090c	48 8b 88 28 08
	00 00		 mov	 rcx, QWORD PTR [rax+2088]
  00913	e8 00 00 00 00	 call	 z900_get_storekey_by_ptr
  00918	0f b6 c0	 movzx	 eax, al
  0091b	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00920	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00925	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0092d	88 84 0a 60 50
	01 00		 mov	 BYTE PTR [rdx+rcx+86112], al

; 2495 :         regs->tlb.acc[ix]        = ACC_READ;

  00934	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00939	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00941	c6 84 01 60 5c
	01 00 04	 mov	 BYTE PTR [rcx+rax+89184], 4

; 2496 :         regs->tlb.main[ix]       = NEW_MAINADDR (regs, addr, apfra);

  00949	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00951	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00958	48 03 44 24 60	 add	 rax, QWORD PTR apfra$[rsp]
  0095d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00965	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  0096c	48 33 c1	 xor	 rax, rcx
  0096f	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00974	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0097c	48 89 84 ca 60
	10 01 00	 mov	 QWORD PTR [rdx+rcx*8+69728], rax

; 2497 : 
; 2498 :     }

  00984	e9 92 04 00 00	 jmp	 $LN26@z900_logic
$LN25@z900_logic:

; 2499 :     else /* (acctype & (ACC_WRITE | ACC_CHECK)) */
; 2500 :     {
; 2501 :         /* Program check if store protected location */
; 2502 :         if (unlikely(ARCH_DEP(is_store_protected) (addr, *regs->dat.storkey, akey, regs)))

  00989	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00991	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00998	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  009a0	44 0f b6 84 24
	c0 00 00 00	 movzx	 r8d, BYTE PTR akey$[rsp]
  009a9	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  009ac	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  009b4	e8 00 00 00 00	 call	 z900_is_store_protected
  009b9	0f b6 c0	 movzx	 eax, al
  009bc	85 c0		 test	 eax, eax
  009be	74 0a		 je	 SHORT $LN65@z900_logic
  009c0	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv456[rsp], 1
  009c8	eb 08		 jmp	 SHORT $LN66@z900_logic
$LN65@z900_logic:
  009ca	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv456[rsp], 0
$LN66@z900_logic:
  009d2	83 7c 24 44 00	 cmp	 DWORD PTR tv456[rsp], 0
  009d7	74 49		 je	 SHORT $LN29@z900_logic

; 2503 :         {
; 2504 :             if (SIE_MODE(regs)) HOSTREGS->dat.protect = 0;

  009d9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009e1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  009e7	d1 e8		 shr	 eax, 1
  009e9	83 e0 01	 and	 eax, 1
  009ec	85 c0		 test	 eax, eax
  009ee	74 2d		 je	 SHORT $LN30@z900_logic
  009f0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009f8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  009ff	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00a05	83 e0 f9	 and	 eax, -7			; fffffff9H
  00a08	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a10	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00a17	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN30@z900_logic:

; 2505 :             goto vabs_prot_excp;

  00a1d	e9 2d 04 00 00	 jmp	 $vabs_prot_excp$86
$LN29@z900_logic:

; 2506 :         }
; 2507 :         if (SIE_MODE(regs) && HOSTREGS->dat.protect)

  00a22	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a2a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00a30	d1 e8		 shr	 eax, 1
  00a32	83 e0 01	 and	 eax, 1
  00a35	85 c0		 test	 eax, eax
  00a37	74 23		 je	 SHORT $LN31@z900_logic
  00a39	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a41	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00a48	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00a4e	d1 e8		 shr	 eax, 1
  00a50	83 e0 03	 and	 eax, 3
  00a53	85 c0		 test	 eax, eax
  00a55	74 05		 je	 SHORT $LN31@z900_logic

; 2508 :             goto vabs_prot_excp;

  00a57	e9 f3 03 00 00	 jmp	 $vabs_prot_excp$86
$LN31@z900_logic:

; 2509 : 
; 2510 :         /* Set the reference and change bits in the storage key */
; 2511 :         if (acctype & ACC_WRITE)

  00a5c	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00a63	83 e0 02	 and	 eax, 2
  00a66	85 c0		 test	 eax, eax
  00a68	74 16		 je	 SHORT $LN32@z900_logic

; 2512 :             ARCH_DEP( or_storage_key_by_ptr )( regs->dat.storkey, (STORKEY_REF | STORKEY_CHANGE) );

  00a6a	b2 06		 mov	 dl, 6
  00a6c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a74	48 8b 88 28 08
	00 00		 mov	 rcx, QWORD PTR [rax+2088]
  00a7b	e8 00 00 00 00	 call	 z900_or_storage_key_by_ptr
$LN32@z900_logic:

; 2513 : 
; 2514 :         /* Update accelerated lookup TLB fields */
; 2515 :         regs->tlb.storkey[ix] = regs->dat.storkey;

  00a80	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00a85	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a8d	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a95	48 8b 92 28 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2088]
  00a9c	48 89 94 c1 60
	30 01 00	 mov	 QWORD PTR [rcx+rax*8+77920], rdx

; 2516 :         regs->tlb.skey[ix]    = ARCH_DEP( get_storekey_by_ptr )( regs->dat.storkey ) & STORKEY_KEY;

  00aa4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aac	48 8b 88 28 08
	00 00		 mov	 rcx, QWORD PTR [rax+2088]
  00ab3	e8 00 00 00 00	 call	 z900_get_storekey_by_ptr
  00ab8	0f b6 c0	 movzx	 eax, al
  00abb	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00ac0	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00ac5	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00acd	88 84 0a 60 50
	01 00		 mov	 BYTE PTR [rdx+rcx+86112], al

; 2517 :         regs->tlb.acc[ix]     = (addr >= PSA_SIZE || regs->dat.pvtaddr)

  00ad4	48 81 bc 24 a0
	00 00 00 00 20
	00 00		 cmp	 QWORD PTR addr$[rsp], 8192 ; 00002000H
  00ae0	73 1f		 jae	 SHORT $LN67@z900_logic
  00ae2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aea	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00af0	83 e0 01	 and	 eax, 1
  00af3	85 c0		 test	 eax, eax
  00af5	75 0a		 jne	 SHORT $LN67@z900_logic
  00af7	c7 44 24 48 04
	00 00 00	 mov	 DWORD PTR tv505[rsp], 4
  00aff	eb 0e		 jmp	 SHORT $LN68@z900_logic
$LN67@z900_logic:
  00b01	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00b08	83 c8 05	 or	 eax, 5
  00b0b	89 44 24 48	 mov	 DWORD PTR tv505[rsp], eax
$LN68@z900_logic:
  00b0f	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00b14	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b1c	0f b6 54 24 48	 movzx	 edx, BYTE PTR tv505[rsp]
  00b21	88 94 01 60 5c
	01 00		 mov	 BYTE PTR [rcx+rax+89184], dl

; 2518 :                               ? (ACC_READ | ACC_CHECK | acctype)
; 2519 :                               :  ACC_READ;
; 2520 :         regs->tlb.main[ix]    = NEW_MAINADDR (regs, addr, apfra);

  00b28	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b30	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00b37	48 03 44 24 60	 add	 rax, QWORD PTR apfra$[rsp]
  00b3c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00b44	48 81 e1 00 f0
	ff ff		 and	 rcx, -4096		; fffffffffffff000H
  00b4b	48 33 c1	 xor	 rax, rcx
  00b4e	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00b53	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b5b	48 89 84 ca 60
	10 01 00	 mov	 QWORD PTR [rdx+rcx*8+69728], rax

; 2521 : 
; 2522 : #if defined( FEATURE_PER )
; 2523 :         if (EN_IC_PER_SA( regs ))

  00b63	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b6b	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00b71	c1 e8 02	 shr	 eax, 2
  00b74	83 e0 01	 and	 eax, 1
  00b77	85 c0		 test	 eax, eax
  00b79	74 0a		 je	 SHORT $LN71@z900_logic
  00b7b	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv525[rsp], 1
  00b83	eb 08		 jmp	 SHORT $LN72@z900_logic
$LN71@z900_logic:
  00b85	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv525[rsp], 0
$LN72@z900_logic:
  00b8d	83 7c 24 4c 00	 cmp	 DWORD PTR tv525[rsp], 0
  00b92	0f 84 83 02 00
	00		 je	 $LN33@z900_logic
  00b98	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ba0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00ba3	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00ba8	85 c0		 test	 eax, eax
  00baa	0f 84 6b 02 00
	00		 je	 $LN33@z900_logic

; 2524 :         {
; 2525 :             regs->tlb.acc[ix] = ACC_READ;

  00bb0	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00bb5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bbd	c6 84 01 60 5c
	01 00 04	 mov	 BYTE PTR [rcx+rax+89184], 4

; 2526 :             if (1
; 2527 :                 && arn != USE_REAL_ADDR
; 2528 : #if defined( FEATURE_PER2 )
; 2529 :                 && (0
; 2530 :                     || REAL_MODE( &regs->psw )
; 2531 :                     || ARCH_DEP( check_sa_per2 )( arn, acctype, regs )
; 2532 :                    )
; 2533 : #endif /* defined( FEATURE_PER2 ) */
; 2534 :                 /* Check that the range that was altered is within the PER SA range */
; 2535 :                 && PER_RANGE_CHECK2( addr, addr+(len-1), regs->CR(10), regs->CR(11))
; 2536 :                 && !IS_PER_SUPRESS( regs, CR9_SA )

  00bc5	33 c0		 xor	 eax, eax
  00bc7	83 f8 01	 cmp	 eax, 1
  00bca	0f 84 4b 02 00
	00		 je	 $LN34@z900_logic
  00bd0	83 bc 24 a8 00
	00 00 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00bd8	0f 84 3d 02 00
	00		 je	 $LN34@z900_logic
  00bde	33 c0		 xor	 eax, eax
  00be0	85 c0		 test	 eax, eax
  00be2	75 39		 jne	 SHORT $LN35@z900_logic
  00be4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bec	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00bf0	83 e0 04	 and	 eax, 4
  00bf3	85 c0		 test	 eax, eax
  00bf5	74 26		 je	 SHORT $LN35@z900_logic
  00bf7	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00bff	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR acctype$[rsp]
  00c06	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR arn$[rsp]
  00c0d	e8 00 00 00 00	 call	 z900_check_sa_per2
  00c12	0f b6 c0	 movzx	 eax, al
  00c15	85 c0		 test	 eax, eax
  00c17	0f 84 fe 01 00
	00		 je	 $LN34@z900_logic
$LN35@z900_logic:
  00c1d	b8 08 00 00 00	 mov	 eax, 8
  00c22	48 6b c0 0c	 imul	 rax, rax, 12
  00c26	b9 08 00 00 00	 mov	 ecx, 8
  00c2b	48 6b c9 0b	 imul	 rcx, rcx, 11
  00c2f	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c37	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00c3f	49 8b 8c 08 00
	06 00 00	 mov	 rcx, QWORD PTR [r8+rcx+1536]
  00c47	48 39 8c 02 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax+1536], rcx
  00c4f	0f 82 19 01 00
	00		 jb	 $LN80@z900_logic
  00c55	b8 08 00 00 00	 mov	 eax, 8
  00c5a	48 6b c0 0b	 imul	 rax, rax, 11
  00c5e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c66	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00c6e	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR addr$[rsp], rax
  00c76	72 27		 jb	 SHORT $LN73@z900_logic
  00c78	b8 08 00 00 00	 mov	 eax, 8
  00c7d	48 6b c0 0c	 imul	 rax, rax, 12
  00c81	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c89	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00c91	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR addr$[rsp], rax
  00c99	0f 86 bd 00 00
	00		 jbe	 $LN75@z900_logic
$LN73@z900_logic:
  00c9f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00ca7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00caf	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00cb4	b9 08 00 00 00	 mov	 ecx, 8
  00cb9	48 6b c9 0b	 imul	 rcx, rcx, 11
  00cbd	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00cc5	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  00ccd	72 30		 jb	 SHORT $LN74@z900_logic
  00ccf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00cd7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00cdf	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00ce4	b9 08 00 00 00	 mov	 ecx, 8
  00ce9	48 6b c9 0c	 imul	 rcx, rcx, 12
  00ced	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00cf5	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  00cfd	76 5d		 jbe	 SHORT $LN75@z900_logic
$LN74@z900_logic:
  00cff	b8 08 00 00 00	 mov	 eax, 8
  00d04	48 6b c0 0b	 imul	 rax, rax, 11
  00d08	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d10	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00d18	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR addr$[rsp], rax
  00d20	77 30		 ja	 SHORT $LN76@z900_logic
  00d22	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00d2a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00d32	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00d37	b9 08 00 00 00	 mov	 ecx, 8
  00d3c	48 6b c9 0c	 imul	 rcx, rcx, 12
  00d40	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00d48	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  00d50	73 0a		 jae	 SHORT $LN75@z900_logic
$LN76@z900_logic:
  00d52	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv605[rsp], 0
  00d5a	eb 08		 jmp	 SHORT $LN79@z900_logic
$LN75@z900_logic:
  00d5c	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv605[rsp], 1
$LN79@z900_logic:
  00d64	8b 44 24 50	 mov	 eax, DWORD PTR tv605[rsp]
  00d68	89 44 24 58	 mov	 DWORD PTR tv606[rsp], eax
  00d6c	eb 6d		 jmp	 SHORT $LN81@z900_logic
$LN80@z900_logic:
  00d6e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00d76	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00d7e	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00d83	b9 08 00 00 00	 mov	 ecx, 8
  00d88	48 6b c9 0b	 imul	 rcx, rcx, 11
  00d8c	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00d94	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  00d9c	73 2d		 jae	 SHORT $LN77@z900_logic
  00d9e	b8 08 00 00 00	 mov	 eax, 8
  00da3	48 6b c0 0c	 imul	 rax, rax, 12
  00da7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00daf	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00db7	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR addr$[rsp], rax
  00dbf	76 0a		 jbe	 SHORT $LN77@z900_logic
  00dc1	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv604[rsp], 0
  00dc9	eb 08		 jmp	 SHORT $LN78@z900_logic
$LN77@z900_logic:
  00dcb	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv604[rsp], 1
$LN78@z900_logic:
  00dd3	8b 44 24 54	 mov	 eax, DWORD PTR tv604[rsp]
  00dd7	89 44 24 58	 mov	 DWORD PTR tv606[rsp], eax
$LN81@z900_logic:
  00ddb	83 7c 24 58 00	 cmp	 DWORD PTR tv606[rsp], 0
  00de0	74 39		 je	 SHORT $LN34@z900_logic
  00de2	ba 00 00 00 20	 mov	 edx, 536870912		; 20000000H
  00de7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00def	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00df4	0f b6 c0	 movzx	 eax, al
  00df7	85 c0		 test	 eax, eax
  00df9	75 20		 jne	 SHORT $LN34@z900_logic
$LN4@z900_logic:

; 2537 :             )
; 2538 :                 ON_IC_PER_SA( regs );

  00dfb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e03	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00e06	0f ba e8 15	 bts	 eax, 21
  00e0a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e12	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00e15	33 c0		 xor	 eax, eax
  00e17	85 c0		 test	 eax, eax
  00e19	75 e0		 jne	 SHORT $LN4@z900_logic
$LN34@z900_logic:
$LN33@z900_logic:
$LN26@z900_logic:

; 2539 :         }
; 2540 : #endif /* defined( FEATURE_PER ) */
; 2541 :     } /* (acctype & (ACC_WRITE | ACC_CHECK)) */
; 2542 : 
; 2543 :     /* Return mainstor address */
; 2544 :     return regs->mainstor + aaddr;

  00e1b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e23	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00e2a	48 03 44 24 28	 add	 rax, QWORD PTR aaddr$[rsp]
  00e2f	e9 ab 02 00 00	 jmp	 $LN1@z900_logic
$vabs_addr_excp$87:

; 2545 : 
; 2546 : vabs_addr_excp:
; 2547 : 
; 2548 :     regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);

  00e34	ba 05 00 00 00	 mov	 edx, 5
  00e39	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e41	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e49	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$vabs_prot_excp$86:

; 2549 : 
; 2550 : vabs_prot_excp:
; 2551 : 
; 2552 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 2553 :     regs->TEA = addr & STORAGE_KEY_PAGEMASK;

  00e4f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00e57	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00e5d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e65	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax

; 2554 :     if (regs->dat.protect && (acctype & (ACC_WRITE|ACC_CHECK)) )

  00e6c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e74	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00e7a	d1 e8		 shr	 eax, 1
  00e7c	83 e0 03	 and	 eax, 3
  00e7f	85 c0		 test	 eax, eax
  00e81	74 6c		 je	 SHORT $LN36@z900_logic
  00e83	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00e8a	83 e0 03	 and	 eax, 3
  00e8d	85 c0		 test	 eax, eax
  00e8f	74 5e		 je	 SHORT $LN36@z900_logic

; 2555 :     {
; 2556 :         regs->TEA |= TEA_PROT_AP;

  00e91	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e99	48 8b 80 18 07
	00 00		 mov	 rax, QWORD PTR [rax+1816]
  00ea0	48 83 c8 04	 or	 rax, 4
  00ea4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00eac	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax

; 2557 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 2558 :         if (regs->dat.protect & 2)

  00eb3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ebb	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00ec1	d1 e8		 shr	 eax, 1
  00ec3	83 e0 03	 and	 eax, 3
  00ec6	83 e0 02	 and	 eax, 2
  00ec9	85 c0		 test	 eax, eax
  00ecb	74 22		 je	 SHORT $LN37@z900_logic

; 2559 :             regs->TEA |= TEA_PROT_A;

  00ecd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ed5	48 8b 80 18 07
	00 00		 mov	 rax, QWORD PTR [rax+1816]
  00edc	48 83 c8 08	 or	 rax, 8
  00ee0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ee8	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax
$LN37@z900_logic:
$LN36@z900_logic:

; 2560 : #endif
; 2561 :     }
; 2562 :     regs->TEA |= regs->dat.stid;

  00eef	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ef7	48 63 80 20 08
	00 00		 movsxd	 rax, DWORD PTR [rax+2080]
  00efe	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f06	48 8b 89 18 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1816]
  00f0d	48 0b c8	 or	 rcx, rax
  00f10	48 8b c1	 mov	 rax, rcx
  00f13	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f1b	48 89 81 18 07
	00 00		 mov	 QWORD PTR [rcx+1816], rax

; 2563 :     regs->excarid = (arn > 0 ? arn : 0);

  00f22	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  00f2a	7e 0d		 jle	 SHORT $LN82@z900_logic
  00f2c	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00f33	89 44 24 5c	 mov	 DWORD PTR tv648[rsp], eax
  00f37	eb 08		 jmp	 SHORT $LN83@z900_logic
$LN82@z900_logic:
  00f39	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv648[rsp], 0
$LN83@z900_logic:
  00f41	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f49	0f b6 4c 24 5c	 movzx	 ecx, BYTE PTR tv648[rsp]
  00f4e	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl

; 2564 : #endif /* defined( FEATURE_SUPPRESSION_ON_PROTECTION ) */
; 2565 : 
; 2566 : #if defined( _FEATURE_PROTECTION_INTERCEPTION_CONTROL )
; 2567 :     if (SIE_MODE( regs ) && HOSTREGS->dat.protect)

  00f54	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f5c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00f62	d1 e8		 shr	 eax, 1
  00f64	83 e0 01	 and	 eax, 1
  00f67	85 c0		 test	 eax, eax
  00f69	0f 84 2c 01 00
	00		 je	 $LN38@z900_logic
  00f6f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f77	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00f7e	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00f84	d1 e8		 shr	 eax, 1
  00f86	83 e0 03	 and	 eax, 3
  00f89	85 c0		 test	 eax, eax
  00f8b	0f 84 0a 01 00
	00		 je	 $LN38@z900_logic

; 2568 :     {
; 2569 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 2570 : 
; 2571 :         switch (HOSTREGS->arch_mode)

  00f91	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f99	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00fa0	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00fa3	89 44 24 24	 mov	 DWORD PTR tv661[rsp], eax
  00fa7	83 7c 24 24 00	 cmp	 DWORD PTR tv661[rsp], 0
  00fac	74 10		 je	 SHORT $LN40@z900_logic
  00fae	83 7c 24 24 01	 cmp	 DWORD PTR tv661[rsp], 1
  00fb3	74 2e		 je	 SHORT $LN41@z900_logic
  00fb5	83 7c 24 24 02	 cmp	 DWORD PTR tv661[rsp], 2
  00fba	74 4c		 je	 SHORT $LN42@z900_logic
  00fbc	eb 71		 jmp	 SHORT $LN43@z900_logic
$LN40@z900_logic:

; 2572 :         {
; 2573 :         case ARCH_370_IDX: HOSTREGS->TEA_370 = regs->TEA; break;

  00fbe	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fc6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00fcd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fd5	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  00fdb	89 88 18 07 00
	00		 mov	 DWORD PTR [rax+1816], ecx
  00fe1	eb 69		 jmp	 SHORT $LN5@z900_logic
$LN41@z900_logic:

; 2574 :         case ARCH_390_IDX: HOSTREGS->TEA_390 = regs->TEA; break;

  00fe3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00feb	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00ff2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ffa	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  01000	89 88 18 07 00
	00		 mov	 DWORD PTR [rax+1816], ecx
  01006	eb 44		 jmp	 SHORT $LN5@z900_logic
$LN42@z900_logic:

; 2575 :         case ARCH_900_IDX: HOSTREGS->TEA_900 = regs->TEA; break;

  01008	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01010	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  01017	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0101f	48 8b 89 18 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1816]
  01026	48 89 88 18 07
	00 00		 mov	 QWORD PTR [rax+1816], rcx
  0102d	eb 1d		 jmp	 SHORT $LN5@z900_logic
$LN43@z900_logic:
$LN9@z900_logic:

; 2576 :         default: CRASH();

  0102f	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$1[rsp], 0
  0103b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$1[rsp]
  01043	c6 00 00	 mov	 BYTE PTR [rax], 0
  01046	33 c0		 xor	 eax, eax
  01048	85 c0		 test	 eax, eax
  0104a	75 e3		 jne	 SHORT $LN9@z900_logic
$LN5@z900_logic:

; 2577 :         }
; 2578 : 
; 2579 :         HOSTREGS->excarid = regs->excarid;

  0104c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01054	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0105b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01063	0f b6 89 3e 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2110]
  0106a	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl

; 2580 : 
; 2581 : #endif /* defined( FEATURE_SUPPRESSION_ON_PROTECTION ) */
; 2582 : 
; 2583 :         HOSTREGS->program_interrupt( HOSTREGS, PGM_PROTECTION_EXCEPTION );

  01070	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01078	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0107f	ba 04 00 00 00	 mov	 edx, 4
  01084	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0108c	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  01093	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]

; 2584 :     }

  01099	eb 1b		 jmp	 SHORT $LN39@z900_logic
$LN38@z900_logic:

; 2585 :     else
; 2586 : #endif /* defined( _FEATURE_PROTECTION_INTERCEPTION_CONTROL ) */
; 2587 :         regs->program_interrupt (regs, PGM_PROTECTION_EXCEPTION);

  0109b	ba 04 00 00 00	 mov	 edx, 4
  010a0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010a8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010b0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN39@z900_logic:
$vabs_prog_check$85:

; 2588 : 
; 2589 : vabs_prog_check:
; 2590 : 
; 2591 :     regs->program_interrupt (regs, regs->dat.xcode);

  010b6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010be	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  010c5	8b d0		 mov	 edx, eax
  010c7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010cf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010d7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]

; 2592 : 
; 2593 :     return NULL; /* prevent warning from compiler */

  010dd	33 c0		 xor	 eax, eax
$LN1@z900_logic:

; 2594 : } /* end function ARCH_DEP(logical_to_main_l) */

  010df	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  010e6	c3		 ret	 0
z900_logical_to_main_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
ix$ = 32
tv701 = 36
aaddr$ = 40
tv230 = 48
tv251 = 52
tv257 = 56
tv358 = 60
tv399 = 64
tv406 = 68
tv428 = 72
tv490 = 76
tv539 = 80
tv560 = 84
tv658 = 88
tv657 = 92
tv659 = 96
tv688 = 100
apfra$ = 104
tv176 = 112
tv192 = 120
tv760 = 128
p$1 = 136
addr$ = 160
arn$ = 168
regs$ = 176
acctype$ = 184
akey$ = 192
len$ = 200
s390_logical_to_main_l PROC

; 2362 : {

$LN87:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2363 : RADR    aaddr;                          /* Absolute address          */
; 2364 : RADR    apfra;                          /* Abs page frame address    */
; 2365 : int     ix = TLBIX(addr);               /* TLB index                 */

  00019	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	c1 e8 0c	 shr	 eax, 12
  00023	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00028	89 44 24 20	 mov	 DWORD PTR ix$[rsp], eax

; 2366 : 
; 2367 :     /* Convert logical address to real address */
; 2368 :     if ( (REAL_MODE(&regs->psw) || arn == USE_REAL_ADDR)
; 2369 : #if defined( FEATURE_SIE )
; 2370 :       /* Under SIE guest real is always host primary, regardless
; 2371 :          of the DAT mode */
; 2372 :       && !(regs->sie_active

  0002c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00034	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00038	83 e0 04	 and	 eax, 4
  0003b	85 c0		 test	 eax, eax
  0003d	74 0e		 je	 SHORT $LN12@s390_logic
  0003f	83 bc 24 a8 00
	00 00 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00047	0f 85 31 01 00
	00		 jne	 $LN10@s390_logic
$LN12@s390_logic:
  0004d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00055	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0005b	83 e0 01	 and	 eax, 1
  0005e	85 c0		 test	 eax, eax
  00060	0f 85 18 01 00
	00		 jne	 $LN10@s390_logic

; 2373 : #if !defined( _FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 2374 :                             && arn == USE_PRIMARY_SPACE
; 2375 : #else
; 2376 : //                          && ( (arn == USE_PRIMARY_SPACE)
; 2377 : //                               || SIE_STATE_BIT_ON(GUESTREGS, MX, XC) )
; 2378 : #endif /* defined( _FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE ) */
; 2379 :           )
; 2380 : #endif /* defined( FEATURE_SIE ) */
; 2381 :        )
; 2382 :     {
; 2383 :         regs->dat.pvtaddr = regs->dat.protect = 0;

  00066	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00074	83 e0 f9	 and	 eax, -7			; fffffff9H
  00077	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007f	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
  00085	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00093	83 e0 fe	 and	 eax, -2			; fffffffeH
  00096	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 2384 :         regs->dat.raddr = addr;

  000a4	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000ab	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 89 81 00 08
	00 00		 mov	 QWORD PTR [rcx+2048], rax

; 2385 :         regs->dat.rpfra = addr & PAGEFRAME_PAGEMASK;

  000ba	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000c1	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  000c6	8b c0		 mov	 eax, eax
  000c8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d0	48 89 81 10 08
	00 00		 mov	 QWORD PTR [rcx+2064], rax

; 2386 : 
; 2387 :         /* Setup `real' TLB entry (for MADDR) */
; 2388 :         regs->tlb.TLB_ASD(ix)   = TLB_REAL_ASD;

  000d7	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  000dc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e4	c7 84 c1 60 b0
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*8+45152], -1 ; ffffffffH

; 2389 :         regs->tlb.TLB_VADDR(ix) = (addr & TLBID_PAGEMASK) | regs->tlbID;

  000ef	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000f6	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  000fb	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00103	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00109	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0010e	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00116	89 84 ca 60 d0
	00 00		 mov	 DWORD PTR [rdx+rcx*8+53344], eax

; 2390 :         regs->tlb.TLB_PTE(ix)   = addr & TLBID_PAGEMASK;

  0011d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00124	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  00129	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0012e	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00136	89 84 ca 60 f0
	00 00		 mov	 DWORD PTR [rdx+rcx*8+61536], eax

; 2391 :         regs->tlb.acc[ix]       =

  0013d	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00142	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014a	c6 84 01 60 58
	01 00 00	 mov	 BYTE PTR [rcx+rax+88160], 0
  00152	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00157	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015f	c6 84 01 60 54
	01 00 00	 mov	 BYTE PTR [rcx+rax+87136], 0
  00167	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  0016c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00174	c6 84 01 60 5c
	01 00 00	 mov	 BYTE PTR [rcx+rax+89184], 0

; 2392 :         regs->tlb.common[ix]    =
; 2393 :         regs->tlb.protect[ix]   = 0;
; 2394 :     }

  0017c	eb 2c		 jmp	 SHORT $LN11@s390_logic
$LN10@s390_logic:

; 2395 :     else {
; 2396 :         if (ARCH_DEP(translate_addr) (addr, arn, regs, acctype))

  0017e	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  00186	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0018e	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR arn$[rsp]
  00195	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0019c	e8 00 00 00 00	 call	 s390_translate_addr
  001a1	85 c0		 test	 eax, eax
  001a3	74 05		 je	 SHORT $LN13@s390_logic

; 2397 :             goto vabs_prog_check;

  001a5	e9 76 0f 00 00	 jmp	 $vabs_prog_check$88
$LN13@s390_logic:
$LN11@s390_logic:

; 2398 :     }
; 2399 : 
; 2400 :     if (regs->dat.protect
; 2401 :      && (acctype & (ACC_WRITE|ACC_CHECK)))

  001aa	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b2	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  001b8	d1 e8		 shr	 eax, 1
  001ba	83 e0 03	 and	 eax, 3
  001bd	85 c0		 test	 eax, eax
  001bf	74 13		 je	 SHORT $LN14@s390_logic
  001c1	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  001c8	83 e0 03	 and	 eax, 3
  001cb	85 c0		 test	 eax, eax
  001cd	74 05		 je	 SHORT $LN14@s390_logic

; 2402 :         goto vabs_prot_excp;

  001cf	e9 2f 0d 00 00	 jmp	 $vabs_prot_excp$89
$LN14@s390_logic:

; 2403 : 
; 2404 :     /* Convert real address to absolute address */
; 2405 :     regs->dat.aaddr = aaddr = APPLY_PREFIXING (regs->dat.raddr, regs->PX);

  001d4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001dc	8b 80 00 08 00
	00		 mov	 eax, DWORD PTR [rax+2048]
  001e2	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  001e8	48 85 c0	 test	 rax, rax
  001eb	74 3a		 je	 SHORT $LN44@s390_logic
  001ed	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f5	8b 80 00 08 00
	00		 mov	 eax, DWORD PTR [rax+2048]
  001fb	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00201	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00209	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0020c	48 3b c1	 cmp	 rax, rcx
  0020f	74 16		 je	 SHORT $LN44@s390_logic
  00211	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00219	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  00220	48 89 44 24 70	 mov	 QWORD PTR tv176[rsp], rax
  00225	eb 22		 jmp	 SHORT $LN45@s390_logic
$LN44@s390_logic:
  00227	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00237	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0023a	8b 80 00 08 00
	00		 mov	 eax, DWORD PTR [rax+2048]
  00240	33 c1		 xor	 eax, ecx
  00242	8b c0		 mov	 eax, eax
  00244	48 89 44 24 70	 mov	 QWORD PTR tv176[rsp], rax
$LN45@s390_logic:
  00249	48 8b 44 24 70	 mov	 rax, QWORD PTR tv176[rsp]
  0024e	48 89 44 24 28	 mov	 QWORD PTR aaddr$[rsp], rax
  00253	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00260	48 89 88 08 08
	00 00		 mov	 QWORD PTR [rax+2056], rcx

; 2406 :     apfra=APPLY_PREFIXING(regs->dat.rpfra,regs->PX);

  00267	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026f	8b 80 10 08 00
	00		 mov	 eax, DWORD PTR [rax+2064]
  00275	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0027b	48 85 c0	 test	 rax, rax
  0027e	74 3a		 je	 SHORT $LN46@s390_logic
  00280	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00288	8b 80 10 08 00
	00		 mov	 eax, DWORD PTR [rax+2064]
  0028e	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00294	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029c	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0029f	48 3b c1	 cmp	 rax, rcx
  002a2	74 16		 je	 SHORT $LN46@s390_logic
  002a4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ac	48 8b 80 10 08
	00 00		 mov	 rax, QWORD PTR [rax+2064]
  002b3	48 89 44 24 78	 mov	 QWORD PTR tv192[rsp], rax
  002b8	eb 22		 jmp	 SHORT $LN47@s390_logic
$LN46@s390_logic:
  002ba	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ca	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  002cd	8b 80 10 08 00
	00		 mov	 eax, DWORD PTR [rax+2064]
  002d3	33 c1		 xor	 eax, ecx
  002d5	8b c0		 mov	 eax, eax
  002d7	48 89 44 24 78	 mov	 QWORD PTR tv192[rsp], rax
$LN47@s390_logic:
  002dc	48 8b 44 24 78	 mov	 rax, QWORD PTR tv192[rsp]
  002e1	48 89 44 24 68	 mov	 QWORD PTR apfra$[rsp], rax

; 2407 : 
; 2408 :     /* Program check if absolute address is outside main storage */
; 2409 :     if (regs->dat.aaddr > regs->mainlim)

  002e6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ee	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f6	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  002fd	48 39 88 08 08
	00 00		 cmp	 QWORD PTR [rax+2056], rcx
  00304	76 05		 jbe	 SHORT $LN15@s390_logic

; 2410 :         goto vabs_addr_excp;

  00306	e9 dd 0b 00 00	 jmp	 $vabs_addr_excp$90
$LN15@s390_logic:

; 2411 : 
; 2412 : #if defined( _FEATURE_SIE )
; 2413 :     if(SIE_MODE(regs)) HOSTREGS->dat.protect = 0;

  0030b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00313	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00319	d1 e8		 shr	 eax, 1
  0031b	83 e0 01	 and	 eax, 1
  0031e	85 c0		 test	 eax, eax
  00320	74 2d		 je	 SHORT $LN16@s390_logic
  00322	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0032a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00331	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00337	83 e0 f9	 and	 eax, -7			; fffffff9H
  0033a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00342	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00349	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN16@s390_logic:

; 2414 :     if(SIE_MODE(regs)  && !regs->sie_pref)

  0034f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00357	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0035d	d1 e8		 shr	 eax, 1
  0035f	83 e0 01	 and	 eax, 1
  00362	85 c0		 test	 eax, eax
  00364	0f 84 c5 04 00
	00		 je	 $LN17@s390_logic
  0036a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00372	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00378	c1 e8 02	 shr	 eax, 2
  0037b	83 e0 01	 and	 eax, 1
  0037e	85 c0		 test	 eax, eax
  00380	0f 85 a9 04 00
	00		 jne	 $LN17@s390_logic

; 2415 :     {
; 2416 :         if (SIE_TRANSLATE_ADDR (regs->sie_mso + regs->dat.aaddr,

  00386	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00395	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  00399	0f 85 90 00 00
	00		 jne	 $LN52@s390_logic
  0039f	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  003a7	7e 3a		 jle	 SHORT $LN48@s390_logic
  003a9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b1	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  003b8	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  003bc	83 e0 01	 and	 eax, 1
  003bf	85 c0		 test	 eax, eax
  003c1	74 20		 je	 SHORT $LN48@s390_logic
  003c3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003cb	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  003cf	83 e0 40	 and	 eax, 64			; 00000040H
  003d2	85 c0		 test	 eax, eax
  003d4	74 0d		 je	 SHORT $LN48@s390_logic
  003d6	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  003dd	89 44 24 30	 mov	 DWORD PTR tv230[rsp], eax
  003e1	eb 08		 jmp	 SHORT $LN49@s390_logic
$LN48@s390_logic:
  003e3	c7 44 24 30 fd
	ff ff ff	 mov	 DWORD PTR tv230[rsp], -3
$LN49@s390_logic:
  003eb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f3	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  003fa	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00402	48 03 81 08 08
	00 00		 add	 rax, QWORD PTR [rcx+2056]
  00409	45 33 c9	 xor	 r9d, r9d
  0040c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00414	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  0041b	8b 54 24 30	 mov	 edx, DWORD PTR tv230[rsp]
  0041f	8b c8		 mov	 ecx, eax
  00421	e8 00 00 00 00	 call	 s390_translate_addr
  00426	89 44 24 38	 mov	 DWORD PTR tv257[rsp], eax
  0042a	e9 8c 00 00 00	 jmp	 $LN53@s390_logic
$LN52@s390_logic:
  0042f	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  00437	7e 3a		 jle	 SHORT $LN50@s390_logic
  00439	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00441	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00448	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0044c	83 e0 01	 and	 eax, 1
  0044f	85 c0		 test	 eax, eax
  00451	74 20		 je	 SHORT $LN50@s390_logic
  00453	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045b	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0045f	83 e0 40	 and	 eax, 64			; 00000040H
  00462	85 c0		 test	 eax, eax
  00464	74 0d		 je	 SHORT $LN50@s390_logic
  00466	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  0046d	89 44 24 34	 mov	 DWORD PTR tv251[rsp], eax
  00471	eb 08		 jmp	 SHORT $LN51@s390_logic
$LN50@s390_logic:
  00473	c7 44 24 34 fd
	ff ff ff	 mov	 DWORD PTR tv251[rsp], -3
$LN51@s390_logic:
  0047b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00483	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  0048a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00492	48 03 81 08 08
	00 00		 add	 rax, QWORD PTR [rcx+2056]
  00499	45 33 c9	 xor	 r9d, r9d
  0049c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a4	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  004ab	8b 54 24 34	 mov	 edx, DWORD PTR tv251[rsp]
  004af	48 8b c8	 mov	 rcx, rax
  004b2	e8 00 00 00 00	 call	 z900_translate_addr
  004b7	89 44 24 38	 mov	 DWORD PTR tv257[rsp], eax
$LN53@s390_logic:
  004bb	83 7c 24 38 00	 cmp	 DWORD PTR tv257[rsp], 0
  004c0	74 4c		 je	 SHORT $LN18@s390_logic

; 2417 :                     (arn > 0 && MULTIPLE_CONTROLLED_DATA_SPACE(regs)) ? arn : USE_PRIMARY_SPACE,
; 2418 :                     HOSTREGS, ACCTYPE_SIE))
; 2419 :             (HOSTREGS->program_interrupt) (HOSTREGS, HOSTREGS->dat.xcode);

  004c2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ca	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  004d1	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  004d8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e0	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  004e7	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv760[rsp], rcx
  004ef	8b d0		 mov	 edx, eax
  004f1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f9	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00500	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv760[rsp]
  00508	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN18@s390_logic:

; 2420 : 
; 2421 :         regs->dat.protect     |= HOSTREGS->dat.protect;

  0050e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00516	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0051c	d1 e8		 shr	 eax, 1
  0051e	83 e0 03	 and	 eax, 3
  00521	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00529	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00530	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  00536	d1 e9		 shr	 ecx, 1
  00538	83 e1 03	 and	 ecx, 3
  0053b	0b c1		 or	 eax, ecx
  0053d	83 e0 03	 and	 eax, 3
  00540	d1 e0		 shl	 eax, 1
  00542	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0054a	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  00550	83 e1 f9	 and	 ecx, -7			; fffffff9H
  00553	0b c8		 or	 ecx, eax
  00555	8b c1		 mov	 eax, ecx
  00557	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0055f	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 2422 :         regs->tlb.protect[ix] |= HOSTREGS->dat.protect;

  00565	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  0056a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00572	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00579	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  0057f	d1 e9		 shr	 ecx, 1
  00581	83 e1 03	 and	 ecx, 3
  00584	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0058c	0f b6 84 02 60
	58 01 00	 movzx	 eax, BYTE PTR [rdx+rax+88160]
  00594	0b c1		 or	 eax, ecx
  00596	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0059b	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005a3	88 84 0a 60 58
	01 00		 mov	 BYTE PTR [rdx+rcx+88160], al

; 2423 : 
; 2424 :         if ( REAL_MODE(&regs->psw) || (arn == USE_REAL_ADDR) )

  005aa	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b2	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  005b6	83 e0 04	 and	 eax, 4
  005b9	85 c0		 test	 eax, eax
  005bb	74 0a		 je	 SHORT $LN20@s390_logic
  005bd	83 bc 24 a8 00
	00 00 fe	 cmp	 DWORD PTR arn$[rsp], -2
  005c5	75 20		 jne	 SHORT $LN19@s390_logic
$LN20@s390_logic:

; 2425 :             regs->tlb.TLB_PTE(ix)   = addr & TLBID_PAGEMASK;

  005c7	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  005ce	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  005d3	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  005d8	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005e0	89 84 ca 60 f0
	00 00		 mov	 DWORD PTR [rdx+rcx*8+61536], eax
$LN19@s390_logic:

; 2426 : 
; 2427 :         /* Indicate a host real space entry for a XC dataspace */
; 2428 :         if (arn > 0 && MULTIPLE_CONTROLLED_DATA_SPACE(regs))

  005e7	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  005ef	0f 8e 8e 01 00
	00		 jle	 $LN21@s390_logic
  005f5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005fd	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00604	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00608	83 e0 01	 and	 eax, 1
  0060b	85 c0		 test	 eax, eax
  0060d	0f 84 70 01 00
	00		 je	 $LN21@s390_logic
  00613	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0061b	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0061f	83 e0 40	 and	 eax, 64			; 00000040H
  00622	85 c0		 test	 eax, eax
  00624	0f 84 59 01 00
	00		 je	 $LN21@s390_logic

; 2429 :         {
; 2430 :             regs->tlb.TLB_ASD(ix) = regs->dat.asd;

  0062a	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  0062f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00637	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0063f	8b 92 18 08 00
	00		 mov	 edx, DWORD PTR [rdx+2072]
  00645	89 94 c1 60 b0
	00 00		 mov	 DWORD PTR [rcx+rax*8+45152], edx

; 2431 :             /* Ensure that the private bit is percolated to the guest such that LAP is applied correctly */
; 2432 :             regs->dat.pvtaddr = HOSTREGS->dat.pvtaddr;

  0064c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00654	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0065b	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00661	83 e0 01	 and	 eax, 1
  00664	83 e0 01	 and	 eax, 1
  00667	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0066f	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  00675	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00678	0b c8		 or	 ecx, eax
  0067a	8b c1		 mov	 eax, ecx
  0067c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00684	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 2433 : 
; 2434 :             /* Build tlb entry of XC dataspace */
; 2435 :             regs->dat.asd = HOSTREGS->dat.asd ^ TLB_HOST_ASD;

  0068a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00692	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00699	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  006a0	48 0f ba f8 0b	 btc	 rax, 11
  006a5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006ad	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 2436 :             regs->CR(CR_ALB_OFFSET + arn) = regs->dat.asd;

  006b4	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  006bb	83 c0 11	 add	 eax, 17
  006be	48 98		 cdqe
  006c0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c8	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006d0	8b 92 18 08 00
	00		 mov	 edx, DWORD PTR [rdx+2072]
  006d6	89 94 c1 00 06
	00 00		 mov	 DWORD PTR [rcx+rax*8+1536], edx

; 2437 :             regs->AEA_AR(arn) = CR_ALB_OFFSET + arn;

  006dd	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  006e4	83 c0 10	 add	 eax, 16
  006e7	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR arn$[rsp]
  006ee	83 c1 05	 add	 ecx, 5
  006f1	48 63 c9	 movsxd	 rcx, ecx
  006f4	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006fc	89 84 8a 94 0c
	00 00		 mov	 DWORD PTR [rdx+rcx*4+3220], eax

; 2438 :             regs->AEA_COMMON(CR_ALB_OFFSET + arn) = (regs->dat.asd & ASD_PRIVATE) == 0;

  00703	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0070b	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00712	48 25 00 01 00
	00		 and	 rax, 256		; 00000100H
  00718	48 85 c0	 test	 rax, rax
  0071b	75 0a		 jne	 SHORT $LN54@s390_logic
  0071d	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv358[rsp], 1
  00725	eb 08		 jmp	 SHORT $LN55@s390_logic
$LN54@s390_logic:
  00727	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv358[rsp], 0
$LN55@s390_logic:
  0072f	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00736	83 c0 11	 add	 eax, 17
  00739	48 98		 cdqe
  0073b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00743	0f b6 54 24 3c	 movzx	 edx, BYTE PTR tv358[rsp]
  00748	88 94 01 e8 0c
	00 00		 mov	 BYTE PTR [rcx+rax+3304], dl

; 2439 :             regs->aea_aleprot[arn] = HOSTREGS->dat.protect & 2;

  0074f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00757	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0075e	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00764	d1 e8		 shr	 eax, 1
  00766	83 e0 03	 and	 eax, 3
  00769	83 e0 02	 and	 eax, 2
  0076c	48 63 8c 24 a8
	00 00 00	 movsxd	 rcx, DWORD PTR arn$[rsp]
  00774	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0077c	88 84 0a 09 0d
	00 00		 mov	 BYTE PTR [rdx+rcx+3337], al
$LN21@s390_logic:

; 2440 :         }
; 2441 : 
; 2442 :         /* Convert host real address to host absolute address.
; 2443 :            Use the Prefixing logic of the SIE host, not the guest!
; 2444 :                                                -- ISW 20181005
; 2445 :         */
; 2446 :         HOSTREGS->dat.aaddr =

  00783	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00792	48 8b 90 00 08
	00 00		 mov	 rdx, QWORD PTR [rax+2048]
  00799	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a1	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  007a8	e8 00 00 00 00	 call	 apply_host_prefixing
  007ad	48 89 44 24 28	 mov	 QWORD PTR aaddr$[rsp], rax
  007b2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ba	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  007c1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR aaddr$[rsp]
  007c6	48 89 88 08 08
	00 00		 mov	 QWORD PTR [rax+2056], rcx

; 2447 :         aaddr = apply_host_prefixing( HOSTREGS, HOSTREGS->dat.raddr );
; 2448 :         apfra = apply_host_prefixing( HOSTREGS, HOSTREGS->dat.rpfra );

  007cd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007d5	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  007dc	48 8b 90 10 08
	00 00		 mov	 rdx, QWORD PTR [rax+2064]
  007e3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007eb	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  007f2	e8 00 00 00 00	 call	 apply_host_prefixing
  007f7	48 89 44 24 68	 mov	 QWORD PTR apfra$[rsp], rax

; 2449 : 
; 2450 :         if (HOSTREGS->dat.aaddr > HOSTREGS->mainlim)

  007fc	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00804	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0080b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00813	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  0081a	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  00821	48 39 88 08 08
	00 00		 cmp	 QWORD PTR [rax+2056], rcx
  00828	76 05		 jbe	 SHORT $LN22@s390_logic

; 2451 :             goto vabs_addr_excp;

  0082a	e9 b9 06 00 00	 jmp	 $vabs_addr_excp$90
$LN22@s390_logic:
$LN17@s390_logic:

; 2452 : 
; 2453 :         /* Take into account SIE guests with a 2K page scheme
; 2454 :            because the SIE host may be operating with a 4K page
; 2455 :            system */
; 2456 : #if defined( FEATURE_2K_STORAGE_KEYS )
; 2457 :         if ((addr & PAGEFRAME_PAGEMASK) & 0x800)
; 2458 :             apfra |= 0x800;
; 2459 : #endif
; 2460 :     }
; 2461 : #endif /* defined( _FEATURE_SIE ) */
; 2462 : 
; 2463 :     /* Save ptr to storage key for this translated logical address */
; 2464 :     regs->dat.storkey = ARCH_DEP( get_ptr_to_storekey )( aaddr );

  0082f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00834	e8 00 00 00 00	 call	 s390_get_ptr_to_storekey
  00839	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00841	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax

; 2465 : 
; 2466 : #if defined( _FEATURE_SIE )
; 2467 :     /* Do not apply host key access when SIE fetches/stores data */
; 2468 :     if (unlikely(SIE_ACTIVE(regs)))

  00848	33 c0		 xor	 eax, eax
  0084a	85 c0		 test	 eax, eax
  0084c	74 19		 je	 SHORT $LN23@s390_logic

; 2469 :         return regs->mainstor + aaddr;

  0084e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00856	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0085d	48 03 44 24 28	 add	 rax, QWORD PTR aaddr$[rsp]
  00862	e9 e2 08 00 00	 jmp	 $LN1@s390_logic
$LN23@s390_logic:

; 2470 : #endif
; 2471 : 
; 2472 :     /* Skip further processing if hardware access */
; 2473 :     if (unlikely( acctype == ACCTYPE_HW ))

  00867	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR acctype$[rsp], 0
  0086f	75 0a		 jne	 SHORT $LN58@s390_logic
  00871	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv399[rsp], 1
  00879	eb 08		 jmp	 SHORT $LN59@s390_logic
$LN58@s390_logic:
  0087b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv399[rsp], 0
$LN59@s390_logic:
  00883	83 7c 24 40 00	 cmp	 DWORD PTR tv399[rsp], 0
  00888	74 19		 je	 SHORT $LN24@s390_logic

; 2474 :     {
; 2475 :         /* Return mainstor address */
; 2476 :         return regs->mainstor + aaddr;

  0088a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00892	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00899	48 03 44 24 28	 add	 rax, QWORD PTR aaddr$[rsp]
  0089e	e9 a6 08 00 00	 jmp	 $LN1@s390_logic
$LN24@s390_logic:

; 2477 :     }
; 2478 : 
; 2479 :     /* Check protection and set reference and change bits */
; 2480 :     if (likely( acctype & ACC_READ ))

  008a3	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  008aa	83 e0 04	 and	 eax, 4
  008ad	85 c0		 test	 eax, eax
  008af	74 0a		 je	 SHORT $LN60@s390_logic
  008b1	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv406[rsp], 1
  008b9	eb 08		 jmp	 SHORT $LN61@s390_logic
$LN60@s390_logic:
  008bb	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv406[rsp], 0
$LN61@s390_logic:
  008c3	83 7c 24 44 00	 cmp	 DWORD PTR tv406[rsp], 0
  008c8	0f 84 57 01 00
	00		 je	 $LN25@s390_logic

; 2481 :     {
; 2482 :         /* Program check if fetch protected location */
; 2483 :         if (unlikely(ARCH_DEP(is_fetch_protected) (addr, *regs->dat.storkey, akey, regs)))

  008ce	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008d6	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  008dd	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  008e5	44 0f b6 84 24
	c0 00 00 00	 movzx	 r8d, BYTE PTR akey$[rsp]
  008ee	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  008f1	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  008f8	e8 00 00 00 00	 call	 s390_is_fetch_protected
  008fd	0f b6 c0	 movzx	 eax, al
  00900	85 c0		 test	 eax, eax
  00902	74 0a		 je	 SHORT $LN64@s390_logic
  00904	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv428[rsp], 1
  0090c	eb 08		 jmp	 SHORT $LN65@s390_logic
$LN64@s390_logic:
  0090e	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv428[rsp], 0
$LN65@s390_logic:
  00916	83 7c 24 48 00	 cmp	 DWORD PTR tv428[rsp], 0
  0091b	74 49		 je	 SHORT $LN27@s390_logic

; 2484 :         {
; 2485 :             if (SIE_MODE(regs)) HOSTREGS->dat.protect = 0;

  0091d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00925	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0092b	d1 e8		 shr	 eax, 1
  0092d	83 e0 01	 and	 eax, 1
  00930	85 c0		 test	 eax, eax
  00932	74 2d		 je	 SHORT $LN28@s390_logic
  00934	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0093c	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00943	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00949	83 e0 f9	 and	 eax, -7			; fffffff9H
  0094c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00954	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  0095b	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN28@s390_logic:

; 2486 :             goto vabs_prot_excp;

  00961	e9 9d 05 00 00	 jmp	 $vabs_prot_excp$89
$LN27@s390_logic:

; 2487 :         }
; 2488 : 
; 2489 :         /* Set the reference bit in the storage key */
; 2490 :         ARCH_DEP( or_storage_key_by_ptr )( regs->dat.storkey, STORKEY_REF );

  00966	b2 04		 mov	 dl, 4
  00968	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00970	48 8b 88 28 08
	00 00		 mov	 rcx, QWORD PTR [rax+2088]
  00977	e8 00 00 00 00	 call	 s390_or_storage_key_by_ptr

; 2491 : 
; 2492 :         /* Update accelerated lookup TLB fields */
; 2493 :         regs->tlb.storkey[ix]    = regs->dat.storkey;

  0097c	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00981	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00989	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00991	48 8b 92 28 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2088]
  00998	48 89 94 c1 60
	30 01 00	 mov	 QWORD PTR [rcx+rax*8+77920], rdx

; 2494 :         regs->tlb.skey[ix]       = ARCH_DEP( get_storekey_by_ptr )( regs->dat.storkey ) & STORKEY_KEY;

  009a0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009a8	48 8b 88 28 08
	00 00		 mov	 rcx, QWORD PTR [rax+2088]
  009af	e8 00 00 00 00	 call	 s390_get_storekey_by_ptr
  009b4	0f b6 c0	 movzx	 eax, al
  009b7	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  009bc	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  009c1	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  009c9	88 84 0a 60 50
	01 00		 mov	 BYTE PTR [rdx+rcx+86112], al

; 2495 :         regs->tlb.acc[ix]        = ACC_READ;

  009d0	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  009d5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009dd	c6 84 01 60 5c
	01 00 04	 mov	 BYTE PTR [rcx+rax+89184], 4

; 2496 :         regs->tlb.main[ix]       = NEW_MAINADDR (regs, addr, apfra);

  009e5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009ed	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  009f4	48 03 44 24 68	 add	 rax, QWORD PTR apfra$[rsp]
  009f9	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00a00	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00a06	8b c9		 mov	 ecx, ecx
  00a08	48 33 c1	 xor	 rax, rcx
  00a0b	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00a10	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a18	48 89 84 ca 60
	10 01 00	 mov	 QWORD PTR [rdx+rcx*8+69728], rax

; 2497 : 
; 2498 :     }

  00a20	e9 aa 04 00 00	 jmp	 $LN26@s390_logic
$LN25@s390_logic:

; 2499 :     else /* (acctype & (ACC_WRITE | ACC_CHECK)) */
; 2500 :     {
; 2501 :         /* Program check if store protected location */
; 2502 :         if (unlikely(ARCH_DEP(is_store_protected) (addr, *regs->dat.storkey, akey, regs)))

  00a25	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a2d	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00a34	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00a3c	44 0f b6 84 24
	c0 00 00 00	 movzx	 r8d, BYTE PTR akey$[rsp]
  00a45	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00a48	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00a4f	e8 00 00 00 00	 call	 s390_is_store_protected
  00a54	0f b6 c0	 movzx	 eax, al
  00a57	85 c0		 test	 eax, eax
  00a59	74 0a		 je	 SHORT $LN68@s390_logic
  00a5b	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv490[rsp], 1
  00a63	eb 08		 jmp	 SHORT $LN69@s390_logic
$LN68@s390_logic:
  00a65	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv490[rsp], 0
$LN69@s390_logic:
  00a6d	83 7c 24 4c 00	 cmp	 DWORD PTR tv490[rsp], 0
  00a72	74 49		 je	 SHORT $LN29@s390_logic

; 2503 :         {
; 2504 :             if (SIE_MODE(regs)) HOSTREGS->dat.protect = 0;

  00a74	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a7c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00a82	d1 e8		 shr	 eax, 1
  00a84	83 e0 01	 and	 eax, 1
  00a87	85 c0		 test	 eax, eax
  00a89	74 2d		 je	 SHORT $LN30@s390_logic
  00a8b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a93	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00a9a	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00aa0	83 e0 f9	 and	 eax, -7			; fffffff9H
  00aa3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aab	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00ab2	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN30@s390_logic:

; 2505 :             goto vabs_prot_excp;

  00ab8	e9 46 04 00 00	 jmp	 $vabs_prot_excp$89
$LN29@s390_logic:

; 2506 :         }
; 2507 :         if (SIE_MODE(regs) && HOSTREGS->dat.protect)

  00abd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ac5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00acb	d1 e8		 shr	 eax, 1
  00acd	83 e0 01	 and	 eax, 1
  00ad0	85 c0		 test	 eax, eax
  00ad2	74 23		 je	 SHORT $LN31@s390_logic
  00ad4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00adc	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00ae3	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00ae9	d1 e8		 shr	 eax, 1
  00aeb	83 e0 03	 and	 eax, 3
  00aee	85 c0		 test	 eax, eax
  00af0	74 05		 je	 SHORT $LN31@s390_logic

; 2508 :             goto vabs_prot_excp;

  00af2	e9 0c 04 00 00	 jmp	 $vabs_prot_excp$89
$LN31@s390_logic:

; 2509 : 
; 2510 :         /* Set the reference and change bits in the storage key */
; 2511 :         if (acctype & ACC_WRITE)

  00af7	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00afe	83 e0 02	 and	 eax, 2
  00b01	85 c0		 test	 eax, eax
  00b03	74 16		 je	 SHORT $LN32@s390_logic

; 2512 :             ARCH_DEP( or_storage_key_by_ptr )( regs->dat.storkey, (STORKEY_REF | STORKEY_CHANGE) );

  00b05	b2 06		 mov	 dl, 6
  00b07	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b0f	48 8b 88 28 08
	00 00		 mov	 rcx, QWORD PTR [rax+2088]
  00b16	e8 00 00 00 00	 call	 s390_or_storage_key_by_ptr
$LN32@s390_logic:

; 2513 : 
; 2514 :         /* Update accelerated lookup TLB fields */
; 2515 :         regs->tlb.storkey[ix] = regs->dat.storkey;

  00b1b	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00b20	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b28	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b30	48 8b 92 28 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2088]
  00b37	48 89 94 c1 60
	30 01 00	 mov	 QWORD PTR [rcx+rax*8+77920], rdx

; 2516 :         regs->tlb.skey[ix]    = ARCH_DEP( get_storekey_by_ptr )( regs->dat.storkey ) & STORKEY_KEY;

  00b3f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b47	48 8b 88 28 08
	00 00		 mov	 rcx, QWORD PTR [rax+2088]
  00b4e	e8 00 00 00 00	 call	 s390_get_storekey_by_ptr
  00b53	0f b6 c0	 movzx	 eax, al
  00b56	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00b5b	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00b60	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b68	88 84 0a 60 50
	01 00		 mov	 BYTE PTR [rdx+rcx+86112], al

; 2517 :         regs->tlb.acc[ix]     = (addr >= PSA_SIZE || regs->dat.pvtaddr)

  00b6f	81 bc 24 a0 00
	00 00 00 10 00
	00		 cmp	 DWORD PTR addr$[rsp], 4096 ; 00001000H
  00b7a	73 1f		 jae	 SHORT $LN70@s390_logic
  00b7c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b84	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00b8a	83 e0 01	 and	 eax, 1
  00b8d	85 c0		 test	 eax, eax
  00b8f	75 0a		 jne	 SHORT $LN70@s390_logic
  00b91	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR tv539[rsp], 4
  00b99	eb 0e		 jmp	 SHORT $LN71@s390_logic
$LN70@s390_logic:
  00b9b	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00ba2	83 c8 05	 or	 eax, 5
  00ba5	89 44 24 50	 mov	 DWORD PTR tv539[rsp], eax
$LN71@s390_logic:
  00ba9	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00bae	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bb6	0f b6 54 24 50	 movzx	 edx, BYTE PTR tv539[rsp]
  00bbb	88 94 01 60 5c
	01 00		 mov	 BYTE PTR [rcx+rax+89184], dl

; 2518 :                               ? (ACC_READ | ACC_CHECK | acctype)
; 2519 :                               :  ACC_READ;
; 2520 :         regs->tlb.main[ix]    = NEW_MAINADDR (regs, addr, apfra);

  00bc2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bca	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00bd1	48 03 44 24 68	 add	 rax, QWORD PTR apfra$[rsp]
  00bd6	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00bdd	81 e1 00 f0 ff
	7f		 and	 ecx, 2147479552		; 7ffff000H
  00be3	8b c9		 mov	 ecx, ecx
  00be5	48 33 c1	 xor	 rax, rcx
  00be8	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00bed	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00bf5	48 89 84 ca 60
	10 01 00	 mov	 QWORD PTR [rdx+rcx*8+69728], rax

; 2521 : 
; 2522 : #if defined( FEATURE_PER )
; 2523 :         if (EN_IC_PER_SA( regs ))

  00bfd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c05	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00c0b	c1 e8 02	 shr	 eax, 2
  00c0e	83 e0 01	 and	 eax, 1
  00c11	85 c0		 test	 eax, eax
  00c13	74 0a		 je	 SHORT $LN74@s390_logic
  00c15	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv560[rsp], 1
  00c1d	eb 08		 jmp	 SHORT $LN75@s390_logic
$LN74@s390_logic:
  00c1f	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv560[rsp], 0
$LN75@s390_logic:
  00c27	83 7c 24 54 00	 cmp	 DWORD PTR tv560[rsp], 0
  00c2c	0f 84 9d 02 00
	00		 je	 $LN33@s390_logic
  00c32	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c3a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00c3d	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00c42	85 c0		 test	 eax, eax
  00c44	0f 84 85 02 00
	00		 je	 $LN33@s390_logic

; 2524 :         {
; 2525 :             regs->tlb.acc[ix] = ACC_READ;

  00c4a	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00c4f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c57	c6 84 01 60 5c
	01 00 04	 mov	 BYTE PTR [rcx+rax+89184], 4

; 2526 :             if (1
; 2527 :                 && arn != USE_REAL_ADDR
; 2528 : #if defined( FEATURE_PER2 )
; 2529 :                 && (0
; 2530 :                     || REAL_MODE( &regs->psw )
; 2531 :                     || ARCH_DEP( check_sa_per2 )( arn, acctype, regs )
; 2532 :                    )
; 2533 : #endif /* defined( FEATURE_PER2 ) */
; 2534 :                 /* Check that the range that was altered is within the PER SA range */
; 2535 :                 && PER_RANGE_CHECK2( addr, addr+(len-1), regs->CR(10), regs->CR(11))
; 2536 :                 && !IS_PER_SUPRESS( regs, CR9_SA )

  00c5f	33 c0		 xor	 eax, eax
  00c61	83 f8 01	 cmp	 eax, 1
  00c64	0f 84 65 02 00
	00		 je	 $LN34@s390_logic
  00c6a	83 bc 24 a8 00
	00 00 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00c72	0f 84 57 02 00
	00		 je	 $LN34@s390_logic
  00c78	33 c0		 xor	 eax, eax
  00c7a	85 c0		 test	 eax, eax
  00c7c	75 39		 jne	 SHORT $LN35@s390_logic
  00c7e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c86	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00c8a	83 e0 04	 and	 eax, 4
  00c8d	85 c0		 test	 eax, eax
  00c8f	74 26		 je	 SHORT $LN35@s390_logic
  00c91	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00c99	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR acctype$[rsp]
  00ca0	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR arn$[rsp]
  00ca7	e8 00 00 00 00	 call	 s390_check_sa_per2
  00cac	0f b6 c0	 movzx	 eax, al
  00caf	85 c0		 test	 eax, eax
  00cb1	0f 84 18 02 00
	00		 je	 $LN34@s390_logic
$LN35@s390_logic:
  00cb7	b8 08 00 00 00	 mov	 eax, 8
  00cbc	48 6b c0 0c	 imul	 rax, rax, 12
  00cc0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cc8	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00ccf	0f ba f0 1f	 btr	 eax, 31
  00cd3	b9 08 00 00 00	 mov	 ecx, 8
  00cd8	48 6b c9 0b	 imul	 rcx, rcx, 11
  00cdc	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00ce4	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00ceb	0f ba f1 1f	 btr	 ecx, 31
  00cef	3b c1		 cmp	 eax, ecx
  00cf1	0f 82 34 01 00
	00		 jb	 $LN83@s390_logic
  00cf7	b8 08 00 00 00	 mov	 eax, 8
  00cfc	48 6b c0 0b	 imul	 rax, rax, 11
  00d00	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d08	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00d0f	0f ba f0 1f	 btr	 eax, 31
  00d13	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR addr$[rsp], eax
  00d1a	72 29		 jb	 SHORT $LN76@s390_logic
  00d1c	b8 08 00 00 00	 mov	 eax, 8
  00d21	48 6b c0 0c	 imul	 rax, rax, 12
  00d25	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d2d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00d34	0f ba f0 1f	 btr	 eax, 31
  00d38	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR addr$[rsp], eax
  00d3f	0f 86 d4 00 00
	00		 jbe	 $LN78@s390_logic
$LN76@s390_logic:
  00d45	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00d4c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00d54	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00d59	b9 08 00 00 00	 mov	 ecx, 8
  00d5e	48 6b c9 0b	 imul	 rcx, rcx, 11
  00d62	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00d6a	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00d71	0f ba f1 1f	 btr	 ecx, 31
  00d75	8b c9		 mov	 ecx, ecx
  00d77	48 3b c1	 cmp	 rax, rcx
  00d7a	72 37		 jb	 SHORT $LN77@s390_logic
  00d7c	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00d83	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00d8b	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00d90	b9 08 00 00 00	 mov	 ecx, 8
  00d95	48 6b c9 0c	 imul	 rcx, rcx, 12
  00d99	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00da1	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00da8	0f ba f1 1f	 btr	 ecx, 31
  00dac	8b c9		 mov	 ecx, ecx
  00dae	48 3b c1	 cmp	 rax, rcx
  00db1	76 66		 jbe	 SHORT $LN78@s390_logic
$LN77@s390_logic:
  00db3	b8 08 00 00 00	 mov	 eax, 8
  00db8	48 6b c0 0b	 imul	 rax, rax, 11
  00dbc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00dc4	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00dcb	0f ba f0 1f	 btr	 eax, 31
  00dcf	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR addr$[rsp], eax
  00dd6	77 37		 ja	 SHORT $LN79@s390_logic
  00dd8	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00ddf	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00de7	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00dec	b9 08 00 00 00	 mov	 ecx, 8
  00df1	48 6b c9 0c	 imul	 rcx, rcx, 12
  00df5	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00dfd	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00e04	0f ba f1 1f	 btr	 ecx, 31
  00e08	8b c9		 mov	 ecx, ecx
  00e0a	48 3b c1	 cmp	 rax, rcx
  00e0d	73 0a		 jae	 SHORT $LN78@s390_logic
$LN79@s390_logic:
  00e0f	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv658[rsp], 0
  00e17	eb 08		 jmp	 SHORT $LN82@s390_logic
$LN78@s390_logic:
  00e19	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv658[rsp], 1
$LN82@s390_logic:
  00e21	8b 44 24 58	 mov	 eax, DWORD PTR tv658[rsp]
  00e25	89 44 24 60	 mov	 DWORD PTR tv659[rsp], eax
  00e29	eb 76		 jmp	 SHORT $LN84@s390_logic
$LN83@s390_logic:
  00e2b	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00e32	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00e3a	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00e3f	b9 08 00 00 00	 mov	 ecx, 8
  00e44	48 6b c9 0b	 imul	 rcx, rcx, 11
  00e48	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00e50	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00e57	0f ba f1 1f	 btr	 ecx, 31
  00e5b	8b c9		 mov	 ecx, ecx
  00e5d	48 3b c1	 cmp	 rax, rcx
  00e60	73 2f		 jae	 SHORT $LN80@s390_logic
  00e62	b8 08 00 00 00	 mov	 eax, 8
  00e67	48 6b c0 0c	 imul	 rax, rax, 12
  00e6b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e73	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00e7a	0f ba f0 1f	 btr	 eax, 31
  00e7e	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR addr$[rsp], eax
  00e85	76 0a		 jbe	 SHORT $LN80@s390_logic
  00e87	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv657[rsp], 0
  00e8f	eb 08		 jmp	 SHORT $LN81@s390_logic
$LN80@s390_logic:
  00e91	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv657[rsp], 1
$LN81@s390_logic:
  00e99	8b 44 24 5c	 mov	 eax, DWORD PTR tv657[rsp]
  00e9d	89 44 24 60	 mov	 DWORD PTR tv659[rsp], eax
$LN84@s390_logic:
  00ea1	83 7c 24 60 00	 cmp	 DWORD PTR tv659[rsp], 0
  00ea6	74 27		 je	 SHORT $LN34@s390_logic
  00ea8	33 c0		 xor	 eax, eax
  00eaa	83 f8 01	 cmp	 eax, 1
  00ead	74 20		 je	 SHORT $LN34@s390_logic
$LN4@s390_logic:

; 2537 :             )
; 2538 :                 ON_IC_PER_SA( regs );

  00eaf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00eb7	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00eba	0f ba e8 15	 bts	 eax, 21
  00ebe	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ec6	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00ec9	33 c0		 xor	 eax, eax
  00ecb	85 c0		 test	 eax, eax
  00ecd	75 e0		 jne	 SHORT $LN4@s390_logic
$LN34@s390_logic:
$LN33@s390_logic:
$LN26@s390_logic:

; 2539 :         }
; 2540 : #endif /* defined( FEATURE_PER ) */
; 2541 :     } /* (acctype & (ACC_WRITE | ACC_CHECK)) */
; 2542 : 
; 2543 :     /* Return mainstor address */
; 2544 :     return regs->mainstor + aaddr;

  00ecf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ed7	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00ede	48 03 44 24 28	 add	 rax, QWORD PTR aaddr$[rsp]
  00ee3	e9 61 02 00 00	 jmp	 $LN1@s390_logic
$vabs_addr_excp$90:

; 2545 : 
; 2546 : vabs_addr_excp:
; 2547 : 
; 2548 :     regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);

  00ee8	ba 05 00 00 00	 mov	 edx, 5
  00eed	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ef5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00efd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$vabs_prot_excp$89:

; 2549 : 
; 2550 : vabs_prot_excp:
; 2551 : 
; 2552 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 2553 :     regs->TEA = addr & STORAGE_KEY_PAGEMASK;

  00f03	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00f0a	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  00f0f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f17	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 2554 :     if (regs->dat.protect && (acctype & (ACC_WRITE|ACC_CHECK)) )

  00f1d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f25	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00f2b	d1 e8		 shr	 eax, 1
  00f2d	83 e0 03	 and	 eax, 3
  00f30	85 c0		 test	 eax, eax
  00f32	74 2d		 je	 SHORT $LN36@s390_logic
  00f34	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00f3b	83 e0 03	 and	 eax, 3
  00f3e	85 c0		 test	 eax, eax
  00f40	74 1f		 je	 SHORT $LN36@s390_logic

; 2555 :     {
; 2556 :         regs->TEA |= TEA_PROT_AP;

  00f42	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f4a	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00f50	83 c8 04	 or	 eax, 4
  00f53	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f5b	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax
$LN36@s390_logic:

; 2557 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 2558 :         if (regs->dat.protect & 2)
; 2559 :             regs->TEA |= TEA_PROT_A;
; 2560 : #endif
; 2561 :     }
; 2562 :     regs->TEA |= regs->dat.stid;

  00f61	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f69	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f71	8b 89 20 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2080]
  00f77	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00f7d	0b c1		 or	 eax, ecx
  00f7f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f87	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 2563 :     regs->excarid = (arn > 0 ? arn : 0);

  00f8d	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  00f95	7e 0d		 jle	 SHORT $LN85@s390_logic
  00f97	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00f9e	89 44 24 64	 mov	 DWORD PTR tv688[rsp], eax
  00fa2	eb 08		 jmp	 SHORT $LN86@s390_logic
$LN85@s390_logic:
  00fa4	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv688[rsp], 0
$LN86@s390_logic:
  00fac	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fb4	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR tv688[rsp]
  00fb9	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl

; 2564 : #endif /* defined( FEATURE_SUPPRESSION_ON_PROTECTION ) */
; 2565 : 
; 2566 : #if defined( _FEATURE_PROTECTION_INTERCEPTION_CONTROL )
; 2567 :     if (SIE_MODE( regs ) && HOSTREGS->dat.protect)

  00fbf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fc7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00fcd	d1 e8		 shr	 eax, 1
  00fcf	83 e0 01	 and	 eax, 1
  00fd2	85 c0		 test	 eax, eax
  00fd4	0f 84 2b 01 00
	00		 je	 $LN37@s390_logic
  00fda	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fe2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00fe9	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00fef	d1 e8		 shr	 eax, 1
  00ff1	83 e0 03	 and	 eax, 3
  00ff4	85 c0		 test	 eax, eax
  00ff6	0f 84 09 01 00
	00		 je	 $LN37@s390_logic

; 2568 :     {
; 2569 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 2570 : 
; 2571 :         switch (HOSTREGS->arch_mode)

  00ffc	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01004	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0100b	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0100e	89 44 24 24	 mov	 DWORD PTR tv701[rsp], eax
  01012	83 7c 24 24 00	 cmp	 DWORD PTR tv701[rsp], 0
  01017	74 10		 je	 SHORT $LN39@s390_logic
  01019	83 7c 24 24 01	 cmp	 DWORD PTR tv701[rsp], 1
  0101e	74 2e		 je	 SHORT $LN40@s390_logic
  01020	83 7c 24 24 02	 cmp	 DWORD PTR tv701[rsp], 2
  01025	74 4c		 je	 SHORT $LN41@s390_logic
  01027	eb 70		 jmp	 SHORT $LN42@s390_logic
$LN39@s390_logic:

; 2572 :         {
; 2573 :         case ARCH_370_IDX: HOSTREGS->TEA_370 = regs->TEA; break;

  01029	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01031	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  01038	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01040	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  01046	89 88 18 07 00
	00		 mov	 DWORD PTR [rax+1816], ecx
  0104c	eb 68		 jmp	 SHORT $LN5@s390_logic
$LN40@s390_logic:

; 2574 :         case ARCH_390_IDX: HOSTREGS->TEA_390 = regs->TEA; break;

  0104e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01056	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0105d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01065	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  0106b	89 88 18 07 00
	00		 mov	 DWORD PTR [rax+1816], ecx
  01071	eb 43		 jmp	 SHORT $LN5@s390_logic
$LN41@s390_logic:

; 2575 :         case ARCH_900_IDX: HOSTREGS->TEA_900 = regs->TEA; break;

  01073	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0107b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  01082	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0108a	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  01090	48 89 88 18 07
	00 00		 mov	 QWORD PTR [rax+1816], rcx
  01097	eb 1d		 jmp	 SHORT $LN5@s390_logic
$LN42@s390_logic:
$LN9@s390_logic:

; 2576 :         default: CRASH();

  01099	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$1[rsp], 0
  010a5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p$1[rsp]
  010ad	c6 00 00	 mov	 BYTE PTR [rax], 0
  010b0	33 c0		 xor	 eax, eax
  010b2	85 c0		 test	 eax, eax
  010b4	75 e3		 jne	 SHORT $LN9@s390_logic
$LN5@s390_logic:

; 2577 :         }
; 2578 : 
; 2579 :         HOSTREGS->excarid = regs->excarid;

  010b6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010be	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  010c5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010cd	0f b6 89 3e 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2110]
  010d4	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl

; 2580 : 
; 2581 : #endif /* defined( FEATURE_SUPPRESSION_ON_PROTECTION ) */
; 2582 : 
; 2583 :         HOSTREGS->program_interrupt( HOSTREGS, PGM_PROTECTION_EXCEPTION );

  010da	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010e2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  010e9	ba 04 00 00 00	 mov	 edx, 4
  010ee	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010f6	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  010fd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]

; 2584 :     }

  01103	eb 1b		 jmp	 SHORT $LN38@s390_logic
$LN37@s390_logic:

; 2585 :     else
; 2586 : #endif /* defined( _FEATURE_PROTECTION_INTERCEPTION_CONTROL ) */
; 2587 :         regs->program_interrupt (regs, PGM_PROTECTION_EXCEPTION);

  01105	ba 04 00 00 00	 mov	 edx, 4
  0110a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01112	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0111a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN38@s390_logic:
$vabs_prog_check$88:

; 2588 : 
; 2589 : vabs_prog_check:
; 2590 : 
; 2591 :     regs->program_interrupt (regs, regs->dat.xcode);

  01120	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01128	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  0112f	8b d0		 mov	 edx, eax
  01131	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01139	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01141	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]

; 2592 : 
; 2593 :     return NULL; /* prevent warning from compiler */

  01147	33 c0		 xor	 eax, eax
$LN1@s390_logic:

; 2594 : } /* end function ARCH_DEP(logical_to_main_l) */

  01149	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  01150	c3		 ret	 0
s390_logical_to_main_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
ix$ = 32
aaddr$ = 40
tv228 = 48
tv339 = 52
tv384 = 56
tv391 = 60
tv413 = 64
tv475 = 68
tv524 = 72
tv545 = 76
tv632 = 80
tv631 = 84
tv633 = 88
apfra$ = 96
tv177 = 104
tv193 = 112
tv690 = 120
addr$ = 144
arn$ = 152
regs$ = 160
acctype$ = 168
akey$ = 176
len$ = 184
s370_logical_to_main_l PROC

; 2362 : {

$LN71:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2363 : RADR    aaddr;                          /* Absolute address          */
; 2364 : RADR    apfra;                          /* Abs page frame address    */
; 2365 : int     ix = TLBIX(addr);               /* TLB index                 */

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	c1 e8 0b	 shr	 eax, 11
  00023	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00028	89 44 24 20	 mov	 DWORD PTR ix$[rsp], eax

; 2366 : 
; 2367 :     /* Convert logical address to real address */
; 2368 :     if ( (REAL_MODE(&regs->psw) || arn == USE_REAL_ADDR)

  0002c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00034	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00038	83 e0 08	 and	 eax, 8
  0003b	85 c0		 test	 eax, eax
  0003d	74 21		 je	 SHORT $LN7@s370_logic
  0003f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00047	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0004b	83 e0 04	 and	 eax, 4
  0004e	85 c0		 test	 eax, eax
  00050	74 0e		 je	 SHORT $LN7@s370_logic
  00052	83 bc 24 98 00
	00 00 fe	 cmp	 DWORD PTR arn$[rsp], -2
  0005a	0f 85 18 01 00
	00		 jne	 $LN5@s370_logic
$LN7@s370_logic:

; 2369 : #if defined( FEATURE_SIE )
; 2370 :       /* Under SIE guest real is always host primary, regardless
; 2371 :          of the DAT mode */
; 2372 :       && !(regs->sie_active
; 2373 : #if !defined( _FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 2374 :                             && arn == USE_PRIMARY_SPACE
; 2375 : #else
; 2376 : //                          && ( (arn == USE_PRIMARY_SPACE)
; 2377 : //                               || SIE_STATE_BIT_ON(GUESTREGS, MX, XC) )
; 2378 : #endif /* defined( _FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE ) */
; 2379 :           )
; 2380 : #endif /* defined( FEATURE_SIE ) */
; 2381 :        )
; 2382 :     {
; 2383 :         regs->dat.pvtaddr = regs->dat.protect = 0;

  00060	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00068	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0006e	83 e0 f9	 and	 eax, -7			; fffffff9H
  00071	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00079	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
  0007f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00087	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0008d	83 e0 fe	 and	 eax, -2			; fffffffeH
  00090	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 2384 :         regs->dat.raddr = addr;

  0009e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000a5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	48 89 81 00 08
	00 00		 mov	 QWORD PTR [rcx+2048], rax

; 2385 :         regs->dat.rpfra = addr & PAGEFRAME_PAGEMASK;

  000b4	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000bb	25 00 f8 ff 7f	 and	 eax, 2147481600		; 7ffff800H
  000c0	8b c0		 mov	 eax, eax
  000c2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	48 89 81 10 08
	00 00		 mov	 QWORD PTR [rcx+2064], rax

; 2386 : 
; 2387 :         /* Setup `real' TLB entry (for MADDR) */
; 2388 :         regs->tlb.TLB_ASD(ix)   = TLB_REAL_ASD;

  000d1	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  000d6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000de	c7 84 c1 60 b0
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*8+45152], -1 ; ffffffffH

; 2389 :         regs->tlb.TLB_VADDR(ix) = (addr & TLBID_PAGEMASK) | regs->tlbID;

  000e9	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000f0	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  000f5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fd	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00103	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00108	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00110	89 84 ca 60 d0
	00 00		 mov	 DWORD PTR [rdx+rcx*8+53344], eax

; 2390 :         regs->tlb.TLB_PTE(ix)   = addr & TLBID_PAGEMASK;

  00117	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  0011e	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  00123	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00128	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00130	89 84 ca 60 f0
	00 00		 mov	 DWORD PTR [rdx+rcx*8+61536], eax

; 2391 :         regs->tlb.acc[ix]       =

  00137	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  0013c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	c6 84 01 60 58
	01 00 00	 mov	 BYTE PTR [rcx+rax+88160], 0
  0014c	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00151	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	c6 84 01 60 54
	01 00 00	 mov	 BYTE PTR [rcx+rax+87136], 0
  00161	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00166	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016e	c6 84 01 60 5c
	01 00 00	 mov	 BYTE PTR [rcx+rax+89184], 0

; 2392 :         regs->tlb.common[ix]    =
; 2393 :         regs->tlb.protect[ix]   = 0;
; 2394 :     }

  00176	eb 2c		 jmp	 SHORT $LN6@s370_logic
$LN5@s370_logic:

; 2395 :     else {
; 2396 :         if (ARCH_DEP(translate_addr) (addr, arn, regs, acctype))

  00178	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  00180	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00188	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR arn$[rsp]
  0018f	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00196	e8 00 00 00 00	 call	 s370_translate_addr
  0019b	85 c0		 test	 eax, eax
  0019d	74 05		 je	 SHORT $LN8@s370_logic

; 2397 :             goto vabs_prog_check;

  0019f	e9 22 0d 00 00	 jmp	 $vabs_prog_check$72
$LN8@s370_logic:
$LN6@s370_logic:

; 2398 :     }
; 2399 : 
; 2400 :     if (regs->dat.protect
; 2401 :      && (acctype & (ACC_WRITE|ACC_CHECK)))

  001a4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ac	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  001b2	d1 e8		 shr	 eax, 1
  001b4	83 e0 03	 and	 eax, 3
  001b7	85 c0		 test	 eax, eax
  001b9	74 13		 je	 SHORT $LN9@s370_logic
  001bb	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  001c2	83 e0 03	 and	 eax, 3
  001c5	85 c0		 test	 eax, eax
  001c7	74 05		 je	 SHORT $LN9@s370_logic

; 2402 :         goto vabs_prot_excp;

  001c9	e9 7d 0c 00 00	 jmp	 $vabs_prot_excp$73
$LN9@s370_logic:

; 2403 : 
; 2404 :     /* Convert real address to absolute address */
; 2405 :     regs->dat.aaddr = aaddr = APPLY_PREFIXING (regs->dat.raddr, regs->PX);

  001ce	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d6	8b 80 00 08 00
	00		 mov	 eax, DWORD PTR [rax+2048]
  001dc	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  001e2	48 85 c0	 test	 rax, rax
  001e5	74 3a		 je	 SHORT $LN34@s370_logic
  001e7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ef	8b 80 00 08 00
	00		 mov	 eax, DWORD PTR [rax+2048]
  001f5	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  001fb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00203	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00206	48 3b c1	 cmp	 rax, rcx
  00209	74 16		 je	 SHORT $LN34@s370_logic
  0020b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00213	48 8b 80 00 08
	00 00		 mov	 rax, QWORD PTR [rax+2048]
  0021a	48 89 44 24 68	 mov	 QWORD PTR tv177[rsp], rax
  0021f	eb 22		 jmp	 SHORT $LN35@s370_logic
$LN34@s370_logic:
  00221	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00229	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00231	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00234	8b 80 00 08 00
	00		 mov	 eax, DWORD PTR [rax+2048]
  0023a	33 c1		 xor	 eax, ecx
  0023c	8b c0		 mov	 eax, eax
  0023e	48 89 44 24 68	 mov	 QWORD PTR tv177[rsp], rax
$LN35@s370_logic:
  00243	48 8b 44 24 68	 mov	 rax, QWORD PTR tv177[rsp]
  00248	48 89 44 24 28	 mov	 QWORD PTR aaddr$[rsp], rax
  0024d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00255	48 8b 4c 24 28	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0025a	48 89 88 08 08
	00 00		 mov	 QWORD PTR [rax+2056], rcx

; 2406 :     apfra=APPLY_PREFIXING(regs->dat.rpfra,regs->PX);

  00261	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00269	8b 80 10 08 00
	00		 mov	 eax, DWORD PTR [rax+2064]
  0026f	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00275	48 85 c0	 test	 rax, rax
  00278	74 3a		 je	 SHORT $LN36@s370_logic
  0027a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00282	8b 80 10 08 00
	00		 mov	 eax, DWORD PTR [rax+2064]
  00288	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0028e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00296	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00299	48 3b c1	 cmp	 rax, rcx
  0029c	74 16		 je	 SHORT $LN36@s370_logic
  0029e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a6	48 8b 80 10 08
	00 00		 mov	 rax, QWORD PTR [rax+2064]
  002ad	48 89 44 24 70	 mov	 QWORD PTR tv193[rsp], rax
  002b2	eb 22		 jmp	 SHORT $LN37@s370_logic
$LN36@s370_logic:
  002b4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c4	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  002c7	8b 80 10 08 00
	00		 mov	 eax, DWORD PTR [rax+2064]
  002cd	33 c1		 xor	 eax, ecx
  002cf	8b c0		 mov	 eax, eax
  002d1	48 89 44 24 70	 mov	 QWORD PTR tv193[rsp], rax
$LN37@s370_logic:
  002d6	48 8b 44 24 70	 mov	 rax, QWORD PTR tv193[rsp]
  002db	48 89 44 24 60	 mov	 QWORD PTR apfra$[rsp], rax

; 2407 : 
; 2408 :     /* Program check if absolute address is outside main storage */
; 2409 :     if (regs->dat.aaddr > regs->mainlim)

  002e0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f0	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  002f7	48 39 88 08 08
	00 00		 cmp	 QWORD PTR [rax+2056], rcx
  002fe	76 05		 jbe	 SHORT $LN10@s370_logic

; 2410 :         goto vabs_addr_excp;

  00300	e9 2b 0b 00 00	 jmp	 $vabs_addr_excp$74
$LN10@s370_logic:

; 2411 : 
; 2412 : #if defined( _FEATURE_SIE )
; 2413 :     if(SIE_MODE(regs)) HOSTREGS->dat.protect = 0;

  00305	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00313	d1 e8		 shr	 eax, 1
  00315	83 e0 01	 and	 eax, 1
  00318	85 c0		 test	 eax, eax
  0031a	74 2d		 je	 SHORT $LN11@s370_logic
  0031c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00324	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0032b	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00331	83 e0 f9	 and	 eax, -7			; fffffff9H
  00334	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033c	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00343	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN11@s370_logic:

; 2414 :     if(SIE_MODE(regs)  && !regs->sie_pref)

  00349	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00351	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00357	d1 e8		 shr	 eax, 1
  00359	83 e0 01	 and	 eax, 1
  0035c	85 c0		 test	 eax, eax
  0035e	0f 84 43 04 00
	00		 je	 $LN12@s370_logic
  00364	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0036c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00372	c1 e8 02	 shr	 eax, 2
  00375	83 e0 01	 and	 eax, 1
  00378	85 c0		 test	 eax, eax
  0037a	0f 85 27 04 00
	00		 jne	 $LN12@s370_logic

; 2415 :     {
; 2416 :         if (SIE_TRANSLATE_ADDR (regs->sie_mso + regs->dat.aaddr,

  00380	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  00388	7e 3a		 jle	 SHORT $LN38@s370_logic
  0038a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00392	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00399	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0039d	83 e0 01	 and	 eax, 1
  003a0	85 c0		 test	 eax, eax
  003a2	74 20		 je	 SHORT $LN38@s370_logic
  003a4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ac	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  003b0	83 e0 40	 and	 eax, 64			; 00000040H
  003b3	85 c0		 test	 eax, eax
  003b5	74 0d		 je	 SHORT $LN38@s370_logic
  003b7	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  003be	89 44 24 30	 mov	 DWORD PTR tv228[rsp], eax
  003c2	eb 08		 jmp	 SHORT $LN39@s370_logic
$LN38@s370_logic:
  003c4	c7 44 24 30 fd
	ff ff ff	 mov	 DWORD PTR tv228[rsp], -3
$LN39@s370_logic:
  003cc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d4	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  003db	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e3	48 03 81 08 08
	00 00		 add	 rax, QWORD PTR [rcx+2056]
  003ea	45 33 c9	 xor	 r9d, r9d
  003ed	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f5	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  003fc	8b 54 24 30	 mov	 edx, DWORD PTR tv228[rsp]
  00400	8b c8		 mov	 ecx, eax
  00402	e8 00 00 00 00	 call	 s390_translate_addr
  00407	85 c0		 test	 eax, eax
  00409	74 46		 je	 SHORT $LN13@s370_logic

; 2417 :                     (arn > 0 && MULTIPLE_CONTROLLED_DATA_SPACE(regs)) ? arn : USE_PRIMARY_SPACE,
; 2418 :                     HOSTREGS, ACCTYPE_SIE))
; 2419 :             (HOSTREGS->program_interrupt) (HOSTREGS, HOSTREGS->dat.xcode);

  0040b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00413	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0041a	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00421	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00429	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00430	48 89 4c 24 78	 mov	 QWORD PTR tv690[rsp], rcx
  00435	8b d0		 mov	 edx, eax
  00437	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0043f	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00446	48 8b 44 24 78	 mov	 rax, QWORD PTR tv690[rsp]
  0044b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s370_logic:

; 2420 : 
; 2421 :         regs->dat.protect     |= HOSTREGS->dat.protect;

  00451	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00459	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0045f	d1 e8		 shr	 eax, 1
  00461	83 e0 03	 and	 eax, 3
  00464	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046c	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00473	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  00479	d1 e9		 shr	 ecx, 1
  0047b	83 e1 03	 and	 ecx, 3
  0047e	0b c1		 or	 eax, ecx
  00480	83 e0 03	 and	 eax, 3
  00483	d1 e0		 shl	 eax, 1
  00485	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0048d	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  00493	83 e1 f9	 and	 ecx, -7			; fffffff9H
  00496	0b c8		 or	 ecx, eax
  00498	8b c1		 mov	 eax, ecx
  0049a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a2	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 2422 :         regs->tlb.protect[ix] |= HOSTREGS->dat.protect;

  004a8	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  004ad	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b5	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  004bc	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  004c2	d1 e9		 shr	 ecx, 1
  004c4	83 e1 03	 and	 ecx, 3
  004c7	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004cf	0f b6 84 02 60
	58 01 00	 movzx	 eax, BYTE PTR [rdx+rax+88160]
  004d7	0b c1		 or	 eax, ecx
  004d9	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  004de	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004e6	88 84 0a 60 58
	01 00		 mov	 BYTE PTR [rdx+rcx+88160], al

; 2423 : 
; 2424 :         if ( REAL_MODE(&regs->psw) || (arn == USE_REAL_ADDR) )

  004ed	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f5	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  004f9	83 e0 08	 and	 eax, 8
  004fc	85 c0		 test	 eax, eax
  004fe	74 1d		 je	 SHORT $LN15@s370_logic
  00500	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00508	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0050c	83 e0 04	 and	 eax, 4
  0050f	85 c0		 test	 eax, eax
  00511	74 0a		 je	 SHORT $LN15@s370_logic
  00513	83 bc 24 98 00
	00 00 fe	 cmp	 DWORD PTR arn$[rsp], -2
  0051b	75 20		 jne	 SHORT $LN14@s370_logic
$LN15@s370_logic:

; 2425 :             regs->tlb.TLB_PTE(ix)   = addr & TLBID_PAGEMASK;

  0051d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00524	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  00529	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  0052e	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00536	89 84 ca 60 f0
	00 00		 mov	 DWORD PTR [rdx+rcx*8+61536], eax
$LN14@s370_logic:

; 2426 : 
; 2427 :         /* Indicate a host real space entry for a XC dataspace */
; 2428 :         if (arn > 0 && MULTIPLE_CONTROLLED_DATA_SPACE(regs))

  0053d	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR arn$[rsp], 0
  00545	0f 8e 8c 01 00
	00		 jle	 $LN16@s370_logic
  0054b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00553	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0055a	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0055e	83 e0 01	 and	 eax, 1
  00561	85 c0		 test	 eax, eax
  00563	0f 84 6e 01 00
	00		 je	 $LN16@s370_logic
  00569	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00571	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00575	83 e0 40	 and	 eax, 64			; 00000040H
  00578	85 c0		 test	 eax, eax
  0057a	0f 84 57 01 00
	00		 je	 $LN16@s370_logic

; 2429 :         {
; 2430 :             regs->tlb.TLB_ASD(ix) = regs->dat.asd;

  00580	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00585	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0058d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00595	8b 92 18 08 00
	00		 mov	 edx, DWORD PTR [rdx+2072]
  0059b	89 94 c1 60 b0
	00 00		 mov	 DWORD PTR [rcx+rax*8+45152], edx

; 2431 :             /* Ensure that the private bit is percolated to the guest such that LAP is applied correctly */
; 2432 :             regs->dat.pvtaddr = HOSTREGS->dat.pvtaddr;

  005a2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005aa	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  005b1	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  005b7	83 e0 01	 and	 eax, 1
  005ba	83 e0 01	 and	 eax, 1
  005bd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c5	8b 89 34 08 00
	00		 mov	 ecx, DWORD PTR [rcx+2100]
  005cb	83 e1 fe	 and	 ecx, -2			; fffffffeH
  005ce	0b c8		 or	 ecx, eax
  005d0	8b c1		 mov	 eax, ecx
  005d2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005da	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax

; 2433 : 
; 2434 :             /* Build tlb entry of XC dataspace */
; 2435 :             regs->dat.asd = HOSTREGS->dat.asd ^ TLB_HOST_ASD;

  005e0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  005ef	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  005f6	48 0f ba f8 0b	 btc	 rax, 11
  005fb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00603	48 89 81 18 08
	00 00		 mov	 QWORD PTR [rcx+2072], rax

; 2436 :             regs->CR(CR_ALB_OFFSET + arn) = regs->dat.asd;

  0060a	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  00611	83 c0 11	 add	 eax, 17
  00614	48 98		 cdqe
  00616	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0061e	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00626	8b 92 18 08 00
	00		 mov	 edx, DWORD PTR [rdx+2072]
  0062c	89 94 c1 00 06
	00 00		 mov	 DWORD PTR [rcx+rax*8+1536], edx

; 2437 :             regs->AEA_AR(arn) = CR_ALB_OFFSET + arn;

  00633	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  0063a	83 c0 10	 add	 eax, 16
  0063d	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR arn$[rsp]
  00644	83 c1 05	 add	 ecx, 5
  00647	48 63 c9	 movsxd	 rcx, ecx
  0064a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00652	89 84 8a 94 0c
	00 00		 mov	 DWORD PTR [rdx+rcx*4+3220], eax

; 2438 :             regs->AEA_COMMON(CR_ALB_OFFSET + arn) = (regs->dat.asd & ASD_PRIVATE) == 0;

  00659	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00661	48 8b 80 18 08
	00 00		 mov	 rax, QWORD PTR [rax+2072]
  00668	48 83 e0 02	 and	 rax, 2
  0066c	48 85 c0	 test	 rax, rax
  0066f	75 0a		 jne	 SHORT $LN40@s370_logic
  00671	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv339[rsp], 1
  00679	eb 08		 jmp	 SHORT $LN41@s370_logic
$LN40@s370_logic:
  0067b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv339[rsp], 0
$LN41@s370_logic:
  00683	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR arn$[rsp]
  0068a	83 c0 11	 add	 eax, 17
  0068d	48 98		 cdqe
  0068f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00697	0f b6 54 24 34	 movzx	 edx, BYTE PTR tv339[rsp]
  0069c	88 94 01 e8 0c
	00 00		 mov	 BYTE PTR [rcx+rax+3304], dl

; 2439 :             regs->aea_aleprot[arn] = HOSTREGS->dat.protect & 2;

  006a3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ab	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  006b2	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  006b8	d1 e8		 shr	 eax, 1
  006ba	83 e0 03	 and	 eax, 3
  006bd	83 e0 02	 and	 eax, 2
  006c0	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR arn$[rsp]
  006c8	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006d0	88 84 0a 09 0d
	00 00		 mov	 BYTE PTR [rdx+rcx+3337], al
$LN16@s370_logic:

; 2440 :         }
; 2441 : 
; 2442 :         /* Convert host real address to host absolute address.
; 2443 :            Use the Prefixing logic of the SIE host, not the guest!
; 2444 :                                                -- ISW 20181005
; 2445 :         */
; 2446 :         HOSTREGS->dat.aaddr =

  006d7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006df	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  006e6	48 8b 90 00 08
	00 00		 mov	 rdx, QWORD PTR [rax+2048]
  006ed	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006f5	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  006fc	e8 00 00 00 00	 call	 apply_host_prefixing
  00701	48 89 44 24 28	 mov	 QWORD PTR aaddr$[rsp], rax
  00706	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0070e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00715	48 8b 4c 24 28	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0071a	48 89 88 08 08
	00 00		 mov	 QWORD PTR [rax+2056], rcx

; 2447 :         aaddr = apply_host_prefixing( HOSTREGS, HOSTREGS->dat.raddr );
; 2448 :         apfra = apply_host_prefixing( HOSTREGS, HOSTREGS->dat.rpfra );

  00721	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00729	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00730	48 8b 90 10 08
	00 00		 mov	 rdx, QWORD PTR [rax+2064]
  00737	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0073f	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00746	e8 00 00 00 00	 call	 apply_host_prefixing
  0074b	48 89 44 24 60	 mov	 QWORD PTR apfra$[rsp], rax

; 2449 : 
; 2450 :         if (HOSTREGS->dat.aaddr > HOSTREGS->mainlim)

  00750	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00758	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0075f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00767	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  0076e	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  00775	48 39 88 08 08
	00 00		 cmp	 QWORD PTR [rax+2056], rcx
  0077c	76 05		 jbe	 SHORT $LN17@s370_logic

; 2451 :             goto vabs_addr_excp;

  0077e	e9 ad 06 00 00	 jmp	 $vabs_addr_excp$74
$LN17@s370_logic:

; 2452 : 
; 2453 :         /* Take into account SIE guests with a 2K page scheme
; 2454 :            because the SIE host may be operating with a 4K page
; 2455 :            system */
; 2456 : #if defined( FEATURE_2K_STORAGE_KEYS )
; 2457 :         if ((addr & PAGEFRAME_PAGEMASK) & 0x800)

  00783	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  0078a	25 00 f8 ff 7f	 and	 eax, 2147481600		; 7ffff800H
  0078f	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00794	85 c0		 test	 eax, eax
  00796	74 0f		 je	 SHORT $LN18@s370_logic

; 2458 :             apfra |= 0x800;

  00798	48 8b 44 24 60	 mov	 rax, QWORD PTR apfra$[rsp]
  0079d	48 0f ba e8 0b	 bts	 rax, 11
  007a2	48 89 44 24 60	 mov	 QWORD PTR apfra$[rsp], rax
$LN18@s370_logic:
$LN12@s370_logic:

; 2459 : #endif
; 2460 :     }
; 2461 : #endif /* defined( _FEATURE_SIE ) */
; 2462 : 
; 2463 :     /* Save ptr to storage key for this translated logical address */
; 2464 :     regs->dat.storkey = ARCH_DEP( get_ptr_to_storekey )( aaddr );

  007a7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR aaddr$[rsp]
  007ac	e8 00 00 00 00	 call	 s370_get_ptr_to_storekey
  007b1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007b9	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax

; 2465 : 
; 2466 : #if defined( _FEATURE_SIE )
; 2467 :     /* Do not apply host key access when SIE fetches/stores data */
; 2468 :     if (unlikely(SIE_ACTIVE(regs)))

  007c0	33 c0		 xor	 eax, eax
  007c2	85 c0		 test	 eax, eax
  007c4	74 19		 je	 SHORT $LN19@s370_logic

; 2469 :         return regs->mainstor + aaddr;

  007c6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ce	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  007d5	48 03 44 24 28	 add	 rax, QWORD PTR aaddr$[rsp]
  007da	e9 10 07 00 00	 jmp	 $LN1@s370_logic
$LN19@s370_logic:

; 2470 : #endif
; 2471 : 
; 2472 :     /* Skip further processing if hardware access */
; 2473 :     if (unlikely( acctype == ACCTYPE_HW ))

  007df	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR acctype$[rsp], 0
  007e7	75 0a		 jne	 SHORT $LN44@s370_logic
  007e9	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv384[rsp], 1
  007f1	eb 08		 jmp	 SHORT $LN45@s370_logic
$LN44@s370_logic:
  007f3	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv384[rsp], 0
$LN45@s370_logic:
  007fb	83 7c 24 38 00	 cmp	 DWORD PTR tv384[rsp], 0
  00800	74 19		 je	 SHORT $LN20@s370_logic

; 2474 :     {
; 2475 :         /* Return mainstor address */
; 2476 :         return regs->mainstor + aaddr;

  00802	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0080a	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00811	48 03 44 24 28	 add	 rax, QWORD PTR aaddr$[rsp]
  00816	e9 d4 06 00 00	 jmp	 $LN1@s370_logic
$LN20@s370_logic:

; 2477 :     }
; 2478 : 
; 2479 :     /* Check protection and set reference and change bits */
; 2480 :     if (likely( acctype & ACC_READ ))

  0081b	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00822	83 e0 04	 and	 eax, 4
  00825	85 c0		 test	 eax, eax
  00827	74 0a		 je	 SHORT $LN46@s370_logic
  00829	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv391[rsp], 1
  00831	eb 08		 jmp	 SHORT $LN47@s370_logic
$LN46@s370_logic:
  00833	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv391[rsp], 0
$LN47@s370_logic:
  0083b	83 7c 24 3c 00	 cmp	 DWORD PTR tv391[rsp], 0
  00840	0f 84 57 01 00
	00		 je	 $LN21@s370_logic

; 2481 :     {
; 2482 :         /* Program check if fetch protected location */
; 2483 :         if (unlikely(ARCH_DEP(is_fetch_protected) (addr, *regs->dat.storkey, akey, regs)))

  00846	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0084e	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00855	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0085d	44 0f b6 84 24
	b0 00 00 00	 movzx	 r8d, BYTE PTR akey$[rsp]
  00866	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00869	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00870	e8 00 00 00 00	 call	 s370_is_fetch_protected
  00875	0f b6 c0	 movzx	 eax, al
  00878	85 c0		 test	 eax, eax
  0087a	74 0a		 je	 SHORT $LN50@s370_logic
  0087c	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv413[rsp], 1
  00884	eb 08		 jmp	 SHORT $LN51@s370_logic
$LN50@s370_logic:
  00886	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv413[rsp], 0
$LN51@s370_logic:
  0088e	83 7c 24 40 00	 cmp	 DWORD PTR tv413[rsp], 0
  00893	74 49		 je	 SHORT $LN23@s370_logic

; 2484 :         {
; 2485 :             if (SIE_MODE(regs)) HOSTREGS->dat.protect = 0;

  00895	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0089d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  008a3	d1 e8		 shr	 eax, 1
  008a5	83 e0 01	 and	 eax, 1
  008a8	85 c0		 test	 eax, eax
  008aa	74 2d		 je	 SHORT $LN24@s370_logic
  008ac	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008b4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  008bb	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  008c1	83 e0 f9	 and	 eax, -7			; fffffff9H
  008c4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008cc	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  008d3	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN24@s370_logic:

; 2486 :             goto vabs_prot_excp;

  008d9	e9 6d 05 00 00	 jmp	 $vabs_prot_excp$73
$LN23@s370_logic:

; 2487 :         }
; 2488 : 
; 2489 :         /* Set the reference bit in the storage key */
; 2490 :         ARCH_DEP( or_storage_key_by_ptr )( regs->dat.storkey, STORKEY_REF );

  008de	b2 04		 mov	 dl, 4
  008e0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008e8	48 8b 88 28 08
	00 00		 mov	 rcx, QWORD PTR [rax+2088]
  008ef	e8 00 00 00 00	 call	 s370_or_storage_key_by_ptr

; 2491 : 
; 2492 :         /* Update accelerated lookup TLB fields */
; 2493 :         regs->tlb.storkey[ix]    = regs->dat.storkey;

  008f4	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  008f9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00901	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00909	48 8b 92 28 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2088]
  00910	48 89 94 c1 60
	30 01 00	 mov	 QWORD PTR [rcx+rax*8+77920], rdx

; 2494 :         regs->tlb.skey[ix]       = ARCH_DEP( get_storekey_by_ptr )( regs->dat.storkey ) & STORKEY_KEY;

  00918	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00920	48 8b 88 28 08
	00 00		 mov	 rcx, QWORD PTR [rax+2088]
  00927	e8 00 00 00 00	 call	 s370_get_storekey_by_ptr
  0092c	0f b6 c0	 movzx	 eax, al
  0092f	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00934	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00939	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00941	88 84 0a 60 50
	01 00		 mov	 BYTE PTR [rdx+rcx+86112], al

; 2495 :         regs->tlb.acc[ix]        = ACC_READ;

  00948	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  0094d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00955	c6 84 01 60 5c
	01 00 04	 mov	 BYTE PTR [rcx+rax+89184], 4

; 2496 :         regs->tlb.main[ix]       = NEW_MAINADDR (regs, addr, apfra);

  0095d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00965	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0096c	48 03 44 24 60	 add	 rax, QWORD PTR apfra$[rsp]
  00971	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00978	81 e1 00 f8 ff
	00		 and	 ecx, 16775168		; 00fff800H
  0097e	8b c9		 mov	 ecx, ecx
  00980	48 33 c1	 xor	 rax, rcx
  00983	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00988	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00990	48 89 84 ca 60
	10 01 00	 mov	 QWORD PTR [rdx+rcx*8+69728], rax

; 2497 : 
; 2498 :     }

  00998	e9 7a 04 00 00	 jmp	 $LN22@s370_logic
$LN21@s370_logic:

; 2499 :     else /* (acctype & (ACC_WRITE | ACC_CHECK)) */
; 2500 :     {
; 2501 :         /* Program check if store protected location */
; 2502 :         if (unlikely(ARCH_DEP(is_store_protected) (addr, *regs->dat.storkey, akey, regs)))

  0099d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009a5	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  009ac	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  009b4	44 0f b6 84 24
	b0 00 00 00	 movzx	 r8d, BYTE PTR akey$[rsp]
  009bd	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  009c0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  009c7	e8 00 00 00 00	 call	 s370_is_store_protected
  009cc	0f b6 c0	 movzx	 eax, al
  009cf	85 c0		 test	 eax, eax
  009d1	74 0a		 je	 SHORT $LN54@s370_logic
  009d3	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv475[rsp], 1
  009db	eb 08		 jmp	 SHORT $LN55@s370_logic
$LN54@s370_logic:
  009dd	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv475[rsp], 0
$LN55@s370_logic:
  009e5	83 7c 24 44 00	 cmp	 DWORD PTR tv475[rsp], 0
  009ea	74 49		 je	 SHORT $LN25@s370_logic

; 2503 :         {
; 2504 :             if (SIE_MODE(regs)) HOSTREGS->dat.protect = 0;

  009ec	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009f4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  009fa	d1 e8		 shr	 eax, 1
  009fc	83 e0 01	 and	 eax, 1
  009ff	85 c0		 test	 eax, eax
  00a01	74 2d		 je	 SHORT $LN26@s370_logic
  00a03	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a0b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00a12	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00a18	83 e0 f9	 and	 eax, -7			; fffffff9H
  00a1b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a23	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00a2a	89 81 34 08 00
	00		 mov	 DWORD PTR [rcx+2100], eax
$LN26@s370_logic:

; 2505 :             goto vabs_prot_excp;

  00a30	e9 16 04 00 00	 jmp	 $vabs_prot_excp$73
$LN25@s370_logic:

; 2506 :         }
; 2507 :         if (SIE_MODE(regs) && HOSTREGS->dat.protect)

  00a35	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a3d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00a43	d1 e8		 shr	 eax, 1
  00a45	83 e0 01	 and	 eax, 1
  00a48	85 c0		 test	 eax, eax
  00a4a	74 23		 je	 SHORT $LN27@s370_logic
  00a4c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a54	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00a5b	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00a61	d1 e8		 shr	 eax, 1
  00a63	83 e0 03	 and	 eax, 3
  00a66	85 c0		 test	 eax, eax
  00a68	74 05		 je	 SHORT $LN27@s370_logic

; 2508 :             goto vabs_prot_excp;

  00a6a	e9 dc 03 00 00	 jmp	 $vabs_prot_excp$73
$LN27@s370_logic:

; 2509 : 
; 2510 :         /* Set the reference and change bits in the storage key */
; 2511 :         if (acctype & ACC_WRITE)

  00a6f	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00a76	83 e0 02	 and	 eax, 2
  00a79	85 c0		 test	 eax, eax
  00a7b	74 16		 je	 SHORT $LN28@s370_logic

; 2512 :             ARCH_DEP( or_storage_key_by_ptr )( regs->dat.storkey, (STORKEY_REF | STORKEY_CHANGE) );

  00a7d	b2 06		 mov	 dl, 6
  00a7f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a87	48 8b 88 28 08
	00 00		 mov	 rcx, QWORD PTR [rax+2088]
  00a8e	e8 00 00 00 00	 call	 s370_or_storage_key_by_ptr
$LN28@s370_logic:

; 2513 : 
; 2514 :         /* Update accelerated lookup TLB fields */
; 2515 :         regs->tlb.storkey[ix] = regs->dat.storkey;

  00a93	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00a98	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aa0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00aa8	48 8b 92 28 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2088]
  00aaf	48 89 94 c1 60
	30 01 00	 mov	 QWORD PTR [rcx+rax*8+77920], rdx

; 2516 :         regs->tlb.skey[ix]    = ARCH_DEP( get_storekey_by_ptr )( regs->dat.storkey ) & STORKEY_KEY;

  00ab7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00abf	48 8b 88 28 08
	00 00		 mov	 rcx, QWORD PTR [rax+2088]
  00ac6	e8 00 00 00 00	 call	 s370_get_storekey_by_ptr
  00acb	0f b6 c0	 movzx	 eax, al
  00ace	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00ad3	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00ad8	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00ae0	88 84 0a 60 50
	01 00		 mov	 BYTE PTR [rdx+rcx+86112], al

; 2517 :         regs->tlb.acc[ix]     = (addr >= PSA_SIZE || regs->dat.pvtaddr)

  00ae7	81 bc 24 90 00
	00 00 00 10 00
	00		 cmp	 DWORD PTR addr$[rsp], 4096 ; 00001000H
  00af2	73 1f		 jae	 SHORT $LN56@s370_logic
  00af4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00afc	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00b02	83 e0 01	 and	 eax, 1
  00b05	85 c0		 test	 eax, eax
  00b07	75 0a		 jne	 SHORT $LN56@s370_logic
  00b09	c7 44 24 48 04
	00 00 00	 mov	 DWORD PTR tv524[rsp], 4
  00b11	eb 0e		 jmp	 SHORT $LN57@s370_logic
$LN56@s370_logic:
  00b13	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00b1a	83 c8 05	 or	 eax, 5
  00b1d	89 44 24 48	 mov	 DWORD PTR tv524[rsp], eax
$LN57@s370_logic:
  00b21	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00b26	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b2e	0f b6 54 24 48	 movzx	 edx, BYTE PTR tv524[rsp]
  00b33	88 94 01 60 5c
	01 00		 mov	 BYTE PTR [rcx+rax+89184], dl

; 2518 :                               ? (ACC_READ | ACC_CHECK | acctype)
; 2519 :                               :  ACC_READ;
; 2520 :         regs->tlb.main[ix]    = NEW_MAINADDR (regs, addr, apfra);

  00b3a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b42	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00b49	48 03 44 24 60	 add	 rax, QWORD PTR apfra$[rsp]
  00b4e	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00b55	81 e1 00 f8 ff
	00		 and	 ecx, 16775168		; 00fff800H
  00b5b	8b c9		 mov	 ecx, ecx
  00b5d	48 33 c1	 xor	 rax, rcx
  00b60	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR ix$[rsp]
  00b65	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b6d	48 89 84 ca 60
	10 01 00	 mov	 QWORD PTR [rdx+rcx*8+69728], rax

; 2521 : 
; 2522 : #if defined( FEATURE_PER )
; 2523 :         if (EN_IC_PER_SA( regs ))

  00b75	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b7d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00b83	c1 e8 02	 shr	 eax, 2
  00b86	83 e0 01	 and	 eax, 1
  00b89	85 c0		 test	 eax, eax
  00b8b	74 0a		 je	 SHORT $LN60@s370_logic
  00b8d	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv545[rsp], 1
  00b95	eb 08		 jmp	 SHORT $LN61@s370_logic
$LN60@s370_logic:
  00b97	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv545[rsp], 0
$LN61@s370_logic:
  00b9f	83 7c 24 4c 00	 cmp	 DWORD PTR tv545[rsp], 0
  00ba4	0f 84 6d 02 00
	00		 je	 $LN29@s370_logic
  00baa	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bb2	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00bb5	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00bba	85 c0		 test	 eax, eax
  00bbc	0f 84 55 02 00
	00		 je	 $LN29@s370_logic

; 2524 :         {
; 2525 :             regs->tlb.acc[ix] = ACC_READ;

  00bc2	48 63 44 24 20	 movsxd	 rax, DWORD PTR ix$[rsp]
  00bc7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bcf	c6 84 01 60 5c
	01 00 04	 mov	 BYTE PTR [rcx+rax+89184], 4

; 2526 :             if (1
; 2527 :                 && arn != USE_REAL_ADDR
; 2528 : #if defined( FEATURE_PER2 )
; 2529 :                 && (0
; 2530 :                     || REAL_MODE( &regs->psw )
; 2531 :                     || ARCH_DEP( check_sa_per2 )( arn, acctype, regs )
; 2532 :                    )
; 2533 : #endif /* defined( FEATURE_PER2 ) */
; 2534 :                 /* Check that the range that was altered is within the PER SA range */
; 2535 :                 && PER_RANGE_CHECK2( addr, addr+(len-1), regs->CR(10), regs->CR(11))
; 2536 :                 && !IS_PER_SUPRESS( regs, CR9_SA )

  00bd7	33 c0		 xor	 eax, eax
  00bd9	83 f8 01	 cmp	 eax, 1
  00bdc	0f 84 35 02 00
	00		 je	 $LN30@s370_logic
  00be2	83 bc 24 98 00
	00 00 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00bea	0f 84 27 02 00
	00		 je	 $LN30@s370_logic
  00bf0	b8 08 00 00 00	 mov	 eax, 8
  00bf5	48 6b c0 0c	 imul	 rax, rax, 12
  00bf9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c01	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00c08	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00c0d	b9 08 00 00 00	 mov	 ecx, 8
  00c12	48 6b c9 0b	 imul	 rcx, rcx, 11
  00c16	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c1e	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00c25	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00c2b	3b c1		 cmp	 eax, ecx
  00c2d	0f 82 3d 01 00
	00		 jb	 $LN69@s370_logic
  00c33	b8 08 00 00 00	 mov	 eax, 8
  00c38	48 6b c0 0b	 imul	 rax, rax, 11
  00c3c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c44	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00c4b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00c50	39 84 24 90 00
	00 00		 cmp	 DWORD PTR addr$[rsp], eax
  00c57	72 2a		 jb	 SHORT $LN62@s370_logic
  00c59	b8 08 00 00 00	 mov	 eax, 8
  00c5e	48 6b c0 0c	 imul	 rax, rax, 12
  00c62	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c6a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00c71	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00c76	39 84 24 90 00
	00 00		 cmp	 DWORD PTR addr$[rsp], eax
  00c7d	0f 86 db 00 00
	00		 jbe	 $LN64@s370_logic
$LN62@s370_logic:
  00c83	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00c8a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00c92	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00c97	b9 08 00 00 00	 mov	 ecx, 8
  00c9c	48 6b c9 0b	 imul	 rcx, rcx, 11
  00ca0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00ca8	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00caf	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00cb5	8b c9		 mov	 ecx, ecx
  00cb7	48 3b c1	 cmp	 rax, rcx
  00cba	72 39		 jb	 SHORT $LN63@s370_logic
  00cbc	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00cc3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00ccb	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00cd0	b9 08 00 00 00	 mov	 ecx, 8
  00cd5	48 6b c9 0c	 imul	 rcx, rcx, 12
  00cd9	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00ce1	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00ce8	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00cee	8b c9		 mov	 ecx, ecx
  00cf0	48 3b c1	 cmp	 rax, rcx
  00cf3	76 69		 jbe	 SHORT $LN64@s370_logic
$LN63@s370_logic:
  00cf5	b8 08 00 00 00	 mov	 eax, 8
  00cfa	48 6b c0 0b	 imul	 rax, rax, 11
  00cfe	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d06	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00d0d	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00d12	39 84 24 90 00
	00 00		 cmp	 DWORD PTR addr$[rsp], eax
  00d19	77 39		 ja	 SHORT $LN65@s370_logic
  00d1b	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00d22	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00d2a	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00d2f	b9 08 00 00 00	 mov	 ecx, 8
  00d34	48 6b c9 0c	 imul	 rcx, rcx, 12
  00d38	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00d40	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00d47	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00d4d	8b c9		 mov	 ecx, ecx
  00d4f	48 3b c1	 cmp	 rax, rcx
  00d52	73 0a		 jae	 SHORT $LN64@s370_logic
$LN65@s370_logic:
  00d54	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv632[rsp], 0
  00d5c	eb 08		 jmp	 SHORT $LN68@s370_logic
$LN64@s370_logic:
  00d5e	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv632[rsp], 1
$LN68@s370_logic:
  00d66	8b 44 24 50	 mov	 eax, DWORD PTR tv632[rsp]
  00d6a	89 44 24 58	 mov	 DWORD PTR tv633[rsp], eax
  00d6e	eb 79		 jmp	 SHORT $LN70@s370_logic
$LN69@s370_logic:
  00d70	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00d77	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00d7f	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00d84	b9 08 00 00 00	 mov	 ecx, 8
  00d89	48 6b c9 0b	 imul	 rcx, rcx, 11
  00d8d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00d95	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00d9c	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00da2	8b c9		 mov	 ecx, ecx
  00da4	48 3b c1	 cmp	 rax, rcx
  00da7	73 30		 jae	 SHORT $LN66@s370_logic
  00da9	b8 08 00 00 00	 mov	 eax, 8
  00dae	48 6b c0 0c	 imul	 rax, rax, 12
  00db2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00dba	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00dc1	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00dc6	39 84 24 90 00
	00 00		 cmp	 DWORD PTR addr$[rsp], eax
  00dcd	76 0a		 jbe	 SHORT $LN66@s370_logic
  00dcf	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv631[rsp], 0
  00dd7	eb 08		 jmp	 SHORT $LN67@s370_logic
$LN66@s370_logic:
  00dd9	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv631[rsp], 1
$LN67@s370_logic:
  00de1	8b 44 24 54	 mov	 eax, DWORD PTR tv631[rsp]
  00de5	89 44 24 58	 mov	 DWORD PTR tv633[rsp], eax
$LN70@s370_logic:
  00de9	83 7c 24 58 00	 cmp	 DWORD PTR tv633[rsp], 0
  00dee	74 27		 je	 SHORT $LN30@s370_logic
  00df0	33 c0		 xor	 eax, eax
  00df2	83 f8 01	 cmp	 eax, 1
  00df5	74 20		 je	 SHORT $LN30@s370_logic
$LN4@s370_logic:

; 2537 :             )
; 2538 :                 ON_IC_PER_SA( regs );

  00df7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dff	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00e02	0f ba e8 15	 bts	 eax, 21
  00e06	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e0e	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00e11	33 c0		 xor	 eax, eax
  00e13	85 c0		 test	 eax, eax
  00e15	75 e0		 jne	 SHORT $LN4@s370_logic
$LN30@s370_logic:
$LN29@s370_logic:
$LN22@s370_logic:

; 2539 :         }
; 2540 : #endif /* defined( FEATURE_PER ) */
; 2541 :     } /* (acctype & (ACC_WRITE | ACC_CHECK)) */
; 2542 : 
; 2543 :     /* Return mainstor address */
; 2544 :     return regs->mainstor + aaddr;

  00e17	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e1f	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00e26	48 03 44 24 28	 add	 rax, QWORD PTR aaddr$[rsp]
  00e2b	e9 bf 00 00 00	 jmp	 $LN1@s370_logic
$vabs_addr_excp$74:

; 2545 : 
; 2546 : vabs_addr_excp:
; 2547 : 
; 2548 :     regs->program_interrupt (regs, PGM_ADDRESSING_EXCEPTION);

  00e30	ba 05 00 00 00	 mov	 edx, 5
  00e35	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e3d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e45	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$vabs_prot_excp$73:

; 2549 : 
; 2550 : vabs_prot_excp:
; 2551 : 
; 2552 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 2553 :     regs->TEA = addr & STORAGE_KEY_PAGEMASK;
; 2554 :     if (regs->dat.protect && (acctype & (ACC_WRITE|ACC_CHECK)) )
; 2555 :     {
; 2556 :         regs->TEA |= TEA_PROT_AP;
; 2557 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 2558 :         if (regs->dat.protect & 2)
; 2559 :             regs->TEA |= TEA_PROT_A;
; 2560 : #endif
; 2561 :     }
; 2562 :     regs->TEA |= regs->dat.stid;
; 2563 :     regs->excarid = (arn > 0 ? arn : 0);
; 2564 : #endif /* defined( FEATURE_SUPPRESSION_ON_PROTECTION ) */
; 2565 : 
; 2566 : #if defined( _FEATURE_PROTECTION_INTERCEPTION_CONTROL )
; 2567 :     if (SIE_MODE( regs ) && HOSTREGS->dat.protect)

  00e4b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e53	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00e59	d1 e8		 shr	 eax, 1
  00e5b	83 e0 01	 and	 eax, 1
  00e5e	85 c0		 test	 eax, eax
  00e60	74 49		 je	 SHORT $LN31@s370_logic
  00e62	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e6a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00e71	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00e77	d1 e8		 shr	 eax, 1
  00e79	83 e0 03	 and	 eax, 3
  00e7c	85 c0		 test	 eax, eax
  00e7e	74 2b		 je	 SHORT $LN31@s370_logic

; 2568 :     {
; 2569 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 2570 : 
; 2571 :         switch (HOSTREGS->arch_mode)
; 2572 :         {
; 2573 :         case ARCH_370_IDX: HOSTREGS->TEA_370 = regs->TEA; break;
; 2574 :         case ARCH_390_IDX: HOSTREGS->TEA_390 = regs->TEA; break;
; 2575 :         case ARCH_900_IDX: HOSTREGS->TEA_900 = regs->TEA; break;
; 2576 :         default: CRASH();
; 2577 :         }
; 2578 : 
; 2579 :         HOSTREGS->excarid = regs->excarid;
; 2580 : 
; 2581 : #endif /* defined( FEATURE_SUPPRESSION_ON_PROTECTION ) */
; 2582 : 
; 2583 :         HOSTREGS->program_interrupt( HOSTREGS, PGM_PROTECTION_EXCEPTION );

  00e80	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e88	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00e8f	ba 04 00 00 00	 mov	 edx, 4
  00e94	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e9c	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00ea3	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]

; 2584 :     }

  00ea9	eb 1b		 jmp	 SHORT $LN32@s370_logic
$LN31@s370_logic:

; 2585 :     else
; 2586 : #endif /* defined( _FEATURE_PROTECTION_INTERCEPTION_CONTROL ) */
; 2587 :         regs->program_interrupt (regs, PGM_PROTECTION_EXCEPTION);

  00eab	ba 04 00 00 00	 mov	 edx, 4
  00eb0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00eb8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ec0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN32@s370_logic:
$vabs_prog_check$72:

; 2588 : 
; 2589 : vabs_prog_check:
; 2590 : 
; 2591 :     regs->program_interrupt (regs, regs->dat.xcode);

  00ec6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ece	0f b7 80 30 08
	00 00		 movzx	 eax, WORD PTR [rax+2096]
  00ed5	8b d0		 mov	 edx, eax
  00ed7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00edf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ee7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]

; 2592 : 
; 2593 :     return NULL; /* prevent warning from compiler */

  00eed	33 c0		 xor	 eax, eax
$LN1@s370_logic:

; 2594 : } /* end function ARCH_DEP(logical_to_main_l) */

  00eef	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00ef6	c3		 ret	 0
s370_logical_to_main_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_storage_key_by_ptr
_TEXT	SEGMENT
abs$ = 32
skey_ptr$ = 64
bits$ = 72
s370_or_storage_key_by_ptr PROC				; COMDAT

; 328  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 329  :     U64 abs = (skey_ptr - sysblk.storkeys) << _STORKEY_ARRAY_SHIFTAMT;

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00014	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR skey_ptr$[rsp]
  00020	48 2b c8	 sub	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx
  00026	48 c1 e0 0b	 shl	 rax, 11
  0002a	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 330  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 331  :     ARCH_DEP( or_2K_storage_key )( abs, bits );

  0002f	0f b6 54 24 48	 movzx	 edx, BYTE PTR bits$[rsp]
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  00039	e8 00 00 00 00	 call	 s370_or_2K_storage_key

; 332  : #else
; 333  :     ARCH_DEP( or_4K_storage_key )( abs, bits );
; 334  : #endif
; 335  : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
s370_or_storage_key_by_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_get_storekey_by_ptr
_TEXT	SEGMENT
abs$ = 32
skey_ptr$ = 64
s370_get_storekey_by_ptr PROC				; COMDAT

; 317  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 318  :     U64 abs = (skey_ptr - sysblk.storkeys) << _STORKEY_ARRAY_SHIFTAMT;

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR skey_ptr$[rsp]
  0001c	48 2b c8	 sub	 rcx, rax
  0001f	48 8b c1	 mov	 rax, rcx
  00022	48 c1 e0 0b	 shl	 rax, 11
  00026	48 89 44 24 20	 mov	 QWORD PTR abs$[rsp], rax

; 319  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 320  :     return ARCH_DEP( get_2K_storage_key )( abs );

  0002b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR abs$[rsp]
  00030	e8 00 00 00 00	 call	 s370_get_2K_storage_key

; 321  : #else
; 322  :     return ARCH_DEP( get_4K_storage_key )( abs );
; 323  : #endif
; 324  : }

  00035	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00039	c3		 ret	 0
s370_get_storekey_by_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_get_ptr_to_storekey
_TEXT	SEGMENT
abs$ = 48
s370_get_ptr_to_storekey PROC				; COMDAT

; 308  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 309  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 310  :     return ARCH_DEP( get_ptr_to_2K_storekey )( abs );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0000e	e8 00 00 00 00	 call	 s370_get_ptr_to_2K_storekey

; 311  : #else
; 312  :     return ARCH_DEP( get_ptr_to_4K_storekey )( abs );
; 313  : #endif
; 314  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
s370_get_ptr_to_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s370_or_2K_storage_key

; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );
; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s370_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_2K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_2K_storage_key PROC				; COMDAT

; 231  :   inline void  ARCH_DEP( or_2K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 2 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 02	 mov	 r8b, 2
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s370__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s370_or_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_get_2K_storage_key
_TEXT	SEGMENT
abs$ = 48
s370_get_2K_storage_key PROC				; COMDAT

; 228  :   inline BYTE  ARCH_DEP( get_2K_storage_key )     (              U64 abs            ) { return ARCH_DEP( _get_storage_key     )(      abs, 2 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 02		 mov	 dl, 2
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 s370__get_storage_key
  00015	0f b6 c0	 movzx	 eax, al
  00018	83 e0 fe	 and	 eax, -2
  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
s370_get_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_get_ptr_to_2K_storekey
_TEXT	SEGMENT
abs$ = 48
s370_get_ptr_to_2K_storekey PROC			; COMDAT

; 227  :   inline BYTE* ARCH_DEP( get_ptr_to_2K_storekey ) (              U64 abs            ) { return           _get_storekey_ptr     (      abs, 2 );                         }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 02		 mov	 dl, 2
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 _get_storekey_ptr
  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
s370_get_ptr_to_2K_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s370__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	0f b6 44 24 60	 movzx	 eax, BYTE PTR K$[rsp]
  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 57		 jne	 SHORT $LN5@s370__or_s
  00022	33 c0		 xor	 eax, eax
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 50		 je	 SHORT $LN5@s370__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0003d	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00042	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  00047	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00051	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00054	0b c8		 or	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0005d	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  0005f	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00064	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00069	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006c	0b c8		 or	 ecx, eax
  0006e	8b c1		 mov	 eax, ecx
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00075	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  00077	eb 2c		 jmp	 SHORT $LN6@s370__or_s
$LN5@s370__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  00079	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00083	e8 00 00 00 00	 call	 _get_storekey_ptr
  00088	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  0008d	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00097	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0009a	0b c8		 or	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a3	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_s:

; 202  :     }
; 203  : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
s370__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__get_storage_key
_TEXT	SEGMENT
skey$ = 32
abs$ = 64
K$ = 72
s370__get_storage_key PROC				; COMDAT

; 130  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370__get_:

; 131  :     BYTE skey;
; 132  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 fa		 jne	 SHORT $LN4@s370__get_

; 133  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00013	0f b6 44 24 48	 movzx	 eax, BYTE PTR K$[rsp]
  00018	83 f8 04	 cmp	 eax, 4
  0001b	75 39		 jne	 SHORT $LN5@s370__get_
  0001d	33 c0		 xor	 eax, eax
  0001f	83 f8 01	 cmp	 eax, 1
  00022	74 32		 je	 SHORT $LN5@s370__get_

; 134  :     {
; 135  :         skey  = *_get_storekey1_ptr( abs );

  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00029	e8 00 00 00 00	 call	 _get_storekey1_ptr
  0002e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00031	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 136  :         skey |= *_get_storekey2_ptr( abs ) & ~(STORKEY_KEY);

  00035	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  0003a	e8 00 00 00 00	 call	 _get_storekey2_ptr
  0003f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00042	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  00047	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  0004c	0b c8		 or	 ecx, eax
  0004e	8b c1		 mov	 eax, ecx
  00050	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 137  :     }

  00054	eb 16		 jmp	 SHORT $LN6@s370__get_
$LN5@s370__get_:

; 138  :     else
; 139  :         skey  = *_get_storekey_ptr(  abs, K );

  00056	0f b6 54 24 48	 movzx	 edx, BYTE PTR K$[rsp]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR abs$[rsp]
  00060	e8 00 00 00 00	 call	 _get_storekey_ptr
  00065	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00068	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@s370__get_:

; 140  :     return skey;

  0006c	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 141  : }

  00071	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00075	c3		 ret	 0
s370__get_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
n$ = 72
z900_update_guest_psw_ia PROC

; 80   : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 81   :     switch (GUESTREGS->arch_mode)

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00012	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00019	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0001c	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  00020	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00025	74 10		 je	 SHORT $LN7@z900_updat
  00027	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  0002c	74 20		 je	 SHORT $LN8@z900_updat
  0002e	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  00033	74 30		 je	 SHORT $LN9@z900_updat
  00035	eb 45		 jmp	 SHORT $LN10@z900_updat
$LN7@z900_updat:

; 82   :     {
; 83   :     case ARCH_370_IDX: s370_update_psw_ia( GUESTREGS, n ); break;

  00037	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00040	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00047	e8 00 00 00 00	 call	 s370_update_psw_ia
  0004c	eb 45		 jmp	 SHORT $LN2@z900_updat
$LN8@z900_updat:

; 84   :     case ARCH_390_IDX: s390_update_psw_ia( GUESTREGS, n ); break;

  0004e	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0005e	e8 00 00 00 00	 call	 s390_update_psw_ia
  00063	eb 2e		 jmp	 SHORT $LN2@z900_updat
$LN9@z900_updat:

; 85   :     case ARCH_900_IDX: z900_update_psw_ia( GUESTREGS, n ); break;

  00065	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00075	e8 00 00 00 00	 call	 z900_update_psw_ia
  0007a	eb 17		 jmp	 SHORT $LN2@z900_updat
$LN10@z900_updat:
$LN6@z900_updat:

; 86   :     default: CRASH();

  0007c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00085	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0008a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0008d	33 c0		 xor	 eax, eax
  0008f	85 c0		 test	 eax, eax
  00091	75 e9		 jne	 SHORT $LN6@z900_updat
$LN2@z900_updat:

; 87   :     }
; 88   : }

  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
z900_update_guest_psw_ia ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
n$ = 72
s390_update_guest_psw_ia PROC

; 80   : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 81   :     switch (GUESTREGS->arch_mode)

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00012	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00019	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0001c	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  00020	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00025	74 10		 je	 SHORT $LN7@s390_updat
  00027	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  0002c	74 20		 je	 SHORT $LN8@s390_updat
  0002e	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  00033	74 30		 je	 SHORT $LN9@s390_updat
  00035	eb 45		 jmp	 SHORT $LN10@s390_updat
$LN7@s390_updat:

; 82   :     {
; 83   :     case ARCH_370_IDX: s370_update_psw_ia( GUESTREGS, n ); break;

  00037	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00040	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00047	e8 00 00 00 00	 call	 s370_update_psw_ia
  0004c	eb 45		 jmp	 SHORT $LN2@s390_updat
$LN8@s390_updat:

; 84   :     case ARCH_390_IDX: s390_update_psw_ia( GUESTREGS, n ); break;

  0004e	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0005e	e8 00 00 00 00	 call	 s390_update_psw_ia
  00063	eb 2e		 jmp	 SHORT $LN2@s390_updat
$LN9@s390_updat:

; 85   :     case ARCH_900_IDX: z900_update_psw_ia( GUESTREGS, n ); break;

  00065	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00075	e8 00 00 00 00	 call	 z900_update_psw_ia
  0007a	eb 17		 jmp	 SHORT $LN2@s390_updat
$LN10@s390_updat:
$LN6@s390_updat:

; 86   :     default: CRASH();

  0007c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00085	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0008a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0008d	33 c0		 xor	 eax, eax
  0008f	85 c0		 test	 eax, eax
  00091	75 e9		 jne	 SHORT $LN6@s390_updat
$LN2@s390_updat:

; 87   :     }
; 88   : }

  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
s390_update_guest_psw_ia ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
n$ = 72
s370_update_guest_psw_ia PROC

; 80   : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 81   :     switch (GUESTREGS->arch_mode)

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00012	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00019	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0001c	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  00020	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00025	74 10		 je	 SHORT $LN7@s370_updat
  00027	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  0002c	74 20		 je	 SHORT $LN8@s370_updat
  0002e	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  00033	74 30		 je	 SHORT $LN9@s370_updat
  00035	eb 45		 jmp	 SHORT $LN10@s370_updat
$LN7@s370_updat:

; 82   :     {
; 83   :     case ARCH_370_IDX: s370_update_psw_ia( GUESTREGS, n ); break;

  00037	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00040	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00047	e8 00 00 00 00	 call	 s370_update_psw_ia
  0004c	eb 45		 jmp	 SHORT $LN2@s370_updat
$LN8@s370_updat:

; 84   :     case ARCH_390_IDX: s390_update_psw_ia( GUESTREGS, n ); break;

  0004e	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00057	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0005e	e8 00 00 00 00	 call	 s390_update_psw_ia
  00063	eb 2e		 jmp	 SHORT $LN2@s370_updat
$LN9@s370_updat:

; 85   :     case ARCH_900_IDX: z900_update_psw_ia( GUESTREGS, n ); break;

  00065	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00075	e8 00 00 00 00	 call	 z900_update_psw_ia
  0007a	eb 17		 jmp	 SHORT $LN2@s370_updat
$LN10@s370_updat:
$LN6@s370_updat:

; 86   :     default: CRASH();

  0007c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00085	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0008a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0008d	33 c0		 xor	 eax, eax
  0008f	85 c0		 test	 eax, eax
  00091	75 e9		 jne	 SHORT $LN6@s370_updat
$LN2@s370_updat:

; 87   :     }
; 88   : }

  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
s370_update_guest_psw_ia ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
regs$ = 80
n$ = 88
z900_update_psw_ia PROC

; 70   : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 71   :     regs->psw.IA += n;

  0000d	48 63 44 24 58	 movsxd	 rax, DWORD PTR n$[rsp]
  00012	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	48 03 81 88 00
	00 00		 add	 rax, QWORD PTR [rcx+136]
  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00023	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 72   :     regs->psw.IA &= ADDRESS_MAXWRAP( regs );

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00034	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  0003b	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00042	48 23 c1	 and	 rax, rcx
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN4@z900_updat:

; 73   :     PTT_PGM( "PGM IA+-sie", regs->psw.IA, regs->instinvalid, n );

  00051	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00058	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005b	48 83 e0 20	 and	 rax, 32			; 00000020H
  0005f	48 85 c0	 test	 rax, rax
  00062	74 53		 je	 SHORT $LN5@z900_updat
  00064	48 63 44 24 58	 movsxd	 rax, DWORD PTR n$[rsp]
  00069	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00074	c1 e9 03	 shr	 ecx, 3
  00077	83 e1 01	 and	 ecx, 1
  0007a	8b c9		 mov	 ecx, ecx
  0007c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00085	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194037
  00091	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00096	44 8b c9	 mov	 r9d, ecx
  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	4c 8b 80 88 00
	00 00		 mov	 r8, QWORD PTR [rax+136]
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194038
  000ac	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN5@z900_updat:
  000b7	33 c0		 xor	 eax, eax
  000b9	85 c0		 test	 eax, eax
  000bb	75 94		 jne	 SHORT $LN4@z900_updat

; 74   : }

  000bd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c1	c3		 ret	 0
z900_update_psw_ia ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
regs$ = 80
n$ = 88
s390_update_psw_ia PROC

; 70   : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 71   :     regs->psw.IA += n;

  0000d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00012	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00018	03 44 24 58	 add	 eax, DWORD PTR n$[rsp]
  0001c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00021	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 72   :     regs->psw.IA &= ADDRESS_MAXWRAP( regs );

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00031	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00037	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0003d	23 c1		 and	 eax, ecx
  0003f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00044	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN4@s390_updat:

; 73   :     PTT_PGM( "PGM IA+-sie", regs->psw.IA, regs->instinvalid, n );

  0004a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00051	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00054	48 83 e0 20	 and	 rax, 32			; 00000020H
  00058	48 85 c0	 test	 rax, rax
  0005b	74 55		 je	 SHORT $LN5@s390_updat
  0005d	48 63 44 24 58	 movsxd	 rax, DWORD PTR n$[rsp]
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00067	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  0006d	c1 e9 03	 shr	 ecx, 3
  00070	83 e1 01	 and	 ecx, 1
  00073	8b c9		 mov	 ecx, ecx
  00075	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0007a	8b 92 88 00 00
	00		 mov	 edx, DWORD PTR [rdx+136]
  00080	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00089	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180312
  00095	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009a	44 8b c9	 mov	 r9d, ecx
  0009d	44 8b c2	 mov	 r8d, edx
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180313
  000a7	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN5@s390_updat:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 92		 jne	 SHORT $LN4@s390_updat

; 74   : }

  000b8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bc	c3		 ret	 0
s390_update_psw_ia ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
regs$ = 80
n$ = 88
s370_update_psw_ia PROC

; 70   : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 71   :     regs->psw.IA += n;

  0000d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00012	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00018	03 44 24 58	 add	 eax, DWORD PTR n$[rsp]
  0001c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00021	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 72   :     regs->psw.IA &= ADDRESS_MAXWRAP( regs );

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002c	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00032	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00037	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0003c	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN4@s370_updat:

; 73   :     PTT_PGM( "PGM IA+-sie", regs->psw.IA, regs->instinvalid, n );

  00042	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00049	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004c	48 83 e0 20	 and	 rax, 32			; 00000020H
  00050	48 85 c0	 test	 rax, rax
  00053	74 55		 je	 SHORT $LN5@s370_updat
  00055	48 63 44 24 58	 movsxd	 rax, DWORD PTR n$[rsp]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00065	c1 e9 03	 shr	 ecx, 3
  00068	83 e1 01	 and	 ecx, 1
  0006b	8b c9		 mov	 ecx, ecx
  0006d	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  00072	8b 92 88 00 00
	00		 mov	 edx, DWORD PTR [rdx+136]
  00078	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00081	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00086	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169583
  0008d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00092	44 8b c9	 mov	 r9d, ecx
  00095	44 8b c2	 mov	 r8d, edx
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169584
  0009f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN5@s370_updat:
  000aa	33 c0		 xor	 eax, eax
  000ac	85 c0		 test	 eax, eax
  000ae	75 92		 jne	 SHORT $LN4@s370_updat

; 74   : }

  000b0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b4	c3		 ret	 0
s370_update_psw_ia ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 0
aaddr$ = 8
tv80 = 16
tv94 = 24
tv136 = 32
p$1 = 40
regs$ = 64
raddr$ = 72
apply_host_prefixing PROC

; 2625 : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2626 :     RADR aaddr = 0;

  0000e	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR aaddr$[rsp], 0

; 2627 :     switch (HOSTREGS->arch_mode)

  00017	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00023	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00026	89 04 24	 mov	 DWORD PTR tv66[rsp], eax
  00029	83 3c 24 00	 cmp	 DWORD PTR tv66[rsp], 0
  0002d	74 15		 je	 SHORT $LN7@apply_host
  0002f	83 3c 24 01	 cmp	 DWORD PTR tv66[rsp], 1
  00033	74 75		 je	 SHORT $LN8@apply_host
  00035	83 3c 24 02	 cmp	 DWORD PTR tv66[rsp], 2
  00039	0f 84 ce 00 00
	00		 je	 $LN9@apply_host
  0003f	e9 2e 01 00 00	 jmp	 $LN10@apply_host
$LN7@apply_host:

; 2628 :     {
; 2629 :     case ARCH_370_IDX: aaddr = APPLY_370_PREFIXING( raddr, HOSTREGS->PX_370 ); break;

  00044	8b 44 24 48	 mov	 eax, DWORD PTR raddr$[rsp]
  00048	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0004e	48 85 c0	 test	 rax, rax
  00051	74 2a		 je	 SHORT $LN12@apply_host
  00053	8b 44 24 48	 mov	 eax, DWORD PTR raddr$[rsp]
  00057	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00069	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0006c	48 3b c1	 cmp	 rax, rcx
  0006f	74 0c		 je	 SHORT $LN12@apply_host
  00071	48 8b 44 24 48	 mov	 rax, QWORD PTR raddr$[rsp]
  00076	48 89 44 24 10	 mov	 QWORD PTR tv80[rsp], rax
  0007b	eb 1e		 jmp	 SHORT $LN13@apply_host
$LN12@apply_host:
  0007d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00082	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00089	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0008c	8b 4c 24 48	 mov	 ecx, DWORD PTR raddr$[rsp]
  00090	33 c8		 xor	 ecx, eax
  00092	8b c1		 mov	 eax, ecx
  00094	8b c0		 mov	 eax, eax
  00096	48 89 44 24 10	 mov	 QWORD PTR tv80[rsp], rax
$LN13@apply_host:
  0009b	48 8b 44 24 10	 mov	 rax, QWORD PTR tv80[rsp]
  000a0	48 89 44 24 08	 mov	 QWORD PTR aaddr$[rsp], rax
  000a5	e9 df 00 00 00	 jmp	 $LN2@apply_host
$LN8@apply_host:

; 2630 :     case ARCH_390_IDX: aaddr = APPLY_390_PREFIXING( raddr, HOSTREGS->PX_390 ); break;

  000aa	8b 44 24 48	 mov	 eax, DWORD PTR raddr$[rsp]
  000ae	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000b4	48 85 c0	 test	 rax, rax
  000b7	74 2a		 je	 SHORT $LN14@apply_host
  000b9	8b 44 24 48	 mov	 eax, DWORD PTR raddr$[rsp]
  000bd	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000c3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  000cf	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  000d2	48 3b c1	 cmp	 rax, rcx
  000d5	74 0c		 je	 SHORT $LN14@apply_host
  000d7	48 8b 44 24 48	 mov	 rax, QWORD PTR raddr$[rsp]
  000dc	48 89 44 24 18	 mov	 QWORD PTR tv94[rsp], rax
  000e1	eb 1e		 jmp	 SHORT $LN15@apply_host
$LN14@apply_host:
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ef	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  000f2	8b 4c 24 48	 mov	 ecx, DWORD PTR raddr$[rsp]
  000f6	33 c8		 xor	 ecx, eax
  000f8	8b c1		 mov	 eax, ecx
  000fa	8b c0		 mov	 eax, eax
  000fc	48 89 44 24 18	 mov	 QWORD PTR tv94[rsp], rax
$LN15@apply_host:
  00101	48 8b 44 24 18	 mov	 rax, QWORD PTR tv94[rsp]
  00106	48 89 44 24 08	 mov	 QWORD PTR aaddr$[rsp], rax
  0010b	eb 7c		 jmp	 SHORT $LN2@apply_host
$LN9@apply_host:

; 2631 :     case ARCH_900_IDX: aaddr = APPLY_900_PREFIXING( raddr, HOSTREGS->PX_900 ); break;

  0010d	48 8b 44 24 48	 mov	 rax, QWORD PTR raddr$[rsp]
  00112	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00118	48 85 c0	 test	 rax, rax
  0011b	74 29		 je	 SHORT $LN16@apply_host
  0011d	48 8b 44 24 48	 mov	 rax, QWORD PTR raddr$[rsp]
  00122	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00128	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0012d	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00134	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  00138	74 0c		 je	 SHORT $LN16@apply_host
  0013a	48 8b 44 24 48	 mov	 rax, QWORD PTR raddr$[rsp]
  0013f	48 89 44 24 20	 mov	 QWORD PTR tv136[rsp], rax
  00144	eb 20		 jmp	 SHORT $LN17@apply_host
$LN16@apply_host:
  00146	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0014b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00152	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00156	48 8b 4c 24 48	 mov	 rcx, QWORD PTR raddr$[rsp]
  0015b	48 33 c8	 xor	 rcx, rax
  0015e	48 8b c1	 mov	 rax, rcx
  00161	48 89 44 24 20	 mov	 QWORD PTR tv136[rsp], rax
$LN17@apply_host:
  00166	48 8b 44 24 20	 mov	 rax, QWORD PTR tv136[rsp]
  0016b	48 89 44 24 08	 mov	 QWORD PTR aaddr$[rsp], rax
  00170	eb 17		 jmp	 SHORT $LN2@apply_host
$LN10@apply_host:
$LN6@apply_host:

; 2632 :     default: CRASH();

  00172	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  0017b	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00180	c6 00 00	 mov	 BYTE PTR [rax], 0
  00183	33 c0		 xor	 eax, eax
  00185	85 c0		 test	 eax, eax
  00187	75 e9		 jne	 SHORT $LN6@apply_host
$LN2@apply_host:

; 2633 :     }
; 2634 :     return aaddr;

  00189	48 8b 44 24 08	 mov	 rax, QWORD PTR aaddr$[rsp]

; 2635 : }

  0018e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00192	c3		 ret	 0
apply_host_prefixing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv74 = 32
tv94 = 36
p$1 = 40
p$2 = 48
regs$ = 80
main$ = 88
z900_invalidate_tlbe PROC

; 2087 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2088 :     /* Do it for the current architecture first */
; 2089 :     ARCH_DEP( do_invalidate_tlbe )( regs, main );

  0000e	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00018	e8 00 00 00 00	 call	 z900_do_invalidate_tlbe

; 2090 : 
; 2091 : #if defined( _FEATURE_SIE )
; 2092 :     /* Also clear the GUEST registers in the SIE copy */
; 2093 :     if (regs->host && GUESTREGS)

  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00028	c1 e8 07	 shr	 eax, 7
  0002b	83 e0 01	 and	 eax, 1
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 a1 00 00
	00		 je	 $LN12@z900_inval
  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0003b	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00043	0f 84 8e 00 00
	00		 je	 $LN12@z900_inval

; 2094 :     {
; 2095 :         switch (GUESTREGS->arch_mode)

  00049	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00055	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00058	89 44 24 20	 mov	 DWORD PTR tv74[rsp], eax
  0005c	83 7c 24 20 00	 cmp	 DWORD PTR tv74[rsp], 0
  00061	74 10		 je	 SHORT $LN14@z900_inval
  00063	83 7c 24 20 01	 cmp	 DWORD PTR tv74[rsp], 1
  00068	74 21		 je	 SHORT $LN15@z900_inval
  0006a	83 7c 24 20 02	 cmp	 DWORD PTR tv74[rsp], 2
  0006f	74 32		 je	 SHORT $LN16@z900_inval
  00071	eb 48		 jmp	 SHORT $LN17@z900_inval
$LN14@z900_inval:

; 2096 :         {
; 2097 :         case ARCH_370_IDX: s370_do_invalidate_tlbe( GUESTREGS, main ); break;

  00073	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  00078	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00084	e8 00 00 00 00	 call	 s370_do_invalidate_tlbe
  00089	eb 47		 jmp	 SHORT $LN2@z900_inval
$LN15@z900_inval:

; 2098 :         case ARCH_390_IDX: s390_do_invalidate_tlbe( GUESTREGS, main ); break;

  0008b	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00095	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0009c	e8 00 00 00 00	 call	 s390_do_invalidate_tlbe
  000a1	eb 2f		 jmp	 SHORT $LN2@z900_inval
$LN16@z900_inval:

; 2099 :         case ARCH_900_IDX: z900_do_invalidate_tlbe( GUESTREGS, main ); break;

  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  000b4	e8 00 00 00 00	 call	 z900_do_invalidate_tlbe
  000b9	eb 17		 jmp	 SHORT $LN2@z900_inval
$LN17@z900_inval:
$LN6@z900_inval:

; 2100 :         default: CRASH();

  000bb	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000c4	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000c9	c6 00 00	 mov	 BYTE PTR [rax], 0
  000cc	33 c0		 xor	 eax, eax
  000ce	85 c0		 test	 eax, eax
  000d0	75 e9		 jne	 SHORT $LN6@z900_inval
$LN2@z900_inval:

; 2101 :         }
; 2102 :     }

  000d2	e9 a2 00 00 00	 jmp	 $LN13@z900_inval
$LN12@z900_inval:

; 2103 :     else if (regs->guest)  /* For guests, also clear HOST entries */

  000d7	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000e2	c1 e8 08	 shr	 eax, 8
  000e5	83 e0 01	 and	 eax, 1
  000e8	85 c0		 test	 eax, eax
  000ea	0f 84 89 00 00
	00		 je	 $LN18@z900_inval

; 2104 :     {
; 2105 :         switch (HOSTREGS->arch_mode)

  000f0	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000fc	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  000ff	89 44 24 24	 mov	 DWORD PTR tv94[rsp], eax
  00103	83 7c 24 24 00	 cmp	 DWORD PTR tv94[rsp], 0
  00108	74 10		 je	 SHORT $LN19@z900_inval
  0010a	83 7c 24 24 01	 cmp	 DWORD PTR tv94[rsp], 1
  0010f	74 21		 je	 SHORT $LN20@z900_inval
  00111	83 7c 24 24 02	 cmp	 DWORD PTR tv94[rsp], 2
  00116	74 32		 je	 SHORT $LN21@z900_inval
  00118	eb 48		 jmp	 SHORT $LN22@z900_inval
$LN19@z900_inval:

; 2106 :         {
; 2107 :         case ARCH_370_IDX: s370_do_invalidate_tlbe( HOSTREGS, main ); break;

  0011a	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  0011f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0012b	e8 00 00 00 00	 call	 s370_do_invalidate_tlbe
  00130	eb 47		 jmp	 SHORT $LN7@z900_inval
$LN20@z900_inval:

; 2108 :         case ARCH_390_IDX: s390_do_invalidate_tlbe( HOSTREGS, main ); break;

  00132	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  00137	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0013c	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00143	e8 00 00 00 00	 call	 s390_do_invalidate_tlbe
  00148	eb 2f		 jmp	 SHORT $LN7@z900_inval
$LN21@z900_inval:

; 2109 :         case ARCH_900_IDX: z900_do_invalidate_tlbe( HOSTREGS, main ); break;

  0014a	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  0014f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00154	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0015b	e8 00 00 00 00	 call	 z900_do_invalidate_tlbe
  00160	eb 17		 jmp	 SHORT $LN7@z900_inval
$LN22@z900_inval:
$LN11@z900_inval:

; 2110 :         default: CRASH();

  00162	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  0016b	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  00170	c6 00 00	 mov	 BYTE PTR [rax], 0
  00173	33 c0		 xor	 eax, eax
  00175	85 c0		 test	 eax, eax
  00177	75 e9		 jne	 SHORT $LN11@z900_inval
$LN7@z900_inval:
$LN18@z900_inval:
$LN13@z900_inval:

; 2111 :         }
; 2112 :     }
; 2113 : #endif /* defined( _FEATURE_SIE ) */
; 2114 : 
; 2115 : } /* end function invalidate_tlbe */

  00179	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017d	c3		 ret	 0
z900_invalidate_tlbe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv74 = 32
tv94 = 36
p$1 = 40
p$2 = 48
regs$ = 80
main$ = 88
s390_invalidate_tlbe PROC

; 2087 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2088 :     /* Do it for the current architecture first */
; 2089 :     ARCH_DEP( do_invalidate_tlbe )( regs, main );

  0000e	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00018	e8 00 00 00 00	 call	 s390_do_invalidate_tlbe

; 2090 : 
; 2091 : #if defined( _FEATURE_SIE )
; 2092 :     /* Also clear the GUEST registers in the SIE copy */
; 2093 :     if (regs->host && GUESTREGS)

  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00028	c1 e8 07	 shr	 eax, 7
  0002b	83 e0 01	 and	 eax, 1
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 a1 00 00
	00		 je	 $LN12@s390_inval
  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0003b	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00043	0f 84 8e 00 00
	00		 je	 $LN12@s390_inval

; 2094 :     {
; 2095 :         switch (GUESTREGS->arch_mode)

  00049	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00055	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00058	89 44 24 20	 mov	 DWORD PTR tv74[rsp], eax
  0005c	83 7c 24 20 00	 cmp	 DWORD PTR tv74[rsp], 0
  00061	74 10		 je	 SHORT $LN14@s390_inval
  00063	83 7c 24 20 01	 cmp	 DWORD PTR tv74[rsp], 1
  00068	74 21		 je	 SHORT $LN15@s390_inval
  0006a	83 7c 24 20 02	 cmp	 DWORD PTR tv74[rsp], 2
  0006f	74 32		 je	 SHORT $LN16@s390_inval
  00071	eb 48		 jmp	 SHORT $LN17@s390_inval
$LN14@s390_inval:

; 2096 :         {
; 2097 :         case ARCH_370_IDX: s370_do_invalidate_tlbe( GUESTREGS, main ); break;

  00073	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  00078	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00084	e8 00 00 00 00	 call	 s370_do_invalidate_tlbe
  00089	eb 47		 jmp	 SHORT $LN2@s390_inval
$LN15@s390_inval:

; 2098 :         case ARCH_390_IDX: s390_do_invalidate_tlbe( GUESTREGS, main ); break;

  0008b	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00095	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0009c	e8 00 00 00 00	 call	 s390_do_invalidate_tlbe
  000a1	eb 2f		 jmp	 SHORT $LN2@s390_inval
$LN16@s390_inval:

; 2099 :         case ARCH_900_IDX: z900_do_invalidate_tlbe( GUESTREGS, main ); break;

  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  000b4	e8 00 00 00 00	 call	 z900_do_invalidate_tlbe
  000b9	eb 17		 jmp	 SHORT $LN2@s390_inval
$LN17@s390_inval:
$LN6@s390_inval:

; 2100 :         default: CRASH();

  000bb	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000c4	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000c9	c6 00 00	 mov	 BYTE PTR [rax], 0
  000cc	33 c0		 xor	 eax, eax
  000ce	85 c0		 test	 eax, eax
  000d0	75 e9		 jne	 SHORT $LN6@s390_inval
$LN2@s390_inval:

; 2101 :         }
; 2102 :     }

  000d2	e9 a2 00 00 00	 jmp	 $LN13@s390_inval
$LN12@s390_inval:

; 2103 :     else if (regs->guest)  /* For guests, also clear HOST entries */

  000d7	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000e2	c1 e8 08	 shr	 eax, 8
  000e5	83 e0 01	 and	 eax, 1
  000e8	85 c0		 test	 eax, eax
  000ea	0f 84 89 00 00
	00		 je	 $LN18@s390_inval

; 2104 :     {
; 2105 :         switch (HOSTREGS->arch_mode)

  000f0	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000fc	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  000ff	89 44 24 24	 mov	 DWORD PTR tv94[rsp], eax
  00103	83 7c 24 24 00	 cmp	 DWORD PTR tv94[rsp], 0
  00108	74 10		 je	 SHORT $LN19@s390_inval
  0010a	83 7c 24 24 01	 cmp	 DWORD PTR tv94[rsp], 1
  0010f	74 21		 je	 SHORT $LN20@s390_inval
  00111	83 7c 24 24 02	 cmp	 DWORD PTR tv94[rsp], 2
  00116	74 32		 je	 SHORT $LN21@s390_inval
  00118	eb 48		 jmp	 SHORT $LN22@s390_inval
$LN19@s390_inval:

; 2106 :         {
; 2107 :         case ARCH_370_IDX: s370_do_invalidate_tlbe( HOSTREGS, main ); break;

  0011a	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  0011f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0012b	e8 00 00 00 00	 call	 s370_do_invalidate_tlbe
  00130	eb 47		 jmp	 SHORT $LN7@s390_inval
$LN20@s390_inval:

; 2108 :         case ARCH_390_IDX: s390_do_invalidate_tlbe( HOSTREGS, main ); break;

  00132	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  00137	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0013c	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00143	e8 00 00 00 00	 call	 s390_do_invalidate_tlbe
  00148	eb 2f		 jmp	 SHORT $LN7@s390_inval
$LN21@s390_inval:

; 2109 :         case ARCH_900_IDX: z900_do_invalidate_tlbe( HOSTREGS, main ); break;

  0014a	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  0014f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00154	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0015b	e8 00 00 00 00	 call	 z900_do_invalidate_tlbe
  00160	eb 17		 jmp	 SHORT $LN7@s390_inval
$LN22@s390_inval:
$LN11@s390_inval:

; 2110 :         default: CRASH();

  00162	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  0016b	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  00170	c6 00 00	 mov	 BYTE PTR [rax], 0
  00173	33 c0		 xor	 eax, eax
  00175	85 c0		 test	 eax, eax
  00177	75 e9		 jne	 SHORT $LN11@s390_inval
$LN7@s390_inval:
$LN18@s390_inval:
$LN13@s390_inval:

; 2111 :         }
; 2112 :     }
; 2113 : #endif /* defined( _FEATURE_SIE ) */
; 2114 : 
; 2115 : } /* end function invalidate_tlbe */

  00179	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017d	c3		 ret	 0
s390_invalidate_tlbe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv74 = 32
tv94 = 36
p$1 = 40
p$2 = 48
regs$ = 80
main$ = 88
s370_invalidate_tlbe PROC

; 2087 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2088 :     /* Do it for the current architecture first */
; 2089 :     ARCH_DEP( do_invalidate_tlbe )( regs, main );

  0000e	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00018	e8 00 00 00 00	 call	 s370_do_invalidate_tlbe

; 2090 : 
; 2091 : #if defined( _FEATURE_SIE )
; 2092 :     /* Also clear the GUEST registers in the SIE copy */
; 2093 :     if (regs->host && GUESTREGS)

  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00028	c1 e8 07	 shr	 eax, 7
  0002b	83 e0 01	 and	 eax, 1
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 a1 00 00
	00		 je	 $LN12@s370_inval
  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0003b	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00043	0f 84 8e 00 00
	00		 je	 $LN12@s370_inval

; 2094 :     {
; 2095 :         switch (GUESTREGS->arch_mode)

  00049	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00055	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00058	89 44 24 20	 mov	 DWORD PTR tv74[rsp], eax
  0005c	83 7c 24 20 00	 cmp	 DWORD PTR tv74[rsp], 0
  00061	74 10		 je	 SHORT $LN14@s370_inval
  00063	83 7c 24 20 01	 cmp	 DWORD PTR tv74[rsp], 1
  00068	74 21		 je	 SHORT $LN15@s370_inval
  0006a	83 7c 24 20 02	 cmp	 DWORD PTR tv74[rsp], 2
  0006f	74 32		 je	 SHORT $LN16@s370_inval
  00071	eb 48		 jmp	 SHORT $LN17@s370_inval
$LN14@s370_inval:

; 2096 :         {
; 2097 :         case ARCH_370_IDX: s370_do_invalidate_tlbe( GUESTREGS, main ); break;

  00073	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  00078	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00084	e8 00 00 00 00	 call	 s370_do_invalidate_tlbe
  00089	eb 47		 jmp	 SHORT $LN2@s370_inval
$LN15@s370_inval:

; 2098 :         case ARCH_390_IDX: s390_do_invalidate_tlbe( GUESTREGS, main ); break;

  0008b	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00095	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0009c	e8 00 00 00 00	 call	 s390_do_invalidate_tlbe
  000a1	eb 2f		 jmp	 SHORT $LN2@s370_inval
$LN16@s370_inval:

; 2099 :         case ARCH_900_IDX: z900_do_invalidate_tlbe( GUESTREGS, main ); break;

  000a3	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  000b4	e8 00 00 00 00	 call	 z900_do_invalidate_tlbe
  000b9	eb 17		 jmp	 SHORT $LN2@s370_inval
$LN17@s370_inval:
$LN6@s370_inval:

; 2100 :         default: CRASH();

  000bb	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000c4	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000c9	c6 00 00	 mov	 BYTE PTR [rax], 0
  000cc	33 c0		 xor	 eax, eax
  000ce	85 c0		 test	 eax, eax
  000d0	75 e9		 jne	 SHORT $LN6@s370_inval
$LN2@s370_inval:

; 2101 :         }
; 2102 :     }

  000d2	e9 a2 00 00 00	 jmp	 $LN13@s370_inval
$LN12@s370_inval:

; 2103 :     else if (regs->guest)  /* For guests, also clear HOST entries */

  000d7	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000e2	c1 e8 08	 shr	 eax, 8
  000e5	83 e0 01	 and	 eax, 1
  000e8	85 c0		 test	 eax, eax
  000ea	0f 84 89 00 00
	00		 je	 $LN18@s370_inval

; 2104 :     {
; 2105 :         switch (HOSTREGS->arch_mode)

  000f0	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000fc	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  000ff	89 44 24 24	 mov	 DWORD PTR tv94[rsp], eax
  00103	83 7c 24 24 00	 cmp	 DWORD PTR tv94[rsp], 0
  00108	74 10		 je	 SHORT $LN19@s370_inval
  0010a	83 7c 24 24 01	 cmp	 DWORD PTR tv94[rsp], 1
  0010f	74 21		 je	 SHORT $LN20@s370_inval
  00111	83 7c 24 24 02	 cmp	 DWORD PTR tv94[rsp], 2
  00116	74 32		 je	 SHORT $LN21@s370_inval
  00118	eb 48		 jmp	 SHORT $LN22@s370_inval
$LN19@s370_inval:

; 2106 :         {
; 2107 :         case ARCH_370_IDX: s370_do_invalidate_tlbe( HOSTREGS, main ); break;

  0011a	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  0011f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0012b	e8 00 00 00 00	 call	 s370_do_invalidate_tlbe
  00130	eb 47		 jmp	 SHORT $LN7@s370_inval
$LN20@s370_inval:

; 2108 :         case ARCH_390_IDX: s390_do_invalidate_tlbe( HOSTREGS, main ); break;

  00132	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  00137	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0013c	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00143	e8 00 00 00 00	 call	 s390_do_invalidate_tlbe
  00148	eb 2f		 jmp	 SHORT $LN7@s370_inval
$LN21@s370_inval:

; 2109 :         case ARCH_900_IDX: z900_do_invalidate_tlbe( HOSTREGS, main ); break;

  0014a	48 8b 54 24 58	 mov	 rdx, QWORD PTR main$[rsp]
  0014f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00154	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0015b	e8 00 00 00 00	 call	 z900_do_invalidate_tlbe
  00160	eb 17		 jmp	 SHORT $LN7@s370_inval
$LN22@s370_inval:
$LN11@s370_inval:

; 2110 :         default: CRASH();

  00162	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  0016b	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  00170	c6 00 00	 mov	 BYTE PTR [rax], 0
  00173	33 c0		 xor	 eax, eax
  00175	85 c0		 test	 eax, eax
  00177	75 e9		 jne	 SHORT $LN11@s370_inval
$LN7@s370_inval:
$LN18@s370_inval:
$LN13@s370_inval:

; 2111 :         }
; 2112 :     }
; 2113 : #endif /* defined( _FEATURE_SIE ) */
; 2114 : 
; 2115 : } /* end function invalidate_tlbe */

  00179	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017d	c3		 ret	 0
s370_invalidate_tlbe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
i$ = 32
tv87 = 36
shift$ = 40
tv95 = 48
mainwid$ = 56
regs$ = 80
main$ = 88
z900_do_invalidate_tlbe PROC

; 2029 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2030 :     int     i;                          /* index into TLB            */
; 2031 :     int     shift;                      /* Number of bits to shift   */
; 2032 :     BYTE*   mainwid;                    /* mainstore with tlbid      */
; 2033 : 
; 2034 :     if (!main)

  0000e	48 83 7c 24 58
	00		 cmp	 QWORD PTR main$[rsp], 0
  00014	75 11		 jne	 SHORT $LN8@z900_do_in

; 2035 :     {
; 2036 :         ARCH_DEP( invalidate_tlb )( regs, 0 );

  00016	33 d2		 xor	 edx, edx
  00018	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0001d	e8 00 00 00 00	 call	 z900_invalidate_tlb

; 2037 :         return;

  00022	e9 42 01 00 00	 jmp	 $LN1@z900_do_in
$LN8@z900_do_in:

; 2038 :     }
; 2039 : 
; 2040 :     mainwid = main + regs->tlbID;

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002c	8b 80 58 b0 00
	00		 mov	 eax, DWORD PTR [rax+45144]
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR main$[rsp]
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	48 89 44 24 38	 mov	 QWORD PTR mainwid$[rsp], rax
$LN4@z900_do_in:

; 2041 : 
; 2042 :     INVALIDATE_AIA_MAIN( regs, main );

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00047	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0004f	74 6b		 je	 SHORT $LN9@z900_do_in
  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR main$[rsp]
  00056	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0005c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	48 3b 81 00 02
	00 00		 cmp	 rax, QWORD PTR [rcx+512]
  00068	75 52		 jne	 SHORT $LN9@z900_do_in
  0006a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0007b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0007f	48 2b c1	 sub	 rax, rcx
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0008e	48 03 c8	 add	 rcx, rax
  00091	48 8b c1	 mov	 rax, rcx
  00094	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00099	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  000ac	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN9@z900_do_in:
  000bc	33 c0		 xor	 eax, eax
  000be	85 c0		 test	 eax, eax
  000c0	75 80		 jne	 SHORT $LN4@z900_do_in

; 2043 : 
; 2044 :     shift = (regs->arch_mode == ARCH_370_IDX) ? 11 : 12;

  000c2	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	83 78 64 00	 cmp	 DWORD PTR [rax+100], 0
  000cb	75 0a		 jne	 SHORT $LN12@z900_do_in
  000cd	c7 44 24 24 0b
	00 00 00	 mov	 DWORD PTR tv87[rsp], 11
  000d5	eb 08		 jmp	 SHORT $LN13@z900_do_in
$LN12@z900_do_in:
  000d7	c7 44 24 24 0c
	00 00 00	 mov	 DWORD PTR tv87[rsp], 12
$LN13@z900_do_in:
  000df	8b 44 24 24	 mov	 eax, DWORD PTR tv87[rsp]
  000e3	89 44 24 28	 mov	 DWORD PTR shift$[rsp], eax

; 2045 : 
; 2046 :     for (i=0; i < TLBN; i++)

  000e7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ef	eb 0a		 jmp	 SHORT $LN7@z900_do_in
$LN5@z900_do_in:
  000f1	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000f5	ff c0		 inc	 eax
  000f7	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_do_in:
  000fb	81 7c 24 20 00
	04 00 00	 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  00103	7d 64		 jge	 SHORT $LN6@z900_do_in

; 2047 :     {
; 2048 :         if (MAINADDR( regs->tlb.main[i], (regs->tlb.TLB_VADDR(i) | (i << shift)) ) == mainwid)

  00105	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0010a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0010f	48 89 4c 24 30	 mov	 QWORD PTR tv95[rsp], rcx
  00114	8b 54 24 28	 mov	 edx, DWORD PTR shift$[rsp]
  00118	0f b6 ca	 movzx	 ecx, dl
  0011b	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  0011f	d3 e2		 shl	 edx, cl
  00121	8b ca		 mov	 ecx, edx
  00123	48 63 c9	 movsxd	 rcx, ecx
  00126	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0012b	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv95[rsp]
  00130	4a 8b 94 c2 60
	d0 00 00	 mov	 rdx, QWORD PTR [rdx+r8*8+53344]
  00138	48 0b d1	 or	 rdx, rcx
  0013b	48 8b ca	 mov	 rcx, rdx
  0013e	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  00143	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0014b	48 33 c1	 xor	 rax, rcx
  0014e	48 3b 44 24 38	 cmp	 rax, QWORD PTR mainwid$[rsp]
  00153	75 12		 jne	 SHORT $LN10@z900_do_in

; 2049 :         {
; 2050 :             regs->tlb.acc[i] = 0;

  00155	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0015a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0015f	c6 84 01 60 5c
	01 00 00	 mov	 BYTE PTR [rcx+rax+89184], 0
$LN10@z900_do_in:

; 2051 : 
; 2052 :             // 370?
; 2053 : #if !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 2054 : 
; 2055 :             if ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K)
; 2056 :                 regs->tlb.acc[i^1] = 0;
; 2057 : #endif
; 2058 :         }
; 2059 :     }

  00167	eb 88		 jmp	 SHORT $LN5@z900_do_in
$LN6@z900_do_in:
$LN1@z900_do_in:

; 2060 : }

  00169	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0016d	c3		 ret	 0
z900_do_invalidate_tlbe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
i$ = 32
tv90 = 36
shift$ = 40
tv130 = 48
mainwid$ = 56
regs$ = 80
main$ = 88
s390_do_invalidate_tlbe PROC

; 2029 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2030 :     int     i;                          /* index into TLB            */
; 2031 :     int     shift;                      /* Number of bits to shift   */
; 2032 :     BYTE*   mainwid;                    /* mainstore with tlbid      */
; 2033 : 
; 2034 :     if (!main)

  0000e	48 83 7c 24 58
	00		 cmp	 QWORD PTR main$[rsp], 0
  00014	75 11		 jne	 SHORT $LN8@s390_do_in

; 2035 :     {
; 2036 :         ARCH_DEP( invalidate_tlb )( regs, 0 );

  00016	33 d2		 xor	 edx, edx
  00018	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0001d	e8 00 00 00 00	 call	 s390_invalidate_tlb

; 2037 :         return;

  00022	e9 3c 01 00 00	 jmp	 $LN1@s390_do_in
$LN8@s390_do_in:

; 2038 :     }
; 2039 : 
; 2040 :     mainwid = main + regs->tlbID;

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002c	8b 80 58 b0 00
	00		 mov	 eax, DWORD PTR [rax+45144]
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR main$[rsp]
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	48 89 44 24 38	 mov	 QWORD PTR mainwid$[rsp], rax
$LN4@s390_do_in:

; 2041 : 
; 2042 :     INVALIDATE_AIA_MAIN( regs, main );

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00047	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0004f	74 68		 je	 SHORT $LN9@s390_do_in
  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR main$[rsp]
  00056	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  0005c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	48 3b 81 00 02
	00 00		 cmp	 rax, QWORD PTR [rcx+512]
  00068	75 4f		 jne	 SHORT $LN9@s390_do_in
  0006a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00075	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0007f	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00086	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0008a	48 2b ca	 sub	 rcx, rdx
  0008d	48 03 c1	 add	 rax, rcx
  00090	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00095	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0009b	48 23 c1	 and	 rax, rcx
  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  000a9	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ae	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN9@s390_do_in:
  000b9	33 c0		 xor	 eax, eax
  000bb	85 c0		 test	 eax, eax
  000bd	75 83		 jne	 SHORT $LN4@s390_do_in

; 2043 : 
; 2044 :     shift = (regs->arch_mode == ARCH_370_IDX) ? 11 : 12;

  000bf	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	83 78 64 00	 cmp	 DWORD PTR [rax+100], 0
  000c8	75 0a		 jne	 SHORT $LN12@s390_do_in
  000ca	c7 44 24 24 0b
	00 00 00	 mov	 DWORD PTR tv90[rsp], 11
  000d2	eb 08		 jmp	 SHORT $LN13@s390_do_in
$LN12@s390_do_in:
  000d4	c7 44 24 24 0c
	00 00 00	 mov	 DWORD PTR tv90[rsp], 12
$LN13@s390_do_in:
  000dc	8b 44 24 24	 mov	 eax, DWORD PTR tv90[rsp]
  000e0	89 44 24 28	 mov	 DWORD PTR shift$[rsp], eax

; 2045 : 
; 2046 :     for (i=0; i < TLBN; i++)

  000e4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ec	eb 0a		 jmp	 SHORT $LN7@s390_do_in
$LN5@s390_do_in:
  000ee	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000f2	ff c0		 inc	 eax
  000f4	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_do_in:
  000f8	81 7c 24 20 00
	04 00 00	 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  00100	7d 61		 jge	 SHORT $LN6@s390_do_in

; 2047 :     {
; 2048 :         if (MAINADDR( regs->tlb.main[i], (regs->tlb.TLB_VADDR(i) | (i << shift)) ) == mainwid)

  00102	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00107	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0010c	48 89 4c 24 30	 mov	 QWORD PTR tv130[rsp], rcx
  00111	8b 54 24 28	 mov	 edx, DWORD PTR shift$[rsp]
  00115	0f b6 ca	 movzx	 ecx, dl
  00118	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  0011c	d3 e2		 shl	 edx, cl
  0011e	8b ca		 mov	 ecx, edx
  00120	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  00125	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv130[rsp]
  0012a	42 8b 94 c2 60
	d0 00 00	 mov	 edx, DWORD PTR [rdx+r8*8+53344]
  00132	0b d1		 or	 edx, ecx
  00134	8b ca		 mov	 ecx, edx
  00136	8b c9		 mov	 ecx, ecx
  00138	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0013d	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  00145	48 33 c1	 xor	 rax, rcx
  00148	48 3b 44 24 38	 cmp	 rax, QWORD PTR mainwid$[rsp]
  0014d	75 12		 jne	 SHORT $LN10@s390_do_in

; 2049 :         {
; 2050 :             regs->tlb.acc[i] = 0;

  0014f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00154	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	c6 84 01 60 5c
	01 00 00	 mov	 BYTE PTR [rcx+rax+89184], 0
$LN10@s390_do_in:

; 2051 : 
; 2052 :             // 370?
; 2053 : #if !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 2054 : 
; 2055 :             if ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K)
; 2056 :                 regs->tlb.acc[i^1] = 0;
; 2057 : #endif
; 2058 :         }
; 2059 :     }

  00161	eb 8b		 jmp	 SHORT $LN5@s390_do_in
$LN6@s390_do_in:
$LN1@s390_do_in:

; 2060 : }

  00163	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00167	c3		 ret	 0
s390_do_invalidate_tlbe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
i$ = 32
tv88 = 36
shift$ = 40
tv128 = 48
mainwid$ = 56
regs$ = 80
main$ = 88
s370_do_invalidate_tlbe PROC

; 2029 : {

$LN15:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2030 :     int     i;                          /* index into TLB            */
; 2031 :     int     shift;                      /* Number of bits to shift   */
; 2032 :     BYTE*   mainwid;                    /* mainstore with tlbid      */
; 2033 : 
; 2034 :     if (!main)

  0000e	48 83 7c 24 58
	00		 cmp	 QWORD PTR main$[rsp], 0
  00014	75 11		 jne	 SHORT $LN8@s370_do_in

; 2035 :     {
; 2036 :         ARCH_DEP( invalidate_tlb )( regs, 0 );

  00016	33 d2		 xor	 edx, edx
  00018	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0001d	e8 00 00 00 00	 call	 s370_invalidate_tlb

; 2037 :         return;

  00022	e9 72 01 00 00	 jmp	 $LN1@s370_do_in
$LN8@s370_do_in:

; 2038 :     }
; 2039 : 
; 2040 :     mainwid = main + regs->tlbID;

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002c	8b 80 58 b0 00
	00		 mov	 eax, DWORD PTR [rax+45144]
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR main$[rsp]
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	48 89 44 24 38	 mov	 QWORD PTR mainwid$[rsp], rax
$LN4@s370_do_in:

; 2041 : 
; 2042 :     INVALIDATE_AIA_MAIN( regs, main );

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00047	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0004f	74 60		 je	 SHORT $LN9@s370_do_in
  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR main$[rsp]
  00056	48 25 00 f8 ff
	7f		 and	 rax, 2147481600		; 7ffff800H
  0005c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	48 3b 81 00 02
	00 00		 cmp	 rax, QWORD PTR [rcx+512]
  00068	75 47		 jne	 SHORT $LN9@s370_do_in
  0006a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00075	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0007f	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00086	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0008a	48 2b ca	 sub	 rcx, rdx
  0008d	48 03 c1	 add	 rax, rcx
  00090	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00096	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0009b	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  000a1	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN9@s370_do_in:
  000b1	33 c0		 xor	 eax, eax
  000b3	85 c0		 test	 eax, eax
  000b5	75 8b		 jne	 SHORT $LN4@s370_do_in

; 2043 : 
; 2044 :     shift = (regs->arch_mode == ARCH_370_IDX) ? 11 : 12;

  000b7	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	83 78 64 00	 cmp	 DWORD PTR [rax+100], 0
  000c0	75 0a		 jne	 SHORT $LN13@s370_do_in
  000c2	c7 44 24 24 0b
	00 00 00	 mov	 DWORD PTR tv88[rsp], 11
  000ca	eb 08		 jmp	 SHORT $LN14@s370_do_in
$LN13@s370_do_in:
  000cc	c7 44 24 24 0c
	00 00 00	 mov	 DWORD PTR tv88[rsp], 12
$LN14@s370_do_in:
  000d4	8b 44 24 24	 mov	 eax, DWORD PTR tv88[rsp]
  000d8	89 44 24 28	 mov	 DWORD PTR shift$[rsp], eax

; 2045 : 
; 2046 :     for (i=0; i < TLBN; i++)

  000dc	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000e4	eb 0a		 jmp	 SHORT $LN7@s370_do_in
$LN5@s370_do_in:
  000e6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000ea	ff c0		 inc	 eax
  000ec	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_do_in:
  000f0	81 7c 24 20 00
	04 00 00	 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  000f8	0f 8d 9b 00 00
	00		 jge	 $LN6@s370_do_in

; 2047 :     {
; 2048 :         if (MAINADDR( regs->tlb.main[i], (regs->tlb.TLB_VADDR(i) | (i << shift)) ) == mainwid)

  000fe	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00103	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00108	48 89 4c 24 30	 mov	 QWORD PTR tv128[rsp], rcx
  0010d	8b 54 24 28	 mov	 edx, DWORD PTR shift$[rsp]
  00111	0f b6 ca	 movzx	 ecx, dl
  00114	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00118	d3 e2		 shl	 edx, cl
  0011a	8b ca		 mov	 ecx, edx
  0011c	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  00121	4c 8b 44 24 30	 mov	 r8, QWORD PTR tv128[rsp]
  00126	42 8b 94 c2 60
	d0 00 00	 mov	 edx, DWORD PTR [rdx+r8*8+53344]
  0012e	0b d1		 or	 edx, ecx
  00130	8b ca		 mov	 ecx, edx
  00132	8b c9		 mov	 ecx, ecx
  00134	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  00139	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  00141	48 33 c1	 xor	 rax, rcx
  00144	48 3b 44 24 38	 cmp	 rax, QWORD PTR mainwid$[rsp]
  00149	75 49		 jne	 SHORT $LN10@s370_do_in

; 2049 :         {
; 2050 :             regs->tlb.acc[i] = 0;

  0014b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00150	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00155	c6 84 01 60 5c
	01 00 00	 mov	 BYTE PTR [rcx+rax+89184], 0

; 2051 : 
; 2052 :             // 370?
; 2053 : #if !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 2054 : 
; 2055 :             if ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K)

  0015d	b8 08 00 00 00	 mov	 eax, 8
  00162	48 6b c0 01	 imul	 rax, rax, 1
  00166	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0016b	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00172	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  00177	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  0017c	75 16		 jne	 SHORT $LN11@s370_do_in

; 2056 :                 regs->tlb.acc[i^1] = 0;

  0017e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00182	83 f0 01	 xor	 eax, 1
  00185	48 98		 cdqe
  00187	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0018c	c6 84 01 60 5c
	01 00 00	 mov	 BYTE PTR [rcx+rax+89184], 0
$LN11@s370_do_in:
$LN10@s370_do_in:

; 2057 : #endif
; 2058 :         }
; 2059 :     }

  00194	e9 4d ff ff ff	 jmp	 $LN5@s370_do_in
$LN6@s370_do_in:
$LN1@s370_do_in:

; 2060 : }

  00199	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0019d	c3		 ret	 0
s370_do_invalidate_tlbe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv75 = 32
tv130 = 36
p$1 = 40
p$2 = 48
regs$ = 80
pfra$ = 88
z900_purge_tlbe PROC

; 1912 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1913 :     /* Do it for the current architecture first */
; 1914 :     ARCH_DEP( do_purge_tlbe )( regs, NULL, pfra );

  0000e	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  00013	33 d2		 xor	 edx, edx
  00015	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0001a	e8 00 00 00 00	 call	 z900_do_purge_tlbe

; 1915 : 
; 1916 : #if defined( _FEATURE_SIE )
; 1917 : 
; 1918 :     /* Also clear the GUEST registers in the SIE copy */
; 1919 :     if (regs->host && GUESTREGS)

  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00024	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0002a	c1 e8 07	 shr	 eax, 7
  0002d	83 e0 01	 and	 eax, 1
  00030	85 c0		 test	 eax, eax
  00032	0f 84 b0 00 00
	00		 je	 $LN12@z900_purge
  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00045	0f 84 9d 00 00
	00		 je	 $LN12@z900_purge

; 1920 :     {
; 1921 :         /*************************************************************/
; 1922 :         /*                                                           */
; 1923 :         /*                   PROGRAMMING NOTE                        */
; 1924 :         /*                                                           */
; 1925 :         /* The SIE guest's TLB PTE entries for DAT-OFF guests like   */
; 1926 :         /* CMS do NOT actually contain the PTE, but rather contain   */
; 1927 :         /* the host primary virtual address. Both are masked with    */
; 1928 :         /* TBLID_PAGEMASK however. Therefore in order to properly    */
; 1929 :         /* check if such a guest TLB PTE entry needs to be cleared,  */
; 1930 :         /* one needs to also check the host's TLB PTE for a match    */
; 1931 :         /* as well. In other words, instead of just doing:           */
; 1932 :         /*                                                           */
; 1933 :         /*    if ((GUESTREGS->tlb.TLB_PTE(i) & ptemask) == pte)      */
; 1934 :         /*         GUESTREGS->tlb.TLB_VADDR(i) &= TLBID_PAGEMASK;    */
; 1935 :         /*                                                           */
; 1936 :         /* we need to essentially do the following instead:          */
; 1937 :         /*                                                           */
; 1938 :         /*    if ((GUESTREGS->tlb.TLB_PTE(i) & ptemask) == pte ||    */
; 1939 :         /*         (HOSTREGS->tlb.TLB_PTE(i) & ptemask) == pte)      */
; 1940 :         /*         GUESTREGS->tlb.TLB_VADDR(i) &= TLBID_PAGEMASK;    */
; 1941 :         /*                                                           */
; 1942 :         /*                         (Peter J. Jansen, 29-Jul-2016)    */
; 1943 :         /*                                                           */
; 1944 :         /* This is accomplished by also passing the host's registers */
; 1945 :         /* to the "do_purge_tlbe" function so it can know to also    */
; 1946 :         /* check the host's TLB PTE entry for a match as well.       */
; 1947 :         /*                                                           */
; 1948 :         /*                    "Fish" (David B. Trout), 07-Oct-2021   */
; 1949 :         /*                                                           */
; 1950 :         /*************************************************************/
; 1951 : 
; 1952 :         switch (GUESTREGS->arch_mode)

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00050	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00057	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0005a	89 44 24 20	 mov	 DWORD PTR tv75[rsp], eax
  0005e	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00063	74 10		 je	 SHORT $LN14@z900_purge
  00065	83 7c 24 20 01	 cmp	 DWORD PTR tv75[rsp], 1
  0006a	74 26		 je	 SHORT $LN15@z900_purge
  0006c	83 7c 24 20 02	 cmp	 DWORD PTR tv75[rsp], 2
  00071	74 3c		 je	 SHORT $LN16@z900_purge
  00073	eb 57		 jmp	 SHORT $LN17@z900_purge
$LN14@z900_purge:

; 1953 :         {
; 1954 :         case ARCH_370_IDX: s370_do_purge_tlbe( GUESTREGS, regs, pfra ); break;

  00075	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  0007a	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0007f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0008b	e8 00 00 00 00	 call	 s370_do_purge_tlbe
  00090	eb 51		 jmp	 SHORT $LN2@z900_purge
$LN15@z900_purge:

; 1955 :         case ARCH_390_IDX: s390_do_purge_tlbe( GUESTREGS, regs, pfra ); break;

  00092	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  00097	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0009c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000a1	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  000a8	e8 00 00 00 00	 call	 s390_do_purge_tlbe
  000ad	eb 34		 jmp	 SHORT $LN2@z900_purge
$LN16@z900_purge:

; 1956 :         case ARCH_900_IDX: z900_do_purge_tlbe( GUESTREGS, regs, pfra ); break;

  000af	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  000b4	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  000b9	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000be	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  000c5	e8 00 00 00 00	 call	 z900_do_purge_tlbe
  000ca	eb 17		 jmp	 SHORT $LN2@z900_purge
$LN17@z900_purge:
$LN6@z900_purge:

; 1957 :         default: CRASH();

  000cc	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000d5	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000da	c6 00 00	 mov	 BYTE PTR [rax], 0
  000dd	33 c0		 xor	 eax, eax
  000df	85 c0		 test	 eax, eax
  000e1	75 e9		 jne	 SHORT $LN6@z900_purge
$LN2@z900_purge:

; 1958 :         }
; 1959 :     }

  000e3	e9 a8 00 00 00	 jmp	 $LN13@z900_purge
$LN12@z900_purge:

; 1960 :     else if (regs->guest)  /* For guests, also clear HOST entries */

  000e8	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000f3	c1 e8 08	 shr	 eax, 8
  000f6	83 e0 01	 and	 eax, 1
  000f9	85 c0		 test	 eax, eax
  000fb	0f 84 8f 00 00
	00		 je	 $LN18@z900_purge

; 1961 :     {
; 1962 :         switch (HOSTREGS->arch_mode)

  00101	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0010d	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00110	89 44 24 24	 mov	 DWORD PTR tv130[rsp], eax
  00114	83 7c 24 24 00	 cmp	 DWORD PTR tv130[rsp], 0
  00119	74 10		 je	 SHORT $LN19@z900_purge
  0011b	83 7c 24 24 01	 cmp	 DWORD PTR tv130[rsp], 1
  00120	74 23		 je	 SHORT $LN20@z900_purge
  00122	83 7c 24 24 02	 cmp	 DWORD PTR tv130[rsp], 2
  00127	74 36		 je	 SHORT $LN21@z900_purge
  00129	eb 4e		 jmp	 SHORT $LN22@z900_purge
$LN19@z900_purge:

; 1963 :         {
; 1964 :         case ARCH_370_IDX: s370_do_purge_tlbe( HOSTREGS, NULL, pfra ); break;

  0012b	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  00130	33 d2		 xor	 edx, edx
  00132	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00137	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0013e	e8 00 00 00 00	 call	 s370_do_purge_tlbe
  00143	eb 4b		 jmp	 SHORT $LN7@z900_purge
$LN20@z900_purge:

; 1965 :         case ARCH_390_IDX: s390_do_purge_tlbe( HOSTREGS, NULL, pfra ); break;

  00145	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  0014a	33 d2		 xor	 edx, edx
  0014c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00151	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00158	e8 00 00 00 00	 call	 s390_do_purge_tlbe
  0015d	eb 31		 jmp	 SHORT $LN7@z900_purge
$LN21@z900_purge:

; 1966 :         case ARCH_900_IDX: z900_do_purge_tlbe( HOSTREGS, NULL, pfra ); break;

  0015f	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  00164	33 d2		 xor	 edx, edx
  00166	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00172	e8 00 00 00 00	 call	 z900_do_purge_tlbe
  00177	eb 17		 jmp	 SHORT $LN7@z900_purge
$LN22@z900_purge:
$LN11@z900_purge:

; 1967 :         default: CRASH();

  00179	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  00187	c6 00 00	 mov	 BYTE PTR [rax], 0
  0018a	33 c0		 xor	 eax, eax
  0018c	85 c0		 test	 eax, eax
  0018e	75 e9		 jne	 SHORT $LN11@z900_purge
$LN7@z900_purge:
$LN18@z900_purge:
$LN13@z900_purge:

; 1968 :         }
; 1969 :     }
; 1970 : #endif /* defined( _FEATURE_SIE ) */
; 1971 : 
; 1972 : } /* end function purge_tlbe */

  00190	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00194	c3		 ret	 0
z900_purge_tlbe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv75 = 32
tv130 = 36
p$1 = 40
p$2 = 48
regs$ = 80
pfra$ = 88
s390_purge_tlbe PROC

; 1912 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1913 :     /* Do it for the current architecture first */
; 1914 :     ARCH_DEP( do_purge_tlbe )( regs, NULL, pfra );

  0000e	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  00013	33 d2		 xor	 edx, edx
  00015	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0001a	e8 00 00 00 00	 call	 s390_do_purge_tlbe

; 1915 : 
; 1916 : #if defined( _FEATURE_SIE )
; 1917 : 
; 1918 :     /* Also clear the GUEST registers in the SIE copy */
; 1919 :     if (regs->host && GUESTREGS)

  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00024	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0002a	c1 e8 07	 shr	 eax, 7
  0002d	83 e0 01	 and	 eax, 1
  00030	85 c0		 test	 eax, eax
  00032	0f 84 b0 00 00
	00		 je	 $LN12@s390_purge
  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00045	0f 84 9d 00 00
	00		 je	 $LN12@s390_purge

; 1920 :     {
; 1921 :         /*************************************************************/
; 1922 :         /*                                                           */
; 1923 :         /*                   PROGRAMMING NOTE                        */
; 1924 :         /*                                                           */
; 1925 :         /* The SIE guest's TLB PTE entries for DAT-OFF guests like   */
; 1926 :         /* CMS do NOT actually contain the PTE, but rather contain   */
; 1927 :         /* the host primary virtual address. Both are masked with    */
; 1928 :         /* TBLID_PAGEMASK however. Therefore in order to properly    */
; 1929 :         /* check if such a guest TLB PTE entry needs to be cleared,  */
; 1930 :         /* one needs to also check the host's TLB PTE for a match    */
; 1931 :         /* as well. In other words, instead of just doing:           */
; 1932 :         /*                                                           */
; 1933 :         /*    if ((GUESTREGS->tlb.TLB_PTE(i) & ptemask) == pte)      */
; 1934 :         /*         GUESTREGS->tlb.TLB_VADDR(i) &= TLBID_PAGEMASK;    */
; 1935 :         /*                                                           */
; 1936 :         /* we need to essentially do the following instead:          */
; 1937 :         /*                                                           */
; 1938 :         /*    if ((GUESTREGS->tlb.TLB_PTE(i) & ptemask) == pte ||    */
; 1939 :         /*         (HOSTREGS->tlb.TLB_PTE(i) & ptemask) == pte)      */
; 1940 :         /*         GUESTREGS->tlb.TLB_VADDR(i) &= TLBID_PAGEMASK;    */
; 1941 :         /*                                                           */
; 1942 :         /*                         (Peter J. Jansen, 29-Jul-2016)    */
; 1943 :         /*                                                           */
; 1944 :         /* This is accomplished by also passing the host's registers */
; 1945 :         /* to the "do_purge_tlbe" function so it can know to also    */
; 1946 :         /* check the host's TLB PTE entry for a match as well.       */
; 1947 :         /*                                                           */
; 1948 :         /*                    "Fish" (David B. Trout), 07-Oct-2021   */
; 1949 :         /*                                                           */
; 1950 :         /*************************************************************/
; 1951 : 
; 1952 :         switch (GUESTREGS->arch_mode)

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00050	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00057	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0005a	89 44 24 20	 mov	 DWORD PTR tv75[rsp], eax
  0005e	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00063	74 10		 je	 SHORT $LN14@s390_purge
  00065	83 7c 24 20 01	 cmp	 DWORD PTR tv75[rsp], 1
  0006a	74 26		 je	 SHORT $LN15@s390_purge
  0006c	83 7c 24 20 02	 cmp	 DWORD PTR tv75[rsp], 2
  00071	74 3c		 je	 SHORT $LN16@s390_purge
  00073	eb 57		 jmp	 SHORT $LN17@s390_purge
$LN14@s390_purge:

; 1953 :         {
; 1954 :         case ARCH_370_IDX: s370_do_purge_tlbe( GUESTREGS, regs, pfra ); break;

  00075	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  0007a	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0007f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0008b	e8 00 00 00 00	 call	 s370_do_purge_tlbe
  00090	eb 51		 jmp	 SHORT $LN2@s390_purge
$LN15@s390_purge:

; 1955 :         case ARCH_390_IDX: s390_do_purge_tlbe( GUESTREGS, regs, pfra ); break;

  00092	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  00097	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0009c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000a1	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  000a8	e8 00 00 00 00	 call	 s390_do_purge_tlbe
  000ad	eb 34		 jmp	 SHORT $LN2@s390_purge
$LN16@s390_purge:

; 1956 :         case ARCH_900_IDX: z900_do_purge_tlbe( GUESTREGS, regs, pfra ); break;

  000af	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  000b4	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  000b9	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000be	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  000c5	e8 00 00 00 00	 call	 z900_do_purge_tlbe
  000ca	eb 17		 jmp	 SHORT $LN2@s390_purge
$LN17@s390_purge:
$LN6@s390_purge:

; 1957 :         default: CRASH();

  000cc	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000d5	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000da	c6 00 00	 mov	 BYTE PTR [rax], 0
  000dd	33 c0		 xor	 eax, eax
  000df	85 c0		 test	 eax, eax
  000e1	75 e9		 jne	 SHORT $LN6@s390_purge
$LN2@s390_purge:

; 1958 :         }
; 1959 :     }

  000e3	e9 a8 00 00 00	 jmp	 $LN13@s390_purge
$LN12@s390_purge:

; 1960 :     else if (regs->guest)  /* For guests, also clear HOST entries */

  000e8	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000f3	c1 e8 08	 shr	 eax, 8
  000f6	83 e0 01	 and	 eax, 1
  000f9	85 c0		 test	 eax, eax
  000fb	0f 84 8f 00 00
	00		 je	 $LN18@s390_purge

; 1961 :     {
; 1962 :         switch (HOSTREGS->arch_mode)

  00101	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0010d	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00110	89 44 24 24	 mov	 DWORD PTR tv130[rsp], eax
  00114	83 7c 24 24 00	 cmp	 DWORD PTR tv130[rsp], 0
  00119	74 10		 je	 SHORT $LN19@s390_purge
  0011b	83 7c 24 24 01	 cmp	 DWORD PTR tv130[rsp], 1
  00120	74 23		 je	 SHORT $LN20@s390_purge
  00122	83 7c 24 24 02	 cmp	 DWORD PTR tv130[rsp], 2
  00127	74 36		 je	 SHORT $LN21@s390_purge
  00129	eb 4e		 jmp	 SHORT $LN22@s390_purge
$LN19@s390_purge:

; 1963 :         {
; 1964 :         case ARCH_370_IDX: s370_do_purge_tlbe( HOSTREGS, NULL, pfra ); break;

  0012b	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  00130	33 d2		 xor	 edx, edx
  00132	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00137	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0013e	e8 00 00 00 00	 call	 s370_do_purge_tlbe
  00143	eb 4b		 jmp	 SHORT $LN7@s390_purge
$LN20@s390_purge:

; 1965 :         case ARCH_390_IDX: s390_do_purge_tlbe( HOSTREGS, NULL, pfra ); break;

  00145	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  0014a	33 d2		 xor	 edx, edx
  0014c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00151	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00158	e8 00 00 00 00	 call	 s390_do_purge_tlbe
  0015d	eb 31		 jmp	 SHORT $LN7@s390_purge
$LN21@s390_purge:

; 1966 :         case ARCH_900_IDX: z900_do_purge_tlbe( HOSTREGS, NULL, pfra ); break;

  0015f	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  00164	33 d2		 xor	 edx, edx
  00166	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00172	e8 00 00 00 00	 call	 z900_do_purge_tlbe
  00177	eb 17		 jmp	 SHORT $LN7@s390_purge
$LN22@s390_purge:
$LN11@s390_purge:

; 1967 :         default: CRASH();

  00179	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  00187	c6 00 00	 mov	 BYTE PTR [rax], 0
  0018a	33 c0		 xor	 eax, eax
  0018c	85 c0		 test	 eax, eax
  0018e	75 e9		 jne	 SHORT $LN11@s390_purge
$LN7@s390_purge:
$LN18@s390_purge:
$LN13@s390_purge:

; 1968 :         }
; 1969 :     }
; 1970 : #endif /* defined( _FEATURE_SIE ) */
; 1971 : 
; 1972 : } /* end function purge_tlbe */

  00190	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00194	c3		 ret	 0
s390_purge_tlbe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv75 = 32
tv130 = 36
p$1 = 40
p$2 = 48
regs$ = 80
pfra$ = 88
s370_purge_tlbe PROC

; 1912 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1913 :     /* Do it for the current architecture first */
; 1914 :     ARCH_DEP( do_purge_tlbe )( regs, NULL, pfra );

  0000e	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  00013	33 d2		 xor	 edx, edx
  00015	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0001a	e8 00 00 00 00	 call	 s370_do_purge_tlbe

; 1915 : 
; 1916 : #if defined( _FEATURE_SIE )
; 1917 : 
; 1918 :     /* Also clear the GUEST registers in the SIE copy */
; 1919 :     if (regs->host && GUESTREGS)

  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00024	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0002a	c1 e8 07	 shr	 eax, 7
  0002d	83 e0 01	 and	 eax, 1
  00030	85 c0		 test	 eax, eax
  00032	0f 84 b0 00 00
	00		 je	 $LN12@s370_purge
  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00045	0f 84 9d 00 00
	00		 je	 $LN12@s370_purge

; 1920 :     {
; 1921 :         /*************************************************************/
; 1922 :         /*                                                           */
; 1923 :         /*                   PROGRAMMING NOTE                        */
; 1924 :         /*                                                           */
; 1925 :         /* The SIE guest's TLB PTE entries for DAT-OFF guests like   */
; 1926 :         /* CMS do NOT actually contain the PTE, but rather contain   */
; 1927 :         /* the host primary virtual address. Both are masked with    */
; 1928 :         /* TBLID_PAGEMASK however. Therefore in order to properly    */
; 1929 :         /* check if such a guest TLB PTE entry needs to be cleared,  */
; 1930 :         /* one needs to also check the host's TLB PTE for a match    */
; 1931 :         /* as well. In other words, instead of just doing:           */
; 1932 :         /*                                                           */
; 1933 :         /*    if ((GUESTREGS->tlb.TLB_PTE(i) & ptemask) == pte)      */
; 1934 :         /*         GUESTREGS->tlb.TLB_VADDR(i) &= TLBID_PAGEMASK;    */
; 1935 :         /*                                                           */
; 1936 :         /* we need to essentially do the following instead:          */
; 1937 :         /*                                                           */
; 1938 :         /*    if ((GUESTREGS->tlb.TLB_PTE(i) & ptemask) == pte ||    */
; 1939 :         /*         (HOSTREGS->tlb.TLB_PTE(i) & ptemask) == pte)      */
; 1940 :         /*         GUESTREGS->tlb.TLB_VADDR(i) &= TLBID_PAGEMASK;    */
; 1941 :         /*                                                           */
; 1942 :         /*                         (Peter J. Jansen, 29-Jul-2016)    */
; 1943 :         /*                                                           */
; 1944 :         /* This is accomplished by also passing the host's registers */
; 1945 :         /* to the "do_purge_tlbe" function so it can know to also    */
; 1946 :         /* check the host's TLB PTE entry for a match as well.       */
; 1947 :         /*                                                           */
; 1948 :         /*                    "Fish" (David B. Trout), 07-Oct-2021   */
; 1949 :         /*                                                           */
; 1950 :         /*************************************************************/
; 1951 : 
; 1952 :         switch (GUESTREGS->arch_mode)

  0004b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00050	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00057	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0005a	89 44 24 20	 mov	 DWORD PTR tv75[rsp], eax
  0005e	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00063	74 10		 je	 SHORT $LN14@s370_purge
  00065	83 7c 24 20 01	 cmp	 DWORD PTR tv75[rsp], 1
  0006a	74 26		 je	 SHORT $LN15@s370_purge
  0006c	83 7c 24 20 02	 cmp	 DWORD PTR tv75[rsp], 2
  00071	74 3c		 je	 SHORT $LN16@s370_purge
  00073	eb 57		 jmp	 SHORT $LN17@s370_purge
$LN14@s370_purge:

; 1953 :         {
; 1954 :         case ARCH_370_IDX: s370_do_purge_tlbe( GUESTREGS, regs, pfra ); break;

  00075	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  0007a	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0007f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00084	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0008b	e8 00 00 00 00	 call	 s370_do_purge_tlbe
  00090	eb 51		 jmp	 SHORT $LN2@s370_purge
$LN15@s370_purge:

; 1955 :         case ARCH_390_IDX: s390_do_purge_tlbe( GUESTREGS, regs, pfra ); break;

  00092	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  00097	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0009c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000a1	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  000a8	e8 00 00 00 00	 call	 s390_do_purge_tlbe
  000ad	eb 34		 jmp	 SHORT $LN2@s370_purge
$LN16@s370_purge:

; 1956 :         case ARCH_900_IDX: z900_do_purge_tlbe( GUESTREGS, regs, pfra ); break;

  000af	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  000b4	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  000b9	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000be	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  000c5	e8 00 00 00 00	 call	 z900_do_purge_tlbe
  000ca	eb 17		 jmp	 SHORT $LN2@s370_purge
$LN17@s370_purge:
$LN6@s370_purge:

; 1957 :         default: CRASH();

  000cc	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000d5	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000da	c6 00 00	 mov	 BYTE PTR [rax], 0
  000dd	33 c0		 xor	 eax, eax
  000df	85 c0		 test	 eax, eax
  000e1	75 e9		 jne	 SHORT $LN6@s370_purge
$LN2@s370_purge:

; 1958 :         }
; 1959 :     }

  000e3	e9 a8 00 00 00	 jmp	 $LN13@s370_purge
$LN12@s370_purge:

; 1960 :     else if (regs->guest)  /* For guests, also clear HOST entries */

  000e8	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000f3	c1 e8 08	 shr	 eax, 8
  000f6	83 e0 01	 and	 eax, 1
  000f9	85 c0		 test	 eax, eax
  000fb	0f 84 8f 00 00
	00		 je	 $LN18@s370_purge

; 1961 :     {
; 1962 :         switch (HOSTREGS->arch_mode)

  00101	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0010d	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00110	89 44 24 24	 mov	 DWORD PTR tv130[rsp], eax
  00114	83 7c 24 24 00	 cmp	 DWORD PTR tv130[rsp], 0
  00119	74 10		 je	 SHORT $LN19@s370_purge
  0011b	83 7c 24 24 01	 cmp	 DWORD PTR tv130[rsp], 1
  00120	74 23		 je	 SHORT $LN20@s370_purge
  00122	83 7c 24 24 02	 cmp	 DWORD PTR tv130[rsp], 2
  00127	74 36		 je	 SHORT $LN21@s370_purge
  00129	eb 4e		 jmp	 SHORT $LN22@s370_purge
$LN19@s370_purge:

; 1963 :         {
; 1964 :         case ARCH_370_IDX: s370_do_purge_tlbe( HOSTREGS, NULL, pfra ); break;

  0012b	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  00130	33 d2		 xor	 edx, edx
  00132	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00137	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  0013e	e8 00 00 00 00	 call	 s370_do_purge_tlbe
  00143	eb 4b		 jmp	 SHORT $LN7@s370_purge
$LN20@s370_purge:

; 1965 :         case ARCH_390_IDX: s390_do_purge_tlbe( HOSTREGS, NULL, pfra ); break;

  00145	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  0014a	33 d2		 xor	 edx, edx
  0014c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00151	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00158	e8 00 00 00 00	 call	 s390_do_purge_tlbe
  0015d	eb 31		 jmp	 SHORT $LN7@s370_purge
$LN21@s370_purge:

; 1966 :         case ARCH_900_IDX: z900_do_purge_tlbe( HOSTREGS, NULL, pfra ); break;

  0015f	4c 8b 44 24 58	 mov	 r8, QWORD PTR pfra$[rsp]
  00164	33 d2		 xor	 edx, edx
  00166	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00172	e8 00 00 00 00	 call	 z900_do_purge_tlbe
  00177	eb 17		 jmp	 SHORT $LN7@s370_purge
$LN22@s370_purge:
$LN11@s370_purge:

; 1967 :         default: CRASH();

  00179	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  00182	48 8b 44 24 30	 mov	 rax, QWORD PTR p$2[rsp]
  00187	c6 00 00	 mov	 BYTE PTR [rax], 0
  0018a	33 c0		 xor	 eax, eax
  0018c	85 c0		 test	 eax, eax
  0018e	75 e9		 jne	 SHORT $LN11@s370_purge
$LN7@s370_purge:
$LN18@s370_purge:
$LN13@s370_purge:

; 1968 :         }
; 1969 :     }
; 1970 : #endif /* defined( _FEATURE_SIE ) */
; 1971 : 
; 1972 : } /* end function purge_tlbe */

  00190	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00194	c3		 ret	 0
s370_purge_tlbe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
i$ = 32
regs$ = 64
host_regs$ = 72
pfra$ = 80
z900_do_purge_tlbe PROC

; 1898 : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900_do_pu:

; 1899 : int  i;
; 1900 : 
; 1901 :     INVALIDATE_AIA( regs );

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00018	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00020	74 52		 je	 SHORT $LN8@z900_do_pu
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0002c	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00033	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00037	48 2b c1	 sub	 rax, rcx
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0003f	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00046	48 03 c8	 add	 rcx, rax
  00049	48 8b c1	 mov	 rax, rcx
  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00051	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00069	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN8@z900_do_pu:
  00074	33 c0		 xor	 eax, eax
  00076	85 c0		 test	 eax, eax
  00078	75 99		 jne	 SHORT $LN4@z900_do_pu

; 1902 : 
; 1903 :     for (i=0; i < TLBN; i++)

  0007a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00082	eb 0a		 jmp	 SHORT $LN7@z900_do_pu
$LN5@z900_do_pu:
  00084	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00088	ff c0		 inc	 eax
  0008a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_do_pu:
  0008e	81 7c 24 20 00
	04 00 00	 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  00096	7d 4c		 jge	 SHORT $LN6@z900_do_pu

; 1904 :         if (ARCH_DEP( is_tlbe_match )( regs, host_regs, pfra, i ))

  00098	44 8b 4c 24 20	 mov	 r9d, DWORD PTR i$[rsp]
  0009d	4c 8b 44 24 50	 mov	 r8, QWORD PTR pfra$[rsp]
  000a2	48 8b 54 24 48	 mov	 rdx, QWORD PTR host_regs$[rsp]
  000a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	e8 00 00 00 00	 call	 z900_is_tlbe_match
  000b1	0f b6 c0	 movzx	 eax, al
  000b4	85 c0		 test	 eax, eax
  000b6	74 2a		 je	 SHORT $LN9@z900_do_pu

; 1905 :             regs->tlb.TLB_VADDR(i) &= TLBID_PAGEMASK;

  000b8	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	48 8b 84 c1 60
	d0 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+53344]
  000ca	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  000d0	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000d5	48 8b 54 24 40	 mov	 rdx, QWORD PTR regs$[rsp]
  000da	48 89 84 ca 60
	d0 00 00	 mov	 QWORD PTR [rdx+rcx*8+53344], rax
$LN9@z900_do_pu:
  000e2	eb a0		 jmp	 SHORT $LN5@z900_do_pu
$LN6@z900_do_pu:

; 1906 : }

  000e4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e8	c3		 ret	 0
z900_do_purge_tlbe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
i$ = 32
regs$ = 64
host_regs$ = 72
pfra$ = 80
s390_do_purge_tlbe PROC

; 1898 : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s390_do_pu:

; 1899 : int  i;
; 1900 : 
; 1901 :     INVALIDATE_AIA( regs );

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00018	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00020	74 4f		 je	 SHORT $LN8@s390_do_pu
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	48 8b 54 24 40	 mov	 rdx, QWORD PTR regs$[rsp]
  00037	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0003e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00042	48 2b ca	 sub	 rcx, rdx
  00045	48 03 c1	 add	 rax, rcx
  00048	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0004d	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00053	48 23 c1	 and	 rax, rcx
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00066	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN8@s390_do_pu:
  00071	33 c0		 xor	 eax, eax
  00073	85 c0		 test	 eax, eax
  00075	75 9c		 jne	 SHORT $LN4@s390_do_pu

; 1902 : 
; 1903 :     for (i=0; i < TLBN; i++)

  00077	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0007f	eb 0a		 jmp	 SHORT $LN7@s390_do_pu
$LN5@s390_do_pu:
  00081	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00085	ff c0		 inc	 eax
  00087	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_do_pu:
  0008b	81 7c 24 20 00
	04 00 00	 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  00093	7d 49		 jge	 SHORT $LN6@s390_do_pu

; 1904 :         if (ARCH_DEP( is_tlbe_match )( regs, host_regs, pfra, i ))

  00095	44 8b 4c 24 20	 mov	 r9d, DWORD PTR i$[rsp]
  0009a	4c 8b 44 24 50	 mov	 r8, QWORD PTR pfra$[rsp]
  0009f	48 8b 54 24 48	 mov	 rdx, QWORD PTR host_regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	e8 00 00 00 00	 call	 s390_is_tlbe_match
  000ae	0f b6 c0	 movzx	 eax, al
  000b1	85 c0		 test	 eax, eax
  000b3	74 27		 je	 SHORT $LN9@s390_do_pu

; 1905 :             regs->tlb.TLB_VADDR(i) &= TLBID_PAGEMASK;

  000b5	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000bf	8b 84 c1 60 d0
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+53344]
  000c6	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  000cb	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000d0	48 8b 54 24 40	 mov	 rdx, QWORD PTR regs$[rsp]
  000d5	89 84 ca 60 d0
	00 00		 mov	 DWORD PTR [rdx+rcx*8+53344], eax
$LN9@s390_do_pu:
  000dc	eb a3		 jmp	 SHORT $LN5@s390_do_pu
$LN6@s390_do_pu:

; 1906 : }

  000de	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e2	c3		 ret	 0
s390_do_purge_tlbe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
i$ = 32
regs$ = 64
host_regs$ = 72
pfra$ = 80
s370_do_purge_tlbe PROC

; 1898 : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370_do_pu:

; 1899 : int  i;
; 1900 : 
; 1901 :     INVALIDATE_AIA( regs );

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00018	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00020	74 47		 je	 SHORT $LN8@s370_do_pu
  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	48 8b 54 24 40	 mov	 rdx, QWORD PTR regs$[rsp]
  00037	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0003e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00042	48 2b ca	 sub	 rcx, rdx
  00045	48 03 c1	 add	 rax, rcx
  00048	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN8@s370_do_pu:
  00069	33 c0		 xor	 eax, eax
  0006b	85 c0		 test	 eax, eax
  0006d	75 a4		 jne	 SHORT $LN4@s370_do_pu

; 1902 : 
; 1903 :     for (i=0; i < TLBN; i++)

  0006f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00077	eb 0a		 jmp	 SHORT $LN7@s370_do_pu
$LN5@s370_do_pu:
  00079	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0007d	ff c0		 inc	 eax
  0007f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_do_pu:
  00083	81 7c 24 20 00
	04 00 00	 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  0008b	7d 49		 jge	 SHORT $LN6@s370_do_pu

; 1904 :         if (ARCH_DEP( is_tlbe_match )( regs, host_regs, pfra, i ))

  0008d	44 8b 4c 24 20	 mov	 r9d, DWORD PTR i$[rsp]
  00092	4c 8b 44 24 50	 mov	 r8, QWORD PTR pfra$[rsp]
  00097	48 8b 54 24 48	 mov	 rdx, QWORD PTR host_regs$[rsp]
  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a1	e8 00 00 00 00	 call	 s370_is_tlbe_match
  000a6	0f b6 c0	 movzx	 eax, al
  000a9	85 c0		 test	 eax, eax
  000ab	74 27		 je	 SHORT $LN9@s370_do_pu

; 1905 :             regs->tlb.TLB_VADDR(i) &= TLBID_PAGEMASK;

  000ad	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000b7	8b 84 c1 60 d0
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+53344]
  000be	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  000c3	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000c8	48 8b 54 24 40	 mov	 rdx, QWORD PTR regs$[rsp]
  000cd	89 84 ca 60 d0
	00 00		 mov	 DWORD PTR [rdx+rcx*8+53344], eax
$LN9@s370_do_pu:
  000d4	eb a3		 jmp	 SHORT $LN5@s370_do_pu
$LN6@s370_do_pu:

; 1906 : }

  000d6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000da	c3		 ret	 0
s370_do_purge_tlbe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
match$ = 32
tv74 = 36
ptemask$ = 40
pte$ = 48
p$1 = 56
regs$ = 80
host_regs$ = 88
pfra$ = 96
i$ = 104
z900_is_tlbe_match PROC

; 1860 : {

$LN16:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1861 : RADR pte;
; 1862 : RADR ptemask;
; 1863 : bool match = false;

  00018	c6 44 24 20 00	 mov	 BYTE PTR match$[rsp], 0

; 1864 : 
; 1865 : #if !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1866 :     ptemask = ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 1867 :               PAGETAB_PFRA_4K : PAGETAB_PFRA_2K;
; 1868 :     pte = ((pfra & 0xFFFFFF) >> 8) & ptemask;
; 1869 : #endif
; 1870 : #if defined( FEATURE_S390_DAT )
; 1871 :     ptemask = PAGETAB_PFRA;
; 1872 :     pte = pfra & ptemask;
; 1873 : #endif
; 1874 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1875 :     ptemask = (RADR)ZPGETAB_PFRA;

  0001d	48 c7 44 24 28
	00 f0 ff ff	 mov	 QWORD PTR ptemask$[rsp], -4096 ; fffffffffffff000H

; 1876 :     pte = pfra & ptemask;

  00026	48 8b 44 24 28	 mov	 rax, QWORD PTR ptemask$[rsp]
  0002b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pfra$[rsp]
  00030	48 23 c8	 and	 rcx, rax
  00033	48 8b c1	 mov	 rax, rcx
  00036	48 89 44 24 30	 mov	 QWORD PTR pte$[rsp], rax

; 1877 : #endif
; 1878 : 
; 1879 :     if ((regs->tlb.TLB_PTE(i) & ptemask) == pte)

  0003b	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	48 8b 54 24 28	 mov	 rdx, QWORD PTR ptemask$[rsp]
  0004a	48 8b 84 c1 60
	f0 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+61536]
  00052	48 23 c2	 and	 rax, rdx
  00055	48 3b 44 24 30	 cmp	 rax, QWORD PTR pte$[rsp]
  0005a	75 0a		 jne	 SHORT $LN7@z900_is_tl

; 1880 :         match = true;

  0005c	c6 44 24 20 01	 mov	 BYTE PTR match$[rsp], 1
  00061	e9 a0 00 00 00	 jmp	 $LN8@z900_is_tl
$LN7@z900_is_tl:

; 1881 :     else if (!host_regs)

  00066	48 83 7c 24 58
	00		 cmp	 QWORD PTR host_regs$[rsp], 0
  0006c	75 0a		 jne	 SHORT $LN9@z900_is_tl

; 1882 :         match = false;

  0006e	c6 44 24 20 00	 mov	 BYTE PTR match$[rsp], 0
  00073	e9 8e 00 00 00	 jmp	 $LN10@z900_is_tl
$LN9@z900_is_tl:

; 1883 :     else switch (host_regs->arch_mode)

  00078	48 8b 44 24 58	 mov	 rax, QWORD PTR host_regs$[rsp]
  0007d	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00080	89 44 24 24	 mov	 DWORD PTR tv74[rsp], eax
  00084	83 7c 24 24 00	 cmp	 DWORD PTR tv74[rsp], 0
  00089	74 10		 je	 SHORT $LN11@z900_is_tl
  0008b	83 7c 24 24 01	 cmp	 DWORD PTR tv74[rsp], 1
  00090	74 25		 je	 SHORT $LN12@z900_is_tl
  00092	83 7c 24 24 02	 cmp	 DWORD PTR tv74[rsp], 2
  00097	74 3a		 je	 SHORT $LN13@z900_is_tl
  00099	eb 54		 jmp	 SHORT $LN14@z900_is_tl
$LN11@z900_is_tl:

; 1884 :     {
; 1885 :     case ARCH_370_IDX: match = s370_is_tlbe_match( host_regs, NULL, pfra, i ); break;

  0009b	44 8b 4c 24 68	 mov	 r9d, DWORD PTR i$[rsp]
  000a0	4c 8b 44 24 60	 mov	 r8, QWORD PTR pfra$[rsp]
  000a5	33 d2		 xor	 edx, edx
  000a7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR host_regs$[rsp]
  000ac	e8 00 00 00 00	 call	 s370_is_tlbe_match
  000b1	88 44 24 20	 mov	 BYTE PTR match$[rsp], al
  000b5	eb 4f		 jmp	 SHORT $LN2@z900_is_tl
$LN12@z900_is_tl:

; 1886 :     case ARCH_390_IDX: match = s390_is_tlbe_match( host_regs, NULL, pfra, i ); break;

  000b7	44 8b 4c 24 68	 mov	 r9d, DWORD PTR i$[rsp]
  000bc	4c 8b 44 24 60	 mov	 r8, QWORD PTR pfra$[rsp]
  000c1	33 d2		 xor	 edx, edx
  000c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR host_regs$[rsp]
  000c8	e8 00 00 00 00	 call	 s390_is_tlbe_match
  000cd	88 44 24 20	 mov	 BYTE PTR match$[rsp], al
  000d1	eb 33		 jmp	 SHORT $LN2@z900_is_tl
$LN13@z900_is_tl:

; 1887 :     case ARCH_900_IDX: match = z900_is_tlbe_match( host_regs, NULL, pfra, i ); break;

  000d3	44 8b 4c 24 68	 mov	 r9d, DWORD PTR i$[rsp]
  000d8	4c 8b 44 24 60	 mov	 r8, QWORD PTR pfra$[rsp]
  000dd	33 d2		 xor	 edx, edx
  000df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR host_regs$[rsp]
  000e4	e8 00 00 00 00	 call	 z900_is_tlbe_match
  000e9	88 44 24 20	 mov	 BYTE PTR match$[rsp], al
  000ed	eb 17		 jmp	 SHORT $LN2@z900_is_tl
$LN14@z900_is_tl:
$LN6@z900_is_tl:

; 1888 :     default: CRASH();

  000ef	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000f8	48 8b 44 24 38	 mov	 rax, QWORD PTR p$1[rsp]
  000fd	c6 00 00	 mov	 BYTE PTR [rax], 0
  00100	33 c0		 xor	 eax, eax
  00102	85 c0		 test	 eax, eax
  00104	75 e9		 jne	 SHORT $LN6@z900_is_tl
$LN2@z900_is_tl:
$LN10@z900_is_tl:
$LN8@z900_is_tl:

; 1889 :     }
; 1890 : 
; 1891 :     return match;

  00106	0f b6 44 24 20	 movzx	 eax, BYTE PTR match$[rsp]

; 1892 : }

  0010b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010f	c3		 ret	 0
z900_is_tlbe_match ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
match$ = 32
tv75 = 36
ptemask$ = 40
pte$ = 48
p$1 = 56
regs$ = 80
host_regs$ = 88
pfra$ = 96
i$ = 104
s390_is_tlbe_match PROC

; 1860 : {

$LN16:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1861 : RADR pte;
; 1862 : RADR ptemask;
; 1863 : bool match = false;

  00018	c6 44 24 20 00	 mov	 BYTE PTR match$[rsp], 0

; 1864 : 
; 1865 : #if !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1866 :     ptemask = ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?
; 1867 :               PAGETAB_PFRA_4K : PAGETAB_PFRA_2K;
; 1868 :     pte = ((pfra & 0xFFFFFF) >> 8) & ptemask;
; 1869 : #endif
; 1870 : #if defined( FEATURE_S390_DAT )
; 1871 :     ptemask = PAGETAB_PFRA;

  0001d	48 c7 44 24 28
	00 f0 ff 7f	 mov	 QWORD PTR ptemask$[rsp], 2147479552 ; 7ffff000H

; 1872 :     pte = pfra & ptemask;

  00026	48 8b 44 24 28	 mov	 rax, QWORD PTR ptemask$[rsp]
  0002b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pfra$[rsp]
  00030	48 23 c8	 and	 rcx, rax
  00033	48 8b c1	 mov	 rax, rcx
  00036	48 89 44 24 30	 mov	 QWORD PTR pte$[rsp], rax

; 1873 : #endif
; 1874 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1875 :     ptemask = (RADR)ZPGETAB_PFRA;
; 1876 :     pte = pfra & ptemask;
; 1877 : #endif
; 1878 : 
; 1879 :     if ((regs->tlb.TLB_PTE(i) & ptemask) == pte)

  0003b	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	8b 84 c1 60 f0
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+61536]
  0004c	48 23 44 24 28	 and	 rax, QWORD PTR ptemask$[rsp]
  00051	48 3b 44 24 30	 cmp	 rax, QWORD PTR pte$[rsp]
  00056	75 0a		 jne	 SHORT $LN7@s390_is_tl

; 1880 :         match = true;

  00058	c6 44 24 20 01	 mov	 BYTE PTR match$[rsp], 1
  0005d	e9 a0 00 00 00	 jmp	 $LN8@s390_is_tl
$LN7@s390_is_tl:

; 1881 :     else if (!host_regs)

  00062	48 83 7c 24 58
	00		 cmp	 QWORD PTR host_regs$[rsp], 0
  00068	75 0a		 jne	 SHORT $LN9@s390_is_tl

; 1882 :         match = false;

  0006a	c6 44 24 20 00	 mov	 BYTE PTR match$[rsp], 0
  0006f	e9 8e 00 00 00	 jmp	 $LN10@s390_is_tl
$LN9@s390_is_tl:

; 1883 :     else switch (host_regs->arch_mode)

  00074	48 8b 44 24 58	 mov	 rax, QWORD PTR host_regs$[rsp]
  00079	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0007c	89 44 24 24	 mov	 DWORD PTR tv75[rsp], eax
  00080	83 7c 24 24 00	 cmp	 DWORD PTR tv75[rsp], 0
  00085	74 10		 je	 SHORT $LN11@s390_is_tl
  00087	83 7c 24 24 01	 cmp	 DWORD PTR tv75[rsp], 1
  0008c	74 25		 je	 SHORT $LN12@s390_is_tl
  0008e	83 7c 24 24 02	 cmp	 DWORD PTR tv75[rsp], 2
  00093	74 3a		 je	 SHORT $LN13@s390_is_tl
  00095	eb 54		 jmp	 SHORT $LN14@s390_is_tl
$LN11@s390_is_tl:

; 1884 :     {
; 1885 :     case ARCH_370_IDX: match = s370_is_tlbe_match( host_regs, NULL, pfra, i ); break;

  00097	44 8b 4c 24 68	 mov	 r9d, DWORD PTR i$[rsp]
  0009c	4c 8b 44 24 60	 mov	 r8, QWORD PTR pfra$[rsp]
  000a1	33 d2		 xor	 edx, edx
  000a3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR host_regs$[rsp]
  000a8	e8 00 00 00 00	 call	 s370_is_tlbe_match
  000ad	88 44 24 20	 mov	 BYTE PTR match$[rsp], al
  000b1	eb 4f		 jmp	 SHORT $LN2@s390_is_tl
$LN12@s390_is_tl:

; 1886 :     case ARCH_390_IDX: match = s390_is_tlbe_match( host_regs, NULL, pfra, i ); break;

  000b3	44 8b 4c 24 68	 mov	 r9d, DWORD PTR i$[rsp]
  000b8	4c 8b 44 24 60	 mov	 r8, QWORD PTR pfra$[rsp]
  000bd	33 d2		 xor	 edx, edx
  000bf	48 8b 4c 24 58	 mov	 rcx, QWORD PTR host_regs$[rsp]
  000c4	e8 00 00 00 00	 call	 s390_is_tlbe_match
  000c9	88 44 24 20	 mov	 BYTE PTR match$[rsp], al
  000cd	eb 33		 jmp	 SHORT $LN2@s390_is_tl
$LN13@s390_is_tl:

; 1887 :     case ARCH_900_IDX: match = z900_is_tlbe_match( host_regs, NULL, pfra, i ); break;

  000cf	44 8b 4c 24 68	 mov	 r9d, DWORD PTR i$[rsp]
  000d4	4c 8b 44 24 60	 mov	 r8, QWORD PTR pfra$[rsp]
  000d9	33 d2		 xor	 edx, edx
  000db	48 8b 4c 24 58	 mov	 rcx, QWORD PTR host_regs$[rsp]
  000e0	e8 00 00 00 00	 call	 z900_is_tlbe_match
  000e5	88 44 24 20	 mov	 BYTE PTR match$[rsp], al
  000e9	eb 17		 jmp	 SHORT $LN2@s390_is_tl
$LN14@s390_is_tl:
$LN6@s390_is_tl:

; 1888 :     default: CRASH();

  000eb	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000f4	48 8b 44 24 38	 mov	 rax, QWORD PTR p$1[rsp]
  000f9	c6 00 00	 mov	 BYTE PTR [rax], 0
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 e9		 jne	 SHORT $LN6@s390_is_tl
$LN2@s390_is_tl:
$LN10@s390_is_tl:
$LN8@s390_is_tl:

; 1889 :     }
; 1890 : 
; 1891 :     return match;

  00102	0f b6 44 24 20	 movzx	 eax, BYTE PTR match$[rsp]

; 1892 : }

  00107	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010b	c3		 ret	 0
s390_is_tlbe_match ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
match$ = 32
tv85 = 36
tv70 = 40
ptemask$ = 48
pte$ = 56
p$1 = 64
regs$ = 96
host_regs$ = 104
pfra$ = 112
i$ = 120
s370_is_tlbe_match PROC

; 1860 : {

$LN18:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1861 : RADR pte;
; 1862 : RADR ptemask;
; 1863 : bool match = false;

  00018	c6 44 24 20 00	 mov	 BYTE PTR match$[rsp], 0

; 1864 : 
; 1865 : #if !defined( FEATURE_S390_DAT ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1866 :     ptemask = ((regs->CR(0) & CR0_PAGE_SIZE) == CR0_PAGE_SZ_4K) ?

  0001d	b8 08 00 00 00	 mov	 eax, 8
  00022	48 6b c0 01	 imul	 rax, rax, 1
  00026	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0002b	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00032	25 00 00 c0 00	 and	 eax, 12582912		; 00c00000H
  00037	3d 00 00 80 00	 cmp	 eax, 8388608		; 00800000H
  0003c	75 0a		 jne	 SHORT $LN16@s370_is_tl
  0003e	c7 44 24 28 f0
	ff 00 00	 mov	 DWORD PTR tv70[rsp], 65520 ; 0000fff0H
  00046	eb 08		 jmp	 SHORT $LN17@s370_is_tl
$LN16@s370_is_tl:
  00048	c7 44 24 28 f8
	ff 00 00	 mov	 DWORD PTR tv70[rsp], 65528 ; 0000fff8H
$LN17@s370_is_tl:
  00050	48 63 44 24 28	 movsxd	 rax, DWORD PTR tv70[rsp]
  00055	48 89 44 24 30	 mov	 QWORD PTR ptemask$[rsp], rax

; 1867 :               PAGETAB_PFRA_4K : PAGETAB_PFRA_2K;
; 1868 :     pte = ((pfra & 0xFFFFFF) >> 8) & ptemask;

  0005a	48 8b 44 24 70	 mov	 rax, QWORD PTR pfra$[rsp]
  0005f	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00065	48 c1 e8 08	 shr	 rax, 8
  00069	48 23 44 24 30	 and	 rax, QWORD PTR ptemask$[rsp]
  0006e	48 89 44 24 38	 mov	 QWORD PTR pte$[rsp], rax

; 1869 : #endif
; 1870 : #if defined( FEATURE_S390_DAT )
; 1871 :     ptemask = PAGETAB_PFRA;
; 1872 :     pte = pfra & ptemask;
; 1873 : #endif
; 1874 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1875 :     ptemask = (RADR)ZPGETAB_PFRA;
; 1876 :     pte = pfra & ptemask;
; 1877 : #endif
; 1878 : 
; 1879 :     if ((regs->tlb.TLB_PTE(i) & ptemask) == pte)

  00073	48 63 44 24 78	 movsxd	 rax, DWORD PTR i$[rsp]
  00078	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0007d	8b 84 c1 60 f0
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+61536]
  00084	48 23 44 24 30	 and	 rax, QWORD PTR ptemask$[rsp]
  00089	48 3b 44 24 38	 cmp	 rax, QWORD PTR pte$[rsp]
  0008e	75 0a		 jne	 SHORT $LN7@s370_is_tl

; 1880 :         match = true;

  00090	c6 44 24 20 01	 mov	 BYTE PTR match$[rsp], 1
  00095	e9 a0 00 00 00	 jmp	 $LN8@s370_is_tl
$LN7@s370_is_tl:

; 1881 :     else if (!host_regs)

  0009a	48 83 7c 24 68
	00		 cmp	 QWORD PTR host_regs$[rsp], 0
  000a0	75 0a		 jne	 SHORT $LN9@s370_is_tl

; 1882 :         match = false;

  000a2	c6 44 24 20 00	 mov	 BYTE PTR match$[rsp], 0
  000a7	e9 8e 00 00 00	 jmp	 $LN10@s370_is_tl
$LN9@s370_is_tl:

; 1883 :     else switch (host_regs->arch_mode)

  000ac	48 8b 44 24 68	 mov	 rax, QWORD PTR host_regs$[rsp]
  000b1	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  000b4	89 44 24 24	 mov	 DWORD PTR tv85[rsp], eax
  000b8	83 7c 24 24 00	 cmp	 DWORD PTR tv85[rsp], 0
  000bd	74 10		 je	 SHORT $LN11@s370_is_tl
  000bf	83 7c 24 24 01	 cmp	 DWORD PTR tv85[rsp], 1
  000c4	74 25		 je	 SHORT $LN12@s370_is_tl
  000c6	83 7c 24 24 02	 cmp	 DWORD PTR tv85[rsp], 2
  000cb	74 3a		 je	 SHORT $LN13@s370_is_tl
  000cd	eb 54		 jmp	 SHORT $LN14@s370_is_tl
$LN11@s370_is_tl:

; 1884 :     {
; 1885 :     case ARCH_370_IDX: match = s370_is_tlbe_match( host_regs, NULL, pfra, i ); break;

  000cf	44 8b 4c 24 78	 mov	 r9d, DWORD PTR i$[rsp]
  000d4	4c 8b 44 24 70	 mov	 r8, QWORD PTR pfra$[rsp]
  000d9	33 d2		 xor	 edx, edx
  000db	48 8b 4c 24 68	 mov	 rcx, QWORD PTR host_regs$[rsp]
  000e0	e8 00 00 00 00	 call	 s370_is_tlbe_match
  000e5	88 44 24 20	 mov	 BYTE PTR match$[rsp], al
  000e9	eb 4f		 jmp	 SHORT $LN2@s370_is_tl
$LN12@s370_is_tl:

; 1886 :     case ARCH_390_IDX: match = s390_is_tlbe_match( host_regs, NULL, pfra, i ); break;

  000eb	44 8b 4c 24 78	 mov	 r9d, DWORD PTR i$[rsp]
  000f0	4c 8b 44 24 70	 mov	 r8, QWORD PTR pfra$[rsp]
  000f5	33 d2		 xor	 edx, edx
  000f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR host_regs$[rsp]
  000fc	e8 00 00 00 00	 call	 s390_is_tlbe_match
  00101	88 44 24 20	 mov	 BYTE PTR match$[rsp], al
  00105	eb 33		 jmp	 SHORT $LN2@s370_is_tl
$LN13@s370_is_tl:

; 1887 :     case ARCH_900_IDX: match = z900_is_tlbe_match( host_regs, NULL, pfra, i ); break;

  00107	44 8b 4c 24 78	 mov	 r9d, DWORD PTR i$[rsp]
  0010c	4c 8b 44 24 70	 mov	 r8, QWORD PTR pfra$[rsp]
  00111	33 d2		 xor	 edx, edx
  00113	48 8b 4c 24 68	 mov	 rcx, QWORD PTR host_regs$[rsp]
  00118	e8 00 00 00 00	 call	 z900_is_tlbe_match
  0011d	88 44 24 20	 mov	 BYTE PTR match$[rsp], al
  00121	eb 17		 jmp	 SHORT $LN2@s370_is_tl
$LN14@s370_is_tl:
$LN6@s370_is_tl:

; 1888 :     default: CRASH();

  00123	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  0012c	48 8b 44 24 40	 mov	 rax, QWORD PTR p$1[rsp]
  00131	c6 00 00	 mov	 BYTE PTR [rax], 0
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	75 e9		 jne	 SHORT $LN6@s370_is_tl
$LN2@s370_is_tl:
$LN10@s370_is_tl:
$LN8@s370_is_tl:

; 1889 :     }
; 1890 : 
; 1891 :     return match;

  0013a	0f b6 44 24 20	 movzx	 eax, BYTE PTR match$[rsp]

; 1892 : }

  0013f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00143	c3		 ret	 0
s370_is_tlbe_match ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
i$ = 0
regs$ = 32
mask$ = 40
z900_do_invalidate_tlb PROC

; 1979 : {

$LN13:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16
$LN4@z900_do_in:

; 1980 : int  i;
; 1981 : 
; 1982 :     INVALIDATE_AIA( regs );

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0001b	74 52		 je	 SHORT $LN8@z900_do_in
  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00022	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00027	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0002e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00032	48 2b c1	 sub	 rax, rcx
  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0003a	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00041	48 03 c8	 add	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00058	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00064	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN8@z900_do_in:
  0006f	33 c0		 xor	 eax, eax
  00071	85 c0		 test	 eax, eax
  00073	75 99		 jne	 SHORT $LN4@z900_do_in

; 1983 :     if (mask == 0)

  00075	0f b6 44 24 28	 movzx	 eax, BYTE PTR mask$[rsp]
  0007a	85 c0		 test	 eax, eax
  0007c	75 19		 jne	 SHORT $LN9@z900_do_in

; 1984 :         memset( &regs->tlb.acc, 0, TLBN );

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00083	48 05 60 5c 01
	00		 add	 rax, 89184		; 00015c60H
  00089	48 8b f8	 mov	 rdi, rax
  0008c	33 c0		 xor	 eax, eax
  0008e	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00093	f3 aa		 rep stosb
  00095	eb 6b		 jmp	 SHORT $LN10@z900_do_in
$LN9@z900_do_in:

; 1985 :     else
; 1986 :         for (i=0; i < TLBN; i++)

  00097	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0009e	eb 08		 jmp	 SHORT $LN7@z900_do_in
$LN5@z900_do_in:
  000a0	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000a3	ff c0		 inc	 eax
  000a5	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_do_in:
  000a8	81 3c 24 00 04
	00 00		 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  000af	7d 51		 jge	 SHORT $LN6@z900_do_in

; 1987 :             if ((regs->tlb.TLB_VADDR(i) & TLBID_BYTEMASK) == regs->tlbID)

  000b1	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000b5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  000ba	48 8b 84 c1 60
	d0 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+53344]
  000c2	48 25 ff ff 3f
	00		 and	 rax, 4194303		; 003fffffH
  000c8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  000cd	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  000d3	48 3b c1	 cmp	 rax, rcx
  000d6	75 28		 jne	 SHORT $LN11@z900_do_in

; 1988 :                 regs->tlb.acc[i] &= mask;

  000d8	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000dc	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR mask$[rsp]
  000e1	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  000e6	0f b6 84 02 60
	5c 01 00	 movzx	 eax, BYTE PTR [rdx+rax+89184]
  000ee	23 c1		 and	 eax, ecx
  000f0	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  000f4	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  000f9	88 84 0a 60 5c
	01 00		 mov	 BYTE PTR [rdx+rcx+89184], al
$LN11@z900_do_in:
  00100	eb 9e		 jmp	 SHORT $LN5@z900_do_in
$LN6@z900_do_in:
$LN10@z900_do_in:

; 1989 : }

  00102	48 83 c4 10	 add	 rsp, 16
  00106	5f		 pop	 rdi
  00107	c3		 ret	 0
z900_do_invalidate_tlb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
i$ = 0
regs$ = 32
mask$ = 40
s390_do_invalidate_tlb PROC

; 1979 : {

$LN13:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16
$LN4@s390_do_in:

; 1980 : int  i;
; 1981 : 
; 1982 :     INVALIDATE_AIA( regs );

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0001b	74 4f		 je	 SHORT $LN8@s390_do_in
  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00028	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  00032	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00039	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0003d	48 2b ca	 sub	 rcx, rdx
  00040	48 03 c1	 add	 rax, rcx
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0004e	48 23 c1	 and	 rax, rcx
  00051	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00056	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00061	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN8@s390_do_in:
  0006c	33 c0		 xor	 eax, eax
  0006e	85 c0		 test	 eax, eax
  00070	75 9c		 jne	 SHORT $LN4@s390_do_in

; 1983 :     if (mask == 0)

  00072	0f b6 44 24 28	 movzx	 eax, BYTE PTR mask$[rsp]
  00077	85 c0		 test	 eax, eax
  00079	75 19		 jne	 SHORT $LN9@s390_do_in

; 1984 :         memset( &regs->tlb.acc, 0, TLBN );

  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00080	48 05 60 5c 01
	00		 add	 rax, 89184		; 00015c60H
  00086	48 8b f8	 mov	 rdi, rax
  00089	33 c0		 xor	 eax, eax
  0008b	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00090	f3 aa		 rep stosb
  00092	eb 66		 jmp	 SHORT $LN10@s390_do_in
$LN9@s390_do_in:

; 1985 :     else
; 1986 :         for (i=0; i < TLBN; i++)

  00094	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0009b	eb 08		 jmp	 SHORT $LN7@s390_do_in
$LN5@s390_do_in:
  0009d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_do_in:
  000a5	81 3c 24 00 04
	00 00		 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  000ac	7d 4c		 jge	 SHORT $LN6@s390_do_in

; 1987 :             if ((regs->tlb.TLB_VADDR(i) & TLBID_BYTEMASK) == regs->tlbID)

  000ae	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000b2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  000b7	8b 84 c1 60 d0
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+53344]
  000be	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  000c3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	3b 81 58 b0 00
	00		 cmp	 eax, DWORD PTR [rcx+45144]
  000ce	75 28		 jne	 SHORT $LN11@s390_do_in

; 1988 :                 regs->tlb.acc[i] &= mask;

  000d0	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000d4	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR mask$[rsp]
  000d9	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  000de	0f b6 84 02 60
	5c 01 00	 movzx	 eax, BYTE PTR [rdx+rax+89184]
  000e6	23 c1		 and	 eax, ecx
  000e8	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  000ec	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	88 84 0a 60 5c
	01 00		 mov	 BYTE PTR [rdx+rcx+89184], al
$LN11@s390_do_in:
  000f8	eb a3		 jmp	 SHORT $LN5@s390_do_in
$LN6@s390_do_in:
$LN10@s390_do_in:

; 1989 : }

  000fa	48 83 c4 10	 add	 rsp, 16
  000fe	5f		 pop	 rdi
  000ff	c3		 ret	 0
s390_do_invalidate_tlb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
i$ = 0
regs$ = 32
mask$ = 40
s370_do_invalidate_tlb PROC

; 1979 : {

$LN13:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16
$LN4@s370_do_in:

; 1980 : int  i;
; 1981 : 
; 1982 :     INVALIDATE_AIA( regs );

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0001b	74 47		 je	 SHORT $LN8@s370_do_in
  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00028	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  00032	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00039	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0003d	48 2b ca	 sub	 rcx, rdx
  00040	48 03 c1	 add	 rax, rcx
  00043	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00049	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00059	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN8@s370_do_in:
  00064	33 c0		 xor	 eax, eax
  00066	85 c0		 test	 eax, eax
  00068	75 a4		 jne	 SHORT $LN4@s370_do_in

; 1983 :     if (mask == 0)

  0006a	0f b6 44 24 28	 movzx	 eax, BYTE PTR mask$[rsp]
  0006f	85 c0		 test	 eax, eax
  00071	75 19		 jne	 SHORT $LN9@s370_do_in

; 1984 :         memset( &regs->tlb.acc, 0, TLBN );

  00073	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 05 60 5c 01
	00		 add	 rax, 89184		; 00015c60H
  0007e	48 8b f8	 mov	 rdi, rax
  00081	33 c0		 xor	 eax, eax
  00083	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00088	f3 aa		 rep stosb
  0008a	eb 66		 jmp	 SHORT $LN10@s370_do_in
$LN9@s370_do_in:

; 1985 :     else
; 1986 :         for (i=0; i < TLBN; i++)

  0008c	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00093	eb 08		 jmp	 SHORT $LN7@s370_do_in
$LN5@s370_do_in:
  00095	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00098	ff c0		 inc	 eax
  0009a	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_do_in:
  0009d	81 3c 24 00 04
	00 00		 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  000a4	7d 4c		 jge	 SHORT $LN6@s370_do_in

; 1987 :             if ((regs->tlb.TLB_VADDR(i) & TLBID_BYTEMASK) == regs->tlbID)

  000a6	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000aa	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  000af	8b 84 c1 60 d0
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+53344]
  000b6	25 ff ff 1f 00	 and	 eax, 2097151		; 001fffffH
  000bb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	3b 81 58 b0 00
	00		 cmp	 eax, DWORD PTR [rcx+45144]
  000c6	75 28		 jne	 SHORT $LN11@s370_do_in

; 1988 :                 regs->tlb.acc[i] &= mask;

  000c8	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000cc	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR mask$[rsp]
  000d1	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  000d6	0f b6 84 02 60
	5c 01 00	 movzx	 eax, BYTE PTR [rdx+rax+89184]
  000de	23 c1		 and	 eax, ecx
  000e0	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  000e4	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  000e9	88 84 0a 60 5c
	01 00		 mov	 BYTE PTR [rdx+rcx+89184], al
$LN11@s370_do_in:
  000f0	eb a3		 jmp	 SHORT $LN5@s370_do_in
$LN6@s370_do_in:
$LN10@s370_do_in:

; 1989 : }

  000f2	48 83 c4 10	 add	 rsp, 16
  000f6	5f		 pop	 rdi
  000f7	c3		 ret	 0
s370_do_invalidate_tlb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
;	COMDAT z900_purge_alb
_TEXT	SEGMENT
tv73 = 32
p$1 = 40
regs$ = 64
z900_purge_alb PROC					; COMDAT

; 231  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 232  :     /* Do it for the current architecture first */
; 233  :     ARCH_DEP( do_purge_alb )( regs );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0000e	e8 00 00 00 00	 call	 z900_do_purge_alb

; 234  : 
; 235  : #if defined( _FEATURE_SIE )
; 236  :     /* Also clear the guest registers in the SIE copy */
; 237  :     if (regs->host && GUESTREGS)

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00018	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001e	c1 e8 07	 shr	 eax, 7
  00021	83 e0 01	 and	 eax, 1
  00024	85 c0		 test	 eax, eax
  00026	74 78		 je	 SHORT $LN7@z900_purge
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0002d	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00035	74 69		 je	 SHORT $LN7@z900_purge

; 238  :     {
; 239  :         switch (GUESTREGS->arch_mode)

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0003c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00043	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00046	89 44 24 20	 mov	 DWORD PTR tv73[rsp], eax
  0004a	83 7c 24 20 00	 cmp	 DWORD PTR tv73[rsp], 0
  0004f	74 10		 je	 SHORT $LN8@z900_purge
  00051	83 7c 24 20 01	 cmp	 DWORD PTR tv73[rsp], 1
  00056	74 0b		 je	 SHORT $LN9@z900_purge
  00058	83 7c 24 20 02	 cmp	 DWORD PTR tv73[rsp], 2
  0005d	74 17		 je	 SHORT $LN10@z900_purge
  0005f	eb 28		 jmp	 SHORT $LN11@z900_purge
$LN8@z900_purge:

; 240  :         {
; 241  :         case ARCH_370_IDX: /* No access regs for 370! */   break;

  00061	eb 3d		 jmp	 SHORT $LN2@z900_purge
$LN9@z900_purge:

; 242  :         case ARCH_390_IDX: s390_do_purge_alb( GUESTREGS ); break;

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00068	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0006f	e8 00 00 00 00	 call	 s390_do_purge_alb
  00074	eb 2a		 jmp	 SHORT $LN2@z900_purge
$LN10@z900_purge:

; 243  :         case ARCH_900_IDX: z900_do_purge_alb( GUESTREGS ); break;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0007b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00082	e8 00 00 00 00	 call	 z900_do_purge_alb
  00087	eb 17		 jmp	 SHORT $LN2@z900_purge
$LN11@z900_purge:
$LN6@z900_purge:

; 244  :         default: CRASH();

  00089	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00092	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00097	c6 00 00	 mov	 BYTE PTR [rax], 0
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 e9		 jne	 SHORT $LN6@z900_purge
$LN2@z900_purge:
$LN7@z900_purge:

; 245  :         }
; 246  :     }
; 247  : #endif // defined( _FEATURE_SIE )
; 248  : }

  000a0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a4	c3		 ret	 0
z900_purge_alb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
;	COMDAT s390_purge_alb
_TEXT	SEGMENT
tv73 = 32
p$1 = 40
regs$ = 64
s390_purge_alb PROC					; COMDAT

; 231  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 232  :     /* Do it for the current architecture first */
; 233  :     ARCH_DEP( do_purge_alb )( regs );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0000e	e8 00 00 00 00	 call	 s390_do_purge_alb

; 234  : 
; 235  : #if defined( _FEATURE_SIE )
; 236  :     /* Also clear the guest registers in the SIE copy */
; 237  :     if (regs->host && GUESTREGS)

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00018	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001e	c1 e8 07	 shr	 eax, 7
  00021	83 e0 01	 and	 eax, 1
  00024	85 c0		 test	 eax, eax
  00026	74 78		 je	 SHORT $LN7@s390_purge
  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0002d	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00035	74 69		 je	 SHORT $LN7@s390_purge

; 238  :     {
; 239  :         switch (GUESTREGS->arch_mode)

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0003c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00043	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00046	89 44 24 20	 mov	 DWORD PTR tv73[rsp], eax
  0004a	83 7c 24 20 00	 cmp	 DWORD PTR tv73[rsp], 0
  0004f	74 10		 je	 SHORT $LN8@s390_purge
  00051	83 7c 24 20 01	 cmp	 DWORD PTR tv73[rsp], 1
  00056	74 0b		 je	 SHORT $LN9@s390_purge
  00058	83 7c 24 20 02	 cmp	 DWORD PTR tv73[rsp], 2
  0005d	74 17		 je	 SHORT $LN10@s390_purge
  0005f	eb 28		 jmp	 SHORT $LN11@s390_purge
$LN8@s390_purge:

; 240  :         {
; 241  :         case ARCH_370_IDX: /* No access regs for 370! */   break;

  00061	eb 3d		 jmp	 SHORT $LN2@s390_purge
$LN9@s390_purge:

; 242  :         case ARCH_390_IDX: s390_do_purge_alb( GUESTREGS ); break;

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00068	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0006f	e8 00 00 00 00	 call	 s390_do_purge_alb
  00074	eb 2a		 jmp	 SHORT $LN2@s390_purge
$LN10@s390_purge:

; 243  :         case ARCH_900_IDX: z900_do_purge_alb( GUESTREGS ); break;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0007b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00082	e8 00 00 00 00	 call	 z900_do_purge_alb
  00087	eb 17		 jmp	 SHORT $LN2@s390_purge
$LN11@s390_purge:
$LN6@s390_purge:

; 244  :         default: CRASH();

  00089	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00092	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00097	c6 00 00	 mov	 BYTE PTR [rax], 0
  0009a	33 c0		 xor	 eax, eax
  0009c	85 c0		 test	 eax, eax
  0009e	75 e9		 jne	 SHORT $LN6@s390_purge
$LN2@s390_purge:
$LN7@s390_purge:

; 245  :         }
; 246  :     }
; 247  : #endif // defined( _FEATURE_SIE )
; 248  : }

  000a0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a4	c3		 ret	 0
s390_purge_alb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
i$ = 0
regs$ = 32
z900_do_purge_alb PROC

; 220  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 221  :     int  i;
; 222  :     for (i=1; i < 16; i++)

  00009	c7 04 24 01 00
	00 00		 mov	 DWORD PTR i$[rsp], 1
  00010	eb 08		 jmp	 SHORT $LN4@z900_do_pu
$LN2@z900_do_pu:
  00012	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00015	ff c0		 inc	 eax
  00017	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_do_pu:
  0001a	83 3c 24 10	 cmp	 DWORD PTR i$[rsp], 16
  0001e	7d 31		 jge	 SHORT $LN3@z900_do_pu

; 223  :         if (regs->AEA_AR(i) >= CR_ALB_OFFSET)

  00020	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00023	83 c0 05	 add	 eax, 5
  00026	48 98		 cdqe
  00028	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	83 bc 81 94 0c
	00 00 10	 cmp	 DWORD PTR [rcx+rax*4+3220], 16
  00035	7c 18		 jl	 SHORT $LN5@z900_do_pu

; 224  :             regs->AEA_AR(i) = 0;

  00037	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0003a	83 c0 05	 add	 eax, 5
  0003d	48 98		 cdqe
  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00044	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN5@z900_do_pu:
  0004f	eb c1		 jmp	 SHORT $LN2@z900_do_pu
$LN3@z900_do_pu:

; 225  : }

  00051	48 83 c4 18	 add	 rsp, 24
  00055	c3		 ret	 0
z900_do_purge_alb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
i$ = 0
regs$ = 32
s390_do_purge_alb PROC

; 220  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 221  :     int  i;
; 222  :     for (i=1; i < 16; i++)

  00009	c7 04 24 01 00
	00 00		 mov	 DWORD PTR i$[rsp], 1
  00010	eb 08		 jmp	 SHORT $LN4@s390_do_pu
$LN2@s390_do_pu:
  00012	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00015	ff c0		 inc	 eax
  00017	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_do_pu:
  0001a	83 3c 24 10	 cmp	 DWORD PTR i$[rsp], 16
  0001e	7d 31		 jge	 SHORT $LN3@s390_do_pu

; 223  :         if (regs->AEA_AR(i) >= CR_ALB_OFFSET)

  00020	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00023	83 c0 05	 add	 eax, 5
  00026	48 98		 cdqe
  00028	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	83 bc 81 94 0c
	00 00 10	 cmp	 DWORD PTR [rcx+rax*4+3220], 16
  00035	7c 18		 jl	 SHORT $LN5@s390_do_pu

; 224  :             regs->AEA_AR(i) = 0;

  00037	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0003a	83 c0 05	 add	 eax, 5
  0003d	48 98		 cdqe
  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00044	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN5@s390_do_pu:
  0004f	eb c1		 jmp	 SHORT $LN2@s390_do_pu
$LN3@s390_do_pu:

; 225  : }

  00051	48 83 c4 18	 add	 rsp, 24
  00055	c3		 ret	 0
s390_do_purge_alb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
;	COMDAT z900_purge_tlb
_TEXT	SEGMENT
tv73 = 32
p$1 = 40
regs$ = 64
z900_purge_tlb PROC					; COMDAT

; 194  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 195  :     /* Do it for the current architecture first */
; 196  :     ARCH_DEP( do_purge_tlb )( regs );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0000e	e8 00 00 00 00	 call	 z900_do_purge_tlb

; 197  : 
; 198  : #if defined( _FEATURE_SIE )
; 199  : 
; 200  :     /* Also clear the guest registers in the SIE copy */
; 201  :     if (regs->host && GUESTREGS)

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00018	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001e	c1 e8 07	 shr	 eax, 7
  00021	83 e0 01	 and	 eax, 1
  00024	85 c0		 test	 eax, eax
  00026	0f 84 89 00 00
	00		 je	 $LN7@z900_purge
  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00031	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00039	74 7a		 je	 SHORT $LN7@z900_purge

; 202  :     {
; 203  :         switch (GUESTREGS->arch_mode)

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00040	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00047	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0004a	89 44 24 20	 mov	 DWORD PTR tv73[rsp], eax
  0004e	83 7c 24 20 00	 cmp	 DWORD PTR tv73[rsp], 0
  00053	74 10		 je	 SHORT $LN8@z900_purge
  00055	83 7c 24 20 01	 cmp	 DWORD PTR tv73[rsp], 1
  0005a	74 1c		 je	 SHORT $LN9@z900_purge
  0005c	83 7c 24 20 02	 cmp	 DWORD PTR tv73[rsp], 2
  00061	74 28		 je	 SHORT $LN10@z900_purge
  00063	eb 39		 jmp	 SHORT $LN11@z900_purge
$LN8@z900_purge:

; 204  :         {
; 205  :         case ARCH_370_IDX: s370_do_purge_tlb( GUESTREGS ); break;

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00071	e8 00 00 00 00	 call	 s370_do_purge_tlb
  00076	eb 3d		 jmp	 SHORT $LN2@z900_purge
$LN9@z900_purge:

; 206  :         case ARCH_390_IDX: s390_do_purge_tlb( GUESTREGS ); break;

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00084	e8 00 00 00 00	 call	 s390_do_purge_tlb
  00089	eb 2a		 jmp	 SHORT $LN2@z900_purge
$LN10@z900_purge:

; 207  :         case ARCH_900_IDX: z900_do_purge_tlb( GUESTREGS ); break;

  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00097	e8 00 00 00 00	 call	 z900_do_purge_tlb
  0009c	eb 17		 jmp	 SHORT $LN2@z900_purge
$LN11@z900_purge:
$LN6@z900_purge:

; 208  :         default: CRASH();

  0009e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000a7	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000ac	c6 00 00	 mov	 BYTE PTR [rax], 0
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 e9		 jne	 SHORT $LN6@z900_purge
$LN2@z900_purge:
$LN7@z900_purge:

; 209  :         }
; 210  :     }
; 211  : #endif // defined( _FEATURE_SIE )
; 212  : }

  000b5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b9	c3		 ret	 0
z900_purge_tlb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
;	COMDAT s390_purge_tlb
_TEXT	SEGMENT
tv73 = 32
p$1 = 40
regs$ = 64
s390_purge_tlb PROC					; COMDAT

; 194  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 195  :     /* Do it for the current architecture first */
; 196  :     ARCH_DEP( do_purge_tlb )( regs );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0000e	e8 00 00 00 00	 call	 s390_do_purge_tlb

; 197  : 
; 198  : #if defined( _FEATURE_SIE )
; 199  : 
; 200  :     /* Also clear the guest registers in the SIE copy */
; 201  :     if (regs->host && GUESTREGS)

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00018	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001e	c1 e8 07	 shr	 eax, 7
  00021	83 e0 01	 and	 eax, 1
  00024	85 c0		 test	 eax, eax
  00026	0f 84 89 00 00
	00		 je	 $LN7@s390_purge
  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00031	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00039	74 7a		 je	 SHORT $LN7@s390_purge

; 202  :     {
; 203  :         switch (GUESTREGS->arch_mode)

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00040	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00047	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0004a	89 44 24 20	 mov	 DWORD PTR tv73[rsp], eax
  0004e	83 7c 24 20 00	 cmp	 DWORD PTR tv73[rsp], 0
  00053	74 10		 je	 SHORT $LN8@s390_purge
  00055	83 7c 24 20 01	 cmp	 DWORD PTR tv73[rsp], 1
  0005a	74 1c		 je	 SHORT $LN9@s390_purge
  0005c	83 7c 24 20 02	 cmp	 DWORD PTR tv73[rsp], 2
  00061	74 28		 je	 SHORT $LN10@s390_purge
  00063	eb 39		 jmp	 SHORT $LN11@s390_purge
$LN8@s390_purge:

; 204  :         {
; 205  :         case ARCH_370_IDX: s370_do_purge_tlb( GUESTREGS ); break;

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00071	e8 00 00 00 00	 call	 s370_do_purge_tlb
  00076	eb 3d		 jmp	 SHORT $LN2@s390_purge
$LN9@s390_purge:

; 206  :         case ARCH_390_IDX: s390_do_purge_tlb( GUESTREGS ); break;

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00084	e8 00 00 00 00	 call	 s390_do_purge_tlb
  00089	eb 2a		 jmp	 SHORT $LN2@s390_purge
$LN10@s390_purge:

; 207  :         case ARCH_900_IDX: z900_do_purge_tlb( GUESTREGS ); break;

  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00097	e8 00 00 00 00	 call	 z900_do_purge_tlb
  0009c	eb 17		 jmp	 SHORT $LN2@s390_purge
$LN11@s390_purge:
$LN6@s390_purge:

; 208  :         default: CRASH();

  0009e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000a7	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000ac	c6 00 00	 mov	 BYTE PTR [rax], 0
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 e9		 jne	 SHORT $LN6@s390_purge
$LN2@s390_purge:
$LN7@s390_purge:

; 209  :         }
; 210  :     }
; 211  : #endif // defined( _FEATURE_SIE )
; 212  : }

  000b5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b9	c3		 ret	 0
s390_purge_tlb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
;	COMDAT s370_purge_tlb
_TEXT	SEGMENT
tv73 = 32
p$1 = 40
regs$ = 64
s370_purge_tlb PROC					; COMDAT

; 194  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 195  :     /* Do it for the current architecture first */
; 196  :     ARCH_DEP( do_purge_tlb )( regs );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0000e	e8 00 00 00 00	 call	 s370_do_purge_tlb

; 197  : 
; 198  : #if defined( _FEATURE_SIE )
; 199  : 
; 200  :     /* Also clear the guest registers in the SIE copy */
; 201  :     if (regs->host && GUESTREGS)

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00018	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001e	c1 e8 07	 shr	 eax, 7
  00021	83 e0 01	 and	 eax, 1
  00024	85 c0		 test	 eax, eax
  00026	0f 84 89 00 00
	00		 je	 $LN7@s370_purge
  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00031	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00039	74 7a		 je	 SHORT $LN7@s370_purge

; 202  :     {
; 203  :         switch (GUESTREGS->arch_mode)

  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00040	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00047	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0004a	89 44 24 20	 mov	 DWORD PTR tv73[rsp], eax
  0004e	83 7c 24 20 00	 cmp	 DWORD PTR tv73[rsp], 0
  00053	74 10		 je	 SHORT $LN8@s370_purge
  00055	83 7c 24 20 01	 cmp	 DWORD PTR tv73[rsp], 1
  0005a	74 1c		 je	 SHORT $LN9@s370_purge
  0005c	83 7c 24 20 02	 cmp	 DWORD PTR tv73[rsp], 2
  00061	74 28		 je	 SHORT $LN10@s370_purge
  00063	eb 39		 jmp	 SHORT $LN11@s370_purge
$LN8@s370_purge:

; 204  :         {
; 205  :         case ARCH_370_IDX: s370_do_purge_tlb( GUESTREGS ); break;

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00071	e8 00 00 00 00	 call	 s370_do_purge_tlb
  00076	eb 3d		 jmp	 SHORT $LN2@s370_purge
$LN9@s370_purge:

; 206  :         case ARCH_390_IDX: s390_do_purge_tlb( GUESTREGS ); break;

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00084	e8 00 00 00 00	 call	 s390_do_purge_tlb
  00089	eb 2a		 jmp	 SHORT $LN2@s370_purge
$LN10@s370_purge:

; 207  :         case ARCH_900_IDX: z900_do_purge_tlb( GUESTREGS ); break;

  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00097	e8 00 00 00 00	 call	 z900_do_purge_tlb
  0009c	eb 17		 jmp	 SHORT $LN2@s370_purge
$LN11@s370_purge:
$LN6@s370_purge:

; 208  :         default: CRASH();

  0009e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  000a7	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  000ac	c6 00 00	 mov	 BYTE PTR [rax], 0
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 e9		 jne	 SHORT $LN6@s370_purge
$LN2@s370_purge:
$LN7@s370_purge:

; 209  :         }
; 210  :     }
; 211  : #endif // defined( _FEATURE_SIE )
; 212  : }

  000b5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b9	c3		 ret	 0
s370_purge_tlb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv78 = 0
regs$ = 32
z900_do_purge_tlb PROC

; 180  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
$LN4@z900_do_pu:

; 181  :     INVALIDATE_AIA( regs );

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0000f	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00017	74 52		 je	 SHORT $LN5@z900_do_pu
  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00023	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0002a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0002e	48 2b c1	 sub	 rax, rcx
  00031	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0003d	48 03 c8	 add	 rcx, rax
  00040	48 8b c1	 mov	 rax, rcx
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00060	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN5@z900_do_pu:
  0006b	33 c0		 xor	 eax, eax
  0006d	85 c0		 test	 eax, eax
  0006f	75 99		 jne	 SHORT $LN4@z900_do_pu

; 182  : 
; 183  :     if (((++regs->tlbID) & TLBID_BYTEMASK) == 0)

  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00076	8b 80 58 b0 00
	00		 mov	 eax, DWORD PTR [rax+45144]
  0007c	ff c0		 inc	 eax
  0007e	89 04 24	 mov	 DWORD PTR tv78[rsp], eax
  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00086	8b 0c 24	 mov	 ecx, DWORD PTR tv78[rsp]
  00089	89 88 58 b0 00
	00		 mov	 DWORD PTR [rax+45144], ecx
  0008f	8b 04 24	 mov	 eax, DWORD PTR tv78[rsp]
  00092	48 25 ff ff 3f
	00		 and	 rax, 4194303		; 003fffffH
  00098	48 85 c0	 test	 rax, rax
  0009b	75 26		 jne	 SHORT $LN6@z900_do_pu

; 184  :     {
; 185  :         memset( &regs->tlb.vaddr, 0, TLBN * sizeof( DW ));

  0009d	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  000a2	48 05 60 d0 00
	00		 add	 rax, 53344		; 0000d060H
  000a8	48 8b f8	 mov	 rdi, rax
  000ab	33 c0		 xor	 eax, eax
  000ad	b9 00 20 00 00	 mov	 ecx, 8192		; 00002000H
  000b2	f3 aa		 rep stosb

; 186  :         regs->tlbID = 1;

  000b4	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  000b9	c7 80 58 b0 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+45144], 1
$LN6@z900_do_pu:

; 187  :     }
; 188  : }

  000c3	48 83 c4 10	 add	 rsp, 16
  000c7	5f		 pop	 rdi
  000c8	c3		 ret	 0
z900_do_purge_tlb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv81 = 0
regs$ = 32
s390_do_purge_tlb PROC

; 180  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
$LN4@s390_do_pu:

; 181  :     INVALIDATE_AIA( regs );

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0000f	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00017	74 4f		 je	 SHORT $LN5@s390_do_pu
  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0001e	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00024	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00029	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  0002e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00035	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00039	48 2b ca	 sub	 rcx, rdx
  0003c	48 03 c1	 add	 rax, rcx
  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00044	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0004a	48 23 c1	 and	 rax, rcx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN5@s390_do_pu:
  00068	33 c0		 xor	 eax, eax
  0006a	85 c0		 test	 eax, eax
  0006c	75 9c		 jne	 SHORT $LN4@s390_do_pu

; 182  : 
; 183  :     if (((++regs->tlbID) & TLBID_BYTEMASK) == 0)

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00073	8b 80 58 b0 00
	00		 mov	 eax, DWORD PTR [rax+45144]
  00079	ff c0		 inc	 eax
  0007b	89 04 24	 mov	 DWORD PTR tv81[rsp], eax
  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00083	8b 0c 24	 mov	 ecx, DWORD PTR tv81[rsp]
  00086	89 88 58 b0 00
	00		 mov	 DWORD PTR [rax+45144], ecx
  0008c	8b 04 24	 mov	 eax, DWORD PTR tv81[rsp]
  0008f	25 ff ff 3f 00	 and	 eax, 4194303		; 003fffffH
  00094	85 c0		 test	 eax, eax
  00096	75 26		 jne	 SHORT $LN6@s390_do_pu

; 184  :     {
; 185  :         memset( &regs->tlb.vaddr, 0, TLBN * sizeof( DW ));

  00098	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0009d	48 05 60 d0 00
	00		 add	 rax, 53344		; 0000d060H
  000a3	48 8b f8	 mov	 rdi, rax
  000a6	33 c0		 xor	 eax, eax
  000a8	b9 00 20 00 00	 mov	 ecx, 8192		; 00002000H
  000ad	f3 aa		 rep stosb

; 186  :         regs->tlbID = 1;

  000af	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	c7 80 58 b0 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+45144], 1
$LN6@s390_do_pu:

; 187  :     }
; 188  : }

  000be	48 83 c4 10	 add	 rsp, 16
  000c2	5f		 pop	 rdi
  000c3	c3		 ret	 0
s390_do_purge_tlb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv79 = 0
regs$ = 32
s370_do_purge_tlb PROC

; 180  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16
$LN4@s370_do_pu:

; 181  :     INVALIDATE_AIA( regs );

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0000f	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00017	74 47		 je	 SHORT $LN5@s370_do_pu
  00019	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0001e	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00024	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00029	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  0002e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00035	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00039	48 2b ca	 sub	 rcx, rdx
  0003c	48 03 c1	 add	 rax, rcx
  0003f	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00045	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00055	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN5@s370_do_pu:
  00060	33 c0		 xor	 eax, eax
  00062	85 c0		 test	 eax, eax
  00064	75 a4		 jne	 SHORT $LN4@s370_do_pu

; 182  : 
; 183  :     if (((++regs->tlbID) & TLBID_BYTEMASK) == 0)

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0006b	8b 80 58 b0 00
	00		 mov	 eax, DWORD PTR [rax+45144]
  00071	ff c0		 inc	 eax
  00073	89 04 24	 mov	 DWORD PTR tv79[rsp], eax
  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0007b	8b 0c 24	 mov	 ecx, DWORD PTR tv79[rsp]
  0007e	89 88 58 b0 00
	00		 mov	 DWORD PTR [rax+45144], ecx
  00084	8b 04 24	 mov	 eax, DWORD PTR tv79[rsp]
  00087	25 ff ff 1f 00	 and	 eax, 2097151		; 001fffffH
  0008c	85 c0		 test	 eax, eax
  0008e	75 26		 jne	 SHORT $LN6@s370_do_pu

; 184  :     {
; 185  :         memset( &regs->tlb.vaddr, 0, TLBN * sizeof( DW ));

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00095	48 05 60 d0 00
	00		 add	 rax, 53344		; 0000d060H
  0009b	48 8b f8	 mov	 rdi, rax
  0009e	33 c0		 xor	 eax, eax
  000a0	b9 00 20 00 00	 mov	 ecx, 8192		; 00002000H
  000a5	f3 aa		 rep stosb

; 186  :         regs->tlbID = 1;

  000a7	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	c7 80 58 b0 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+45144], 1
$LN6@s370_do_pu:

; 187  :     }
; 188  : }

  000b6	48 83 c4 10	 add	 rsp, 16
  000ba	5f		 pop	 rdi
  000bb	c3		 ret	 0
s370_do_purge_tlb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
z900_set_guest_aea_common PROC

; 102  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 103  :     switch (GUESTREGS->arch_mode)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00015	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00018	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00021	74 10		 je	 SHORT $LN7@z900_set_g
  00023	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00028	74 1c		 je	 SHORT $LN8@z900_set_g
  0002a	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  0002f	74 28		 je	 SHORT $LN9@z900_set_g
  00031	eb 39		 jmp	 SHORT $LN10@z900_set_g
$LN7@z900_set_g:

; 104  :     {
; 105  :     case ARCH_370_IDX: s370_set_aea_common( GUESTREGS ); break;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00038	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0003f	e8 00 00 00 00	 call	 s370_set_aea_common
  00044	eb 3d		 jmp	 SHORT $LN2@z900_set_g
$LN8@z900_set_g:

; 106  :     case ARCH_390_IDX: s390_set_aea_common( GUESTREGS ); break;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00052	e8 00 00 00 00	 call	 s390_set_aea_common
  00057	eb 2a		 jmp	 SHORT $LN2@z900_set_g
$LN9@z900_set_g:

; 107  :     case ARCH_900_IDX: z900_set_aea_common( GUESTREGS ); break;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00065	e8 00 00 00 00	 call	 z900_set_aea_common
  0006a	eb 17		 jmp	 SHORT $LN2@z900_set_g
$LN10@z900_set_g:
$LN6@z900_set_g:

; 108  :     default: CRASH();

  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0007a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 e9		 jne	 SHORT $LN6@z900_set_g
$LN2@z900_set_g:

; 109  :     }
; 110  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
z900_set_guest_aea_common ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
s390_set_guest_aea_common PROC

; 102  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 103  :     switch (GUESTREGS->arch_mode)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00015	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00018	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00021	74 10		 je	 SHORT $LN7@s390_set_g
  00023	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00028	74 1c		 je	 SHORT $LN8@s390_set_g
  0002a	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  0002f	74 28		 je	 SHORT $LN9@s390_set_g
  00031	eb 39		 jmp	 SHORT $LN10@s390_set_g
$LN7@s390_set_g:

; 104  :     {
; 105  :     case ARCH_370_IDX: s370_set_aea_common( GUESTREGS ); break;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00038	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0003f	e8 00 00 00 00	 call	 s370_set_aea_common
  00044	eb 3d		 jmp	 SHORT $LN2@s390_set_g
$LN8@s390_set_g:

; 106  :     case ARCH_390_IDX: s390_set_aea_common( GUESTREGS ); break;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00052	e8 00 00 00 00	 call	 s390_set_aea_common
  00057	eb 2a		 jmp	 SHORT $LN2@s390_set_g
$LN9@s390_set_g:

; 107  :     case ARCH_900_IDX: z900_set_aea_common( GUESTREGS ); break;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00065	e8 00 00 00 00	 call	 z900_set_aea_common
  0006a	eb 17		 jmp	 SHORT $LN2@s390_set_g
$LN10@s390_set_g:
$LN6@s390_set_g:

; 108  :     default: CRASH();

  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0007a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 e9		 jne	 SHORT $LN6@s390_set_g
$LN2@s390_set_g:

; 109  :     }
; 110  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
s390_set_guest_aea_common ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
s370_set_guest_aea_common PROC

; 102  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 103  :     switch (GUESTREGS->arch_mode)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00015	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00018	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00021	74 10		 je	 SHORT $LN7@s370_set_g
  00023	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00028	74 1c		 je	 SHORT $LN8@s370_set_g
  0002a	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  0002f	74 28		 je	 SHORT $LN9@s370_set_g
  00031	eb 39		 jmp	 SHORT $LN10@s370_set_g
$LN7@s370_set_g:

; 104  :     {
; 105  :     case ARCH_370_IDX: s370_set_aea_common( GUESTREGS ); break;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00038	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0003f	e8 00 00 00 00	 call	 s370_set_aea_common
  00044	eb 3d		 jmp	 SHORT $LN2@s370_set_g
$LN8@s370_set_g:

; 106  :     case ARCH_390_IDX: s390_set_aea_common( GUESTREGS ); break;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00052	e8 00 00 00 00	 call	 s390_set_aea_common
  00057	eb 2a		 jmp	 SHORT $LN2@s370_set_g
$LN9@s370_set_g:

; 107  :     case ARCH_900_IDX: z900_set_aea_common( GUESTREGS ); break;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00065	e8 00 00 00 00	 call	 z900_set_aea_common
  0006a	eb 17		 jmp	 SHORT $LN2@s370_set_g
$LN10@s370_set_g:
$LN6@s370_set_g:

; 108  :     default: CRASH();

  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0007a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 e9		 jne	 SHORT $LN6@s370_set_g
$LN2@s370_set_g:

; 109  :     }
; 110  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
s370_set_guest_aea_common ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv73 = 0
tv84 = 4
tv95 = 8
regs$ = 32
z900_set_aea_common PROC

; 94   : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24
$LN4@z900_set_a:

; 95   :     SET_AEA_COMMON( regs );

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 02	 imul	 rax, rax, 2
  00012	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0001f	48 25 20 01 00
	00		 and	 rax, 288		; 00000120H
  00025	48 85 c0	 test	 rax, rax
  00028	75 09		 jne	 SHORT $LN6@z900_set_a
  0002a	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv73[rsp], 1
  00031	eb 07		 jmp	 SHORT $LN7@z900_set_a
$LN6@z900_set_a:
  00033	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv73[rsp], 0
$LN7@z900_set_a:
  0003a	b8 01 00 00 00	 mov	 eax, 1
  0003f	48 6b c0 02	 imul	 rax, rax, 2
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	0f b6 14 24	 movzx	 edx, BYTE PTR tv73[rsp]
  0004c	88 94 01 e8 0c
	00 00		 mov	 BYTE PTR [rcx+rax+3304], dl
  00053	b8 08 00 00 00	 mov	 eax, 8
  00058	48 6b c0 08	 imul	 rax, rax, 8
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00069	48 25 20 01 00
	00		 and	 rax, 288		; 00000120H
  0006f	48 85 c0	 test	 rax, rax
  00072	75 0a		 jne	 SHORT $LN8@z900_set_a
  00074	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  0007c	eb 08		 jmp	 SHORT $LN9@z900_set_a
$LN8@z900_set_a:
  0007e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN9@z900_set_a:
  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	48 6b c0 08	 imul	 rax, rax, 8
  0008f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00094	0f b6 54 24 04	 movzx	 edx, BYTE PTR tv84[rsp]
  00099	88 94 01 e8 0c
	00 00		 mov	 BYTE PTR [rcx+rax+3304], dl
  000a0	b8 08 00 00 00	 mov	 eax, 8
  000a5	48 6b c0 0e	 imul	 rax, rax, 14
  000a9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000b6	48 25 20 01 00
	00		 and	 rax, 288		; 00000120H
  000bc	48 85 c0	 test	 rax, rax
  000bf	75 0a		 jne	 SHORT $LN10@z900_set_a
  000c1	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv95[rsp], 1
  000c9	eb 08		 jmp	 SHORT $LN11@z900_set_a
$LN10@z900_set_a:
  000cb	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN11@z900_set_a:
  000d3	b8 01 00 00 00	 mov	 eax, 1
  000d8	48 6b c0 0e	 imul	 rax, rax, 14
  000dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	0f b6 54 24 08	 movzx	 edx, BYTE PTR tv95[rsp]
  000e6	88 94 01 e8 0c
	00 00		 mov	 BYTE PTR [rcx+rax+3304], dl
  000ed	33 c0		 xor	 eax, eax
  000ef	85 c0		 test	 eax, eax
  000f1	0f 85 12 ff ff
	ff		 jne	 $LN4@z900_set_a

; 96   : }

  000f7	48 83 c4 18	 add	 rsp, 24
  000fb	c3		 ret	 0
z900_set_aea_common ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv73 = 0
tv84 = 4
tv95 = 8
regs$ = 32
s390_set_aea_common PROC

; 94   : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24
$LN4@s390_set_a:

; 95   :     SET_AEA_COMMON( regs );

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 02	 imul	 rax, rax, 2
  00012	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00023	85 c0		 test	 eax, eax
  00025	75 09		 jne	 SHORT $LN6@s390_set_a
  00027	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv73[rsp], 1
  0002e	eb 07		 jmp	 SHORT $LN7@s390_set_a
$LN6@s390_set_a:
  00030	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv73[rsp], 0
$LN7@s390_set_a:
  00037	b8 01 00 00 00	 mov	 eax, 1
  0003c	48 6b c0 02	 imul	 rax, rax, 2
  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 14 24	 movzx	 edx, BYTE PTR tv73[rsp]
  00049	88 94 01 e8 0c
	00 00		 mov	 BYTE PTR [rcx+rax+3304], dl
  00050	b8 08 00 00 00	 mov	 eax, 8
  00055	48 6b c0 08	 imul	 rax, rax, 8
  00059	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00065	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0006a	85 c0		 test	 eax, eax
  0006c	75 0a		 jne	 SHORT $LN8@s390_set_a
  0006e	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  00076	eb 08		 jmp	 SHORT $LN9@s390_set_a
$LN8@s390_set_a:
  00078	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN9@s390_set_a:
  00080	b8 01 00 00 00	 mov	 eax, 1
  00085	48 6b c0 08	 imul	 rax, rax, 8
  00089	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	0f b6 54 24 04	 movzx	 edx, BYTE PTR tv84[rsp]
  00093	88 94 01 e8 0c
	00 00		 mov	 BYTE PTR [rcx+rax+3304], dl
  0009a	b8 08 00 00 00	 mov	 eax, 8
  0009f	48 6b c0 0e	 imul	 rax, rax, 14
  000a3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000af	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000b4	85 c0		 test	 eax, eax
  000b6	75 0a		 jne	 SHORT $LN10@s390_set_a
  000b8	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv95[rsp], 1
  000c0	eb 08		 jmp	 SHORT $LN11@s390_set_a
$LN10@s390_set_a:
  000c2	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN11@s390_set_a:
  000ca	b8 01 00 00 00	 mov	 eax, 1
  000cf	48 6b c0 0e	 imul	 rax, rax, 14
  000d3	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	0f b6 54 24 08	 movzx	 edx, BYTE PTR tv95[rsp]
  000dd	88 94 01 e8 0c
	00 00		 mov	 BYTE PTR [rcx+rax+3304], dl
  000e4	33 c0		 xor	 eax, eax
  000e6	85 c0		 test	 eax, eax
  000e8	0f 85 1b ff ff
	ff		 jne	 $LN4@s390_set_a

; 96   : }

  000ee	48 83 c4 18	 add	 rsp, 24
  000f2	c3		 ret	 0
s390_set_aea_common ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv73 = 0
tv84 = 4
regs$ = 32
s370_set_aea_common PROC

; 94   : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24
$LN4@s370_set_a:

; 95   :     SET_AEA_COMMON( regs );

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 02	 imul	 rax, rax, 2
  00012	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	83 e0 02	 and	 eax, 2
  00021	85 c0		 test	 eax, eax
  00023	75 09		 jne	 SHORT $LN6@s370_set_a
  00025	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv73[rsp], 1
  0002c	eb 07		 jmp	 SHORT $LN7@s370_set_a
$LN6@s370_set_a:
  0002e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv73[rsp], 0
$LN7@s370_set_a:
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 02	 imul	 rax, rax, 2
  0003e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00043	0f b6 14 24	 movzx	 edx, BYTE PTR tv73[rsp]
  00047	88 94 01 e8 0c
	00 00		 mov	 BYTE PTR [rcx+rax+3304], dl
  0004e	b8 08 00 00 00	 mov	 eax, 8
  00053	48 6b c0 08	 imul	 rax, rax, 8
  00057	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00063	83 e0 02	 and	 eax, 2
  00066	85 c0		 test	 eax, eax
  00068	75 0a		 jne	 SHORT $LN8@s370_set_a
  0006a	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  00072	eb 08		 jmp	 SHORT $LN9@s370_set_a
$LN8@s370_set_a:
  00074	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN9@s370_set_a:
  0007c	b8 01 00 00 00	 mov	 eax, 1
  00081	48 6b c0 08	 imul	 rax, rax, 8
  00085	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0008a	0f b6 54 24 04	 movzx	 edx, BYTE PTR tv84[rsp]
  0008f	88 94 01 e8 0c
	00 00		 mov	 BYTE PTR [rcx+rax+3304], dl
  00096	33 c0		 xor	 eax, eax
  00098	85 c0		 test	 eax, eax
  0009a	0f 85 69 ff ff
	ff		 jne	 $LN4@s370_set_a

; 96   : }

  000a0	48 83 c4 18	 add	 rsp, 24
  000a4	c3		 ret	 0
s370_set_aea_common ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
z900_set_guest_aea_mode PROC

; 166  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 167  :     switch (GUESTREGS->arch_mode)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00015	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00018	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00021	74 10		 je	 SHORT $LN7@z900_set_g
  00023	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00028	74 1c		 je	 SHORT $LN8@z900_set_g
  0002a	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  0002f	74 28		 je	 SHORT $LN9@z900_set_g
  00031	eb 39		 jmp	 SHORT $LN10@z900_set_g
$LN7@z900_set_g:

; 168  :     {
; 169  :     case ARCH_370_IDX: s370_set_aea_mode( GUESTREGS ); break;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00038	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0003f	e8 00 00 00 00	 call	 s370_set_aea_mode
  00044	eb 3d		 jmp	 SHORT $LN2@z900_set_g
$LN8@z900_set_g:

; 170  :     case ARCH_390_IDX: s390_set_aea_mode( GUESTREGS ); break;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00052	e8 00 00 00 00	 call	 s390_set_aea_mode
  00057	eb 2a		 jmp	 SHORT $LN2@z900_set_g
$LN9@z900_set_g:

; 171  :     case ARCH_900_IDX: z900_set_aea_mode( GUESTREGS ); break;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00065	e8 00 00 00 00	 call	 z900_set_aea_mode
  0006a	eb 17		 jmp	 SHORT $LN2@z900_set_g
$LN10@z900_set_g:
$LN6@z900_set_g:

; 172  :     default: CRASH();

  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0007a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 e9		 jne	 SHORT $LN6@z900_set_g
$LN2@z900_set_g:

; 173  :     }
; 174  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
z900_set_guest_aea_mode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
s390_set_guest_aea_mode PROC

; 166  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 167  :     switch (GUESTREGS->arch_mode)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00015	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00018	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00021	74 10		 je	 SHORT $LN7@s390_set_g
  00023	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00028	74 1c		 je	 SHORT $LN8@s390_set_g
  0002a	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  0002f	74 28		 je	 SHORT $LN9@s390_set_g
  00031	eb 39		 jmp	 SHORT $LN10@s390_set_g
$LN7@s390_set_g:

; 168  :     {
; 169  :     case ARCH_370_IDX: s370_set_aea_mode( GUESTREGS ); break;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00038	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0003f	e8 00 00 00 00	 call	 s370_set_aea_mode
  00044	eb 3d		 jmp	 SHORT $LN2@s390_set_g
$LN8@s390_set_g:

; 170  :     case ARCH_390_IDX: s390_set_aea_mode( GUESTREGS ); break;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00052	e8 00 00 00 00	 call	 s390_set_aea_mode
  00057	eb 2a		 jmp	 SHORT $LN2@s390_set_g
$LN9@s390_set_g:

; 171  :     case ARCH_900_IDX: z900_set_aea_mode( GUESTREGS ); break;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00065	e8 00 00 00 00	 call	 z900_set_aea_mode
  0006a	eb 17		 jmp	 SHORT $LN2@s390_set_g
$LN10@s390_set_g:
$LN6@s390_set_g:

; 172  :     default: CRASH();

  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0007a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 e9		 jne	 SHORT $LN6@s390_set_g
$LN2@s390_set_g:

; 173  :     }
; 174  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
s390_set_guest_aea_mode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
s370_set_guest_aea_mode PROC

; 166  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 167  :     switch (GUESTREGS->arch_mode)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00015	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00018	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00021	74 10		 je	 SHORT $LN7@s370_set_g
  00023	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00028	74 1c		 je	 SHORT $LN8@s370_set_g
  0002a	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  0002f	74 28		 je	 SHORT $LN9@s370_set_g
  00031	eb 39		 jmp	 SHORT $LN10@s370_set_g
$LN7@s370_set_g:

; 168  :     {
; 169  :     case ARCH_370_IDX: s370_set_aea_mode( GUESTREGS ); break;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00038	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0003f	e8 00 00 00 00	 call	 s370_set_aea_mode
  00044	eb 3d		 jmp	 SHORT $LN2@s370_set_g
$LN8@s370_set_g:

; 170  :     case ARCH_390_IDX: s390_set_aea_mode( GUESTREGS ); break;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00052	e8 00 00 00 00	 call	 s390_set_aea_mode
  00057	eb 2a		 jmp	 SHORT $LN2@s370_set_g
$LN9@s370_set_g:

; 171  :     case ARCH_900_IDX: z900_set_aea_mode( GUESTREGS ); break;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00065	e8 00 00 00 00	 call	 z900_set_aea_mode
  0006a	eb 17		 jmp	 SHORT $LN2@s370_set_g
$LN10@s370_set_g:
$LN6@s370_set_g:

; 172  :     default: CRASH();

  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0007a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 e9		 jne	 SHORT $LN6@s370_set_g
$LN2@s370_set_g:

; 173  :     }
; 174  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
s370_set_guest_aea_mode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
z900_set_guest_ic_mask PROC

; 152  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 153  :     switch (GUESTREGS->arch_mode)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00015	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00018	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00021	74 10		 je	 SHORT $LN7@z900_set_g
  00023	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00028	74 1c		 je	 SHORT $LN8@z900_set_g
  0002a	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  0002f	74 28		 je	 SHORT $LN9@z900_set_g
  00031	eb 39		 jmp	 SHORT $LN10@z900_set_g
$LN7@z900_set_g:

; 154  :     {
; 155  :     case ARCH_370_IDX: s370_set_ic_mask( GUESTREGS ); break;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00038	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0003f	e8 00 00 00 00	 call	 s370_set_ic_mask
  00044	eb 3d		 jmp	 SHORT $LN2@z900_set_g
$LN8@z900_set_g:

; 156  :     case ARCH_390_IDX: s390_set_ic_mask( GUESTREGS ); break;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00052	e8 00 00 00 00	 call	 s390_set_ic_mask
  00057	eb 2a		 jmp	 SHORT $LN2@z900_set_g
$LN9@z900_set_g:

; 157  :     case ARCH_900_IDX: z900_set_ic_mask( GUESTREGS ); break;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00065	e8 00 00 00 00	 call	 z900_set_ic_mask
  0006a	eb 17		 jmp	 SHORT $LN2@z900_set_g
$LN10@z900_set_g:
$LN6@z900_set_g:

; 158  :     default: CRASH();

  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0007a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 e9		 jne	 SHORT $LN6@z900_set_g
$LN2@z900_set_g:

; 159  :     }
; 160  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
z900_set_guest_ic_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
s390_set_guest_ic_mask PROC

; 152  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 153  :     switch (GUESTREGS->arch_mode)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00015	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00018	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00021	74 10		 je	 SHORT $LN7@s390_set_g
  00023	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00028	74 1c		 je	 SHORT $LN8@s390_set_g
  0002a	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  0002f	74 28		 je	 SHORT $LN9@s390_set_g
  00031	eb 39		 jmp	 SHORT $LN10@s390_set_g
$LN7@s390_set_g:

; 154  :     {
; 155  :     case ARCH_370_IDX: s370_set_ic_mask( GUESTREGS ); break;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00038	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0003f	e8 00 00 00 00	 call	 s370_set_ic_mask
  00044	eb 3d		 jmp	 SHORT $LN2@s390_set_g
$LN8@s390_set_g:

; 156  :     case ARCH_390_IDX: s390_set_ic_mask( GUESTREGS ); break;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00052	e8 00 00 00 00	 call	 s390_set_ic_mask
  00057	eb 2a		 jmp	 SHORT $LN2@s390_set_g
$LN9@s390_set_g:

; 157  :     case ARCH_900_IDX: z900_set_ic_mask( GUESTREGS ); break;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00065	e8 00 00 00 00	 call	 z900_set_ic_mask
  0006a	eb 17		 jmp	 SHORT $LN2@s390_set_g
$LN10@s390_set_g:
$LN6@s390_set_g:

; 158  :     default: CRASH();

  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0007a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 e9		 jne	 SHORT $LN6@s390_set_g
$LN2@s390_set_g:

; 159  :     }
; 160  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
s390_set_guest_ic_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
s370_set_guest_ic_mask PROC

; 152  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 153  :     switch (GUESTREGS->arch_mode)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00015	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00018	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00021	74 10		 je	 SHORT $LN7@s370_set_g
  00023	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00028	74 1c		 je	 SHORT $LN8@s370_set_g
  0002a	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  0002f	74 28		 je	 SHORT $LN9@s370_set_g
  00031	eb 39		 jmp	 SHORT $LN10@s370_set_g
$LN7@s370_set_g:

; 154  :     {
; 155  :     case ARCH_370_IDX: s370_set_ic_mask( GUESTREGS ); break;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00038	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0003f	e8 00 00 00 00	 call	 s370_set_ic_mask
  00044	eb 3d		 jmp	 SHORT $LN2@s370_set_g
$LN8@s370_set_g:

; 156  :     case ARCH_390_IDX: s390_set_ic_mask( GUESTREGS ); break;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00052	e8 00 00 00 00	 call	 s390_set_ic_mask
  00057	eb 2a		 jmp	 SHORT $LN2@s370_set_g
$LN9@s370_set_g:

; 157  :     case ARCH_900_IDX: z900_set_ic_mask( GUESTREGS ); break;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00065	e8 00 00 00 00	 call	 z900_set_ic_mask
  0006a	eb 17		 jmp	 SHORT $LN2@s370_set_g
$LN10@s370_set_g:
$LN6@s370_set_g:

; 158  :     default: CRASH();

  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0007a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 e9		 jne	 SHORT $LN6@s370_set_g
$LN2@s370_set_g:

; 159  :     }
; 160  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
s370_set_guest_ic_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
z900_invalidate_guest_aia PROC

; 138  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 139  :     switch (GUESTREGS->arch_mode)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00015	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00018	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00021	74 10		 je	 SHORT $LN7@z900_inval
  00023	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00028	74 1c		 je	 SHORT $LN8@z900_inval
  0002a	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  0002f	74 28		 je	 SHORT $LN9@z900_inval
  00031	eb 39		 jmp	 SHORT $LN10@z900_inval
$LN7@z900_inval:

; 140  :     {
; 141  :     case ARCH_370_IDX: s370_invalidate_aia( GUESTREGS ); break;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00038	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0003f	e8 00 00 00 00	 call	 s370_invalidate_aia
  00044	eb 3d		 jmp	 SHORT $LN2@z900_inval
$LN8@z900_inval:

; 142  :     case ARCH_390_IDX: s390_invalidate_aia( GUESTREGS ); break;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00052	e8 00 00 00 00	 call	 s390_invalidate_aia
  00057	eb 2a		 jmp	 SHORT $LN2@z900_inval
$LN9@z900_inval:

; 143  :     case ARCH_900_IDX: z900_invalidate_aia( GUESTREGS ); break;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00065	e8 00 00 00 00	 call	 z900_invalidate_aia
  0006a	eb 17		 jmp	 SHORT $LN2@z900_inval
$LN10@z900_inval:
$LN6@z900_inval:

; 144  :     default: CRASH();

  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0007a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 e9		 jne	 SHORT $LN6@z900_inval
$LN2@z900_inval:

; 145  :     }
; 146  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
z900_invalidate_guest_aia ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
s390_invalidate_guest_aia PROC

; 138  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 139  :     switch (GUESTREGS->arch_mode)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00015	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00018	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00021	74 10		 je	 SHORT $LN7@s390_inval
  00023	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00028	74 1c		 je	 SHORT $LN8@s390_inval
  0002a	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  0002f	74 28		 je	 SHORT $LN9@s390_inval
  00031	eb 39		 jmp	 SHORT $LN10@s390_inval
$LN7@s390_inval:

; 140  :     {
; 141  :     case ARCH_370_IDX: s370_invalidate_aia( GUESTREGS ); break;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00038	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0003f	e8 00 00 00 00	 call	 s370_invalidate_aia
  00044	eb 3d		 jmp	 SHORT $LN2@s390_inval
$LN8@s390_inval:

; 142  :     case ARCH_390_IDX: s390_invalidate_aia( GUESTREGS ); break;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00052	e8 00 00 00 00	 call	 s390_invalidate_aia
  00057	eb 2a		 jmp	 SHORT $LN2@s390_inval
$LN9@s390_inval:

; 143  :     case ARCH_900_IDX: z900_invalidate_aia( GUESTREGS ); break;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00065	e8 00 00 00 00	 call	 z900_invalidate_aia
  0006a	eb 17		 jmp	 SHORT $LN2@s390_inval
$LN10@s390_inval:
$LN6@s390_inval:

; 144  :     default: CRASH();

  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0007a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 e9		 jne	 SHORT $LN6@s390_inval
$LN2@s390_inval:

; 145  :     }
; 146  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
s390_invalidate_guest_aia ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv66 = 32
p$1 = 40
regs$ = 64
s370_invalidate_guest_aia PROC

; 138  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 139  :     switch (GUESTREGS->arch_mode)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00015	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00018	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  0001c	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  00021	74 10		 je	 SHORT $LN7@s370_inval
  00023	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00028	74 1c		 je	 SHORT $LN8@s370_inval
  0002a	83 7c 24 20 02	 cmp	 DWORD PTR tv66[rsp], 2
  0002f	74 28		 je	 SHORT $LN9@s370_inval
  00031	eb 39		 jmp	 SHORT $LN10@s370_inval
$LN7@s370_inval:

; 140  :     {
; 141  :     case ARCH_370_IDX: s370_invalidate_aia( GUESTREGS ); break;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00038	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0003f	e8 00 00 00 00	 call	 s370_invalidate_aia
  00044	eb 3d		 jmp	 SHORT $LN2@s370_inval
$LN8@s370_inval:

; 142  :     case ARCH_390_IDX: s390_invalidate_aia( GUESTREGS ); break;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00052	e8 00 00 00 00	 call	 s390_invalidate_aia
  00057	eb 2a		 jmp	 SHORT $LN2@s370_inval
$LN9@s370_inval:

; 143  :     case ARCH_900_IDX: z900_invalidate_aia( GUESTREGS ); break;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00065	e8 00 00 00 00	 call	 z900_invalidate_aia
  0006a	eb 17		 jmp	 SHORT $LN2@s370_inval
$LN10@s370_inval:
$LN6@s370_inval:

; 144  :     default: CRASH();

  0006c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00075	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0007a	c6 00 00	 mov	 BYTE PTR [rax], 0
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 e9		 jne	 SHORT $LN6@s370_inval
$LN2@s370_inval:

; 145  :     }
; 146  : }

  00083	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00087	c3		 ret	 0
s370_invalidate_guest_aia ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
oldmode$1 = 32
i$2 = 36
tv144 = 40
tv86 = 44
tv138 = 48
tv91 = 52
tv254 = 56
inst_cr$3 = 60
regs$ = 80
z900_set_aea_mode PROC

; 130  : {

$LN56:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900_set_a:

; 131  :     SET_AEA_MODE( regs );

  00009	b8 04 00 00 00	 mov	 eax, 4
  0000e	48 6b c0 04	 imul	 rax, rax, 4
  00012	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  0001e	89 44 24 3c	 mov	 DWORD PTR inst_cr$3[rsp], eax
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00027	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  0002e	88 44 24 20	 mov	 BYTE PTR oldmode$1[rsp], al
  00032	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00037	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0003b	83 e0 04	 and	 eax, 4
  0003e	85 c0		 test	 eax, eax
  00040	75 57		 jne	 SHORT $LN47@z900_set_a
  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00047	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0004d	d1 e8		 shr	 eax, 1
  0004f	83 e0 01	 and	 eax, 1
  00052	85 c0		 test	 eax, eax
  00054	74 31		 je	 SHORT $LN45@z900_set_a
  00056	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0005b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00062	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00066	83 e0 01	 and	 eax, 1
  00069	85 c0		 test	 eax, eax
  0006b	74 1a		 je	 SHORT $LN45@z900_set_a
  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00072	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00076	83 e0 40	 and	 eax, 64			; 00000040H
  00079	85 c0		 test	 eax, eax
  0007b	74 0a		 je	 SHORT $LN45@z900_set_a
  0007d	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv86[rsp], 2
  00085	eb 08		 jmp	 SHORT $LN46@z900_set_a
$LN45@z900_set_a:
  00087	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN46@z900_set_a:
  0008f	8b 44 24 2c	 mov	 eax, DWORD PTR tv86[rsp]
  00093	89 44 24 34	 mov	 DWORD PTR tv91[rsp], eax
  00097	eb 12		 jmp	 SHORT $LN48@z900_set_a
$LN47@z900_set_a:
  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  000a2	c1 f8 06	 sar	 eax, 6
  000a5	ff c0		 inc	 eax
  000a7	89 44 24 34	 mov	 DWORD PTR tv91[rsp], eax
$LN48@z900_set_a:
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 45		 jne	 SHORT $LN49@z900_set_a
  000b1	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  000ba	83 e0 40	 and	 eax, 64			; 00000040H
  000bd	85 c0		 test	 eax, eax
  000bf	75 35		 jne	 SHORT $LN49@z900_set_a
  000c1	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000cc	d1 e8		 shr	 eax, 1
  000ce	83 e0 01	 and	 eax, 1
  000d1	85 c0		 test	 eax, eax
  000d3	74 17		 je	 SHORT $LN50@z900_set_a
  000d5	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000e1	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000e5	83 e0 01	 and	 eax, 1
  000e8	85 c0		 test	 eax, eax
  000ea	75 0a		 jne	 SHORT $LN49@z900_set_a
$LN50@z900_set_a:
  000ec	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
  000f4	eb 08		 jmp	 SHORT $LN51@z900_set_a
$LN49@z900_set_a:
  000f6	c7 44 24 30 40
	00 00 00	 mov	 DWORD PTR tv138[rsp], 64 ; 00000040H
$LN51@z900_set_a:
  000fe	8b 44 24 30	 mov	 eax, DWORD PTR tv138[rsp]
  00102	8b 4c 24 34	 mov	 ecx, DWORD PTR tv91[rsp]
  00106	0b c8		 or	 ecx, eax
  00108	8b c1		 mov	 eax, ecx
  0010a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	88 81 90 0c 00
	00		 mov	 BYTE PTR [rcx+3216], al
  00115	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00121	83 e0 0f	 and	 eax, 15
  00124	89 44 24 28	 mov	 DWORD PTR tv144[rsp], eax
  00128	83 7c 24 28 01	 cmp	 DWORD PTR tv144[rsp], 1
  0012d	74 22		 je	 SHORT $LN31@z900_set_a
  0012f	83 7c 24 28 02	 cmp	 DWORD PTR tv144[rsp], 2
  00134	74 56		 je	 SHORT $LN32@z900_set_a
  00136	83 7c 24 28 03	 cmp	 DWORD PTR tv144[rsp], 3
  0013b	0f 84 ff 00 00
	00		 je	 $LN36@z900_set_a
  00141	83 7c 24 28 04	 cmp	 DWORD PTR tv144[rsp], 4
  00146	0f 84 45 01 00
	00		 je	 $LN37@z900_set_a
  0014c	e9 78 01 00 00	 jmp	 $LN38@z900_set_a
$LN31@z900_set_a:
  00151	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR i$2[rsp], -1
  00159	eb 0a		 jmp	 SHORT $LN9@z900_set_a
$LN7@z900_set_a:
  0015b	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  0015f	ff c0		 inc	 eax
  00161	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN9@z900_set_a:
  00165	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  0016a	7d 1b		 jge	 SHORT $LN8@z900_set_a
  0016c	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  00170	83 c0 05	 add	 eax, 5
  00173	48 98		 cdqe
  00175	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0017a	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00185	eb d4		 jmp	 SHORT $LN7@z900_set_a
$LN8@z900_set_a:
  00187	e9 73 01 00 00	 jmp	 $LN5@z900_set_a
$LN32@z900_set_a:
  0018c	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR i$2[rsp], -1
  00194	eb 0a		 jmp	 SHORT $LN12@z900_set_a
$LN10@z900_set_a:
  00196	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  0019a	ff c0		 inc	 eax
  0019c	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN12@z900_set_a:
  001a0	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  001a5	7d 1b		 jge	 SHORT $LN11@z900_set_a
  001a7	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  001ab	83 c0 05	 add	 eax, 5
  001ae	48 98		 cdqe
  001b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  001c0	eb d4		 jmp	 SHORT $LN10@z900_set_a
$LN11@z900_set_a:
  001c2	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR i$2[rsp], 1
  001ca	eb 0a		 jmp	 SHORT $LN15@z900_set_a
$LN13@z900_set_a:
  001cc	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  001d0	ff c0		 inc	 eax
  001d2	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN15@z900_set_a:
  001d6	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  001db	7d 5e		 jge	 SHORT $LN14@z900_set_a
  001dd	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$2[rsp]
  001e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  001ef	75 1b		 jne	 SHORT $LN33@z900_set_a
  001f1	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  001f5	83 c0 05	 add	 eax, 5
  001f8	48 98		 cdqe
  001fa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001ff	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0020a	eb 2d		 jmp	 SHORT $LN34@z900_set_a
$LN33@z900_set_a:
  0020c	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$2[rsp]
  00211	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00216	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0021e	74 19		 je	 SHORT $LN35@z900_set_a
  00220	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  00224	83 c0 05	 add	 eax, 5
  00227	48 98		 cdqe
  00229	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0022e	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN35@z900_set_a:
$LN34@z900_set_a:
  00239	eb 91		 jmp	 SHORT $LN13@z900_set_a
$LN14@z900_set_a:
  0023b	e9 bf 00 00 00	 jmp	 $LN5@z900_set_a
$LN36@z900_set_a:
  00240	b8 04 00 00 00	 mov	 eax, 4
  00245	48 6b c0 04	 imul	 rax, rax, 4
  00249	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0024e	c7 84 01 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+3220], 1
  00259	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00261	eb 0a		 jmp	 SHORT $LN18@z900_set_a
$LN16@z900_set_a:
  00263	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  00267	ff c0		 inc	 eax
  00269	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN18@z900_set_a:
  0026d	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  00272	7d 1b		 jge	 SHORT $LN17@z900_set_a
  00274	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  00278	83 c0 05	 add	 eax, 5
  0027b	48 98		 cdqe
  0027d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00282	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0028d	eb d4		 jmp	 SHORT $LN16@z900_set_a
$LN17@z900_set_a:
  0028f	eb 6e		 jmp	 SHORT $LN5@z900_set_a
$LN37@z900_set_a:
  00291	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR i$2[rsp], -1
  00299	eb 0a		 jmp	 SHORT $LN21@z900_set_a
$LN19@z900_set_a:
  0029b	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  0029f	ff c0		 inc	 eax
  002a1	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN21@z900_set_a:
  002a5	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  002aa	7d 1b		 jge	 SHORT $LN20@z900_set_a
  002ac	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  002b0	83 c0 05	 add	 eax, 5
  002b3	48 98		 cdqe
  002b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  002ba	c7 84 81 94 0c
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 13
  002c5	eb d4		 jmp	 SHORT $LN19@z900_set_a
$LN20@z900_set_a:
  002c7	eb 36		 jmp	 SHORT $LN5@z900_set_a
$LN38@z900_set_a:
  002c9	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR i$2[rsp], -1
  002d1	eb 0a		 jmp	 SHORT $LN24@z900_set_a
$LN22@z900_set_a:
  002d3	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  002d7	ff c0		 inc	 eax
  002d9	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN24@z900_set_a:
  002dd	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  002e2	7d 1b		 jge	 SHORT $LN23@z900_set_a
  002e4	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  002e8	83 c0 05	 add	 eax, 5
  002eb	48 98		 cdqe
  002ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	c7 84 81 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+3220], -1
  002fd	eb d4		 jmp	 SHORT $LN22@z900_set_a
$LN23@z900_set_a:
$LN5@z900_set_a:
  002ff	b8 04 00 00 00	 mov	 eax, 4
  00304	48 6b c0 04	 imul	 rax, rax, 4
  00308	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0030d	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00314	39 44 24 3c	 cmp	 DWORD PTR inst_cr$3[rsp], eax
  00318	74 67		 je	 SHORT $LN39@z900_set_a
$LN27@z900_set_a:
  0031a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0031f	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00327	74 52		 je	 SHORT $LN40@z900_set_a
  00329	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0032e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00333	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0033a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0033e	48 2b c1	 sub	 rax, rcx
  00341	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00346	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0034d	48 03 c8	 add	 rcx, rax
  00350	48 8b c1	 mov	 rax, rcx
  00353	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00358	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0035f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00364	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  0036b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00370	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN40@z900_set_a:
  0037b	33 c0		 xor	 eax, eax
  0037d	85 c0		 test	 eax, eax
  0037f	75 99		 jne	 SHORT $LN27@z900_set_a
$LN39@z900_set_a:
  00381	0f b6 44 24 20	 movzx	 eax, BYTE PTR oldmode$1[rsp]
  00386	83 e0 40	 and	 eax, 64			; 00000040H
  00389	85 c0		 test	 eax, eax
  0038b	0f 85 c9 00 00
	00		 jne	 $LN41@z900_set_a
  00391	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00396	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  0039d	83 e0 40	 and	 eax, 64			; 00000040H
  003a0	85 c0		 test	 eax, eax
  003a2	0f 84 b2 00 00
	00		 je	 $LN41@z900_set_a
$LN30@z900_set_a:
  003a8	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  003ad	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  003b5	74 52		 je	 SHORT $LN42@z900_set_a
  003b7	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  003bc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  003c1	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  003c8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  003cc	48 2b c1	 sub	 rax, rcx
  003cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  003d4	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  003db	48 03 c8	 add	 rcx, rax
  003de	48 8b c1	 mov	 rax, rcx
  003e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  003e6	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  003f2	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  003f9	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  003fe	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN42@z900_set_a:
  00409	33 c0		 xor	 eax, eax
  0040b	85 c0		 test	 eax, eax
  0040d	75 99		 jne	 SHORT $LN30@z900_set_a
  0040f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00414	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0041a	c1 e8 02	 shr	 eax, 2
  0041d	83 e0 01	 and	 eax, 1
  00420	85 c0		 test	 eax, eax
  00422	74 0a		 je	 SHORT $LN54@z900_set_a
  00424	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv254[rsp], 1
  0042c	eb 08		 jmp	 SHORT $LN55@z900_set_a
$LN54@z900_set_a:
  0042e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv254[rsp], 0
$LN55@z900_set_a:
  00436	83 7c 24 38 00	 cmp	 DWORD PTR tv254[rsp], 0
  0043b	74 1d		 je	 SHORT $LN43@z900_set_a
  0043d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00442	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00445	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  0044a	85 c0		 test	 eax, eax
  0044c	74 0c		 je	 SHORT $LN43@z900_set_a
  0044e	b2 fc		 mov	 dl, 252			; 000000fcH
  00450	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00455	e8 00 00 00 00	 call	 z900_invalidate_tlb
$LN43@z900_set_a:
$LN41@z900_set_a:
  0045a	33 c0		 xor	 eax, eax
  0045c	85 c0		 test	 eax, eax
  0045e	0f 85 a5 fb ff
	ff		 jne	 $LN4@z900_set_a

; 132  : }

  00464	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00468	c3		 ret	 0
z900_set_aea_mode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
oldmode$1 = 32
i$2 = 36
tv144 = 40
tv86 = 44
tv138 = 48
tv91 = 52
tv260 = 56
inst_cr$3 = 60
regs$ = 80
s390_set_aea_mode PROC

; 130  : {

$LN56:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_set_a:

; 131  :     SET_AEA_MODE( regs );

  00009	b8 04 00 00 00	 mov	 eax, 4
  0000e	48 6b c0 04	 imul	 rax, rax, 4
  00012	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  0001e	89 44 24 3c	 mov	 DWORD PTR inst_cr$3[rsp], eax
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00027	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  0002e	88 44 24 20	 mov	 BYTE PTR oldmode$1[rsp], al
  00032	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00037	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0003b	83 e0 04	 and	 eax, 4
  0003e	85 c0		 test	 eax, eax
  00040	75 57		 jne	 SHORT $LN47@s390_set_a
  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00047	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0004d	d1 e8		 shr	 eax, 1
  0004f	83 e0 01	 and	 eax, 1
  00052	85 c0		 test	 eax, eax
  00054	74 31		 je	 SHORT $LN45@s390_set_a
  00056	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0005b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00062	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00066	83 e0 01	 and	 eax, 1
  00069	85 c0		 test	 eax, eax
  0006b	74 1a		 je	 SHORT $LN45@s390_set_a
  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00072	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00076	83 e0 40	 and	 eax, 64			; 00000040H
  00079	85 c0		 test	 eax, eax
  0007b	74 0a		 je	 SHORT $LN45@s390_set_a
  0007d	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv86[rsp], 2
  00085	eb 08		 jmp	 SHORT $LN46@s390_set_a
$LN45@s390_set_a:
  00087	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN46@s390_set_a:
  0008f	8b 44 24 2c	 mov	 eax, DWORD PTR tv86[rsp]
  00093	89 44 24 34	 mov	 DWORD PTR tv91[rsp], eax
  00097	eb 12		 jmp	 SHORT $LN48@s390_set_a
$LN47@s390_set_a:
  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  000a2	c1 f8 06	 sar	 eax, 6
  000a5	ff c0		 inc	 eax
  000a7	89 44 24 34	 mov	 DWORD PTR tv91[rsp], eax
$LN48@s390_set_a:
  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 45		 jne	 SHORT $LN49@s390_set_a
  000b1	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  000ba	83 e0 40	 and	 eax, 64			; 00000040H
  000bd	85 c0		 test	 eax, eax
  000bf	75 35		 jne	 SHORT $LN49@s390_set_a
  000c1	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000cc	d1 e8		 shr	 eax, 1
  000ce	83 e0 01	 and	 eax, 1
  000d1	85 c0		 test	 eax, eax
  000d3	74 17		 je	 SHORT $LN50@s390_set_a
  000d5	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000e1	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000e5	83 e0 01	 and	 eax, 1
  000e8	85 c0		 test	 eax, eax
  000ea	75 0a		 jne	 SHORT $LN49@s390_set_a
$LN50@s390_set_a:
  000ec	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
  000f4	eb 08		 jmp	 SHORT $LN51@s390_set_a
$LN49@s390_set_a:
  000f6	c7 44 24 30 40
	00 00 00	 mov	 DWORD PTR tv138[rsp], 64 ; 00000040H
$LN51@s390_set_a:
  000fe	8b 44 24 30	 mov	 eax, DWORD PTR tv138[rsp]
  00102	8b 4c 24 34	 mov	 ecx, DWORD PTR tv91[rsp]
  00106	0b c8		 or	 ecx, eax
  00108	8b c1		 mov	 eax, ecx
  0010a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	88 81 90 0c 00
	00		 mov	 BYTE PTR [rcx+3216], al
  00115	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00121	83 e0 0f	 and	 eax, 15
  00124	89 44 24 28	 mov	 DWORD PTR tv144[rsp], eax
  00128	83 7c 24 28 01	 cmp	 DWORD PTR tv144[rsp], 1
  0012d	74 22		 je	 SHORT $LN31@s390_set_a
  0012f	83 7c 24 28 02	 cmp	 DWORD PTR tv144[rsp], 2
  00134	74 56		 je	 SHORT $LN32@s390_set_a
  00136	83 7c 24 28 03	 cmp	 DWORD PTR tv144[rsp], 3
  0013b	0f 84 ff 00 00
	00		 je	 $LN36@s390_set_a
  00141	83 7c 24 28 04	 cmp	 DWORD PTR tv144[rsp], 4
  00146	0f 84 45 01 00
	00		 je	 $LN37@s390_set_a
  0014c	e9 78 01 00 00	 jmp	 $LN38@s390_set_a
$LN31@s390_set_a:
  00151	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR i$2[rsp], -1
  00159	eb 0a		 jmp	 SHORT $LN9@s390_set_a
$LN7@s390_set_a:
  0015b	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  0015f	ff c0		 inc	 eax
  00161	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN9@s390_set_a:
  00165	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  0016a	7d 1b		 jge	 SHORT $LN8@s390_set_a
  0016c	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  00170	83 c0 05	 add	 eax, 5
  00173	48 98		 cdqe
  00175	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0017a	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00185	eb d4		 jmp	 SHORT $LN7@s390_set_a
$LN8@s390_set_a:
  00187	e9 73 01 00 00	 jmp	 $LN5@s390_set_a
$LN32@s390_set_a:
  0018c	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR i$2[rsp], -1
  00194	eb 0a		 jmp	 SHORT $LN12@s390_set_a
$LN10@s390_set_a:
  00196	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  0019a	ff c0		 inc	 eax
  0019c	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN12@s390_set_a:
  001a0	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  001a5	7d 1b		 jge	 SHORT $LN11@s390_set_a
  001a7	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  001ab	83 c0 05	 add	 eax, 5
  001ae	48 98		 cdqe
  001b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  001c0	eb d4		 jmp	 SHORT $LN10@s390_set_a
$LN11@s390_set_a:
  001c2	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR i$2[rsp], 1
  001ca	eb 0a		 jmp	 SHORT $LN15@s390_set_a
$LN13@s390_set_a:
  001cc	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  001d0	ff c0		 inc	 eax
  001d2	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN15@s390_set_a:
  001d6	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  001db	7d 5e		 jge	 SHORT $LN14@s390_set_a
  001dd	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$2[rsp]
  001e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  001ef	75 1b		 jne	 SHORT $LN33@s390_set_a
  001f1	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  001f5	83 c0 05	 add	 eax, 5
  001f8	48 98		 cdqe
  001fa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001ff	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0020a	eb 2d		 jmp	 SHORT $LN34@s390_set_a
$LN33@s390_set_a:
  0020c	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$2[rsp]
  00211	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00216	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0021e	74 19		 je	 SHORT $LN35@s390_set_a
  00220	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  00224	83 c0 05	 add	 eax, 5
  00227	48 98		 cdqe
  00229	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0022e	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN35@s390_set_a:
$LN34@s390_set_a:
  00239	eb 91		 jmp	 SHORT $LN13@s390_set_a
$LN14@s390_set_a:
  0023b	e9 bf 00 00 00	 jmp	 $LN5@s390_set_a
$LN36@s390_set_a:
  00240	b8 04 00 00 00	 mov	 eax, 4
  00245	48 6b c0 04	 imul	 rax, rax, 4
  00249	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0024e	c7 84 01 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+3220], 1
  00259	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00261	eb 0a		 jmp	 SHORT $LN18@s390_set_a
$LN16@s390_set_a:
  00263	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  00267	ff c0		 inc	 eax
  00269	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN18@s390_set_a:
  0026d	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  00272	7d 1b		 jge	 SHORT $LN17@s390_set_a
  00274	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  00278	83 c0 05	 add	 eax, 5
  0027b	48 98		 cdqe
  0027d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00282	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0028d	eb d4		 jmp	 SHORT $LN16@s390_set_a
$LN17@s390_set_a:
  0028f	eb 6e		 jmp	 SHORT $LN5@s390_set_a
$LN37@s390_set_a:
  00291	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR i$2[rsp], -1
  00299	eb 0a		 jmp	 SHORT $LN21@s390_set_a
$LN19@s390_set_a:
  0029b	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  0029f	ff c0		 inc	 eax
  002a1	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN21@s390_set_a:
  002a5	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  002aa	7d 1b		 jge	 SHORT $LN20@s390_set_a
  002ac	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  002b0	83 c0 05	 add	 eax, 5
  002b3	48 98		 cdqe
  002b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  002ba	c7 84 81 94 0c
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 13
  002c5	eb d4		 jmp	 SHORT $LN19@s390_set_a
$LN20@s390_set_a:
  002c7	eb 36		 jmp	 SHORT $LN5@s390_set_a
$LN38@s390_set_a:
  002c9	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR i$2[rsp], -1
  002d1	eb 0a		 jmp	 SHORT $LN24@s390_set_a
$LN22@s390_set_a:
  002d3	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  002d7	ff c0		 inc	 eax
  002d9	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN24@s390_set_a:
  002dd	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  002e2	7d 1b		 jge	 SHORT $LN23@s390_set_a
  002e4	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  002e8	83 c0 05	 add	 eax, 5
  002eb	48 98		 cdqe
  002ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	c7 84 81 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+3220], -1
  002fd	eb d4		 jmp	 SHORT $LN22@s390_set_a
$LN23@s390_set_a:
$LN5@s390_set_a:
  002ff	b8 04 00 00 00	 mov	 eax, 4
  00304	48 6b c0 04	 imul	 rax, rax, 4
  00308	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0030d	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00314	39 44 24 3c	 cmp	 DWORD PTR inst_cr$3[rsp], eax
  00318	74 64		 je	 SHORT $LN39@s390_set_a
$LN27@s390_set_a:
  0031a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0031f	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00327	74 4f		 je	 SHORT $LN40@s390_set_a
  00329	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0032e	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00334	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00339	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0033e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00345	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00349	48 2b ca	 sub	 rcx, rdx
  0034c	48 03 c1	 add	 rax, rcx
  0034f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00354	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0035a	48 23 c1	 and	 rax, rcx
  0035d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00362	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00368	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0036d	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN40@s390_set_a:
  00378	33 c0		 xor	 eax, eax
  0037a	85 c0		 test	 eax, eax
  0037c	75 9c		 jne	 SHORT $LN27@s390_set_a
$LN39@s390_set_a:
  0037e	0f b6 44 24 20	 movzx	 eax, BYTE PTR oldmode$1[rsp]
  00383	83 e0 40	 and	 eax, 64			; 00000040H
  00386	85 c0		 test	 eax, eax
  00388	0f 85 c6 00 00
	00		 jne	 $LN41@s390_set_a
  0038e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00393	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  0039a	83 e0 40	 and	 eax, 64			; 00000040H
  0039d	85 c0		 test	 eax, eax
  0039f	0f 84 af 00 00
	00		 je	 $LN41@s390_set_a
$LN30@s390_set_a:
  003a5	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  003aa	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  003b2	74 4f		 je	 SHORT $LN42@s390_set_a
  003b4	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  003b9	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  003bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  003c4	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  003c9	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  003d0	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  003d4	48 2b ca	 sub	 rcx, rdx
  003d7	48 03 c1	 add	 rax, rcx
  003da	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  003df	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  003e5	48 23 c1	 and	 rax, rcx
  003e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  003ed	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  003f3	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  003f8	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN42@s390_set_a:
  00403	33 c0		 xor	 eax, eax
  00405	85 c0		 test	 eax, eax
  00407	75 9c		 jne	 SHORT $LN30@s390_set_a
  00409	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0040e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00414	c1 e8 02	 shr	 eax, 2
  00417	83 e0 01	 and	 eax, 1
  0041a	85 c0		 test	 eax, eax
  0041c	74 0a		 je	 SHORT $LN54@s390_set_a
  0041e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv260[rsp], 1
  00426	eb 08		 jmp	 SHORT $LN55@s390_set_a
$LN54@s390_set_a:
  00428	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv260[rsp], 0
$LN55@s390_set_a:
  00430	83 7c 24 38 00	 cmp	 DWORD PTR tv260[rsp], 0
  00435	74 1d		 je	 SHORT $LN43@s390_set_a
  00437	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0043c	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0043f	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00444	85 c0		 test	 eax, eax
  00446	74 0c		 je	 SHORT $LN43@s390_set_a
  00448	b2 fc		 mov	 dl, 252			; 000000fcH
  0044a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0044f	e8 00 00 00 00	 call	 s390_invalidate_tlb
$LN43@s390_set_a:
$LN41@s390_set_a:
  00454	33 c0		 xor	 eax, eax
  00456	85 c0		 test	 eax, eax
  00458	0f 85 ab fb ff
	ff		 jne	 $LN4@s390_set_a

; 132  : }

  0045e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00462	c3		 ret	 0
s390_set_aea_mode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
oldmode$1 = 32
i$2 = 36
tv90 = 40
tv146 = 44
tv95 = 48
tv152 = 52
tv226 = 56
inst_cr$3 = 60
regs$ = 80
s370_set_aea_mode PROC

; 130  : {

$LN43:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370_set_a:

; 131  :     SET_AEA_MODE( regs );

  00009	b8 04 00 00 00	 mov	 eax, 4
  0000e	48 6b c0 04	 imul	 rax, rax, 4
  00012	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  0001e	89 44 24 3c	 mov	 DWORD PTR inst_cr$3[rsp], eax
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00027	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  0002e	88 44 24 20	 mov	 BYTE PTR oldmode$1[rsp], al
  00032	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00037	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0003b	83 e0 08	 and	 eax, 8
  0003e	85 c0		 test	 eax, eax
  00040	74 24		 je	 SHORT $LN31@s370_set_a
  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00047	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0004b	83 e0 04	 and	 eax, 4
  0004e	85 c0		 test	 eax, eax
  00050	74 14		 je	 SHORT $LN31@s370_set_a
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00057	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0005b	c1 f8 06	 sar	 eax, 6
  0005e	ff c0		 inc	 eax
  00060	89 44 24 30	 mov	 DWORD PTR tv95[rsp], eax
  00064	eb 55		 jmp	 SHORT $LN34@s370_set_a
$LN31@s370_set_a:
  00066	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0006b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00071	d1 e8		 shr	 eax, 1
  00073	83 e0 01	 and	 eax, 1
  00076	85 c0		 test	 eax, eax
  00078	74 31		 je	 SHORT $LN32@s370_set_a
  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00086	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 1a		 je	 SHORT $LN32@s370_set_a
  00091	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00096	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0009a	83 e0 40	 and	 eax, 64			; 00000040H
  0009d	85 c0		 test	 eax, eax
  0009f	74 0a		 je	 SHORT $LN32@s370_set_a
  000a1	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR tv90[rsp], 2
  000a9	eb 08		 jmp	 SHORT $LN33@s370_set_a
$LN32@s370_set_a:
  000ab	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN33@s370_set_a:
  000b3	8b 44 24 28	 mov	 eax, DWORD PTR tv90[rsp]
  000b7	89 44 24 30	 mov	 DWORD PTR tv95[rsp], eax
$LN34@s370_set_a:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	75 55		 jne	 SHORT $LN36@s370_set_a
  000c1	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000ca	83 e0 08	 and	 eax, 8
  000cd	85 c0		 test	 eax, eax
  000cf	74 10		 je	 SHORT $LN35@s370_set_a
  000d1	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000d6	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  000da	83 e0 40	 and	 eax, 64			; 00000040H
  000dd	85 c0		 test	 eax, eax
  000df	75 35		 jne	 SHORT $LN36@s370_set_a
$LN35@s370_set_a:
  000e1	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000e6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000ec	d1 e8		 shr	 eax, 1
  000ee	83 e0 01	 and	 eax, 1
  000f1	85 c0		 test	 eax, eax
  000f3	74 17		 je	 SHORT $LN37@s370_set_a
  000f5	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000fa	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00101	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00105	83 e0 01	 and	 eax, 1
  00108	85 c0		 test	 eax, eax
  0010a	75 0a		 jne	 SHORT $LN36@s370_set_a
$LN37@s370_set_a:
  0010c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv146[rsp], 0
  00114	eb 08		 jmp	 SHORT $LN38@s370_set_a
$LN36@s370_set_a:
  00116	c7 44 24 2c 40
	00 00 00	 mov	 DWORD PTR tv146[rsp], 64 ; 00000040H
$LN38@s370_set_a:
  0011e	8b 44 24 2c	 mov	 eax, DWORD PTR tv146[rsp]
  00122	8b 4c 24 30	 mov	 ecx, DWORD PTR tv95[rsp]
  00126	0b c8		 or	 ecx, eax
  00128	8b c1		 mov	 eax, ecx
  0012a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	88 81 90 0c 00
	00		 mov	 BYTE PTR [rcx+3216], al
  00135	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00141	83 e0 0f	 and	 eax, 15
  00144	89 44 24 34	 mov	 DWORD PTR tv152[rsp], eax
  00148	83 7c 24 34 01	 cmp	 DWORD PTR tv152[rsp], 1
  0014d	74 0c		 je	 SHORT $LN22@s370_set_a
  0014f	83 7c 24 34 03	 cmp	 DWORD PTR tv152[rsp], 3
  00154	74 40		 je	 SHORT $LN23@s370_set_a
  00156	e9 8c 00 00 00	 jmp	 $LN24@s370_set_a
$LN22@s370_set_a:
  0015b	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR i$2[rsp], -1
  00163	eb 0a		 jmp	 SHORT $LN9@s370_set_a
$LN7@s370_set_a:
  00165	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  00169	ff c0		 inc	 eax
  0016b	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN9@s370_set_a:
  0016f	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  00174	7d 1b		 jge	 SHORT $LN8@s370_set_a
  00176	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  0017a	83 c0 05	 add	 eax, 5
  0017d	48 98		 cdqe
  0017f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0018f	eb d4		 jmp	 SHORT $LN7@s370_set_a
$LN8@s370_set_a:
  00191	e9 87 00 00 00	 jmp	 $LN5@s370_set_a
$LN23@s370_set_a:
  00196	b8 04 00 00 00	 mov	 eax, 4
  0019b	48 6b c0 04	 imul	 rax, rax, 4
  0019f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001a4	c7 84 01 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+3220], 1
  001af	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  001b7	eb 0a		 jmp	 SHORT $LN12@s370_set_a
$LN10@s370_set_a:
  001b9	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  001bd	ff c0		 inc	 eax
  001bf	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN12@s370_set_a:
  001c3	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  001c8	7d 1b		 jge	 SHORT $LN11@s370_set_a
  001ca	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  001ce	83 c0 05	 add	 eax, 5
  001d1	48 98		 cdqe
  001d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  001d8	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  001e3	eb d4		 jmp	 SHORT $LN10@s370_set_a
$LN11@s370_set_a:
  001e5	eb 36		 jmp	 SHORT $LN5@s370_set_a
$LN24@s370_set_a:
  001e7	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR i$2[rsp], -1
  001ef	eb 0a		 jmp	 SHORT $LN15@s370_set_a
$LN13@s370_set_a:
  001f1	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  001f5	ff c0		 inc	 eax
  001f7	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN15@s370_set_a:
  001fb	83 7c 24 24 10	 cmp	 DWORD PTR i$2[rsp], 16
  00200	7d 1b		 jge	 SHORT $LN14@s370_set_a
  00202	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  00206	83 c0 05	 add	 eax, 5
  00209	48 98		 cdqe
  0020b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00210	c7 84 81 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+3220], -1
  0021b	eb d4		 jmp	 SHORT $LN13@s370_set_a
$LN14@s370_set_a:
$LN5@s370_set_a:
  0021d	b8 04 00 00 00	 mov	 eax, 4
  00222	48 6b c0 04	 imul	 rax, rax, 4
  00226	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0022b	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00232	39 44 24 3c	 cmp	 DWORD PTR inst_cr$3[rsp], eax
  00236	74 5c		 je	 SHORT $LN25@s370_set_a
$LN18@s370_set_a:
  00238	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0023d	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00245	74 47		 je	 SHORT $LN26@s370_set_a
  00247	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0024c	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00252	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00257	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  0025c	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00263	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00267	48 2b ca	 sub	 rcx, rdx
  0026a	48 03 c1	 add	 rax, rcx
  0026d	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00273	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00278	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  0027e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00283	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN26@s370_set_a:
  0028e	33 c0		 xor	 eax, eax
  00290	85 c0		 test	 eax, eax
  00292	75 a4		 jne	 SHORT $LN18@s370_set_a
$LN25@s370_set_a:
  00294	0f b6 44 24 20	 movzx	 eax, BYTE PTR oldmode$1[rsp]
  00299	83 e0 40	 and	 eax, 64			; 00000040H
  0029c	85 c0		 test	 eax, eax
  0029e	0f 85 be 00 00
	00		 jne	 $LN27@s370_set_a
  002a4	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  002a9	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  002b0	83 e0 40	 and	 eax, 64			; 00000040H
  002b3	85 c0		 test	 eax, eax
  002b5	0f 84 a7 00 00
	00		 je	 $LN27@s370_set_a
$LN21@s370_set_a:
  002bb	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  002c0	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  002c8	74 47		 je	 SHORT $LN28@s370_set_a
  002ca	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  002cf	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  002d5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  002da	48 8b 54 24 50	 mov	 rdx, QWORD PTR regs$[rsp]
  002df	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  002e6	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  002ea	48 2b ca	 sub	 rcx, rdx
  002ed	48 03 c1	 add	 rax, rcx
  002f0	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  002f6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  002fb	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00301	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00306	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN28@s370_set_a:
  00311	33 c0		 xor	 eax, eax
  00313	85 c0		 test	 eax, eax
  00315	75 a4		 jne	 SHORT $LN21@s370_set_a
  00317	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0031c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00322	c1 e8 02	 shr	 eax, 2
  00325	83 e0 01	 and	 eax, 1
  00328	85 c0		 test	 eax, eax
  0032a	74 0a		 je	 SHORT $LN41@s370_set_a
  0032c	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv226[rsp], 1
  00334	eb 08		 jmp	 SHORT $LN42@s370_set_a
$LN41@s370_set_a:
  00336	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv226[rsp], 0
$LN42@s370_set_a:
  0033e	83 7c 24 38 00	 cmp	 DWORD PTR tv226[rsp], 0
  00343	74 1d		 je	 SHORT $LN29@s370_set_a
  00345	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0034a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0034d	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00352	85 c0		 test	 eax, eax
  00354	74 0c		 je	 SHORT $LN29@s370_set_a
  00356	b2 fc		 mov	 dl, 252			; 000000fcH
  00358	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0035d	e8 00 00 00 00	 call	 s370_invalidate_tlb
$LN29@s370_set_a:
$LN27@s370_set_a:
  00362	33 c0		 xor	 eax, eax
  00364	85 c0		 test	 eax, eax
  00366	0f 85 9d fc ff
	ff		 jne	 $LN4@s370_set_a

; 132  : }

  0036c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00370	c3		 ret	 0
s370_set_aea_mode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv69 = 0
tv131 = 4
tv149 = 8
tv168 = 12
tv173 = 16
tv81 = 24
tv143 = 32
regs$ = 64
z900_set_ic_mask PROC

; 123  : {

$LN25:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900_set_i:

; 124  :     SET_IC_MASK( regs );

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00012	83 e0 02	 and	 eax, 2
  00015	85 c0		 test	 eax, eax
  00017	74 09		 je	 SHORT $LN11@z900_set_i
  00019	c7 04 24 00 00
	00 40		 mov	 DWORD PTR tv69[rsp], 1073741824 ; 40000000H
  00020	eb 07		 jmp	 SHORT $LN12@z900_set_i
$LN11@z900_set_i:
  00022	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
$LN12@z900_set_i:
  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00032	83 e0 04	 and	 eax, 4
  00035	85 c0		 test	 eax, eax
  00037	74 23		 je	 SHORT $LN13@z900_set_i
  00039	b8 08 00 00 00	 mov	 eax, 8
  0003e	48 6b c0 0f	 imul	 rax, rax, 15
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00047	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0004f	48 25 00 00 00
	1f		 and	 rax, 520093696		; 1f000000H
  00055	48 89 44 24 18	 mov	 QWORD PTR tv81[rsp], rax
  0005a	eb 09		 jmp	 SHORT $LN14@z900_set_i
$LN13@z900_set_i:
  0005c	48 c7 44 24 18
	00 00 00 00	 mov	 QWORD PTR tv81[rsp], 0
$LN14@z900_set_i:
  00065	33 c0		 xor	 eax, eax
  00067	85 c0		 test	 eax, eax
  00069	75 45		 jne	 SHORT $LN15@z900_set_i
  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00070	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00074	83 e0 40	 and	 eax, 64			; 00000040H
  00077	85 c0		 test	 eax, eax
  00079	75 35		 jne	 SHORT $LN15@z900_set_i
  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00080	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00086	d1 e8		 shr	 eax, 1
  00088	83 e0 01	 and	 eax, 1
  0008b	85 c0		 test	 eax, eax
  0008d	74 17		 je	 SHORT $LN16@z900_set_i
  0008f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00094	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0009b	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0009f	83 e0 01	 and	 eax, 1
  000a2	85 c0		 test	 eax, eax
  000a4	75 0a		 jne	 SHORT $LN15@z900_set_i
$LN16@z900_set_i:
  000a6	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
  000ae	eb 11		 jmp	 SHORT $LN17@z900_set_i
$LN15@z900_set_i:
  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000b5	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000b8	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  000bd	89 44 24 04	 mov	 DWORD PTR tv131[rsp], eax
$LN17@z900_set_i:
  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  000ca	83 e0 01	 and	 eax, 1
  000cd	85 c0		 test	 eax, eax
  000cf	74 23		 je	 SHORT $LN18@z900_set_i
  000d1	b8 08 00 00 00	 mov	 eax, 8
  000d6	48 6b c0 01	 imul	 rax, rax, 1
  000da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000e7	48 25 f0 fe 00
	00		 and	 rax, 65264		; 0000fef0H
  000ed	48 89 44 24 20	 mov	 QWORD PTR tv143[rsp], rax
  000f2	eb 09		 jmp	 SHORT $LN19@z900_set_i
$LN18@z900_set_i:
  000f4	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv143[rsp], 0
$LN19@z900_set_i:
  000fd	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00102	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00106	83 e0 02	 and	 eax, 2
  00109	85 c0		 test	 eax, eax
  0010b	74 0a		 je	 SHORT $LN20@z900_set_i
  0010d	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv149[rsp], 1
  00115	eb 08		 jmp	 SHORT $LN21@z900_set_i
$LN20@z900_set_i:
  00117	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN21@z900_set_i:
  0011f	8b 04 24	 mov	 eax, DWORD PTR tv69[rsp]
  00122	0d 0a 00 00 80	 or	 eax, -2147483638	; 8000000aH
  00127	8b c0		 mov	 eax, eax
  00129	48 0b 44 24 18	 or	 rax, QWORD PTR tv81[rsp]
  0012e	8b 4c 24 04	 mov	 ecx, DWORD PTR tv131[rsp]
  00132	48 0b c1	 or	 rax, rcx
  00135	48 0b 44 24 20	 or	 rax, QWORD PTR tv143[rsp]
  0013a	8b 4c 24 08	 mov	 ecx, DWORD PTR tv149[rsp]
  0013e	48 0b c1	 or	 rax, rcx
  00141	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00146	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00149	33 c0		 xor	 eax, eax
  0014b	85 c0		 test	 eax, eax
  0014d	75 45		 jne	 SHORT $LN22@z900_set_i
  0014f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00154	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00158	83 e0 40	 and	 eax, 64			; 00000040H
  0015b	85 c0		 test	 eax, eax
  0015d	75 35		 jne	 SHORT $LN22@z900_set_i
  0015f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00164	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0016a	d1 e8		 shr	 eax, 1
  0016c	83 e0 01	 and	 eax, 1
  0016f	85 c0		 test	 eax, eax
  00171	74 17		 je	 SHORT $LN23@z900_set_i
  00173	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00178	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0017f	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00183	83 e0 01	 and	 eax, 1
  00186	85 c0		 test	 eax, eax
  00188	75 0a		 jne	 SHORT $LN22@z900_set_i
$LN23@z900_set_i:
  0018a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv168[rsp], 0
  00192	eb 08		 jmp	 SHORT $LN24@z900_set_i
$LN22@z900_set_i:
  00194	c7 44 24 0c 01
	00 00 00	 mov	 DWORD PTR tv168[rsp], 1
$LN24@z900_set_i:
  0019c	8b 44 24 0c	 mov	 eax, DWORD PTR tv168[rsp]
  001a0	83 e0 01	 and	 eax, 1
  001a3	c1 e0 02	 shl	 eax, 2
  001a6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  001b1	83 e1 fb	 and	 ecx, -5			; fffffffbH
  001b4	0b c8		 or	 ecx, eax
  001b6	89 4c 24 10	 mov	 DWORD PTR tv173[rsp], ecx
  001ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  001bf	8b 4c 24 10	 mov	 ecx, DWORD PTR tv173[rsp]
  001c3	89 88 28 07 00
	00		 mov	 DWORD PTR [rax+1832], ecx
  001c9	8b 44 24 10	 mov	 eax, DWORD PTR tv173[rsp]
  001cd	c1 e8 02	 shr	 eax, 2
  001d0	83 e0 01	 and	 eax, 1
  001d3	85 c0		 test	 eax, eax
  001d5	74 67		 je	 SHORT $LN8@z900_set_i
$LN7@z900_set_i:
  001d7	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  001dc	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  001e4	74 52		 je	 SHORT $LN9@z900_set_i
  001e6	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  001f0	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  001f7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001fb	48 2b c1	 sub	 rax, rcx
  001fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00203	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0020a	48 03 c8	 add	 rcx, rax
  0020d	48 8b c1	 mov	 rax, rcx
  00210	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00215	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0021c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00221	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00228	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN9@z900_set_i:
  00238	33 c0		 xor	 eax, eax
  0023a	85 c0		 test	 eax, eax
  0023c	75 99		 jne	 SHORT $LN7@z900_set_i
$LN8@z900_set_i:
  0023e	33 c0		 xor	 eax, eax
  00240	85 c0		 test	 eax, eax
  00242	0f 85 c1 fd ff
	ff		 jne	 $LN4@z900_set_i

; 125  : }

  00248	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0024c	c3		 ret	 0
z900_set_ic_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv69 = 0
tv80 = 4
tv130 = 8
tv141 = 12
tv147 = 16
tv164 = 20
tv169 = 24
regs$ = 48
s390_set_ic_mask PROC

; 123  : {

$LN25:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@s390_set_i:

; 124  :     SET_IC_MASK( regs );

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00012	83 e0 02	 and	 eax, 2
  00015	85 c0		 test	 eax, eax
  00017	74 09		 je	 SHORT $LN11@s390_set_i
  00019	c7 04 24 00 00
	00 40		 mov	 DWORD PTR tv69[rsp], 1073741824 ; 40000000H
  00020	eb 07		 jmp	 SHORT $LN12@s390_set_i
$LN11@s390_set_i:
  00022	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
$LN12@s390_set_i:
  00029	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00032	83 e0 04	 and	 eax, 4
  00035	85 c0		 test	 eax, eax
  00037	74 20		 je	 SHORT $LN13@s390_set_i
  00039	b8 08 00 00 00	 mov	 eax, 8
  0003e	48 6b c0 0f	 imul	 rax, rax, 15
  00042	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00047	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0004e	25 00 00 00 1f	 and	 eax, 520093696		; 1f000000H
  00053	89 44 24 04	 mov	 DWORD PTR tv80[rsp], eax
  00057	eb 08		 jmp	 SHORT $LN14@s390_set_i
$LN13@s390_set_i:
  00059	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN14@s390_set_i:
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 45		 jne	 SHORT $LN15@s390_set_i
  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00070	83 e0 40	 and	 eax, 64			; 00000040H
  00073	85 c0		 test	 eax, eax
  00075	75 35		 jne	 SHORT $LN15@s390_set_i
  00077	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0007c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00082	d1 e8		 shr	 eax, 1
  00084	83 e0 01	 and	 eax, 1
  00087	85 c0		 test	 eax, eax
  00089	74 17		 je	 SHORT $LN16@s390_set_i
  0008b	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00097	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0009b	83 e0 01	 and	 eax, 1
  0009e	85 c0		 test	 eax, eax
  000a0	75 0a		 jne	 SHORT $LN15@s390_set_i
$LN16@s390_set_i:
  000a2	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
  000aa	eb 11		 jmp	 SHORT $LN17@s390_set_i
$LN15@s390_set_i:
  000ac	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000b4	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  000b9	89 44 24 08	 mov	 DWORD PTR tv130[rsp], eax
$LN17@s390_set_i:
  000bd	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c2	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  000c6	83 e0 01	 and	 eax, 1
  000c9	85 c0		 test	 eax, eax
  000cb	74 20		 je	 SHORT $LN18@s390_set_i
  000cd	b8 08 00 00 00	 mov	 eax, 8
  000d2	48 6b c0 01	 imul	 rax, rax, 1
  000d6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  000db	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000e2	25 f0 fe 00 00	 and	 eax, 65264		; 0000fef0H
  000e7	89 44 24 0c	 mov	 DWORD PTR tv141[rsp], eax
  000eb	eb 08		 jmp	 SHORT $LN19@s390_set_i
$LN18@s390_set_i:
  000ed	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv141[rsp], 0
$LN19@s390_set_i:
  000f5	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000fa	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000fe	83 e0 02	 and	 eax, 2
  00101	85 c0		 test	 eax, eax
  00103	74 0a		 je	 SHORT $LN20@s390_set_i
  00105	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv147[rsp], 1
  0010d	eb 08		 jmp	 SHORT $LN21@s390_set_i
$LN20@s390_set_i:
  0010f	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN21@s390_set_i:
  00117	8b 04 24	 mov	 eax, DWORD PTR tv69[rsp]
  0011a	0d 0a 00 00 80	 or	 eax, -2147483638	; 8000000aH
  0011f	0b 44 24 04	 or	 eax, DWORD PTR tv80[rsp]
  00123	0b 44 24 08	 or	 eax, DWORD PTR tv130[rsp]
  00127	0b 44 24 0c	 or	 eax, DWORD PTR tv141[rsp]
  0012b	0b 44 24 10	 or	 eax, DWORD PTR tv147[rsp]
  0012f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00137	33 c0		 xor	 eax, eax
  00139	85 c0		 test	 eax, eax
  0013b	75 45		 jne	 SHORT $LN22@s390_set_i
  0013d	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00142	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00146	83 e0 40	 and	 eax, 64			; 00000040H
  00149	85 c0		 test	 eax, eax
  0014b	75 35		 jne	 SHORT $LN22@s390_set_i
  0014d	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00152	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00158	d1 e8		 shr	 eax, 1
  0015a	83 e0 01	 and	 eax, 1
  0015d	85 c0		 test	 eax, eax
  0015f	74 17		 je	 SHORT $LN23@s390_set_i
  00161	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00166	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0016d	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00171	83 e0 01	 and	 eax, 1
  00174	85 c0		 test	 eax, eax
  00176	75 0a		 jne	 SHORT $LN22@s390_set_i
$LN23@s390_set_i:
  00178	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR tv164[rsp], 0
  00180	eb 08		 jmp	 SHORT $LN24@s390_set_i
$LN22@s390_set_i:
  00182	c7 44 24 14 01
	00 00 00	 mov	 DWORD PTR tv164[rsp], 1
$LN24@s390_set_i:
  0018a	8b 44 24 14	 mov	 eax, DWORD PTR tv164[rsp]
  0018e	83 e0 01	 and	 eax, 1
  00191	c1 e0 02	 shl	 eax, 2
  00194	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00199	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  0019f	83 e1 fb	 and	 ecx, -5			; fffffffbH
  001a2	0b c8		 or	 ecx, eax
  001a4	89 4c 24 18	 mov	 DWORD PTR tv169[rsp], ecx
  001a8	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  001ad	8b 4c 24 18	 mov	 ecx, DWORD PTR tv169[rsp]
  001b1	89 88 28 07 00
	00		 mov	 DWORD PTR [rax+1832], ecx
  001b7	8b 44 24 18	 mov	 eax, DWORD PTR tv169[rsp]
  001bb	c1 e8 02	 shr	 eax, 2
  001be	83 e0 01	 and	 eax, 1
  001c1	85 c0		 test	 eax, eax
  001c3	74 64		 je	 SHORT $LN8@s390_set_i
$LN7@s390_set_i:
  001c5	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  001ca	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  001d2	74 4f		 je	 SHORT $LN9@s390_set_i
  001d4	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  001d9	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  001df	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  001e4	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  001e9	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  001f0	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  001f4	48 2b ca	 sub	 rcx, rdx
  001f7	48 03 c1	 add	 rax, rcx
  001fa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  001ff	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00205	48 23 c1	 and	 rax, rcx
  00208	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0020d	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00213	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00218	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN9@s390_set_i:
  00223	33 c0		 xor	 eax, eax
  00225	85 c0		 test	 eax, eax
  00227	75 9c		 jne	 SHORT $LN7@s390_set_i
$LN8@s390_set_i:
  00229	33 c0		 xor	 eax, eax
  0022b	85 c0		 test	 eax, eax
  0022d	0f 85 d6 fd ff
	ff		 jne	 $LN4@s390_set_i

; 125  : }

  00233	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00237	c3		 ret	 0
s390_set_ic_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
tv73 = 0
tv78 = 4
tv160 = 8
tv79 = 12
tv90 = 16
tv144 = 20
tv163 = 24
tv169 = 28
tv190 = 32
tv195 = 36
regs$ = 64
s370_set_ic_mask PROC

; 123  : {

$LN33:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370_set_i:

; 124  :     SET_IC_MASK( regs );

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00012	83 e0 08	 and	 eax, 8
  00015	85 c0		 test	 eax, eax
  00017	74 29		 je	 SHORT $LN15@s370_set_i
  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0001e	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00022	83 e0 02	 and	 eax, 2
  00025	85 c0		 test	 eax, eax
  00027	74 09		 je	 SHORT $LN11@s370_set_i
  00029	c7 04 24 00 00
	00 40		 mov	 DWORD PTR tv73[rsp], 1073741824 ; 40000000H
  00030	eb 07		 jmp	 SHORT $LN12@s370_set_i
$LN11@s370_set_i:
  00032	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv73[rsp], 0
$LN12@s370_set_i:
  00039	8b 04 24	 mov	 eax, DWORD PTR tv73[rsp]
  0003c	89 44 24 0c	 mov	 DWORD PTR tv79[rsp], eax
  00040	eb 2c		 jmp	 SHORT $LN16@s370_set_i
$LN15@s370_set_i:
  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00047	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0004b	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  00050	85 c0		 test	 eax, eax
  00052	74 0a		 je	 SHORT $LN13@s370_set_i
  00054	c7 44 24 04 00
	00 00 40	 mov	 DWORD PTR tv78[rsp], 1073741824 ; 40000000H
  0005c	eb 08		 jmp	 SHORT $LN14@s370_set_i
$LN13@s370_set_i:
  0005e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN14@s370_set_i:
  00066	8b 44 24 04	 mov	 eax, DWORD PTR tv78[rsp]
  0006a	89 44 24 0c	 mov	 DWORD PTR tv79[rsp], eax
$LN16@s370_set_i:
  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00073	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00077	83 e0 04	 and	 eax, 4
  0007a	85 c0		 test	 eax, eax
  0007c	74 20		 je	 SHORT $LN17@s370_set_i
  0007e	b8 08 00 00 00	 mov	 eax, 8
  00083	48 6b c0 0f	 imul	 rax, rax, 15
  00087	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0008c	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00093	25 00 00 00 1f	 and	 eax, 520093696		; 1f000000H
  00098	89 44 24 10	 mov	 DWORD PTR tv90[rsp], eax
  0009c	eb 08		 jmp	 SHORT $LN18@s370_set_i
$LN17@s370_set_i:
  0009e	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN18@s370_set_i:
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 55		 jne	 SHORT $LN20@s370_set_i
  000ac	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000b5	83 e0 08	 and	 eax, 8
  000b8	85 c0		 test	 eax, eax
  000ba	74 10		 je	 SHORT $LN19@s370_set_i
  000bc	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  000c5	83 e0 40	 and	 eax, 64			; 00000040H
  000c8	85 c0		 test	 eax, eax
  000ca	75 35		 jne	 SHORT $LN20@s370_set_i
$LN19@s370_set_i:
  000cc	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d7	d1 e8		 shr	 eax, 1
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 17		 je	 SHORT $LN21@s370_set_i
  000e0	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000e5	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000ec	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000f0	83 e0 01	 and	 eax, 1
  000f3	85 c0		 test	 eax, eax
  000f5	75 0a		 jne	 SHORT $LN20@s370_set_i
$LN21@s370_set_i:
  000f7	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR tv144[rsp], 0
  000ff	eb 11		 jmp	 SHORT $LN22@s370_set_i
$LN20@s370_set_i:
  00101	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00106	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00109	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  0010e	89 44 24 14	 mov	 DWORD PTR tv144[rsp], eax
$LN22@s370_set_i:
  00112	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00117	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0011b	83 e0 01	 and	 eax, 1
  0011e	85 c0		 test	 eax, eax
  00120	74 54		 je	 SHORT $LN25@s370_set_i
  00122	b8 08 00 00 00	 mov	 eax, 8
  00127	48 6b c0 01	 imul	 rax, rax, 1
  0012b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00137	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0013c	85 c0		 test	 eax, eax
  0013e	74 0a		 je	 SHORT $LN23@s370_set_i
  00140	c7 44 24 08 00
	01 00 00	 mov	 DWORD PTR tv160[rsp], 256 ; 00000100H
  00148	eb 08		 jmp	 SHORT $LN24@s370_set_i
$LN23@s370_set_i:
  0014a	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv160[rsp], 0
$LN24@s370_set_i:
  00152	b8 08 00 00 00	 mov	 eax, 8
  00157	48 6b c0 01	 imul	 rax, rax, 1
  0015b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00167	25 f0 fe 00 00	 and	 eax, 65264		; 0000fef0H
  0016c	0b 44 24 08	 or	 eax, DWORD PTR tv160[rsp]
  00170	89 44 24 18	 mov	 DWORD PTR tv163[rsp], eax
  00174	eb 08		 jmp	 SHORT $LN26@s370_set_i
$LN25@s370_set_i:
  00176	c7 44 24 18 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
$LN26@s370_set_i:
  0017e	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00183	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00187	83 e0 02	 and	 eax, 2
  0018a	85 c0		 test	 eax, eax
  0018c	74 0a		 je	 SHORT $LN27@s370_set_i
  0018e	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR tv169[rsp], 1
  00196	eb 08		 jmp	 SHORT $LN28@s370_set_i
$LN27@s370_set_i:
  00198	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
$LN28@s370_set_i:
  001a0	8b 44 24 0c	 mov	 eax, DWORD PTR tv79[rsp]
  001a4	0d 0a 00 00 80	 or	 eax, -2147483638	; 8000000aH
  001a9	0b 44 24 10	 or	 eax, DWORD PTR tv90[rsp]
  001ad	0b 44 24 14	 or	 eax, DWORD PTR tv144[rsp]
  001b1	0b 44 24 18	 or	 eax, DWORD PTR tv163[rsp]
  001b5	0b 44 24 1c	 or	 eax, DWORD PTR tv169[rsp]
  001b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  001be	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  001c1	33 c0		 xor	 eax, eax
  001c3	85 c0		 test	 eax, eax
  001c5	75 55		 jne	 SHORT $LN30@s370_set_i
  001c7	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  001cc	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  001d0	83 e0 08	 and	 eax, 8
  001d3	85 c0		 test	 eax, eax
  001d5	74 10		 je	 SHORT $LN29@s370_set_i
  001d7	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  001dc	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  001e0	83 e0 40	 and	 eax, 64			; 00000040H
  001e3	85 c0		 test	 eax, eax
  001e5	75 35		 jne	 SHORT $LN30@s370_set_i
$LN29@s370_set_i:
  001e7	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  001ec	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001f2	d1 e8		 shr	 eax, 1
  001f4	83 e0 01	 and	 eax, 1
  001f7	85 c0		 test	 eax, eax
  001f9	74 17		 je	 SHORT $LN31@s370_set_i
  001fb	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00200	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00207	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0020b	83 e0 01	 and	 eax, 1
  0020e	85 c0		 test	 eax, eax
  00210	75 0a		 jne	 SHORT $LN30@s370_set_i
$LN31@s370_set_i:
  00212	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv190[rsp], 0
  0021a	eb 08		 jmp	 SHORT $LN32@s370_set_i
$LN30@s370_set_i:
  0021c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv190[rsp], 1
$LN32@s370_set_i:
  00224	8b 44 24 20	 mov	 eax, DWORD PTR tv190[rsp]
  00228	83 e0 01	 and	 eax, 1
  0022b	c1 e0 02	 shl	 eax, 2
  0022e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00233	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00239	83 e1 fb	 and	 ecx, -5			; fffffffbH
  0023c	0b c8		 or	 ecx, eax
  0023e	89 4c 24 24	 mov	 DWORD PTR tv195[rsp], ecx
  00242	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00247	8b 4c 24 24	 mov	 ecx, DWORD PTR tv195[rsp]
  0024b	89 88 28 07 00
	00		 mov	 DWORD PTR [rax+1832], ecx
  00251	8b 44 24 24	 mov	 eax, DWORD PTR tv195[rsp]
  00255	c1 e8 02	 shr	 eax, 2
  00258	83 e0 01	 and	 eax, 1
  0025b	85 c0		 test	 eax, eax
  0025d	74 5c		 je	 SHORT $LN8@s370_set_i
$LN7@s370_set_i:
  0025f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00264	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0026c	74 47		 je	 SHORT $LN9@s370_set_i
  0026e	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00273	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00279	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0027e	48 8b 54 24 40	 mov	 rdx, QWORD PTR regs$[rsp]
  00283	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0028a	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0028e	48 2b ca	 sub	 rcx, rdx
  00291	48 03 c1	 add	 rax, rcx
  00294	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0029a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0029f	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  002a5	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  002aa	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN9@s370_set_i:
  002b5	33 c0		 xor	 eax, eax
  002b7	85 c0		 test	 eax, eax
  002b9	75 a4		 jne	 SHORT $LN7@s370_set_i
$LN8@s370_set_i:
  002bb	33 c0		 xor	 eax, eax
  002bd	85 c0		 test	 eax, eax
  002bf	0f 85 44 fd ff
	ff		 jne	 $LN4@s370_set_i

; 125  : }

  002c5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002c9	c3		 ret	 0
s370_set_ic_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
regs$ = 8
z900_invalidate_aia PROC

; 116  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@z900_inval:

; 117  :     INVALIDATE_AIA( regs );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0000a	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00012	74 52		 je	 SHORT $LN5@z900_inval
  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00019	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  0001e	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00025	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00029	48 2b c1	 sub	 rax, rcx
  0002c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00031	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00038	48 03 c8	 add	 rcx, rax
  0003b	48 8b c1	 mov	 rax, rcx
  0003e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00043	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0004a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00056	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0005b	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN5@z900_inval:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 99		 jne	 SHORT $LN4@z900_inval

; 118  : }

  0006c	c3		 ret	 0
z900_invalidate_aia ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
regs$ = 8
s390_invalidate_aia PROC

; 116  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_inval:

; 117  :     INVALIDATE_AIA( regs );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0000a	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00012	74 4f		 je	 SHORT $LN5@s390_inval
  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0001f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00024	48 8b 54 24 08	 mov	 rdx, QWORD PTR regs$[rsp]
  00029	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00030	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00034	48 2b ca	 sub	 rcx, rdx
  00037	48 03 c1	 add	 rax, rcx
  0003a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  0003f	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00045	48 23 c1	 and	 rax, rcx
  00048	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  0004d	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00053	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00058	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN5@s390_inval:
  00063	33 c0		 xor	 eax, eax
  00065	85 c0		 test	 eax, eax
  00067	75 9c		 jne	 SHORT $LN4@s390_inval

; 118  : }

  00069	c3		 ret	 0
s390_invalidate_aia ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.c
_TEXT	SEGMENT
regs$ = 8
s370_invalidate_aia PROC

; 116  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_inval:

; 117  :     INVALIDATE_AIA( regs );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0000a	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00012	74 47		 je	 SHORT $LN5@s370_inval
  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0001f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00024	48 8b 54 24 08	 mov	 rdx, QWORD PTR regs$[rsp]
  00029	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00030	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00034	48 2b ca	 sub	 rcx, rdx
  00037	48 03 c1	 add	 rax, rcx
  0003a	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00040	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  0004b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00050	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN5@s370_inval:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c0		 test	 eax, eax
  0005f	75 a4		 jne	 SHORT $LN4@s370_inval

; 118  : }

  00061	c3		 ret	 0
s370_invalidate_aia ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
END
