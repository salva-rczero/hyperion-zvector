; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	logger_syslogfd
_BSS	SEGMENT
?buf@?1??log_dsphrdcpy@@9@9 DB 0106H DUP (?)		; `log_dsphrdcpy'::`2'::buf
_BSS	ENDS
_DATA	SEGMENT
logger_syslogfd DD 0ffffffffH
	DD	0ffffffffH
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	logger_init
PUBLIC	log_read
PUBLIC	log_line
PUBLIC	log_sethrdcpy
PUBLIC	log_wakeup
PUBLIC	log_dsphrdcpy
PUBLIC	logger_isactive
PUBLIC	logger_timestamped_logfile_write
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	memchr:PROC
EXTRN	strchr:PROC
EXTRN	strlen:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp_recv:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_dup:PROC
EXTRN	__imp_dup2:PROC
EXTRN	__imp_isatty:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_setvbuf:PROC
EXTRN	__imp_fileno:PROC
EXTRN	fthread_self:PROC
EXTRN	hthread_initialize_lock:PROC
EXTRN	hthread_obtain_lock:PROC
EXTRN	hthread_release_lock:PROC
EXTRN	hthread_initialize_condition:PROC
EXTRN	hthread_signal_condition:PROC
EXTRN	hthread_broadcast_condition:PROC
EXTRN	hthread_wait_condition:PROC
EXTRN	hthread_create_thread:PROC
EXTRN	hthread_get_thread_prio:PROC
EXTRN	memrchr:PROC
EXTRN	strlcpy:PROC
EXTRN	FormatTIMEVAL:PROC
EXTRN	w32_strerror:PROC
EXTRN	socketpair:PROC
EXTRN	hostpath:PROC
EXTRN	socket_set_blocking_mode:PROC
EXTRN	w32_fdopen:PROC
EXTRN	w32_fwrite:PROC
EXTRN	w32_snprintf:PROC
EXTRN	w32_fprintf:PROC
EXTRN	w32_fclose:PROC
EXTRN	w32_hopen:PROC
EXTRN	fwritemsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_extgui:DWORD
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
	ALIGN	8

logger_cond DQ	01H DUP (?)
logger_lock DQ	01H DUP (?)
logger_init_flg DD 01H DUP (?)
	ALIGN	8

logger_buffer DQ 01H DUP (?)
logger_bufsize DD 01H DUP (?)
logger_currmsg DD 01H DUP (?)
logger_wrapped DD 01H DUP (?)
logger_active DD 01H DUP (?)
logger_syslog DQ 02H DUP (?)
logger_hrdcpy DQ 01H DUP (?)
logger_hrdcpyfd DD 01H DUP (?)
logger_filename DB 0104H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$logger_init DD imagerel $LN21
	DD	imagerel $LN21+1520
	DD	imagerel $unwind$logger_init
$pdata$log_read DD imagerel $LN16
	DD	imagerel $LN16+421
	DD	imagerel $unwind$log_read
$pdata$log_line DD imagerel $LN21
	DD	imagerel $LN21+550
	DD	imagerel $unwind$log_line
$pdata$log_sethrdcpy DD imagerel $LN14
	DD	imagerel $LN14+961
	DD	imagerel $unwind$log_sethrdcpy
$pdata$log_wakeup DD imagerel $LN7
	DD	imagerel $LN7+86
	DD	imagerel $unwind$log_wakeup
$pdata$log_dsphrdcpy DD imagerel $LN5
	DD	imagerel $LN5+85
	DD	imagerel $unwind$log_dsphrdcpy
$pdata$logger_timestamped_logfile_write DD imagerel $LN6
	DD	imagerel $LN6+95
	DD	imagerel $unwind$logger_timestamped_logfile_write
$pdata$logger_logfile_write DD imagerel logger_logfile_write
	DD	imagerel logger_logfile_write+157
	DD	imagerel $unwind$logger_logfile_write
$pdata$logger_logfile_timestamp DD imagerel logger_logfile_timestamp
	DD	imagerel logger_logfile_timestamp+398
	DD	imagerel $unwind$logger_logfile_timestamp
$pdata$logger_thread DD imagerel logger_thread
	DD	imagerel logger_thread+1390
	DD	imagerel $unwind$logger_thread
pdata	ENDS
_DATA	SEGMENT
$SG168138 DB	'logger.c:88', 00H
?dostamp@?M@??logger_thread@@9@9 DB 01H			; `logger_thread'::`12'::dostamp
	ORG $+3
$SG168141 DB	'logger.c:94', 00H
$SG168254 DB	'E', 00H
	ORG $+2
$SG168142 DB	'logger.c:100', 00H
	ORG $+3
$SG168150 DB	'logger.c:129', 00H
	ORG $+3
$SG168245 DB	'logger.c:319', 00H
	ORG $+3
$SG168246 DB	'logger.c:324', 00H
	ORG $+3
$SG168247 DB	'logger.c:326', 00H
	ORG $+3
$SG168251 DB	'logger.c:353', 00H
	ORG $+3
$SG168253 DB	'read_pipe()', 00H
$SG168279 DB	'I', 00H
	ORG $+2
$SG168255 DB	'HHC02102%s Logger: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168256 DB	'logger.c:362', 00H
	ORG $+3
$SG168260 DB	'logger.c:383', 00H
	ORG $+3
$SG168270 DB	'logger.c:430', 00H
	ORG $+3
$SG168272 DB	'logger.c:442', 00H
	ORG $+3
$SG168273 DB	'logger.c:444', 00H
	ORG $+3
$SG168274 DB	'logger.c:446', 00H
	ORG $+3
$SG168275 DB	'logger.c:454', 00H
	ORG $+3
$SG168277 DB	'logger_thread', 00H
	ORG $+2
$SG168278 DB	'logger.c:462', 00H
	ORG $+3
$SG168280 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG168281 DB	'logger.c:472', 00H
	ORG $+3
$SG168282 DB	'logger.c:474', 00H
	ORG $+3
$SG168290 DB	'logger.c:483', 00H
	ORG $+3
$SG168291 DB	'logger.c:484', 00H
	ORG $+3
$SG168292 DB	'&logger_lock', 00H
	ORG $+3
$SG168293 DB	'logger.c:487', 00H
	ORG $+3
$SG168299 DB	'STDOUT redirected from command line', 00H
$SG168301 DB	'dup2()', 00H
	ORG $+1
$SG168302 DB	'E', 00H
	ORG $+2
$SG168303 DB	'HHC02102%s Logger: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168306 DB	'STDOUT redirected from command line', 00H
$SG168308 DB	'dup2()', 00H
	ORG $+1
$SG168309 DB	'E', 00H
	ORG $+2
$SG168310 DB	'HHC02102%s Logger: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168312 DB	'STDERR redirected from command line', 00H
$SG168314 DB	'dup2()', 00H
	ORG $+1
$SG168315 DB	'E', 00H
	ORG $+2
$SG168316 DB	'HHC02102%s Logger: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168318 DB	'dup()', 00H
	ORG $+2
$SG168319 DB	'E', 00H
	ORG $+2
$SG168323 DB	'w', 00H
	ORG $+2
$SG168320 DB	'HHC02102%s Logger: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168324 DB	'fdopen()', 00H
	ORG $+3
$SG168325 DB	'E', 00H
	ORG $+2
$SG168326 DB	'HHC02102%s Logger: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168328 DB	'a', 00H
	ORG $+2
$SG168329 DB	'LOG', 00H
$SG168331 DB	'malloc(%d)', 00H
	ORG $+1
$SG168332 DB	'E', 00H
	ORG $+2
$SG168333 DB	'HHC02102%s Logger: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168335 DB	'create_pipe()', 00H
	ORG $+2
$SG168336 DB	'E', 00H
	ORG $+2
$SG168341 DB	'E', 00H
	ORG $+2
$SG168337 DB	'HHC02102%s Logger: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168338 DB	'logger.c:585', 00H
	ORG $+3
$SG168339 DB	'logger_thread', 00H
	ORG $+2
$SG168342 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG168368 DB	'E', 00H
	ORG $+2
$SG168343 DB	'logger.c:593', 00H
	ORG $+3
$SG168344 DB	'logger.c:595', 00H
	ORG $+3
?pzbuf@?1??log_dsphrdcpy@@9@9 DQ FLAT:?buf@?1??log_dsphrdcpy@@9@9 ; `log_dsphrdcpy'::`2'::pzbuf
$SG168353 DB	'''%s''', 00H
	ORG $+3
$SG168369 DB	'HHC02100%s Logger: log not active', 0aH, 00H
	ORG $+1
$SG168374 DB	'I', 00H
	ORG $+2
$SG168370 DB	'log_sethrdcpy', 00H
	ORG $+2
$SG168371 DB	'logger.c', 00H
	ORG $+3
$SG168376 DB	'I', 00H
	ORG $+2
$SG168372 DB	'logger.c:628', 00H
	ORG $+3
$SG168373 DB	'logger.c:634', 00H
	ORG $+3
$SG168375 DB	'HHC02101%s Logger: log closed', 0aH, 00H
	ORG $+1
$SG168377 DB	'HHC02101%s Logger: log closed', 0aH, 00H
	ORG $+1
$SG168378 DB	'log_sethrdcpy', 00H
	ORG $+2
$SG168379 DB	'logger.c', 00H
	ORG $+3
$SG168382 DB	'open()', 00H
	ORG $+1
$SG168383 DB	'E', 00H
	ORG $+2
$SG168384 DB	'HHC02102%s Logger: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168385 DB	'log_sethrdcpy', 00H
	ORG $+2
$SG168386 DB	'logger.c', 00H
	ORG $+3
$SG168389 DB	'w', 00H
	ORG $+2
$SG168390 DB	'fdopen()', 00H
	ORG $+3
$SG168391 DB	'E', 00H
	ORG $+2
$SG168392 DB	'HHC02102%s Logger: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG168393 DB	'log_sethrdcpy', 00H
	ORG $+2
$SG168394 DB	'logger.c', 00H
	ORG $+3
$SG168401 DB	'I', 00H
	ORG $+2
$SG168395 DB	'logger.c:679', 00H
	ORG $+3
$SG168396 DB	'logger.c:687', 00H
	ORG $+3
$SG168400 DB	'''%s''', 00H
	ORG $+3
$SG168402 DB	'HHC02104%s Logger: log switched to %s', 0aH, 00H
	ORG $+1
$SG168410 DB	'logger.c:720', 00H
	ORG $+3
$SG168411 DB	'logger.c:722', 00H
	ORG $+3
$SG168412 DB	'logger.c:724', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:logger_thread
	DD	016H
	DD	0556H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:logger_logfile_timestamp
	DD	0eH
	DD	017cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:log_sethrdcpy
	DD	017H
	DD	03a8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:logger_init
	DD	011H
	DD	05d8H
voltbl	ENDS
xdata	SEGMENT
$unwind$logger_init DD 021919H
	DD	0170107H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$log_read DD 011301H
	DD	06213H
$unwind$log_line DD 010801H
	DD	0c208H
$unwind$log_sethrdcpy DD 031f19H
	DD	056010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	02a0H
$unwind$log_wakeup DD 010901H
	DD	04209H
$unwind$log_dsphrdcpy DD 010401H
	DD	04204H
$unwind$logger_timestamped_logfile_write DD 010e01H
	DD	0420eH
$unwind$logger_logfile_write DD 010e01H
	DD	0620eH
$unwind$logger_logfile_timestamp DD 011319H
	DD	0c204H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$logger_thread DD 021e19H
	DD	023010cH
	DD	imagerel __GSHandlerCheck
	DD	0100H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logger.c
_TEXT	SEGMENT
nLeft$1 = 64
bytes_read$ = 68
nRight$2 = 72
tv82 = 76
read_pipe_errno$3 = 80
nLeft2$4 = 84
pLeft$5 = 88
tv220 = 96
pNL$6 = 104
pRight$7 = 112
pLeft2$8 = 120
buf$9 = 128
__$ArrayPad$ = 256
arg$ = 288
logger_thread PROC

; 308  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@logger_thr:

; 309  :     int bytes_read;
; 310  : 
; 311  :     UNREFERENCED( arg );

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN4@logger_thr

; 312  : 
; 313  : #if !defined( _MSVC_ )
; 314  :     logger_redirect();
; 315  : #endif
; 316  : 
; 317  :     setvbuf( stdout, NULL, _IONBF, 0 );

  00024	b9 01 00 00 00	 mov	 ecx, 1
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002f	45 33 c9	 xor	 r9d, r9d
  00032	41 b8 04 00 00
	00		 mov	 r8d, 4
  00038	33 d2		 xor	 edx, edx
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf

; 318  : 
; 319  :     obtain_lock( &logger_lock );

  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168245
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  00051	e8 00 00 00 00	 call	 hthread_obtain_lock

; 320  :     {
; 321  :         logger_active = 1;

  00056	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR logger_active, 1

; 322  : 
; 323  :         /* Signal initialization complete */
; 324  :         signal_condition( &logger_cond );

  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168246
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_cond
  0006e	e8 00 00 00 00	 call	 hthread_signal_condition

; 325  :     }
; 326  :     release_lock( &logger_lock );

  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168247
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  00081	e8 00 00 00 00	 call	 hthread_release_lock
$LN31@logger_thr:
$LN30@logger_thr:
$LN5@logger_thr:

; 327  : 
; 328  :     /* This read causes logger to exit when the write end is closed */
; 329  :     while
; 330  :     (
; 331  :         (bytes_read =

  00086	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR logger_currmsg
  0008c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR logger_bufsize
  00092	2b c8		 sub	 ecx, eax
  00094	8b c1		 mov	 eax, ecx
  00096	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  0009b	7d 16		 jge	 SHORT $LN28@logger_thr
  0009d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR logger_currmsg
  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR logger_bufsize
  000a9	2b c8		 sub	 ecx, eax
  000ab	8b c1		 mov	 eax, ecx
  000ad	89 44 24 4c	 mov	 DWORD PTR tv82[rsp], eax
  000b1	eb 08		 jmp	 SHORT $LN29@logger_thr
$LN28@logger_thr:
  000b3	c7 44 24 4c 00
	00 10 00	 mov	 DWORD PTR tv82[rsp], 1048576 ; 00100000H
$LN29@logger_thr:
  000bb	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR logger_currmsg
  000c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR logger_buffer
  000c9	48 03 c8	 add	 rcx, rax
  000cc	48 8b c1	 mov	 rax, rcx
  000cf	b9 04 00 00 00	 mov	 ecx, 4
  000d4	48 6b c9 00	 imul	 rcx, rcx, 0
  000d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:logger_syslogfd
  000df	48 63 0c 0a	 movsxd	 rcx, DWORD PTR [rdx+rcx]
  000e3	45 33 c9	 xor	 r9d, r9d
  000e6	44 8b 44 24 4c	 mov	 r8d, DWORD PTR tv82[rsp]
  000eb	48 8b d0	 mov	 rdx, rax
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  000f4	89 44 24 44	 mov	 DWORD PTR bytes_read$[rsp], eax
  000f8	83 7c 24 44 00	 cmp	 DWORD PTR bytes_read$[rsp], 0
  000fd	0f 84 38 03 00
	00		 je	 $LN6@logger_thr

; 332  :             read_pipe   // read the maximum amount possible
; 333  :             (
; 334  :                 logger_syslogfd[ LOG_READ ],
; 335  :                  (logger_buffer  + logger_currmsg),
; 336  :                 ((logger_bufsize - logger_currmsg) < LOG_DEFSIZE ?
; 337  :                  (logger_bufsize - logger_currmsg) : LOG_DEFSIZE)
; 338  :             )
; 339  :         )
; 340  :     )
; 341  :     {
; 342  :         if (bytes_read < 0)

  00103	83 7c 24 44 00	 cmp	 DWORD PTR bytes_read$[rsp], 0
  00108	0f 8d 9c 00 00
	00		 jge	 $LN9@logger_thr

; 343  :         {
; 344  :             int read_pipe_errno = HSO_errno;

  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00114	89 44 24 50	 mov	 DWORD PTR read_pipe_errno$3[rsp], eax

; 345  : 
; 346  :             /* Ignore any/all errors during shutdown */
; 347  :             if (sysblk.shutdown)

  00118	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011f	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00125	c1 e8 0b	 shr	 eax, 11
  00128	83 e0 01	 and	 eax, 1
  0012b	85 c0		 test	 eax, eax
  0012d	74 05		 je	 SHORT $LN10@logger_thr

; 348  :                 continue;

  0012f	e9 52 ff ff ff	 jmp	 $LN5@logger_thr
$LN10@logger_thr:

; 349  : 
; 350  :             if (HSO_EINTR == read_pipe_errno)

  00134	81 7c 24 50 14
	27 00 00	 cmp	 DWORD PTR read_pipe_errno$3[rsp], 10004 ; 00002714H
  0013c	75 05		 jne	 SHORT $LN11@logger_thr

; 351  :                 continue;

  0013e	e9 43 ff ff ff	 jmp	 $LN30@logger_thr
$LN11@logger_thr:

; 352  : 
; 353  :             obtain_lock( &logger_lock );

  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168251
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  00151	e8 00 00 00 00	 call	 hthread_obtain_lock

; 354  :             {
; 355  :                 if (logger_hrdcpy)

  00156	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR logger_hrdcpy, 0
  0015e	74 2f		 je	 SHORT $LN12@logger_thr

; 356  :                 {
; 357  :                     // "Logger: error in function %s: %s"
; 358  :                     fprintf( logger_hrdcpy, MSG( HHC02102, "E",

  00160	8b 4c 24 50	 mov	 ecx, DWORD PTR read_pipe_errno$3[rsp]
  00164	e8 00 00 00 00	 call	 w32_strerror
  00169	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168253
  00175	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168254
  0017c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168255
  00183	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR logger_hrdcpy
  0018a	e8 00 00 00 00	 call	 w32_fprintf
$LN12@logger_thr:

; 359  :                         "read_pipe()", strerror( read_pipe_errno )));
; 360  :                 }
; 361  :             }
; 362  :             release_lock( &logger_lock );

  0018f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168256
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  0019d	e8 00 00 00 00	 call	 hthread_release_lock

; 363  : 
; 364  :             bytes_read = 0;

  001a2	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR bytes_read$[rsp], 0
$LN9@logger_thr:

; 365  :         }
; 366  : 
; 367  :         /* If Hercules is not running in daemon mode and panel
; 368  :            initialization is not yet complete, write message
; 369  :            to stderr so the user can see it on the terminal */
; 370  :         if (!sysblk.daemon_mode)

  001aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b1	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  001b7	c1 e8 02	 shr	 eax, 2
  001ba	83 e0 01	 and	 eax, 1
  001bd	85 c0		 test	 eax, eax
  001bf	75 65		 jne	 SHORT $LN13@logger_thr

; 371  :         {
; 372  :             if (!sysblk.panel_init)

  001c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c8	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  001ce	c1 e8 03	 shr	 eax, 3
  001d1	83 e0 01	 and	 eax, 1
  001d4	85 c0		 test	 eax, eax
  001d6	75 4e		 jne	 SHORT $LN14@logger_thr

; 373  :             {
; 374  :                 char* pLeft2 = logger_buffer + logger_currmsg;

  001d8	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR logger_currmsg
  001df	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR logger_buffer
  001e6	48 03 c8	 add	 rcx, rax
  001e9	48 8b c1	 mov	 rax, rcx
  001ec	48 89 44 24 78	 mov	 QWORD PTR pLeft2$8[rsp], rax

; 375  :                 int   nLeft2 = bytes_read;

  001f1	8b 44 24 44	 mov	 eax, DWORD PTR bytes_read$[rsp]
  001f5	89 44 24 54	 mov	 DWORD PTR nLeft2$4[rsp], eax

; 376  : 
; 377  :                 /* (ignore any errors; we did the best we could) */
; 378  :                 if (nLeft2)

  001f9	83 7c 24 54 00	 cmp	 DWORD PTR nLeft2$4[rsp], 0
  001fe	74 26		 je	 SHORT $LN15@logger_thr

; 379  :                     fwrite( pLeft2, nLeft2, 1, stderr );

  00200	b9 02 00 00 00	 mov	 ecx, 2
  00205	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0020b	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR nLeft2$4[rsp]
  00210	4c 8b c8	 mov	 r9, rax
  00213	41 b8 01 00 00
	00		 mov	 r8d, 1
  00219	48 8b d1	 mov	 rdx, rcx
  0021c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLeft2$8[rsp]
  00221	e8 00 00 00 00	 call	 w32_fwrite
$LN15@logger_thr:
$LN14@logger_thr:
$LN13@logger_thr:

; 380  :             }
; 381  :         }
; 382  : 
; 383  :         obtain_lock( &logger_lock );

  00226	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168260
  0022d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  00234	e8 00 00 00 00	 call	 hthread_obtain_lock

; 384  :         {
; 385  :             /* Write log data to hardcopy file */
; 386  :             if (logger_hrdcpy)

  00239	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR logger_hrdcpy, 0
  00241	0f 84 6d 01 00
	00		 je	 $LN16@logger_thr

; 387  :             {
; 388  :                 /* Prefix each line with a date/time stamp if needed */
; 389  : 
; 390  :                 static bool dostamp = true; // (MAYBE!)
; 391  :                 char*  pLeft  = logger_buffer + logger_currmsg;

  00247	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR logger_currmsg
  0024e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR logger_buffer
  00255	48 03 c8	 add	 rcx, rax
  00258	48 8b c1	 mov	 rax, rcx
  0025b	48 89 44 24 58	 mov	 QWORD PTR pLeft$5[rsp], rax

; 392  :                 int    nLeft  = bytes_read;

  00260	8b 44 24 44	 mov	 eax, DWORD PTR bytes_read$[rsp]
  00264	89 44 24 40	 mov	 DWORD PTR nLeft$1[rsp], eax

; 393  :                 char*  pRight = NULL;

  00268	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR pRight$7[rsp], 0

; 394  :                 int    nRight = 0;

  00271	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR nRight$2[rsp], 0

; 395  :                 char*  pNL    = NULL;   /* (pointer to NEWLINE character) */

  00279	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR pNL$6[rsp], 0

; 396  : 
; 397  :                 if (dostamp)

  00282	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?dostamp@?M@??logger_thread@@9@9
  00289	85 c0		 test	 eax, eax
  0028b	74 3a		 je	 SHORT $LN17@logger_thr

; 398  :                 {
; 399  :                     if (STAMPLOG)

  0028d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00294	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0029a	c1 e8 17	 shr	 eax, 23
  0029d	83 e0 01	 and	 eax, 1
  002a0	85 c0		 test	 eax, eax
  002a2	74 17		 je	 SHORT $LN19@logger_thr
  002a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002ab	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  002b1	c1 e8 16	 shr	 eax, 22
  002b4	83 e0 01	 and	 eax, 1
  002b7	85 c0		 test	 eax, eax
  002b9	75 05		 jne	 SHORT $LN18@logger_thr
$LN19@logger_thr:

; 400  :                         logger_logfile_timestamp();

  002bb	e8 00 00 00 00	 call	 logger_logfile_timestamp
$LN18@logger_thr:

; 401  :                     dostamp = false;

  002c0	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?dostamp@?M@??logger_thread@@9@9, 0
$LN17@logger_thr:
$LN7@logger_thr:

; 402  :                 }
; 403  : 
; 404  :                 while ((pNL = memchr( pLeft, '\n', nLeft )) != NULL)

  002c7	48 63 44 24 40	 movsxd	 rax, DWORD PTR nLeft$1[rsp]
  002cc	4c 8b c0	 mov	 r8, rax
  002cf	ba 0a 00 00 00	 mov	 edx, 10
  002d4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLeft$5[rsp]
  002d9	e8 00 00 00 00	 call	 memchr
  002de	48 89 44 24 68	 mov	 QWORD PTR pNL$6[rsp], rax
  002e3	48 83 7c 24 68
	00		 cmp	 QWORD PTR pNL$6[rsp], 0
  002e9	0f 84 ac 00 00
	00		 je	 $LN8@logger_thr

; 405  :                 {
; 406  :                     pRight  = pNL + 1;

  002ef	48 8b 44 24 68	 mov	 rax, QWORD PTR pNL$6[rsp]
  002f4	48 ff c0	 inc	 rax
  002f7	48 89 44 24 70	 mov	 QWORD PTR pRight$7[rsp], rax

; 407  :                     nRight  = nLeft - ((int)(pRight - pLeft));

  002fc	48 8b 44 24 58	 mov	 rax, QWORD PTR pLeft$5[rsp]
  00301	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pRight$7[rsp]
  00306	48 2b c8	 sub	 rcx, rax
  00309	48 8b c1	 mov	 rax, rcx
  0030c	8b 4c 24 40	 mov	 ecx, DWORD PTR nLeft$1[rsp]
  00310	2b c8		 sub	 ecx, eax
  00312	8b c1		 mov	 eax, ecx
  00314	89 44 24 48	 mov	 DWORD PTR nRight$2[rsp], eax

; 408  :                     nLeft  -= nRight;

  00318	8b 44 24 48	 mov	 eax, DWORD PTR nRight$2[rsp]
  0031c	8b 4c 24 40	 mov	 ecx, DWORD PTR nLeft$1[rsp]
  00320	2b c8		 sub	 ecx, eax
  00322	8b c1		 mov	 eax, ecx
  00324	89 44 24 40	 mov	 DWORD PTR nLeft$1[rsp], eax

; 409  : 
; 410  :                     if (nLeft)

  00328	83 7c 24 40 00	 cmp	 DWORD PTR nLeft$1[rsp], 0
  0032d	74 12		 je	 SHORT $LN20@logger_thr

; 411  :                         logger_logfile_write( pLeft, nLeft );

  0032f	48 63 44 24 40	 movsxd	 rax, DWORD PTR nLeft$1[rsp]
  00334	48 8b d0	 mov	 rdx, rax
  00337	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLeft$5[rsp]
  0033c	e8 00 00 00 00	 call	 logger_logfile_write
$LN20@logger_thr:

; 412  : 
; 413  :                     pLeft = pRight;

  00341	48 8b 44 24 70	 mov	 rax, QWORD PTR pRight$7[rsp]
  00346	48 89 44 24 58	 mov	 QWORD PTR pLeft$5[rsp], rax

; 414  :                     nLeft = nRight;

  0034b	8b 44 24 48	 mov	 eax, DWORD PTR nRight$2[rsp]
  0034f	89 44 24 40	 mov	 DWORD PTR nLeft$1[rsp], eax

; 415  : 
; 416  :                     if (!nLeft)

  00353	83 7c 24 40 00	 cmp	 DWORD PTR nLeft$1[rsp], 0
  00358	75 09		 jne	 SHORT $LN21@logger_thr

; 417  :                     {
; 418  :                         dostamp = true;

  0035a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?dostamp@?M@??logger_thread@@9@9, 1

; 419  :                         break;

  00361	eb 38		 jmp	 SHORT $LN8@logger_thr
$LN21@logger_thr:

; 420  :                     }
; 421  : 
; 422  :                     if (STAMPLOG)

  00363	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0036a	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00370	c1 e8 17	 shr	 eax, 23
  00373	83 e0 01	 and	 eax, 1
  00376	85 c0		 test	 eax, eax
  00378	74 17		 je	 SHORT $LN23@logger_thr
  0037a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00381	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00387	c1 e8 16	 shr	 eax, 22
  0038a	83 e0 01	 and	 eax, 1
  0038d	85 c0		 test	 eax, eax
  0038f	75 05		 jne	 SHORT $LN22@logger_thr
$LN23@logger_thr:

; 423  :                         logger_logfile_timestamp();

  00391	e8 00 00 00 00	 call	 logger_logfile_timestamp
$LN22@logger_thr:

; 424  :                 }

  00396	e9 2c ff ff ff	 jmp	 $LN7@logger_thr
$LN8@logger_thr:

; 425  : 
; 426  :                 if (nLeft)

  0039b	83 7c 24 40 00	 cmp	 DWORD PTR nLeft$1[rsp], 0
  003a0	74 12		 je	 SHORT $LN24@logger_thr

; 427  :                     logger_logfile_write( pLeft, nLeft );

  003a2	48 63 44 24 40	 movsxd	 rax, DWORD PTR nLeft$1[rsp]
  003a7	48 8b d0	 mov	 rdx, rax
  003aa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLeft$5[rsp]
  003af	e8 00 00 00 00	 call	 logger_logfile_write
$LN24@logger_thr:
$LN16@logger_thr:

; 428  :             }
; 429  :         }
; 430  :         release_lock( &logger_lock );

  003b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168270
  003bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  003c2	e8 00 00 00 00	 call	 hthread_release_lock

; 431  : 
; 432  :         /* Increment buffer index to next available position */
; 433  :         logger_currmsg += bytes_read;

  003c7	8b 44 24 44	 mov	 eax, DWORD PTR bytes_read$[rsp]
  003cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR logger_currmsg
  003d1	03 c8		 add	 ecx, eax
  003d3	8b c1		 mov	 eax, ecx
  003d5	89 05 00 00 00
	00		 mov	 DWORD PTR logger_currmsg, eax

; 434  : 
; 435  :         if (logger_currmsg >= logger_bufsize)

  003db	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR logger_bufsize
  003e1	39 05 00 00 00
	00		 cmp	 DWORD PTR logger_currmsg, eax
  003e7	7c 14		 jl	 SHORT $LN25@logger_thr

; 436  :         {
; 437  :             logger_currmsg = 0;

  003e9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR logger_currmsg, 0

; 438  :             logger_wrapped = 1;

  003f3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR logger_wrapped, 1
$LN25@logger_thr:

; 439  :         }
; 440  : 
; 441  :         /* Notify all interested parties new log data is available */
; 442  :         obtain_lock( &logger_lock );

  003fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168272
  00404	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  0040b	e8 00 00 00 00	 call	 hthread_obtain_lock

; 443  :         {
; 444  :             broadcast_condition( &logger_cond );

  00410	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168273
  00417	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_cond
  0041e	e8 00 00 00 00	 call	 hthread_broadcast_condition

; 445  :         }
; 446  :         release_lock( &logger_lock );

  00423	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168274
  0042a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  00431	e8 00 00 00 00	 call	 hthread_release_lock

; 447  : 
; 448  :     } /* end while (...) */

  00436	e9 4b fc ff ff	 jmp	 $LN31@logger_thr
$LN6@logger_thr:

; 449  : 
; 450  :     logger_active = 0;

  0043b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR logger_active, 0

; 451  :     sysblk.loggertid = 0;

  00445	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0044c	c7 80 dc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+220], 0

; 452  : 
; 453  :     /* Logger is now terminating */
; 454  :     obtain_lock( &logger_lock );

  00456	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168275
  0045d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  00464	e8 00 00 00 00	 call	 hthread_obtain_lock

; 455  :     {
; 456  :         /* Write final message to hardcopy file */
; 457  :         if (logger_hrdcpy)

  00469	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR logger_hrdcpy, 0
  00471	74 71		 je	 SHORT $LN26@logger_thr

; 458  :         {
; 459  :             char buf[128];
; 460  :             // "Thread id "TIDPAT", prio %2d, name %s ended"
; 461  :             MSGBUF( buf, MSG( HHC00101, "I", TID_CAST( thread_id()),

  00473	e8 00 00 00 00	 call	 fthread_self
  00478	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168278
  0047f	8b c8		 mov	 ecx, eax
  00481	e8 00 00 00 00	 call	 hthread_get_thread_prio
  00486	89 44 24 60	 mov	 DWORD PTR tv220[rsp], eax
  0048a	e8 00 00 00 00	 call	 fthread_self
  0048f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168277
  00496	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0049b	8b 4c 24 60	 mov	 ecx, DWORD PTR tv220[rsp]
  0049f	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  004a3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  004a7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168279
  004ae	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168280
  004b5	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  004ba	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$9[rsp]
  004c2	e8 00 00 00 00	 call	 w32_snprintf

; 462  :                 get_thread_priority(), LOGGER_THREAD_NAME ));
; 463  :             logger_timestamped_logfile_write( buf, strlen( buf ));

  004c7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$9[rsp]
  004cf	e8 00 00 00 00	 call	 strlen
  004d4	48 8b d0	 mov	 rdx, rax
  004d7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$9[rsp]
  004df	e8 00 00 00 00	 call	 logger_timestamped_logfile_write
$LN26@logger_thr:

; 464  :         }
; 465  : 
; 466  :         /* Redirect all msgs to stderr */
; 467  :         logger_syslog   [ LOG_WRITE ] = stderr;

  004e4	b9 02 00 00 00	 mov	 ecx, 2
  004e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004ef	b9 08 00 00 00	 mov	 ecx, 8
  004f4	48 6b c9 01	 imul	 rcx, rcx, 1
  004f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:logger_syslog
  004ff	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 468  :         logger_syslogfd [ LOG_WRITE ] = STDERR_FILENO;

  00503	b8 04 00 00 00	 mov	 eax, 4
  00508	48 6b c0 01	 imul	 rax, rax, 1
  0050c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_syslogfd
  00513	c7 04 01 02 00
	00 00		 mov	 DWORD PTR [rcx+rax], 2

; 469  :         fflush( stderr );

  0051a	b9 02 00 00 00	 mov	 ecx, 2
  0051f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00525	48 8b c8	 mov	 rcx, rax
  00528	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 470  : 
; 471  :         /* Signal any waiting tasks */
; 472  :         broadcast_condition( &logger_cond );

  0052e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168281
  00535	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_cond
  0053c	e8 00 00 00 00	 call	 hthread_broadcast_condition

; 473  :     }
; 474  :     release_lock( &logger_lock );

  00541	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168282
  00548	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  0054f	e8 00 00 00 00	 call	 hthread_release_lock

; 475  : 
; 476  :     return NULL;

  00554	33 c0		 xor	 eax, eax

; 477  : }

  00556	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0055e	48 33 cc	 xor	 rcx, rsp
  00561	e8 00 00 00 00	 call	 __security_check_cookie
  00566	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0056d	c3		 ret	 0
logger_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logger.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
stamp$3 = 48
__$ArrayPad$ = 80
logger_logfile_timestamp PROC

; 267  : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000b	48 33 c4	 xor	 rax, rsp
  0000e	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 268  :     if (!extgui) // FIXME! (see above)

  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  0001a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0001d	0f 85 59 01 00
	00		 jne	 $LN2@logger_log

; 269  :     {
; 270  :         char stamp[32];     // "YYYY-MM-DD HH:MM:SS.uuuuuu"
; 271  : 
; 272  :         FormatTIMEVAL( NULL, stamp, sizeof( stamp ));

  00023	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00029	48 8d 54 24 30	 lea	 rdx, QWORD PTR stamp$3[rsp]
  0002e	33 c9		 xor	 ecx, ecx
  00030	e8 00 00 00 00	 call	 FormatTIMEVAL

; 273  : 
; 274  :         stamp[19] = ' ';    // "YYYY-MM-DD HH:MM:SS uuuuuu"

  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 13	 imul	 rax, rax, 19
  0003e	c6 44 04 30 20	 mov	 BYTE PTR stamp$3[rsp+rax], 32 ; 00000020H

; 275  :         stamp[20] =  0;     // "YYYY-MM-DD HH:MM:SS "

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	48 6b c0 14	 imul	 rax, rax, 20
  0004c	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  00051	48 83 7c 24 20
	20		 cmp	 QWORD PTR $T1[rsp], 32	; 00000020H
  00057	73 02		 jae	 SHORT $LN10@logger_log
  00059	eb 05		 jmp	 SHORT $LN11@logger_log
$LN10@logger_log:
  0005b	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN11@logger_log:
  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR $T1[rsp]
  00065	c6 44 04 30 00	 mov	 BYTE PTR stamp$3[rsp+rax], 0

; 276  : 
; 277  :         if (DATESTAMPLOG && TIMESTAMPLOG)

  0006a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00071	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00077	c1 e8 16	 shr	 eax, 22
  0007a	83 e0 01	 and	 eax, 1
  0007d	85 c0		 test	 eax, eax
  0007f	75 33		 jne	 SHORT $LN3@logger_log
  00081	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00088	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0008e	c1 e8 17	 shr	 eax, 23
  00091	83 e0 01	 and	 eax, 1
  00094	85 c0		 test	 eax, eax
  00096	75 1c		 jne	 SHORT $LN3@logger_log

; 278  :         {
; 279  :             logger_logfile_write( stamp, strlen( stamp ));

  00098	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stamp$3[rsp]
  0009d	e8 00 00 00 00	 call	 strlen
  000a2	48 8b d0	 mov	 rdx, rax
  000a5	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stamp$3[rsp]
  000aa	e8 00 00 00 00	 call	 logger_logfile_write

; 280  :         }

  000af	e9 c8 00 00 00	 jmp	 $LN4@logger_log
$LN3@logger_log:

; 281  :         else if (DATESTAMPLOG && !TIMESTAMPLOG)

  000b4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000bb	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000c1	c1 e8 16	 shr	 eax, 22
  000c4	83 e0 01	 and	 eax, 1
  000c7	85 c0		 test	 eax, eax
  000c9	75 57		 jne	 SHORT $LN5@logger_log
  000cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d2	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000d8	c1 e8 17	 shr	 eax, 23
  000db	83 e0 01	 and	 eax, 1
  000de	85 c0		 test	 eax, eax
  000e0	74 40		 je	 SHORT $LN5@logger_log

; 282  :         {
; 283  :             stamp[11] = 0;  // "YYYY-MM-DD "

  000e2	b8 01 00 00 00	 mov	 eax, 1
  000e7	48 6b c0 0b	 imul	 rax, rax, 11
  000eb	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
  000f0	48 83 7c 24 28
	20		 cmp	 QWORD PTR $T2[rsp], 32	; 00000020H
  000f6	73 02		 jae	 SHORT $LN12@logger_log
  000f8	eb 05		 jmp	 SHORT $LN13@logger_log
$LN12@logger_log:
  000fa	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN13@logger_log:
  000ff	48 8b 44 24 28	 mov	 rax, QWORD PTR $T2[rsp]
  00104	c6 44 04 30 00	 mov	 BYTE PTR stamp$3[rsp+rax], 0

; 284  :             logger_logfile_write( stamp, strlen( stamp ));

  00109	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stamp$3[rsp]
  0010e	e8 00 00 00 00	 call	 strlen
  00113	48 8b d0	 mov	 rdx, rax
  00116	48 8d 4c 24 30	 lea	 rcx, QWORD PTR stamp$3[rsp]
  0011b	e8 00 00 00 00	 call	 logger_logfile_write

; 285  :         }

  00120	eb 5a		 jmp	 SHORT $LN6@logger_log
$LN5@logger_log:

; 286  :         else if (TIMESTAMPLOG && !DATESTAMPLOG)

  00122	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00129	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0012f	c1 e8 17	 shr	 eax, 23
  00132	83 e0 01	 and	 eax, 1
  00135	85 c0		 test	 eax, eax
  00137	75 43		 jne	 SHORT $LN7@logger_log
  00139	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00140	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00146	c1 e8 16	 shr	 eax, 22
  00149	83 e0 01	 and	 eax, 1
  0014c	85 c0		 test	 eax, eax
  0014e	74 2c		 je	 SHORT $LN7@logger_log

; 287  :         {
; 288  :             logger_logfile_write( &stamp[11], strlen( &stamp[11] ));

  00150	b8 01 00 00 00	 mov	 eax, 1
  00155	48 6b c0 0b	 imul	 rax, rax, 11
  00159	48 8d 44 04 30	 lea	 rax, QWORD PTR stamp$3[rsp+rax]
  0015e	48 8b c8	 mov	 rcx, rax
  00161	e8 00 00 00 00	 call	 strlen
  00166	b9 01 00 00 00	 mov	 ecx, 1
  0016b	48 6b c9 0b	 imul	 rcx, rcx, 11
  0016f	48 8d 4c 0c 30	 lea	 rcx, QWORD PTR stamp$3[rsp+rcx]
  00174	48 8b d0	 mov	 rdx, rax
  00177	e8 00 00 00 00	 call	 logger_logfile_write
$LN7@logger_log:
$LN6@logger_log:
$LN4@logger_log:
$LN2@logger_log:
$LN9@logger_log:

; 289  :         }
; 290  :         else // neither!
; 291  :         {
; 292  :             return;
; 293  :         }
; 294  :     }
; 295  : }

  0017c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00181	48 33 cc	 xor	 rcx, rsp
  00184	e8 00 00 00 00	 call	 __security_check_cookie
  00189	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018d	c3		 ret	 0
logger_logfile_timestamp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logger.c
_TEXT	SEGMENT
nLeft$ = 32
pLeft$ = 40
pBuff$ = 64
nBytes$ = 72
logger_logfile_write PROC

; 223  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 224  :     char* pLeft = (char*) pBuff;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR pBuff$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR pLeft$[rsp], rax

; 225  :     int   nLeft = (int)   nBytes;

  00018	8b 44 24 48	 mov	 eax, DWORD PTR nBytes$[rsp]
  0001c	89 44 24 20	 mov	 DWORD PTR nLeft$[rsp], eax

; 226  : 
; 227  :     /* daemon_mode only (wherein both stdout/stderr have both
; 228  :        been redirected): don't write to hardcopy during shutdown
; 229  :        to prevent duplicate messages from occurring when stderr
; 230  :        is redirected to stdout (or vice versa) via the command
; 231  :        line (e.g. 2>&1).
; 232  : 
; 233  :        The duplicate messages occur because during shutdown
; 234  :        all messages are issued to stderr and we redirect stderr
; 235  :        to stdout during shutdown.  This causes log messages
; 236  :        (written to stdout) to be written to the logfile as well
; 237  :        as to stderr too, which, due to our redirection, ends up
; 238  :        being written again to the very same (hardcopy) file.
; 239  :        The below test prevents this from happening.
; 240  :     */
; 241  :     if (nLeft && (!sysblk.daemon_mode || !sysblk.shutdown))

  00020	83 7c 24 20 00	 cmp	 DWORD PTR nLeft$[rsp], 0
  00025	74 4d		 je	 SHORT $LN2@logger_log
  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00034	c1 e8 02	 shr	 eax, 2
  00037	83 e0 01	 and	 eax, 1
  0003a	85 c0		 test	 eax, eax
  0003c	74 17		 je	 SHORT $LN3@logger_log
  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00045	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0004b	c1 e8 0b	 shr	 eax, 11
  0004e	83 e0 01	 and	 eax, 1
  00051	85 c0		 test	 eax, eax
  00053	75 1f		 jne	 SHORT $LN2@logger_log
$LN3@logger_log:

; 242  :     {
; 243  :         /* (ignore any errors; we did the best we could) */
; 244  :         fwrite( pLeft, nLeft, 1, logger_hrdcpy );

  00055	48 63 44 24 20	 movsxd	 rax, DWORD PTR nLeft$[rsp]
  0005a	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR logger_hrdcpy
  00061	41 b8 01 00 00
	00		 mov	 r8d, 1
  00067	48 8b d0	 mov	 rdx, rax
  0006a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLeft$[rsp]
  0006f	e8 00 00 00 00	 call	 w32_fwrite
$LN2@logger_log:

; 245  :     }
; 246  : 
; 247  :     if (sysblk.shutdown)

  00074	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00081	c1 e8 0b	 shr	 eax, 11
  00084	83 e0 01	 and	 eax, 1
  00087	85 c0		 test	 eax, eax
  00089	74 0d		 je	 SHORT $LN4@logger_log

; 248  :         fflush( logger_hrdcpy );

  0008b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR logger_hrdcpy
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush
$LN4@logger_log:

; 249  : }

  00098	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009c	c3		 ret	 0
logger_logfile_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logger.c
_TEXT	SEGMENT
pBuff$ = 48
nBytes$ = 56
logger_timestamped_logfile_write PROC

; 298  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 299  :     if (logger_hrdcpy)

  0000e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR logger_hrdcpy, 0
  00016	74 42		 je	 SHORT $LN2@logger_tim

; 300  :     {
; 301  :         if (STAMPLOG)

  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001f	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00025	c1 e8 17	 shr	 eax, 23
  00028	83 e0 01	 and	 eax, 1
  0002b	85 c0		 test	 eax, eax
  0002d	74 17		 je	 SHORT $LN4@logger_tim
  0002f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00036	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0003c	c1 e8 16	 shr	 eax, 22
  0003f	83 e0 01	 and	 eax, 1
  00042	85 c0		 test	 eax, eax
  00044	75 05		 jne	 SHORT $LN3@logger_tim
$LN4@logger_tim:

; 302  :             logger_logfile_timestamp();

  00046	e8 00 00 00 00	 call	 logger_logfile_timestamp
$LN3@logger_tim:

; 303  :         logger_logfile_write( pBuff, nBytes );

  0004b	48 8b 54 24 38	 mov	 rdx, QWORD PTR nBytes$[rsp]
  00050	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pBuff$[rsp]
  00055	e8 00 00 00 00	 call	 logger_logfile_write
$LN2@logger_tim:

; 304  :     }
; 305  : }

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
logger_timestamped_logfile_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logger.c
_TEXT	SEGMENT
logger_isactive PROC

; 731  :     return logger_active;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR logger_active

; 732  : }

  00006	c3		 ret	 0
logger_isactive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logger.c
_TEXT	SEGMENT
log_dsphrdcpy PROC

; 599  : {

$LN5:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 600  :     static char   buf[ MAX_PATH + 2 ];
; 601  :     static char*  pzbuf = buf;
; 602  : 
; 603  :     if (!strchr( logger_filename, SPACE ))

  00004	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_filename
  00010	e8 00 00 00 00	 call	 strchr
  00015	48 85 c0	 test	 rax, rax
  00018	75 10		 jne	 SHORT $LN2@log_dsphrd

; 604  :         pzbuf = logger_filename;

  0001a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:logger_filename
  00021	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?pzbuf@?1??log_dsphrdcpy@@9@9, rax
  00028	eb 1f		 jmp	 SHORT $LN3@log_dsphrd
$LN2@log_dsphrd:

; 605  :     else
; 606  :         MSGBUF( buf, "'%s'", logger_filename );

  0002a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:logger_filename
  00031	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168353
  00038	ba 06 01 00 00	 mov	 edx, 262		; 00000106H
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?buf@?1??log_dsphrdcpy@@9@9
  00044	e8 00 00 00 00	 call	 w32_snprintf
$LN3@log_dsphrd:

; 607  : 
; 608  :     return pzbuf;

  00049	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?pzbuf@?1??log_dsphrdcpy@@9@9

; 609  : }

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
log_dsphrdcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logger.c
_TEXT	SEGMENT
arg$ = 48
log_wakeup PROC

; 715  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@log_wakeup:

; 716  :     UNREFERENCED( arg );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@log_wakeup

; 717  : 
; 718  :     if (logger_init_flg)

  0000f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR logger_init_flg, 0
  00016	74 39		 je	 SHORT $LN5@log_wakeup

; 719  :     {
; 720  :         obtain_lock( &logger_lock );

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168410
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  00026	e8 00 00 00 00	 call	 hthread_obtain_lock

; 721  :         {
; 722  :             broadcast_condition( &logger_cond );

  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168411
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_cond
  00039	e8 00 00 00 00	 call	 hthread_broadcast_condition

; 723  :         }
; 724  :         release_lock( &logger_lock );

  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168412
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  0004c	e8 00 00 00 00	 call	 hthread_release_lock
$LN5@log_wakeup:

; 725  :     }
; 726  : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
log_wakeup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logger.c
_TEXT	SEGMENT
new_hrdcpyfd$1 = 80
old_hrdcpy$ = 88
new_hrdcpy$2 = 96
pzbuf$3 = 104
tv140 = 112
tv158 = 120
pathname$4 = 128
buf$5 = 400
__$ArrayPad$ = 672
filename$ = 704
log_sethrdcpy PROC

; 612  : {

$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec b0 02
	00 00		 sub	 rsp, 688		; 000002b0H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 613  :     FILE*  old_hrdcpy;
; 614  : 
; 615  :     /* If no filename specified then close the current logfile */
; 616  :     if (!filename)

  0001f	48 83 bc 24 c0
	02 00 00 00	 cmp	 QWORD PTR filename$[rsp], 0
  00028	0f 85 21 01 00
	00		 jne	 $LN2@log_sethrd

; 617  :     {
; 618  :         memset( logger_filename, 0, sizeof( logger_filename ));

  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:logger_filename
  00035	48 8b f8	 mov	 rdi, rax
  00038	33 c0		 xor	 eax, eax
  0003a	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  0003f	f3 aa		 rep stosb

; 619  : 
; 620  :         if (!logger_hrdcpy)

  00041	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR logger_hrdcpy, 0
  00049	75 4b		 jne	 SHORT $LN4@log_sethrd

; 621  :         {
; 622  :             // "Logger: log not active"
; 623  :             WRMSG( HHC02100, "E" );

  0004b	b9 01 00 00 00	 mov	 ecx, 1
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168368
  0005d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168369
  00069	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0006e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00073	41 b9 03 00 00
	00		 mov	 r9d, 3
  00079	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168370
  00080	ba 6f 02 00 00	 mov	 edx, 623		; 0000026fH
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168371
  0008c	e8 00 00 00 00	 call	 fwritemsg

; 624  :         }

  00091	e9 af 00 00 00	 jmp	 $LN5@log_sethrd
$LN4@log_sethrd:

; 625  :         else
; 626  :         {
; 627  :             /* Disable logging and close logfile */
; 628  :             obtain_lock( &logger_lock );

  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168372
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  000a4	e8 00 00 00 00	 call	 hthread_obtain_lock

; 629  :             {
; 630  :                 old_hrdcpy      = logger_hrdcpy;

  000a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR logger_hrdcpy
  000b0	48 89 44 24 58	 mov	 QWORD PTR old_hrdcpy$[rsp], rax

; 631  :                 logger_hrdcpy   = 0;

  000b5	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR logger_hrdcpy, 0

; 632  :                 logger_hrdcpyfd = 0;

  000c0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR logger_hrdcpyfd, 0

; 633  :             }
; 634  :             release_lock( &logger_lock );

  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168373
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  000d8	e8 00 00 00 00	 call	 hthread_release_lock

; 635  : 
; 636  :             // "Logger: log closed"
; 637  :             fprintf( old_hrdcpy, MSG( HHC02101, "I" ));

  000dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168374
  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168375
  000eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR old_hrdcpy$[rsp]
  000f0	e8 00 00 00 00	 call	 w32_fprintf

; 638  :             fclose(  old_hrdcpy );

  000f5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR old_hrdcpy$[rsp]
  000fa	e8 00 00 00 00	 call	 w32_fclose

; 639  : 
; 640  :             // "Logger: log closed"
; 641  :             WRMSG( HHC02101, "I" );

  000ff	b9 01 00 00 00	 mov	 ecx, 1
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168376
  00111	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168377
  0011d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00122	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00127	41 b9 03 00 00
	00		 mov	 r9d, 3
  0012d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168378
  00134	ba 81 02 00 00	 mov	 edx, 641		; 00000281H
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168379
  00140	e8 00 00 00 00	 call	 fwritemsg
$LN5@log_sethrd:

; 642  :         }
; 643  :         return;

  00145	e9 5e 02 00 00	 jmp	 $LN1@log_sethrd

; 644  :     }

  0014a	e9 59 02 00 00	 jmp	 $LN3@log_sethrd
$LN2@log_sethrd:

; 645  :     else
; 646  :     {
; 647  :         FILE*  new_hrdcpy;
; 648  :         int    new_hrdcpyfd;
; 649  :         char   pathname[ MAX_PATH ];
; 650  : 
; 651  :         /* Open the new logfile */
; 652  : 
; 653  :         hostpath( pathname, filename, sizeof( pathname ));

  0014f	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00155	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR filename$[rsp]
  0015d	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR pathname$4[rsp]
  00165	e8 00 00 00 00	 call	 hostpath

; 654  : 
; 655  :         memset( logger_filename, 0, sizeof( logger_filename ));

  0016a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:logger_filename
  00171	48 8b f8	 mov	 rdi, rax
  00174	33 c0		 xor	 eax, eax
  00176	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  0017b	f3 aa		 rep stosb

; 656  : 
; 657  :         new_hrdcpyfd = HOPEN( pathname,

  0017d	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  00183	ba 01 03 00 00	 mov	 edx, 769		; 00000301H
  00188	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR pathname$4[rsp]
  00190	e8 00 00 00 00	 call	 w32_hopen
  00195	89 44 24 50	 mov	 DWORD PTR new_hrdcpyfd$1[rsp], eax

; 658  :                 O_WRONLY | O_CREAT | O_TRUNC /* O_SYNC */,
; 659  :                 S_IRUSR  | S_IWUSR | S_IRGRP );
; 660  : 
; 661  :         if (new_hrdcpyfd < 0)

  00199	83 7c 24 50 00	 cmp	 DWORD PTR new_hrdcpyfd$1[rsp], 0
  0019e	7d 73		 jge	 SHORT $LN6@log_sethrd

; 662  :         {
; 663  :             // "Logger: error in function %s: %s"
; 664  :             WRMSG( HHC02102, "E","open()", strerror( errno ));

  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001a6	8b 08		 mov	 ecx, DWORD PTR [rax]
  001a8	e8 00 00 00 00	 call	 w32_strerror
  001ad	48 89 44 24 70	 mov	 QWORD PTR tv140[rsp], rax
  001b2	b9 01 00 00 00	 mov	 ecx, 1
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001bd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv140[rsp]
  001c2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168382
  001ce	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168383
  001da	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168384
  001e6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f0	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168385
  001fd	ba 98 02 00 00	 mov	 edx, 664		; 00000298H
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168386
  00209	e8 00 00 00 00	 call	 fwritemsg

; 665  :         }

  0020e	e9 95 01 00 00	 jmp	 $LN7@log_sethrd
$LN6@log_sethrd:

; 666  :         else
; 667  :         {
; 668  :             if (!(new_hrdcpy = fdopen( new_hrdcpyfd, "w" )))

  00213	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168389
  0021a	8b 4c 24 50	 mov	 ecx, DWORD PTR new_hrdcpyfd$1[rsp]
  0021e	e8 00 00 00 00	 call	 w32_fdopen
  00223	48 89 44 24 60	 mov	 QWORD PTR new_hrdcpy$2[rsp], rax
  00228	48 83 7c 24 60
	00		 cmp	 QWORD PTR new_hrdcpy$2[rsp], 0
  0022e	75 7d		 jne	 SHORT $LN8@log_sethrd

; 669  :             {
; 670  :                 // "Logger: error in function %s: %s"
; 671  :                 WRMSG( HHC02102,"E", "fdopen()", strerror( errno ));

  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00236	8b 08		 mov	 ecx, DWORD PTR [rax]
  00238	e8 00 00 00 00	 call	 w32_strerror
  0023d	48 89 44 24 78	 mov	 QWORD PTR tv158[rsp], rax
  00242	b9 01 00 00 00	 mov	 ecx, 1
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0024d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv158[rsp]
  00252	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168390
  0025e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00263	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168391
  0026a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0026f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168392
  00276	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0027b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00280	41 b9 03 00 00
	00		 mov	 r9d, 3
  00286	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168393
  0028d	ba 9f 02 00 00	 mov	 edx, 671		; 0000029fH
  00292	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168394
  00299	e8 00 00 00 00	 call	 fwritemsg

; 672  :                 close( new_hrdcpyfd );

  0029e	8b 4c 24 50	 mov	 ecx, DWORD PTR new_hrdcpyfd$1[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 673  :             }

  002a8	e9 fb 00 00 00	 jmp	 $LN9@log_sethrd
$LN8@log_sethrd:

; 674  :             else
; 675  :             {
; 676  :                 /* Set no buffering and switch to using new logfile */
; 677  :                 setvbuf( new_hrdcpy, NULL, _IONBF, 0 );

  002ad	45 33 c9	 xor	 r9d, r9d
  002b0	41 b8 04 00 00
	00		 mov	 r8d, 4
  002b6	33 d2		 xor	 edx, edx
  002b8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR new_hrdcpy$2[rsp]
  002bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf

; 678  : 
; 679  :                 obtain_lock( &logger_lock );

  002c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168395
  002ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  002d1	e8 00 00 00 00	 call	 hthread_obtain_lock

; 680  :                 {
; 681  :                     old_hrdcpy      = logger_hrdcpy;

  002d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR logger_hrdcpy
  002dd	48 89 44 24 58	 mov	 QWORD PTR old_hrdcpy$[rsp], rax

; 682  :                     logger_hrdcpy   = new_hrdcpy;

  002e2	48 8b 44 24 60	 mov	 rax, QWORD PTR new_hrdcpy$2[rsp]
  002e7	48 89 05 00 00
	00 00		 mov	 QWORD PTR logger_hrdcpy, rax

; 683  :                     logger_hrdcpyfd = new_hrdcpyfd;

  002ee	8b 44 24 50	 mov	 eax, DWORD PTR new_hrdcpyfd$1[rsp]
  002f2	89 05 00 00 00
	00		 mov	 DWORD PTR logger_hrdcpyfd, eax

; 684  : 
; 685  :                     STRLCPY( logger_filename, filename );

  002f8	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  002fe	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR filename$[rsp]
  00306	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_filename
  0030d	e8 00 00 00 00	 call	 strlcpy

; 686  :                 }
; 687  :                 release_lock( &logger_lock );

  00312	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168396
  00319	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  00320	e8 00 00 00 00	 call	 hthread_release_lock

; 688  : 
; 689  :                 /* Write a message in the old logfile indicating
; 690  :                    logging was switched to a different logfile,
; 691  :                    and then close the old logfile afterwards.
; 692  :                 */
; 693  :                 if (old_hrdcpy)

  00325	48 83 7c 24 58
	00		 cmp	 QWORD PTR old_hrdcpy$[rsp], 0
  0032b	74 7b		 je	 SHORT $LN10@log_sethrd

; 694  :                 {
; 695  :                     char buf[ MAX_PATH + 2 ];
; 696  :                     const char* pzbuf = buf;

  0032d	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR buf$5[rsp]
  00335	48 89 44 24 68	 mov	 QWORD PTR pzbuf$3[rsp], rax

; 697  : 
; 698  :                     /* Quote the filename if it contains any blanks */
; 699  :                     if (!strchr( filename, SPACE ))

  0033a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0033f	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  00347	e8 00 00 00 00	 call	 strchr
  0034c	48 85 c0	 test	 rax, rax
  0034f	75 0f		 jne	 SHORT $LN11@log_sethrd

; 700  :                         pzbuf = filename;

  00351	48 8b 84 24 c0
	02 00 00	 mov	 rax, QWORD PTR filename$[rsp]
  00359	48 89 44 24 68	 mov	 QWORD PTR pzbuf$3[rsp], rax
  0035e	eb 21		 jmp	 SHORT $LN12@log_sethrd
$LN11@log_sethrd:

; 701  :                     else
; 702  :                         MSGBUF( buf, "'%s'", filename );

  00360	4c 8b 8c 24 c0
	02 00 00	 mov	 r9, QWORD PTR filename$[rsp]
  00368	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168400
  0036f	ba 06 01 00 00	 mov	 edx, 262		; 00000106H
  00374	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR buf$5[rsp]
  0037c	e8 00 00 00 00	 call	 w32_snprintf
$LN12@log_sethrd:

; 703  : 
; 704  :                     // "Logger: log switched to %s"
; 705  :                     fprintf( old_hrdcpy, MSG( HHC02104, "I", pzbuf ));

  00381	4c 8b 4c 24 68	 mov	 r9, QWORD PTR pzbuf$3[rsp]
  00386	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168401
  0038d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168402
  00394	48 8b 4c 24 58	 mov	 rcx, QWORD PTR old_hrdcpy$[rsp]
  00399	e8 00 00 00 00	 call	 w32_fprintf

; 706  :                     fclose(  old_hrdcpy );

  0039e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR old_hrdcpy$[rsp]
  003a3	e8 00 00 00 00	 call	 w32_fclose
$LN10@log_sethrd:
$LN9@log_sethrd:
$LN7@log_sethrd:
$LN3@log_sethrd:
$LN1@log_sethrd:

; 707  :                 }
; 708  :             }
; 709  :         }
; 710  :     }
; 711  : }

  003a8	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003b0	48 33 cc	 xor	 rcx, rsp
  003b3	e8 00 00 00 00	 call	 __security_check_cookie
  003b8	48 81 c4 b0 02
	00 00		 add	 rsp, 688		; 000002b0H
  003bf	5f		 pop	 rdi
  003c0	c3		 ret	 0
log_sethrdcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logger.c
_TEXT	SEGMENT
i$ = 32
tv81 = 36
tv179 = 40
tv66 = 44
msglen$ = 48
tmpbuf$ = 56
msgidx$ = 64
msgbuf$ = 72
linenumber$ = 112
log_line PROC

; 154  : {

$LN21:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 155  : char *msgbuf[2] = {NULL, NULL}, *tmpbuf = NULL;

  00008	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR msgbuf$[rsp], 0
  00011	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR msgbuf$[rsp+8], 0
  0001a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tmpbuf$[rsp], 0

; 156  : int  msgidx[2] = { -1, -1 };

  00023	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR msgidx$[rsp], -1
  0002b	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR msgidx$[rsp+4], -1

; 157  : int  msglen[2] = {0, 0};

  00033	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR msglen$[rsp], 0
  0003b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR msglen$[rsp+4], 0

; 158  : int  i;
; 159  : 
; 160  :     if(!linenumber++)

  00043	8b 44 24 70	 mov	 eax, DWORD PTR linenumber$[rsp]
  00047	89 44 24 2c	 mov	 DWORD PTR tv66[rsp], eax
  0004b	8b 44 24 70	 mov	 eax, DWORD PTR linenumber$[rsp]
  0004f	ff c0		 inc	 eax
  00051	89 44 24 70	 mov	 DWORD PTR linenumber$[rsp], eax
  00055	83 7c 24 2c 00	 cmp	 DWORD PTR tv66[rsp], 0
  0005a	75 0b		 jne	 SHORT $LN13@log_line

; 161  :         return logger_currmsg;

  0005c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR logger_currmsg
  00062	e9 ba 01 00 00	 jmp	 $LN1@log_line
$LN13@log_line:
$LN4@log_line:

; 162  : 
; 163  :     /* Find the last two blocks in the log */
; 164  :     do {
; 165  :         msgidx[0] = msgidx[1];

  00067	b8 04 00 00 00	 mov	 eax, 4
  0006c	48 6b c0 01	 imul	 rax, rax, 1
  00070	b9 04 00 00 00	 mov	 ecx, 4
  00075	48 6b c9 00	 imul	 rcx, rcx, 0
  00079	8b 44 04 40	 mov	 eax, DWORD PTR msgidx$[rsp+rax]
  0007d	89 44 0c 40	 mov	 DWORD PTR msgidx$[rsp+rcx], eax

; 166  :         msgbuf[0] = msgbuf[1];

  00081	b8 08 00 00 00	 mov	 eax, 8
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	b9 08 00 00 00	 mov	 ecx, 8
  0008f	48 6b c9 00	 imul	 rcx, rcx, 0
  00093	48 8b 44 04 48	 mov	 rax, QWORD PTR msgbuf$[rsp+rax]
  00098	48 89 44 0c 48	 mov	 QWORD PTR msgbuf$[rsp+rcx], rax

; 167  :         msglen[0] = msglen[1];

  0009d	b8 04 00 00 00	 mov	 eax, 4
  000a2	48 6b c0 01	 imul	 rax, rax, 1
  000a6	b9 04 00 00 00	 mov	 ecx, 4
  000ab	48 6b c9 00	 imul	 rcx, rcx, 0
  000af	8b 44 04 30	 mov	 eax, DWORD PTR msglen$[rsp+rax]
  000b3	89 44 0c 30	 mov	 DWORD PTR msglen$[rsp+rcx], eax

; 168  :     } while((msglen[1] = log_read(&msgbuf[1], &msgidx[1], LOG_NOBLOCK)));

  000b7	b8 04 00 00 00	 mov	 eax, 4
  000bc	48 6b c0 01	 imul	 rax, rax, 1
  000c0	48 8d 44 04 40	 lea	 rax, QWORD PTR msgidx$[rsp+rax]
  000c5	b9 08 00 00 00	 mov	 ecx, 8
  000ca	48 6b c9 01	 imul	 rcx, rcx, 1
  000ce	48 8d 4c 0c 48	 lea	 rcx, QWORD PTR msgbuf$[rsp+rcx]
  000d3	45 33 c0	 xor	 r8d, r8d
  000d6	48 8b d0	 mov	 rdx, rax
  000d9	e8 00 00 00 00	 call	 log_read
  000de	89 44 24 24	 mov	 DWORD PTR tv81[rsp], eax
  000e2	b8 04 00 00 00	 mov	 eax, 4
  000e7	48 6b c0 01	 imul	 rax, rax, 1
  000eb	8b 4c 24 24	 mov	 ecx, DWORD PTR tv81[rsp]
  000ef	89 4c 04 30	 mov	 DWORD PTR msglen$[rsp+rax], ecx
  000f3	83 7c 24 24 00	 cmp	 DWORD PTR tv81[rsp], 0
  000f8	0f 85 69 ff ff
	ff		 jne	 $LN4@log_line

; 169  : 
; 170  :     for(i = 0; i < 2 && linenumber; i++)

  000fe	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00106	eb 0a		 jmp	 SHORT $LN7@log_line
$LN5@log_line:
  00108	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0010c	ff c0		 inc	 eax
  0010e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@log_line:
  00112	83 7c 24 20 02	 cmp	 DWORD PTR i$[rsp], 2
  00117	0f 8d 84 00 00
	00		 jge	 $LN6@log_line
  0011d	83 7c 24 70 00	 cmp	 DWORD PTR linenumber$[rsp], 0
  00122	74 7d		 je	 SHORT $LN6@log_line

; 171  :         if(msgidx[i] != -1)

  00124	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00129	83 7c 84 40 ff	 cmp	 DWORD PTR msgidx$[rsp+rax*4], -1
  0012e	74 6c		 je	 SHORT $LN14@log_line

; 172  :         {
; 173  :             for(; linenumber > 0; linenumber--)

  00130	eb 0a		 jmp	 SHORT $LN10@log_line
$LN8@log_line:
  00132	8b 44 24 70	 mov	 eax, DWORD PTR linenumber$[rsp]
  00136	ff c8		 dec	 eax
  00138	89 44 24 70	 mov	 DWORD PTR linenumber$[rsp], eax
$LN10@log_line:
  0013c	83 7c 24 70 00	 cmp	 DWORD PTR linenumber$[rsp], 0
  00141	7e 50		 jle	 SHORT $LN9@log_line

; 174  :             {
; 175  :                 if(!(tmpbuf = (void *)memrchr(msgbuf[i],'\n',msglen[i])))

  00143	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00148	48 63 44 84 30	 movsxd	 rax, DWORD PTR msglen$[rsp+rax*4]
  0014d	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00152	4c 8b c0	 mov	 r8, rax
  00155	ba 0a 00 00 00	 mov	 edx, 10
  0015a	48 8b 4c cc 48	 mov	 rcx, QWORD PTR msgbuf$[rsp+rcx*8]
  0015f	e8 00 00 00 00	 call	 memrchr
  00164	48 89 44 24 38	 mov	 QWORD PTR tmpbuf$[rsp], rax
  00169	48 83 7c 24 38
	00		 cmp	 QWORD PTR tmpbuf$[rsp], 0
  0016f	75 02		 jne	 SHORT $LN15@log_line

; 176  :                     break;

  00171	eb 20		 jmp	 SHORT $LN9@log_line
$LN15@log_line:

; 177  :                 msglen[i] = (int)(tmpbuf - msgbuf[i]);

  00173	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00178	48 8b 44 c4 48	 mov	 rax, QWORD PTR msgbuf$[rsp+rax*8]
  0017d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tmpbuf$[rsp]
  00182	48 2b c8	 sub	 rcx, rax
  00185	48 8b c1	 mov	 rax, rcx
  00188	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0018d	89 44 8c 30	 mov	 DWORD PTR msglen$[rsp+rcx*4], eax

; 178  :             }

  00191	eb 9f		 jmp	 SHORT $LN8@log_line
$LN9@log_line:

; 179  :             if(!linenumber)

  00193	83 7c 24 70 00	 cmp	 DWORD PTR linenumber$[rsp], 0
  00198	75 02		 jne	 SHORT $LN16@log_line

; 180  :                 break;

  0019a	eb 05		 jmp	 SHORT $LN6@log_line
$LN16@log_line:
$LN14@log_line:

; 181  :         }

  0019c	e9 67 ff ff ff	 jmp	 $LN5@log_line
$LN6@log_line:
$LN11@log_line:

; 182  : 
; 183  :     while(i < 2 && tmpbuf && (*tmpbuf == '\r' || *tmpbuf == '\n'))

  001a1	83 7c 24 20 02	 cmp	 DWORD PTR i$[rsp], 2
  001a6	7d 45		 jge	 SHORT $LN12@log_line
  001a8	48 83 7c 24 38
	00		 cmp	 QWORD PTR tmpbuf$[rsp], 0
  001ae	74 3d		 je	 SHORT $LN12@log_line
  001b0	48 8b 44 24 38	 mov	 rax, QWORD PTR tmpbuf$[rsp]
  001b5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001b8	83 f8 0d	 cmp	 eax, 13
  001bb	74 0d		 je	 SHORT $LN17@log_line
  001bd	48 8b 44 24 38	 mov	 rax, QWORD PTR tmpbuf$[rsp]
  001c2	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001c5	83 f8 0a	 cmp	 eax, 10
  001c8	75 23		 jne	 SHORT $LN12@log_line
$LN17@log_line:

; 184  :     {
; 185  :         tmpbuf++;

  001ca	48 8b 44 24 38	 mov	 rax, QWORD PTR tmpbuf$[rsp]
  001cf	48 ff c0	 inc	 rax
  001d2	48 89 44 24 38	 mov	 QWORD PTR tmpbuf$[rsp], rax

; 186  :         msglen[i]++;

  001d7	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001dc	8b 44 84 30	 mov	 eax, DWORD PTR msglen$[rsp+rax*4]
  001e0	ff c0		 inc	 eax
  001e2	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001e7	89 44 8c 30	 mov	 DWORD PTR msglen$[rsp+rcx*4], eax

; 187  :     }

  001eb	eb b4		 jmp	 SHORT $LN11@log_line
$LN12@log_line:

; 188  : 
; 189  :     return i ? msglen[i] + msgidx[0] : msglen[i];

  001ed	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  001f2	74 1c		 je	 SHORT $LN19@log_line
  001f4	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001f9	b9 04 00 00 00	 mov	 ecx, 4
  001fe	48 6b c9 00	 imul	 rcx, rcx, 0
  00202	8b 44 84 30	 mov	 eax, DWORD PTR msglen$[rsp+rax*4]
  00206	03 44 0c 40	 add	 eax, DWORD PTR msgidx$[rsp+rcx]
  0020a	89 44 24 28	 mov	 DWORD PTR tv179[rsp], eax
  0020e	eb 0d		 jmp	 SHORT $LN20@log_line
$LN19@log_line:
  00210	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00215	8b 44 84 30	 mov	 eax, DWORD PTR msglen$[rsp+rax*4]
  00219	89 44 24 28	 mov	 DWORD PTR tv179[rsp], eax
$LN20@log_line:
  0021d	8b 44 24 28	 mov	 eax, DWORD PTR tv179[rsp]
$LN1@log_line:

; 190  : }

  00221	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00225	c3		 ret	 0
log_line ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logger.c
_TEXT	SEGMENT
bytes_returned$ = 32
tv79 = 36
msg$ = 64
msgidx$ = 72
block$ = 80
log_read PROC

; 85   : {

$LN16:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 86   : int bytes_returned;
; 87   : 
; 88   :     obtain_lock( &logger_lock );

  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168138
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  00021	e8 00 00 00 00	 call	 hthread_obtain_lock
$LN2@log_read:

; 89   : 
; 90   :     while (*msgidx == logger_currmsg && block)

  00026	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR logger_currmsg
  00031	39 08		 cmp	 DWORD PTR [rax], ecx
  00033	75 71		 jne	 SHORT $LN3@log_read
  00035	83 7c 24 50 00	 cmp	 DWORD PTR block$[rsp], 0
  0003a	74 6a		 je	 SHORT $LN3@log_read

; 91   :     {
; 92   :         if (logger_active)

  0003c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR logger_active, 0
  00043	74 1c		 je	 SHORT $LN4@log_read

; 93   :         {
; 94   :             wait_condition( &logger_cond, &logger_lock );

  00045	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168141
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:logger_lock
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_cond
  0005a	e8 00 00 00 00	 call	 hthread_wait_condition

; 95   :         }

  0005f	eb 43		 jmp	 SHORT $LN5@log_read
$LN4@log_read:

; 96   :         else
; 97   :         {
; 98   :             *msgidx = logger_currmsg;

  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  00066	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR logger_currmsg
  0006c	89 08		 mov	 DWORD PTR [rax], ecx

; 99   :             *msg = logger_buffer + logger_currmsg;

  0006e	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR logger_currmsg
  00075	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR logger_buffer
  0007c	48 03 c8	 add	 rcx, rax
  0007f	48 8b c1	 mov	 rax, rcx
  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR msg$[rsp]
  00087	48 89 01	 mov	 QWORD PTR [rcx], rax

; 100  :             release_lock( &logger_lock );

  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168142
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  00098	e8 00 00 00 00	 call	 hthread_release_lock

; 101  :             return 0;

  0009d	33 c0		 xor	 eax, eax
  0009f	e9 fc 00 00 00	 jmp	 $LN1@log_read
$LN5@log_read:

; 102  :         }
; 103  :     }

  000a4	eb 80		 jmp	 SHORT $LN2@log_read
$LN3@log_read:

; 104  : 
; 105  :     if (*msgidx != logger_currmsg)

  000a6	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR logger_currmsg
  000b1	39 08		 cmp	 DWORD PTR [rax], ecx
  000b3	0f 84 c8 00 00
	00		 je	 $LN6@log_read

; 106  :     {
; 107  :         if (*msgidx < 0)

  000b9	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  000be	83 38 00	 cmp	 DWORD PTR [rax], 0
  000c1	7d 28		 jge	 SHORT $LN8@log_read

; 108  :             *msgidx = logger_wrapped ? logger_currmsg : 0;

  000c3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR logger_wrapped, 0
  000ca	74 0c		 je	 SHORT $LN14@log_read
  000cc	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR logger_currmsg
  000d2	89 44 24 24	 mov	 DWORD PTR tv79[rsp], eax
  000d6	eb 08		 jmp	 SHORT $LN15@log_read
$LN14@log_read:
  000d8	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN15@log_read:
  000e0	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  000e5	8b 4c 24 24	 mov	 ecx, DWORD PTR tv79[rsp]
  000e9	89 08		 mov	 DWORD PTR [rax], ecx
$LN8@log_read:

; 109  : 
; 110  :         if (*msgidx < 0 || *msgidx >= logger_bufsize)

  000eb	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  000f0	83 38 00	 cmp	 DWORD PTR [rax], 0
  000f3	7c 0f		 jl	 SHORT $LN10@log_read
  000f5	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  000fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR logger_bufsize
  00100	39 08		 cmp	 DWORD PTR [rax], ecx
  00102	7c 0b		 jl	 SHORT $LN9@log_read
$LN10@log_read:

; 111  :             *msgidx = 0;

  00104	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  00109	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN9@log_read:

; 112  : 
; 113  :         *msg = logger_buffer + *msgidx;

  0010f	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  00114	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00117	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR logger_buffer
  0011e	48 03 c8	 add	 rcx, rax
  00121	48 8b c1	 mov	 rax, rcx
  00124	48 8b 4c 24 40	 mov	 rcx, QWORD PTR msg$[rsp]
  00129	48 89 01	 mov	 QWORD PTR [rcx], rax

; 114  : 
; 115  :         if (*msgidx >= logger_currmsg)

  0012c	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  00131	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR logger_currmsg
  00137	39 08		 cmp	 DWORD PTR [rax], ecx
  00139	7c 22		 jl	 SHORT $LN11@log_read

; 116  :         {
; 117  :             bytes_returned = logger_bufsize - *msgidx;

  0013b	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  00140	8b 00		 mov	 eax, DWORD PTR [rax]
  00142	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR logger_bufsize
  00148	2b c8		 sub	 ecx, eax
  0014a	8b c1		 mov	 eax, ecx
  0014c	89 44 24 20	 mov	 DWORD PTR bytes_returned$[rsp], eax

; 118  :             *msgidx = 0;

  00150	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  00155	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 119  :         }

  0015b	eb 22		 jmp	 SHORT $LN12@log_read
$LN11@log_read:

; 120  :         else
; 121  :         {
; 122  :             bytes_returned = logger_currmsg - *msgidx;

  0015d	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  00162	8b 00		 mov	 eax, DWORD PTR [rax]
  00164	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR logger_currmsg
  0016a	2b c8		 sub	 ecx, eax
  0016c	8b c1		 mov	 eax, ecx
  0016e	89 44 24 20	 mov	 DWORD PTR bytes_returned$[rsp], eax

; 123  :             *msgidx = logger_currmsg;

  00172	48 8b 44 24 48	 mov	 rax, QWORD PTR msgidx$[rsp]
  00177	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR logger_currmsg
  0017d	89 08		 mov	 DWORD PTR [rax], ecx
$LN12@log_read:

; 124  :         }
; 125  :     }

  0017f	eb 08		 jmp	 SHORT $LN7@log_read
$LN6@log_read:

; 126  :     else
; 127  :         bytes_returned = 0;

  00181	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR bytes_returned$[rsp], 0
$LN7@log_read:

; 128  : 
; 129  :     release_lock( &logger_lock );

  00189	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168150
  00190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  00197	e8 00 00 00 00	 call	 hthread_release_lock

; 130  : 
; 131  :     return bytes_returned;

  0019c	8b 44 24 20	 mov	 eax, DWORD PTR bytes_returned$[rsp]
$LN1@log_read:

; 132  : }

  001a0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001a4	c3		 ret	 0
log_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\logger.c
_TEXT	SEGMENT
rc$ = 48
tv137 = 56
tv160 = 64
tv183 = 72
tv195 = 80
tv210 = 88
tv241 = 96
tv290 = 104
tv321 = 112
buf$1 = 120
__$ArrayPad$ = 160
logger_init PROC

; 480  : {

$LN21:
  00000	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 481  :     int rc;
; 482  : 
; 483  :     initialize_condition( &logger_cond );

  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168290
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_cond
  00027	e8 00 00 00 00	 call	 hthread_initialize_condition

; 484  :     initialize_lock( &logger_lock );

  0002c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168291
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168292
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  00041	e8 00 00 00 00	 call	 hthread_initialize_lock

; 485  :     logger_init_flg = TRUE;

  00046	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR logger_init_flg, 1

; 486  : 
; 487  :     obtain_lock( &logger_lock );

  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168293
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  0005e	e8 00 00 00 00	 call	 hthread_obtain_lock

; 488  : 
; 489  :     if (0
; 490  :         || fileno( stdin  ) >= 0
; 491  :         || fileno( stdout ) >= 0
; 492  :         || fileno( stderr ) >= 0

  00063	33 c0		 xor	 eax, eax
  00065	85 c0		 test	 eax, eax
  00067	75 49		 jne	 SHORT $LN4@logger_ini
  00069	33 c9		 xor	 ecx, ecx
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00071	48 8b c8	 mov	 rcx, rax
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  0007a	85 c0		 test	 eax, eax
  0007c	7d 34		 jge	 SHORT $LN4@logger_ini
  0007e	b9 01 00 00 00	 mov	 ecx, 1
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00089	48 8b c8	 mov	 rcx, rax
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  00092	85 c0		 test	 eax, eax
  00094	7d 1c		 jge	 SHORT $LN4@logger_ini
  00096	b9 02 00 00 00	 mov	 ecx, 2
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a1	48 8b c8	 mov	 rcx, rax
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  000aa	85 c0		 test	 eax, eax
  000ac	0f 8c ff 02 00
	00		 jl	 $LN2@logger_ini
$LN4@logger_ini:

; 493  :     )
; 494  :     {
; 495  :         logger_syslog[ LOG_WRITE ] = stderr;

  000b2	b9 02 00 00 00	 mov	 ecx, 2
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000bd	b9 08 00 00 00	 mov	 ecx, 8
  000c2	48 6b c9 01	 imul	 rcx, rcx, 1
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:logger_syslog
  000cd	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 496  : 
; 497  :         /* If standard error is redirected, then use standard error
; 498  :            as the log file. */
; 499  :         if (sysblk.daemon_mode)

  000d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d8	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000de	c1 e8 02	 shr	 eax, 2
  000e1	83 e0 01	 and	 eax, 1
  000e4	85 c0		 test	 eax, eax
  000e6	0f 84 93 00 00
	00		 je	 $LN5@logger_ini

; 500  :         {
; 501  :             STRLCPY( logger_filename, "STDOUT redirected from command line" );

  000ec	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168299
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_filename
  00100	e8 00 00 00 00	 call	 strlcpy

; 502  :             /* Ignore standard output to the extent that it is
; 503  :                treated as standard error */
; 504  :             logger_hrdcpyfd = dup( STDOUT_FILENO );

  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dup
  00110	89 05 00 00 00
	00		 mov	 DWORD PTR logger_hrdcpyfd, eax

; 505  : 
; 506  :             if (dup2( STDERR_FILENO, STDOUT_FILENO ) == -1)

  00116	ba 01 00 00 00	 mov	 edx, 1
  0011b	b9 02 00 00 00	 mov	 ecx, 2
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dup2
  00126	83 f8 ff	 cmp	 eax, -1
  00129	75 4f		 jne	 SHORT $LN7@logger_ini

; 507  :             {
; 508  :                 // "Logger: error in function %s: %s"
; 509  :                 fprintf( stderr, MSG( HHC02102, "E", "dup2()", strerror( errno )));

  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00131	8b 08		 mov	 ecx, DWORD PTR [rax]
  00133	e8 00 00 00 00	 call	 w32_strerror
  00138	48 89 44 24 38	 mov	 QWORD PTR tv137[rsp], rax
  0013d	b9 02 00 00 00	 mov	 ecx, 2
  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00148	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv137[rsp]
  0014d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00152	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168301
  00159	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168302
  00160	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168303
  00167	48 8b c8	 mov	 rcx, rax
  0016a	e8 00 00 00 00	 call	 w32_fprintf

; 510  :                 exit(1);

  0016f	b9 01 00 00 00	 mov	 ecx, 1
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN7@logger_ini:

; 511  :             }
; 512  :         }

  0017a	e9 47 01 00 00	 jmp	 $LN6@logger_ini
$LN5@logger_ini:

; 513  :         else
; 514  :         {
; 515  :             if (!isatty( STDOUT_FILENO ))

  0017f	b9 01 00 00 00	 mov	 ecx, 1
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  0018a	85 c0		 test	 eax, eax
  0018c	0f 85 93 00 00
	00		 jne	 $LN8@logger_ini

; 516  :             {
; 517  :                 STRLCPY( logger_filename, "STDOUT redirected from command line" );

  00192	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00198	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168306
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_filename
  001a6	e8 00 00 00 00	 call	 strlcpy

; 518  :                 logger_hrdcpyfd = dup( STDOUT_FILENO );

  001ab	b9 01 00 00 00	 mov	 ecx, 1
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dup
  001b6	89 05 00 00 00
	00		 mov	 DWORD PTR logger_hrdcpyfd, eax

; 519  : 
; 520  :                 if (dup2( STDERR_FILENO, STDOUT_FILENO ) == -1)

  001bc	ba 01 00 00 00	 mov	 edx, 1
  001c1	b9 02 00 00 00	 mov	 ecx, 2
  001c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dup2
  001cc	83 f8 ff	 cmp	 eax, -1
  001cf	75 4f		 jne	 SHORT $LN10@logger_ini

; 521  :                 {
; 522  :                     // "Logger: error in function %s: %s"
; 523  :                     fprintf( stderr, MSG( HHC02102, "E", "dup2()", strerror( errno )));

  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001d7	8b 08		 mov	 ecx, DWORD PTR [rax]
  001d9	e8 00 00 00 00	 call	 w32_strerror
  001de	48 89 44 24 40	 mov	 QWORD PTR tv160[rsp], rax
  001e3	b9 02 00 00 00	 mov	 ecx, 2
  001e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv160[rsp]
  001f3	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001f8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168308
  001ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168309
  00206	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168310
  0020d	48 8b c8	 mov	 rcx, rax
  00210	e8 00 00 00 00	 call	 w32_fprintf

; 524  :                     exit(1);

  00215	b9 01 00 00 00	 mov	 ecx, 1
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN10@logger_ini:

; 525  :                 }
; 526  :             }

  00220	e9 a1 00 00 00	 jmp	 $LN9@logger_ini
$LN8@logger_ini:

; 527  :             else if (!isatty( STDERR_FILENO ))

  00225	b9 02 00 00 00	 mov	 ecx, 2
  0022a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  00230	85 c0		 test	 eax, eax
  00232	0f 85 8e 00 00
	00		 jne	 $LN11@logger_ini

; 528  :             {
; 529  :                 STRLCPY( logger_filename, "STDERR redirected from command line" );

  00238	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0023e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168312
  00245	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_filename
  0024c	e8 00 00 00 00	 call	 strlcpy

; 530  :                 logger_hrdcpyfd = dup( STDERR_FILENO );

  00251	b9 02 00 00 00	 mov	 ecx, 2
  00256	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dup
  0025c	89 05 00 00 00
	00		 mov	 DWORD PTR logger_hrdcpyfd, eax

; 531  : 
; 532  :                 if (dup2( STDOUT_FILENO, STDERR_FILENO ) == -1)

  00262	ba 02 00 00 00	 mov	 edx, 2
  00267	b9 01 00 00 00	 mov	 ecx, 1
  0026c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dup2
  00272	83 f8 ff	 cmp	 eax, -1
  00275	75 4f		 jne	 SHORT $LN12@logger_ini

; 533  :                 {
; 534  :                     // "Logger: error in function %s: %s"
; 535  :                     fprintf( stderr, MSG( HHC02102, "E", "dup2()", strerror( errno )));

  00277	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0027d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0027f	e8 00 00 00 00	 call	 w32_strerror
  00284	48 89 44 24 48	 mov	 QWORD PTR tv183[rsp], rax
  00289	b9 02 00 00 00	 mov	 ecx, 2
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00294	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv183[rsp]
  00299	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0029e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168314
  002a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168315
  002ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168316
  002b3	48 8b c8	 mov	 rcx, rax
  002b6	e8 00 00 00 00	 call	 w32_fprintf

; 536  :                     exit(1);

  002bb	b9 01 00 00 00	 mov	 ecx, 1
  002c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN12@logger_ini:
$LN11@logger_ini:
$LN9@logger_ini:
$LN6@logger_ini:

; 537  :                 }
; 538  :             }
; 539  :         }
; 540  : 
; 541  :         if (logger_hrdcpyfd == -1)

  002c6	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR logger_hrdcpyfd, -1
  002cd	75 4e		 jne	 SHORT $LN13@logger_ini

; 542  :         {
; 543  :             logger_hrdcpyfd = 0;

  002cf	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR logger_hrdcpyfd, 0

; 544  :             // "Logger: error in function %s: %s"
; 545  :             fprintf( stderr, MSG( HHC02102, "E", "dup()", strerror( errno )));

  002d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002df	8b 08		 mov	 ecx, DWORD PTR [rax]
  002e1	e8 00 00 00 00	 call	 w32_strerror
  002e6	48 89 44 24 50	 mov	 QWORD PTR tv195[rsp], rax
  002eb	b9 02 00 00 00	 mov	 ecx, 2
  002f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv195[rsp]
  002fb	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00300	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168318
  00307	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168319
  0030e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168320
  00315	48 8b c8	 mov	 rcx, rax
  00318	e8 00 00 00 00	 call	 w32_fprintf
$LN13@logger_ini:

; 546  :         }
; 547  : 
; 548  :         if (logger_hrdcpyfd)

  0031d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR logger_hrdcpyfd, 0
  00324	74 67		 je	 SHORT $LN14@logger_ini

; 549  :         {
; 550  :             if (!(logger_hrdcpy = fdopen( logger_hrdcpyfd, "w" )))

  00326	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168323
  0032d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR logger_hrdcpyfd
  00333	e8 00 00 00 00	 call	 w32_fdopen
  00338	48 89 05 00 00
	00 00		 mov	 QWORD PTR logger_hrdcpy, rax
  0033f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR logger_hrdcpy, 0
  00347	75 44		 jne	 SHORT $LN15@logger_ini

; 551  :                 // "Logger: error in function %s: %s"
; 552  :                 fprintf( stderr, MSG( HHC02102, "E", "fdopen()", strerror( errno )));

  00349	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0034f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00351	e8 00 00 00 00	 call	 w32_strerror
  00356	48 89 44 24 58	 mov	 QWORD PTR tv210[rsp], rax
  0035b	b9 02 00 00 00	 mov	 ecx, 2
  00360	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00366	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv210[rsp]
  0036b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00370	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168324
  00377	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168325
  0037e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168326
  00385	48 8b c8	 mov	 rcx, rax
  00388	e8 00 00 00 00	 call	 w32_fprintf
$LN15@logger_ini:
$LN14@logger_ini:

; 553  :         }
; 554  : 
; 555  :         if (logger_hrdcpy)

  0038d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR logger_hrdcpy, 0
  00395	74 18		 je	 SHORT $LN16@logger_ini

; 556  :             setvbuf( logger_hrdcpy, NULL, _IONBF, 0 );

  00397	45 33 c9	 xor	 r9d, r9d
  0039a	41 b8 04 00 00
	00		 mov	 r8d, 4
  003a0	33 d2		 xor	 edx, edx
  003a2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR logger_hrdcpy
  003a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf
$LN16@logger_ini:

; 557  :     }

  003af	eb 28		 jmp	 SHORT $LN3@logger_ini
$LN2@logger_ini:

; 558  :     else
; 559  :     {
; 560  :         logger_syslog[ LOG_WRITE ] = fopen( "LOG", "a" );

  003b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168328
  003b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168329
  003bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  003c5	b9 08 00 00 00	 mov	 ecx, 8
  003ca	48 6b c9 01	 imul	 rcx, rcx, 1
  003ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:logger_syslog
  003d5	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax
$LN3@logger_ini:

; 561  :     }
; 562  : 
; 563  :     logger_bufsize = LOG_DEFSIZE;

  003d9	c7 05 00 00 00
	00 00 00 10 00	 mov	 DWORD PTR logger_bufsize, 1048576 ; 00100000H

; 564  : 
; 565  :     if (!(logger_buffer = malloc( logger_bufsize )))

  003e3	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR logger_bufsize
  003ea	48 8b c8	 mov	 rcx, rax
  003ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  003f3	48 89 05 00 00
	00 00		 mov	 QWORD PTR logger_buffer, rax
  003fa	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR logger_buffer, 0
  00402	75 6a		 jne	 SHORT $LN17@logger_ini

; 566  :     {
; 567  :         char buf[40];
; 568  :         MSGBUF( buf, "malloc(%d)", logger_bufsize );

  00404	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR logger_bufsize
  0040b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168331
  00412	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00417	48 8d 4c 24 78	 lea	 rcx, QWORD PTR buf$1[rsp]
  0041c	e8 00 00 00 00	 call	 w32_snprintf

; 569  :         // "Logger: error in function %s: %s"
; 570  :         fprintf( stderr, MSG( HHC02102, "E", buf, strerror( errno )));

  00421	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00427	8b 08		 mov	 ecx, DWORD PTR [rax]
  00429	e8 00 00 00 00	 call	 w32_strerror
  0042e	48 89 44 24 60	 mov	 QWORD PTR tv241[rsp], rax
  00433	b9 02 00 00 00	 mov	 ecx, 2
  00438	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0043e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv241[rsp]
  00443	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00448	4c 8d 4c 24 78	 lea	 r9, QWORD PTR buf$1[rsp]
  0044d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168332
  00454	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168333
  0045b	48 8b c8	 mov	 rcx, rax
  0045e	e8 00 00 00 00	 call	 w32_fprintf

; 571  :         exit(1);

  00463	b9 01 00 00 00	 mov	 ecx, 1
  00468	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN17@logger_ini:

; 572  :     }
; 573  : 
; 574  :     if (create_pipe( logger_syslogfd ))

  0046e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:logger_syslogfd
  00475	45 33 c0	 xor	 r8d, r8d
  00478	ba 01 00 00 00	 mov	 edx, 1
  0047d	b9 02 00 00 00	 mov	 ecx, 2
  00482	e8 00 00 00 00	 call	 socketpair
  00487	85 c0		 test	 eax, eax
  00489	74 4f		 je	 SHORT $LN18@logger_ini

; 575  :     {
; 576  :         // "Logger: error in function %s: %s"
; 577  :         fprintf( stderr, MSG( HHC02102, "E", "create_pipe()", strerror( errno )));

  0048b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00491	8b 08		 mov	 ecx, DWORD PTR [rax]
  00493	e8 00 00 00 00	 call	 w32_strerror
  00498	48 89 44 24 68	 mov	 QWORD PTR tv290[rsp], rax
  0049d	b9 02 00 00 00	 mov	 ecx, 2
  004a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004a8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv290[rsp]
  004ad	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004b2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168335
  004b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168336
  004c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168337
  004c7	48 8b c8	 mov	 rcx, rax
  004ca	e8 00 00 00 00	 call	 w32_fprintf

; 578  :         exit(1);  /* Hercules running without syslog */

  004cf	b9 01 00 00 00	 mov	 ecx, 1
  004d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN18@logger_ini:

; 579  :     }
; 580  :     socket_set_blocking_mode(logger_syslogfd[ LOG_WRITE ], O_NONBLOCK);

  004da	b8 04 00 00 00	 mov	 eax, 4
  004df	48 6b c0 01	 imul	 rax, rax, 1
  004e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_syslogfd
  004ea	33 d2		 xor	 edx, edx
  004ec	8b 0c 01	 mov	 ecx, DWORD PTR [rcx+rax]
  004ef	e8 00 00 00 00	 call	 socket_set_blocking_mode

; 581  : 
; 582  :     setvbuf( logger_syslog[ LOG_WRITE ], NULL, _IONBF, 0 );

  004f4	b8 08 00 00 00	 mov	 eax, 8
  004f9	48 6b c0 01	 imul	 rax, rax, 1
  004fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_syslog
  00504	45 33 c9	 xor	 r9d, r9d
  00507	41 b8 04 00 00
	00		 mov	 r8d, 4
  0050d	33 d2		 xor	 edx, edx
  0050f	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00513	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf

; 583  : 
; 584  :     rc = create_thread( &sysblk.loggertid, JOINABLE,

  00519	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00520	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  00526	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0052d	48 81 c1 dc 00
	00 00		 add	 rcx, 220		; 000000dcH
  00534	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168338
  0053b	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00540	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168339
  00547	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0054c	45 33 c9	 xor	 r9d, r9d
  0054f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:logger_thread
  00556	48 8b d0	 mov	 rdx, rax
  00559	e8 00 00 00 00	 call	 hthread_create_thread
  0055e	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax

; 585  :                         logger_thread, NULL, LOGGER_THREAD_NAME );
; 586  :     if (rc)

  00562	83 7c 24 30 00	 cmp	 DWORD PTR rc$[rsp], 0
  00567	74 42		 je	 SHORT $LN19@logger_ini

; 587  :     {
; 588  :         fprintf( stderr, MSG( HHC00102, "E", strerror( rc )));

  00569	8b 4c 24 30	 mov	 ecx, DWORD PTR rc$[rsp]
  0056d	e8 00 00 00 00	 call	 w32_strerror
  00572	48 89 44 24 70	 mov	 QWORD PTR tv321[rsp], rax
  00577	b9 02 00 00 00	 mov	 ecx, 2
  0057c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00582	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv321[rsp]
  00587	4c 8b c9	 mov	 r9, rcx
  0058a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168341
  00591	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168342
  00598	48 8b c8	 mov	 rcx, rax
  0059b	e8 00 00 00 00	 call	 w32_fprintf

; 589  :         exit(1);

  005a0	b9 01 00 00 00	 mov	 ecx, 1
  005a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN19@logger_ini:

; 590  :     }
; 591  : 
; 592  :     /* Wait for logger_thread to start */
; 593  :     wait_condition( &logger_cond, &logger_lock );

  005ab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168343
  005b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:logger_lock
  005b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_cond
  005c0	e8 00 00 00 00	 call	 hthread_wait_condition

; 594  : 
; 595  :     release_lock( &logger_lock );

  005c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168344
  005cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logger_lock
  005d3	e8 00 00 00 00	 call	 hthread_release_lock
$LN20@logger_ini:

; 596  : }

  005d8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005e0	48 33 cc	 xor	 rcx, rsp
  005e3	e8 00 00 00 00	 call	 __security_check_cookie
  005e8	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  005ef	c3		 ret	 0
logger_init ENDP
_TEXT	ENDS
END
