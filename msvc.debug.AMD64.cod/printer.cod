; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	fcbmask_hardware
PUBLIC	fcbmask_legacy
PUBLIC	fcbmask_fcb2std2
PUBLIC	fcbmask_fcb2id1
PUBLIC	cctape_legacy
PUBLIC	cctape_fcb2std2
PUBLIC	cctape_fcb2id1
PUBLIC	prt3203_device_hndinfo
_BSS	SEGMENT
prt3203_immed_commands DB 0100H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
printer_immed_commands DB 00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
$SG168136 DB	'legacy', 00H
	ORG $+1
$SG168137 DB	'fcb2std', 00H
$SG168138 DB	'fcb2id1', 00H
$SG168139 DB	'hardware', 00H
	ORG $+3
$SG168140 DB	'legacy', 00H
	ORG $+5
$SG168141 DB	'fcb2std2', 00H
	ORG $+7
$SG168142 DB	'fcb2id1', 00H
	ORG $+8
prt3203_device_hndinfo DQ FLAT:printer_init_handler
	DQ	FLAT:printer_execute_ccw
	DQ	FLAT:printer_close_device
	DQ	FLAT:printer_query_device
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:prt3203_immed_commands
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+8
fcbmask_hardware DD 042H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+972
fcbmask_legacy DD 042H
	DD	01H
	DD	07H
	DD	0dH
	DD	013H
	DD	019H
	DD	01fH
	DD	025H
	DD	02bH
	DD	03fH
	DD	031H
	DD	037H
	DD	03dH
	ORG $+972
fcbmask_fcb2std2 DD 042H
	DD	01H
	DD	07H
	DD	0dH
	DD	013H
	DD	019H
	DD	01fH
	DD	025H
	DD	02bH
	DD	031H
	DD	037H
	DD	03dH
	DD	03fH
	ORG $+972
fcbmask_fcb2id1 DD 058H
	DD	01H
	DD	08H
	DD	0fH
	DD	016H
	DD	01dH
	DD	024H
	DD	02bH
	DD	032H
	DD	039H
	DD	040H
	DD	047H
	DD	04eH
	ORG $+972
cctape_legacy DW 08000H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	04000H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	02000H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01000H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0800H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0400H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0200H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0100H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	040H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	020H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	010H
	DW	00H
	DW	080H
	DW	00H
	DW	00H
	DW	00H
	ORG $+380
cctape_fcb2std2 DW 08000H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	04000H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	02000H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01000H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0800H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0400H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0200H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0100H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	080H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	040H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	020H
	DW	00H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	ORG $+380
cctape_fcb2id1 DW 08000H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	04000H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	02000H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	01000H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0800H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0400H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0200H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	0100H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	080H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	040H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	020H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	010H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	DW	00H
	ORG $+336
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	hdl_check_depends_ep
PUBLIC	hdl_define_devtypes_ep
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isdigit:PROC
EXTRN	__imp_toupper:PROC
EXTRN	__imp__errno:PROC
EXTRN	strstr:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_GetCurrentThreadId:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_strtoul:PROC
EXTRN	__imp_recv:PROC
EXTRN	__imp__chsize_s:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_set_thread_name:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_reverse_bits:PROC
EXTRN	__imp_FormatFCB:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_sleep:PROC
EXTRN	__imp_sched_yield:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_close_socket:PROC
EXTRN	__imp_w32_FD_SET:PROC
EXTRN	__imp_w32_FD_ISSET:PROC
EXTRN	__imp_w32_select:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_poor_mans_fork:PROC
EXTRN	__imp_w32_set_thread_name:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	bind_device_ex:PROC
EXTRN	unbind_device_ex:PROC
EXTRN	__imp_write_socket:PROC
EXTRN	__imp_device_attention:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG168509 DB	01H DUP (?)
	ALIGN	4

$SG168511 DB	01H DUP (?)
	ALIGN	4

$SG168513 DB	01H DUP (?)
	ALIGN	4

$SG168515 DB	01H DUP (?)
	ALIGN	4

$SG168517 DB	01H DUP (?)
	ALIGN	4

$SG168519 DB	01H DUP (?)
	ALIGN	4

$SG168521 DB	01H DUP (?)
	ALIGN	4

$SG168523 DB	01H DUP (?)
	ALIGN	4

$SG168525 DB	01H DUP (?)
	ALIGN	4

$SG168527 DB	01H DUP (?)
	ALIGN	4

$SG168529 DB	01H DUP (?)
	ALIGN	4

$SG168531 DB	01H DUP (?)
	ALIGN	4

$SG168533 DB	01H DUP (?)
	ALIGN	4

$SG168535 DB	01H DUP (?)
	ALIGN	4

$SG168537 DB	01H DUP (?)
	ALIGN	4

$SG168539 DB	01H DUP (?)
	ALIGN	4

$SG168853 DB	01H DUP (?)
	ALIGN	4

$SG168855 DB	01H DUP (?)
	ALIGN	4

$SG168857 DB	01H DUP (?)
	ALIGN	4

$SG168859 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$write_buffer DD imagerel write_buffer
	DD	imagerel write_buffer+848
	DD	imagerel $unwind$write_buffer
$pdata$SpaceLines DD imagerel SpaceLines
	DD	imagerel SpaceLines+512
	DD	imagerel $unwind$SpaceLines
$pdata$WriteLine DD imagerel WriteLine
	DD	imagerel WriteLine+912
	DD	imagerel $unwind$WriteLine
$pdata$SkipToChannel DD imagerel SkipToChannel
	DD	imagerel SkipToChannel+1136
	DD	imagerel $unwind$SkipToChannel
$pdata$DoSpaceOrSkip DD imagerel DoSpaceOrSkip
	DD	imagerel DoSpaceOrSkip+227
	DD	imagerel $unwind$DoSpaceOrSkip
$pdata$spthread DD imagerel spthread
	DD	imagerel spthread+1175
	DD	imagerel $unwind$spthread
$pdata$onconnect_callback DD imagerel onconnect_callback
	DD	imagerel onconnect_callback+193
	DD	imagerel $unwind$onconnect_callback
$pdata$on_new_fcb DD imagerel on_new_fcb
	DD	imagerel on_new_fcb+726
	DD	imagerel $unwind$on_new_fcb
$pdata$on_new_cctape DD imagerel on_new_cctape
	DD	imagerel on_new_cctape+395
	DD	imagerel $unwind$on_new_cctape
$pdata$LoadUCB DD imagerel LoadUCB
	DD	imagerel LoadUCB+244
	DD	imagerel $unwind$LoadUCB
$pdata$valid_cctape DD imagerel valid_cctape
	DD	imagerel valid_cctape+290
	DD	imagerel $unwind$valid_cctape
$pdata$valid_fcb DD imagerel valid_fcb
	DD	imagerel valid_fcb+463
	DD	imagerel $unwind$valid_fcb
$pdata$format_sense DD imagerel format_sense
	DD	imagerel format_sense+1299
	DD	imagerel $unwind$format_sense
$pdata$open_printer DD imagerel open_printer
	DD	imagerel open_printer+1322
	DD	imagerel $unwind$open_printer
$pdata$printer_init_handler DD imagerel printer_init_handler
	DD	imagerel printer_init_handler+13300
	DD	imagerel $unwind$printer_init_handler
$pdata$printer_query_device DD imagerel printer_query_device
	DD	imagerel printer_query_device+611
	DD	imagerel $unwind$printer_query_device
$pdata$printer_close_device DD imagerel printer_close_device
	DD	imagerel printer_close_device+665
	DD	imagerel $unwind$printer_close_device
$pdata$printer_execute_ccw DD imagerel printer_execute_ccw
	DD	imagerel printer_execute_ccw+5287
	DD	imagerel $unwind$printer_execute_ccw
$pdata$hdl_check_depends_ep DD imagerel $LN11
	DD	imagerel $LN11+110
	DD	imagerel $unwind$hdl_check_depends_ep
$pdata$hdl_define_devtypes_ep DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$hdl_define_devtypes_ep
pdata	ENDS
_DATA	SEGMENT
$SG168159 DB	'I', 00H
	ORG $+6
fcbtab	DB	00H
	ORG $+7
	DQ	FLAT:$SG168136
	DQ	FLAT:fcbmask_legacy
	DB	00H
	ORG $+7
	DQ	FLAT:$SG168137
	DQ	FLAT:fcbmask_fcb2std2
	DB	00H
	ORG $+7
	DQ	FLAT:$SG168138
	DQ	FLAT:fcbmask_fcb2id1
	DB	00H
	ORG $+7
	DQ	FLAT:$SG168139
	DQ	FLAT:fcbmask_hardware
	DB	01H
	ORG $+7
	DQ	FLAT:$SG168140
	DQ	FLAT:cctape_legacy
	DB	01H
	ORG $+7
	DQ	FLAT:$SG168141
	DQ	FLAT:cctape_fcb2std2
	DB	01H
	ORG $+7
	DQ	FLAT:$SG168142
	DQ	FLAT:cctape_fcb2id1
$SG168165 DB	'write()', 00H
$SG168160 DB	'HHC01100%s %1d:%04X Printer: client %s, IP %s disconnect'
	DB	'ed from device %s', 0aH, 00H
	ORG $+1
$SG168167 DB	'E', 00H
	ORG $+2
$SG168161 DB	'write_buffer', 00H
	ORG $+3
$SG168162 DB	'printer.c', 00H
	ORG $+2
$SG168201 DB	0dH, 00H
	ORG $+2
$SG168164 DB	'incomplete record written', 00H
	ORG $+2
$SG168202 DB	0aH, 0aH, 0aH, 00H
$SG168166 DB	'Printer', 00H
$SG168168 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG168252 DB	0dH, 00H
	ORG $+2
$SG168169 DB	'write_buffer', 00H
	ORG $+3
$SG168170 DB	'printer.c', 00H
	ORG $+2
$SG168297 DB	0cH, 00H
	ORG $+2
$SG168191 DB	'SpaceLines', 00H
	ORG $+1
$SG168299 DB	0aH, 00H
	ORG $+2
$SG168192 DB	'printer.c', 00H
	ORG $+6
$SG168193 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168195 DB	'SpaceLines', 00H
	ORG $+1
$SG168303 DB	0aH, 00H
	ORG $+2
$SG168196 DB	'printer.c', 00H
	ORG $+2
$SG168305 DB	0aH, 00H
	ORG $+2
$SG168357 DB	'spthread %1d:%04X', 00H
	ORG $+6
$SG168197 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168360 DB	'printer.c', 00H
	ORG $+2
$SG168377 DB	'I', 00H
	ORG $+2
$SG168366 DB	'spthread', 00H
	ORG $+3
$SG168391 DB	'E', 00H
	ORG $+2
$SG168367 DB	'printer.c', 00H
	ORG $+6
$SG168375 DB	'printer.c:669', 00H
	ORG $+2
$SG168392 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG168368 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168370 DB	'spthread', 00H
	ORG $+3
$SG168408 DB	'I', 00H
	ORG $+2
$SG168371 DB	'printer.c', 00H
	ORG $+6
$SG168381 DB	'printer.c:688', 00H
	ORG $+2
$SG168393 DB	'onconnect_callback', 00H
	ORG $+5
$SG168372 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168388 DB	'printer.c:702', 00H
	ORG $+2
$SG168409 DB	'HHC02210%s %1d:%04X %s', 0aH, 00H
$SG168378 DB	'HHC01100%s %1d:%04X Printer: client %s, IP %s disconnect'
	DB	'ed from device %s', 0aH, 00H
	ORG $+1
$SG168418 DB	'W', 00H
	ORG $+2
$SG168379 DB	'spthread', 00H
	ORG $+3
$SG168438 DB	'W', 00H
	ORG $+2
$SG168380 DB	'printer.c', 00H
	ORG $+2
$SG168473 DB	'cctape', 00H
	ORG $+1
$SG168474 DB	'E', 00H
	ORG $+2
$SG168389 DB	'spthread', 00H
	ORG $+3
$SG168490 DB	'fcb', 00H
$SG168394 DB	'printer.c', 00H
	ORG $+2
$SG168491 DB	'E', 00H
	ORG $+2
$SG168407 DB	'LOADED %s', 00H
	ORG $+2
$SG168496 DB	'E', 00H
	ORG $+2
$SG168410 DB	'on_new_fcb', 00H
	ORG $+1
$SG168608 DB	'E', 00H
	ORG $+2
$SG168411 DB	'printer.c', 00H
	ORG $+2
$SG168510 DB	'MECHM ', 00H
	ORG $+1
$SG168612 DB	'%hx', 00H
$SG168419 DB	'HHC01111%s %1d:%04X Printer: channel 1 is undefined', 0aH
	DB	00H
	ORG $+3
$SG168420 DB	'on_new_fcb', 00H
	ORG $+1
$SG168614 DB	'E', 00H
	ORG $+2
$SG168421 DB	'printer.c', 00H
	ORG $+2
$SG168516 DB	'POSCK ', 00H
	ORG $+1
$SG168626 DB	'E', 00H
	ORG $+2
$SG168439 DB	'HHC01111%s %1d:%04X Printer: channel 1 is undefined', 0aH
	DB	00H
	ORG $+3
$SG168440 DB	'on_new_cctape', 00H
	ORG $+2
$SG168441 DB	'printer.c', 00H
	ORG $+6
$SG168476 DB	'valid_cctape', 00H
	ORG $+3
$SG168508 DB	'--- ', 00H
	ORG $+3
$SG168475 DB	'HHC01113%s %1d:%04X Printer: incompatible ''%s'' and ''l'
	DB	'pp'' values detected', 0aH, 00H
	ORG $+2
$SG168520 DB	'PRTCK ', 00H
	ORG $+1
$SG168636 DB	'E', 00H
	ORG $+2
$SG168477 DB	'printer.c', 00H
	ORG $+6
$SG168512 DB	'CMDSUP ', 00H
$SG168492 DB	'HHC01113%s %1d:%04X Printer: incompatible ''%s'' and ''l'
	DB	'pp'' values detected', 0aH, 00H
	ORG $+2
$SG168524 DB	'CHAN9 ', 00H
	ORG $+1
$SG168642 DB	'E', 00H
	ORG $+2
$SG168493 DB	'valid_fcb', 00H
	ORG $+2
$SG168528 DB	'OVRUN ', 00H
	ORG $+1
$SG168651 DB	'E', 00H
	ORG $+2
$SG168494 DB	'printer.c', 00H
	ORG $+6
$SG168497 DB	'HHC01112%s %1d:%04X Printer: invalid fcb: maximum channe'
	DB	'l codes exceeded', 0aH, 00H
	ORG $+2
$SG168530 DB	'DATAC ', 00H
	ORG $+1
$SG168657 DB	'E', 00H
	ORG $+2
$SG168498 DB	'valid_fcb', 00H
	ORG $+2
$SG168532 DB	'EQPCK ', 00H
	ORG $+1
$SG168664 DB	'E', 00H
	ORG $+2
$SG168499 DB	'printer.c', 00H
	ORG $+2
$SG168534 DB	'BUSCK ', 00H
	ORG $+1
$SG168671 DB	'E', 00H
	ORG $+2
$SG168514 DB	'FORMCK ', 00H
$SG168518 DB	'QUAL ', 00H
	ORG $+2
$SG168522 DB	'--- ', 00H
	ORG $+3
$SG168526 DB	'LOADCK ', 00H
$SG168536 DB	'INTREQ ', 00H
$SG168538 DB	'CMDREJ ', 00H
$SG168540 DB	'%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s', 00H
	ORG $+3
$SG168619 DB	'legacy', 00H
	ORG $+1
$SG168681 DB	'E', 00H
	ORG $+2
$SG168603 DB	'printer.c:944', 00H
	ORG $+2
$SG168604 DB	'printer.c:946', 00H
	ORG $+2
$SG168609 DB	'HHC01101%s %1d:%04X Printer: file name missing or invali'
	DB	'd', 0aH, 00H
	ORG $+1
$SG168687 DB	':', 00H
	ORG $+2
$SG168610 DB	'printer_init_handler', 00H
	ORG $+3
$SG168611 DB	'printer.c', 00H
	ORG $+2
$SG168621 DB	'append', 00H
	ORG $+1
$SG168690 DB	'E', 00H
	ORG $+2
$SG168615 DB	'HHC01105%s %1d:%04X Printer: unsupported device type %04'
	DB	'X', 0aH, 00H
	ORG $+1
$SG168697 DB	'E', 00H
	ORG $+2
$SG168616 DB	'printer_init_handler', 00H
	ORG $+3
$SG168617 DB	'printer.c', 00H
	ORG $+2
$SG168710 DB	'E', 00H
	ORG $+2
$SG168623 DB	'cctape=', 00H
$SG168625 DB	'option ''cctape''', 00H
$SG168628 DB	'printer_init_handler', 00H
	ORG $+3
$SG168627 DB	'HHC01109%s %1d:%04X Printer: %s incompatible with device'
	DB	' type %04X', 0aH, 00H
$SG168716 DB	'E', 00H
	ORG $+2
$SG168629 DB	'printer.c', 00H
	ORG $+6
$SG168638 DB	'printer_init_handler', 00H
	ORG $+3
$SG168637 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168639 DB	'printer.c', 00H
	ORG $+6
$SG168643 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168644 DB	'printer_init_handler', 00H
	ORG $+3
$SG168645 DB	'printer.c', 00H
	ORG $+6
$SG168653 DB	'printer_init_handler', 00H
	ORG $+3
$SG168652 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168654 DB	'printer.c', 00H
	ORG $+6
$SG168658 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168659 DB	'printer_init_handler', 00H
	ORG $+3
$SG168660 DB	'printer.c', 00H
	ORG $+6
$SG168666 DB	'printer_init_handler', 00H
	ORG $+3
$SG168665 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168667 DB	'printer.c', 00H
	ORG $+6
$SG168672 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168673 DB	'printer_init_handler', 00H
	ORG $+3
$SG168674 DB	'printer.c', 00H
	ORG $+2
$SG168676 DB	'crlf', 00H
	ORG $+3
$SG168678 DB	'fcb=', 00H
	ORG $+3
$SG168722 DB	'E', 00H
	ORG $+2
$SG168680 DB	'option ''fcb''', 00H
	ORG $+3
$SG168683 DB	'printer_init_handler', 00H
	ORG $+3
$SG168682 DB	'HHC01109%s %1d:%04X Printer: %s incompatible with device'
	DB	' type %04X', 0aH, 00H
$SG168727 DB	'E', 00H
	ORG $+2
$SG168684 DB	'printer.c', 00H
	ORG $+6
$SG168692 DB	'printer_init_handler', 00H
	ORG $+3
$SG168691 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168693 DB	'printer.c', 00H
	ORG $+6
$SG168698 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168699 DB	'printer_init_handler', 00H
	ORG $+3
$SG168700 DB	'printer.c', 00H
	ORG $+6
$SG168712 DB	'printer_init_handler', 00H
	ORG $+3
$SG168711 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168713 DB	'printer.c', 00H
	ORG $+6
$SG168717 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168718 DB	'printer_init_handler', 00H
	ORG $+3
$SG168719 DB	'printer.c', 00H
	ORG $+6
$SG168724 DB	'printer_init_handler', 00H
	ORG $+3
$SG168723 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168725 DB	'printer.c', 00H
	ORG $+6
$SG168728 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168729 DB	'printer_init_handler', 00H
	ORG $+3
$SG168730 DB	'printer.c', 00H
	ORG $+2
$SG168733 DB	'E', 00H
	ORG $+2
$SG168735 DB	'printer_init_handler', 00H
	ORG $+3
$SG168734 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168736 DB	'printer.c', 00H
	ORG $+2
$SG168741 DB	'E', 00H
	ORG $+2
$SG168738 DB	'fcbcheck', 00H
	ORG $+3
$SG168747 DB	'W', 00H
	ORG $+2
$SG168740 DB	'option ''fcbcheck''', 00H
	ORG $+6
$SG168743 DB	'printer_init_handler', 00H
	ORG $+3
$SG168742 DB	'HHC01109%s %1d:%04X Printer: %s incompatible with device'
	DB	' type %04X', 0aH, 00H
$SG168755 DB	'E', 00H
	ORG $+2
$SG168744 DB	'printer.c', 00H
	ORG $+2
$SG168752 DB	'index=', 00H
	ORG $+1
$SG168761 DB	'E', 00H
	ORG $+2
$SG168745 DB	'fcbcheck', 00H
	ORG $+3
$SG168766 DB	'W', 00H
	ORG $+2
$SG168746 DB	'Printer', 00H
$SG168748 DB	'HHC01251%s %1d:%04X %s: option ''%s'' has been deprecate'
	DB	'd', 0aH, 00H
	ORG $+3
$SG168774 DB	'E', 00H
	ORG $+2
$SG168749 DB	'printer_init_handler', 00H
	ORG $+3
$SG168750 DB	'printer.c', 00H
	ORG $+2
$SG168782 DB	'E', 00H
	ORG $+2
$SG168754 DB	'option ''index''', 00H
	ORG $+1
$SG168756 DB	'HHC01109%s %1d:%04X Printer: %s incompatible with device'
	DB	' type %04X', 0aH, 00H
$SG168790 DB	'W', 00H
	ORG $+2
$SG168757 DB	'printer_init_handler', 00H
	ORG $+3
$SG168758 DB	'printer.c', 00H
	ORG $+6
$SG168762 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168763 DB	'printer_init_handler', 00H
	ORG $+3
$SG168764 DB	'printer.c', 00H
	ORG $+6
$SG168768 DB	'printer_init_handler', 00H
	ORG $+3
$SG168767 DB	'HHC01110%s %1d:%04X Printer: Indexing accepted but ignor'
	DB	'ed for 3203-5', 0aH, 00H
	ORG $+1
$SG168769 DB	'printer.c', 00H
	ORG $+2
$SG168771 DB	'lpi=', 00H
	ORG $+7
$SG168775 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168776 DB	'printer_init_handler', 00H
	ORG $+3
$SG168777 DB	'printer.c', 00H
	ORG $+2
$SG168779 DB	'lpp=', 00H
	ORG $+7
$SG168783 DB	'HHC01103%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' position %d is invalid', 0aH, 00H
$SG168784 DB	'printer_init_handler', 00H
	ORG $+3
$SG168785 DB	'printer.c', 00H
	ORG $+2
$SG168798 DB	'E', 00H
	ORG $+2
$SG168787 DB	'noclear', 00H
$SG168788 DB	'noclear', 00H
$SG168789 DB	'Printer', 00H
$SG168791 DB	'HHC01251%s %1d:%04X %s: option ''%s'' has been deprecate'
	DB	'd', 0aH, 00H
	ORG $+3
$SG168804 DB	'W', 00H
	ORG $+2
$SG168792 DB	'printer_init_handler', 00H
	ORG $+3
$SG168793 DB	'printer.c', 00H
	ORG $+2
$SG168810 DB	'E', 00H
	ORG $+2
$SG168795 DB	'nofcbcheck', 00H
	ORG $+1
$SG168820 DB	'E', 00H
	ORG $+2
$SG168797 DB	'option ''nofcbcheck''', 00H
	ORG $+4
$SG168799 DB	'HHC01109%s %1d:%04X Printer: %s incompatible with device'
	DB	' type %04X', 0aH, 00H
$SG168826 DB	'E', 00H
	ORG $+2
$SG168800 DB	'printer_init_handler', 00H
	ORG $+3
$SG168801 DB	'printer.c', 00H
	ORG $+2
$SG168845 DB	'PRT', 00H
$SG168802 DB	'nofcbcheck', 00H
	ORG $+1
$SG168851 DB	'.', 00H
	ORG $+2
$SG168803 DB	'Printer', 00H
$SG168805 DB	'HHC01251%s %1d:%04X %s: option ''%s'' has been deprecate'
	DB	'd', 0aH, 00H
	ORG $+3
$SG168856 DB	' crlf', 00H
	ORG $+2
$SG168878 DB	'E', 00H
	ORG $+2
$SG168806 DB	'printer_init_handler', 00H
	ORG $+3
$SG168807 DB	'printer.c', 00H
	ORG $+2
$SG168886 DB	'E', 00H
	ORG $+2
$SG168809 DB	'sockdev', 00H
$SG168811 DB	'HHC01102%s %1d:%04X Printer: argument %d parameter ''%s'''
	DB	' is invalid', 0aH, 00H
$SG168893 DB	'E', 00H
	ORG $+2
$SG168812 DB	'printer_init_handler', 00H
	ORG $+3
$SG168813 DB	'printer.c', 00H
	ORG $+2
$SG168891 DB	'fork()', 00H
	ORG $+1
$SG168897 DB	'I', 00H
	ORG $+2
$SG168819 DB	'sockdev/crlf', 00H
	ORG $+3
$SG168821 DB	'HHC01104%s %1d:%04X Printer: option %s is incompatible', 0aH
	DB	00H
$SG168822 DB	'printer_init_handler', 00H
	ORG $+3
$SG168823 DB	'printer.c', 00H
	ORG $+2
$SG168909 DB	'I', 00H
	ORG $+2
$SG168825 DB	'sockdev/noclear', 00H
$SG168827 DB	'HHC01104%s %1d:%04X Printer: option %s is incompatible', 0aH
	DB	00H
$SG168828 DB	'printer_init_handler', 00H
	ORG $+3
$SG168829 DB	'printer.c', 00H
	ORG $+2
$SG168915 DB	'I', 00H
	ORG $+2
$SG168852 DB	' (stopped)', 00H
	ORG $+5
$SG168854 DB	' append', 00H
$SG168858 DB	' sockdev', 00H
	ORG $+7
$SG168860 DB	'%s%s%s%s%s IO[%llu]', 00H
	ORG $+4
$SG168876 DB	'HOPEN()', 00H
$SG168877 DB	'Printer', 00H
$SG168879 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG168880 DB	'open_printer', 00H
	ORG $+3
$SG168881 DB	'printer.c', 00H
	ORG $+6
$SG168884 DB	'lseek()', 00H
$SG168885 DB	'Printer', 00H
$SG168887 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG168888 DB	'open_printer', 00H
	ORG $+3
$SG168889 DB	'printer.c', 00H
	ORG $+6
$SG168892 DB	'Printer', 00H
$SG168894 DB	'HHC01250%s %1d:%04X %s: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG168895 DB	'open_printer', 00H
	ORG $+3
$SG168896 DB	'printer.c', 00H
	ORG $+6
$SG168899 DB	'open_printer', 00H
	ORG $+3
$SG168911 DB	'printer_close_device', 00H
	ORG $+3
$SG168898 DB	'HHC01106%s %1d:%04X Printer: pipe receiver with pid %d s'
	DB	'tarting', 0aH, 00H
	ORG $+7
$SG168900 DB	'printer.c', 00H
	ORG $+6
$SG168917 DB	'printer_close_device', 00H
	ORG $+3
$SG168910 DB	'HHC01107%s %1d:%04X Printer: pipe receiver with pid %d t'
	DB	'erminating', 0aH, 00H
	ORG $+4
$SG168912 DB	'printer.c', 00H
	ORG $+2
$SG169168 DB	'DEVBLK', 00H
	ORG $+5
$SG168916 DB	'HHC01100%s %1d:%04X Printer: client %s, IP %s disconnect'
	DB	'ed from device %s', 0aH, 00H
	ORG $+5
$SG168918 DB	'printer.c', 00H
	ORG $+6
printer_device_hndinfo DQ FLAT:printer_init_handler
	DQ	FLAT:printer_execute_ccw
	DQ	FLAT:printer_close_device
	DQ	FLAT:printer_query_device
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:printer_immed_commands
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG169164 DB	'SDL 4.60', 00H
	ORG $+7
$SG169165 DB	'HERCULES', 00H
	ORG $+7
$SG169167 DB	'SDL 4.00', 00H
	ORG $+3
$SG169173 DB	'1403', 00H
	ORG $+3
$SG169174 DB	'3203', 00H
	ORG $+3
$SG169175 DB	'3211', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:printer_execute_ccw
	DD	026H
	DD	0128aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:printer_query_device
	DD	025H
	DD	024bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:on_new_fcb
	DD	016H
	DD	02beH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:spthread
	DD	01cH
	DD	047fH
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$write_buffer DD 021b01H
	DD	015011bH
$unwind$SpaceLines DD 011301H
	DD	08213H
$unwind$WriteLine DD 021801H
	DD	070147218H
$unwind$SkipToChannel DD 011701H
	DD	08217H
$unwind$DoSpaceOrSkip DD 011201H
	DD	06212H
$unwind$spthread DD 022419H
	DD	081f0112H
	DD	imagerel __GSHandlerCheck
	DD	040e0H
$unwind$onconnect_callback DD 010901H
	DD	0a209H
$unwind$on_new_fcb DD 021e19H
	DD	051010cH
	DD	imagerel __GSHandlerCheck
	DD	0270H
$unwind$on_new_cctape DD 010901H
	DD	0c209H
$unwind$LoadUCB DD 031901H
	DD	070154219H
	DD	06014H
$unwind$valid_cctape DD 010901H
	DD	0e209H
$unwind$valid_fcb DD 010901H
	DD	0e209H
$unwind$format_sense DD 021601H
	DD	0250116H
$unwind$open_printer DD 020c01H
	DD	019010cH
$unwind$printer_init_handler DD 041701H
	DD	0530117H
	DD	0600f7010H
$unwind$printer_query_device DD 022d19H
	DD	035011bH
	DD	imagerel __GSHandlerCheck
	DD	0190H
$unwind$printer_close_device DD 020c01H
	DD	013010cH
$unwind$printer_execute_ccw DD 042e19H
	DD	099011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	04b0H
$unwind$hdl_check_depends_ep DD 010901H
	DD	06209H
$unwind$hdl_define_devtypes_ep DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
defdev$ = 48
hdl_define_devtypes_ep PROC

; 2619 : HDL_DEVICE_SECTION;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2620 : {
; 2621 :     HDL_DEVICE( 1403, printer_device_hndinfo );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:printer_device_hndinfo
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169173
  00017	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 2622 :     HDL_DEVICE( 3203, prt3203_device_hndinfo );

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:prt3203_device_hndinfo
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169174
  00029	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 2623 :     HDL_DEVICE( 3211, printer_device_hndinfo );

  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:printer_device_hndinfo
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169175
  0003b	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 2624 : }
; 2625 : END_DEVICE_SECTION

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
hdl_define_devtypes_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
depchk_rc$ = 32
depchk$ = 64
hdl_check_depends_ep PROC

; 2611 : HDL_DEPENDENCY_SECTION;

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 0
$LN4@hdl_check_:

; 2612 : {
; 2613 :      HDL_DEPENDENCY(HERCULES);

  00011	41 b8 08 00 00
	00		 mov	 r8d, 8
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169164
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169165
  00025	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00029	85 c0		 test	 eax, eax
  0002b	74 08		 je	 SHORT $LN8@hdl_check_
  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN8@hdl_check_:
  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 d6		 jne	 SHORT $LN4@hdl_check_
$LN7@hdl_check_:

; 2614 :      HDL_DEPENDENCY(DEVBLK);

  0003b	41 b8 a0 1b 00
	00		 mov	 r8d, 7072		; 00001ba0H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169167
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169168
  0004f	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN9@hdl_check_
  00057	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN9@hdl_check_:
  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 d6		 jne	 SHORT $LN7@hdl_check_

; 2615 : }
; 2616 : END_DEPENDENCY_SECTION

  00065	8b 44 24 20	 mov	 eax, DWORD PTR depchk_rc$[rsp]
  00069	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006d	c3		 ret	 0
hdl_check_depends_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
b$1 = 64
b$2 = 65
num$ = 68
i$3 = 72
i$4 = 76
plbsize$ = 80
f$5 = 84
f$6 = 88
tv139 = 92
fcbsize$ = 96
k$7 = 100
rc$ = 104
ucbsize$ = 108
tv68 = 112
tv75 = 116
tv76 = 120
tv80 = 124
tv141 = 128
tv154 = 132
tv203 = 136
tv222 = 140
tv249 = 144
tv272 = 148
tv293 = 152
k$8 = 156
tv477 = 160
tv227 = 168
savedfcb$9 = 176
__$ArrayPad$ = 1200
dev$ = 1248
code$ = 1256
flags$ = 1264
chained$ = 1272
count$ = 1280
prevcode$ = 1288
ccwseq$ = 1296
iobuf$ = 1304
more$ = 1312
unitstat$ = 1320
residual$ = 1328
printer_execute_ccw PROC

; 1795 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec c8 04
	00 00		 sub	 rsp, 1224		; 000004c8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 b0
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@printer_ex:

; 1796 :     int  rc;
; 1797 :     U32  num, fcbsize, ucbsize, plbsize;
; 1798 : 
; 1799 :     UNREFERENCED( prevcode );

  0002e	33 c0		 xor	 eax, eax
  00030	85 c0		 test	 eax, eax
  00032	75 fa		 jne	 SHORT $LN4@printer_ex

; 1800 : 
; 1801 :     fcbsize = FCBSIZE( dev );

  00034	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00040	3d 11 32 00 00	 cmp	 eax, 12817		; 00003211H
  00045	75 0a		 jne	 SHORT $LN151@printer_ex
  00047	c7 44 24 70 b4
	00 00 00	 mov	 DWORD PTR tv68[rsp], 180 ; 000000b4H
  0004f	eb 08		 jmp	 SHORT $LN152@printer_ex
$LN151@printer_ex:
  00051	c7 44 24 70 00
	01 00 00	 mov	 DWORD PTR tv68[rsp], 256 ; 00000100H
$LN152@printer_ex:
  00059	8b 44 24 70	 mov	 eax, DWORD PTR tv68[rsp]
  0005d	89 44 24 60	 mov	 DWORD PTR fcbsize$[rsp], eax

; 1802 :     ucbsize = UCBSIZE( dev );

  00061	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00069	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0006d	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  00072	75 0a		 jne	 SHORT $LN155@printer_ex
  00074	c7 44 24 78 f0
	00 00 00	 mov	 DWORD PTR tv76[rsp], 240 ; 000000f0H
  0007c	eb 2d		 jmp	 SHORT $LN156@printer_ex
$LN155@printer_ex:
  0007e	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00086	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0008a	3d 03 32 00 00	 cmp	 eax, 12803		; 00003203H
  0008f	75 0a		 jne	 SHORT $LN153@printer_ex
  00091	c7 44 24 74 30
	01 00 00	 mov	 DWORD PTR tv75[rsp], 304 ; 00000130H
  00099	eb 08		 jmp	 SHORT $LN154@printer_ex
$LN153@printer_ex:
  0009b	c7 44 24 74 b0
	01 00 00	 mov	 DWORD PTR tv75[rsp], 432 ; 000001b0H
$LN154@printer_ex:
  000a3	8b 44 24 74	 mov	 eax, DWORD PTR tv75[rsp]
  000a7	89 44 24 78	 mov	 DWORD PTR tv76[rsp], eax
$LN156@printer_ex:
  000ab	8b 44 24 78	 mov	 eax, DWORD PTR tv76[rsp]
  000af	89 44 24 6c	 mov	 DWORD PTR ucbsize$[rsp], eax

; 1803 :     plbsize = PLBSIZE( dev );

  000b3	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000bb	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  000bf	3d 11 32 00 00	 cmp	 eax, 12817		; 00003211H
  000c4	75 0a		 jne	 SHORT $LN157@printer_ex
  000c6	c7 44 24 7c 84
	00 00 00	 mov	 DWORD PTR tv80[rsp], 132 ; 00000084H
  000ce	eb 08		 jmp	 SHORT $LN158@printer_ex
$LN157@printer_ex:
  000d0	c7 44 24 7c 84
	00 00 00	 mov	 DWORD PTR tv80[rsp], 132 ; 00000084H
$LN158@printer_ex:
  000d8	8b 44 24 7c	 mov	 eax, DWORD PTR tv80[rsp]
  000dc	89 44 24 50	 mov	 DWORD PTR plbsize$[rsp], eax

; 1804 : 
; 1805 :     /* Reset flags at start of CCW chain */
; 1806 :     if (!ccwseq)

  000e0	83 bc 24 10 05
	00 00 00	 cmp	 DWORD PTR ccwseq$[rsp], 0
  000e8	75 1f		 jne	 SHORT $LN15@printer_ex

; 1807 :         dev->diaggate = 0;

  000ea	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f2	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  000f8	83 e0 ef	 and	 eax, -17		; ffffffefH
  000fb	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00103	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax
$LN15@printer_ex:

; 1808 : 
; 1809 :     /* Open the device file if necessary */
; 1810 :     if (dev->fd < 0 && !IS_CCW_SENSE( code ))

  00109	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00111	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00118	7d 23		 jge	 SHORT $LN16@printer_ex
  0011a	0f b6 84 24 e8
	04 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00122	83 e0 0f	 and	 eax, 15
  00125	83 f8 04	 cmp	 eax, 4
  00128	74 13		 je	 SHORT $LN16@printer_ex

; 1811 :         rc = open_printer( dev );

  0012a	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00132	e8 00 00 00 00	 call	 open_printer
  00137	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax
  0013b	eb 3a		 jmp	 SHORT $LN17@printer_ex
$LN16@printer_ex:

; 1812 :     else
; 1813 :     {
; 1814 :         /* If printer stopped, return intervention required */
; 1815 :         if (dev->stopdev && !IS_CCW_SENSE( code ))

  0013d	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00145	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  0014b	c1 e8 02	 shr	 eax, 2
  0014e	83 e0 01	 and	 eax, 1
  00151	85 c0		 test	 eax, eax
  00153	74 1a		 je	 SHORT $LN18@printer_ex
  00155	0f b6 84 24 e8
	04 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0015d	83 e0 0f	 and	 eax, 15
  00160	83 f8 04	 cmp	 eax, 4
  00163	74 0a		 je	 SHORT $LN18@printer_ex

; 1816 :             rc = -1;

  00165	c7 44 24 68 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
  0016d	eb 08		 jmp	 SHORT $LN19@printer_ex
$LN18@printer_ex:

; 1817 :         else
; 1818 :             rc = 0;

  0016f	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN19@printer_ex:
$LN17@printer_ex:

; 1819 :     }
; 1820 : 
; 1821 :     if (rc < 0)

  00177	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  0017c	7d 29		 jge	 SHORT $LN20@printer_ex

; 1822 :     {
; 1823 :         /* Set unit check with intervention required */
; 1824 :         dev->sense[0] = SENSE_IR;

  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	48 6b c0 00	 imul	 rax, rax, 0
  00187	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018f	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 1825 :         *unitstat = CSW_UC;

  00197	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0019f	c6 00 02	 mov	 BYTE PTR [rax], 2

; 1826 :         return;

  001a2	e9 e3 10 00 00	 jmp	 $LN1@printer_ex
$LN20@printer_ex:

; 1827 :     }
; 1828 : 
; 1829 :     /* Reset skip immediate flag before processing CCW opcode */
; 1830 :     dev->skpimmed = 0;

  001a7	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001af	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  001b5	0f ba f0 08	 btr	 eax, 8
  001b9	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001c1	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 1831 : 
; 1832 :     /* Process depending on CCW opcode */
; 1833 :     switch (code)

  001c7	0f b6 84 24 e8
	04 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  001cf	89 44 24 5c	 mov	 DWORD PTR tv139[rsp], eax
  001d3	8b 44 24 5c	 mov	 eax, DWORD PTR tv139[rsp]
  001d7	ff c8		 dec	 eax
  001d9	89 44 24 5c	 mov	 DWORD PTR tv139[rsp], eax
  001dd	81 7c 24 5c fa
	00 00 00	 cmp	 DWORD PTR tv139[rsp], 250 ; 000000faH
  001e5	0f 87 7b 10 00
	00		 ja	 $LN149@printer_ex
  001eb	48 63 44 24 5c	 movsxd	 rax, DWORD PTR tv139[rsp]
  001f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  001f7	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN175@printer_ex[rcx+rax]
  001ff	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN176@printer_ex[rcx+rax*4]
  00206	48 03 c1	 add	 rax, rcx
  00209	ff e0		 jmp	 rax
$LN21@printer_ex:

; 1834 :     {
; 1835 :     /*---------------------------------------------------------------*/
; 1836 :     /* DIAGNOSTIC READ PLB                                           */
; 1837 :     /*---------------------------------------------------------------*/
; 1838 :     case 0x02:
; 1839 : 
; 1840 :         /* Calculate residual byte count */
; 1841 :         num = (count < plbsize) ? count : plbsize;

  0020b	8b 44 24 50	 mov	 eax, DWORD PTR plbsize$[rsp]
  0020f	39 84 24 00 05
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00216	73 10		 jae	 SHORT $LN159@printer_ex
  00218	8b 84 24 00 05
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0021f	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv141[rsp], eax
  00226	eb 0b		 jmp	 SHORT $LN160@printer_ex
$LN159@printer_ex:
  00228	8b 44 24 50	 mov	 eax, DWORD PTR plbsize$[rsp]
  0022c	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv141[rsp], eax
$LN160@printer_ex:
  00233	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv141[rsp]
  0023a	89 44 24 44	 mov	 DWORD PTR num$[rsp], eax

; 1842 :         *residual = count - num;

  0023e	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  00242	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00249	2b c8		 sub	 ecx, eax
  0024b	8b c1		 mov	 eax, ecx
  0024d	48 8b 8c 24 30
	05 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00255	89 01		 mov	 DWORD PTR [rcx], eax

; 1843 :         if (count < plbsize) *more = 1;

  00257	8b 44 24 50	 mov	 eax, DWORD PTR plbsize$[rsp]
  0025b	39 84 24 00 05
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00262	73 0b		 jae	 SHORT $LN22@printer_ex
  00264	48 8b 84 24 20
	05 00 00	 mov	 rax, QWORD PTR more$[rsp]
  0026c	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN22@printer_ex:

; 1844 : 
; 1845 :         /* Copy PLB to channel I/O buffer */
; 1846 :         memcpy( iobuf, dev->plb, num );

  0026f	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  00273	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0027b	48 81 c1 5c 0f
	00 00		 add	 rcx, 3932		; 00000f5cH
  00282	48 8b bc 24 18
	05 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0028a	48 8b f1	 mov	 rsi, rcx
  0028d	8b c8		 mov	 ecx, eax
  0028f	f3 a4		 rep movsb

; 1847 : 
; 1848 :         /* Return normal status */
; 1849 :         *unitstat = CSW_CE | CSW_DE;

  00291	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00299	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1850 :         break;

  0029c	e9 e9 0f 00 00	 jmp	 $LN5@printer_ex
$LN23@printer_ex:

; 1851 : 
; 1852 :     /*---------------------------------------------------------------*/
; 1853 :     /* NOP                                                           */
; 1854 :     /*---------------------------------------------------------------*/
; 1855 :     case 0x03:
; 1856 : 
; 1857 :         /* No Operation */
; 1858 :         *unitstat = CSW_CE | CSW_DE;

  002a1	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  002a9	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1859 :         break;

  002ac	e9 d9 0f 00 00	 jmp	 $LN5@printer_ex
$LN24@printer_ex:

; 1860 : 
; 1861 :     /*---------------------------------------------------------------*/
; 1862 :     /* SENSE                                                         */
; 1863 :     /*---------------------------------------------------------------*/
; 1864 :     case 0x04:
; 1865 : 
; 1866 :         /* Calculate residual byte count */
; 1867 :         num = (count < dev->numsense) ? count : dev->numsense;

  002b1	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002b9	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  002bf	39 84 24 00 05
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  002c6	73 10		 jae	 SHORT $LN161@printer_ex
  002c8	8b 84 24 00 05
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  002cf	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv154[rsp], eax
  002d6	eb 15		 jmp	 SHORT $LN162@printer_ex
$LN161@printer_ex:
  002d8	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002e0	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  002e6	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv154[rsp], eax
$LN162@printer_ex:
  002ed	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv154[rsp]
  002f4	89 44 24 44	 mov	 DWORD PTR num$[rsp], eax

; 1868 :         *residual = count - num;

  002f8	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  002fc	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00303	2b c8		 sub	 ecx, eax
  00305	8b c1		 mov	 eax, ecx
  00307	48 8b 8c 24 30
	05 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0030f	89 01		 mov	 DWORD PTR [rcx], eax

; 1869 :         if (count < dev->numsense) *more = 1;

  00311	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00319	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  0031f	39 84 24 00 05
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00326	73 0b		 jae	 SHORT $LN25@printer_ex
  00328	48 8b 84 24 20
	05 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00330	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN25@printer_ex:

; 1870 : 
; 1871 :         /* Copy device sense bytes to channel I/O buffer */
; 1872 :         memcpy( iobuf, dev->sense, num );

  00333	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  00337	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0033f	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  00346	48 8b bc 24 18
	05 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0034e	48 8b f1	 mov	 rsi, rcx
  00351	8b c8		 mov	 ecx, eax
  00353	f3 a4		 rep movsb

; 1873 : 
; 1874 :         /* Clear the device sense bytes */
; 1875 :         memset( dev->sense, 0, sizeof( dev->sense ));

  00355	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0035d	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  00363	48 8b f8	 mov	 rdi, rax
  00366	33 c0		 xor	 eax, eax
  00368	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0036d	f3 aa		 rep stosb

; 1876 : 
; 1877 :         /* Return normal status */
; 1878 :         *unitstat = CSW_CE | CSW_DE;

  0036f	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00377	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1879 :         break;

  0037a	e9 0b 0f 00 00	 jmp	 $LN5@printer_ex
$LN26@printer_ex:
$LN27@printer_ex:
$LN28@printer_ex:
$LN29@printer_ex:
$LN30@printer_ex:
$LN31@printer_ex:
$LN32@printer_ex:
$LN33@printer_ex:
$LN34@printer_ex:
$LN35@printer_ex:
$LN36@printer_ex:
$LN37@printer_ex:
$LN38@printer_ex:
$LN39@printer_ex:
$LN40@printer_ex:
$LN41@printer_ex:

; 1880 : 
; 1881 :     /*---------------------------------------------------------------*/
; 1882 :     /* WRITE DATA THEN MOVE CARRIAGE COMMANDS                        */
; 1883 :     /*---------------------------------------------------------------*/
; 1884 :     case 0x01:  /*  Write Without Spacing         */
; 1885 :     case 0x09:  /*  Write and Space 1 Line        */
; 1886 :     case 0x11:  /*  Write and Space 2 Lines       */
; 1887 :     case 0x19:  /*  Write and Space 3 Lines       */
; 1888 :     case 0x89:  /*  Write and Skip to Channel 1   */
; 1889 :     case 0x91:  /*  Write and Skip to Channel 2   */
; 1890 :     case 0x99:  /*  Write and Skip to Channel 3   */
; 1891 :     case 0xA1:  /*  Write and Skip to Channel 4   */
; 1892 :     case 0xA9:  /*  Write and Skip to Channel 5   */
; 1893 :     case 0xB1:  /*  Write and Skip to Channel 6   */
; 1894 :     case 0xB9:  /*  Write and Skip to Channel 7   */
; 1895 :     case 0xC1:  /*  Write and Skip to Channel 8   */
; 1896 :     case 0xC9:  /*  Write and Skip to Channel 9   */
; 1897 :     case 0xD1:  /*  Write and Skip to Channel 10  */
; 1898 :     case 0xD9:  /*  Write and Skip to Channel 11  */
; 1899 :     case 0xE1:  /*  Write and Skip to Channel 12  */
; 1900 : 
; 1901 :         if (WriteLine( dev, code, flags, chained, count, iobuf, unitstat, residual ) == 0)

  0037f	48 8b 84 24 30
	05 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00387	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0038c	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00394	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00399	48 8b 84 24 18
	05 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  003a1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003a6	8b 84 24 00 05
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  003ad	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003b1	44 0f b6 8c 24
	f8 04 00 00	 movzx	 r9d, BYTE PTR chained$[rsp]
  003ba	44 0f b6 84 24
	f0 04 00 00	 movzx	 r8d, BYTE PTR flags$[rsp]
  003c3	0f b6 94 24 e8
	04 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  003cb	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003d3	e8 00 00 00 00	 call	 WriteLine
  003d8	0f b6 c0	 movzx	 eax, al
  003db	85 c0		 test	 eax, eax
  003dd	75 3b		 jne	 SHORT $LN42@printer_ex

; 1902 :         {
; 1903 :             if (!(flags & CCW_FLAGS_CD))

  003df	0f b6 84 24 f0
	04 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  003e7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003ec	85 c0		 test	 eax, eax
  003ee	75 1f		 jne	 SHORT $LN43@printer_ex

; 1904 :                 DoSpaceOrSkip( dev, code, unitstat );

  003f0	4c 8b 84 24 28
	05 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  003f8	0f b6 94 24 e8
	04 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  00400	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00408	e8 00 00 00 00	 call	 DoSpaceOrSkip
  0040d	eb 0b		 jmp	 SHORT $LN44@printer_ex
$LN43@printer_ex:

; 1905 :             else
; 1906 :                 *unitstat = CSW_CE | CSW_DE;

  0040f	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00417	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN44@printer_ex:
$LN42@printer_ex:

; 1907 :         }
; 1908 :         break;

  0041a	e9 6b 0e 00 00	 jmp	 $LN5@printer_ex
$LN45@printer_ex:
$LN46@printer_ex:
$LN47@printer_ex:
$LN48@printer_ex:
$LN49@printer_ex:
$LN50@printer_ex:
$LN51@printer_ex:
$LN52@printer_ex:
$LN53@printer_ex:
$LN54@printer_ex:
$LN55@printer_ex:
$LN56@printer_ex:
$LN57@printer_ex:
$LN58@printer_ex:
$LN59@printer_ex:

; 1909 : 
; 1910 :     /*---------------------------------------------------------------*/
; 1911 :     /* CONTROL IMMEDIATE COMMANDS                                    */
; 1912 :     /*---------------------------------------------------------------*/
; 1913 :     case 0x0B:  /*  Space 1 Line       Immediate  */
; 1914 :     case 0x13:  /*  Space 2 Lines      Immediate  */
; 1915 :     case 0x1B:  /*  Space 3 Lines      Immediate  */
; 1916 :     case 0x8B:  /*  Skip to Channel 1  Immediate  */
; 1917 :     case 0x93:  /*  Skip to Channel 2  Immediate  */
; 1918 :     case 0x9B:  /*  Skip to Channel 3  Immediate  */
; 1919 :     case 0xA3:  /*  Skip to Channel 4  Immediate  */
; 1920 :     case 0xAB:  /*  Skip to Channel 5  Immediate  */
; 1921 :     case 0xB3:  /*  Skip to Channel 6  Immediate  */
; 1922 :     case 0xBB:  /*  Skip to Channel 7  Immediate  */
; 1923 :     case 0xC3:  /*  Skip to Channel 8  Immediate  */
; 1924 :     case 0xCB:  /*  Skip to Channel 9  Immediate  */
; 1925 :     case 0xD3:  /*  Skip to Channel 10 Immediate  */
; 1926 :     case 0xDB:  /*  Skip to Channel 11 Immediate  */
; 1927 :     case 0xE3:  /*  Skip to Channel 12 Immediate  */
; 1928 : 
; 1929 :         DoSpaceOrSkip( dev, code, unitstat );

  0041f	4c 8b 84 24 28
	05 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  00427	0f b6 94 24 e8
	04 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  0042f	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00437	e8 00 00 00 00	 call	 DoSpaceOrSkip

; 1930 :         break;

  0043c	e9 49 0e 00 00	 jmp	 $LN5@printer_ex
$LN60@printer_ex:
$LN61@printer_ex:
$LN62@printer_ex:
$LN63@printer_ex:
$LN64@printer_ex:
$LN65@printer_ex:
$LN66@printer_ex:
$LN67@printer_ex:
$LN68@printer_ex:
$LN69@printer_ex:
$LN70@printer_ex:
$LN71@printer_ex:
$LN72@printer_ex:
$LN73@printer_ex:
$LN74@printer_ex:

; 1931 : 
; 1932 :     /*---------------------------------------------------------------*/
; 1933 :     /* 1403 DIAGNOSTIC WRITE                                         */
; 1934 :     /*---------------------------------------------------------------*/
; 1935 :                case 0x0D:
; 1936 :     case 0x15: case 0x1D:
; 1937 :                case 0x8D:
; 1938 :     case 0x95: case 0x9D:
; 1939 :     case 0xA5: case 0xAD:
; 1940 :     case 0xB5: case 0xBD:
; 1941 :     case 0xC5: case 0xCD:
; 1942 :     case 0xD5: case 0xDD:
; 1943 :     case 0xE5:
; 1944 : 
; 1945 :         if (dev->devtype != 0x1403)

  00441	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00449	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0044d	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  00452	74 29		 je	 SHORT $LN75@printer_ex

; 1946 :         {
; 1947 :             /* Command Reject */
; 1948 :             dev->sense[0] = SENSE_CR;

  00454	b8 01 00 00 00	 mov	 eax, 1
  00459	48 6b c0 00	 imul	 rax, rax, 0
  0045d	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00465	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1949 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0046d	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00475	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1950 :             break;

  00478	e9 0d 0e 00 00	 jmp	 $LN5@printer_ex
$LN75@printer_ex:
$LN76@printer_ex:

; 1951 :         }
; 1952 : 
; 1953 :         /* PURPOSELY FALL THROUGH to case 0x05: */
; 1954 :         /* FALLTHRU */
; 1955 : 
; 1956 :     /*---------------------------------------------------------------*/
; 1957 :     /* DIAGNOSTIC WRITE                                              */
; 1958 :     /*---------------------------------------------------------------*/
; 1959 :     case 0x05:
; 1960 : 
; 1961 :         /* Diagnostic write is not supported on the 3203 */
; 1962 :         if (dev->devtype == 0x3203)

  0047d	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00485	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00489	3d 03 32 00 00	 cmp	 eax, 12803		; 00003203H
  0048e	75 29		 jne	 SHORT $LN77@printer_ex

; 1963 :         {
; 1964 :             /* Command Reject */
; 1965 :             dev->sense[0] = SENSE_CR;

  00490	b8 01 00 00 00	 mov	 eax, 1
  00495	48 6b c0 00	 imul	 rax, rax, 0
  00499	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004a1	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1966 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  004a9	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  004b1	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1967 :         }

  004b4	e9 93 00 00 00	 jmp	 $LN78@printer_ex
$LN77@printer_ex:

; 1968 :         else
; 1969 :         {
; 1970 :             /* Calculate number of bytes to write and set residual count */
; 1971 :             num = (count < plbsize) ? count : plbsize;

  004b9	8b 44 24 50	 mov	 eax, DWORD PTR plbsize$[rsp]
  004bd	39 84 24 00 05
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  004c4	73 10		 jae	 SHORT $LN163@printer_ex
  004c6	8b 84 24 00 05
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  004cd	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv203[rsp], eax
  004d4	eb 0b		 jmp	 SHORT $LN164@printer_ex
$LN163@printer_ex:
  004d6	8b 44 24 50	 mov	 eax, DWORD PTR plbsize$[rsp]
  004da	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv203[rsp], eax
$LN164@printer_ex:
  004e1	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv203[rsp]
  004e8	89 44 24 44	 mov	 DWORD PTR num$[rsp], eax

; 1972 :             *residual = count - num;

  004ec	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  004f0	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  004f7	2b c8		 sub	 ecx, eax
  004f9	8b c1		 mov	 eax, ecx
  004fb	48 8b 8c 24 30
	05 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00503	89 01		 mov	 DWORD PTR [rcx], eax

; 1973 : 
; 1974 :             /* Clear PLB of any previously printed data */
; 1975 :             memset( dev->plb, 0, sizeof( dev->plb ));

  00505	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0050d	48 05 5c 0f 00
	00		 add	 rax, 3932		; 00000f5cH
  00513	48 8b f8	 mov	 rdi, rax
  00516	33 c0		 xor	 eax, eax
  00518	b9 96 00 00 00	 mov	 ecx, 150		; 00000096H
  0051d	f3 aa		 rep stosb

; 1976 : 
; 1977 :             /* Copy channel I/O buffer to PLB */
; 1978 :             memcpy( dev->plb, iobuf, num );

  0051f	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  00523	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0052b	48 81 c1 5c 0f
	00 00		 add	 rcx, 3932		; 00000f5cH
  00532	48 8b f9	 mov	 rdi, rcx
  00535	48 8b b4 24 18
	05 00 00	 mov	 rsi, QWORD PTR iobuf$[rsp]
  0053d	8b c8		 mov	 ecx, eax
  0053f	f3 a4		 rep movsb

; 1979 : 
; 1980 :             /* Return normal status */
; 1981 :             *unitstat = CSW_CE | CSW_DE;

  00541	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00549	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN78@printer_ex:

; 1982 :         }
; 1983 :         break;

  0054c	e9 39 0d 00 00	 jmp	 $LN5@printer_ex
$LN79@printer_ex:

; 1984 : 
; 1985 :     /*---------------------------------------------------------------*/
; 1986 :     /* DIAGNOSTIC CHECK READ                                         */
; 1987 :     /*---------------------------------------------------------------*/
; 1988 :     case 0x06:
; 1989 : 
; 1990 :         /*      (Note: "PLB" = "Print Line Buffer")
; 1991 : 
; 1992 :         This command transfers unique check information stored
; 1993 :         in each addressable position of the PLB to the channel.
; 1994 :         It is normally used for diagnostic purposes, such as fault
; 1995 :         isolation to an individual print position.  Bit positions
; 1996 :         (zero) (0) through four (4) on bus-in are not used.  Bit
; 1997 :         position five (5) signifies that the print line complete
; 1998 :         (PLC) bit was set, indicating that a print compare was
; 1999 :         completed for the corresponding position or that the PLB
; 2000 :         contained a blank or null code.  Bit position six (6)
; 2001 :         signifies that the print error check (PEC) bit had been set
; 2002 :         due to invalid parity or a hammer check for the corres-
; 2003 :         ponding print position.  Bit seven (7) signifies that
; 2004 :         invalid parity was detected for the nine data bits in that
; 2005 :         PLB position.
; 2006 :         */
; 2007 :         if (!dev->diaggate)

  00551	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00559	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  0055f	c1 e8 04	 shr	 eax, 4
  00562	83 e0 01	 and	 eax, 1
  00565	85 c0		 test	 eax, eax
  00567	0f 85 8c 00 00
	00		 jne	 $LN80@printer_ex

; 2008 :         {
; 2009 :             /* Calculate residual byte count */
; 2010 :             num = (count < plbsize) ? count : plbsize;

  0056d	8b 44 24 50	 mov	 eax, DWORD PTR plbsize$[rsp]
  00571	39 84 24 00 05
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00578	73 10		 jae	 SHORT $LN165@printer_ex
  0057a	8b 84 24 00 05
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00581	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv222[rsp], eax
  00588	eb 0b		 jmp	 SHORT $LN166@printer_ex
$LN165@printer_ex:
  0058a	8b 44 24 50	 mov	 eax, DWORD PTR plbsize$[rsp]
  0058e	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv222[rsp], eax
$LN166@printer_ex:
  00595	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv222[rsp]
  0059c	89 44 24 44	 mov	 DWORD PTR num$[rsp], eax

; 2011 :             *residual = count - num;

  005a0	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  005a4	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  005ab	2b c8		 sub	 ecx, eax
  005ad	8b c1		 mov	 eax, ecx
  005af	48 8b 8c 24 30
	05 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  005b7	89 01		 mov	 DWORD PTR [rcx], eax

; 2012 :             if (count < plbsize) *more = 1;

  005b9	8b 44 24 50	 mov	 eax, DWORD PTR plbsize$[rsp]
  005bd	39 84 24 00 05
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  005c4	73 0b		 jae	 SHORT $LN82@printer_ex
  005c6	48 8b 84 24 20
	05 00 00	 mov	 rax, QWORD PTR more$[rsp]
  005ce	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN82@printer_ex:

; 2013 : 
; 2014 :             /* Copy requested Check Read bytes to channel I/O buffer */
; 2015 :             memset( iobuf, 0x04, num );

  005d1	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  005d5	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv227[rsp], rax
  005dd	48 8b bc 24 18
	05 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  005e5	b8 04 00 00 00	 mov	 eax, 4
  005ea	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv227[rsp]
  005f2	f3 aa		 rep stosb

; 2016 :         }

  005f4	e9 dd 00 00 00	 jmp	 $LN81@printer_ex
$LN80@printer_ex:

; 2017 :         else /* (dev->diaggate) */
; 2018 :         {
; 2019 :             /*
; 2020 :             When the 'check read' command is given after a 'diagnostic
; 2021 :             gate' command, the eight bits of the FCB pointer indicating
; 2022 :             the position of the current line in the forms control buffer
; 2023 :             are transferred to the channel.  The maximum data transfer
; 2024 :             length is 1.  The value of the FCB pointer is encoded in the
; 2025 :             same way as the 3811, as follows:
; 2026 : 
; 2027 :              * Internally, the FCB position is stored in 'zero origin'
; 2028 :                notation (the first line is line 0, the second line is
; 2029 :                line 1, etc...
; 2030 : 
; 2031 :              * A value of two is added to the zero origin notatIon.
; 2032 : 
; 2033 :              * The hexadecimal notation of the resultant one-byte value
; 2034 :                is reversed (bits 7, 6, 5, 4, 3, 2, 1, 0 become bits 0, 1,
; 2035 :                2, 3, 4, 5, 6, 7 respectively).
; 2036 : 
; 2037 :             For example, FCB pointer value hex '40' is encoded for the
; 2038 :             first line of the form; hex 'C0' is encoded for the second
; 2039 :             line, etc...
; 2040 :             */
; 2041 :             iobuf[0] = (BYTE)(dev->currline - 1);   // zero origin

  005f9	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00601	8b 80 a8 0d 00
	00		 mov	 eax, DWORD PTR [rax+3496]
  00607	ff c8		 dec	 eax
  00609	b9 01 00 00 00	 mov	 ecx, 1
  0060e	48 6b c9 00	 imul	 rcx, rcx, 0
  00612	48 8b 94 24 18
	05 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0061a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2042 :             iobuf[0] += 2;                          // plus 2

  0061d	b8 01 00 00 00	 mov	 eax, 1
  00622	48 6b c0 00	 imul	 rax, rax, 0
  00626	48 8b 8c 24 18
	05 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0062e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00632	83 c0 02	 add	 eax, 2
  00635	b9 01 00 00 00	 mov	 ecx, 1
  0063a	48 6b c9 00	 imul	 rcx, rcx, 0
  0063e	48 8b 94 24 18
	05 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  00646	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2043 :             iobuf[0] = reverse_bits( iobuf[0] );    // reverse bits

  00649	b8 01 00 00 00	 mov	 eax, 1
  0064e	48 6b c0 00	 imul	 rax, rax, 0
  00652	48 8b 8c 24 18
	05 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0065a	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0065e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_reverse_bits
  00664	b9 01 00 00 00	 mov	 ecx, 1
  00669	48 6b c9 00	 imul	 rcx, rcx, 0
  0066d	48 8b 94 24 18
	05 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  00675	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2044 : 
; 2045 :             /* Calculate residual byte count */
; 2046 :             num = (count < 1) ? count : 1;

  00678	83 bc 24 00 05
	00 00 01	 cmp	 DWORD PTR count$[rsp], 1
  00680	73 10		 jae	 SHORT $LN167@printer_ex
  00682	8b 84 24 00 05
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00689	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv249[rsp], eax
  00690	eb 0b		 jmp	 SHORT $LN168@printer_ex
$LN167@printer_ex:
  00692	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv249[rsp], 1
$LN168@printer_ex:
  0069d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv249[rsp]
  006a4	89 44 24 44	 mov	 DWORD PTR num$[rsp], eax

; 2047 :             *residual = count - num;

  006a8	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  006ac	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  006b3	2b c8		 sub	 ecx, eax
  006b5	8b c1		 mov	 eax, ecx
  006b7	48 8b 8c 24 30
	05 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  006bf	89 01		 mov	 DWORD PTR [rcx], eax

; 2048 :             if (count < 1) *more = 1;

  006c1	83 bc 24 00 05
	00 00 01	 cmp	 DWORD PTR count$[rsp], 1
  006c9	73 0b		 jae	 SHORT $LN83@printer_ex
  006cb	48 8b 84 24 20
	05 00 00	 mov	 rax, QWORD PTR more$[rsp]
  006d3	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN83@printer_ex:
$LN81@printer_ex:

; 2049 :         }
; 2050 : 
; 2051 :         /* Return normal status */
; 2052 :         *unitstat = CSW_CE | CSW_DE;

  006d6	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  006de	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2053 :         break;

  006e1	e9 a4 0b 00 00	 jmp	 $LN5@printer_ex
$LN84@printer_ex:

; 2054 : 
; 2055 :     /*---------------------------------------------------------------*/
; 2056 :     /* DIAGNOSTIC GATE                                               */
; 2057 :     /*---------------------------------------------------------------*/
; 2058 :     case 0x07:
; 2059 : 
; 2060 :         /* Command reject if 1403. Otherwise treated as NOP */
; 2061 :         if (dev->devtype == 0x1403)

  006e6	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006ee	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  006f2	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  006f7	75 29		 jne	 SHORT $LN85@printer_ex

; 2062 :         {
; 2063 :             /* Command Reject */
; 2064 :             dev->sense[0] = SENSE_CR;

  006f9	b8 01 00 00 00	 mov	 eax, 1
  006fe	48 6b c0 00	 imul	 rax, rax, 0
  00702	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0070a	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 2065 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00712	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0071a	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2066 :             break;

  0071d	e9 68 0b 00 00	 jmp	 $LN5@printer_ex
$LN85@printer_ex:

; 2067 :         }
; 2068 : 
; 2069 :         /* Set diagnostic gate flag */
; 2070 :         dev->diaggate = 1;

  00722	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0072a	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  00730	83 c8 10	 or	 eax, 16
  00733	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0073b	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 2071 : 
; 2072 :         /* Return normal status */
; 2073 :         *unitstat = CSW_CE | CSW_DE;

  00741	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00749	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2074 :         break;

  0074c	e9 39 0b 00 00	 jmp	 $LN5@printer_ex
$LN86@printer_ex:

; 2075 : 
; 2076 :     /*---------------------------------------------------------------*/
; 2077 :     /* DIAGNOSTIC READ UCS BUFFER                                    */
; 2078 :     /*---------------------------------------------------------------*/
; 2079 :     case 0x0A:
; 2080 : 
; 2081 :         /* Reject if 1403 or not preceded by DIAGNOSTIC GATE */
; 2082 :         if (dev->devtype == 0x1403 || !dev->diaggate)

  00751	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00759	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0075d	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  00762	74 18		 je	 SHORT $LN89@printer_ex
  00764	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0076c	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  00772	c1 e8 04	 shr	 eax, 4
  00775	83 e0 01	 and	 eax, 1
  00778	85 c0		 test	 eax, eax
  0077a	75 29		 jne	 SHORT $LN87@printer_ex
$LN89@printer_ex:

; 2083 :         {
; 2084 :             /* Command Reject */
; 2085 :             dev->sense[0] = SENSE_CR;

  0077c	b8 01 00 00 00	 mov	 eax, 1
  00781	48 6b c0 00	 imul	 rax, rax, 0
  00785	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0078d	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 2086 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00795	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0079d	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2087 :         }

  007a0	e9 91 00 00 00	 jmp	 $LN88@printer_ex
$LN87@printer_ex:

; 2088 :         else
; 2089 :         {
; 2090 :             /* Calculate residual byte count */
; 2091 :             num = (count < ucbsize) ? count : ucbsize;

  007a5	8b 44 24 6c	 mov	 eax, DWORD PTR ucbsize$[rsp]
  007a9	39 84 24 00 05
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  007b0	73 10		 jae	 SHORT $LN169@printer_ex
  007b2	8b 84 24 00 05
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  007b9	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv272[rsp], eax
  007c0	eb 0b		 jmp	 SHORT $LN170@printer_ex
$LN169@printer_ex:
  007c2	8b 44 24 6c	 mov	 eax, DWORD PTR ucbsize$[rsp]
  007c6	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv272[rsp], eax
$LN170@printer_ex:
  007cd	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv272[rsp]
  007d4	89 44 24 44	 mov	 DWORD PTR num$[rsp], eax

; 2092 :             *residual = count - num;

  007d8	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  007dc	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  007e3	2b c8		 sub	 ecx, eax
  007e5	8b c1		 mov	 eax, ecx
  007e7	48 8b 8c 24 30
	05 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  007ef	89 01		 mov	 DWORD PTR [rcx], eax

; 2093 :             if (count < ucbsize) *more = 1;

  007f1	8b 44 24 6c	 mov	 eax, DWORD PTR ucbsize$[rsp]
  007f5	39 84 24 00 05
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  007fc	73 0b		 jae	 SHORT $LN90@printer_ex
  007fe	48 8b 84 24 20
	05 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00806	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN90@printer_ex:

; 2094 : 
; 2095 :             /* Copy requested UCB bytes to channel I/O buffer */
; 2096 :             memcpy( iobuf, dev->ucb, num );

  00809	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  0080d	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00815	48 81 c1 ac 0d
	00 00		 add	 rcx, 3500		; 00000dacH
  0081c	48 8b bc 24 18
	05 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00824	48 8b f1	 mov	 rsi, rcx
  00827	8b c8		 mov	 ecx, eax
  00829	f3 a4		 rep movsb

; 2097 : 
; 2098 :             /* Return normal status */
; 2099 :             *unitstat = CSW_CE | CSW_DE;

  0082b	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00833	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN88@printer_ex:

; 2100 :         }
; 2101 :         break;

  00836	e9 4f 0a 00 00	 jmp	 $LN5@printer_ex
$LN91@printer_ex:

; 2102 : 
; 2103 :     /*---------------------------------------------------------------*/
; 2104 :     /* DIAGNOSTIC READ FCB                                           */
; 2105 :     /*---------------------------------------------------------------*/
; 2106 :     case 0x12:
; 2107 : 
; 2108 :         /* Reject if 1403 or not preceded by DIAGNOSTIC GATE */
; 2109 :         if (dev->devtype == 0x1403 || !dev->diaggate)

  0083b	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00843	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00847	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  0084c	74 18		 je	 SHORT $LN94@printer_ex
  0084e	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00856	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  0085c	c1 e8 04	 shr	 eax, 4
  0085f	83 e0 01	 and	 eax, 1
  00862	85 c0		 test	 eax, eax
  00864	75 29		 jne	 SHORT $LN92@printer_ex
$LN94@printer_ex:

; 2110 :         {
; 2111 :             /* Command Reject */
; 2112 :             dev->sense[0] = SENSE_CR;

  00866	b8 01 00 00 00	 mov	 eax, 1
  0086b	48 6b c0 00	 imul	 rax, rax, 0
  0086f	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00877	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 2113 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0087f	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00887	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2114 :         }

  0088a	e9 c4 01 00 00	 jmp	 $LN93@printer_ex
$LN92@printer_ex:

; 2115 :         else
; 2116 :         {
; 2117 :             U32 i = 0;      // iobuf index

  0088f	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0

; 2118 :             U32 f;          // FCB index
; 2119 :             U32 k;          // work count
; 2120 :             BYTE b;         // work byte
; 2121 : 
; 2122 :             /* Calculate residual byte count */
; 2123 :             num = (count < fcbsize) ? count : fcbsize;

  00897	8b 44 24 60	 mov	 eax, DWORD PTR fcbsize$[rsp]
  0089b	39 84 24 00 05
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  008a2	73 10		 jae	 SHORT $LN171@printer_ex
  008a4	8b 84 24 00 05
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  008ab	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv293[rsp], eax
  008b2	eb 0b		 jmp	 SHORT $LN172@printer_ex
$LN171@printer_ex:
  008b4	8b 44 24 60	 mov	 eax, DWORD PTR fcbsize$[rsp]
  008b8	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv293[rsp], eax
$LN172@printer_ex:
  008bf	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv293[rsp]
  008c6	89 44 24 44	 mov	 DWORD PTR num$[rsp], eax

; 2124 :             *residual = count - num;

  008ca	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  008ce	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  008d5	2b c8		 sub	 ecx, eax
  008d7	8b c1		 mov	 eax, ecx
  008d9	48 8b 8c 24 30
	05 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  008e1	89 01		 mov	 DWORD PTR [rcx], eax

; 2125 :             if (count < fcbsize) *more = 1;

  008e3	8b 44 24 60	 mov	 eax, DWORD PTR fcbsize$[rsp]
  008e7	39 84 24 00 05
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  008ee	73 0b		 jae	 SHORT $LN95@printer_ex
  008f0	48 8b 84 24 20
	05 00 00	 mov	 rax, QWORD PTR more$[rsp]
  008f8	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN95@printer_ex:

; 2126 : 
; 2127 :             /* Copy requested FCB bytes to channel I/O buffer */
; 2128 :             if (dev->index)

  008fb	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00903	83 b8 8c 07 00
	00 00		 cmp	 DWORD PTR [rax+1932], 0
  0090a	74 64		 je	 SHORT $LN96@printer_ex

; 2129 :             {
; 2130 :                 if (dev->index < 0)

  0090c	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00914	83 b8 8c 07 00
	00 00		 cmp	 DWORD PTR [rax+1932], 0
  0091b	7d 1e		 jge	 SHORT $LN97@printer_ex

; 2131 :                     b = 0xC0 | ((BYTE)-dev->index);

  0091d	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00925	8b 80 8c 07 00
	00		 mov	 eax, DWORD PTR [rax+1932]
  0092b	f7 d8		 neg	 eax
  0092d	0f b6 c0	 movzx	 eax, al
  00930	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  00935	88 44 24 40	 mov	 BYTE PTR b$1[rsp], al
  00939	eb 17		 jmp	 SHORT $LN98@printer_ex
$LN97@printer_ex:

; 2132 :                 else
; 2133 :                     b = 0x80 | ((BYTE)+dev->index);

  0093b	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00943	0f b6 80 8c 07
	00 00		 movzx	 eax, BYTE PTR [rax+1932]
  0094a	0f ba e8 07	 bts	 eax, 7
  0094e	88 44 24 40	 mov	 BYTE PTR b$1[rsp], al
$LN98@printer_ex:

; 2134 : 
; 2135 :                 iobuf[i++] = b;

  00952	8b 44 24 48	 mov	 eax, DWORD PTR i$3[rsp]
  00956	48 8b 8c 24 18
	05 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0095e	0f b6 54 24 40	 movzx	 edx, BYTE PTR b$1[rsp]
  00963	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00966	8b 44 24 48	 mov	 eax, DWORD PTR i$3[rsp]
  0096a	ff c0		 inc	 eax
  0096c	89 44 24 48	 mov	 DWORD PTR i$3[rsp], eax
$LN96@printer_ex:

; 2136 :             }
; 2137 :             for (k=dev->lpp, f=1; f <= k && i < num; f++)

  00970	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00978	8b 80 90 07 00
	00		 mov	 eax, DWORD PTR [rax+1936]
  0097e	89 84 24 9c 00
	00 00		 mov	 DWORD PTR k$8[rsp], eax
  00985	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR f$6[rsp], 1
  0098d	eb 0a		 jmp	 SHORT $LN9@printer_ex
$LN7@printer_ex:
  0098f	8b 44 24 58	 mov	 eax, DWORD PTR f$6[rsp]
  00993	ff c0		 inc	 eax
  00995	89 44 24 58	 mov	 DWORD PTR f$6[rsp], eax
$LN9@printer_ex:
  00999	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR k$8[rsp]
  009a0	39 44 24 58	 cmp	 DWORD PTR f$6[rsp], eax
  009a4	77 7c		 ja	 SHORT $LN8@printer_ex
  009a6	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  009aa	39 44 24 48	 cmp	 DWORD PTR i$3[rsp], eax
  009ae	73 72		 jae	 SHORT $LN8@printer_ex

; 2138 :             {
; 2139 :                 b = (BYTE) dev->fcb[f];

  009b0	8b 44 24 58	 mov	 eax, DWORD PTR f$6[rsp]
  009b4	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009bc	0f b6 84 81 94
	07 00 00	 movzx	 eax, BYTE PTR [rcx+rax*4+1940]
  009c4	88 44 24 40	 mov	 BYTE PTR b$1[rsp], al

; 2140 :                 if (0
; 2141 :                     || (f == 1 && dev->lpi == 8)
; 2142 :                     ||  f == k

  009c8	33 c0		 xor	 eax, eax
  009ca	85 c0		 test	 eax, eax
  009cc	75 25		 jne	 SHORT $LN100@printer_ex
  009ce	83 7c 24 58 01	 cmp	 DWORD PTR f$6[rsp], 1
  009d3	75 11		 jne	 SHORT $LN101@printer_ex
  009d5	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009dd	83 b8 88 07 00
	00 08		 cmp	 DWORD PTR [rax+1928], 8
  009e4	74 0d		 je	 SHORT $LN100@printer_ex
$LN101@printer_ex:
  009e6	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR k$8[rsp]
  009ed	39 44 24 58	 cmp	 DWORD PTR f$6[rsp], eax
  009f1	75 0c		 jne	 SHORT $LN99@printer_ex
$LN100@printer_ex:

; 2143 :                 )
; 2144 :                     b |= 0x10;

  009f3	0f b6 44 24 40	 movzx	 eax, BYTE PTR b$1[rsp]
  009f8	83 c8 10	 or	 eax, 16
  009fb	88 44 24 40	 mov	 BYTE PTR b$1[rsp], al
$LN99@printer_ex:

; 2145 :                 iobuf[i++] = b;

  009ff	8b 44 24 48	 mov	 eax, DWORD PTR i$3[rsp]
  00a03	48 8b 8c 24 18
	05 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00a0b	0f b6 54 24 40	 movzx	 edx, BYTE PTR b$1[rsp]
  00a10	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00a13	8b 44 24 48	 mov	 eax, DWORD PTR i$3[rsp]
  00a17	ff c0		 inc	 eax
  00a19	89 44 24 48	 mov	 DWORD PTR i$3[rsp], eax

; 2146 :             }

  00a1d	e9 6d ff ff ff	 jmp	 $LN7@printer_ex
$LN8@printer_ex:
$LN10@printer_ex:

; 2147 :             while (i < num)

  00a22	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  00a26	39 44 24 48	 cmp	 DWORD PTR i$3[rsp], eax
  00a2a	73 1c		 jae	 SHORT $LN11@printer_ex

; 2148 :                 iobuf[i++] = 0;

  00a2c	8b 44 24 48	 mov	 eax, DWORD PTR i$3[rsp]
  00a30	48 8b 8c 24 18
	05 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00a38	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  00a3c	8b 44 24 48	 mov	 eax, DWORD PTR i$3[rsp]
  00a40	ff c0		 inc	 eax
  00a42	89 44 24 48	 mov	 DWORD PTR i$3[rsp], eax
  00a46	eb da		 jmp	 SHORT $LN10@printer_ex
$LN11@printer_ex:

; 2149 : 
; 2150 :             /* Return normal status */
; 2151 :             *unitstat = CSW_CE | CSW_DE;

  00a48	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00a50	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN93@printer_ex:

; 2152 :         }
; 2153 :         break;

  00a53	e9 32 08 00 00	 jmp	 $LN5@printer_ex
$LN102@printer_ex:

; 2154 : 
; 2155 :     /*---------------------------------------------------------------*/
; 2156 :     /* UNFOLD                                                        */
; 2157 :     /*---------------------------------------------------------------*/
; 2158 :     case 0x23:
; 2159 : 
; 2160 :         if (dev->devtype == 0x1403)

  00a58	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a60	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00a64	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  00a69	75 26		 jne	 SHORT $LN103@printer_ex

; 2161 :         {
; 2162 :             /* Command Reject */
; 2163 :             dev->sense[0] = SENSE_CR;

  00a6b	b8 01 00 00 00	 mov	 eax, 1
  00a70	48 6b c0 00	 imul	 rax, rax, 0
  00a74	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a7c	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 2164 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00a84	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00a8c	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2165 :         }

  00a8f	eb 2a		 jmp	 SHORT $LN104@printer_ex
$LN103@printer_ex:

; 2166 :         else
; 2167 :         {
; 2168 :             /* Reset fold indicator */
; 2169 :             dev->fold = 0;

  00a91	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a99	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  00a9f	83 e0 df	 and	 eax, -33		; ffffffdfH
  00aa2	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00aaa	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 2170 : 
; 2171 :             /* Return normal status */
; 2172 :             *unitstat = CSW_CE | CSW_DE;

  00ab0	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00ab8	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN104@printer_ex:

; 2173 :         }
; 2174 :         break;

  00abb	e9 ca 07 00 00	 jmp	 $LN5@printer_ex
$LN105@printer_ex:

; 2175 : 
; 2176 :     /*---------------------------------------------------------------*/
; 2177 :     /* FOLD                                                          */
; 2178 :     /*---------------------------------------------------------------*/
; 2179 :     case 0x43:
; 2180 : 
; 2181 :         if (dev->devtype == 0x1403)

  00ac0	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ac8	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00acc	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  00ad1	75 26		 jne	 SHORT $LN106@printer_ex

; 2182 :         {
; 2183 :             /* Command Reject */
; 2184 :             dev->sense[0] = SENSE_CR;

  00ad3	b8 01 00 00 00	 mov	 eax, 1
  00ad8	48 6b c0 00	 imul	 rax, rax, 0
  00adc	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ae4	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 2185 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00aec	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00af4	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2186 :         }

  00af7	eb 2a		 jmp	 SHORT $LN107@printer_ex
$LN106@printer_ex:

; 2187 :         else
; 2188 :         {
; 2189 :             /* Set fold indicator */
; 2190 :             dev->fold = 1;

  00af9	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b01	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  00b07	83 c8 20	 or	 eax, 32			; 00000020H
  00b0a	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b12	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 2191 : 
; 2192 :             /* Return normal status */
; 2193 :             *unitstat = CSW_CE | CSW_DE;

  00b18	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00b20	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN107@printer_ex:

; 2194 :         }
; 2195 :         break;

  00b23	e9 62 07 00 00	 jmp	 $LN5@printer_ex
$LN108@printer_ex:

; 2196 : 
; 2197 :     /*---------------------------------------------------------------*/
; 2198 :     /* LOAD FORMS CONTROL BUFFER                                     */
; 2199 :     /*---------------------------------------------------------------*/
; 2200 :     case 0x63:
; 2201 : 
; 2202 :         if (dev->devtype == 0x1403)

  00b28	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b30	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00b34	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  00b39	75 29		 jne	 SHORT $LN109@printer_ex

; 2203 :         {
; 2204 :             /* Command Reject */
; 2205 :             dev->sense[0] = SENSE_CR;

  00b3b	b8 01 00 00 00	 mov	 eax, 1
  00b40	48 6b c0 00	 imul	 rax, rax, 0
  00b44	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b4c	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 2206 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00b54	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00b5c	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2207 :         }

  00b5f	e9 23 03 00 00	 jmp	 $LN110@printer_ex
$LN109@printer_ex:

; 2208 :         else
; 2209 :         {
; 2210 :             /*  The first byte of the FCB image is either the print
; 2211 :             **  position indexing byte, or the lines-per-inch byte.
; 2212 :             **
; 2213 :             **  The print position indexing byte is optional and, when
; 2214 :             **  used, precedes the lines-per-inch byte.
; 2215 :             **
; 2216 :             **  The 3203-5, 3262-5, 4245, 4248, and 6262-14 printers
; 2217 :             **  accept and discard the index byte if it is present,
; 2218 :             **  because they do not support the indexing feature.
; 2219 :             **
; 2220 :             **  A description of the print position indexing feature
; 2221 :             **  and its use can be found in the publication GA24-3543
; 2222 :             **  "IBM 3211 Printer, 3216 Interchangeable Train
; 2223 :             **  Cartridge, and 3811 Printer Control Unit Component
; 2224 :             **  Description and Operator's Guide".
; 2225 :             **
; 2226 :             **  The special index flag contains X'80' plus a binary
; 2227 :             **  index value, from 1 to 32 (the default is 1).  This
; 2228 :             **  index value sets the left margin: 1 indicates flush-
; 2229 :             **  left; any other value indicates a line indented
; 2230 :             **  the specified number of spaces. FISH NOTE: it appears
; 2231 :             **  a negative value sets a negative margin shifting the
; 2232 :             **  print line 'n' columns to the left thus chopping off
; 2233 :             **  the print line at that column (i.e. the first n chars
; 2234 :             **  of the print line are dropped and printing begins in
; 2235 :             **  column 1 with the N'th character of the print line).
; 2236 :             **
; 2237 :             **  The form image begins with the first line of the page,
; 2238 :             **  and if the X'1n' flag bit is set, indicates an 8 lines
; 2239 :             **  per inch form. The default when the X'1n' flag bit is
; 2240 :             **  not set indicates a normal 6 lines per inch form.
; 2241 :             **
; 2242 :             **  All remaining bytes (lines) must contain X'0n', except
; 2243 :             **  the last byte, which must be X'1n'.  The letter n can
; 2244 :             **  be a hexadecimal value from 1 to C, representing a
; 2245 :             **  channel (one to 12), or it can be 0, which means no
; 2246 :             **  channel is indicated for that line.
; 2247 :             */
; 2248 : 
; 2249 :             int  savedfcb[ MAX_FCBSIZE ];
; 2250 : 
; 2251 :             U32  i = 0;     // iobuf index

  00b64	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0

; 2252 :             U32  f;         // FCB index
; 2253 :             int  k;         // work counter
; 2254 :             BYTE b;         // work byte
; 2255 : 
; 2256 :             /* Load Check if X'20' bit on in first byte of FCB */
; 2257 :             if (iobuf[0] & 0x20)

  00b6c	b8 01 00 00 00	 mov	 eax, 1
  00b71	48 6b c0 00	 imul	 rax, rax, 0
  00b75	48 8b 8c 24 18
	05 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00b7d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b81	83 e0 20	 and	 eax, 32			; 00000020H
  00b84	85 c0		 test	 eax, eax
  00b86	74 3a		 je	 SHORT $LN111@printer_ex

; 2258 :             {
; 2259 :                 /* Set Unit Check, SENSE = Load Check */
; 2260 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00b88	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00b90	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2261 :                 dev->sense[0] = SENSE_LDCK;

  00b93	b8 01 00 00 00	 mov	 eax, 1
  00b98	48 6b c0 00	 imul	 rax, rax, 0
  00b9c	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ba4	c6 84 01 64 03
	00 00 02	 mov	 BYTE PTR [rcx+rax+868], 2

; 2262 :                 *residual = count;

  00bac	48 8b 84 24 30
	05 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00bb4	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00bbb	89 08		 mov	 DWORD PTR [rax], ecx

; 2263 :                 break;

  00bbd	e9 c8 06 00 00	 jmp	 $LN5@printer_ex
$LN111@printer_ex:

; 2264 :             }
; 2265 : 
; 2266 :             /* Save old fcb and clear to zero; new one being loaded */
; 2267 :             memcpy( savedfcb, dev->fcb, sizeof( savedfcb ));

  00bc2	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR savedfcb$9[rsp]
  00bca	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bd2	48 8b f8	 mov	 rdi, rax
  00bd5	48 8d b1 94 07
	00 00		 lea	 rsi, QWORD PTR [rcx+1940]
  00bdc	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00be1	f3 a4		 rep movsb

; 2268 :             memset( dev->fcb,     0,    sizeof( dev->fcb ));

  00be3	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00beb	48 05 94 07 00
	00		 add	 rax, 1940		; 00000794H
  00bf1	48 8b f8	 mov	 rdi, rax
  00bf4	33 c0		 xor	 eax, eax
  00bf6	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00bfb	f3 aa		 rep stosb

; 2269 : 
; 2270 :             /* First byte of FCB is optional indexing byte */
; 2271 :             dev->index = 0;

  00bfd	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c05	c7 80 8c 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1932], 0

; 2272 :             b = iobuf[i];

  00c0f	8b 44 24 4c	 mov	 eax, DWORD PTR i$4[rsp]
  00c13	48 8b 8c 24 18
	05 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00c1b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c1f	88 44 24 41	 mov	 BYTE PTR b$2[rsp], al

; 2273 : 
; 2274 :             /* Was indexing option specified? */
; 2275 :             if (b & 0x80)

  00c23	0f b6 44 24 41	 movzx	 eax, BYTE PTR b$2[rsp]
  00c28	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00c2d	85 c0		 test	 eax, eax
  00c2f	74 6f		 je	 SHORT $LN112@printer_ex

; 2276 :             {
; 2277 :                 dev->index = (b & 0x1F);    /* Save indexing value   */

  00c31	0f b6 44 24 41	 movzx	 eax, BYTE PTR b$2[rsp]
  00c36	83 e0 1f	 and	 eax, 31
  00c39	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c41	89 81 8c 07 00
	00		 mov	 DWORD PTR [rcx+1932], eax

; 2278 :                 i++;                        /* Consume optional byte */

  00c47	8b 44 24 4c	 mov	 eax, DWORD PTR i$4[rsp]
  00c4b	ff c0		 inc	 eax
  00c4d	89 44 24 4c	 mov	 DWORD PTR i$4[rsp], eax

; 2279 : 
; 2280 :                 if (b & 0x40)               /* Negative indexing?    */

  00c51	0f b6 44 24 41	 movzx	 eax, BYTE PTR b$2[rsp]
  00c56	83 e0 40	 and	 eax, 64			; 00000040H
  00c59	85 c0		 test	 eax, eax
  00c5b	74 1d		 je	 SHORT $LN113@printer_ex

; 2281 :                     dev->index *= -1;       /* Then make it negative */

  00c5d	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c65	6b 80 8c 07 00
	00 ff		 imul	 eax, DWORD PTR [rax+1932], -1
  00c6c	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c74	89 81 8c 07 00
	00		 mov	 DWORD PTR [rcx+1932], eax
$LN113@printer_ex:

; 2282 : 
; 2283 :                 dev->fcb[0] = dev->index;   /* Save FCB index value  */

  00c7a	b8 04 00 00 00	 mov	 eax, 4
  00c7f	48 6b c0 00	 imul	 rax, rax, 0
  00c83	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c8b	48 8b 94 24 e0
	04 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00c93	8b 92 8c 07 00
	00		 mov	 edx, DWORD PTR [rdx+1932]
  00c99	89 94 01 94 07
	00 00		 mov	 DWORD PTR [rcx+rax+1940], edx
$LN112@printer_ex:

; 2284 :             }
; 2285 : 
; 2286 :             /* Process FCB bytes for line=channel... */
; 2287 :             dev->lpi = 6;

  00ca0	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ca8	c7 80 88 07 00
	00 06 00 00 00	 mov	 DWORD PTR [rax+1928], 6

; 2288 :             dev->lpp = 0;

  00cb2	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cba	c7 80 90 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1936], 0

; 2289 : 
; 2290 :             for (k=MAX_CHAN_STOPS, f=1; f < fcbsize && i < count; f++)

  00cc4	c7 44 24 64 1e
	00 00 00	 mov	 DWORD PTR k$7[rsp], 30
  00ccc	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR f$5[rsp], 1
  00cd4	eb 0a		 jmp	 SHORT $LN14@printer_ex
$LN12@printer_ex:
  00cd6	8b 44 24 54	 mov	 eax, DWORD PTR f$5[rsp]
  00cda	ff c0		 inc	 eax
  00cdc	89 44 24 54	 mov	 DWORD PTR f$5[rsp], eax
$LN14@printer_ex:
  00ce0	8b 44 24 60	 mov	 eax, DWORD PTR fcbsize$[rsp]
  00ce4	39 44 24 54	 cmp	 DWORD PTR f$5[rsp], eax
  00ce8	0f 83 cd 00 00
	00		 jae	 $LN13@printer_ex
  00cee	8b 84 24 00 05
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00cf5	39 44 24 4c	 cmp	 DWORD PTR i$4[rsp], eax
  00cf9	0f 83 bc 00 00
	00		 jae	 $LN13@printer_ex

; 2291 :             {
; 2292 :                 /* Consume the first or next FCB byte */
; 2293 :                 b = iobuf[i++];

  00cff	8b 44 24 4c	 mov	 eax, DWORD PTR i$4[rsp]
  00d03	48 8b 8c 24 18
	05 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00d0b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d0f	88 44 24 41	 mov	 BYTE PTR b$2[rsp], al
  00d13	8b 44 24 4c	 mov	 eax, DWORD PTR i$4[rsp]
  00d17	ff c0		 inc	 eax
  00d19	89 44 24 4c	 mov	 DWORD PTR i$4[rsp], eax

; 2294 : 
; 2295 :                 /* Save channel number for this line */
; 2296 :                 dev->fcb[f] = (b & (0xFF-0x10));

  00d1d	0f b6 44 24 41	 movzx	 eax, BYTE PTR b$2[rsp]
  00d22	25 ef 00 00 00	 and	 eax, 239		; 000000efH
  00d27	8b 4c 24 54	 mov	 ecx, DWORD PTR f$5[rsp]
  00d2b	48 8b 94 24 e0
	04 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00d33	89 84 8a 94 07
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1940], eax

; 2297 : 
; 2298 :                 /* Specifed channel greater than 12? */
; 2299 :                 if (dev->fcb[f] > 12)

  00d3a	8b 44 24 54	 mov	 eax, DWORD PTR f$5[rsp]
  00d3e	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d46	83 bc 81 94 07
	00 00 0c	 cmp	 DWORD PTR [rcx+rax*4+1940], 12
  00d4e	7e 02		 jle	 SHORT $LN114@printer_ex

; 2300 :                     break;

  00d50	eb 69		 jmp	 SHORT $LN13@printer_ex
$LN114@printer_ex:

; 2301 : 
; 2302 :                 /* PROGRAMMING NOTE: a maximum of 30 channel codes
; 2303 :                    can be specified if the end of sheet is not
; 2304 :                    coded in the same byte as a channel code; a
; 2305 :                    maximum of 31 channel codes can be specified
; 2306 :                    if the end of sheet code is coded in the same
; 2307 :                    byte as a channel code. Thus the order of the
; 2308 :                    below two tests is important: we MUST check for
; 2309 :                    end of sheet FIRST (to skip decrementing our
; 2310 :                    channel code counter 'k') and then AFTERWARDS
; 2311 :                    decrement the counter if a channel was coded.
; 2312 :                 */
; 2313 :                 /* Flag bit set on first line of FCB means 8 LPI.
; 2314 :                    Otherwise flag bit set means last line of FCB.
; 2315 :                 */
; 2316 :                 if (b & 0x10)

  00d52	0f b6 44 24 41	 movzx	 eax, BYTE PTR b$2[rsp]
  00d57	83 e0 10	 and	 eax, 16
  00d5a	85 c0		 test	 eax, eax
  00d5c	74 2f		 je	 SHORT $LN115@printer_ex

; 2317 :                 {
; 2318 :                     if (f == 1)

  00d5e	83 7c 24 54 01	 cmp	 DWORD PTR f$5[rsp], 1
  00d63	75 14		 jne	 SHORT $LN116@printer_ex

; 2319 :                         dev->lpi = 8;

  00d65	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d6d	c7 80 88 07 00
	00 08 00 00 00	 mov	 DWORD PTR [rax+1928], 8
  00d77	eb 14		 jmp	 SHORT $LN117@printer_ex
$LN116@printer_ex:

; 2320 :                     else
; 2321 :                     {
; 2322 :                         dev->lpp = f;

  00d79	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d81	8b 4c 24 54	 mov	 ecx, DWORD PTR f$5[rsp]
  00d85	89 88 90 07 00
	00		 mov	 DWORD PTR [rax+1936], ecx

; 2323 :                         break;

  00d8b	eb 2e		 jmp	 SHORT $LN13@printer_ex
$LN117@printer_ex:
$LN115@printer_ex:

; 2324 :                     }
; 2325 :                 }
; 2326 : 
; 2327 :                 /* Count channel codes. Abort if max exceeded. */
; 2328 :                 if (dev->fcb[f])

  00d8d	8b 44 24 54	 mov	 eax, DWORD PTR f$5[rsp]
  00d91	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d99	83 bc 81 94 07
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+1940], 0
  00da1	74 13		 je	 SHORT $LN118@printer_ex

; 2329 :                     if (--k < 0)

  00da3	8b 44 24 64	 mov	 eax, DWORD PTR k$7[rsp]
  00da7	ff c8		 dec	 eax
  00da9	89 44 24 64	 mov	 DWORD PTR k$7[rsp], eax
  00dad	83 7c 24 64 00	 cmp	 DWORD PTR k$7[rsp], 0
  00db2	7d 02		 jge	 SHORT $LN119@printer_ex

; 2330 :                         break;

  00db4	eb 05		 jmp	 SHORT $LN13@printer_ex
$LN119@printer_ex:
$LN118@printer_ex:

; 2331 :             }

  00db6	e9 1b ff ff ff	 jmp	 $LN12@printer_ex
$LN13@printer_ex:

; 2332 : 
; 2333 :             /* Any errors detected? */
; 2334 :             if (k < 0 || !dev->lpp)

  00dbb	83 7c 24 64 00	 cmp	 DWORD PTR k$7[rsp], 0
  00dc0	7c 11		 jl	 SHORT $LN122@printer_ex
  00dc2	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00dca	83 b8 90 07 00
	00 00		 cmp	 DWORD PTR [rax+1936], 0
  00dd1	75 60		 jne	 SHORT $LN120@printer_ex
$LN122@printer_ex:

; 2335 :             {
; 2336 :                 /* Set Unit Check, SENSE = Load Check */
; 2337 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00dd3	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00ddb	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2338 :                 dev->sense[0] = SENSE_LDCK;

  00dde	b8 01 00 00 00	 mov	 eax, 1
  00de3	48 6b c0 00	 imul	 rax, rax, 0
  00de7	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00def	c6 84 01 64 03
	00 00 02	 mov	 BYTE PTR [rcx+rax+868], 2

; 2339 : 
; 2340 :                 /* Calculate residual */
; 2341 :                 *residual = count - i;

  00df7	8b 44 24 4c	 mov	 eax, DWORD PTR i$4[rsp]
  00dfb	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00e02	2b c8		 sub	 ecx, eax
  00e04	8b c1		 mov	 eax, ecx
  00e06	48 8b 8c 24 30
	05 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00e0e	89 01		 mov	 DWORD PTR [rcx], eax

; 2342 : 
; 2343 :                 /* Restore original FCB */
; 2344 :                 memcpy( dev->fcb, savedfcb, sizeof( dev->fcb ));

  00e10	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e18	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR savedfcb$9[rsp]
  00e20	48 8d b8 94 07
	00 00		 lea	 rdi, QWORD PTR [rax+1940]
  00e27	48 8b f1	 mov	 rsi, rcx
  00e2a	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00e2f	f3 a4		 rep movsb

; 2345 :             }

  00e31	eb 54		 jmp	 SHORT $LN121@printer_ex
$LN120@printer_ex:

; 2346 :             else // success
; 2347 :             {
; 2348 :                 /* Return normal status */
; 2349 :                 *unitstat = CSW_CE | CSW_DE;

  00e33	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00e3b	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2350 : 
; 2351 :                 /* Calculate residual byte count */
; 2352 :                 if (dev->devtype == 0x3211)

  00e3e	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e46	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00e4a	3d 11 32 00 00	 cmp	 eax, 12817		; 00003211H
  00e4f	75 10		 jne	 SHORT $LN123@printer_ex

; 2353 :                 {
; 2354 :                     /* Note: The 3211 printer does not set incorrect length
; 2355 :                        on 'load FCB'. This is *not* mentioned anywhere in
; 2356 :                        the 3211 manual (GA24-3543), but *is* mentioned in
; 2357 :                        Appendix C of the 3203-5 manual (GA33-1529, updated
; 2358 :                        by TNL GN33-1732) where it describes the differences
; 2359 :                        between the 3203-5 and other printers.
; 2360 :                     */
; 2361 :                     *residual = 0;    /* prevent incorrect length */

  00e51	48 8b 84 24 30
	05 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00e59	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 2362 :                 }

  00e5f	eb 19		 jmp	 SHORT $LN124@printer_ex
$LN123@printer_ex:

; 2363 :                 else
; 2364 :                     *residual = count - i;

  00e61	8b 44 24 4c	 mov	 eax, DWORD PTR i$4[rsp]
  00e65	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00e6c	2b c8		 sub	 ecx, eax
  00e6e	8b c1		 mov	 eax, ecx
  00e70	48 8b 8c 24 30
	05 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00e78	89 01		 mov	 DWORD PTR [rcx], eax
$LN124@printer_ex:

; 2365 : 
; 2366 :                 /* A new fcb has just been loaded */
; 2367 :                 on_new_fcb( dev );

  00e7a	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00e82	e8 00 00 00 00	 call	 on_new_fcb
$LN121@printer_ex:
$LN110@printer_ex:

; 2368 :             }
; 2369 :         }
; 2370 :         break;

  00e87	e9 fe 03 00 00	 jmp	 $LN5@printer_ex
$LN125@printer_ex:

; 2371 : 
; 2372 :     /*---------------------------------------------------------------*/
; 2373 :     /* RAISE COVER                                                   */
; 2374 :     /*---------------------------------------------------------------*/
; 2375 :     case 0x6B:
; 2376 : 
; 2377 :         if (dev->devtype == 0x1403)

  00e8c	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e94	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00e98	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  00e9d	75 26		 jne	 SHORT $LN126@printer_ex

; 2378 :         {
; 2379 :             /* Command Reject */
; 2380 :             dev->sense[0] = SENSE_CR;

  00e9f	b8 01 00 00 00	 mov	 eax, 1
  00ea4	48 6b c0 00	 imul	 rax, rax, 0
  00ea8	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00eb0	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 2381 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00eb8	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00ec0	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2382 :         }

  00ec3	eb 0b		 jmp	 SHORT $LN127@printer_ex
$LN126@printer_ex:

; 2383 :         else /* 3203, 3211 */
; 2384 :         {
; 2385 :             /* 3203 == accepted but no action occurs */
; 2386 :             /* 3211 == accepted and raises the cover */
; 2387 : 
; 2388 :             /* Return normal status */
; 2389 :             *unitstat = CSW_CE | CSW_DE;

  00ec5	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00ecd	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN127@printer_ex:

; 2390 :         }
; 2391 :         break;

  00ed0	e9 b5 03 00 00	 jmp	 $LN5@printer_ex
$LN128@printer_ex:

; 2392 : 
; 2393 :     /*---------------------------------------------------------------*/
; 2394 :     /* BLOCK DATA CHECK                                              */
; 2395 :     /*---------------------------------------------------------------*/
; 2396 :     case 0x73:
; 2397 : 
; 2398 :         /* Return normal status */
; 2399 :         *unitstat = CSW_CE | CSW_DE;

  00ed5	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00edd	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2400 :         break;

  00ee0	e9 a5 03 00 00	 jmp	 $LN5@printer_ex
$LN129@printer_ex:

; 2401 : 
; 2402 :     /*---------------------------------------------------------------*/
; 2403 :     /* ALLOW DATA CHECK                                              */
; 2404 :     /*---------------------------------------------------------------*/
; 2405 :     case 0x7B:
; 2406 : 
; 2407 :         /* Return normal status */
; 2408 :         *unitstat = CSW_CE | CSW_DE;

  00ee5	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00eed	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2409 :         break;

  00ef0	e9 95 03 00 00	 jmp	 $LN5@printer_ex
$LN130@printer_ex:

; 2410 : 
; 2411 :     /*---------------------------------------------------------------*/
; 2412 :     /* SKIP TO CHANNEL 0 IMMEDIATE                                   */
; 2413 :     /*---------------------------------------------------------------*/
; 2414 :     case 0x83:
; 2415 : 
; 2416 :         if (dev->devtype != 0x3211)

  00ef5	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00efd	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00f01	3d 11 32 00 00	 cmp	 eax, 12817		; 00003211H
  00f06	74 26		 je	 SHORT $LN131@printer_ex

; 2417 :         {
; 2418 :             /* Command Reject */
; 2419 :             dev->sense[0] = SENSE_CR;

  00f08	b8 01 00 00 00	 mov	 eax, 1
  00f0d	48 6b c0 00	 imul	 rax, rax, 0
  00f11	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f19	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 2420 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00f21	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00f29	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2421 :         }

  00f2c	eb 0b		 jmp	 SHORT $LN132@printer_ex
$LN131@printer_ex:

; 2422 :         else
; 2423 :         {
; 2424 :             /* Return normal status */
; 2425 :             *unitstat = CSW_CE | CSW_DE;

  00f2e	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00f36	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN132@printer_ex:

; 2426 :         }
; 2427 :         break;

  00f39	e9 4c 03 00 00	 jmp	 $LN5@printer_ex
$LN133@printer_ex:

; 2428 : 
; 2429 :     /*---------------------------------------------------------------*/
; 2430 :     /* SENSE ID                                                      */
; 2431 :     /*---------------------------------------------------------------*/
; 2432 :     case 0xE4:
; 2433 : 
; 2434 :         /* SENSE ID is only supported if LEGACYSENSEID is ON */
; 2435 :         if (sysblk.legacysenseid)

  00f3e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f45	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00f4b	c1 e8 14	 shr	 eax, 20
  00f4e	83 e0 01	 and	 eax, 1
  00f51	85 c0		 test	 eax, eax
  00f53	0f 84 b1 00 00
	00		 je	 $LN134@printer_ex

; 2436 :         {
; 2437 :             /* Calculate residual byte count */
; 2438 :             num = (count < dev->numdevid) ? count : dev->numdevid;

  00f59	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f61	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00f67	39 84 24 00 05
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00f6e	73 10		 jae	 SHORT $LN173@printer_ex
  00f70	8b 84 24 00 05
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00f77	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv477[rsp], eax
  00f7e	eb 15		 jmp	 SHORT $LN174@printer_ex
$LN173@printer_ex:
  00f80	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f88	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00f8e	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv477[rsp], eax
$LN174@printer_ex:
  00f95	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv477[rsp]
  00f9c	89 44 24 44	 mov	 DWORD PTR num$[rsp], eax

; 2439 :             *residual = count - num;

  00fa0	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  00fa4	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00fab	2b c8		 sub	 ecx, eax
  00fad	8b c1		 mov	 eax, ecx
  00faf	48 8b 8c 24 30
	05 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00fb7	89 01		 mov	 DWORD PTR [rcx], eax

; 2440 :             if (count < dev->numdevid) *more = 1;

  00fb9	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fc1	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00fc7	39 84 24 00 05
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00fce	73 0b		 jae	 SHORT $LN136@printer_ex
  00fd0	48 8b 84 24 20
	05 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00fd8	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN136@printer_ex:

; 2441 : 
; 2442 :             /* Copy device identifier bytes to channel I/O buffer */
; 2443 :             memcpy( iobuf, dev->devid, num );

  00fdb	8b 44 24 44	 mov	 eax, DWORD PTR num$[rsp]
  00fdf	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fe7	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  00fee	48 8b bc 24 18
	05 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00ff6	48 8b f1	 mov	 rsi, rcx
  00ff9	8b c8		 mov	 ecx, eax
  00ffb	f3 a4		 rep movsb

; 2444 : 
; 2445 :             /* Return normal status */
; 2446 :             *unitstat = CSW_CE | CSW_DE;

  00ffd	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01005	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2447 :         }

  01008	eb 24		 jmp	 SHORT $LN135@printer_ex
$LN134@printer_ex:

; 2448 :         else
; 2449 :         {
; 2450 :             /* Command Reject */
; 2451 :             dev->sense[0] = SENSE_CR;

  0100a	b8 01 00 00 00	 mov	 eax, 1
  0100f	48 6b c0 00	 imul	 rax, rax, 0
  01013	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0101b	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 2452 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  01023	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0102b	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN135@printer_ex:

; 2453 :         }
; 2454 :         break;

  0102e	e9 57 02 00 00	 jmp	 $LN5@printer_ex
$LN137@printer_ex:

; 2455 : 
; 2456 :     /*---------------------------------------------------------------*/
; 2457 :     /* UCS GATE LOAD                                                 */
; 2458 :     /*---------------------------------------------------------------*/
; 2459 :     case 0xEB:
; 2460 : 
; 2461 :         /* Command reject if not 1403 */
; 2462 :         if (dev->devtype != 0x1403)

  01033	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0103b	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0103f	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  01044	74 26		 je	 SHORT $LN138@printer_ex

; 2463 :         {
; 2464 :             /* Command Reject */
; 2465 :             dev->sense[0] = SENSE_CR;

  01046	b8 01 00 00 00	 mov	 eax, 1
  0104b	48 6b c0 00	 imul	 rax, rax, 0
  0104f	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01057	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 2466 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0105f	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01067	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2467 :         }

  0106a	eb 2a		 jmp	 SHORT $LN139@printer_ex
$LN138@printer_ex:

; 2468 :         else
; 2469 :         {
; 2470 :             /* Set diagnostic gate flag */
; 2471 :             dev->diaggate = 1;

  0106c	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01074	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  0107a	83 c8 10	 or	 eax, 16
  0107d	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01085	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 2472 : 
; 2473 :             /* Return normal status */
; 2474 :             *unitstat = CSW_CE | CSW_DE;

  0108b	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01093	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN139@printer_ex:

; 2475 :         }
; 2476 :         break;

  01096	e9 ef 01 00 00	 jmp	 $LN5@printer_ex
$LN140@printer_ex:

; 2477 : 
; 2478 :     /*---------------------------------------------------------------*/
; 2479 :     /* LOAD UCS BUFFER AND FOLD                                      */
; 2480 :     /*---------------------------------------------------------------*/
; 2481 :     case 0xF3:
; 2482 : 
; 2483 :         /* Reject if not 1403 or not preceded by UCS GATE LOAD */
; 2484 :         if (dev->devtype != 0x1403 || !dev->diaggate)

  0109b	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  010a3	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  010a7	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  010ac	75 18		 jne	 SHORT $LN143@printer_ex
  010ae	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  010b6	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  010bc	c1 e8 04	 shr	 eax, 4
  010bf	83 e0 01	 and	 eax, 1
  010c2	85 c0		 test	 eax, eax
  010c4	75 29		 jne	 SHORT $LN141@printer_ex
$LN143@printer_ex:

; 2485 :         {
; 2486 :             /* Command Reject */
; 2487 :             dev->sense[0] = SENSE_CR;

  010c6	b8 01 00 00 00	 mov	 eax, 1
  010cb	48 6b c0 00	 imul	 rax, rax, 0
  010cf	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010d7	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 2488 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  010df	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  010e7	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2489 :         }

  010ea	e9 8e 00 00 00	 jmp	 $LN142@printer_ex
$LN141@printer_ex:

; 2490 :         else
; 2491 :         {
; 2492 :             if (LoadUCB( dev, count, iobuf, more, unitstat, residual ) == 0)

  010ef	48 8b 84 24 30
	05 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  010f7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  010fc	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01104	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01109	4c 8b 8c 24 20
	05 00 00	 mov	 r9, QWORD PTR more$[rsp]
  01111	4c 8b 84 24 18
	05 00 00	 mov	 r8, QWORD PTR iobuf$[rsp]
  01119	8b 94 24 00 05
	00 00		 mov	 edx, DWORD PTR count$[rsp]
  01120	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01128	e8 00 00 00 00	 call	 LoadUCB
  0112d	0f b6 c0	 movzx	 eax, al
  01130	85 c0		 test	 eax, eax
  01132	75 49		 jne	 SHORT $LN144@printer_ex

; 2493 :             {
; 2494 :                 /* Set fold indicator */
; 2495 :                 dev->fold = 1;

  01134	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0113c	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  01142	83 c8 20	 or	 eax, 32			; 00000020H
  01145	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0114d	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 2496 :                 dev->ffpend = 1;

  01153	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0115b	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  01161	83 c8 40	 or	 eax, 64			; 00000040H
  01164	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0116c	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 2497 : 
; 2498 :                 /* Return normal status */
; 2499 :                 *unitstat = CSW_CE | CSW_DE;

  01172	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0117a	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN144@printer_ex:
$LN142@printer_ex:

; 2500 :             }
; 2501 :         }
; 2502 :         break;

  0117d	e9 08 01 00 00	 jmp	 $LN5@printer_ex
$LN145@printer_ex:

; 2503 : 
; 2504 :     /*---------------------------------------------------------------*/
; 2505 :     /* LOAD UCS BUFFER  (NO FOLD implied)                            */
; 2506 :     /*---------------------------------------------------------------*/
; 2507 :     case 0xFB:
; 2508 : 
; 2509 :         /* For 1403, command reject if not chained to UCS GATE LOAD */
; 2510 :         if (dev->devtype == 0x1403 && !dev->diaggate)

  01182	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0118a	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0118e	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  01193	75 41		 jne	 SHORT $LN146@printer_ex
  01195	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0119d	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  011a3	c1 e8 04	 shr	 eax, 4
  011a6	83 e0 01	 and	 eax, 1
  011a9	85 c0		 test	 eax, eax
  011ab	75 29		 jne	 SHORT $LN146@printer_ex

; 2511 :         {
; 2512 :             /* Command Reject */
; 2513 :             dev->sense[0] = SENSE_CR;

  011ad	b8 01 00 00 00	 mov	 eax, 1
  011b2	48 6b c0 00	 imul	 rax, rax, 0
  011b6	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011be	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 2514 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  011c6	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  011ce	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2515 :         }

  011d1	e9 8e 00 00 00	 jmp	 $LN147@printer_ex
$LN146@printer_ex:

; 2516 :         else
; 2517 :         {
; 2518 :             if (LoadUCB( dev, count, iobuf, more, unitstat, residual ) == 0)

  011d6	48 8b 84 24 30
	05 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  011de	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  011e3	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  011eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011f0	4c 8b 8c 24 20
	05 00 00	 mov	 r9, QWORD PTR more$[rsp]
  011f8	4c 8b 84 24 18
	05 00 00	 mov	 r8, QWORD PTR iobuf$[rsp]
  01200	8b 94 24 00 05
	00 00		 mov	 edx, DWORD PTR count$[rsp]
  01207	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0120f	e8 00 00 00 00	 call	 LoadUCB
  01214	0f b6 c0	 movzx	 eax, al
  01217	85 c0		 test	 eax, eax
  01219	75 49		 jne	 SHORT $LN148@printer_ex

; 2519 :             {
; 2520 :                 /* Reset fold indicator */
; 2521 :                 dev->fold = 0;

  0121b	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01223	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  01229	83 e0 df	 and	 eax, -33		; ffffffdfH
  0122c	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01234	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 2522 :                 dev->ffpend = 1;

  0123a	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01242	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  01248	83 c8 40	 or	 eax, 64			; 00000040H
  0124b	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01253	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 2523 : 
; 2524 :                 /* Return normal status */
; 2525 :                 *unitstat = CSW_CE | CSW_DE;

  01259	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01261	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN148@printer_ex:
$LN147@printer_ex:

; 2526 :             }
; 2527 :         }
; 2528 :         break;

  01264	eb 24		 jmp	 SHORT $LN5@printer_ex
$LN149@printer_ex:

; 2529 : 
; 2530 :     /*---------------------------------------------------------------*/
; 2531 :     /* INVALID OPERATION                                             */
; 2532 :     /*---------------------------------------------------------------*/
; 2533 :     default:
; 2534 : 
; 2535 :         /* Set command reject sense byte, and unit check status */
; 2536 :         dev->sense[0] = SENSE_CR;

  01266	b8 01 00 00 00	 mov	 eax, 1
  0126b	48 6b c0 00	 imul	 rax, rax, 0
  0126f	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01277	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 2537 :         *unitstat = CSW_UC;

  0127f	48 8b 84 24 28
	05 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01287	c6 00 02	 mov	 BYTE PTR [rax], 2
$LN5@printer_ex:
$LN1@printer_ex:

; 2538 : 
; 2539 :     } /* end switch(code) */
; 2540 : 
; 2541 : } /* end function printer_execute_ccw */

  0128a	48 8b 8c 24 b0
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01292	48 33 cc	 xor	 rcx, rsp
  01295	e8 00 00 00 00	 call	 __security_check_cookie
  0129a	48 81 c4 c8 04
	00 00		 add	 rsp, 1224		; 000004c8H
  012a1	5f		 pop	 rdi
  012a2	5e		 pop	 rsi
  012a3	c3		 ret	 0
$LN176@printer_ex:
  012a4	00 00 00 00	 DD	 $LN26@printer_ex
  012a8	00 00 00 00	 DD	 $LN21@printer_ex
  012ac	00 00 00 00	 DD	 $LN23@printer_ex
  012b0	00 00 00 00	 DD	 $LN24@printer_ex
  012b4	00 00 00 00	 DD	 $LN76@printer_ex
  012b8	00 00 00 00	 DD	 $LN79@printer_ex
  012bc	00 00 00 00	 DD	 $LN84@printer_ex
  012c0	00 00 00 00	 DD	 $LN27@printer_ex
  012c4	00 00 00 00	 DD	 $LN86@printer_ex
  012c8	00 00 00 00	 DD	 $LN45@printer_ex
  012cc	00 00 00 00	 DD	 $LN60@printer_ex
  012d0	00 00 00 00	 DD	 $LN28@printer_ex
  012d4	00 00 00 00	 DD	 $LN91@printer_ex
  012d8	00 00 00 00	 DD	 $LN46@printer_ex
  012dc	00 00 00 00	 DD	 $LN61@printer_ex
  012e0	00 00 00 00	 DD	 $LN29@printer_ex
  012e4	00 00 00 00	 DD	 $LN47@printer_ex
  012e8	00 00 00 00	 DD	 $LN62@printer_ex
  012ec	00 00 00 00	 DD	 $LN102@printer_ex
  012f0	00 00 00 00	 DD	 $LN105@printer_ex
  012f4	00 00 00 00	 DD	 $LN108@printer_ex
  012f8	00 00 00 00	 DD	 $LN125@printer_ex
  012fc	00 00 00 00	 DD	 $LN128@printer_ex
  01300	00 00 00 00	 DD	 $LN129@printer_ex
  01304	00 00 00 00	 DD	 $LN130@printer_ex
  01308	00 00 00 00	 DD	 $LN30@printer_ex
  0130c	00 00 00 00	 DD	 $LN48@printer_ex
  01310	00 00 00 00	 DD	 $LN63@printer_ex
  01314	00 00 00 00	 DD	 $LN31@printer_ex
  01318	00 00 00 00	 DD	 $LN49@printer_ex
  0131c	00 00 00 00	 DD	 $LN64@printer_ex
  01320	00 00 00 00	 DD	 $LN32@printer_ex
  01324	00 00 00 00	 DD	 $LN50@printer_ex
  01328	00 00 00 00	 DD	 $LN65@printer_ex
  0132c	00 00 00 00	 DD	 $LN33@printer_ex
  01330	00 00 00 00	 DD	 $LN51@printer_ex
  01334	00 00 00 00	 DD	 $LN66@printer_ex
  01338	00 00 00 00	 DD	 $LN34@printer_ex
  0133c	00 00 00 00	 DD	 $LN52@printer_ex
  01340	00 00 00 00	 DD	 $LN67@printer_ex
  01344	00 00 00 00	 DD	 $LN35@printer_ex
  01348	00 00 00 00	 DD	 $LN53@printer_ex
  0134c	00 00 00 00	 DD	 $LN68@printer_ex
  01350	00 00 00 00	 DD	 $LN36@printer_ex
  01354	00 00 00 00	 DD	 $LN54@printer_ex
  01358	00 00 00 00	 DD	 $LN69@printer_ex
  0135c	00 00 00 00	 DD	 $LN37@printer_ex
  01360	00 00 00 00	 DD	 $LN55@printer_ex
  01364	00 00 00 00	 DD	 $LN70@printer_ex
  01368	00 00 00 00	 DD	 $LN38@printer_ex
  0136c	00 00 00 00	 DD	 $LN56@printer_ex
  01370	00 00 00 00	 DD	 $LN71@printer_ex
  01374	00 00 00 00	 DD	 $LN39@printer_ex
  01378	00 00 00 00	 DD	 $LN57@printer_ex
  0137c	00 00 00 00	 DD	 $LN72@printer_ex
  01380	00 00 00 00	 DD	 $LN40@printer_ex
  01384	00 00 00 00	 DD	 $LN58@printer_ex
  01388	00 00 00 00	 DD	 $LN73@printer_ex
  0138c	00 00 00 00	 DD	 $LN41@printer_ex
  01390	00 00 00 00	 DD	 $LN59@printer_ex
  01394	00 00 00 00	 DD	 $LN133@printer_ex
  01398	00 00 00 00	 DD	 $LN74@printer_ex
  0139c	00 00 00 00	 DD	 $LN137@printer_ex
  013a0	00 00 00 00	 DD	 $LN140@printer_ex
  013a4	00 00 00 00	 DD	 $LN145@printer_ex
  013a8	00 00 00 00	 DD	 $LN149@printer_ex
$LN175@printer_ex:
  013ac	00		 DB	 0
  013ad	01		 DB	 1
  013ae	02		 DB	 2
  013af	03		 DB	 3
  013b0	04		 DB	 4
  013b1	05		 DB	 5
  013b2	06		 DB	 6
  013b3	41		 DB	 65			; 00000041H
  013b4	07		 DB	 7
  013b5	08		 DB	 8
  013b6	09		 DB	 9
  013b7	41		 DB	 65			; 00000041H
  013b8	0a		 DB	 10
  013b9	41		 DB	 65			; 00000041H
  013ba	41		 DB	 65			; 00000041H
  013bb	41		 DB	 65			; 00000041H
  013bc	0b		 DB	 11
  013bd	0c		 DB	 12
  013be	0d		 DB	 13
  013bf	41		 DB	 65			; 00000041H
  013c0	0e		 DB	 14
  013c1	41		 DB	 65			; 00000041H
  013c2	41		 DB	 65			; 00000041H
  013c3	41		 DB	 65			; 00000041H
  013c4	0f		 DB	 15
  013c5	41		 DB	 65			; 00000041H
  013c6	10		 DB	 16
  013c7	41		 DB	 65			; 00000041H
  013c8	11		 DB	 17
  013c9	41		 DB	 65			; 00000041H
  013ca	41		 DB	 65			; 00000041H
  013cb	41		 DB	 65			; 00000041H
  013cc	41		 DB	 65			; 00000041H
  013cd	41		 DB	 65			; 00000041H
  013ce	12		 DB	 18
  013cf	41		 DB	 65			; 00000041H
  013d0	41		 DB	 65			; 00000041H
  013d1	41		 DB	 65			; 00000041H
  013d2	41		 DB	 65			; 00000041H
  013d3	41		 DB	 65			; 00000041H
  013d4	41		 DB	 65			; 00000041H
  013d5	41		 DB	 65			; 00000041H
  013d6	41		 DB	 65			; 00000041H
  013d7	41		 DB	 65			; 00000041H
  013d8	41		 DB	 65			; 00000041H
  013d9	41		 DB	 65			; 00000041H
  013da	41		 DB	 65			; 00000041H
  013db	41		 DB	 65			; 00000041H
  013dc	41		 DB	 65			; 00000041H
  013dd	41		 DB	 65			; 00000041H
  013de	41		 DB	 65			; 00000041H
  013df	41		 DB	 65			; 00000041H
  013e0	41		 DB	 65			; 00000041H
  013e1	41		 DB	 65			; 00000041H
  013e2	41		 DB	 65			; 00000041H
  013e3	41		 DB	 65			; 00000041H
  013e4	41		 DB	 65			; 00000041H
  013e5	41		 DB	 65			; 00000041H
  013e6	41		 DB	 65			; 00000041H
  013e7	41		 DB	 65			; 00000041H
  013e8	41		 DB	 65			; 00000041H
  013e9	41		 DB	 65			; 00000041H
  013ea	41		 DB	 65			; 00000041H
  013eb	41		 DB	 65			; 00000041H
  013ec	41		 DB	 65			; 00000041H
  013ed	41		 DB	 65			; 00000041H
  013ee	13		 DB	 19
  013ef	41		 DB	 65			; 00000041H
  013f0	41		 DB	 65			; 00000041H
  013f1	41		 DB	 65			; 00000041H
  013f2	41		 DB	 65			; 00000041H
  013f3	41		 DB	 65			; 00000041H
  013f4	41		 DB	 65			; 00000041H
  013f5	41		 DB	 65			; 00000041H
  013f6	41		 DB	 65			; 00000041H
  013f7	41		 DB	 65			; 00000041H
  013f8	41		 DB	 65			; 00000041H
  013f9	41		 DB	 65			; 00000041H
  013fa	41		 DB	 65			; 00000041H
  013fb	41		 DB	 65			; 00000041H
  013fc	41		 DB	 65			; 00000041H
  013fd	41		 DB	 65			; 00000041H
  013fe	41		 DB	 65			; 00000041H
  013ff	41		 DB	 65			; 00000041H
  01400	41		 DB	 65			; 00000041H
  01401	41		 DB	 65			; 00000041H
  01402	41		 DB	 65			; 00000041H
  01403	41		 DB	 65			; 00000041H
  01404	41		 DB	 65			; 00000041H
  01405	41		 DB	 65			; 00000041H
  01406	41		 DB	 65			; 00000041H
  01407	41		 DB	 65			; 00000041H
  01408	41		 DB	 65			; 00000041H
  01409	41		 DB	 65			; 00000041H
  0140a	41		 DB	 65			; 00000041H
  0140b	41		 DB	 65			; 00000041H
  0140c	41		 DB	 65			; 00000041H
  0140d	41		 DB	 65			; 00000041H
  0140e	14		 DB	 20
  0140f	41		 DB	 65			; 00000041H
  01410	41		 DB	 65			; 00000041H
  01411	41		 DB	 65			; 00000041H
  01412	41		 DB	 65			; 00000041H
  01413	41		 DB	 65			; 00000041H
  01414	41		 DB	 65			; 00000041H
  01415	41		 DB	 65			; 00000041H
  01416	15		 DB	 21
  01417	41		 DB	 65			; 00000041H
  01418	41		 DB	 65			; 00000041H
  01419	41		 DB	 65			; 00000041H
  0141a	41		 DB	 65			; 00000041H
  0141b	41		 DB	 65			; 00000041H
  0141c	41		 DB	 65			; 00000041H
  0141d	41		 DB	 65			; 00000041H
  0141e	16		 DB	 22
  0141f	41		 DB	 65			; 00000041H
  01420	41		 DB	 65			; 00000041H
  01421	41		 DB	 65			; 00000041H
  01422	41		 DB	 65			; 00000041H
  01423	41		 DB	 65			; 00000041H
  01424	41		 DB	 65			; 00000041H
  01425	41		 DB	 65			; 00000041H
  01426	17		 DB	 23
  01427	41		 DB	 65			; 00000041H
  01428	41		 DB	 65			; 00000041H
  01429	41		 DB	 65			; 00000041H
  0142a	41		 DB	 65			; 00000041H
  0142b	41		 DB	 65			; 00000041H
  0142c	41		 DB	 65			; 00000041H
  0142d	41		 DB	 65			; 00000041H
  0142e	18		 DB	 24
  0142f	41		 DB	 65			; 00000041H
  01430	41		 DB	 65			; 00000041H
  01431	41		 DB	 65			; 00000041H
  01432	41		 DB	 65			; 00000041H
  01433	41		 DB	 65			; 00000041H
  01434	19		 DB	 25
  01435	41		 DB	 65			; 00000041H
  01436	1a		 DB	 26
  01437	41		 DB	 65			; 00000041H
  01438	1b		 DB	 27
  01439	41		 DB	 65			; 00000041H
  0143a	41		 DB	 65			; 00000041H
  0143b	41		 DB	 65			; 00000041H
  0143c	1c		 DB	 28
  0143d	41		 DB	 65			; 00000041H
  0143e	1d		 DB	 29
  0143f	41		 DB	 65			; 00000041H
  01440	1e		 DB	 30
  01441	41		 DB	 65			; 00000041H
  01442	41		 DB	 65			; 00000041H
  01443	41		 DB	 65			; 00000041H
  01444	1f		 DB	 31
  01445	41		 DB	 65			; 00000041H
  01446	20		 DB	 32			; 00000020H
  01447	41		 DB	 65			; 00000041H
  01448	21		 DB	 33			; 00000021H
  01449	41		 DB	 65			; 00000041H
  0144a	41		 DB	 65			; 00000041H
  0144b	41		 DB	 65			; 00000041H
  0144c	22		 DB	 34			; 00000022H
  0144d	41		 DB	 65			; 00000041H
  0144e	23		 DB	 35			; 00000023H
  0144f	41		 DB	 65			; 00000041H
  01450	24		 DB	 36			; 00000024H
  01451	41		 DB	 65			; 00000041H
  01452	41		 DB	 65			; 00000041H
  01453	41		 DB	 65			; 00000041H
  01454	25		 DB	 37			; 00000025H
  01455	41		 DB	 65			; 00000041H
  01456	26		 DB	 38			; 00000026H
  01457	41		 DB	 65			; 00000041H
  01458	27		 DB	 39			; 00000027H
  01459	41		 DB	 65			; 00000041H
  0145a	41		 DB	 65			; 00000041H
  0145b	41		 DB	 65			; 00000041H
  0145c	28		 DB	 40			; 00000028H
  0145d	41		 DB	 65			; 00000041H
  0145e	29		 DB	 41			; 00000029H
  0145f	41		 DB	 65			; 00000041H
  01460	2a		 DB	 42			; 0000002aH
  01461	41		 DB	 65			; 00000041H
  01462	41		 DB	 65			; 00000041H
  01463	41		 DB	 65			; 00000041H
  01464	2b		 DB	 43			; 0000002bH
  01465	41		 DB	 65			; 00000041H
  01466	2c		 DB	 44			; 0000002cH
  01467	41		 DB	 65			; 00000041H
  01468	2d		 DB	 45			; 0000002dH
  01469	41		 DB	 65			; 00000041H
  0146a	41		 DB	 65			; 00000041H
  0146b	41		 DB	 65			; 00000041H
  0146c	2e		 DB	 46			; 0000002eH
  0146d	41		 DB	 65			; 00000041H
  0146e	2f		 DB	 47			; 0000002fH
  0146f	41		 DB	 65			; 00000041H
  01470	30		 DB	 48			; 00000030H
  01471	41		 DB	 65			; 00000041H
  01472	41		 DB	 65			; 00000041H
  01473	41		 DB	 65			; 00000041H
  01474	31		 DB	 49			; 00000031H
  01475	41		 DB	 65			; 00000041H
  01476	32		 DB	 50			; 00000032H
  01477	41		 DB	 65			; 00000041H
  01478	33		 DB	 51			; 00000033H
  01479	41		 DB	 65			; 00000041H
  0147a	41		 DB	 65			; 00000041H
  0147b	41		 DB	 65			; 00000041H
  0147c	34		 DB	 52			; 00000034H
  0147d	41		 DB	 65			; 00000041H
  0147e	35		 DB	 53			; 00000035H
  0147f	41		 DB	 65			; 00000041H
  01480	36		 DB	 54			; 00000036H
  01481	41		 DB	 65			; 00000041H
  01482	41		 DB	 65			; 00000041H
  01483	41		 DB	 65			; 00000041H
  01484	37		 DB	 55			; 00000037H
  01485	41		 DB	 65			; 00000041H
  01486	38		 DB	 56			; 00000038H
  01487	41		 DB	 65			; 00000041H
  01488	39		 DB	 57			; 00000039H
  01489	41		 DB	 65			; 00000041H
  0148a	41		 DB	 65			; 00000041H
  0148b	41		 DB	 65			; 00000041H
  0148c	3a		 DB	 58			; 0000003aH
  0148d	41		 DB	 65			; 00000041H
  0148e	3b		 DB	 59			; 0000003bH
  0148f	3c		 DB	 60			; 0000003cH
  01490	3d		 DB	 61			; 0000003dH
  01491	41		 DB	 65			; 00000041H
  01492	41		 DB	 65			; 00000041H
  01493	41		 DB	 65			; 00000041H
  01494	41		 DB	 65			; 00000041H
  01495	41		 DB	 65			; 00000041H
  01496	3e		 DB	 62			; 0000003eH
  01497	41		 DB	 65			; 00000041H
  01498	41		 DB	 65			; 00000041H
  01499	41		 DB	 65			; 00000041H
  0149a	41		 DB	 65			; 00000041H
  0149b	41		 DB	 65			; 00000041H
  0149c	41		 DB	 65			; 00000041H
  0149d	41		 DB	 65			; 00000041H
  0149e	3f		 DB	 63			; 0000003fH
  0149f	41		 DB	 65			; 00000041H
  014a0	41		 DB	 65			; 00000041H
  014a1	41		 DB	 65			; 00000041H
  014a2	41		 DB	 65			; 00000041H
  014a3	41		 DB	 65			; 00000041H
  014a4	41		 DB	 65			; 00000041H
  014a5	41		 DB	 65			; 00000041H
  014a6	40		 DB	 64			; 00000040H
printer_execute_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
fd$ = 96
tv80 = 100
tv86 = 104
tv145 = 108
tv151 = 112
tv165 = 120
tv164 = 128
tv162 = 136
dev$ = 160
printer_close_device PROC

; 1749 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1750 : int fd = dev->fd;

  0000c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00014	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [rax+428]
  0001a	89 44 24 60	 mov	 DWORD PTR fd$[rsp], eax

; 1751 : 
; 1752 :     if (fd == -1)

  0001e	83 7c 24 60 ff	 cmp	 DWORD PTR fd$[rsp], -1
  00023	75 07		 jne	 SHORT $LN2@printer_cl

; 1753 :         return 0;

  00025	33 c0		 xor	 eax, eax
  00027	e9 65 02 00 00	 jmp	 $LN1@printer_cl
$LN2@printer_cl:

; 1754 : 
; 1755 :     dev->fd      = -1;

  0002c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00034	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 1756 :     dev->stopdev =  FALSE;

  0003e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00046	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  0004c	83 e0 fb	 and	 eax, -5			; fffffffbH
  0004f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00057	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 1757 : 
; 1758 :     /* Close the device file */
; 1759 :     if ( dev->ispiped )

  0005d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00065	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  0006b	d1 e8		 shr	 eax, 1
  0006d	83 e0 01	 and	 eax, 1
  00070	85 c0		 test	 eax, eax
  00072	0f 84 d6 00 00
	00		 je	 $LN3@printer_cl

; 1760 :     {
; 1761 : #if !defined( _MSVC_ )
; 1762 :         close_pipe (fd);
; 1763 : #else /* defined( _MSVC_ ) */
; 1764 :         close (fd);

  00078	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 1765 : #endif /* defined( _MSVC_ ) */
; 1766 :         // "%1d:%04X Printer: pipe receiver with pid %d terminating"
; 1767 :         WRMSG (HHC01107, "I", LCSS_DEVNUM, dev->ptpcpid);

  00082	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0008b	74 12		 je	 SHORT $LN8@printer_cl
  0008d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00095	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00099	89 44 24 64	 mov	 DWORD PTR tv80[rsp], eax
  0009d	eb 08		 jmp	 SHORT $LN9@printer_cl
$LN8@printer_cl:
  0009f	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN9@printer_cl:
  000a7	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000b0	74 14		 je	 SHORT $LN10@printer_cl
  000b2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ba	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000be	d1 f8		 sar	 eax, 1
  000c0	89 44 24 68	 mov	 DWORD PTR tv86[rsp], eax
  000c4	eb 08		 jmp	 SHORT $LN11@printer_cl
$LN10@printer_cl:
  000c6	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN11@printer_cl:
  000ce	b9 01 00 00 00	 mov	 ecx, 1
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000e1	8b 89 80 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1920]
  000e7	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000eb	8b 4c 24 64	 mov	 ecx, DWORD PTR tv80[rsp]
  000ef	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f3	8b 4c 24 68	 mov	 ecx, DWORD PTR tv86[rsp]
  000f7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168909
  00102	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168910
  0010e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00113	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00118	41 b9 03 00 00
	00		 mov	 r9d, 3
  0011e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168911
  00125	ba e7 06 00 00	 mov	 edx, 1767		; 000006e7H
  0012a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168912
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1768 :         dev->ptpcpid = 0;

  00137	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0013f	c7 80 80 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1920], 0

; 1769 :     }

  00149	e9 41 01 00 00	 jmp	 $LN4@printer_cl
$LN3@printer_cl:

; 1770 :     else
; 1771 :     {
; 1772 :         if (dev->bs)

  0014e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00156	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  0015e	0f 84 21 01 00
	00		 je	 $LN5@printer_cl

; 1773 :         {
; 1774 :             close_socket (fd);

  00164	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 1775 :             // "%1d:%04X Printer: client %s, IP %s disconnected from device %s"
; 1776 :             WRMSG (HHC01100, "I", LCSS_DEVNUM, dev->bs->clientname, dev->bs->clientip, dev->bs->spec);

  0016e	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00177	74 12		 je	 SHORT $LN12@printer_cl
  00179	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00181	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00185	89 44 24 6c	 mov	 DWORD PTR tv145[rsp], eax
  00189	eb 08		 jmp	 SHORT $LN13@printer_cl
$LN12@printer_cl:
  0018b	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN13@printer_cl:
  00193	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0019c	74 14		 je	 SHORT $LN14@printer_cl
  0019e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001aa	d1 f8		 sar	 eax, 1
  001ac	89 44 24 70	 mov	 DWORD PTR tv151[rsp], eax
  001b0	eb 08		 jmp	 SHORT $LN15@printer_cl
$LN14@printer_cl:
  001b2	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN15@printer_cl:
  001ba	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c2	48 8b 80 b8 01
	00 00		 mov	 rax, QWORD PTR [rax+440]
  001c9	48 89 44 24 78	 mov	 QWORD PTR tv165[rsp], rax
  001ce	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001d6	48 8b 89 b8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+440]
  001dd	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv164[rsp], rcx
  001e5	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001ed	48 8b 92 b8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+440]
  001f4	48 89 94 24 88
	00 00 00	 mov	 QWORD PTR tv162[rsp], rdx
  001fc	b9 01 00 00 00	 mov	 ecx, 1
  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00207	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv165[rsp]
  0020c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00210	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00215	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv164[rsp]
  0021d	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00221	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00226	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv162[rsp]
  0022e	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00232	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00237	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv145[rsp]
  0023b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0023f	8b 4c 24 70	 mov	 ecx, DWORD PTR tv151[rsp]
  00243	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00247	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168915
  0024e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00253	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168916
  0025a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0025f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00264	41 b9 03 00 00
	00		 mov	 r9d, 3
  0026a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168917
  00271	ba f0 06 00 00	 mov	 edx, 1776		; 000006f0H
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168918
  0027d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1777 :         }

  00283	eb 0a		 jmp	 SHORT $LN6@printer_cl
$LN5@printer_cl:

; 1778 :         else
; 1779 :         {
; 1780 :             /* Regular printer */
; 1781 :             close (fd);

  00285	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  00289	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
$LN6@printer_cl:
$LN4@printer_cl:

; 1782 :         }
; 1783 :     }
; 1784 : 
; 1785 :     return 0;

  0028f	33 c0		 xor	 eax, eax
$LN1@printer_cl:

; 1786 : 
; 1787 : } /* end function printer_close_device */

  00291	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00298	c3		 ret	 0
printer_close_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
$T1 = 80
tv129 = 88
tv134 = 96
tv139 = 104
tv143 = 112
filename$ = 128
__$ArrayPad$ = 400
dev$ = 432
devclass$ = 440
buflen$ = 448
buffer$ = 456
printer_query_device PROC

; 1565 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1566 :     char  filename[ PATH_MAX + 1 ];     /* full path or just name    */
; 1567 : 
; 1568 :     BEGIN_DEVICE_CLASS_QUERY( "PRT", dev, devclass, buflen, buffer );

  0002d	48 83 bc 24 b8
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@printer_qu
  00038	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR devclass$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168845
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@printer_qu:
  0004a	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@printer_qu
  00055	48 83 bc 24 b8
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@printer_qu
  00060	83 bc 24 c0 01
	00 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@printer_qu
  0006a	48 83 bc 24 c8
	01 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@printer_qu
$LN4@printer_qu:
  00075	e9 d1 01 00 00	 jmp	 $LN1@printer_qu
$LN3@printer_qu:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 75		 je	 SHORT $LN5@printer_qu
  00091	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168851
  000c6	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  000ce	e8 00 00 00 00	 call	 strcmp
  000d3	85 c0		 test	 eax, eax
  000d5	75 2d		 jne	 SHORT $LN7@printer_qu
  000d7	b8 01 00 00 00	 mov	 eax, 1
  000dc	48 6b c0 00	 imul	 rax, rax, 0
  000e0	48 89 44 24 50	 mov	 QWORD PTR $T1[rsp], rax
  000e5	48 81 7c 24 50
	05 01 00 00	 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  000ee	73 02		 jae	 SHORT $LN9@printer_qu
  000f0	eb 05		 jmp	 SHORT $LN10@printer_qu
$LN9@printer_qu:
  000f2	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN10@printer_qu:
  000f7	48 8b 44 24 50	 mov	 rax, QWORD PTR $T1[rsp]
  000fc	c6 84 04 80 00
	00 00 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@printer_qu:
  00104	eb 25		 jmp	 SHORT $LN6@printer_qu
$LN5@printer_qu:
  00106	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010e	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00114	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  0011a	48 8b d0	 mov	 rdx, rax
  0011d	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@printer_qu:

; 1569 : 
; 1570 :     snprintf (buffer, buflen, "%s%s%s%s%s IO[%"PRIu64"]",

  0012b	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00133	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  00139	c1 e8 02	 shr	 eax, 2
  0013c	83 e0 01	 and	 eax, 1
  0013f	85 c0		 test	 eax, eax
  00141	74 0e		 je	 SHORT $LN11@printer_qu
  00143	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168852
  0014a	48 89 44 24 58	 mov	 QWORD PTR tv129[rsp], rax
  0014f	eb 0c		 jmp	 SHORT $LN12@printer_qu
$LN11@printer_qu:
  00151	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168853
  00158	48 89 44 24 58	 mov	 QWORD PTR tv129[rsp], rax
$LN12@printer_qu:
  0015d	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00165	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0016b	83 e0 01	 and	 eax, 1
  0016e	85 c0		 test	 eax, eax
  00170	74 0e		 je	 SHORT $LN13@printer_qu
  00172	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168854
  00179	48 89 44 24 60	 mov	 QWORD PTR tv134[rsp], rax
  0017e	eb 0c		 jmp	 SHORT $LN14@printer_qu
$LN13@printer_qu:
  00180	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168855
  00187	48 89 44 24 60	 mov	 QWORD PTR tv134[rsp], rax
$LN14@printer_qu:
  0018c	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00194	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  0019a	83 e0 01	 and	 eax, 1
  0019d	85 c0		 test	 eax, eax
  0019f	74 0e		 je	 SHORT $LN15@printer_qu
  001a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168856
  001a8	48 89 44 24 68	 mov	 QWORD PTR tv139[rsp], rax
  001ad	eb 0c		 jmp	 SHORT $LN16@printer_qu
$LN15@printer_qu:
  001af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168857
  001b6	48 89 44 24 68	 mov	 QWORD PTR tv139[rsp], rax
$LN16@printer_qu:
  001bb	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c3	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  001cb	74 0e		 je	 SHORT $LN17@printer_qu
  001cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168858
  001d4	48 89 44 24 70	 mov	 QWORD PTR tv143[rsp], rax
  001d9	eb 0c		 jmp	 SHORT $LN18@printer_qu
$LN17@printer_qu:
  001db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168859
  001e2	48 89 44 24 70	 mov	 QWORD PTR tv143[rsp], rax
$LN18@printer_qu:
  001e7	48 63 84 24 c0
	01 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  001ef	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f7	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  001fe	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00203	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv129[rsp]
  00208	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0020d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv134[rsp]
  00212	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00217	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv139[rsp]
  0021c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00221	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv143[rsp]
  00226	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0022b	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR filename$[rsp]
  00233	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168860
  0023a	48 8b d0	 mov	 rdx, rax
  0023d	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN1@printer_qu:
$LN8@printer_qu:

; 1571 :                  filename,
; 1572 :                 (dev->bs      ? " sockdev"   : ""),
; 1573 :                 (dev->crlf    ? " crlf"      : ""),
; 1574 :                 (dev->append  ? " append"    : ""),
; 1575 :                 (dev->stopdev ? " (stopped)" : ""),
; 1576 :                  dev->excps );
; 1577 : 
; 1578 : } /* end function printer_query_device */

  0024b	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00253	48 33 cc	 xor	 rcx, rsp
  00256	e8 00 00 00 00	 call	 __security_check_cookie
  0025b	48 81 c4 a8 01
	00 00		 add	 rsp, 424		; 000001a8H
  00262	c3		 ret	 0
printer_query_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
iarg$ = 96
ptr$ = 104
j$ = 112
sockdev$ = 116
c$1 = 117
nxt$ = 120
i$ = 128
line$2 = 132
chan$3 = 136
chan$4 = 140
line$5 = 144
fcbsize$ = 148
tv170 = 152
tv176 = 156
tv190 = 160
tv238 = 164
tv323 = 168
tv329 = 172
found$6 = 176
tv399 = 180
tv405 = 184
tv458 = 188
tv464 = 192
tv518 = 196
tv524 = 200
tv607 = 204
tv613 = 208
tv654 = 212
tv660 = 216
tv716 = 220
tv722 = 224
tv762 = 228
tv768 = 232
tv830 = 236
tv836 = 240
tv885 = 244
tv891 = 248
found$7 = 252
tv978 = 256
tv984 = 260
tv1068 = 264
tv1074 = 268
tv1127 = 272
tv1133 = 276
tv1162 = 280
tv1168 = 284
tv1195 = 288
tv1201 = 292
tv1230 = 296
tv1236 = 300
tv1252 = 304
tv1258 = 308
tv1290 = 312
tv1296 = 316
tv1375 = 320
tv1381 = 324
tv1398 = 328
tv1404 = 332
tv1459 = 336
tv1465 = 340
tv1518 = 344
tv1524 = 348
tv1550 = 352
tv1556 = 356
tv1584 = 360
tv1590 = 364
tv1638 = 368
tv1644 = 372
tv1678 = 376
tv1684 = 380
tv1715 = 384
tv1721 = 388
tv1741 = 392
tv1747 = 396
tv94 = 400
tv132 = 404
table$8 = 408
table$9 = 416
tv513 = 424
tv602 = 428
tv649 = 432
tv711 = 436
tv756 = 440
tv825 = 444
tv880 = 448
tv973 = 452
tv1063 = 456
tv1122 = 460
tv1157 = 464
tv1190 = 468
tv1224 = 472
tv1284 = 476
tv1370 = 480
tv1454 = 484
tv1513 = 488
tv1578 = 492
tv1673 = 496
tv165 = 500
tv317 = 504
tv394 = 508
tv453 = 512
tv390 = 520
tv449 = 528
tv509 = 536
tv598 = 544
tv645 = 552
tv707 = 560
tv821 = 568
tv876 = 576
tv969 = 584
tv1059 = 592
tv1118 = 600
tv1153 = 608
tv1186 = 616
tv1366 = 624
tv1450 = 632
tv1509 = 640
tv1669 = 648
dev$ = 688
argc$ = 696
argv$ = 704
printer_init_handler PROC

; 930  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 98 02
	00 00		 sub	 rsp, 664		; 00000298H

; 931  : char *ptr;                              /* Work variable for parsing */
; 932  : char *nxt;                              /* Work variable for parsing */
; 933  : int   iarg, i, j;                       /* Some array subscripts     */
; 934  : U8    sockdev = FALSE;                  /* TRUE == is socket device  */

  00017	c6 44 24 74 00	 mov	 BYTE PTR sockdev$[rsp], 0

; 935  : int   fcbsize;                          /* FCB size for this devtype */
; 936  : 
; 937  :     dev->sns = format_sense;            /* Sense formatting fuction  */

  0001c	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:format_sense
  0002b	48 89 88 c0 02
	00 00		 mov	 QWORD PTR [rax+704], rcx

; 938  : 
; 939  :     /* For re-initialisation, close the existing file, if any, and raise attention */
; 940  :     if (dev->fd >= 0)

  00032	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003a	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00041	7c 62		 jl	 SHORT $LN20@printer_in

; 941  :     {
; 942  :         (dev->hnd->close)( dev );

  00043	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004b	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00052	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0005a	ff 50 10	 call	 QWORD PTR [rax+16]

; 943  : 
; 944  :         release_lock( &dev->lock );

  0005d	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00065	48 83 c0 38	 add	 rax, 56			; 00000038H
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168603
  00070	48 8b c8	 mov	 rcx, rax
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 945  :         device_attention( dev, CSW_DE );

  00079	b2 04		 mov	 dl, 4
  0007b	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_device_attention

; 946  :         obtain_lock( &dev->lock );

  00089	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00091	48 83 c0 38	 add	 rax, 56			; 00000038H
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168604
  0009c	48 8b c8	 mov	 rcx, rax
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN20@printer_in:

; 947  :     }
; 948  : 
; 949  :     dev->excps = 0;

  000a5	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ad	48 c7 80 00 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1536], 0

; 950  : 
; 951  :     /* Forcibly disconnect anyone already currently connected */
; 952  :     if (dev->bs && !unbind_device_ex( dev, 1 ))

  000b8	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c0	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  000c8	74 20		 je	 SHORT $LN21@printer_in
  000ca	ba 01 00 00 00	 mov	 edx, 1
  000cf	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000d7	e8 00 00 00 00	 call	 unbind_device_ex
  000dc	85 c0		 test	 eax, eax
  000de	75 0a		 jne	 SHORT $LN21@printer_in

; 953  :         return -1; // (error msg already issued)

  000e0	b8 ff ff ff ff	 mov	 eax, -1
  000e5	e9 00 33 00 00	 jmp	 $LN1@printer_in
$LN21@printer_in:

; 954  : 
; 955  :     /* The first argument is the file name */
; 956  :     if (argc == 0 || strlen( argv[0] ) >= sizeof( dev->filename ))

  000ea	83 bc 24 b8 02
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  000f2	74 26		 je	 SHORT $LN23@printer_in
  000f4	b8 08 00 00 00	 mov	 eax, 8
  000f9	48 6b c0 00	 imul	 rax, rax, 0
  000fd	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00105	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00109	e8 00 00 00 00	 call	 strlen
  0010e	48 3d 05 01 00
	00		 cmp	 rax, 261		; 00000105H
  00114	0f 82 bf 00 00
	00		 jb	 $LN22@printer_in
$LN23@printer_in:

; 957  :     {
; 958  :         // "%1d:%04X Printer: file name missing or invalid"
; 959  :         WRMSG( HHC01101, "E", LCSS_DEVNUM );

  0011a	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00123	74 15		 je	 SHORT $LN102@printer_in
  00125	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0012d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00131	89 84 24 90 01
	00 00		 mov	 DWORD PTR tv94[rsp], eax
  00138	eb 0b		 jmp	 SHORT $LN103@printer_in
$LN102@printer_in:
  0013a	c7 84 24 90 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv94[rsp], 0
$LN103@printer_in:
  00145	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0014e	74 17		 je	 SHORT $LN104@printer_in
  00150	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00158	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0015c	d1 f8		 sar	 eax, 1
  0015e	89 84 24 94 01
	00 00		 mov	 DWORD PTR tv132[rsp], eax
  00165	eb 0b		 jmp	 SHORT $LN105@printer_in
$LN104@printer_in:
  00167	c7 84 24 94 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv132[rsp], 0
$LN105@printer_in:
  00172	b9 01 00 00 00	 mov	 ecx, 1
  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0017d	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR tv94[rsp]
  00184	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00188	8b 8c 24 94 01
	00 00		 mov	 ecx, DWORD PTR tv132[rsp]
  0018f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168608
  0019a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168609
  001a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b0	41 b9 03 00 00
	00		 mov	 r9d, 3
  001b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168610
  001bd	ba bf 03 00 00	 mov	 edx, 959		; 000003bfH
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168611
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 960  :         return -1;

  001cf	b8 ff ff ff ff	 mov	 eax, -1
  001d4	e9 11 32 00 00	 jmp	 $LN1@printer_in
$LN22@printer_in:

; 961  :     }
; 962  : 
; 963  :     /* Save the file name in the device block */
; 964  :     hostpath( dev->filename, argv[0], sizeof( dev->filename ));

  001d9	b8 08 00 00 00	 mov	 eax, 8
  001de	48 6b c0 00	 imul	 rax, rax, 0
  001e2	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ea	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  001f1	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  001f7	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  001ff	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 965  : 
; 966  :     /* Save the device type */
; 967  :     sscanf( dev->typname, "%hx", &dev->devtype );

  00209	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00211	48 83 c0 4a	 add	 rax, 74			; 0000004aH
  00215	4c 8b c0	 mov	 r8, rax
  00218	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168612
  0021f	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00227	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  0022b	e8 00 00 00 00	 call	 sscanf

; 968  :     if (1
; 969  :         && 0x1403 != dev->devtype
; 970  :         && 0x3203 != dev->devtype
; 971  :         && 0x3211 != dev->devtype

  00230	33 c0		 xor	 eax, eax
  00232	83 f8 01	 cmp	 eax, 1
  00235	0f 84 22 01 00
	00		 je	 $LN24@printer_in
  0023b	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00243	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00247	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  0024c	0f 84 0b 01 00
	00		 je	 $LN24@printer_in
  00252	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0025a	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0025e	3d 03 32 00 00	 cmp	 eax, 12803		; 00003203H
  00263	0f 84 f4 00 00
	00		 je	 $LN24@printer_in
  00269	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00271	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00275	3d 11 32 00 00	 cmp	 eax, 12817		; 00003211H
  0027a	0f 84 dd 00 00
	00		 je	 $LN24@printer_in

; 972  :     )
; 973  :     {
; 974  :         // "%1d:%04X Printer: unsupported device type %04X"
; 975  :         WRMSG( HHC01105, "E", LCSS_DEVNUM,

  00280	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00289	74 15		 je	 SHORT $LN106@printer_in
  0028b	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00293	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00297	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv170[rsp], eax
  0029e	eb 0b		 jmp	 SHORT $LN107@printer_in
$LN106@printer_in:
  002a0	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv170[rsp], 0
$LN107@printer_in:
  002ab	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002b4	74 17		 je	 SHORT $LN108@printer_in
  002b6	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002be	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002c2	d1 f8		 sar	 eax, 1
  002c4	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv176[rsp], eax
  002cb	eb 0b		 jmp	 SHORT $LN109@printer_in
$LN108@printer_in:
  002cd	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv176[rsp], 0
$LN109@printer_in:
  002d8	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002e0	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  002e4	89 84 24 f4 01
	00 00		 mov	 DWORD PTR tv165[rsp], eax
  002eb	b9 01 00 00 00	 mov	 ecx, 1
  002f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f6	8b 8c 24 f4 01
	00 00		 mov	 ecx, DWORD PTR tv165[rsp]
  002fd	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00301	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv170[rsp]
  00308	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0030c	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv176[rsp]
  00313	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00317	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168614
  0031e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00323	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168615
  0032a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0032f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00334	41 b9 03 00 00
	00		 mov	 r9d, 3
  0033a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168616
  00341	ba d0 03 00 00	 mov	 edx, 976		; 000003d0H
  00346	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168617
  0034d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 976  :             dev->devtype );
; 977  :         return -1;

  00353	b8 ff ff ff ff	 mov	 eax, -1
  00358	e9 8d 30 00 00	 jmp	 $LN1@printer_in
$LN24@printer_in:

; 978  :     }
; 979  :     fcbsize = FCBSIZE( dev ); // (now that we know the device type)

  0035d	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00365	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00369	3d 11 32 00 00	 cmp	 eax, 12817		; 00003211H
  0036e	75 0d		 jne	 SHORT $LN110@printer_in
  00370	c7 84 24 a0 00
	00 00 b4 00 00
	00		 mov	 DWORD PTR tv190[rsp], 180 ; 000000b4H
  0037b	eb 0b		 jmp	 SHORT $LN111@printer_in
$LN110@printer_in:
  0037d	c7 84 24 a0 00
	00 00 00 01 00
	00		 mov	 DWORD PTR tv190[rsp], 256 ; 00000100H
$LN111@printer_in:
  00388	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv190[rsp]
  0038f	89 84 24 94 00
	00 00		 mov	 DWORD PTR fcbsize$[rsp], eax

; 980  : 
; 981  :     /* Initialize the device identifier bytes */
; 982  :     dev->devid[0] = 0xFF;

  00396	b8 01 00 00 00	 mov	 eax, 1
  0039b	48 6b c0 00	 imul	 rax, rax, 0
  0039f	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003a7	c6 84 01 68 04
	00 00 ff	 mov	 BYTE PTR [rcx+rax+1128], 255 ; 000000ffH

; 983  :     dev->devid[1] = 0x28; /* Control unit type is 2821-1 */

  003af	b8 01 00 00 00	 mov	 eax, 1
  003b4	48 6b c0 01	 imul	 rax, rax, 1
  003b8	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003c0	c6 84 01 68 04
	00 00 28	 mov	 BYTE PTR [rcx+rax+1128], 40 ; 00000028H

; 984  :     dev->devid[2] = 0x21;

  003c8	b8 01 00 00 00	 mov	 eax, 1
  003cd	48 6b c0 02	 imul	 rax, rax, 2
  003d1	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003d9	c6 84 01 68 04
	00 00 21	 mov	 BYTE PTR [rcx+rax+1128], 33 ; 00000021H

; 985  :     dev->devid[3] = 0x01;

  003e1	b8 01 00 00 00	 mov	 eax, 1
  003e6	48 6b c0 03	 imul	 rax, rax, 3
  003ea	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003f2	c6 84 01 68 04
	00 00 01	 mov	 BYTE PTR [rcx+rax+1128], 1

; 986  :     dev->devid[4] = dev->devtype >> 8;

  003fa	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00402	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00406	c1 f8 08	 sar	 eax, 8
  00409	b9 01 00 00 00	 mov	 ecx, 1
  0040e	48 6b c9 04	 imul	 rcx, rcx, 4
  00412	48 8b 94 24 b0
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0041a	88 84 0a 68 04
	00 00		 mov	 BYTE PTR [rdx+rcx+1128], al

; 987  :     dev->devid[5] = dev->devtype & 0xFF;

  00421	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00429	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0042d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00432	b9 01 00 00 00	 mov	 ecx, 1
  00437	48 6b c9 05	 imul	 rcx, rcx, 5
  0043b	48 8b 94 24 b0
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00443	88 84 0a 68 04
	00 00		 mov	 BYTE PTR [rdx+rcx+1128], al

; 988  :     dev->devid[6] = 0x01;

  0044a	b8 01 00 00 00	 mov	 eax, 1
  0044f	48 6b c0 06	 imul	 rax, rax, 6
  00453	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0045b	c6 84 01 68 04
	00 00 01	 mov	 BYTE PTR [rcx+rax+1128], 1

; 989  :     dev->numdevid = 7;

  00463	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0046b	c7 80 64 04 00
	00 07 00 00 00	 mov	 DWORD PTR [rax+1124], 7

; 990  : 
; 991  :     /* Set number of sense bytes */
; 992  :     dev->numsense = 2;

  00475	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0047d	c7 80 60 03 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+864], 2

; 993  : 
; 994  :     /* Initialize device dependent fields */
; 995  :     dev->fd       = -1;

  00487	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0048f	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 996  :     dev->crlf     = 0;

  00499	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004a1	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  004a7	83 e0 fe	 and	 eax, -2			; fffffffeH
  004aa	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004b2	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 997  :     dev->stopdev  = FALSE;

  004b8	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004c0	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  004c6	83 e0 fb	 and	 eax, -5			; fffffffbH
  004c9	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004d1	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 998  :     dev->append   = 0;

  004d7	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004df	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004e5	83 e0 fe	 and	 eax, -2			; fffffffeH
  004e8	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004f0	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 999  :     dev->ispiped  = (dev->filename[0] == '|');

  004f6	b8 01 00 00 00	 mov	 eax, 1
  004fb	48 6b c0 00	 imul	 rax, rax, 0
  004ff	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00507	0f be 84 01 a4
	00 00 00	 movsx	 eax, BYTE PTR [rcx+rax+164]
  0050f	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00512	75 0d		 jne	 SHORT $LN112@printer_in
  00514	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv238[rsp], 1
  0051f	eb 0b		 jmp	 SHORT $LN113@printer_in
$LN112@printer_in:
  00521	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv238[rsp], 0
$LN113@printer_in:
  0052c	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv238[rsp]
  00533	83 e0 01	 and	 eax, 1
  00536	d1 e0		 shl	 eax, 1
  00538	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00540	8b 89 84 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1924]
  00546	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00549	0b c8		 or	 ecx, eax
  0054b	8b c1		 mov	 eax, ecx
  0054d	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00555	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 1000 : 
; 1001 :     /* Set length of print buffer */
; 1002 :     dev->bufsize = BUFF_SIZE;

  0055b	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00563	c7 80 d8 01 00
	00 b0 01 00 00	 mov	 DWORD PTR [rax+472], 432 ; 000001b0H

; 1003 :     dev->bufres  = BUFF_SIZE;

  0056d	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00575	c7 80 e4 01 00
	00 b0 01 00 00	 mov	 DWORD PTR [rax+484], 432 ; 000001b0H

; 1004 :     dev->bufoff  = 0;

  0057f	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00587	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 1005 : 
; 1006 :     /* Initialize Forms Control Buffer and Carriage Control Tape */
; 1007 :     dev->lpi      = 6;

  00591	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00599	c7 80 88 07 00
	00 06 00 00 00	 mov	 DWORD PTR [rax+1928], 6

; 1008 :     dev->index    = 0;

  005a3	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005ab	c7 80 8c 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1932], 0

; 1009 :     dev->diaggate = 0;

  005b5	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005bd	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  005c3	83 e0 ef	 and	 eax, -17		; ffffffefH
  005c6	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005ce	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 1010 :     dev->fold     = 0;

  005d4	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005dc	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  005e2	83 e0 df	 and	 eax, -33		; ffffffdfH
  005e5	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005ed	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 1011 :     dev->fcbcheck = 1;  /* (DEPRECATED!) */

  005f3	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005fb	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  00601	83 c8 08	 or	 eax, 8
  00604	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0060c	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 1012 :     dev->ffpend   = 0;

  00612	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0061a	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  00620	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00623	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0062b	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 1013 :     dev->sp0after = 0;

  00631	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00639	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  0063f	0f ba f0 07	 btr	 eax, 7
  00643	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0064b	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 1014 :     dev->currline = 1;

  00651	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00659	c7 80 a8 0d 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+3496], 1

; 1015 : 
; 1016 :     memcpy( dev->fcb,    fcbmask_legacy, sizeof( dev->fcb    ));

  00663	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0066b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fcbmask_legacy
  00672	48 8d b8 94 07
	00 00		 lea	 rdi, QWORD PTR [rax+1940]
  00679	48 8b f1	 mov	 rsi, rcx
  0067c	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00681	f3 a4		 rep movsb

; 1017 :     memcpy( dev->cctape, cctape_legacy,  sizeof( dev->cctape ));

  00683	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0068b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cctape_legacy
  00692	48 8d b8 a0 0b
	00 00		 lea	 rdi, QWORD PTR [rax+2976]
  00699	48 8b f1	 mov	 rsi, rcx
  0069c	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  006a1	f3 a4		 rep movsb

; 1018 : 
; 1019 :     dev->lpp = dev->fcb[0];

  006a3	b8 04 00 00 00	 mov	 eax, 4
  006a8	48 6b c0 00	 imul	 rax, rax, 0
  006ac	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006b4	48 8b 94 24 b0
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  006bc	8b 84 02 94 07
	00 00		 mov	 eax, DWORD PTR [rdx+rax+1940]
  006c3	89 81 90 07 00
	00		 mov	 DWORD PTR [rcx+1936], eax

; 1020 : 
; 1021 :     if (dev->fcbname)

  006c9	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006d1	48 83 b8 98 0b
	00 00 00	 cmp	 QWORD PTR [rax+2968], 0
  006d9	74 28		 je	 SHORT $LN25@printer_in

; 1022 :     {
; 1023 :         free( dev->fcbname );

  006db	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006e3	48 8b 88 98 0b
	00 00		 mov	 rcx, QWORD PTR [rax+2968]
  006ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1024 :         dev->fcbname = NULL;

  006f0	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006f8	48 c7 80 98 0b
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+2968], 0
$LN25@printer_in:

; 1025 :     }
; 1026 :     dev->fcbname = strdup( "legacy" );

  00703	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168619
  0070a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00710	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00718	48 89 81 98 0b
	00 00		 mov	 QWORD PTR [rcx+2968], rax

; 1027 : 
; 1028 :     /* Process the driver arguments...
; 1029 :        PLEASE TRY TO KEEP THE BELOW IN ALPHABETICAL ORDER.
; 1030 :     */
; 1031 :     for (iarg=1; iarg < argc; iarg++)

  0071f	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR iarg$[rsp], 1
  00727	eb 0a		 jmp	 SHORT $LN4@printer_in
$LN2@printer_in:
  00729	8b 44 24 60	 mov	 eax, DWORD PTR iarg$[rsp]
  0072d	ff c0		 inc	 eax
  0072f	89 44 24 60	 mov	 DWORD PTR iarg$[rsp], eax
$LN4@printer_in:
  00733	8b 84 24 b8 02
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0073a	39 44 24 60	 cmp	 DWORD PTR iarg$[rsp], eax
  0073e	0f 8d 12 2a 00
	00		 jge	 $LN3@printer_in

; 1032 :     {
; 1033 :         if (strcasecmp( argv[iarg], "append" ) == 0)

  00744	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  00749	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168621
  00750	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00758	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0075c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00762	85 c0		 test	 eax, eax
  00764	75 21		 jne	 SHORT $LN26@printer_in

; 1034 :         {
; 1035 :             dev->append = 1;

  00766	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0076e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00774	83 c8 01	 or	 eax, 1
  00777	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0077f	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1036 :             continue;

  00785	eb a2		 jmp	 SHORT $LN2@printer_in
$LN26@printer_in:

; 1037 :         }
; 1038 : 
; 1039 :         if (strncasecmp( "cctape=", argv[iarg], 7 ) == 0)

  00787	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  0078c	41 b8 07 00 00
	00		 mov	 r8d, 7
  00792	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0079a	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0079e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168623
  007a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  007ab	85 c0		 test	 eax, eax
  007ad	0f 85 8c 0c 00
	00		 jne	 $LN27@printer_in

; 1040 :         {
; 1041 :             int line, chan, found;
; 1042 :             if (dev->devtype != 0x1403)

  007b3	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007bb	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  007bf	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  007c4	0f 84 e9 00 00
	00		 je	 $LN28@printer_in

; 1043 :             {
; 1044 :                 // HHC01109 "%1d:%04X Printer: option %s incompatible with device type %04X"
; 1045 :                 WRMSG( HHC01109, "E", LCSS_DEVNUM,

  007ca	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  007d3	74 15		 je	 SHORT $LN114@printer_in
  007d5	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007dd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  007e1	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv323[rsp], eax
  007e8	eb 0b		 jmp	 SHORT $LN115@printer_in
$LN114@printer_in:
  007ea	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv323[rsp], 0
$LN115@printer_in:
  007f5	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  007fe	74 17		 je	 SHORT $LN116@printer_in
  00800	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00808	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0080c	d1 f8		 sar	 eax, 1
  0080e	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv329[rsp], eax
  00815	eb 0b		 jmp	 SHORT $LN117@printer_in
$LN116@printer_in:
  00817	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv329[rsp], 0
$LN117@printer_in:
  00822	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0082a	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0082e	89 84 24 f8 01
	00 00		 mov	 DWORD PTR tv317[rsp], eax
  00835	b9 01 00 00 00	 mov	 ecx, 1
  0083a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00840	8b 8c 24 f8 01
	00 00		 mov	 ecx, DWORD PTR tv317[rsp]
  00847	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0084b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168625
  00852	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00857	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv323[rsp]
  0085e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00862	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv329[rsp]
  00869	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0086d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168626
  00874	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00879	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168627
  00880	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00885	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0088a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00890	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168628
  00897	ba 16 04 00 00	 mov	 edx, 1046		; 00000416H
  0089c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168629
  008a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1046 :                     "option 'cctape'", dev->devtype );
; 1047 :                 return -1;

  008a9	b8 ff ff ff ff	 mov	 eax, -1
  008ae	e9 37 2b 00 00	 jmp	 $LN1@printer_in
$LN28@printer_in:

; 1048 :             }
; 1049 :             /*  "cctape=(ll=cc,ll=(cc,cc)...)"
; 1050 :                 "cctape=name"
; 1051 :             */
; 1052 :             ptr = argv[iarg] + 7;  /* get past "cctape=" */

  008b3	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  008b8	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008c0	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  008c4	48 83 c0 07	 add	 rax, 7
  008c8	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax

; 1053 :             if (ptr[0] != '(')

  008cd	b8 01 00 00 00	 mov	 eax, 1
  008d2	48 6b c0 00	 imul	 rax, rax, 0
  008d6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  008db	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  008df	83 f8 28	 cmp	 eax, 40			; 00000028H
  008e2	0f 84 49 02 00
	00		 je	 $LN29@printer_in

; 1054 :             {
; 1055 :                 /* Doesn't look like they're trying to define a custom
; 1056 :                    cctape. See if they specified a cctape name instead.
; 1057 :                 */
; 1058 :                 FCBTAB* table = fcbtab;

  008e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:fcbtab
  008ef	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR table$8[rsp], rax

; 1059 : 
; 1060 :                 for (i=0, found=0; i < (int) _countof( fcbtab ); i++)

  008f7	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00902	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR found$6[rsp], 0
  0090d	eb 10		 jmp	 SHORT $LN7@printer_in
$LN5@printer_in:
  0090f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00916	ff c0		 inc	 eax
  00918	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN7@printer_in:
  0091f	83 bc 24 80 00
	00 00 07	 cmp	 DWORD PTR i$[rsp], 7
  00927	0f 8d e4 00 00
	00		 jge	 $LN6@printer_in

; 1061 :                 {
; 1062 :                     if (FCBTYPE_CCTAPE != table[i].type)

  0092d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00935	48 6b c0 18	 imul	 rax, rax, 24
  00939	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR table$8[rsp]
  00941	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00945	83 f8 01	 cmp	 eax, 1
  00948	74 02		 je	 SHORT $LN31@printer_in

; 1063 :                         continue;

  0094a	eb c3		 jmp	 SHORT $LN5@printer_in
$LN31@printer_in:

; 1064 : 
; 1065 :                     /* Is this the one they want? */
; 1066 :                     if (strcasecmp( table[i].name, ptr ) == 0)

  0094c	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00954	48 6b c0 18	 imul	 rax, rax, 24
  00958	48 8b 54 24 68	 mov	 rdx, QWORD PTR ptr$[rsp]
  0095d	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR table$8[rsp]
  00965	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  0096a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00970	85 c0		 test	 eax, eax
  00972	0f 85 94 00 00
	00		 jne	 $LN32@printer_in

; 1067 :                     {
; 1068 :                         found = 1;

  00978	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR found$6[rsp], 1

; 1069 :                         memcpy( dev->cctape, table[i].image, sizeof( dev->cctape ));

  00983	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0098b	48 6b c0 18	 imul	 rax, rax, 24
  0098f	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR table$8[rsp]
  00997	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  0099c	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009a4	48 8d b9 a0 0b
	00 00		 lea	 rdi, QWORD PTR [rcx+2976]
  009ab	48 8b f0	 mov	 rsi, rax
  009ae	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  009b3	f3 a4		 rep movsb

; 1070 :                         if (dev->fcbname) free( dev->fcbname );

  009b5	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009bd	48 83 b8 98 0b
	00 00 00	 cmp	 QWORD PTR [rax+2968], 0
  009c5	74 15		 je	 SHORT $LN33@printer_in
  009c7	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009cf	48 8b 88 98 0b
	00 00		 mov	 rcx, QWORD PTR [rax+2968]
  009d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN33@printer_in:

; 1071 :                         dev->fcbname = strdup( table[i].name );

  009dc	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  009e4	48 6b c0 18	 imul	 rax, rax, 24
  009e8	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR table$8[rsp]
  009f0	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  009f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  009fb	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a03	48 89 81 98 0b
	00 00		 mov	 QWORD PTR [rcx+2968], rax

; 1072 :                         break;

  00a0a	eb 05		 jmp	 SHORT $LN6@printer_in
$LN32@printer_in:

; 1073 :                     }
; 1074 :                 }

  00a0c	e9 fe fe ff ff	 jmp	 $LN5@printer_in
$LN6@printer_in:

; 1075 :                 if (!found)

  00a11	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR found$6[rsp], 0
  00a19	0f 85 0d 01 00
	00		 jne	 $LN34@printer_in

; 1076 :                 {
; 1077 :                     j = 8;

  00a1f	c7 44 24 70 08
	00 00 00	 mov	 DWORD PTR j$[rsp], 8

; 1078 :                     // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1079 :                     WRMSG( HHC01103, "E", LCSS_DEVNUM,

  00a27	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00a30	74 15		 je	 SHORT $LN118@printer_in
  00a32	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a3a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00a3e	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv399[rsp], eax
  00a45	eb 0b		 jmp	 SHORT $LN119@printer_in
$LN118@printer_in:
  00a47	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv399[rsp], 0
$LN119@printer_in:
  00a52	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00a5b	74 17		 je	 SHORT $LN120@printer_in
  00a5d	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a65	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00a69	d1 f8		 sar	 eax, 1
  00a6b	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv405[rsp], eax
  00a72	eb 0b		 jmp	 SHORT $LN121@printer_in
$LN120@printer_in:
  00a74	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv405[rsp], 0
$LN121@printer_in:
  00a7f	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  00a84	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR tv390[rsp], rax
  00a8c	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  00a90	ff c1		 inc	 ecx
  00a92	89 8c 24 fc 01
	00 00		 mov	 DWORD PTR tv394[rsp], ecx
  00a99	b9 01 00 00 00	 mov	 ecx, 1
  00a9e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00aa4	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  00aa8	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00aac	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00ab4	48 8b 94 24 08
	02 00 00	 mov	 rdx, QWORD PTR tv390[rsp]
  00abc	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00ac0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00ac5	8b 8c 24 fc 01
	00 00		 mov	 ecx, DWORD PTR tv394[rsp]
  00acc	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00ad0	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv399[rsp]
  00ad7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00adb	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv405[rsp]
  00ae2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ae6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168636
  00aed	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00af2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168637
  00af9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00afe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b03	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b09	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168638
  00b10	ba 38 04 00 00	 mov	 edx, 1080		; 00000438H
  00b15	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168639
  00b1c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1080 :                         iarg + 1, argv[ iarg ], j );
; 1081 :                     return -1;

  00b22	b8 ff ff ff ff	 mov	 eax, -1
  00b27	e9 be 28 00 00	 jmp	 $LN1@printer_in
$LN34@printer_in:

; 1082 :                 }
; 1083 :             }

  00b2c	e9 fc 08 00 00	 jmp	 $LN30@printer_in
$LN29@printer_in:

; 1084 :             else
; 1085 :             {
; 1086 :                 ptr++;  /* get past '(' */

  00b31	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  00b36	48 ff c0	 inc	 rax
  00b39	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax

; 1087 :                 memset( dev->cctape, 0, sizeof( dev->cctape ));

  00b3e	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b46	48 05 a0 0b 00
	00		 add	 rax, 2976		; 00000ba0H
  00b4c	48 8b f8	 mov	 rdi, rax
  00b4f	33 c0		 xor	 eax, eax
  00b51	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00b56	f3 aa		 rep stosb

; 1088 :                 errno = 0;

  00b58	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00b5e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN8@printer_in:

; 1089 :                 /* Keep parsing until closing ')' found */
; 1090 :                 while (ptr[0] && ptr[0] != ')')

  00b64	b8 01 00 00 00	 mov	 eax, 1
  00b69	48 6b c0 00	 imul	 rax, rax, 0
  00b6d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  00b72	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00b76	85 c0		 test	 eax, eax
  00b78	0f 84 4f 07 00
	00		 je	 $LN9@printer_in
  00b7e	b8 01 00 00 00	 mov	 eax, 1
  00b83	48 6b c0 00	 imul	 rax, rax, 0
  00b87	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  00b8c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00b90	83 f8 29	 cmp	 eax, 41			; 00000029H
  00b93	0f 84 34 07 00
	00		 je	 $LN9@printer_in

; 1091 :                 {
; 1092 :                     line = (int) strtoul( ptr, &nxt, 10 );

  00b99	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00b9f	48 8d 54 24 78	 lea	 rdx, QWORD PTR nxt$[rsp]
  00ba4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  00ba9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  00baf	89 84 24 90 00
	00 00		 mov	 DWORD PTR line$5[rsp], eax

; 1093 :                     if (0
; 1094 :                         || errno != 0
; 1095 :                         || *nxt != '='
; 1096 :                         || line < 1
; 1097 :                         || line > fcbsize

  00bb6	33 c0		 xor	 eax, eax
  00bb8	85 c0		 test	 eax, eax
  00bba	75 36		 jne	 SHORT $LN36@printer_in
  00bbc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00bc2	83 38 00	 cmp	 DWORD PTR [rax], 0
  00bc5	75 2b		 jne	 SHORT $LN36@printer_in
  00bc7	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  00bcc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00bcf	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  00bd2	75 1e		 jne	 SHORT $LN36@printer_in
  00bd4	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR line$5[rsp], 1
  00bdc	7c 14		 jl	 SHORT $LN36@printer_in
  00bde	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR fcbsize$[rsp]
  00be5	39 84 24 90 00
	00 00		 cmp	 DWORD PTR line$5[rsp], eax
  00bec	0f 8e 22 01 00
	00		 jle	 $LN35@printer_in
$LN36@printer_in:

; 1098 :                     )
; 1099 :                     {
; 1100 :                         j = ptr+1 - argv[ iarg ];

  00bf2	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  00bf7	48 ff c0	 inc	 rax
  00bfa	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  00bff	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00c07	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  00c0b	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1101 :                         // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1102 :                         WRMSG( HHC01103, "E", LCSS_DEVNUM,

  00c0f	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00c18	74 15		 je	 SHORT $LN122@printer_in
  00c1a	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c22	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00c26	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv458[rsp], eax
  00c2d	eb 0b		 jmp	 SHORT $LN123@printer_in
$LN122@printer_in:
  00c2f	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv458[rsp], 0
$LN123@printer_in:
  00c3a	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00c43	74 17		 je	 SHORT $LN124@printer_in
  00c45	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c4d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00c51	d1 f8		 sar	 eax, 1
  00c53	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv464[rsp], eax
  00c5a	eb 0b		 jmp	 SHORT $LN125@printer_in
$LN124@printer_in:
  00c5c	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv464[rsp], 0
$LN125@printer_in:
  00c67	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  00c6c	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR tv449[rsp], rax
  00c74	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  00c78	ff c1		 inc	 ecx
  00c7a	89 8c 24 00 02
	00 00		 mov	 DWORD PTR tv453[rsp], ecx
  00c81	b9 01 00 00 00	 mov	 ecx, 1
  00c86	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c8c	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  00c90	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00c94	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00c9c	48 8b 94 24 10
	02 00 00	 mov	 rdx, QWORD PTR tv449[rsp]
  00ca4	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00ca8	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00cad	8b 8c 24 00 02
	00 00		 mov	 ecx, DWORD PTR tv453[rsp]
  00cb4	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00cb8	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv458[rsp]
  00cbf	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00cc3	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv464[rsp]
  00cca	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00cce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168642
  00cd5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00cda	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168643
  00ce1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ce6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ceb	41 b9 03 00 00
	00		 mov	 r9d, 3
  00cf1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168644
  00cf8	ba 4f 04 00 00	 mov	 edx, 1103		; 0000044fH
  00cfd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168645
  00d04	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1103 :                             iarg + 1, argv[ iarg ], j );
; 1104 :                         return -1;

  00d0a	b8 ff ff ff ff	 mov	 eax, -1
  00d0f	e9 d6 26 00 00	 jmp	 $LN1@printer_in
$LN35@printer_in:

; 1105 :                     }
; 1106 :                     /* get past '=' to first chan# or '(' start of chan# list */
; 1107 :                     ptr = nxt + 1;

  00d14	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  00d19	48 ff c0	 inc	 rax
  00d1c	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax

; 1108 :                     if (ptr[0] == '(')  /* start of chan# list? */

  00d21	b8 01 00 00 00	 mov	 eax, 1
  00d26	48 6b c0 00	 imul	 rax, rax, 0
  00d2a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  00d2f	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00d33	83 f8 28	 cmp	 eax, 40			; 00000028H
  00d36	0f 85 91 03 00
	00		 jne	 $LN37@printer_in

; 1109 :                     {
; 1110 :                         ptr++;  /* point to '(' list begin */

  00d3c	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  00d41	48 ff c0	 inc	 rax
  00d44	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax
$LN10@printer_in:

; 1111 :                         /* Keep parsing chan#s until ')' end of list */
; 1112 :                         while (ptr[0] && ptr[0] != ')')

  00d49	b8 01 00 00 00	 mov	 eax, 1
  00d4e	48 6b c0 00	 imul	 rax, rax, 0
  00d52	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  00d57	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00d5b	85 c0		 test	 eax, eax
  00d5d	0f 84 1b 02 00
	00		 je	 $LN11@printer_in
  00d63	b8 01 00 00 00	 mov	 eax, 1
  00d68	48 6b c0 00	 imul	 rax, rax, 0
  00d6c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  00d71	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00d75	83 f8 29	 cmp	 eax, 41			; 00000029H
  00d78	0f 84 00 02 00
	00		 je	 $LN11@printer_in

; 1113 :                         {
; 1114 :                             chan = (int) strtoul( ptr, &nxt, 10 );

  00d7e	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00d84	48 8d 54 24 78	 lea	 rdx, QWORD PTR nxt$[rsp]
  00d89	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  00d8e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  00d94	89 84 24 8c 00
	00 00		 mov	 DWORD PTR chan$4[rsp], eax

; 1115 :                             if (0
; 1116 :                                 || errno != 0
; 1117 :                                 || (*nxt != ',' && *nxt != ')')
; 1118 :                                 || chan < 1
; 1119 :                                 || chan > 12

  00d9b	33 c0		 xor	 eax, eax
  00d9d	85 c0		 test	 eax, eax
  00d9f	75 3d		 jne	 SHORT $LN40@printer_in
  00da1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00da7	83 38 00	 cmp	 DWORD PTR [rax], 0
  00daa	75 32		 jne	 SHORT $LN40@printer_in
  00dac	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  00db1	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00db4	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00db7	74 0d		 je	 SHORT $LN41@printer_in
  00db9	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  00dbe	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00dc1	83 f8 29	 cmp	 eax, 41			; 00000029H
  00dc4	75 18		 jne	 SHORT $LN40@printer_in
$LN41@printer_in:
  00dc6	83 bc 24 8c 00
	00 00 01	 cmp	 DWORD PTR chan$4[rsp], 1
  00dce	7c 0e		 jl	 SHORT $LN40@printer_in
  00dd0	83 bc 24 8c 00
	00 00 0c	 cmp	 DWORD PTR chan$4[rsp], 12
  00dd8	0f 8e 22 01 00
	00		 jle	 $LN39@printer_in
$LN40@printer_in:

; 1120 :                             )
; 1121 :                             {
; 1122 :                                 j = ptr+1 - argv[ iarg ];

  00dde	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  00de3	48 ff c0	 inc	 rax
  00de6	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  00deb	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00df3	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  00df7	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1123 :                                 // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1124 :                                 WRMSG( HHC01103, "E", LCSS_DEVNUM,

  00dfb	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00e04	74 15		 je	 SHORT $LN126@printer_in
  00e06	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e0e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00e12	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv518[rsp], eax
  00e19	eb 0b		 jmp	 SHORT $LN127@printer_in
$LN126@printer_in:
  00e1b	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv518[rsp], 0
$LN127@printer_in:
  00e26	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00e2f	74 17		 je	 SHORT $LN128@printer_in
  00e31	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e39	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00e3d	d1 f8		 sar	 eax, 1
  00e3f	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv524[rsp], eax
  00e46	eb 0b		 jmp	 SHORT $LN129@printer_in
$LN128@printer_in:
  00e48	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv524[rsp], 0
$LN129@printer_in:
  00e53	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  00e58	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR tv509[rsp], rax
  00e60	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  00e64	ff c1		 inc	 ecx
  00e66	89 8c 24 a8 01
	00 00		 mov	 DWORD PTR tv513[rsp], ecx
  00e6d	b9 01 00 00 00	 mov	 ecx, 1
  00e72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e78	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  00e7c	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00e80	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00e88	48 8b 94 24 18
	02 00 00	 mov	 rdx, QWORD PTR tv509[rsp]
  00e90	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00e94	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00e99	8b 8c 24 a8 01
	00 00		 mov	 ecx, DWORD PTR tv513[rsp]
  00ea0	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00ea4	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv518[rsp]
  00eab	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00eaf	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv524[rsp]
  00eb6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00eba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168651
  00ec1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ec6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168652
  00ecd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ed2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ed7	41 b9 03 00 00
	00		 mov	 r9d, 3
  00edd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168653
  00ee4	ba 65 04 00 00	 mov	 edx, 1125		; 00000465H
  00ee9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168654
  00ef0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1125 :                                     iarg + 1, argv[ iarg ], j );
; 1126 :                                 return -1;

  00ef6	b8 ff ff ff ff	 mov	 eax, -1
  00efb	e9 ea 24 00 00	 jmp	 $LN1@printer_in
$LN39@printer_in:

; 1127 :                             }
; 1128 :                             dev->cctape[ line-1 ] |= 0x8000 >> (chan - 1);

  00f00	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR line$5[rsp]
  00f07	ff c8		 dec	 eax
  00f09	48 98		 cdqe
  00f0b	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR chan$4[rsp]
  00f12	ff c9		 dec	 ecx
  00f14	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00f19	d3 fa		 sar	 edx, cl
  00f1b	8b ca		 mov	 ecx, edx
  00f1d	48 8b 94 24 b0
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00f25	0f b7 84 42 a0
	0b 00 00	 movzx	 eax, WORD PTR [rdx+rax*2+2976]
  00f2d	0b c1		 or	 eax, ecx
  00f2f	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR line$5[rsp]
  00f36	ff c9		 dec	 ecx
  00f38	48 63 c9	 movsxd	 rcx, ecx
  00f3b	48 8b 94 24 b0
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00f43	66 89 84 4a a0
	0b 00 00	 mov	 WORD PTR [rdx+rcx*2+2976], ax

; 1129 :                             if ((ptr = nxt)[0] == ',')

  00f4b	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  00f50	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax
  00f55	b8 01 00 00 00	 mov	 eax, 1
  00f5a	48 6b c0 00	 imul	 rax, rax, 0
  00f5e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  00f63	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00f67	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  00f6a	75 0d		 jne	 SHORT $LN42@printer_in

; 1130 :                                 ptr++; /* get past ',' to next chan# */

  00f6c	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  00f71	48 ff c0	 inc	 rax
  00f74	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax
$LN42@printer_in:

; 1131 : 
; 1132 :                         } /* while (ptr[0] && ptr[0] != ')') */

  00f79	e9 cb fd ff ff	 jmp	 $LN10@printer_in
$LN11@printer_in:

; 1133 : 
; 1134 :                         /* Check for proper ')' end of list */
; 1135 :                         if (ptr[0] != ')')

  00f7e	b8 01 00 00 00	 mov	 eax, 1
  00f83	48 6b c0 00	 imul	 rax, rax, 0
  00f87	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  00f8c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00f90	83 f8 29	 cmp	 eax, 41			; 00000029H
  00f93	0f 84 22 01 00
	00		 je	 $LN43@printer_in

; 1136 :                         {
; 1137 :                             j = ptr+1 - argv[iarg];

  00f99	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  00f9e	48 ff c0	 inc	 rax
  00fa1	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  00fa6	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00fae	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  00fb2	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1138 :                             // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1139 :                             WRMSG( HHC01103, "E", LCSS_DEVNUM,

  00fb6	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00fbf	74 15		 je	 SHORT $LN130@printer_in
  00fc1	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fc9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00fcd	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv607[rsp], eax
  00fd4	eb 0b		 jmp	 SHORT $LN131@printer_in
$LN130@printer_in:
  00fd6	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv607[rsp], 0
$LN131@printer_in:
  00fe1	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00fea	74 17		 je	 SHORT $LN132@printer_in
  00fec	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ff4	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00ff8	d1 f8		 sar	 eax, 1
  00ffa	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv613[rsp], eax
  01001	eb 0b		 jmp	 SHORT $LN133@printer_in
$LN132@printer_in:
  01003	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv613[rsp], 0
$LN133@printer_in:
  0100e	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  01013	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR tv598[rsp], rax
  0101b	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  0101f	ff c1		 inc	 ecx
  01021	89 8c 24 ac 01
	00 00		 mov	 DWORD PTR tv602[rsp], ecx
  01028	b9 01 00 00 00	 mov	 ecx, 1
  0102d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01033	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  01037	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0103b	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  01043	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR tv598[rsp]
  0104b	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0104f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01054	8b 8c 24 ac 01
	00 00		 mov	 ecx, DWORD PTR tv602[rsp]
  0105b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0105f	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv607[rsp]
  01066	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0106a	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv613[rsp]
  01071	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168657
  0107c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168658
  01088	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0108d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01092	41 b9 03 00 00
	00		 mov	 r9d, 3
  01098	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168659
  0109f	ba 74 04 00 00	 mov	 edx, 1140		; 00000474H
  010a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168660
  010ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1140 :                                 iarg + 1, argv[ iarg ], j );
; 1141 :                             return -1;

  010b1	b8 ff ff ff ff	 mov	 eax, -1
  010b6	e9 2f 23 00 00	 jmp	 $LN1@printer_in
$LN43@printer_in:

; 1142 :                         }
; 1143 :                         nxt = ptr+1; /* get past ')' to maybe ',' */

  010bb	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  010c0	48 ff c0	 inc	 rax
  010c3	48 89 44 24 78	 mov	 QWORD PTR nxt$[rsp], rax

; 1144 :                     }

  010c8	e9 cd 01 00 00	 jmp	 $LN38@printer_in
$LN37@printer_in:

; 1145 :                     else /* ptr --> chan# or something else */
; 1146 :                     {
; 1147 :                         chan = (int) strtoul( ptr, &nxt, 10 );

  010cd	41 b8 0a 00 00
	00		 mov	 r8d, 10
  010d3	48 8d 54 24 78	 lea	 rdx, QWORD PTR nxt$[rsp]
  010d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  010dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  010e3	89 84 24 8c 00
	00 00		 mov	 DWORD PTR chan$4[rsp], eax

; 1148 :                         if (0
; 1149 :                             || errno != 0
; 1150 :                             || (*nxt != ',' && *nxt != ')')
; 1151 :                             || chan < 1
; 1152 :                             || chan > 12

  010ea	33 c0		 xor	 eax, eax
  010ec	85 c0		 test	 eax, eax
  010ee	75 3d		 jne	 SHORT $LN45@printer_in
  010f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  010f6	83 38 00	 cmp	 DWORD PTR [rax], 0
  010f9	75 32		 jne	 SHORT $LN45@printer_in
  010fb	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  01100	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01103	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  01106	74 0d		 je	 SHORT $LN46@printer_in
  01108	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  0110d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01110	83 f8 29	 cmp	 eax, 41			; 00000029H
  01113	75 18		 jne	 SHORT $LN45@printer_in
$LN46@printer_in:
  01115	83 bc 24 8c 00
	00 00 01	 cmp	 DWORD PTR chan$4[rsp], 1
  0111d	7c 0e		 jl	 SHORT $LN45@printer_in
  0111f	83 bc 24 8c 00
	00 00 0c	 cmp	 DWORD PTR chan$4[rsp], 12
  01127	0f 8e 22 01 00
	00		 jle	 $LN44@printer_in
$LN45@printer_in:

; 1153 :                         )
; 1154 :                         {
; 1155 :                             j = ptr+1 - argv[ iarg ];

  0112d	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  01132	48 ff c0	 inc	 rax
  01135	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  0113a	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  01142	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  01146	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1156 :                             // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1157 :                             WRMSG( HHC01103, "E", LCSS_DEVNUM,

  0114a	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01153	74 15		 je	 SHORT $LN134@printer_in
  01155	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0115d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01161	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv654[rsp], eax
  01168	eb 0b		 jmp	 SHORT $LN135@printer_in
$LN134@printer_in:
  0116a	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv654[rsp], 0
$LN135@printer_in:
  01175	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0117e	74 17		 je	 SHORT $LN136@printer_in
  01180	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01188	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0118c	d1 f8		 sar	 eax, 1
  0118e	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv660[rsp], eax
  01195	eb 0b		 jmp	 SHORT $LN137@printer_in
$LN136@printer_in:
  01197	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv660[rsp], 0
$LN137@printer_in:
  011a2	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  011a7	48 89 84 24 28
	02 00 00	 mov	 QWORD PTR tv645[rsp], rax
  011af	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  011b3	ff c1		 inc	 ecx
  011b5	89 8c 24 b0 01
	00 00		 mov	 DWORD PTR tv649[rsp], ecx
  011bc	b9 01 00 00 00	 mov	 ecx, 1
  011c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011c7	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  011cb	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  011cf	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  011d7	48 8b 94 24 28
	02 00 00	 mov	 rdx, QWORD PTR tv645[rsp]
  011df	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  011e3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  011e8	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR tv649[rsp]
  011ef	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  011f3	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv654[rsp]
  011fa	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  011fe	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv660[rsp]
  01205	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01209	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168664
  01210	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01215	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168665
  0121c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01221	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01226	41 b9 03 00 00
	00		 mov	 r9d, 3
  0122c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168666
  01233	ba 86 04 00 00	 mov	 edx, 1158		; 00000486H
  01238	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168667
  0123f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1158 :                                 iarg + 1, argv[ iarg ], j );
; 1159 :                             return -1;

  01245	b8 ff ff ff ff	 mov	 eax, -1
  0124a	e9 9b 21 00 00	 jmp	 $LN1@printer_in
$LN44@printer_in:

; 1160 :                         }
; 1161 :                         dev->cctape[ line-1 ] |= 0x8000 >> (chan - 1);

  0124f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR line$5[rsp]
  01256	ff c8		 dec	 eax
  01258	48 98		 cdqe
  0125a	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR chan$4[rsp]
  01261	ff c9		 dec	 ecx
  01263	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  01268	d3 fa		 sar	 edx, cl
  0126a	8b ca		 mov	 ecx, edx
  0126c	48 8b 94 24 b0
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01274	0f b7 84 42 a0
	0b 00 00	 movzx	 eax, WORD PTR [rdx+rax*2+2976]
  0127c	0b c1		 or	 eax, ecx
  0127e	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR line$5[rsp]
  01285	ff c9		 dec	 ecx
  01287	48 63 c9	 movsxd	 rcx, ecx
  0128a	48 8b 94 24 b0
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01292	66 89 84 4a a0
	0b 00 00	 mov	 WORD PTR [rdx+rcx*2+2976], ax
$LN38@printer_in:

; 1162 :                     }
; 1163 :                     if ((ptr = nxt)[0] == ',')

  0129a	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  0129f	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax
  012a4	b8 01 00 00 00	 mov	 eax, 1
  012a9	48 6b c0 00	 imul	 rax, rax, 0
  012ad	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  012b2	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  012b6	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  012b9	75 0d		 jne	 SHORT $LN47@printer_in

; 1164 :                         ptr++; /* get past ',' to next line# */

  012bb	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  012c0	48 ff c0	 inc	 rax
  012c3	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax
$LN47@printer_in:

; 1165 : 
; 1166 :                 } /* while (ptr[0] && ptr[0] != ')') */

  012c8	e9 97 f8 ff ff	 jmp	 $LN8@printer_in
$LN9@printer_in:

; 1167 : 
; 1168 :                 /* Check for proper closing ')' found and nothing after it */
; 1169 :                 if (ptr[0] != ')' || (ptr += 1)[0] != 0)

  012cd	b8 01 00 00 00	 mov	 eax, 1
  012d2	48 6b c0 00	 imul	 rax, rax, 0
  012d6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  012db	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  012df	83 f8 29	 cmp	 eax, 41			; 00000029H
  012e2	75 27		 jne	 SHORT $LN49@printer_in
  012e4	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  012e9	48 ff c0	 inc	 rax
  012ec	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax
  012f1	b8 01 00 00 00	 mov	 eax, 1
  012f6	48 6b c0 00	 imul	 rax, rax, 0
  012fa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  012ff	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  01303	85 c0		 test	 eax, eax
  01305	0f 84 22 01 00
	00		 je	 $LN48@printer_in
$LN49@printer_in:

; 1170 :                 {
; 1171 :                     j = ptr+1 - argv[ iarg ];

  0130b	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  01310	48 ff c0	 inc	 rax
  01313	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  01318	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  01320	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  01324	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1172 :                     // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1173 :                     WRMSG( HHC01103, "E", LCSS_DEVNUM,

  01328	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01331	74 15		 je	 SHORT $LN138@printer_in
  01333	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0133b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0133f	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv716[rsp], eax
  01346	eb 0b		 jmp	 SHORT $LN139@printer_in
$LN138@printer_in:
  01348	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv716[rsp], 0
$LN139@printer_in:
  01353	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0135c	74 17		 je	 SHORT $LN140@printer_in
  0135e	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01366	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0136a	d1 f8		 sar	 eax, 1
  0136c	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv722[rsp], eax
  01373	eb 0b		 jmp	 SHORT $LN141@printer_in
$LN140@printer_in:
  01375	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv722[rsp], 0
$LN141@printer_in:
  01380	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  01385	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR tv707[rsp], rax
  0138d	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  01391	ff c1		 inc	 ecx
  01393	89 8c 24 b4 01
	00 00		 mov	 DWORD PTR tv711[rsp], ecx
  0139a	b9 01 00 00 00	 mov	 ecx, 1
  0139f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013a5	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  013a9	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  013ad	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  013b5	48 8b 94 24 30
	02 00 00	 mov	 rdx, QWORD PTR tv707[rsp]
  013bd	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  013c1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  013c6	8b 8c 24 b4 01
	00 00		 mov	 ecx, DWORD PTR tv711[rsp]
  013cd	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  013d1	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv716[rsp]
  013d8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  013dc	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv722[rsp]
  013e3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  013e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168671
  013ee	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  013f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168672
  013fa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  013ff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01404	41 b9 03 00 00
	00		 mov	 r9d, 3
  0140a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168673
  01411	ba 96 04 00 00	 mov	 edx, 1174		; 00000496H
  01416	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168674
  0141d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1174 :                         iarg + 1, argv[ iarg ], j );
; 1175 :                     return -1;

  01423	b8 ff ff ff ff	 mov	 eax, -1
  01428	e9 bd 1f 00 00	 jmp	 $LN1@printer_in
$LN48@printer_in:
$LN30@printer_in:

; 1176 :                 }
; 1177 :             }
; 1178 :             on_new_cctape( dev );

  0142d	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01435	e8 00 00 00 00	 call	 on_new_cctape

; 1179 :             continue;

  0143a	e9 ea f2 ff ff	 jmp	 $LN2@printer_in
$LN27@printer_in:

; 1180 :         } /* "cctape=" */
; 1181 : 
; 1182 :         if (strcasecmp( argv[ iarg ], "crlf" ) == 0)

  0143f	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  01444	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168676
  0144b	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  01453	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  01457	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0145d	85 c0		 test	 eax, eax
  0145f	75 24		 jne	 SHORT $LN50@printer_in

; 1183 :         {
; 1184 :             dev->crlf = 1;

  01461	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01469	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  0146f	83 c8 01	 or	 eax, 1
  01472	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0147a	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 1185 :             continue;

  01480	e9 a4 f2 ff ff	 jmp	 $LN2@printer_in
$LN50@printer_in:

; 1186 :         }
; 1187 : 
; 1188 :         if (strncasecmp( "fcb=", argv[ iarg ], 4 ) == 0)

  01485	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  0148a	41 b8 04 00 00
	00		 mov	 r8d, 4
  01490	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  01498	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0149c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168678
  014a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  014a9	85 c0		 test	 eax, eax
  014ab	0f 85 92 0e 00
	00		 jne	 $LN51@printer_in

; 1189 :         {
; 1190 :             int line, chan, found;
; 1191 :             if (dev->devtype == 0x1403)

  014b1	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014b9	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  014bd	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  014c2	0f 85 e9 00 00
	00		 jne	 $LN52@printer_in

; 1192 :             {
; 1193 :                 // HHC01109 "%1d:%04X Printer: option %s incompatible with device type %04X"
; 1194 :                 WRMSG( HHC01109, "E", LCSS_DEVNUM,

  014c8	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  014d1	74 15		 je	 SHORT $LN142@printer_in
  014d3	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014db	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  014df	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv762[rsp], eax
  014e6	eb 0b		 jmp	 SHORT $LN143@printer_in
$LN142@printer_in:
  014e8	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv762[rsp], 0
$LN143@printer_in:
  014f3	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  014fc	74 17		 je	 SHORT $LN144@printer_in
  014fe	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01506	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0150a	d1 f8		 sar	 eax, 1
  0150c	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv768[rsp], eax
  01513	eb 0b		 jmp	 SHORT $LN145@printer_in
$LN144@printer_in:
  01515	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv768[rsp], 0
$LN145@printer_in:
  01520	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01528	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0152c	89 84 24 b8 01
	00 00		 mov	 DWORD PTR tv756[rsp], eax
  01533	b9 01 00 00 00	 mov	 ecx, 1
  01538	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0153e	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR tv756[rsp]
  01545	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01549	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168680
  01550	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01555	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv762[rsp]
  0155c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01560	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv768[rsp]
  01567	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0156b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168681
  01572	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01577	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168682
  0157e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01583	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01588	41 b9 03 00 00
	00		 mov	 r9d, 3
  0158e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168683
  01595	ba ab 04 00 00	 mov	 edx, 1195		; 000004abH
  0159a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168684
  015a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1195 :                     "option 'fcb'", dev->devtype );
; 1196 :                 return -1;

  015a7	b8 ff ff ff ff	 mov	 eax, -1
  015ac	e9 39 1e 00 00	 jmp	 $LN1@printer_in
$LN52@printer_in:

; 1197 :             }
; 1198 :             memset( dev->fcb, 0, sizeof( dev->fcb ));

  015b1	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  015b9	48 05 94 07 00
	00		 add	 rax, 1940		; 00000794H
  015bf	48 8b f8	 mov	 rdi, rax
  015c2	33 c0		 xor	 eax, eax
  015c4	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  015c9	f3 aa		 rep stosb

; 1199 : 
; 1200 :             /*  "fcb=fcb=cc:ll,..."
; 1201 :                 "fcb=fcb=ppnn..."
; 1202 :                 "fcb=name"
; 1203 :             */
; 1204 :             /* check for new format */
; 1205 :             if (strstr( argv[ iarg ], ":" ))

  015cb	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  015d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168687
  015d7	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  015df	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  015e3	e8 00 00 00 00	 call	 strstr
  015e8	48 85 c0	 test	 rax, rax
  015eb	0f 84 f7 03 00
	00		 je	 $LN53@printer_in

; 1206 :             {
; 1207 :                 /* ':" found == new format ==> "fcb=cc:ll,..." */
; 1208 :                 ptr = argv[ iarg ] + 4; /* get past "fcb=" */

  015f1	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  015f6	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  015fe	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01602	48 83 c0 04	 add	 rax, 4
  01606	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax

; 1209 :                 dev->fcb[0] = dev->lpp;

  0160b	b8 04 00 00 00	 mov	 eax, 4
  01610	48 6b c0 00	 imul	 rax, rax, 0
  01614	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0161c	48 8b 94 24 b0
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01624	8b 92 90 07 00
	00		 mov	 edx, DWORD PTR [rdx+1936]
  0162a	89 94 01 94 07
	00 00		 mov	 DWORD PTR [rcx+rax+1940], edx
$LN12@printer_in:

; 1210 :                 while (*ptr)

  01631	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  01636	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01639	85 c0		 test	 eax, eax
  0163b	0f 84 a2 03 00
	00		 je	 $LN13@printer_in

; 1211 :                 {
; 1212 :                     // Parse channel number
; 1213 :                     errno = 0;

  01641	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01647	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1214 :                     chan = (int) strtoul( ptr, &nxt, 10 );

  0164d	41 b8 0a 00 00
	00		 mov	 r8d, 10
  01653	48 8d 54 24 78	 lea	 rdx, QWORD PTR nxt$[rsp]
  01658	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  0165d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  01663	89 84 24 88 00
	00 00		 mov	 DWORD PTR chan$3[rsp], eax

; 1215 :                     if (0
; 1216 :                         || errno != 0
; 1217 :                         || *nxt != ':'
; 1218 :                         || nxt == ptr
; 1219 :                         || chan < 0
; 1220 :                         || chan > 12

  0166a	33 c0		 xor	 eax, eax
  0166c	85 c0		 test	 eax, eax
  0166e	75 3c		 jne	 SHORT $LN56@printer_in
  01670	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01676	83 38 00	 cmp	 DWORD PTR [rax], 0
  01679	75 31		 jne	 SHORT $LN56@printer_in
  0167b	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  01680	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01683	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  01686	75 24		 jne	 SHORT $LN56@printer_in
  01688	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  0168d	48 39 44 24 78	 cmp	 QWORD PTR nxt$[rsp], rax
  01692	74 18		 je	 SHORT $LN56@printer_in
  01694	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR chan$3[rsp], 0
  0169c	7c 0e		 jl	 SHORT $LN56@printer_in
  0169e	83 bc 24 88 00
	00 00 0c	 cmp	 DWORD PTR chan$3[rsp], 12
  016a6	0f 8e 22 01 00
	00		 jle	 $LN55@printer_in
$LN56@printer_in:

; 1221 :                     )
; 1222 :                     {
; 1223 :                         j = ptr+1 - argv[ iarg ];

  016ac	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  016b1	48 ff c0	 inc	 rax
  016b4	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  016b9	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  016c1	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  016c5	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1224 :                         // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1225 :                         WRMSG( HHC01103, "E", LCSS_DEVNUM,

  016c9	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  016d2	74 15		 je	 SHORT $LN146@printer_in
  016d4	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  016dc	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  016e0	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv830[rsp], eax
  016e7	eb 0b		 jmp	 SHORT $LN147@printer_in
$LN146@printer_in:
  016e9	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv830[rsp], 0
$LN147@printer_in:
  016f4	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  016fd	74 17		 je	 SHORT $LN148@printer_in
  016ff	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01707	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0170b	d1 f8		 sar	 eax, 1
  0170d	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv836[rsp], eax
  01714	eb 0b		 jmp	 SHORT $LN149@printer_in
$LN148@printer_in:
  01716	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv836[rsp], 0
$LN149@printer_in:
  01721	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  01726	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR tv821[rsp], rax
  0172e	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  01732	ff c1		 inc	 ecx
  01734	89 8c 24 bc 01
	00 00		 mov	 DWORD PTR tv825[rsp], ecx
  0173b	b9 01 00 00 00	 mov	 ecx, 1
  01740	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01746	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  0174a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0174e	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  01756	48 8b 94 24 38
	02 00 00	 mov	 rdx, QWORD PTR tv821[rsp]
  0175e	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  01762	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01767	8b 8c 24 bc 01
	00 00		 mov	 ecx, DWORD PTR tv825[rsp]
  0176e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01772	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv830[rsp]
  01779	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0177d	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv836[rsp]
  01784	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01788	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168690
  0178f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01794	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168691
  0179b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  017a0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  017a5	41 b9 03 00 00
	00		 mov	 r9d, 3
  017ab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168692
  017b2	ba ca 04 00 00	 mov	 edx, 1226		; 000004caH
  017b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168693
  017be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1226 :                             iarg + 1, argv[ iarg ], j );
; 1227 :                         return -1;

  017c4	b8 ff ff ff ff	 mov	 eax, -1
  017c9	e9 1c 1c 00 00	 jmp	 $LN1@printer_in
$LN55@printer_in:

; 1228 :                     }
; 1229 : 
; 1230 :                     ptr = nxt + 1;  // (next token)

  017ce	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  017d3	48 ff c0	 inc	 rax
  017d6	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax

; 1231 : 
; 1232 :                     // Parse line number
; 1233 :                     errno = 0;

  017db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  017e1	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1234 :                     line = (int) strtoul( ptr, &nxt, 10 );

  017e7	41 b8 0a 00 00
	00		 mov	 r8d, 10
  017ed	48 8d 54 24 78	 lea	 rdx, QWORD PTR nxt$[rsp]
  017f2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  017f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  017fd	89 84 24 84 00
	00 00		 mov	 DWORD PTR line$2[rsp], eax

; 1235 :                     if (0
; 1236 :                         || errno != 0
; 1237 :                         || (*nxt != ',' && *nxt != 0)
; 1238 :                         || nxt == ptr
; 1239 :                         || line < 0
; 1240 :                         || line > dev->lpp
; 1241 :                         || dev->fcb[ line ] != 0

  01804	33 c0		 xor	 eax, eax
  01806	85 c0		 test	 eax, eax
  01808	75 6f		 jne	 SHORT $LN58@printer_in
  0180a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01810	83 38 00	 cmp	 DWORD PTR [rax], 0
  01813	75 64		 jne	 SHORT $LN58@printer_in
  01815	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  0181a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0181d	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  01820	74 0c		 je	 SHORT $LN59@printer_in
  01822	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  01827	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0182a	85 c0		 test	 eax, eax
  0182c	75 4b		 jne	 SHORT $LN58@printer_in
$LN59@printer_in:
  0182e	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  01833	48 39 44 24 78	 cmp	 QWORD PTR nxt$[rsp], rax
  01838	74 3f		 je	 SHORT $LN58@printer_in
  0183a	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR line$2[rsp], 0
  01842	7c 35		 jl	 SHORT $LN58@printer_in
  01844	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0184c	8b 80 90 07 00
	00		 mov	 eax, DWORD PTR [rax+1936]
  01852	39 84 24 84 00
	00 00		 cmp	 DWORD PTR line$2[rsp], eax
  01859	7f 1e		 jg	 SHORT $LN58@printer_in
  0185b	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR line$2[rsp]
  01863	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0186b	83 bc 81 94 07
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+1940], 0
  01873	0f 84 22 01 00
	00		 je	 $LN57@printer_in
$LN58@printer_in:

; 1242 :                     )
; 1243 :                     {
; 1244 :                         j = ptr+1 - argv[ iarg ];

  01879	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  0187e	48 ff c0	 inc	 rax
  01881	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  01886	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0188e	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  01892	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1245 :                         // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1246 :                         WRMSG( HHC01103, "E", LCSS_DEVNUM,

  01896	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0189f	74 15		 je	 SHORT $LN150@printer_in
  018a1	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  018a9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  018ad	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv885[rsp], eax
  018b4	eb 0b		 jmp	 SHORT $LN151@printer_in
$LN150@printer_in:
  018b6	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv885[rsp], 0
$LN151@printer_in:
  018c1	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  018ca	74 17		 je	 SHORT $LN152@printer_in
  018cc	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  018d4	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  018d8	d1 f8		 sar	 eax, 1
  018da	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv891[rsp], eax
  018e1	eb 0b		 jmp	 SHORT $LN153@printer_in
$LN152@printer_in:
  018e3	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv891[rsp], 0
$LN153@printer_in:
  018ee	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  018f3	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR tv876[rsp], rax
  018fb	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  018ff	ff c1		 inc	 ecx
  01901	89 8c 24 c0 01
	00 00		 mov	 DWORD PTR tv880[rsp], ecx
  01908	b9 01 00 00 00	 mov	 ecx, 1
  0190d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01913	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  01917	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0191b	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  01923	48 8b 94 24 40
	02 00 00	 mov	 rdx, QWORD PTR tv876[rsp]
  0192b	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0192f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01934	8b 8c 24 c0 01
	00 00		 mov	 ecx, DWORD PTR tv880[rsp]
  0193b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0193f	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv885[rsp]
  01946	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0194a	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv891[rsp]
  01951	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01955	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168697
  0195c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01961	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168698
  01968	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0196d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01972	41 b9 03 00 00
	00		 mov	 r9d, 3
  01978	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168699
  0197f	ba df 04 00 00	 mov	 edx, 1247		; 000004dfH
  01984	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168700
  0198b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1247 :                             iarg + 1, argv[ iarg ], j );
; 1248 :                         return -1;

  01991	b8 ff ff ff ff	 mov	 eax, -1
  01996	e9 4f 1a 00 00	 jmp	 $LN1@printer_in
$LN57@printer_in:

; 1249 :                     }
; 1250 : 
; 1251 :                     /* Register channel in FCB only if it's being defined */
; 1252 :                     if (line)

  0199b	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR line$2[rsp], 0
  019a3	74 1e		 je	 SHORT $LN60@printer_in

; 1253 :                         dev->fcb[ line ] = chan;

  019a5	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR line$2[rsp]
  019ad	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  019b5	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR chan$3[rsp]
  019bc	89 94 81 94 07
	00 00		 mov	 DWORD PTR [rcx+rax*4+1940], edx
$LN60@printer_in:

; 1254 : 
; 1255 :                     // Are we done parsing yet?
; 1256 :                     if (*nxt == 0)

  019c3	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  019c8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  019cb	85 c0		 test	 eax, eax
  019cd	75 02		 jne	 SHORT $LN61@printer_in

; 1257 :                         break;

  019cf	eb 12		 jmp	 SHORT $LN13@printer_in
$LN61@printer_in:

; 1258 : 
; 1259 :                     ptr = nxt + 1;  // (next token)

  019d1	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  019d6	48 ff c0	 inc	 rax
  019d9	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax

; 1260 :                 }

  019de	e9 4e fc ff ff	 jmp	 $LN12@printer_in
$LN13@printer_in:

; 1261 :             }

  019e3	e9 49 09 00 00	 jmp	 $LN54@printer_in
$LN53@printer_in:

; 1262 :             else
; 1263 :             {
; 1264 :                 /* ':" NOT found. old format or fcb name */
; 1265 :                 char c;
; 1266 :                 ptr = argv[ iarg ] + 4; /* get past "fcb=" */

  019e8	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  019ed	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  019f5	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  019f9	48 83 c0 04	 add	 rax, 4
  019fd	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax

; 1267 :                 if (strlen( ptr ) != 26 || !isdigit( *ptr ))

  01a02	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  01a07	e8 00 00 00 00	 call	 strlen
  01a0c	48 83 f8 1a	 cmp	 rax, 26
  01a10	75 18		 jne	 SHORT $LN64@printer_in
  01a12	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  01a17	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01a1a	8b c8		 mov	 ecx, eax
  01a1c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  01a22	85 c0		 test	 eax, eax
  01a24	0f 85 83 02 00
	00		 jne	 $LN62@printer_in
$LN64@printer_in:

; 1268 :                 {
; 1269 :                     /* It doesn't appear they're defining a custom
; 1270 :                        fcb. See if they gave us an fcb name instead.
; 1271 :                     */
; 1272 :                     FCBTAB* table = fcbtab;

  01a2a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:fcbtab
  01a31	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR table$9[rsp], rax

; 1273 : 
; 1274 :                     for (i=0, found=0; i < (int) _countof( fcbtab ); i++)

  01a39	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  01a44	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR found$7[rsp], 0
  01a4f	eb 10		 jmp	 SHORT $LN16@printer_in
$LN14@printer_in:
  01a51	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01a58	ff c0		 inc	 eax
  01a5a	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN16@printer_in:
  01a61	83 bc 24 80 00
	00 00 07	 cmp	 DWORD PTR i$[rsp], 7
  01a69	0f 8d e3 00 00
	00		 jge	 $LN15@printer_in

; 1275 :                     {
; 1276 :                         if (FCBTYPE_FCB != table[i].type)

  01a6f	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  01a77	48 6b c0 18	 imul	 rax, rax, 24
  01a7b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR table$9[rsp]
  01a83	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01a87	85 c0		 test	 eax, eax
  01a89	74 02		 je	 SHORT $LN65@printer_in

; 1277 :                             continue;

  01a8b	eb c4		 jmp	 SHORT $LN14@printer_in
$LN65@printer_in:

; 1278 : 
; 1279 :                         /* Is this the one they want? */
; 1280 :                         if (strcasecmp( table[i].name, ptr ) == 0)

  01a8d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  01a95	48 6b c0 18	 imul	 rax, rax, 24
  01a99	48 8b 54 24 68	 mov	 rdx, QWORD PTR ptr$[rsp]
  01a9e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR table$9[rsp]
  01aa6	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  01aab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  01ab1	85 c0		 test	 eax, eax
  01ab3	0f 85 94 00 00
	00		 jne	 $LN66@printer_in

; 1281 :                         {
; 1282 :                             found = 1;

  01ab9	c7 84 24 fc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR found$7[rsp], 1

; 1283 :                             memcpy( dev->fcb, table[i].image, sizeof( dev->fcb ));

  01ac4	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  01acc	48 6b c0 18	 imul	 rax, rax, 24
  01ad0	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR table$9[rsp]
  01ad8	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  01add	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01ae5	48 8d b9 94 07
	00 00		 lea	 rdi, QWORD PTR [rcx+1940]
  01aec	48 8b f0	 mov	 rsi, rax
  01aef	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  01af4	f3 a4		 rep movsb

; 1284 :                             if (dev->fcbname) free( dev->fcbname );

  01af6	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01afe	48 83 b8 98 0b
	00 00 00	 cmp	 QWORD PTR [rax+2968], 0
  01b06	74 15		 je	 SHORT $LN67@printer_in
  01b08	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b10	48 8b 88 98 0b
	00 00		 mov	 rcx, QWORD PTR [rax+2968]
  01b17	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN67@printer_in:

; 1285 :                             dev->fcbname = strdup( table[i].name );

  01b1d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  01b25	48 6b c0 18	 imul	 rax, rax, 24
  01b29	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR table$9[rsp]
  01b31	48 8b 4c 01 08	 mov	 rcx, QWORD PTR [rcx+rax+8]
  01b36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  01b3c	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01b44	48 89 81 98 0b
	00 00		 mov	 QWORD PTR [rcx+2968], rax

; 1286 :                             break;

  01b4b	eb 05		 jmp	 SHORT $LN15@printer_in
$LN66@printer_in:

; 1287 :                         }
; 1288 :                     }

  01b4d	e9 ff fe ff ff	 jmp	 $LN14@printer_in
$LN15@printer_in:

; 1289 :                     if (!found)

  01b52	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR found$7[rsp], 0
  01b5a	0f 85 22 01 00
	00		 jne	 $LN68@printer_in

; 1290 :                     {
; 1291 :                         j = ptr+1 - argv[iarg];

  01b60	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  01b65	48 ff c0	 inc	 rax
  01b68	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  01b6d	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  01b75	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  01b79	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1292 :                         // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1293 :                         WRMSG( HHC01103, "E", LCSS_DEVNUM,

  01b7d	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01b86	74 15		 je	 SHORT $LN154@printer_in
  01b88	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b90	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01b94	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv978[rsp], eax
  01b9b	eb 0b		 jmp	 SHORT $LN155@printer_in
$LN154@printer_in:
  01b9d	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv978[rsp], 0
$LN155@printer_in:
  01ba8	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01bb1	74 17		 je	 SHORT $LN156@printer_in
  01bb3	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01bbb	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01bbf	d1 f8		 sar	 eax, 1
  01bc1	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv984[rsp], eax
  01bc8	eb 0b		 jmp	 SHORT $LN157@printer_in
$LN156@printer_in:
  01bca	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv984[rsp], 0
$LN157@printer_in:
  01bd5	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  01bda	48 89 84 24 48
	02 00 00	 mov	 QWORD PTR tv969[rsp], rax
  01be2	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  01be6	ff c1		 inc	 ecx
  01be8	89 8c 24 c4 01
	00 00		 mov	 DWORD PTR tv973[rsp], ecx
  01bef	b9 01 00 00 00	 mov	 ecx, 1
  01bf4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01bfa	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  01bfe	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  01c02	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  01c0a	48 8b 94 24 48
	02 00 00	 mov	 rdx, QWORD PTR tv969[rsp]
  01c12	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  01c16	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01c1b	8b 8c 24 c4 01
	00 00		 mov	 ecx, DWORD PTR tv973[rsp]
  01c22	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01c26	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv978[rsp]
  01c2d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01c31	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv984[rsp]
  01c38	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01c3c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168710
  01c43	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01c48	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168711
  01c4f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01c54	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01c59	41 b9 03 00 00
	00		 mov	 r9d, 3
  01c5f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168712
  01c66	ba 0e 05 00 00	 mov	 edx, 1294		; 0000050eH
  01c6b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168713
  01c72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1294 :                             iarg + 1, argv[ iarg ], j );
; 1295 :                         return -1;

  01c78	b8 ff ff ff ff	 mov	 eax, -1
  01c7d	e9 68 17 00 00	 jmp	 $LN1@printer_in
$LN68@printer_in:

; 1296 :                     }
; 1297 :                     dev->lpp = dev->fcb[0];

  01c82	b8 04 00 00 00	 mov	 eax, 4
  01c87	48 6b c0 00	 imul	 rax, rax, 0
  01c8b	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01c93	48 8b 94 24 b0
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01c9b	8b 84 02 94 07
	00 00		 mov	 eax, DWORD PTR [rdx+rax+1940]
  01ca2	89 81 90 07 00
	00		 mov	 DWORD PTR [rcx+1936], eax

; 1298 :                 }

  01ca8	e9 84 06 00 00	 jmp	 $LN63@printer_in
$LN62@printer_in:

; 1299 :                 else
; 1300 :                 {
; 1301 :                     /* old format ==> "fcb=66010713192531374361495561" */
; 1302 :                     errno = 0;

  01cad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01cb3	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1303 :                     c = ptr[2];

  01cb9	b8 01 00 00 00	 mov	 eax, 1
  01cbe	48 6b c0 02	 imul	 rax, rax, 2
  01cc2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  01cc7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01ccb	88 44 24 75	 mov	 BYTE PTR c$1[rsp], al

; 1304 :                     ptr[2] = 0;

  01ccf	b8 01 00 00 00	 mov	 eax, 1
  01cd4	48 6b c0 02	 imul	 rax, rax, 2
  01cd8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  01cdd	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1305 :                     dev->lpp = (int) strtoul( ptr, &nxt, 10 );

  01ce1	41 b8 0a 00 00
	00		 mov	 r8d, 10
  01ce7	48 8d 54 24 78	 lea	 rdx, QWORD PTR nxt$[rsp]
  01cec	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  01cf1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  01cf7	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01cff	89 81 90 07 00
	00		 mov	 DWORD PTR [rcx+1936], eax

; 1306 :                     ptr[2] = c;

  01d05	b8 01 00 00 00	 mov	 eax, 1
  01d0a	48 6b c0 02	 imul	 rax, rax, 2
  01d0e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  01d13	0f b6 54 24 75	 movzx	 edx, BYTE PTR c$1[rsp]
  01d18	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1307 :                     if (0
; 1308 :                         || errno != 0
; 1309 :                         || nxt != (ptr+2)
; 1310 :                         || dev->lpp < 1
; 1311 :                         || dev->lpp > fcbsize

  01d1b	33 c0		 xor	 eax, eax
  01d1d	85 c0		 test	 eax, eax
  01d1f	75 47		 jne	 SHORT $LN70@printer_in
  01d21	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01d27	83 38 00	 cmp	 DWORD PTR [rax], 0
  01d2a	75 3c		 jne	 SHORT $LN70@printer_in
  01d2c	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  01d31	48 83 c0 02	 add	 rax, 2
  01d35	48 39 44 24 78	 cmp	 QWORD PTR nxt$[rsp], rax
  01d3a	75 2c		 jne	 SHORT $LN70@printer_in
  01d3c	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01d44	83 b8 90 07 00
	00 01		 cmp	 DWORD PTR [rax+1936], 1
  01d4b	7c 1b		 jl	 SHORT $LN70@printer_in
  01d4d	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01d55	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR fcbsize$[rsp]
  01d5c	39 88 90 07 00
	00		 cmp	 DWORD PTR [rax+1936], ecx
  01d62	0f 8e 22 01 00
	00		 jle	 $LN69@printer_in
$LN70@printer_in:

; 1312 :                     )
; 1313 :                     {
; 1314 :                         j = ptr+1 - argv[iarg];

  01d68	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  01d6d	48 ff c0	 inc	 rax
  01d70	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  01d75	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  01d7d	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  01d81	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1315 :                         // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1316 :                         WRMSG( HHC01103, "E", LCSS_DEVNUM,

  01d85	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01d8e	74 15		 je	 SHORT $LN158@printer_in
  01d90	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01d98	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01d9c	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv1068[rsp], eax
  01da3	eb 0b		 jmp	 SHORT $LN159@printer_in
$LN158@printer_in:
  01da5	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1068[rsp], 0
$LN159@printer_in:
  01db0	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01db9	74 17		 je	 SHORT $LN160@printer_in
  01dbb	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01dc3	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01dc7	d1 f8		 sar	 eax, 1
  01dc9	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv1074[rsp], eax
  01dd0	eb 0b		 jmp	 SHORT $LN161@printer_in
$LN160@printer_in:
  01dd2	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1074[rsp], 0
$LN161@printer_in:
  01ddd	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  01de2	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR tv1059[rsp], rax
  01dea	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  01dee	ff c1		 inc	 ecx
  01df0	89 8c 24 c8 01
	00 00		 mov	 DWORD PTR tv1063[rsp], ecx
  01df7	b9 01 00 00 00	 mov	 ecx, 1
  01dfc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01e02	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  01e06	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  01e0a	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  01e12	48 8b 94 24 50
	02 00 00	 mov	 rdx, QWORD PTR tv1059[rsp]
  01e1a	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  01e1e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01e23	8b 8c 24 c8 01
	00 00		 mov	 ecx, DWORD PTR tv1063[rsp]
  01e2a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01e2e	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv1068[rsp]
  01e35	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01e39	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv1074[rsp]
  01e40	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01e44	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168716
  01e4b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01e50	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168717
  01e57	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01e5c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e61	41 b9 03 00 00
	00		 mov	 r9d, 3
  01e67	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168718
  01e6e	ba 25 05 00 00	 mov	 edx, 1317		; 00000525H
  01e73	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168719
  01e7a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1317 :                             iarg + 1, argv[ iarg ], j );
; 1318 :                         return -1;

  01e80	b8 ff ff ff ff	 mov	 eax, -1
  01e85	e9 60 15 00 00	 jmp	 $LN1@printer_in
$LN69@printer_in:

; 1319 :                     }
; 1320 :                     dev->fcb[0] = dev->lpp;

  01e8a	b8 04 00 00 00	 mov	 eax, 4
  01e8f	48 6b c0 00	 imul	 rax, rax, 0
  01e93	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01e9b	48 8b 94 24 b0
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01ea3	8b 92 90 07 00
	00		 mov	 edx, DWORD PTR [rdx+1936]
  01ea9	89 94 01 94 07
	00 00		 mov	 DWORD PTR [rcx+rax+1940], edx

; 1321 :                     chan = 0;

  01eb0	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR chan$3[rsp], 0

; 1322 :                     for (ptr += 2; c; ptr += 2)

  01ebb	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  01ec0	48 83 c0 02	 add	 rax, 2
  01ec4	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax
  01ec9	eb 0e		 jmp	 SHORT $LN19@printer_in
$LN17@printer_in:
  01ecb	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  01ed0	48 83 c0 02	 add	 rax, 2
  01ed4	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax
$LN19@printer_in:
  01ed9	0f be 44 24 75	 movsx	 eax, BYTE PTR c$1[rsp]
  01ede	85 c0		 test	 eax, eax
  01ee0	0f 84 30 03 00
	00		 je	 $LN18@printer_in

; 1323 :                     {
; 1324 :                         c = ptr[2];

  01ee6	b8 01 00 00 00	 mov	 eax, 1
  01eeb	48 6b c0 02	 imul	 rax, rax, 2
  01eef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  01ef4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01ef8	88 44 24 75	 mov	 BYTE PTR c$1[rsp], al

; 1325 :                         ptr[2] = 0;

  01efc	b8 01 00 00 00	 mov	 eax, 1
  01f01	48 6b c0 02	 imul	 rax, rax, 2
  01f05	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  01f0a	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1326 :                         line = (int) strtoul( ptr, &nxt, 10 );

  01f0e	41 b8 0a 00 00
	00		 mov	 r8d, 10
  01f14	48 8d 54 24 78	 lea	 rdx, QWORD PTR nxt$[rsp]
  01f19	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  01f1e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  01f24	89 84 24 84 00
	00 00		 mov	 DWORD PTR line$2[rsp], eax

; 1327 :                         ptr[2] = c;

  01f2b	b8 01 00 00 00	 mov	 eax, 1
  01f30	48 6b c0 02	 imul	 rax, rax, 2
  01f34	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  01f39	0f b6 54 24 75	 movzx	 edx, BYTE PTR c$1[rsp]
  01f3e	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 1328 :                         if (0
; 1329 :                             || errno != 0
; 1330 :                             || nxt != (ptr+2)
; 1331 :                             || line < 0
; 1332 :                             || line > dev->lpp

  01f41	33 c0		 xor	 eax, eax
  01f43	85 c0		 test	 eax, eax
  01f45	75 40		 jne	 SHORT $LN72@printer_in
  01f47	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01f4d	83 38 00	 cmp	 DWORD PTR [rax], 0
  01f50	75 35		 jne	 SHORT $LN72@printer_in
  01f52	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  01f57	48 83 c0 02	 add	 rax, 2
  01f5b	48 39 44 24 78	 cmp	 QWORD PTR nxt$[rsp], rax
  01f60	75 25		 jne	 SHORT $LN72@printer_in
  01f62	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR line$2[rsp], 0
  01f6a	7c 1b		 jl	 SHORT $LN72@printer_in
  01f6c	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01f74	8b 80 90 07 00
	00		 mov	 eax, DWORD PTR [rax+1936]
  01f7a	39 84 24 84 00
	00 00		 cmp	 DWORD PTR line$2[rsp], eax
  01f81	0f 8e 22 01 00
	00		 jle	 $LN71@printer_in
$LN72@printer_in:

; 1333 :                         )
; 1334 :                         {
; 1335 :                             j = ptr+1 - argv[ iarg ];

  01f87	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  01f8c	48 ff c0	 inc	 rax
  01f8f	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  01f94	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  01f9c	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  01fa0	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1336 :                             // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1337 :                             WRMSG( HHC01103, "E", LCSS_DEVNUM,

  01fa4	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01fad	74 15		 je	 SHORT $LN162@printer_in
  01faf	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01fb7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01fbb	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv1127[rsp], eax
  01fc2	eb 0b		 jmp	 SHORT $LN163@printer_in
$LN162@printer_in:
  01fc4	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1127[rsp], 0
$LN163@printer_in:
  01fcf	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01fd8	74 17		 je	 SHORT $LN164@printer_in
  01fda	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01fe2	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01fe6	d1 f8		 sar	 eax, 1
  01fe8	89 84 24 14 01
	00 00		 mov	 DWORD PTR tv1133[rsp], eax
  01fef	eb 0b		 jmp	 SHORT $LN165@printer_in
$LN164@printer_in:
  01ff1	c7 84 24 14 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1133[rsp], 0
$LN165@printer_in:
  01ffc	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  02001	48 89 84 24 58
	02 00 00	 mov	 QWORD PTR tv1118[rsp], rax
  02009	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  0200d	ff c1		 inc	 ecx
  0200f	89 8c 24 cc 01
	00 00		 mov	 DWORD PTR tv1122[rsp], ecx
  02016	b9 01 00 00 00	 mov	 ecx, 1
  0201b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02021	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  02025	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  02029	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  02031	48 8b 94 24 58
	02 00 00	 mov	 rdx, QWORD PTR tv1118[rsp]
  02039	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0203d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  02042	8b 8c 24 cc 01
	00 00		 mov	 ecx, DWORD PTR tv1122[rsp]
  02049	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0204d	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv1127[rsp]
  02054	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02058	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR tv1133[rsp]
  0205f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168722
  0206a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0206f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168723
  02076	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0207b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02080	41 b9 03 00 00
	00		 mov	 r9d, 3
  02086	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168724
  0208d	ba 3a 05 00 00	 mov	 edx, 1338		; 0000053aH
  02092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168725
  02099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1338 :                                 iarg + 1, argv[ iarg ], j );
; 1339 :                             return -1;

  0209f	b8 ff ff ff ff	 mov	 eax, -1
  020a4	e9 41 13 00 00	 jmp	 $LN1@printer_in
$LN71@printer_in:

; 1340 :                         }
; 1341 :                         chan += 1;

  020a9	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR chan$3[rsp]
  020b0	ff c0		 inc	 eax
  020b2	89 84 24 88 00
	00 00		 mov	 DWORD PTR chan$3[rsp], eax

; 1342 :                         if (chan > 12)

  020b9	83 bc 24 88 00
	00 00 0c	 cmp	 DWORD PTR chan$3[rsp], 12
  020c1	0f 8e 22 01 00
	00		 jle	 $LN73@printer_in

; 1343 :                         {
; 1344 :                             j = ptr+1 - argv[ iarg ];

  020c7	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  020cc	48 ff c0	 inc	 rax
  020cf	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  020d4	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  020dc	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  020e0	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1345 :                             // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1346 :                             WRMSG( HHC01103, "E", LCSS_DEVNUM,

  020e4	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  020ed	74 15		 je	 SHORT $LN166@printer_in
  020ef	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  020f7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  020fb	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv1162[rsp], eax
  02102	eb 0b		 jmp	 SHORT $LN167@printer_in
$LN166@printer_in:
  02104	c7 84 24 18 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1162[rsp], 0
$LN167@printer_in:
  0210f	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02118	74 17		 je	 SHORT $LN168@printer_in
  0211a	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02122	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02126	d1 f8		 sar	 eax, 1
  02128	89 84 24 1c 01
	00 00		 mov	 DWORD PTR tv1168[rsp], eax
  0212f	eb 0b		 jmp	 SHORT $LN169@printer_in
$LN168@printer_in:
  02131	c7 84 24 1c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1168[rsp], 0
$LN169@printer_in:
  0213c	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  02141	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR tv1153[rsp], rax
  02149	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  0214d	ff c1		 inc	 ecx
  0214f	89 8c 24 d0 01
	00 00		 mov	 DWORD PTR tv1157[rsp], ecx
  02156	b9 01 00 00 00	 mov	 ecx, 1
  0215b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02161	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  02165	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  02169	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  02171	48 8b 94 24 60
	02 00 00	 mov	 rdx, QWORD PTR tv1153[rsp]
  02179	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0217d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  02182	8b 8c 24 d0 01
	00 00		 mov	 ecx, DWORD PTR tv1157[rsp]
  02189	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0218d	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR tv1162[rsp]
  02194	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02198	8b 8c 24 1c 01
	00 00		 mov	 ecx, DWORD PTR tv1168[rsp]
  0219f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  021a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168727
  021aa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  021af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168728
  021b6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  021bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  021c0	41 b9 03 00 00
	00		 mov	 r9d, 3
  021c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168729
  021cd	ba 43 05 00 00	 mov	 edx, 1347		; 00000543H
  021d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168730
  021d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1347 :                                 iarg + 1, argv[ iarg ], j );
; 1348 :                             return -1;

  021df	b8 ff ff ff ff	 mov	 eax, -1
  021e4	e9 01 12 00 00	 jmp	 $LN1@printer_in
$LN73@printer_in:

; 1349 :                         }
; 1350 : 
; 1351 :                         /* Register channel in FCB only if it's being defined */
; 1352 :                         if (line)

  021e9	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR line$2[rsp], 0
  021f1	74 1e		 je	 SHORT $LN74@printer_in

; 1353 :                             dev->fcb[line] = chan;

  021f3	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR line$2[rsp]
  021fb	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02203	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR chan$3[rsp]
  0220a	89 94 81 94 07
	00 00		 mov	 DWORD PTR [rcx+rax*4+1940], edx
$LN74@printer_in:

; 1354 :                     }

  02211	e9 b5 fc ff ff	 jmp	 $LN17@printer_in
$LN18@printer_in:

; 1355 :                     if (chan != 12)

  02216	83 bc 24 88 00
	00 00 0c	 cmp	 DWORD PTR chan$3[rsp], 12
  0221e	0f 84 0d 01 00
	00		 je	 $LN75@printer_in

; 1356 :                     {
; 1357 :                         j = 5;

  02224	c7 44 24 70 05
	00 00 00	 mov	 DWORD PTR j$[rsp], 5

; 1358 :                         // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1359 :                         WRMSG( HHC01103, "E", LCSS_DEVNUM,

  0222c	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02235	74 15		 je	 SHORT $LN170@printer_in
  02237	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0223f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02243	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv1195[rsp], eax
  0224a	eb 0b		 jmp	 SHORT $LN171@printer_in
$LN170@printer_in:
  0224c	c7 84 24 20 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1195[rsp], 0
$LN171@printer_in:
  02257	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02260	74 17		 je	 SHORT $LN172@printer_in
  02262	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0226a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0226e	d1 f8		 sar	 eax, 1
  02270	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv1201[rsp], eax
  02277	eb 0b		 jmp	 SHORT $LN173@printer_in
$LN172@printer_in:
  02279	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1201[rsp], 0
$LN173@printer_in:
  02284	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  02289	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR tv1186[rsp], rax
  02291	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  02295	ff c1		 inc	 ecx
  02297	89 8c 24 d4 01
	00 00		 mov	 DWORD PTR tv1190[rsp], ecx
  0229e	b9 01 00 00 00	 mov	 ecx, 1
  022a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  022a9	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  022ad	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  022b1	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  022b9	48 8b 94 24 68
	02 00 00	 mov	 rdx, QWORD PTR tv1186[rsp]
  022c1	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  022c5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  022ca	8b 8c 24 d4 01
	00 00		 mov	 ecx, DWORD PTR tv1190[rsp]
  022d1	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  022d5	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv1195[rsp]
  022dc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  022e0	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR tv1201[rsp]
  022e7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  022eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168733
  022f2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  022f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168734
  022fe	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02303	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02308	41 b9 03 00 00
	00		 mov	 r9d, 3
  0230e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168735
  02315	ba 50 05 00 00	 mov	 edx, 1360		; 00000550H
  0231a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168736
  02321	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1360 :                             iarg + 1, argv[ iarg ], j );
; 1361 :                         return -1;

  02327	b8 ff ff ff ff	 mov	 eax, -1
  0232c	e9 b9 10 00 00	 jmp	 $LN1@printer_in
$LN75@printer_in:
$LN63@printer_in:
$LN54@printer_in:

; 1362 :                     }
; 1363 :                 }
; 1364 :             }
; 1365 :             on_new_fcb( dev );

  02331	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02339	e8 00 00 00 00	 call	 on_new_fcb

; 1366 :             continue;

  0233e	e9 e6 e3 ff ff	 jmp	 $LN2@printer_in
$LN51@printer_in:

; 1367 :         } /* "fcb=" */
; 1368 : 
; 1369 :         /* (DEPRECATED!) */
; 1370 :         if (strcasecmp( argv[ iarg ], "fcbcheck" ) == 0)

  02343	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  02348	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168738
  0234f	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  02357	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0235b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  02361	85 c0		 test	 eax, eax
  02363	0f 85 f1 01 00
	00		 jne	 $LN76@printer_in

; 1371 :         {
; 1372 :             if (dev->devtype == 0x1403)

  02369	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02371	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  02375	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  0237a	0f 85 e9 00 00
	00		 jne	 $LN77@printer_in

; 1373 :             {
; 1374 :                 // HHC01109 "%1d:%04X Printer: option %s incompatible with device type %04X"
; 1375 :                 WRMSG( HHC01109, "E", LCSS_DEVNUM,

  02380	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02389	74 15		 je	 SHORT $LN174@printer_in
  0238b	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02393	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02397	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv1230[rsp], eax
  0239e	eb 0b		 jmp	 SHORT $LN175@printer_in
$LN174@printer_in:
  023a0	c7 84 24 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1230[rsp], 0
$LN175@printer_in:
  023ab	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  023b4	74 17		 je	 SHORT $LN176@printer_in
  023b6	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  023be	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  023c2	d1 f8		 sar	 eax, 1
  023c4	89 84 24 2c 01
	00 00		 mov	 DWORD PTR tv1236[rsp], eax
  023cb	eb 0b		 jmp	 SHORT $LN177@printer_in
$LN176@printer_in:
  023cd	c7 84 24 2c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1236[rsp], 0
$LN177@printer_in:
  023d8	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  023e0	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  023e4	89 84 24 d8 01
	00 00		 mov	 DWORD PTR tv1224[rsp], eax
  023eb	b9 01 00 00 00	 mov	 ecx, 1
  023f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  023f6	8b 8c 24 d8 01
	00 00		 mov	 ecx, DWORD PTR tv1224[rsp]
  023fd	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  02401	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168740
  02408	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0240d	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv1230[rsp]
  02414	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02418	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR tv1236[rsp]
  0241f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02423	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168741
  0242a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0242f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168742
  02436	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0243b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02440	41 b9 03 00 00
	00		 mov	 r9d, 3
  02446	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168743
  0244d	ba 60 05 00 00	 mov	 edx, 1376		; 00000560H
  02452	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168744
  02459	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1376 :                     "option 'fcbcheck'", dev->devtype );
; 1377 :                 return -1;

  0245f	b8 ff ff ff ff	 mov	 eax, -1
  02464	e9 81 0f 00 00	 jmp	 $LN1@printer_in
$LN77@printer_in:

; 1378 :             }
; 1379 : 
; 1380 :             // "%1d:%04X %s: option '%s' has been deprecated"
; 1381 :             WRMSG( HHC01251, "W", LCSS_DEVNUM,

  02469	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02472	74 15		 je	 SHORT $LN178@printer_in
  02474	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0247c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02480	89 84 24 30 01
	00 00		 mov	 DWORD PTR tv1252[rsp], eax
  02487	eb 0b		 jmp	 SHORT $LN179@printer_in
$LN178@printer_in:
  02489	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1252[rsp], 0
$LN179@printer_in:
  02494	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0249d	74 17		 je	 SHORT $LN180@printer_in
  0249f	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  024a7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  024ab	d1 f8		 sar	 eax, 1
  024ad	89 84 24 34 01
	00 00		 mov	 DWORD PTR tv1258[rsp], eax
  024b4	eb 0b		 jmp	 SHORT $LN181@printer_in
$LN180@printer_in:
  024b6	c7 84 24 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1258[rsp], 0
$LN181@printer_in:
  024c1	b9 01 00 00 00	 mov	 ecx, 1
  024c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  024cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168745
  024d3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  024d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168746
  024df	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  024e4	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR tv1252[rsp]
  024eb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  024ef	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR tv1258[rsp]
  024f6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  024fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168747
  02501	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02506	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168748
  0250d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02512	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02517	41 b9 03 00 00
	00		 mov	 r9d, 3
  0251d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168749
  02524	ba 66 05 00 00	 mov	 edx, 1382		; 00000566H
  02529	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168750
  02530	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1382 :                 "Printer", "fcbcheck" );
; 1383 : 
; 1384 :             dev->fcbcheck = 1;

  02536	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0253e	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  02544	83 c8 08	 or	 eax, 8
  02547	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0254f	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 1385 :             continue;

  02555	e9 cf e1 ff ff	 jmp	 $LN2@printer_in
$LN76@printer_in:

; 1386 :         }
; 1387 : 
; 1388 :         if (strncasecmp( "index=", argv[ iarg ], 6 ) == 0)

  0255a	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  0255f	41 b8 06 00 00
	00		 mov	 r8d, 6
  02565	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0256d	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  02571	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168752
  02578	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0257e	85 c0		 test	 eax, eax
  02580	0f 85 8c 03 00
	00		 jne	 $LN78@printer_in

; 1389 :         {
; 1390 :             if (dev->devtype == 0x1403)

  02586	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0258e	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  02592	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  02597	0f 85 e9 00 00
	00		 jne	 $LN79@printer_in

; 1391 :             {
; 1392 :                 // HHC01109 "%1d:%04X Printer: option %s incompatible with device type %04X"
; 1393 :                 WRMSG( HHC01109, "E", LCSS_DEVNUM,

  0259d	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  025a6	74 15		 je	 SHORT $LN182@printer_in
  025a8	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  025b0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  025b4	89 84 24 38 01
	00 00		 mov	 DWORD PTR tv1290[rsp], eax
  025bb	eb 0b		 jmp	 SHORT $LN183@printer_in
$LN182@printer_in:
  025bd	c7 84 24 38 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1290[rsp], 0
$LN183@printer_in:
  025c8	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  025d1	74 17		 je	 SHORT $LN184@printer_in
  025d3	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  025db	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  025df	d1 f8		 sar	 eax, 1
  025e1	89 84 24 3c 01
	00 00		 mov	 DWORD PTR tv1296[rsp], eax
  025e8	eb 0b		 jmp	 SHORT $LN185@printer_in
$LN184@printer_in:
  025ea	c7 84 24 3c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1296[rsp], 0
$LN185@printer_in:
  025f5	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  025fd	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  02601	89 84 24 dc 01
	00 00		 mov	 DWORD PTR tv1284[rsp], eax
  02608	b9 01 00 00 00	 mov	 ecx, 1
  0260d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02613	8b 8c 24 dc 01
	00 00		 mov	 ecx, DWORD PTR tv1284[rsp]
  0261a	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0261e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168754
  02625	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0262a	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR tv1290[rsp]
  02631	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02635	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR tv1296[rsp]
  0263c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02640	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168755
  02647	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0264c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168756
  02653	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02658	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0265d	41 b9 03 00 00
	00		 mov	 r9d, 3
  02663	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168757
  0266a	ba 72 05 00 00	 mov	 edx, 1394		; 00000572H
  0266f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168758
  02676	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1394 :                     "option 'index'", dev->devtype );
; 1395 :                 return -1;

  0267c	b8 ff ff ff ff	 mov	 eax, -1
  02681	e9 64 0d 00 00	 jmp	 $LN1@printer_in
$LN79@printer_in:

; 1396 :             }
; 1397 :             ptr = argv[ iarg ] + 6;

  02686	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  0268b	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  02693	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  02697	48 83 c0 06	 add	 rax, 6
  0269b	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax

; 1398 :             errno = 0;

  026a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  026a6	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1399 :             dev->index = (int) strtoul( ptr, &nxt, 10 );

  026ac	41 b8 0a 00 00
	00		 mov	 r8d, 10
  026b2	48 8d 54 24 78	 lea	 rdx, QWORD PTR nxt$[rsp]
  026b7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  026bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  026c2	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  026ca	89 81 8c 07 00
	00		 mov	 DWORD PTR [rcx+1932], eax

; 1400 :             if (0
; 1401 :                 || errno != 0
; 1402 :                 || nxt == ptr
; 1403 :                 || *nxt != 0
; 1404 :                 || dev->index < MIN_PLB_INDEX
; 1405 :                 || dev->index > MAX_PLB_INDEX

  026d0	33 c0		 xor	 eax, eax
  026d2	85 c0		 test	 eax, eax
  026d4	75 49		 jne	 SHORT $LN81@printer_in
  026d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  026dc	83 38 00	 cmp	 DWORD PTR [rax], 0
  026df	75 3e		 jne	 SHORT $LN81@printer_in
  026e1	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  026e6	48 39 44 24 78	 cmp	 QWORD PTR nxt$[rsp], rax
  026eb	74 32		 je	 SHORT $LN81@printer_in
  026ed	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  026f2	0f be 00	 movsx	 eax, BYTE PTR [rax]
  026f5	85 c0		 test	 eax, eax
  026f7	75 26		 jne	 SHORT $LN81@printer_in
  026f9	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02701	83 b8 8c 07 00
	00 e1		 cmp	 DWORD PTR [rax+1932], -31
  02708	7c 15		 jl	 SHORT $LN81@printer_in
  0270a	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02712	83 b8 8c 07 00
	00 1f		 cmp	 DWORD PTR [rax+1932], 31
  02719	0f 8e 22 01 00
	00		 jle	 $LN80@printer_in
$LN81@printer_in:

; 1406 :             )
; 1407 :             {
; 1408 :                 j = ptr+1 - argv[iarg];

  0271f	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  02724	48 ff c0	 inc	 rax
  02727	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  0272c	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  02734	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  02738	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1409 :                 // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1410 :                 WRMSG( HHC01103, "E", LCSS_DEVNUM,

  0273c	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02745	74 15		 je	 SHORT $LN186@printer_in
  02747	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0274f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02753	89 84 24 40 01
	00 00		 mov	 DWORD PTR tv1375[rsp], eax
  0275a	eb 0b		 jmp	 SHORT $LN187@printer_in
$LN186@printer_in:
  0275c	c7 84 24 40 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1375[rsp], 0
$LN187@printer_in:
  02767	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02770	74 17		 je	 SHORT $LN188@printer_in
  02772	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0277a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0277e	d1 f8		 sar	 eax, 1
  02780	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv1381[rsp], eax
  02787	eb 0b		 jmp	 SHORT $LN189@printer_in
$LN188@printer_in:
  02789	c7 84 24 44 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1381[rsp], 0
$LN189@printer_in:
  02794	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  02799	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR tv1366[rsp], rax
  027a1	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  027a5	ff c1		 inc	 ecx
  027a7	89 8c 24 e0 01
	00 00		 mov	 DWORD PTR tv1370[rsp], ecx
  027ae	b9 01 00 00 00	 mov	 ecx, 1
  027b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  027b9	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  027bd	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  027c1	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  027c9	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR tv1366[rsp]
  027d1	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  027d5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  027da	8b 8c 24 e0 01
	00 00		 mov	 ecx, DWORD PTR tv1370[rsp]
  027e1	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  027e5	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tv1375[rsp]
  027ec	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  027f0	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR tv1381[rsp]
  027f7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  027fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168761
  02802	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02807	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168762
  0280e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02813	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02818	41 b9 03 00 00
	00		 mov	 r9d, 3
  0281e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168763
  02825	ba 83 05 00 00	 mov	 edx, 1411		; 00000583H
  0282a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168764
  02831	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1411 :                     iarg + 1, argv[ iarg ], j );
; 1412 :                 return -1;

  02837	b8 ff ff ff ff	 mov	 eax, -1
  0283c	e9 a9 0b 00 00	 jmp	 $LN1@printer_in
$LN80@printer_in:

; 1413 :             }
; 1414 :             if (dev->devtype == 0x3203)

  02841	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02849	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0284d	3d 03 32 00 00	 cmp	 eax, 12803		; 00003203H
  02852	0f 85 b5 00 00
	00		 jne	 $LN82@printer_in

; 1415 :             {
; 1416 :                 // "%1d:%04X Printer: Indexing accepted and ignored for 3203-5"
; 1417 :                 WRMSG( HHC01110, "W", LCSS_DEVNUM );

  02858	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02861	74 15		 je	 SHORT $LN190@printer_in
  02863	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0286b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0286f	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv1398[rsp], eax
  02876	eb 0b		 jmp	 SHORT $LN191@printer_in
$LN190@printer_in:
  02878	c7 84 24 48 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1398[rsp], 0
$LN191@printer_in:
  02883	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0288c	74 17		 je	 SHORT $LN192@printer_in
  0288e	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02896	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0289a	d1 f8		 sar	 eax, 1
  0289c	89 84 24 4c 01
	00 00		 mov	 DWORD PTR tv1404[rsp], eax
  028a3	eb 0b		 jmp	 SHORT $LN193@printer_in
$LN192@printer_in:
  028a5	c7 84 24 4c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1404[rsp], 0
$LN193@printer_in:
  028b0	b9 01 00 00 00	 mov	 ecx, 1
  028b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  028bb	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR tv1398[rsp]
  028c2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  028c6	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR tv1404[rsp]
  028cd	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  028d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168766
  028d8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  028dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168767
  028e4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  028e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  028ee	41 b9 03 00 00
	00		 mov	 r9d, 3
  028f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168768
  028fb	ba 89 05 00 00	 mov	 edx, 1417		; 00000589H
  02900	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168769
  02907	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN82@printer_in:

; 1418 :             }
; 1419 :             continue;

  0290d	e9 17 de ff ff	 jmp	 $LN2@printer_in
$LN78@printer_in:

; 1420 :         }
; 1421 : 
; 1422 :         if (strncasecmp( "lpi=", argv[ iarg ], 4 ) == 0)

  02912	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  02917	41 b8 04 00 00
	00		 mov	 r8d, 4
  0291d	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  02925	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  02929	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168771
  02930	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  02936	85 c0		 test	 eax, eax
  02938	0f 85 c4 01 00
	00		 jne	 $LN83@printer_in

; 1423 :         {
; 1424 :             ptr = argv[ iarg ] + 4;

  0293e	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  02943	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0294b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0294f	48 83 c0 04	 add	 rax, 4
  02953	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax

; 1425 :             errno = 0;

  02958	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0295e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1426 :             dev->lpi = (int) strtoul( ptr, &nxt, 10 );

  02964	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0296a	48 8d 54 24 78	 lea	 rdx, QWORD PTR nxt$[rsp]
  0296f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  02974	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  0297a	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02982	89 81 88 07 00
	00		 mov	 DWORD PTR [rcx+1928], eax

; 1427 :             if (0
; 1428 :                 || errno != 0
; 1429 :                 || nxt == ptr
; 1430 :                 || *nxt != 0
; 1431 :                 || (dev->lpi != 6 && dev->lpi != 8)

  02988	33 c0		 xor	 eax, eax
  0298a	85 c0		 test	 eax, eax
  0298c	75 4d		 jne	 SHORT $LN85@printer_in
  0298e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  02994	83 38 00	 cmp	 DWORD PTR [rax], 0
  02997	75 42		 jne	 SHORT $LN85@printer_in
  02999	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  0299e	48 39 44 24 78	 cmp	 QWORD PTR nxt$[rsp], rax
  029a3	74 36		 je	 SHORT $LN85@printer_in
  029a5	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  029aa	0f be 00	 movsx	 eax, BYTE PTR [rax]
  029ad	85 c0		 test	 eax, eax
  029af	75 2a		 jne	 SHORT $LN85@printer_in
  029b1	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  029b9	83 b8 88 07 00
	00 06		 cmp	 DWORD PTR [rax+1928], 6
  029c0	0f 84 37 01 00
	00		 je	 $LN84@printer_in
  029c6	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  029ce	83 b8 88 07 00
	00 08		 cmp	 DWORD PTR [rax+1928], 8
  029d5	0f 84 22 01 00
	00		 je	 $LN84@printer_in
$LN85@printer_in:

; 1432 :             )
; 1433 :             {
; 1434 :                 j = ptr+1 - argv[iarg];

  029db	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  029e0	48 ff c0	 inc	 rax
  029e3	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  029e8	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  029f0	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  029f4	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1435 :                 // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1436 :                 WRMSG( HHC01103, "E", LCSS_DEVNUM,

  029f8	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02a01	74 15		 je	 SHORT $LN194@printer_in
  02a03	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02a0b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02a0f	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv1459[rsp], eax
  02a16	eb 0b		 jmp	 SHORT $LN195@printer_in
$LN194@printer_in:
  02a18	c7 84 24 50 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1459[rsp], 0
$LN195@printer_in:
  02a23	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02a2c	74 17		 je	 SHORT $LN196@printer_in
  02a2e	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02a36	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02a3a	d1 f8		 sar	 eax, 1
  02a3c	89 84 24 54 01
	00 00		 mov	 DWORD PTR tv1465[rsp], eax
  02a43	eb 0b		 jmp	 SHORT $LN197@printer_in
$LN196@printer_in:
  02a45	c7 84 24 54 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1465[rsp], 0
$LN197@printer_in:
  02a50	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  02a55	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR tv1450[rsp], rax
  02a5d	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  02a61	ff c1		 inc	 ecx
  02a63	89 8c 24 e4 01
	00 00		 mov	 DWORD PTR tv1454[rsp], ecx
  02a6a	b9 01 00 00 00	 mov	 ecx, 1
  02a6f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02a75	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  02a79	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  02a7d	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  02a85	48 8b 94 24 78
	02 00 00	 mov	 rdx, QWORD PTR tv1450[rsp]
  02a8d	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  02a91	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  02a96	8b 8c 24 e4 01
	00 00		 mov	 ecx, DWORD PTR tv1454[rsp]
  02a9d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  02aa1	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR tv1459[rsp]
  02aa8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02aac	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR tv1465[rsp]
  02ab3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02ab7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168774
  02abe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02ac3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168775
  02aca	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02acf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02ad4	41 b9 03 00 00
	00		 mov	 r9d, 3
  02ada	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168776
  02ae1	ba 9d 05 00 00	 mov	 edx, 1437		; 0000059dH
  02ae6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168777
  02aed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1437 :                     iarg + 1, argv[ iarg ], j );
; 1438 :                 return -1;

  02af3	b8 ff ff ff ff	 mov	 eax, -1
  02af8	e9 ed 08 00 00	 jmp	 $LN1@printer_in
$LN84@printer_in:

; 1439 :             }
; 1440 :             continue;

  02afd	e9 27 dc ff ff	 jmp	 $LN2@printer_in
$LN83@printer_in:

; 1441 :         }
; 1442 : 
; 1443 :         if (strncasecmp( "lpp=", argv[ iarg ], 4 ) == 0)

  02b02	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  02b07	41 b8 04 00 00
	00		 mov	 r8d, 4
  02b0d	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  02b15	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  02b19	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168779
  02b20	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  02b26	85 c0		 test	 eax, eax
  02b28	0f 85 b5 01 00
	00		 jne	 $LN86@printer_in

; 1444 :         {
; 1445 :             ptr = argv[ iarg ] + 4;

  02b2e	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  02b33	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  02b3b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  02b3f	48 83 c0 04	 add	 rax, 4
  02b43	48 89 44 24 68	 mov	 QWORD PTR ptr$[rsp], rax

; 1446 :             errno = 0;

  02b48	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  02b4e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1447 :             dev->lpp = (int) strtoul( ptr, &nxt, 10 );

  02b54	41 b8 0a 00 00
	00		 mov	 r8d, 10
  02b5a	48 8d 54 24 78	 lea	 rdx, QWORD PTR nxt$[rsp]
  02b5f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ptr$[rsp]
  02b64	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  02b6a	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02b72	89 81 90 07 00
	00		 mov	 DWORD PTR [rcx+1936], eax

; 1448 :             if (0
; 1449 :                 || errno != 0
; 1450 :                 || nxt == ptr
; 1451 :                 || *nxt != 0
; 1452 :                 || dev->lpp >= fcbsize

  02b78	33 c0		 xor	 eax, eax
  02b7a	85 c0		 test	 eax, eax
  02b7c	75 3e		 jne	 SHORT $LN88@printer_in
  02b7e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  02b84	83 38 00	 cmp	 DWORD PTR [rax], 0
  02b87	75 33		 jne	 SHORT $LN88@printer_in
  02b89	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  02b8e	48 39 44 24 78	 cmp	 QWORD PTR nxt$[rsp], rax
  02b93	74 27		 je	 SHORT $LN88@printer_in
  02b95	48 8b 44 24 78	 mov	 rax, QWORD PTR nxt$[rsp]
  02b9a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  02b9d	85 c0		 test	 eax, eax
  02b9f	75 1b		 jne	 SHORT $LN88@printer_in
  02ba1	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02ba9	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR fcbsize$[rsp]
  02bb0	39 88 90 07 00
	00		 cmp	 DWORD PTR [rax+1936], ecx
  02bb6	0f 8c 22 01 00
	00		 jl	 $LN87@printer_in
$LN88@printer_in:

; 1453 :             )
; 1454 :             {
; 1455 :                 j = ptr + 1 - argv[ iarg ];

  02bbc	48 8b 44 24 68	 mov	 rax, QWORD PTR ptr$[rsp]
  02bc1	48 ff c0	 inc	 rax
  02bc4	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR iarg$[rsp]
  02bc9	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  02bd1	48 2b 04 ca	 sub	 rax, QWORD PTR [rdx+rcx*8]
  02bd5	89 44 24 70	 mov	 DWORD PTR j$[rsp], eax

; 1456 :                 // "%1d:%04X Printer: argument %d parameter '%s' position %d is invalid"
; 1457 :                 WRMSG( HHC01103, "E", LCSS_DEVNUM,

  02bd9	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02be2	74 15		 je	 SHORT $LN198@printer_in
  02be4	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02bec	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02bf0	89 84 24 58 01
	00 00		 mov	 DWORD PTR tv1518[rsp], eax
  02bf7	eb 0b		 jmp	 SHORT $LN199@printer_in
$LN198@printer_in:
  02bf9	c7 84 24 58 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1518[rsp], 0
$LN199@printer_in:
  02c04	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02c0d	74 17		 je	 SHORT $LN200@printer_in
  02c0f	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02c17	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02c1b	d1 f8		 sar	 eax, 1
  02c1d	89 84 24 5c 01
	00 00		 mov	 DWORD PTR tv1524[rsp], eax
  02c24	eb 0b		 jmp	 SHORT $LN201@printer_in
$LN200@printer_in:
  02c26	c7 84 24 5c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1524[rsp], 0
$LN201@printer_in:
  02c31	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  02c36	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR tv1509[rsp], rax
  02c3e	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  02c42	ff c1		 inc	 ecx
  02c44	89 8c 24 e8 01
	00 00		 mov	 DWORD PTR tv1513[rsp], ecx
  02c4b	b9 01 00 00 00	 mov	 ecx, 1
  02c50	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02c56	8b 4c 24 70	 mov	 ecx, DWORD PTR j$[rsp]
  02c5a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  02c5e	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  02c66	48 8b 94 24 80
	02 00 00	 mov	 rdx, QWORD PTR tv1509[rsp]
  02c6e	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  02c72	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  02c77	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR tv1513[rsp]
  02c7e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  02c82	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR tv1518[rsp]
  02c89	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02c8d	8b 8c 24 5c 01
	00 00		 mov	 ecx, DWORD PTR tv1524[rsp]
  02c94	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02c98	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168782
  02c9f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02ca4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168783
  02cab	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02cb0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02cb5	41 b9 03 00 00
	00		 mov	 r9d, 3
  02cbb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168784
  02cc2	ba b2 05 00 00	 mov	 edx, 1458		; 000005b2H
  02cc7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168785
  02cce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1458 :                     iarg + 1, argv[ iarg ], j );
; 1459 :                 return -1;

  02cd4	b8 ff ff ff ff	 mov	 eax, -1
  02cd9	e9 0c 07 00 00	 jmp	 $LN1@printer_in
$LN87@printer_in:

; 1460 :             }
; 1461 :             continue;

  02cde	e9 46 da ff ff	 jmp	 $LN2@printer_in
$LN86@printer_in:

; 1462 :         }
; 1463 : 
; 1464 :         if (strcasecmp( argv[ iarg ], "noclear" ) == 0)

  02ce3	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  02ce8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168787
  02cef	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  02cf7	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  02cfb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  02d01	85 c0		 test	 eax, eax
  02d03	0f 85 f1 00 00
	00		 jne	 $LN89@printer_in

; 1465 :         {
; 1466 :             dev->append = 1;

  02d09	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02d11	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  02d17	83 c8 01	 or	 eax, 1
  02d1a	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02d22	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1467 :             // "%1d:%04X %s: option '%s' has been deprecated"
; 1468 :             WRMSG( HHC01251, "W", LCSS_DEVNUM,

  02d28	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02d31	74 15		 je	 SHORT $LN202@printer_in
  02d33	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02d3b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02d3f	89 84 24 60 01
	00 00		 mov	 DWORD PTR tv1550[rsp], eax
  02d46	eb 0b		 jmp	 SHORT $LN203@printer_in
$LN202@printer_in:
  02d48	c7 84 24 60 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1550[rsp], 0
$LN203@printer_in:
  02d53	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02d5c	74 17		 je	 SHORT $LN204@printer_in
  02d5e	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02d66	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02d6a	d1 f8		 sar	 eax, 1
  02d6c	89 84 24 64 01
	00 00		 mov	 DWORD PTR tv1556[rsp], eax
  02d73	eb 0b		 jmp	 SHORT $LN205@printer_in
$LN204@printer_in:
  02d75	c7 84 24 64 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1556[rsp], 0
$LN205@printer_in:
  02d80	b9 01 00 00 00	 mov	 ecx, 1
  02d85	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02d8b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168788
  02d92	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  02d97	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168789
  02d9e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  02da3	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR tv1550[rsp]
  02daa	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02dae	8b 8c 24 64 01
	00 00		 mov	 ecx, DWORD PTR tv1556[rsp]
  02db5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02db9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168790
  02dc0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02dc5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168791
  02dcc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02dd1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02dd6	41 b9 03 00 00
	00		 mov	 r9d, 3
  02ddc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168792
  02de3	ba bd 05 00 00	 mov	 edx, 1469		; 000005bdH
  02de8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168793
  02def	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1469 :                 "Printer", "noclear" );
; 1470 :             continue;

  02df5	e9 2f d9 ff ff	 jmp	 $LN2@printer_in
$LN89@printer_in:

; 1471 :         }
; 1472 : 
; 1473 :         /* (DEPRECATED!) */
; 1474 :         if (strcasecmp( argv[ iarg ], "nofcbcheck" ) == 0)

  02dfa	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  02dff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168795
  02e06	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  02e0e	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  02e12	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  02e18	85 c0		 test	 eax, eax
  02e1a	0f 85 f1 01 00
	00		 jne	 $LN90@printer_in

; 1475 :         {
; 1476 :             if (dev->devtype == 0x1403)

  02e20	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02e28	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  02e2c	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  02e31	0f 85 e9 00 00
	00		 jne	 $LN91@printer_in

; 1477 :             {
; 1478 :                 // HHC01109 "%1d:%04X Printer: option %s incompatible with device type %04X"
; 1479 :                 WRMSG( HHC01109, "E", LCSS_DEVNUM,

  02e37	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02e40	74 15		 je	 SHORT $LN206@printer_in
  02e42	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02e4a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02e4e	89 84 24 68 01
	00 00		 mov	 DWORD PTR tv1584[rsp], eax
  02e55	eb 0b		 jmp	 SHORT $LN207@printer_in
$LN206@printer_in:
  02e57	c7 84 24 68 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1584[rsp], 0
$LN207@printer_in:
  02e62	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02e6b	74 17		 je	 SHORT $LN208@printer_in
  02e6d	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02e75	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02e79	d1 f8		 sar	 eax, 1
  02e7b	89 84 24 6c 01
	00 00		 mov	 DWORD PTR tv1590[rsp], eax
  02e82	eb 0b		 jmp	 SHORT $LN209@printer_in
$LN208@printer_in:
  02e84	c7 84 24 6c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1590[rsp], 0
$LN209@printer_in:
  02e8f	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02e97	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  02e9b	89 84 24 ec 01
	00 00		 mov	 DWORD PTR tv1578[rsp], eax
  02ea2	b9 01 00 00 00	 mov	 ecx, 1
  02ea7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02ead	8b 8c 24 ec 01
	00 00		 mov	 ecx, DWORD PTR tv1578[rsp]
  02eb4	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  02eb8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168797
  02ebf	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  02ec4	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR tv1584[rsp]
  02ecb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02ecf	8b 8c 24 6c 01
	00 00		 mov	 ecx, DWORD PTR tv1590[rsp]
  02ed6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02eda	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168798
  02ee1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02ee6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168799
  02eed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02ef2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02ef7	41 b9 03 00 00
	00		 mov	 r9d, 3
  02efd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168800
  02f04	ba c8 05 00 00	 mov	 edx, 1480		; 000005c8H
  02f09	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168801
  02f10	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1480 :                     "option 'nofcbcheck'", dev->devtype );
; 1481 :                 return -1;

  02f16	b8 ff ff ff ff	 mov	 eax, -1
  02f1b	e9 ca 04 00 00	 jmp	 $LN1@printer_in
$LN91@printer_in:

; 1482 :             }
; 1483 : 
; 1484 :             // "%1d:%04X %s: option '%s' has been deprecated"
; 1485 :             WRMSG( HHC01251, "W", LCSS_DEVNUM,

  02f20	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02f29	74 15		 je	 SHORT $LN210@printer_in
  02f2b	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02f33	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02f37	89 84 24 70 01
	00 00		 mov	 DWORD PTR tv1638[rsp], eax
  02f3e	eb 0b		 jmp	 SHORT $LN211@printer_in
$LN210@printer_in:
  02f40	c7 84 24 70 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1638[rsp], 0
$LN211@printer_in:
  02f4b	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02f54	74 17		 je	 SHORT $LN212@printer_in
  02f56	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02f5e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02f62	d1 f8		 sar	 eax, 1
  02f64	89 84 24 74 01
	00 00		 mov	 DWORD PTR tv1644[rsp], eax
  02f6b	eb 0b		 jmp	 SHORT $LN213@printer_in
$LN212@printer_in:
  02f6d	c7 84 24 74 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1644[rsp], 0
$LN213@printer_in:
  02f78	b9 01 00 00 00	 mov	 ecx, 1
  02f7d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02f83	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168802
  02f8a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  02f8f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168803
  02f96	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  02f9b	8b 8c 24 70 01
	00 00		 mov	 ecx, DWORD PTR tv1638[rsp]
  02fa2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02fa6	8b 8c 24 74 01
	00 00		 mov	 ecx, DWORD PTR tv1644[rsp]
  02fad	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02fb1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168804
  02fb8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02fbd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168805
  02fc4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02fc9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02fce	41 b9 03 00 00
	00		 mov	 r9d, 3
  02fd4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168806
  02fdb	ba ce 05 00 00	 mov	 edx, 1486		; 000005ceH
  02fe0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168807
  02fe7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1486 :                 "Printer", "nofcbcheck" );
; 1487 : 
; 1488 :             //dev->fcbcheck = 0;      // IGNORED
; 1489 :             dev->fcbcheck = 1;      // FORCED

  02fed	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02ff5	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  02ffb	83 c8 08	 or	 eax, 8
  02ffe	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03006	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 1490 :             continue;

  0300c	e9 18 d7 ff ff	 jmp	 $LN2@printer_in
$LN90@printer_in:

; 1491 :         }
; 1492 : 
; 1493 :         /* sockdev means the device file is actually
; 1494 :            a connected socket instead of a disk file.
; 1495 :            The file name is the socket_spec (host:port)
; 1496 :            to listen for connections on.
; 1497 :         */
; 1498 :         if (!dev->ispiped && strcasecmp( argv[ iarg ], "sockdev" ) == 0)

  03011	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03019	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  0301f	d1 e8		 shr	 eax, 1
  03021	83 e0 01	 and	 eax, 1
  03024	85 c0		 test	 eax, eax
  03026	75 2c		 jne	 SHORT $LN92@printer_in
  03028	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  0302d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168809
  03034	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0303c	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  03040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  03046	85 c0		 test	 eax, eax
  03048	75 0a		 jne	 SHORT $LN92@printer_in

; 1499 :         {
; 1500 :             sockdev = TRUE;

  0304a	c6 44 24 74 01	 mov	 BYTE PTR sockdev$[rsp], 1

; 1501 :             continue;

  0304f	e9 d5 d6 ff ff	 jmp	 $LN2@printer_in
$LN92@printer_in:

; 1502 :         }
; 1503 : 
; 1504 :         // "%1d:%04X Printer: argument %d parameter '%s' is invalid"
; 1505 :         WRMSG( HHC01102, "E", LCSS_DEVNUM,

  03054	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0305d	74 15		 je	 SHORT $LN214@printer_in
  0305f	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03067	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0306b	89 84 24 78 01
	00 00		 mov	 DWORD PTR tv1678[rsp], eax
  03072	eb 0b		 jmp	 SHORT $LN215@printer_in
$LN214@printer_in:
  03074	c7 84 24 78 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1678[rsp], 0
$LN215@printer_in:
  0307f	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  03088	74 17		 je	 SHORT $LN216@printer_in
  0308a	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03092	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  03096	d1 f8		 sar	 eax, 1
  03098	89 84 24 7c 01
	00 00		 mov	 DWORD PTR tv1684[rsp], eax
  0309f	eb 0b		 jmp	 SHORT $LN217@printer_in
$LN216@printer_in:
  030a1	c7 84 24 7c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1684[rsp], 0
$LN217@printer_in:
  030ac	48 63 44 24 60	 movsxd	 rax, DWORD PTR iarg$[rsp]
  030b1	48 89 84 24 88
	02 00 00	 mov	 QWORD PTR tv1669[rsp], rax
  030b9	8b 4c 24 60	 mov	 ecx, DWORD PTR iarg$[rsp]
  030bd	ff c1		 inc	 ecx
  030bf	89 8c 24 f0 01
	00 00		 mov	 DWORD PTR tv1673[rsp], ecx
  030c6	b9 01 00 00 00	 mov	 ecx, 1
  030cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  030d1	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  030d9	48 8b 94 24 88
	02 00 00	 mov	 rdx, QWORD PTR tv1669[rsp]
  030e1	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  030e5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  030ea	8b 8c 24 f0 01
	00 00		 mov	 ecx, DWORD PTR tv1673[rsp]
  030f1	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  030f5	8b 8c 24 78 01
	00 00		 mov	 ecx, DWORD PTR tv1678[rsp]
  030fc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  03100	8b 8c 24 7c 01
	00 00		 mov	 ecx, DWORD PTR tv1684[rsp]
  03107	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0310b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168810
  03112	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  03117	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168811
  0311e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  03123	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  03128	41 b9 03 00 00
	00		 mov	 r9d, 3
  0312e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168812
  03135	ba e2 05 00 00	 mov	 edx, 1506		; 000005e2H
  0313a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168813
  03141	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1506 :             iarg + 1, argv[ iarg ]);
; 1507 :         return -1;

  03147	b8 ff ff ff ff	 mov	 eax, -1
  0314c	e9 99 02 00 00	 jmp	 $LN1@printer_in

; 1508 : 
; 1509 :     } /* for (iarg = 1; iarg < argc; iarg++) Process the driver arguments */

  03151	e9 d3 d5 ff ff	 jmp	 $LN2@printer_in
$LN3@printer_in:

; 1510 : 
; 1511 :     /* Perform final fcb/cctape validation: for fcb only, verify there
; 1512 :        are not more than 30 channel stops defined. For both cctape and
; 1513 :        fcb, verify no channel stop is on a line greater than the lpp.
; 1514 :     */
; 1515 :     if (0x1403 == dev->devtype)

  03156	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0315e	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  03162	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  03167	75 20		 jne	 SHORT $LN93@printer_in

; 1516 :     {
; 1517 :         if (!valid_cctape( dev ))

  03169	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03171	e8 00 00 00 00	 call	 valid_cctape
  03176	0f b6 c0	 movzx	 eax, al
  03179	85 c0		 test	 eax, eax
  0317b	75 0a		 jne	 SHORT $LN95@printer_in

; 1518 :             return -1;  // (error msg already issued)

  0317d	b8 ff ff ff ff	 mov	 eax, -1
  03182	e9 63 02 00 00	 jmp	 $LN1@printer_in
$LN95@printer_in:

; 1519 :     }

  03187	eb 1e		 jmp	 SHORT $LN94@printer_in
$LN93@printer_in:

; 1520 :     else // 3203 or 3211
; 1521 :     {
; 1522 :         if (!valid_fcb( dev ))

  03189	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03191	e8 00 00 00 00	 call	 valid_fcb
  03196	0f b6 c0	 movzx	 eax, al
  03199	85 c0		 test	 eax, eax
  0319b	75 0a		 jne	 SHORT $LN96@printer_in

; 1523 :             return -1;  // (error msg already issued)

  0319d	b8 ff ff ff ff	 mov	 eax, -1
  031a2	e9 43 02 00 00	 jmp	 $LN1@printer_in
$LN96@printer_in:
$LN94@printer_in:

; 1524 :     }
; 1525 : 
; 1526 :     /* Check for incompatible options... */
; 1527 : 
; 1528 :     if (sockdev && dev->crlf)

  031a7	0f b6 44 24 74	 movzx	 eax, BYTE PTR sockdev$[rsp]
  031ac	85 c0		 test	 eax, eax
  031ae	0f 84 e4 00 00
	00		 je	 $LN97@printer_in
  031b4	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  031bc	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  031c2	83 e0 01	 and	 eax, 1
  031c5	85 c0		 test	 eax, eax
  031c7	0f 84 cb 00 00
	00		 je	 $LN97@printer_in

; 1529 :     {
; 1530 :         // "%1d:%04X Printer: option %s is incompatible"
; 1531 :         WRMSG( HHC01104, "E", LCSS_DEVNUM,

  031cd	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  031d6	74 15		 je	 SHORT $LN218@printer_in
  031d8	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  031e0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  031e4	89 84 24 80 01
	00 00		 mov	 DWORD PTR tv1715[rsp], eax
  031eb	eb 0b		 jmp	 SHORT $LN219@printer_in
$LN218@printer_in:
  031ed	c7 84 24 80 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1715[rsp], 0
$LN219@printer_in:
  031f8	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  03201	74 17		 je	 SHORT $LN220@printer_in
  03203	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0320b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0320f	d1 f8		 sar	 eax, 1
  03211	89 84 24 84 01
	00 00		 mov	 DWORD PTR tv1721[rsp], eax
  03218	eb 0b		 jmp	 SHORT $LN221@printer_in
$LN220@printer_in:
  0321a	c7 84 24 84 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1721[rsp], 0
$LN221@printer_in:
  03225	b9 01 00 00 00	 mov	 ecx, 1
  0322a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  03230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168819
  03237	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0323c	8b 8c 24 80 01
	00 00		 mov	 ecx, DWORD PTR tv1715[rsp]
  03243	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  03247	8b 8c 24 84 01
	00 00		 mov	 ecx, DWORD PTR tv1721[rsp]
  0324e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  03252	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168820
  03259	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0325e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168821
  03265	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0326a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0326f	41 b9 03 00 00
	00		 mov	 r9d, 3
  03275	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168822
  0327c	ba fc 05 00 00	 mov	 edx, 1532		; 000005fcH
  03281	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168823
  03288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1532 :             "sockdev/crlf" );
; 1533 :         return -1;

  0328e	b8 ff ff ff ff	 mov	 eax, -1
  03293	e9 52 01 00 00	 jmp	 $LN1@printer_in
$LN97@printer_in:

; 1534 :     }
; 1535 : 
; 1536 :     if (sockdev && dev->append)

  03298	0f b6 44 24 74	 movzx	 eax, BYTE PTR sockdev$[rsp]
  0329d	85 c0		 test	 eax, eax
  0329f	0f 84 e1 00 00
	00		 je	 $LN98@printer_in
  032a5	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  032ad	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  032b3	83 e0 01	 and	 eax, 1
  032b6	85 c0		 test	 eax, eax
  032b8	0f 84 c8 00 00
	00		 je	 $LN98@printer_in

; 1537 :     {
; 1538 :         // "%1d:%04X Printer: option %s is incompatible"
; 1539 :         WRMSG( HHC01104, "E", LCSS_DEVNUM,

  032be	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  032c7	74 15		 je	 SHORT $LN222@printer_in
  032c9	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  032d1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  032d5	89 84 24 88 01
	00 00		 mov	 DWORD PTR tv1741[rsp], eax
  032dc	eb 0b		 jmp	 SHORT $LN223@printer_in
$LN222@printer_in:
  032de	c7 84 24 88 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1741[rsp], 0
$LN223@printer_in:
  032e9	48 83 bc 24 b0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  032f2	74 17		 je	 SHORT $LN224@printer_in
  032f4	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  032fc	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  03300	d1 f8		 sar	 eax, 1
  03302	89 84 24 8c 01
	00 00		 mov	 DWORD PTR tv1747[rsp], eax
  03309	eb 0b		 jmp	 SHORT $LN225@printer_in
$LN224@printer_in:
  0330b	c7 84 24 8c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1747[rsp], 0
$LN225@printer_in:
  03316	b9 01 00 00 00	 mov	 ecx, 1
  0331b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  03321	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168825
  03328	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0332d	8b 8c 24 88 01
	00 00		 mov	 ecx, DWORD PTR tv1741[rsp]
  03334	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  03338	8b 8c 24 8c 01
	00 00		 mov	 ecx, DWORD PTR tv1747[rsp]
  0333f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  03343	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168826
  0334a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0334f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168827
  03356	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0335b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  03360	41 b9 03 00 00
	00		 mov	 r9d, 3
  03366	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168828
  0336d	ba 04 06 00 00	 mov	 edx, 1540		; 00000604H
  03372	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168829
  03379	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1540 :             "sockdev/noclear" );
; 1541 :         return -1;

  0337f	b8 ff ff ff ff	 mov	 eax, -1
  03384	eb 64		 jmp	 SHORT $LN1@printer_in
$LN98@printer_in:

; 1542 :     }
; 1543 : 
; 1544 :     /* If socket device, create a listening socket
; 1545 :        to accept connections on.
; 1546 :     */
; 1547 :     if (sockdev && !bind_device_ex( dev,

  03386	0f b6 44 24 74	 movzx	 eax, BYTE PTR sockdev$[rsp]
  0338b	85 c0		 test	 eax, eax
  0338d	74 38		 je	 SHORT $LN99@printer_in
  0338f	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03397	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0339d	4c 8b 8c 24 b0
	02 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  033a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:onconnect_callback
  033ac	48 8b d0	 mov	 rdx, rax
  033af	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  033b7	e8 00 00 00 00	 call	 bind_device_ex
  033bc	85 c0		 test	 eax, eax
  033be	75 07		 jne	 SHORT $LN99@printer_in

; 1548 :         dev->filename, onconnect_callback, dev ))
; 1549 :     {
; 1550 :         return -1;  // (error msg already issued)

  033c0	b8 ff ff ff ff	 mov	 eax, -1
  033c5	eb 23		 jmp	 SHORT $LN1@printer_in
$LN99@printer_in:

; 1551 :     }
; 1552 : 
; 1553 :     /* Open the device file right away */
; 1554 :     if (!sockdev && open_printer( dev ) != 0)

  033c7	0f b6 44 24 74	 movzx	 eax, BYTE PTR sockdev$[rsp]
  033cc	85 c0		 test	 eax, eax
  033ce	75 18		 jne	 SHORT $LN100@printer_in
  033d0	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  033d8	e8 00 00 00 00	 call	 open_printer
  033dd	85 c0		 test	 eax, eax
  033df	74 07		 je	 SHORT $LN100@printer_in

; 1555 :         return -1;  // (error msg already issued)

  033e1	b8 ff ff ff ff	 mov	 eax, -1
  033e6	eb 02		 jmp	 SHORT $LN1@printer_in
$LN100@printer_in:

; 1556 : 
; 1557 :     return 0;

  033e8	33 c0		 xor	 eax, eax
$LN1@printer_in:

; 1558 : } /* end function printer_init_handler */

  033ea	48 81 c4 98 02
	00 00		 add	 rsp, 664		; 00000298H
  033f1	5f		 pop	 rdi
  033f2	5e		 pop	 rsi
  033f3	c3		 ret	 0
printer_init_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
open_flags$ = 96
fd$1 = 100
pid$ = 104
tv72 = 108
tv92 = 112
tv130 = 116
tv158 = 120
tv164 = 124
tv197 = 128
tv203 = 132
tv218 = 136
tv224 = 140
rc$ = 144
filesize$ = 152
tv83 = 160
tv149 = 168
tv188 = 176
dev$ = 208
open_printer PROC

; 1584 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 1585 : pid_t           pid;                    /* Child process identifier  */
; 1586 : int             open_flags;             /* File open flags           */
; 1587 : #if !defined( _MSVC_ )
; 1588 : int             pipefd[2];              /* Pipe descriptors          */
; 1589 : #endif
; 1590 : int             rc;                     /* Return code               */
; 1591 : off_t           filesize = 0;           /* file size for ftruncate   */

  0000c	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR filesize$[rsp], 0

; 1592 : 
; 1593 :     /* Regular open if 1st char of filename is not vertical bar */
; 1594 :     if (!dev->ispiped)

  00018	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00020	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  00026	d1 e8		 shr	 eax, 1
  00028	83 e0 01	 and	 eax, 1
  0002b	85 c0		 test	 eax, eax
  0002d	0f 85 ef 02 00
	00		 jne	 $LN5@open_print

; 1595 :     {
; 1596 :         int    fd;
; 1597 : 
; 1598 :         /* Socket printer? */
; 1599 :         if (dev->bs)

  00033	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  00043	74 2c		 je	 SHORT $LN6@open_print

; 1600 :             return (dev->fd < 0 ? -1 : 0);

  00045	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004d	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00054	7d 0a		 jge	 SHORT $LN13@open_print
  00056	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR tv72[rsp], -1
  0005e	eb 08		 jmp	 SHORT $LN14@open_print
$LN13@open_print:
  00060	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN14@open_print:
  00068	8b 44 24 6c	 mov	 eax, DWORD PTR tv72[rsp]
  0006c	e9 b1 04 00 00	 jmp	 $LN1@open_print
$LN6@open_print:

; 1601 : 
; 1602 :         /* Normal printer */
; 1603 :         open_flags = O_BINARY | O_WRONLY | O_CREAT /* | O_SYNC */;

  00071	c7 44 24 60 01
	81 00 00	 mov	 DWORD PTR open_flags$[rsp], 33025 ; 00008101H

; 1604 : 
; 1605 :         if (!dev->append)

  00079	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00081	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00087	83 e0 01	 and	 eax, 1
  0008a	85 c0		 test	 eax, eax
  0008c	75 0c		 jne	 SHORT $LN7@open_print

; 1606 :             open_flags |= O_TRUNC;

  0008e	8b 44 24 60	 mov	 eax, DWORD PTR open_flags$[rsp]
  00092	0f ba e8 09	 bts	 eax, 9
  00096	89 44 24 60	 mov	 DWORD PTR open_flags$[rsp], eax
$LN7@open_print:

; 1607 : 
; 1608 :         if ((fd = HOPEN( dev->filename, open_flags, S_IRUSR | S_IWUSR | S_IRGRP )) < 0)

  0009a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a2	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  000a8	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  000ae	8b 54 24 60	 mov	 edx, DWORD PTR open_flags$[rsp]
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  000bb	89 44 24 64	 mov	 DWORD PTR fd$1[rsp], eax
  000bf	83 7c 24 64 00	 cmp	 DWORD PTR fd$1[rsp], 0
  000c4	0f 8d e8 00 00
	00		 jge	 $LN8@open_print

; 1609 :         {
; 1610 :             // "%1d:%04X %s: error in function %s: %s"
; 1611 :             WRMSG( HHC01250, "E", LCSS_DEVNUM,

  000ca	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000d3	74 12		 je	 SHORT $LN15@open_print
  000d5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000dd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000e1	89 44 24 70	 mov	 DWORD PTR tv92[rsp], eax
  000e5	eb 08		 jmp	 SHORT $LN16@open_print
$LN15@open_print:
  000e7	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN16@open_print:
  000ef	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000f8	74 14		 je	 SHORT $LN17@open_print
  000fa	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00102	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00106	d1 f8		 sar	 eax, 1
  00108	89 44 24 74	 mov	 DWORD PTR tv130[rsp], eax
  0010c	eb 08		 jmp	 SHORT $LN18@open_print
$LN17@open_print:
  0010e	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN18@open_print:
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0011c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00124	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv83[rsp], rax
  0012c	b9 01 00 00 00	 mov	 ecx, 1
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00137	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv83[rsp]
  0013f	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168876
  0014b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168877
  00157	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0015c	8b 4c 24 70	 mov	 ecx, DWORD PTR tv92[rsp]
  00160	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00164	8b 4c 24 74	 mov	 ecx, DWORD PTR tv130[rsp]
  00168	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168878
  00173	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00178	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168879
  0017f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00184	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00189	41 b9 03 00 00
	00		 mov	 r9d, 3
  0018f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168880
  00196	ba 4c 06 00 00	 mov	 edx, 1612		; 0000064cH
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168881
  001a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1612 :                 "Printer", "HOPEN()", strerror( errno ));
; 1613 :             return -1;

  001a8	b8 ff ff ff ff	 mov	 eax, -1
  001ad	e9 70 03 00 00	 jmp	 $LN1@open_print
$LN8@open_print:

; 1614 :         }
; 1615 : 
; 1616 :         if (dev->append)

  001b2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ba	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001c0	83 e0 01	 and	 eax, 1
  001c3	85 c0		 test	 eax, eax
  001c5	0f 84 11 01 00
	00		 je	 $LN9@open_print

; 1617 :         {
; 1618 :             if ((filesize = lseek( fd, 0, SEEK_END )) < 0)

  001cb	41 b8 02 00 00
	00		 mov	 r8d, 2
  001d1	33 d2		 xor	 edx, edx
  001d3	8b 4c 24 64	 mov	 ecx, DWORD PTR fd$1[rsp]
  001d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  001dd	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR filesize$[rsp], rax
  001e5	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR filesize$[rsp], 0
  001ee	0f 8d e8 00 00
	00		 jge	 $LN10@open_print

; 1619 :             {
; 1620 :                 // "%1d:%04X %s: error in function %s: %s"
; 1621 :                 WRMSG( HHC01250, "E", LCSS_DEVNUM,

  001f4	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001fd	74 12		 je	 SHORT $LN19@open_print
  001ff	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00207	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0020b	89 44 24 78	 mov	 DWORD PTR tv158[rsp], eax
  0020f	eb 08		 jmp	 SHORT $LN20@open_print
$LN19@open_print:
  00211	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
$LN20@open_print:
  00219	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00222	74 14		 je	 SHORT $LN21@open_print
  00224	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0022c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00230	d1 f8		 sar	 eax, 1
  00232	89 44 24 7c	 mov	 DWORD PTR tv164[rsp], eax
  00236	eb 08		 jmp	 SHORT $LN22@open_print
$LN21@open_print:
  00238	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv164[rsp], 0
$LN22@open_print:
  00240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00246	8b 08		 mov	 ecx, DWORD PTR [rax]
  00248	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0024e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv149[rsp], rax
  00256	b9 01 00 00 00	 mov	 ecx, 1
  0025b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00261	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv149[rsp]
  00269	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0026e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168884
  00275	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0027a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168885
  00281	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00286	8b 4c 24 78	 mov	 ecx, DWORD PTR tv158[rsp]
  0028a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0028e	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv164[rsp]
  00292	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168886
  0029d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168887
  002a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  002b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168888
  002c0	ba 56 06 00 00	 mov	 edx, 1622		; 00000656H
  002c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168889
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1622 :                     "Printer", "lseek()", strerror( errno ));
; 1623 :                 return -1;

  002d2	b8 ff ff ff ff	 mov	 eax, -1
  002d7	e9 46 02 00 00	 jmp	 $LN1@open_print
$LN10@open_print:
$LN9@open_print:

; 1624 :             }
; 1625 :         }
; 1626 : 
; 1627 :         /* Save file descriptor in device block and return */
; 1628 :         dev->fd = fd;

  002dc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002e4	8b 4c 24 64	 mov	 ecx, DWORD PTR fd$1[rsp]
  002e8	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx
$LN4@open_print:

; 1629 : 
; 1630 :         /* Set new physical EOF */
; 1631 :         do rc = ftruncate( dev->fd, filesize );

  002ee	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR filesize$[rsp]
  002f6	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002fe	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00304	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__chsize_s
  0030a	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1632 :         while (EINTR == rc);

  00311	83 bc 24 90 00
	00 00 04	 cmp	 DWORD PTR rc$[rsp], 4
  00319	74 d3		 je	 SHORT $LN4@open_print

; 1633 : 
; 1634 :         return 0;

  0031b	33 c0		 xor	 eax, eax
  0031d	e9 00 02 00 00	 jmp	 $LN1@open_print
$LN5@open_print:

; 1635 :     }
; 1636 : 
; 1637 :     /* Filename is in format |xxx, set up pipe to program xxx */
; 1638 : 
; 1639 : #if defined( _MSVC_ )
; 1640 : 
; 1641 :     /* "Poor man's" fork... */
; 1642 :     pid = w32_poor_mans_fork ( dev->filename+1, &dev->fd );

  00322	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0032a	48 05 ac 01 00
	00		 add	 rax, 428		; 000001acH
  00330	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00338	48 81 c1 a5 00
	00 00		 add	 rcx, 165		; 000000a5H
  0033f	48 8b d0	 mov	 rdx, rax
  00342	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_poor_mans_fork
  00348	89 44 24 68	 mov	 DWORD PTR pid$[rsp], eax

; 1643 :     if (pid < 0)

  0034c	83 7c 24 68 00	 cmp	 DWORD PTR pid$[rsp], 0
  00351	0f 8d fa 00 00
	00		 jge	 $LN11@open_print

; 1644 :     {
; 1645 :         // "%1d:%04X %s: error in function %s: %s"
; 1646 :         WRMSG( HHC01250, "E", LCSS_DEVNUM,

  00357	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00360	74 15		 je	 SHORT $LN23@open_print
  00362	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0036a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0036e	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv197[rsp], eax
  00375	eb 0b		 jmp	 SHORT $LN24@open_print
$LN23@open_print:
  00377	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv197[rsp], 0
$LN24@open_print:
  00382	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0038b	74 17		 je	 SHORT $LN25@open_print
  0038d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00395	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00399	d1 f8		 sar	 eax, 1
  0039b	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv203[rsp], eax
  003a2	eb 0b		 jmp	 SHORT $LN26@open_print
$LN25@open_print:
  003a4	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv203[rsp], 0
$LN26@open_print:
  003af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003b5	8b 08		 mov	 ecx, DWORD PTR [rax]
  003b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  003bd	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv188[rsp], rax
  003c5	b9 01 00 00 00	 mov	 ecx, 1
  003ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003d0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv188[rsp]
  003d8	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  003dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168891
  003e4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  003e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168892
  003f0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003f5	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv197[rsp]
  003fc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00400	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv203[rsp]
  00407	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0040b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168893
  00412	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00417	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168894
  0041e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00423	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00428	41 b9 03 00 00
	00		 mov	 r9d, 3
  0042e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168895
  00435	ba 6f 06 00 00	 mov	 edx, 1647		; 0000066fH
  0043a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168896
  00441	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1647 :             "Printer", "fork()", strerror( errno ));
; 1648 :         return -1;

  00447	b8 ff ff ff ff	 mov	 eax, -1
  0044c	e9 d1 00 00 00	 jmp	 $LN1@open_print
$LN11@open_print:

; 1649 :     }
; 1650 : 
; 1651 :     // "%1d:%04X Printer: pipe receiver with pid %d starting"
; 1652 :     WRMSG( HHC01106, "I", LCSS_DEVNUM, pid );

  00451	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0045a	74 15		 je	 SHORT $LN27@open_print
  0045c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00464	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00468	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv218[rsp], eax
  0046f	eb 0b		 jmp	 SHORT $LN28@open_print
$LN27@open_print:
  00471	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv218[rsp], 0
$LN28@open_print:
  0047c	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00485	74 17		 je	 SHORT $LN29@open_print
  00487	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0048f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00493	d1 f8		 sar	 eax, 1
  00495	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv224[rsp], eax
  0049c	eb 0b		 jmp	 SHORT $LN30@open_print
$LN29@open_print:
  0049e	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv224[rsp], 0
$LN30@open_print:
  004a9	b9 01 00 00 00	 mov	 ecx, 1
  004ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004b4	8b 4c 24 68	 mov	 ecx, DWORD PTR pid$[rsp]
  004b8	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  004bc	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv218[rsp]
  004c3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004c7	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv224[rsp]
  004ce	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168897
  004d9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168898
  004e5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004ea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ef	41 b9 03 00 00
	00		 mov	 r9d, 3
  004f5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168899
  004fc	ba 74 06 00 00	 mov	 edx, 1652		; 00000674H
  00501	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168900
  00508	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1653 :     dev->ptpcpid = pid;

  0050e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00516	8b 4c 24 68	 mov	 ecx, DWORD PTR pid$[rsp]
  0051a	89 88 80 07 00
	00		 mov	 DWORD PTR [rax+1920], ecx

; 1654 : 
; 1655 : #else /* !defined( _MSVC_ ) */
; 1656 : 
; 1657 :     /* Create a pipe */
; 1658 :     if ((rc = create_pipe( pipefd )) < 0)
; 1659 :     {
; 1660 :         // "%1d:%04X %s: error in function %s: %s"
; 1661 :         WRMSG( HHC01250, "E", LCSS_DEVNUM,
; 1662 :             "Printer", "create_pipe()", strerror( errno ));
; 1663 :         return -1;
; 1664 :     }
; 1665 : 
; 1666 :     /* Fork a child process to receive the pipe data */
; 1667 :     if ((pid = fork()) < 0)
; 1668 :     {
; 1669 :         // "%1d:%04X COMM: outgoing call failed during %s command: %s"
; 1670 :         WRMSG( HHC01005, "E", LCSS_DEVNUM,
; 1671 :             "fork()", strerror( errno ));
; 1672 :         close_pipe( pipefd[0] );
; 1673 :         close_pipe( pipefd[1] );
; 1674 :         return -1;
; 1675 :     }
; 1676 : 
; 1677 :     /* The child process executes the pipe receiver program... */
; 1678 :     if (pid == 0)
; 1679 :     {
; 1680 :         // "%1d:%04X Printer: pipe receiver with pid %d starting"
; 1681 :         WRMSG( HHC01106, "I", LCSS_DEVNUM, getpid() );
; 1682 : 
; 1683 :         /* Close the write end of the pipe */
; 1684 :         close_pipe( pipefd[1] );
; 1685 : 
; 1686 :         /* Duplicate the read end of the pipe onto STDIN */
; 1687 :         if (pipefd[0] != STDIN_FILENO)
; 1688 :         {
; 1689 :             if ((rc = dup2( pipefd[0], STDIN_FILENO )) != STDIN_FILENO)
; 1690 :             {
; 1691 :                 // "%1d:%04X %s: error in function %s: %s"
; 1692 :                 WRMSG( HHC01250, "E", LCSS_DEVNUM,
; 1693 :                     "Printer", "dup2()", strerror( errno ));
; 1694 :                 close_pipe( pipefd[0] );
; 1695 :                 _exit( 127 );
; 1696 :             }
; 1697 :         } /* end if (pipefd[0] != STDIN_FILENO) */
; 1698 : 
; 1699 :         /* Close the original descriptor now duplicated to STDIN */
; 1700 :         close_pipe( pipefd[0] );
; 1701 : 
; 1702 :         /* Redirect stderr (screen) to hercules log task */
; 1703 :         dup2( STDOUT_FILENO, STDERR_FILENO );
; 1704 : 
; 1705 :         /* Relinquish any ROOT authority before calling shell */
; 1706 :         SETMODE( TERM );
; 1707 : 
; 1708 :         /* Execute the specified pipe receiver program */
; 1709 :         rc = system( dev->filename+1 );
; 1710 : 
; 1711 :         if (rc == 0)
; 1712 :         {
; 1713 :             // "%1d:%04X Printer: pipe receiver with pid %d terminating"
; 1714 :             WRMSG( HHC01107, "I", LCSS_DEVNUM,
; 1715 :                 getpid() );
; 1716 :         }
; 1717 :         else
; 1718 :         {
; 1719 :             // "%1d:%04X Printer: unable to execute file %s: %s"
; 1720 :             WRMSG( HHC01108, "E", LCSS_DEVNUM,
; 1721 :                 dev->filename+1, strerror( errno ));
; 1722 :         }
; 1723 : 
; 1724 :         /* The child process terminates using _exit instead of exit
; 1725 :            to avoid invoking the panel atexit cleanup routine */
; 1726 :         _exit( rc );
; 1727 : 
; 1728 :     } /* end if (pid == 0) */
; 1729 : 
; 1730 :     /* The parent process continues as the pipe sender */
; 1731 : 
; 1732 :     /* Close the read end of the pipe */
; 1733 :     close_pipe( pipefd[0] );
; 1734 : 
; 1735 :     /* Save pipe write descriptor in the device block */
; 1736 :     dev->fd = pipefd[1];
; 1737 :     dev->ptpcpid = pid;
; 1738 : 
; 1739 : #endif /* defined( _MSVC_ ) */
; 1740 : 
; 1741 :     return 0;

  00520	33 c0		 xor	 eax, eax
$LN1@open_print:

; 1742 : 
; 1743 : } /* end function open_printer */

  00522	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00529	c3		 ret	 0
open_printer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
tv71 = 160
tv79 = 168
tv87 = 176
tv95 = 184
tv135 = 192
tv143 = 200
tv151 = 208
tv159 = 216
tv167 = 224
tv175 = 232
tv183 = 240
tv191 = 248
tv199 = 256
tv207 = 264
tv215 = 272
tv223 = 280
dev$ = 304
buf$ = 312
bufsz$ = 320
format_sense PROC

; 900  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H

; 901  :     snprintf( buf, bufsz, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	48 6b c0 01	 imul	 rax, rax, 1
  0001f	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00027	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  0002f	83 e0 01	 and	 eax, 1
  00032	85 c0		 test	 eax, eax
  00034	74 11		 je	 SHORT $LN3@format_sen
  00036	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168508
  0003d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv71[rsp], rax
  00045	eb 0f		 jmp	 SHORT $LN4@format_sen
$LN3@format_sen:
  00047	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168509
  0004e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv71[rsp], rax
$LN4@format_sen:
  00056	b8 01 00 00 00	 mov	 eax, 1
  0005b	48 6b c0 01	 imul	 rax, rax, 1
  0005f	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00067	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  0006f	83 e0 02	 and	 eax, 2
  00072	85 c0		 test	 eax, eax
  00074	74 11		 je	 SHORT $LN5@format_sen
  00076	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168510
  0007d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
  00085	eb 0f		 jmp	 SHORT $LN6@format_sen
$LN5@format_sen:
  00087	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168511
  0008e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
$LN6@format_sen:
  00096	b8 01 00 00 00	 mov	 eax, 1
  0009b	48 6b c0 01	 imul	 rax, rax, 1
  0009f	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a7	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  000af	83 e0 04	 and	 eax, 4
  000b2	85 c0		 test	 eax, eax
  000b4	74 11		 je	 SHORT $LN7@format_sen
  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168512
  000bd	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv87[rsp], rax
  000c5	eb 0f		 jmp	 SHORT $LN8@format_sen
$LN7@format_sen:
  000c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168513
  000ce	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv87[rsp], rax
$LN8@format_sen:
  000d6	b8 01 00 00 00	 mov	 eax, 1
  000db	48 6b c0 01	 imul	 rax, rax, 1
  000df	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000e7	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  000ef	83 e0 08	 and	 eax, 8
  000f2	85 c0		 test	 eax, eax
  000f4	74 11		 je	 SHORT $LN9@format_sen
  000f6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168514
  000fd	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv95[rsp], rax
  00105	eb 0f		 jmp	 SHORT $LN10@format_sen
$LN9@format_sen:
  00107	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168515
  0010e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv95[rsp], rax
$LN10@format_sen:
  00116	b8 01 00 00 00	 mov	 eax, 1
  0011b	48 6b c0 01	 imul	 rax, rax, 1
  0011f	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00127	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  0012f	83 e0 10	 and	 eax, 16
  00132	85 c0		 test	 eax, eax
  00134	74 11		 je	 SHORT $LN11@format_sen
  00136	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168516
  0013d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
  00145	eb 0f		 jmp	 SHORT $LN12@format_sen
$LN11@format_sen:
  00147	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168517
  0014e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
$LN12@format_sen:
  00156	b8 01 00 00 00	 mov	 eax, 1
  0015b	48 6b c0 01	 imul	 rax, rax, 1
  0015f	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00167	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  0016f	83 e0 20	 and	 eax, 32			; 00000020H
  00172	85 c0		 test	 eax, eax
  00174	74 11		 je	 SHORT $LN13@format_sen
  00176	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168518
  0017d	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv143[rsp], rax
  00185	eb 0f		 jmp	 SHORT $LN14@format_sen
$LN13@format_sen:
  00187	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168519
  0018e	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv143[rsp], rax
$LN14@format_sen:
  00196	b8 01 00 00 00	 mov	 eax, 1
  0019b	48 6b c0 01	 imul	 rax, rax, 1
  0019f	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a7	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  001af	83 e0 40	 and	 eax, 64			; 00000040H
  001b2	85 c0		 test	 eax, eax
  001b4	74 11		 je	 SHORT $LN15@format_sen
  001b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168520
  001bd	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv151[rsp], rax
  001c5	eb 0f		 jmp	 SHORT $LN16@format_sen
$LN15@format_sen:
  001c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168521
  001ce	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv151[rsp], rax
$LN16@format_sen:
  001d6	b8 01 00 00 00	 mov	 eax, 1
  001db	48 6b c0 01	 imul	 rax, rax, 1
  001df	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001e7	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  001ef	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001f4	85 c0		 test	 eax, eax
  001f6	74 11		 je	 SHORT $LN17@format_sen
  001f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168522
  001ff	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv159[rsp], rax
  00207	eb 0f		 jmp	 SHORT $LN18@format_sen
$LN17@format_sen:
  00209	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168523
  00210	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv159[rsp], rax
$LN18@format_sen:
  00218	b8 01 00 00 00	 mov	 eax, 1
  0021d	48 6b c0 00	 imul	 rax, rax, 0
  00221	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00229	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  00231	83 e0 01	 and	 eax, 1
  00234	85 c0		 test	 eax, eax
  00236	74 11		 je	 SHORT $LN19@format_sen
  00238	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168524
  0023f	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv167[rsp], rax
  00247	eb 0f		 jmp	 SHORT $LN20@format_sen
$LN19@format_sen:
  00249	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168525
  00250	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv167[rsp], rax
$LN20@format_sen:
  00258	b8 01 00 00 00	 mov	 eax, 1
  0025d	48 6b c0 00	 imul	 rax, rax, 0
  00261	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00269	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  00271	83 e0 02	 and	 eax, 2
  00274	85 c0		 test	 eax, eax
  00276	74 11		 je	 SHORT $LN21@format_sen
  00278	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168526
  0027f	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv175[rsp], rax
  00287	eb 0f		 jmp	 SHORT $LN22@format_sen
$LN21@format_sen:
  00289	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168527
  00290	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv175[rsp], rax
$LN22@format_sen:
  00298	b8 01 00 00 00	 mov	 eax, 1
  0029d	48 6b c0 00	 imul	 rax, rax, 0
  002a1	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002a9	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  002b1	83 e0 04	 and	 eax, 4
  002b4	85 c0		 test	 eax, eax
  002b6	74 11		 je	 SHORT $LN23@format_sen
  002b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168528
  002bf	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv183[rsp], rax
  002c7	eb 0f		 jmp	 SHORT $LN24@format_sen
$LN23@format_sen:
  002c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168529
  002d0	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv183[rsp], rax
$LN24@format_sen:
  002d8	b8 01 00 00 00	 mov	 eax, 1
  002dd	48 6b c0 00	 imul	 rax, rax, 0
  002e1	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e9	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  002f1	83 e0 08	 and	 eax, 8
  002f4	85 c0		 test	 eax, eax
  002f6	74 11		 je	 SHORT $LN25@format_sen
  002f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168530
  002ff	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv191[rsp], rax
  00307	eb 0f		 jmp	 SHORT $LN26@format_sen
$LN25@format_sen:
  00309	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168531
  00310	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv191[rsp], rax
$LN26@format_sen:
  00318	b8 01 00 00 00	 mov	 eax, 1
  0031d	48 6b c0 00	 imul	 rax, rax, 0
  00321	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00329	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  00331	83 e0 10	 and	 eax, 16
  00334	85 c0		 test	 eax, eax
  00336	74 11		 je	 SHORT $LN27@format_sen
  00338	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168532
  0033f	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv199[rsp], rax
  00347	eb 0f		 jmp	 SHORT $LN28@format_sen
$LN27@format_sen:
  00349	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168533
  00350	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv199[rsp], rax
$LN28@format_sen:
  00358	b8 01 00 00 00	 mov	 eax, 1
  0035d	48 6b c0 00	 imul	 rax, rax, 0
  00361	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00369	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  00371	83 e0 20	 and	 eax, 32			; 00000020H
  00374	85 c0		 test	 eax, eax
  00376	74 11		 je	 SHORT $LN29@format_sen
  00378	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168534
  0037f	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv207[rsp], rax
  00387	eb 0f		 jmp	 SHORT $LN30@format_sen
$LN29@format_sen:
  00389	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168535
  00390	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv207[rsp], rax
$LN30@format_sen:
  00398	b8 01 00 00 00	 mov	 eax, 1
  0039d	48 6b c0 00	 imul	 rax, rax, 0
  003a1	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003a9	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  003b1	83 e0 40	 and	 eax, 64			; 00000040H
  003b4	85 c0		 test	 eax, eax
  003b6	74 11		 je	 SHORT $LN31@format_sen
  003b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168536
  003bf	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv215[rsp], rax
  003c7	eb 0f		 jmp	 SHORT $LN32@format_sen
$LN31@format_sen:
  003c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168537
  003d0	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv215[rsp], rax
$LN32@format_sen:
  003d8	b8 01 00 00 00	 mov	 eax, 1
  003dd	48 6b c0 00	 imul	 rax, rax, 0
  003e1	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003e9	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  003f1	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003f6	85 c0		 test	 eax, eax
  003f8	74 11		 je	 SHORT $LN33@format_sen
  003fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168538
  00401	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv223[rsp], rax
  00409	eb 0f		 jmp	 SHORT $LN34@format_sen
$LN33@format_sen:
  0040b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168539
  00412	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv223[rsp], rax
$LN34@format_sen:
  0041a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv71[rsp]
  00422	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rax
  0042a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv79[rsp]
  00432	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rax
  0043a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv87[rsp]
  00442	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rax
  0044a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv95[rsp]
  00452	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  00457	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv135[rsp]
  0045f	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00464	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv143[rsp]
  0046c	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  00471	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv151[rsp]
  00479	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  0047e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv159[rsp]
  00486	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0048b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv167[rsp]
  00493	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00498	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv175[rsp]
  004a0	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  004a5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv183[rsp]
  004ad	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  004b2	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv191[rsp]
  004ba	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  004bf	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR tv199[rsp]
  004c7	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  004cc	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv207[rsp]
  004d4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004d9	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv215[rsp]
  004e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004e6	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR tv223[rsp]
  004ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168540
  004f5	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR bufsz$[rsp]
  004fd	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00505	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 902  : 
; 903  :         , (dev->sense[0] & SENSE_CR   ) ? "CMDREJ " : ""
; 904  :         , (dev->sense[0] & SENSE_IR   ) ? "INTREQ " : ""
; 905  :         , (dev->sense[0] & SENSE_BOC  ) ? "BUSCK "  : ""
; 906  :         , (dev->sense[0] & SENSE_EC   ) ? "EQPCK "  : ""
; 907  :         , (dev->sense[0] & SENSE_DC   ) ? "DATAC "  : ""
; 908  :         , (dev->sense[0] & SENSE_OR   ) ? "OVRUN "  : ""
; 909  :         , (dev->sense[0] & SENSE_LDCK ) ? "LOADCK " : ""
; 910  :         , (dev->sense[0] & SENSE_CH9  ) ? "CHAN9 "  : ""
; 911  : 
; 912  :         , (dev->sense[1] & SENSE1_PER ) ? "--- "    : ""
; 913  :         , (dev->sense[1] & SENSE1_PRTC) ? "PRTCK "  : ""
; 914  :         , (dev->sense[1] & SENSE1_QUAL) ? "QUAL "   : ""
; 915  :         , (dev->sense[1] & SENSE1_LPC ) ? "POSCK "  : ""
; 916  :         , (dev->sense[1] & SENSE1_FORM) ? "FORMCK " : ""
; 917  :         , (dev->sense[1] & SENSE1_CS  ) ? "CMDSUP " : ""
; 918  :         , (dev->sense[1] & SENSE1_MECH) ? "MECHM "  : ""
; 919  :         , (dev->sense[1] & SENSE1_IE  ) ? "--- "    : ""
; 920  :     );
; 921  : }

  0050b	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00512	c3		 ret	 0
format_sense ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
line$ = 80
chanstops$ = 84
tv67 = 88
fcbsize$ = 92
tv79 = 96
tv83 = 100
tv131 = 104
tv135 = 108
dev$ = 128
valid_fcb PROC

; 854  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 855  :     int line;
; 856  :     int fcbsize = FCBSIZE( dev );

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00011	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00015	3d 11 32 00 00	 cmp	 eax, 12817		; 00003211H
  0001a	75 0a		 jne	 SHORT $LN9@valid_fcb
  0001c	c7 44 24 58 b4
	00 00 00	 mov	 DWORD PTR tv67[rsp], 180 ; 000000b4H
  00024	eb 08		 jmp	 SHORT $LN10@valid_fcb
$LN9@valid_fcb:
  00026	c7 44 24 58 00
	01 00 00	 mov	 DWORD PTR tv67[rsp], 256 ; 00000100H
$LN10@valid_fcb:
  0002e	8b 44 24 58	 mov	 eax, DWORD PTR tv67[rsp]
  00032	89 44 24 5c	 mov	 DWORD PTR fcbsize$[rsp], eax

; 857  :     int chanstops = MAX_CHAN_STOPS;

  00036	c7 44 24 54 1e
	00 00 00	 mov	 DWORD PTR chanstops$[rsp], 30

; 858  : 
; 859  :     /* PROGRAMMING NOTE: we cannot use dev->lpp for the exit condition
; 860  :        because we need to always scan the entire fcb since they might
; 861  :        have defined channel stops defined beyond the dev->lpp entry,
; 862  :        which is one of the very conditions we're supposed to detect.
; 863  :     */
; 864  :     for (line=1; line < fcbsize; line++)

  0003e	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR line$[rsp], 1
  00046	eb 0a		 jmp	 SHORT $LN4@valid_fcb
$LN2@valid_fcb:
  00048	8b 44 24 50	 mov	 eax, DWORD PTR line$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 50	 mov	 DWORD PTR line$[rsp], eax
$LN4@valid_fcb:
  00052	8b 44 24 5c	 mov	 eax, DWORD PTR fcbsize$[rsp]
  00056	39 44 24 50	 cmp	 DWORD PTR line$[rsp], eax
  0005a	0f 8d 68 01 00
	00		 jge	 $LN3@valid_fcb

; 865  :     {
; 866  :         if (!dev->fcb[ line ])

  00060	48 63 44 24 50	 movsxd	 rax, DWORD PTR line$[rsp]
  00065	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0006d	83 bc 81 94 07
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+1940], 0
  00075	75 02		 jne	 SHORT $LN5@valid_fcb

; 867  :             continue;

  00077	eb cf		 jmp	 SHORT $LN2@valid_fcb
$LN5@valid_fcb:

; 868  : 
; 869  :         if (line > dev->lpp)

  00079	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00081	8b 80 90 07 00
	00		 mov	 eax, DWORD PTR [rax+1936]
  00087	39 44 24 50	 cmp	 DWORD PTR line$[rsp], eax
  0008b	0f 8e 8c 00 00
	00		 jle	 $LN6@valid_fcb

; 870  :         {
; 871  :             // "%1d:%04X Printer: incompatible '%s' and 'lpp' values detected"
; 872  :             WRMSG( HHC01113, "E", SSID_TO_LCSS( dev->ssid ),

  00091	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0009d	89 44 24 60	 mov	 DWORD PTR tv79[rsp], eax
  000a1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a9	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  000ad	d1 f9		 sar	 ecx, 1
  000af	89 4c 24 64	 mov	 DWORD PTR tv83[rsp], ecx
  000b3	b9 01 00 00 00	 mov	 ecx, 1
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168490
  000c5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000ca	8b 4c 24 60	 mov	 ecx, DWORD PTR tv79[rsp]
  000ce	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000d2	8b 4c 24 64	 mov	 ecx, DWORD PTR tv83[rsp]
  000d6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168491
  000e1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168492
  000ed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168493
  00104	ba 69 03 00 00	 mov	 edx, 873		; 00000369H
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168494
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 873  :                 dev->devnum, "fcb" );
; 874  :             return FALSE;

  00116	32 c0		 xor	 al, al
  00118	e9 ad 00 00 00	 jmp	 $LN1@valid_fcb
$LN6@valid_fcb:

; 875  :         }
; 876  : 
; 877  :         /* PROGRAMMING NOTE: a maximum of 30 channel codes can be
; 878  :            specified if the end of sheet is not coded in the same
; 879  :            byte as a channel code; a maximum of 31 channel codes
; 880  :            can be specified if the end of sheet code is coded in
; 881  :            the same byte as a channel code. Thus we only decrement
; 882  :            our counter if this is not the last line.
; 883  :         */
; 884  :         if (line != dev->lpp && --chanstops < 0)

  0011d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00125	8b 80 90 07 00
	00		 mov	 eax, DWORD PTR [rax+1936]
  0012b	39 44 24 50	 cmp	 DWORD PTR line$[rsp], eax
  0012f	0f 84 8e 00 00
	00		 je	 $LN7@valid_fcb
  00135	8b 44 24 54	 mov	 eax, DWORD PTR chanstops$[rsp]
  00139	ff c8		 dec	 eax
  0013b	89 44 24 54	 mov	 DWORD PTR chanstops$[rsp], eax
  0013f	83 7c 24 54 00	 cmp	 DWORD PTR chanstops$[rsp], 0
  00144	7d 7d		 jge	 SHORT $LN7@valid_fcb

; 885  :         {
; 886  :             // "%1d:%04X Printer: invalid fcb: maximum channel codes exceeded"
; 887  :             WRMSG( HHC01112, "E", SSID_TO_LCSS( dev->ssid ),

  00146	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00152	89 44 24 68	 mov	 DWORD PTR tv131[rsp], eax
  00156	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0015e	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00162	d1 f9		 sar	 ecx, 1
  00164	89 4c 24 6c	 mov	 DWORD PTR tv135[rsp], ecx
  00168	b9 01 00 00 00	 mov	 ecx, 1
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00173	8b 4c 24 68	 mov	 ecx, DWORD PTR tv131[rsp]
  00177	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0017b	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv135[rsp]
  0017f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168496
  0018a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0018f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168497
  00196	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0019b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a0	41 b9 03 00 00
	00		 mov	 r9d, 3
  001a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168498
  001ad	ba 78 03 00 00	 mov	 edx, 888		; 00000378H
  001b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168499
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 888  :                 dev->devnum );
; 889  :             return FALSE;

  001bf	32 c0		 xor	 al, al
  001c1	eb 07		 jmp	 SHORT $LN1@valid_fcb
$LN7@valid_fcb:

; 890  :         }
; 891  :     }

  001c3	e9 80 fe ff ff	 jmp	 $LN2@valid_fcb
$LN3@valid_fcb:

; 892  : 
; 893  :     return TRUE;

  001c8	b0 01		 mov	 al, 1
$LN1@valid_fcb:

; 894  : }

  001ca	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001ce	c3		 ret	 0
valid_fcb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
line$ = 80
tv67 = 84
cctape_size$ = 88
tv81 = 92
tv85 = 96
dev$ = 128
valid_cctape PROC

; 824  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 825  :     int line;
; 826  :     int cctape_size = FCBSIZE( dev );

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00011	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00015	3d 11 32 00 00	 cmp	 eax, 12817		; 00003211H
  0001a	75 0a		 jne	 SHORT $LN8@valid_ccta
  0001c	c7 44 24 54 b4
	00 00 00	 mov	 DWORD PTR tv67[rsp], 180 ; 000000b4H
  00024	eb 08		 jmp	 SHORT $LN9@valid_ccta
$LN8@valid_ccta:
  00026	c7 44 24 54 00
	01 00 00	 mov	 DWORD PTR tv67[rsp], 256 ; 00000100H
$LN9@valid_ccta:
  0002e	8b 44 24 54	 mov	 eax, DWORD PTR tv67[rsp]
  00032	89 44 24 58	 mov	 DWORD PTR cctape_size$[rsp], eax

; 827  : 
; 828  :     /* PROGRAMMING NOTE: we cannot use dev->lpp for the exit condition
; 829  :        since we need to always scan the entire cctape since they might
; 830  :        have defined channel stops beyond the dev->lpp entry, which is
; 831  :        the very condition we're supposed to detect.
; 832  :     */
; 833  :     for (line=0; line < cctape_size; line++)

  00036	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR line$[rsp], 0
  0003e	eb 0a		 jmp	 SHORT $LN4@valid_ccta
$LN2@valid_ccta:
  00040	8b 44 24 50	 mov	 eax, DWORD PTR line$[rsp]
  00044	ff c0		 inc	 eax
  00046	89 44 24 50	 mov	 DWORD PTR line$[rsp], eax
$LN4@valid_ccta:
  0004a	8b 44 24 58	 mov	 eax, DWORD PTR cctape_size$[rsp]
  0004e	39 44 24 50	 cmp	 DWORD PTR line$[rsp], eax
  00052	0f 8d c3 00 00
	00		 jge	 $LN3@valid_ccta

; 834  :     {
; 835  :         if (!dev->cctape[ line ])

  00058	48 63 44 24 50	 movsxd	 rax, DWORD PTR line$[rsp]
  0005d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00065	0f b7 84 41 a0
	0b 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+2976]
  0006d	85 c0		 test	 eax, eax
  0006f	75 02		 jne	 SHORT $LN5@valid_ccta

; 836  :             continue;

  00071	eb cd		 jmp	 SHORT $LN2@valid_ccta
$LN5@valid_ccta:

; 837  : 
; 838  :         if ((line+1) > dev->lpp)

  00073	8b 44 24 50	 mov	 eax, DWORD PTR line$[rsp]
  00077	ff c0		 inc	 eax
  00079	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00081	3b 81 90 07 00
	00		 cmp	 eax, DWORD PTR [rcx+1936]
  00087	0f 8e 89 00 00
	00		 jle	 $LN6@valid_ccta

; 839  :         {
; 840  :             // "%1d:%04X Printer: incompatible '%s' and 'lpp' values detected"
; 841  :             WRMSG( HHC01113, "E", SSID_TO_LCSS( dev->ssid ),

  0008d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00095	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00099	89 44 24 5c	 mov	 DWORD PTR tv81[rsp], eax
  0009d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a5	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  000a9	d1 f9		 sar	 ecx, 1
  000ab	89 4c 24 60	 mov	 DWORD PTR tv85[rsp], ecx
  000af	b9 01 00 00 00	 mov	 ecx, 1
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168473
  000c1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000c6	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv81[rsp]
  000ca	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000ce	8b 4c 24 60	 mov	 ecx, DWORD PTR tv85[rsp]
  000d2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168474
  000dd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168475
  000e9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f3	41 b9 03 00 00
	00		 mov	 r9d, 3
  000f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168476
  00100	ba 4a 03 00 00	 mov	 edx, 842		; 0000034aH
  00105	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168477
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 842  :                 dev->devnum, "cctape" );
; 843  :             return FALSE;

  00112	32 c0		 xor	 al, al
  00114	eb 07		 jmp	 SHORT $LN1@valid_ccta
$LN6@valid_ccta:

; 844  :         }
; 845  :     }

  00116	e9 25 ff ff ff	 jmp	 $LN2@valid_ccta
$LN3@valid_ccta:

; 846  : 
; 847  :     return TRUE;

  0011b	b0 01		 mov	 al, 1
$LN1@valid_ccta:

; 848  : }

  0011d	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00121	c3		 ret	 0
valid_cctape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
ucbsize$ = 0
tv70 = 4
tv71 = 8
tv74 = 12
num$ = 16
dev$ = 64
count$ = 72
iobuf$ = 80
more$ = 88
unitstat$ = 96
residual$ = 104
LoadUCB	PROC

; 796  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 797  :     U32 num, ucbsize = UCBSIZE( dev );

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00022	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  00027	75 0a		 jne	 SHORT $LN9@LoadUCB
  00029	c7 44 24 08 f0
	00 00 00	 mov	 DWORD PTR tv71[rsp], 240 ; 000000f0H
  00031	eb 2a		 jmp	 SHORT $LN10@LoadUCB
$LN9@LoadUCB:
  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00038	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0003c	3d 03 32 00 00	 cmp	 eax, 12803		; 00003203H
  00041	75 0a		 jne	 SHORT $LN7@LoadUCB
  00043	c7 44 24 04 30
	01 00 00	 mov	 DWORD PTR tv70[rsp], 304 ; 00000130H
  0004b	eb 08		 jmp	 SHORT $LN8@LoadUCB
$LN7@LoadUCB:
  0004d	c7 44 24 04 b0
	01 00 00	 mov	 DWORD PTR tv70[rsp], 432 ; 000001b0H
$LN8@LoadUCB:
  00055	8b 44 24 04	 mov	 eax, DWORD PTR tv70[rsp]
  00059	89 44 24 08	 mov	 DWORD PTR tv71[rsp], eax
$LN10@LoadUCB:
  0005d	8b 44 24 08	 mov	 eax, DWORD PTR tv71[rsp]
  00061	89 04 24	 mov	 DWORD PTR ucbsize$[rsp], eax
$LN4@LoadUCB:

; 798  : 
; 799  :     UNREFERENCED( more );

  00064	33 c0		 xor	 eax, eax
  00066	85 c0		 test	 eax, eax
  00068	75 fa		 jne	 SHORT $LN4@LoadUCB

; 800  : 
; 801  :     /* Calculate residual byte count */
; 802  :     num = (count < ucbsize) ? count : ucbsize;

  0006a	8b 04 24	 mov	 eax, DWORD PTR ucbsize$[rsp]
  0006d	39 44 24 48	 cmp	 DWORD PTR count$[rsp], eax
  00071	73 0a		 jae	 SHORT $LN11@LoadUCB
  00073	8b 44 24 48	 mov	 eax, DWORD PTR count$[rsp]
  00077	89 44 24 0c	 mov	 DWORD PTR tv74[rsp], eax
  0007b	eb 07		 jmp	 SHORT $LN12@LoadUCB
$LN11@LoadUCB:
  0007d	8b 04 24	 mov	 eax, DWORD PTR ucbsize$[rsp]
  00080	89 44 24 0c	 mov	 DWORD PTR tv74[rsp], eax
$LN12@LoadUCB:
  00084	8b 44 24 0c	 mov	 eax, DWORD PTR tv74[rsp]
  00088	89 44 24 10	 mov	 DWORD PTR num$[rsp], eax

; 803  :     *residual = count - num;

  0008c	8b 44 24 10	 mov	 eax, DWORD PTR num$[rsp]
  00090	8b 4c 24 48	 mov	 ecx, DWORD PTR count$[rsp]
  00094	2b c8		 sub	 ecx, eax
  00096	8b c1		 mov	 eax, ecx
  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR residual$[rsp]
  0009d	89 01		 mov	 DWORD PTR [rcx], eax

; 804  : 
; 805  :     /* Make sure enough data was provided */
; 806  :     if (count < ucbsize)

  0009f	8b 04 24	 mov	 eax, DWORD PTR ucbsize$[rsp]
  000a2	39 44 24 48	 cmp	 DWORD PTR count$[rsp], eax
  000a6	73 28		 jae	 SHORT $LN5@LoadUCB

; 807  :     {
; 808  :         /* Set unit check with SENSE = Load Check */
; 809  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  000a8	48 8b 44 24 60	 mov	 rax, QWORD PTR unitstat$[rsp]
  000ad	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 810  :         dev->sense[0] = SENSE_LDCK;

  000b0	b8 01 00 00 00	 mov	 eax, 1
  000b5	48 6b c0 00	 imul	 rax, rax, 0
  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000be	c6 84 01 64 03
	00 00 02	 mov	 BYTE PTR [rcx+rax+868], 2

; 811  :         return *unitstat;

  000c6	48 8b 44 24 60	 mov	 rax, QWORD PTR unitstat$[rsp]
  000cb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ce	eb 1d		 jmp	 SHORT $LN1@LoadUCB
$LN5@LoadUCB:

; 812  :     }
; 813  : 
; 814  :     /* Load new UCB */
; 815  :     memcpy( dev->ucb, iobuf, ucbsize );

  000d0	8b 04 24	 mov	 eax, DWORD PTR ucbsize$[rsp]
  000d3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000d8	48 81 c1 ac 0d
	00 00		 add	 rcx, 3500		; 00000dacH
  000df	48 8b f9	 mov	 rdi, rcx
  000e2	48 8b 74 24 50	 mov	 rsi, QWORD PTR iobuf$[rsp]
  000e7	8b c8		 mov	 ecx, eax
  000e9	f3 a4		 rep movsb

; 816  : 
; 817  :     return 0;

  000eb	32 c0		 xor	 al, al
$LN1@LoadUCB:

; 818  : }

  000ed	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000f1	5f		 pop	 rdi
  000f2	5e		 pop	 rsi
  000f3	c3		 ret	 0
LoadUCB	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
line$ = 80
chan1line$ = 84
tv131 = 88
tv137 = 92
dev$ = 112
on_new_cctape PROC

; 760  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 761  :     int line, chan1line;
; 762  : 
; 763  :     /* Scan new cctape and: 1) save new channel-9 and channel-12 line
; 764  :        numbers, and 2) issue a warning if channel-1 wasn't defined.
; 765  :     */
; 766  :     dev->chan9line  = 0;    // (reset due to new cctape)

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	c7 80 a0 0d 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+3488], 0

; 767  :     dev->chan12line = 0;    // (reset due to new cctape)

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	c7 80 a4 0d 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+3492], 0

; 768  :     dev->currline   = 1;    // (reset due to new cctape)

  00027	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0002c	c7 80 a8 0d 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+3496], 1

; 769  : 
; 770  :     for (line=0, chan1line=0; line < (int) _countof( dev->cctape); line++)

  00036	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR line$[rsp], 0
  0003e	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR chan1line$[rsp], 0
  00046	eb 0a		 jmp	 SHORT $LN4@on_new_cct
$LN2@on_new_cct:
  00048	8b 44 24 50	 mov	 eax, DWORD PTR line$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 50	 mov	 DWORD PTR line$[rsp], eax
$LN4@on_new_cct:
  00052	81 7c 24 50 00
	01 00 00	 cmp	 DWORD PTR line$[rsp], 256 ; 00000100H
  0005a	0f 8d 84 00 00
	00		 jge	 $LN3@on_new_cct

; 771  :     {
; 772  :         if      (dev->cctape[ line ] & 0x8000)      chan1line  = line+1;

  00060	48 63 44 24 50	 movsxd	 rax, DWORD PTR line$[rsp]
  00065	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0006a	0f b7 84 41 a0
	0b 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+2976]
  00072	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00077	85 c0		 test	 eax, eax
  00079	74 0c		 je	 SHORT $LN5@on_new_cct
  0007b	8b 44 24 50	 mov	 eax, DWORD PTR line$[rsp]
  0007f	ff c0		 inc	 eax
  00081	89 44 24 54	 mov	 DWORD PTR chan1line$[rsp], eax
  00085	eb 58		 jmp	 SHORT $LN6@on_new_cct
$LN5@on_new_cct:

; 773  :         else if (dev->cctape[ line ] & 0x0080) dev->chan9line  = line+1;

  00087	48 63 44 24 50	 movsxd	 rax, DWORD PTR line$[rsp]
  0008c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00091	0f b7 84 41 a0
	0b 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+2976]
  00099	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0009e	85 c0		 test	 eax, eax
  000a0	74 13		 je	 SHORT $LN7@on_new_cct
  000a2	8b 44 24 50	 mov	 eax, DWORD PTR line$[rsp]
  000a6	ff c0		 inc	 eax
  000a8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000ad	89 81 a0 0d 00
	00		 mov	 DWORD PTR [rcx+3488], eax
  000b3	eb 2a		 jmp	 SHORT $LN8@on_new_cct
$LN7@on_new_cct:

; 774  :         else if (dev->cctape[ line ] & 0x0010) dev->chan12line = line+1;

  000b5	48 63 44 24 50	 movsxd	 rax, DWORD PTR line$[rsp]
  000ba	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000bf	0f b7 84 41 a0
	0b 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+2976]
  000c7	83 e0 10	 and	 eax, 16
  000ca	85 c0		 test	 eax, eax
  000cc	74 11		 je	 SHORT $LN9@on_new_cct
  000ce	8b 44 24 50	 mov	 eax, DWORD PTR line$[rsp]
  000d2	ff c0		 inc	 eax
  000d4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000d9	89 81 a4 0d 00
	00		 mov	 DWORD PTR [rcx+3492], eax
$LN9@on_new_cct:
$LN8@on_new_cct:
$LN6@on_new_cct:

; 775  :     }

  000df	e9 64 ff ff ff	 jmp	 $LN2@on_new_cct
$LN3@on_new_cct:

; 776  : 
; 777  :     if (!chan1line)

  000e4	83 7c 24 54 00	 cmp	 DWORD PTR chan1line$[rsp], 0
  000e9	0f 85 97 00 00
	00		 jne	 $LN10@on_new_cct

; 778  :     {
; 779  :         // "%1d:%04X Printer: channel 1 is undefined"
; 780  :         WRMSG( HHC01111, "W", LCSS_DEVNUM );

  000ef	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000f5	74 0f		 je	 SHORT $LN12@on_new_cct
  000f7	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000fc	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00100	89 44 24 58	 mov	 DWORD PTR tv131[rsp], eax
  00104	eb 08		 jmp	 SHORT $LN13@on_new_cct
$LN12@on_new_cct:
  00106	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN13@on_new_cct:
  0010e	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00114	74 11		 je	 SHORT $LN14@on_new_cct
  00116	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0011b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0011f	d1 f8		 sar	 eax, 1
  00121	89 44 24 5c	 mov	 DWORD PTR tv137[rsp], eax
  00125	eb 08		 jmp	 SHORT $LN15@on_new_cct
$LN14@on_new_cct:
  00127	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN15@on_new_cct:
  0012f	b9 01 00 00 00	 mov	 ecx, 1
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0013a	8b 4c 24 58	 mov	 ecx, DWORD PTR tv131[rsp]
  0013e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00142	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv137[rsp]
  00146	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168438
  00151	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168439
  0015d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00162	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00167	41 b9 03 00 00
	00		 mov	 r9d, 3
  0016d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168440
  00174	ba 0c 03 00 00	 mov	 edx, 780		; 0000030cH
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168441
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@on_new_cct:

; 781  :     }
; 782  : }

  00186	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018a	c3		 ret	 0
on_new_cctape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
line$ = 80
chan1line$ = 84
tv157 = 88
tv163 = 92
tv83 = 96
tv87 = 100
fcbfmt$1 = 112
loaded$2 = 368
__$ArrayPad$ = 624
dev$ = 656
on_new_fcb PROC

; 716  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 02
	00 00		 sub	 rsp, 648		; 00000288H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 717  :     int line, chan1line;
; 718  : 
; 719  :     /* Display FCB just loaded if verbose messages enabled */
; 720  :     if (MLVL( VERBOSE ))

  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00025	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  0002b	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00030	85 c0		 test	 eax, eax
  00032	0f 84 f8 00 00
	00		 je	 $LN5@on_new_fcb

; 721  :     {
; 722  :         char fcbfmt[256];
; 723  :         char loaded[256];
; 724  : 
; 725  :         FormatFCB( fcbfmt, sizeof( fcbfmt ),

  00038	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00040	48 05 94 07 00
	00		 add	 rax, 1940		; 00000794H
  00046	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004b	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00053	8b 80 90 07 00
	00		 mov	 eax, DWORD PTR [rax+1936]
  00059	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0005d	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00065	44 8b 88 88 07
	00 00		 mov	 r9d, DWORD PTR [rax+1928]
  0006c	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00074	44 8b 80 8c 07
	00 00		 mov	 r8d, DWORD PTR [rax+1932]
  0007b	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00080	48 8d 4c 24 70	 lea	 rcx, QWORD PTR fcbfmt$1[rsp]
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatFCB

; 726  :             dev->index, dev->lpi, dev->lpp, dev->fcb );
; 727  : 
; 728  :         MSGBUF( loaded, "LOADED %s", fcbfmt );

  0008b	4c 8d 4c 24 70	 lea	 r9, QWORD PTR fcbfmt$1[rsp]
  00090	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168407
  00097	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0009c	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR loaded$2[rsp]
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 729  : 
; 730  :         // "%1d:%04X %s"
; 731  :         WRMSG( HHC02210, "I", SSID_TO_LCSS( dev->ssid ),

  000aa	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000b6	89 44 24 60	 mov	 DWORD PTR tv83[rsp], eax
  000ba	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000c2	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  000c6	d1 f9		 sar	 ecx, 1
  000c8	89 4c 24 64	 mov	 DWORD PTR tv87[rsp], ecx
  000cc	b9 01 00 00 00	 mov	 ecx, 1
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d7	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR loaded$2[rsp]
  000df	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000e4	8b 4c 24 60	 mov	 ecx, DWORD PTR tv83[rsp]
  000e8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000ec	8b 4c 24 64	 mov	 ecx, DWORD PTR tv87[rsp]
  000f0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168408
  000fb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168409
  00107	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00111	41 b9 03 00 00
	00		 mov	 r9d, 3
  00117	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168410
  0011e	ba dc 02 00 00	 mov	 edx, 732		; 000002dcH
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168411
  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@on_new_fcb:

; 732  :             dev->devnum, loaded );
; 733  :     }
; 734  : 
; 735  :     /* Scan new fcb and: 1) save new channel-9 and channel-12 line
; 736  :        numbers, and 2) issue a warning if channel-1 wasn't defined.
; 737  :     */
; 738  :     dev->currline   = 1;    // (reset due to new FCB load)

  00130	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00138	c7 80 a8 0d 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+3496], 1

; 739  :     dev->chan9line  = 0;    // (reset due to new FCB load)

  00142	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014a	c7 80 a0 0d 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+3488], 0

; 740  :     dev->chan12line = 0;    // (reset due to new FCB load)

  00154	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0015c	c7 80 a4 0d 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+3492], 0

; 741  : 
; 742  :     for (chan1line=0, line=1; line <= dev->lpp; line++)

  00166	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR chan1line$[rsp], 0
  0016e	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR line$[rsp], 1
  00176	eb 0a		 jmp	 SHORT $LN4@on_new_fcb
$LN2@on_new_fcb:
  00178	8b 44 24 50	 mov	 eax, DWORD PTR line$[rsp]
  0017c	ff c0		 inc	 eax
  0017e	89 44 24 50	 mov	 DWORD PTR line$[rsp], eax
$LN4@on_new_fcb:
  00182	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0018a	8b 80 90 07 00
	00		 mov	 eax, DWORD PTR [rax+1936]
  00190	39 44 24 50	 cmp	 DWORD PTR line$[rsp], eax
  00194	7f 7a		 jg	 SHORT $LN3@on_new_fcb

; 743  :     {
; 744  :         if      (dev->fcb[ line ] ==  1)      chan1line  = line;

  00196	48 63 44 24 50	 movsxd	 rax, DWORD PTR line$[rsp]
  0019b	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a3	83 bc 81 94 07
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+1940], 1
  001ab	75 0a		 jne	 SHORT $LN6@on_new_fcb
  001ad	8b 44 24 50	 mov	 eax, DWORD PTR line$[rsp]
  001b1	89 44 24 54	 mov	 DWORD PTR chan1line$[rsp], eax
  001b5	eb 54		 jmp	 SHORT $LN7@on_new_fcb
$LN6@on_new_fcb:

; 745  :         else if (dev->fcb[ line ] ==  9) dev->chan9line  = line;

  001b7	48 63 44 24 50	 movsxd	 rax, DWORD PTR line$[rsp]
  001bc	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001c4	83 bc 81 94 07
	00 00 09	 cmp	 DWORD PTR [rcx+rax*4+1940], 9
  001cc	75 14		 jne	 SHORT $LN8@on_new_fcb
  001ce	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d6	8b 4c 24 50	 mov	 ecx, DWORD PTR line$[rsp]
  001da	89 88 a0 0d 00
	00		 mov	 DWORD PTR [rax+3488], ecx
  001e0	eb 29		 jmp	 SHORT $LN9@on_new_fcb
$LN8@on_new_fcb:

; 746  :         else if (dev->fcb[ line ] == 12) dev->chan12line = line;

  001e2	48 63 44 24 50	 movsxd	 rax, DWORD PTR line$[rsp]
  001e7	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ef	83 bc 81 94 07
	00 00 0c	 cmp	 DWORD PTR [rcx+rax*4+1940], 12
  001f7	75 12		 jne	 SHORT $LN10@on_new_fcb
  001f9	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00201	8b 4c 24 50	 mov	 ecx, DWORD PTR line$[rsp]
  00205	89 88 a4 0d 00
	00		 mov	 DWORD PTR [rax+3492], ecx
$LN10@on_new_fcb:
$LN9@on_new_fcb:
$LN7@on_new_fcb:

; 747  :     }

  0020b	e9 68 ff ff ff	 jmp	 $LN2@on_new_fcb
$LN3@on_new_fcb:

; 748  : 
; 749  :     if (!chan1line)

  00210	83 7c 24 54 00	 cmp	 DWORD PTR chan1line$[rsp], 0
  00215	0f 85 a3 00 00
	00		 jne	 $LN11@on_new_fcb

; 750  :     {
; 751  :         // "%1d:%04X Printer: channel 1 is undefined"
; 752  :         WRMSG( HHC01111, "W", LCSS_DEVNUM );

  0021b	48 83 bc 24 90
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00224	74 12		 je	 SHORT $LN13@on_new_fcb
  00226	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0022e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00232	89 44 24 58	 mov	 DWORD PTR tv157[rsp], eax
  00236	eb 08		 jmp	 SHORT $LN14@on_new_fcb
$LN13@on_new_fcb:
  00238	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN14@on_new_fcb:
  00240	48 83 bc 24 90
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00249	74 14		 je	 SHORT $LN15@on_new_fcb
  0024b	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00253	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00257	d1 f8		 sar	 eax, 1
  00259	89 44 24 5c	 mov	 DWORD PTR tv163[rsp], eax
  0025d	eb 08		 jmp	 SHORT $LN16@on_new_fcb
$LN15@on_new_fcb:
  0025f	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
$LN16@on_new_fcb:
  00267	b9 01 00 00 00	 mov	 ecx, 1
  0026c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00272	8b 4c 24 58	 mov	 ecx, DWORD PTR tv157[rsp]
  00276	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0027a	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv163[rsp]
  0027e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00282	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168418
  00289	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0028e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168419
  00295	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0029a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0029f	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168420
  002ac	ba f0 02 00 00	 mov	 edx, 752		; 000002f0H
  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168421
  002b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN11@on_new_fcb:

; 753  :     }
; 754  : }

  002be	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002c6	48 33 cc	 xor	 rcx, rsp
  002c9	e8 00 00 00 00	 call	 __security_check_cookie
  002ce	48 81 c4 88 02
	00 00		 add	 rsp, 648		; 00000288H
  002d5	c3		 ret	 0
on_new_fcb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
rc$ = 64
tid$ = 68
tv73 = 72
dev$ = 96
onconnect_callback PROC

; 698  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 699  :     TID tid;
; 700  :     int rc;
; 701  : 
; 702  :     rc = create_thread( &tid, DETACHED, spthread, dev, "spthread" );

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168388
  0001d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168389
  00029	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0002e	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dev$[rsp]
  00033	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:spthread
  0003a	48 8b d0	 mov	 rdx, rax
  0003d	48 8d 4c 24 44	 lea	 rcx, QWORD PTR tid$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00048	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 703  :     if (rc)

  0004c	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00051	74 64		 je	 SHORT $LN2@onconnect_

; 704  :     {
; 705  :         // "Error in function create_thread(): %s"
; 706  :         WRMSG( HHC00102, "E", strerror( rc ) );

  00053	8b 4c 24 40	 mov	 ecx, DWORD PTR rc$[rsp]
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0005d	48 89 44 24 48	 mov	 QWORD PTR tv73[rsp], rax
  00062	b9 01 00 00 00	 mov	 ecx, 1
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv73[rsp]
  00072	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168391
  0007e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168392
  0008a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0008f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00094	41 b9 03 00 00
	00		 mov	 r9d, 3
  0009a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168393
  000a1	ba c2 02 00 00	 mov	 edx, 706		; 000002c2H
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168394
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 707  :         return 0;

  000b3	33 c0		 xor	 eax, eax
  000b5	eb 05		 jmp	 SHORT $LN1@onconnect_
$LN2@onconnect_:

; 708  :     }
; 709  :     return 1;

  000b7	b8 01 00 00 00	 mov	 eax, 1
$LN1@onconnect_:

; 710  : }

  000bc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000c0	c3		 ret	 0
onconnect_callback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
fd$ = 96
dev$ = 104
rc$1 = 112
rc$2 = 116
rc$ = 120
byte$ = 124
tv69 = 128
tv75 = 132
tv201 = 136
tv207 = 140
tv$ = 144
tv223 = 152
tv222 = 160
tv218 = 168
errorset$ = 176
readset$ = 8384
thread_name$3 = 16592
__$ArrayPad$ = 16608
arg$ = 16640
spthread PROC

; 603  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 f8 40 00 00	 mov	 eax, 16632		; 000040f8H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 e0
	40 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 604  :     DEVBLK* dev = (DEVBLK*) arg;

  00024	48 8b 84 24 00
	41 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  0002c	48 89 44 24 68	 mov	 QWORD PTR dev$[rsp], rax

; 605  :     BYTE byte;
; 606  :     fd_set readset, errorset;
; 607  :     struct timeval tv;
; 608  :     int rc, fd = dev->fd;           // (save original fd)

  00031	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00036	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [rax+428]
  0003c	89 44 24 60	 mov	 DWORD PTR fd$[rsp], eax

; 609  : 
; 610  :     /* Fix thread name */
; 611  :     {
; 612  :         char    thread_name[16];
; 613  :         MSGBUF( thread_name, "spthread %1d:%04X", LCSS_DEVNUM );

  00040	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00046	74 12		 je	 SHORT $LN35@spthread
  00048	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0004d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00051	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv69[rsp], eax
  00058	eb 0b		 jmp	 SHORT $LN36@spthread
$LN35@spthread:
  0005a	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv69[rsp], 0
$LN36@spthread:
  00065	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0006b	74 14		 je	 SHORT $LN37@spthread
  0006d	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00072	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00076	d1 f8		 sar	 eax, 1
  00078	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv75[rsp], eax
  0007f	eb 0b		 jmp	 SHORT $LN38@spthread
$LN37@spthread:
  00081	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv75[rsp], 0
$LN38@spthread:
  0008c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv69[rsp]
  00093	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00097	44 8b 8c 24 84
	00 00 00	 mov	 r9d, DWORD PTR tv75[rsp]
  0009f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168357
  000a6	ba 10 00 00 00	 mov	 edx, 16
  000ab	48 8d 8c 24 d0
	40 00 00	 lea	 rcx, QWORD PTR thread_name$3[rsp]
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN4@spthread:

; 614  :         SET_THREAD_NAME( thread_name );

  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  000bf	48 8d 94 24 d0
	40 00 00	 lea	 rdx, QWORD PTR thread_name$3[rsp]
  000c7	8b c8		 mov	 ecx, eax
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_set_thread_name
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  000d5	48 8d 94 24 d0
	40 00 00	 lea	 rdx, QWORD PTR thread_name$3[rsp]
  000dd	8b c8		 mov	 ecx, eax
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_name
  000e5	33 c0		 xor	 eax, eax
  000e7	85 c0		 test	 eax, eax
  000e9	75 ce		 jne	 SHORT $LN4@spthread
$LN44@spthread:
$LN43@spthread:
$LN5@spthread:

; 615  :     }
; 616  : 
; 617  :     // Looooop...  until shutdown or disconnect...
; 618  : 
; 619  :     // PROGRAMMING NOTE: we do our select specifying an immediate
; 620  :     // timeout to prevent our select from holding up (slowing down)
; 621  :     // the device thread (which does the actual writing of data to
; 622  :     // the client). The only purpose for our thread even existing
; 623  :     // is to detect a severed connection (i.e. to detect when the
; 624  :     // client disconnects)...
; 625  : 
; 626  :     while ( !sysblk.shutdown && dev->fd == fd )

  000eb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000f2	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000f8	c1 e8 0b	 shr	 eax, 11
  000fb	83 e0 01	 and	 eax, 1
  000fe	85 c0		 test	 eax, eax
  00100	0f 85 ff 01 00
	00		 jne	 $LN6@spthread
  00106	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0010b	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  0010f	39 88 ac 01 00
	00		 cmp	 DWORD PTR [rax+428], ecx
  00115	0f 85 ea 01 00
	00		 jne	 $LN6@spthread

; 627  :     {
; 628  :         if (dev->busy)

  0011b	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00120	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00126	c1 e8 13	 shr	 eax, 19
  00129	83 e0 01	 and	 eax, 1
  0012c	85 c0		 test	 eax, eax
  0012e	74 34		 je	 SHORT $LN23@spthread
$LN9@spthread:

; 629  :         {
; 630  :             SLEEP(3);

  00130	c7 44 24 70 03
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 3
$LN10@spthread:
  00138	83 7c 24 70 00	 cmp	 DWORD PTR rc$1[rsp], 0
  0013d	74 1d		 je	 SHORT $LN11@spthread
  0013f	8b 4c 24 70	 mov	 ecx, DWORD PTR rc$1[rsp]
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  00149	89 44 24 70	 mov	 DWORD PTR rc$1[rsp], eax
  0014d	83 7c 24 70 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00152	74 06		 je	 SHORT $LN24@spthread
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN24@spthread:
  0015a	eb dc		 jmp	 SHORT $LN10@spthread
$LN11@spthread:
  0015c	33 c0		 xor	 eax, eax
  0015e	85 c0		 test	 eax, eax
  00160	75 ce		 jne	 SHORT $LN9@spthread

; 631  :             continue;

  00162	eb 87		 jmp	 SHORT $LN5@spthread
$LN23@spthread:

; 632  :         }
; 633  : 
; 634  :         FD_ZERO( &readset );

  00164	c7 84 24 c0 20
	00 00 00 00 00
	00		 mov	 DWORD PTR readset$[rsp], 0

; 635  :         FD_ZERO( &errorset );

  0016f	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR errorset$[rsp], 0

; 636  : 
; 637  :         FD_SET( fd, &readset );

  0017a	48 8d 94 24 c0
	20 00 00	 lea	 rdx, QWORD PTR readset$[rsp]
  00182	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 638  :         FD_SET( fd, &errorset );

  0018c	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR errorset$[rsp]
  00194	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 639  : 
; 640  :         tv.tv_sec = 0;

  0019e	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv$[rsp], 0

; 641  :         tv.tv_usec = 0;

  001a9	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv$[rsp+4], 0

; 642  : 
; 643  :         rc = select( fd+1, &readset, NULL, &errorset, &tv );

  001b4	8b 44 24 60	 mov	 eax, DWORD PTR fd$[rsp]
  001b8	ff c0		 inc	 eax
  001ba	c7 44 24 30 83
	02 00 00	 mov	 DWORD PTR [rsp+48], 643	; 00000283H
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168360
  001c9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ce	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR tv$[rsp]
  001d6	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001db	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR errorset$[rsp]
  001e3	45 33 c0	 xor	 r8d, r8d
  001e6	48 8d 94 24 c0
	20 00 00	 lea	 rdx, QWORD PTR readset$[rsp]
  001ee	8b c8		 mov	 ecx, eax
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_select
  001f6	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 644  : 
; 645  :         if (rc < 0)

  001fa	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  001ff	7d 05		 jge	 SHORT $LN25@spthread

; 646  :             break;

  00201	e9 ff 00 00 00	 jmp	 $LN6@spthread
$LN25@spthread:

; 647  : 
; 648  :         if (rc == 0)

  00206	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  0020b	75 37		 jne	 SHORT $LN26@spthread
$LN14@spthread:

; 649  :         {
; 650  :             SLEEP(3);

  0020d	c7 44 24 74 03
	00 00 00	 mov	 DWORD PTR rc$2[rsp], 3
$LN15@spthread:
  00215	83 7c 24 74 00	 cmp	 DWORD PTR rc$2[rsp], 0
  0021a	74 1d		 je	 SHORT $LN16@spthread
  0021c	8b 4c 24 74	 mov	 ecx, DWORD PTR rc$2[rsp]
  00220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  00226	89 44 24 74	 mov	 DWORD PTR rc$2[rsp], eax
  0022a	83 7c 24 74 00	 cmp	 DWORD PTR rc$2[rsp], 0
  0022f	74 06		 je	 SHORT $LN27@spthread
  00231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN27@spthread:
  00237	eb dc		 jmp	 SHORT $LN15@spthread
$LN16@spthread:
  00239	33 c0		 xor	 eax, eax
  0023b	85 c0		 test	 eax, eax
  0023d	75 ce		 jne	 SHORT $LN14@spthread

; 651  :             continue;

  0023f	e9 a7 fe ff ff	 jmp	 $LN43@spthread
$LN26@spthread:

; 652  :         }
; 653  : 
; 654  :         if (FD_ISSET( fd, &errorset ))

  00244	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR errorset$[rsp]
  0024c	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  00250	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  00256	85 c0		 test	 eax, eax
  00258	74 05		 je	 SHORT $LN28@spthread

; 655  :             break;

  0025a	e9 a6 00 00 00	 jmp	 $LN6@spthread
$LN28@spthread:
$LN19@spthread:

; 656  : 
; 657  :         // Read and ignore any data they send us...
; 658  :         // Note: recv should complete immediately
; 659  :         // as we know data is waiting to be read.
; 660  : 
; 661  :         ASSERT( FD_ISSET( fd, &readset ) );

  0025f	48 8d 94 24 c0
	20 00 00	 lea	 rdx, QWORD PTR readset$[rsp]
  00267	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  0026b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  00271	85 c0		 test	 eax, eax
  00273	75 5c		 jne	 SHORT $LN29@spthread
$LN22@spthread:
  00275	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168366
  0027c	41 b8 95 02 00
	00		 mov	 r8d, 661		; 00000295H
  00282	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168367
  00289	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168368
  00290	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0029c	85 c0		 test	 eax, eax
  0029e	74 20		 je	 SHORT $LN30@spthread
  002a0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168370
  002a7	41 b8 95 02 00
	00		 mov	 r8d, 661		; 00000295H
  002ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168371
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168372
  002bb	e8 00 00 00 00	 call	 DebuggerTrace
$LN30@spthread:
  002c0	33 c0		 xor	 eax, eax
  002c2	85 c0		 test	 eax, eax
  002c4	75 af		 jne	 SHORT $LN22@spthread
  002c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002cc	85 c0		 test	 eax, eax
  002ce	74 01		 je	 SHORT $LN31@spthread
  002d0	cc		 int	 3
$LN31@spthread:
$LN29@spthread:
  002d1	33 c0		 xor	 eax, eax
  002d3	85 c0		 test	 eax, eax
  002d5	75 88		 jne	 SHORT $LN19@spthread

; 662  : 
; 663  :         rc = recv( fd, &byte, sizeof(byte), 0 );

  002d7	48 63 44 24 60	 movsxd	 rax, DWORD PTR fd$[rsp]
  002dc	45 33 c9	 xor	 r9d, r9d
  002df	41 b8 01 00 00
	00		 mov	 r8d, 1
  002e5	48 8d 54 24 7c	 lea	 rdx, QWORD PTR byte$[rsp]
  002ea	48 8b c8	 mov	 rcx, rax
  002ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  002f3	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 664  : 
; 665  :         if (rc <= 0)

  002f7	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  002fc	7f 02		 jg	 SHORT $LN32@spthread

; 666  :             break;

  002fe	eb 05		 jmp	 SHORT $LN6@spthread
$LN32@spthread:

; 667  :     }

  00300	e9 e6 fd ff ff	 jmp	 $LN44@spthread
$LN6@spthread:

; 668  : 
; 669  :     obtain_lock( &dev->lock );

  00305	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0030a	48 83 c0 38	 add	 rax, 56			; 00000038H
  0030e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168375
  00315	48 8b c8	 mov	 rcx, rax
  00318	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 670  : 
; 671  :     // PROGRAMMING NOTE: the following tells us whether we detected
; 672  :     // the error or if the device thread already did. If the device
; 673  :     // thread detected it while we were sleeping (and subsequently
; 674  :     // closed the connection) then we don't need to do anything at
; 675  :     // all; just exit. If we were the ones that detected the error
; 676  :     // however, then we need to close the connection so the device
; 677  :     // thread can learn of it...
; 678  : 
; 679  :     if (dev->fd == fd)

  0031e	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00323	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  00327	39 88 ac 01 00
	00		 cmp	 DWORD PTR [rax+428], ecx
  0032d	0f 85 31 01 00
	00		 jne	 $LN33@spthread

; 680  :     {
; 681  :         dev->fd = -1;

  00333	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00338	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 682  :         close_socket( fd );

  00342	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  00346	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 683  :         // "%1d:%04X Printer: client %s, IP %s disconnected from device %s"
; 684  :         WRMSG (HHC01100, "I", LCSS_DEVNUM,

  0034c	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00352	74 12		 je	 SHORT $LN39@spthread
  00354	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00359	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0035d	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv201[rsp], eax
  00364	eb 0b		 jmp	 SHORT $LN40@spthread
$LN39@spthread:
  00366	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv201[rsp], 0
$LN40@spthread:
  00371	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00377	74 14		 je	 SHORT $LN41@spthread
  00379	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0037e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00382	d1 f8		 sar	 eax, 1
  00384	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv207[rsp], eax
  0038b	eb 0b		 jmp	 SHORT $LN42@spthread
$LN41@spthread:
  0038d	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv207[rsp], 0
$LN42@spthread:
  00398	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0039d	48 8b 80 b8 01
	00 00		 mov	 rax, QWORD PTR [rax+440]
  003a4	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv223[rsp], rax
  003ac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  003b1	48 8b 89 b8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+440]
  003b8	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR tv222[rsp], rcx
  003c0	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  003c5	48 8b 92 b8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+440]
  003cc	48 89 94 24 a8
	00 00 00	 mov	 QWORD PTR tv218[rsp], rdx
  003d4	b9 01 00 00 00	 mov	 ecx, 1
  003d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003df	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv223[rsp]
  003e7	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  003eb	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  003f0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv222[rsp]
  003f8	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  003fc	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00401	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv218[rsp]
  00409	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0040d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00412	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv201[rsp]
  00419	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0041d	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv207[rsp]
  00424	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00428	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168377
  0042f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00434	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168378
  0043b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00440	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00445	41 b9 03 00 00
	00		 mov	 r9d, 3
  0044b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168379
  00452	ba ad 02 00 00	 mov	 edx, 685		; 000002adH
  00457	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168380
  0045e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN33@spthread:

; 685  :                dev->bs->clientname, dev->bs->clientip, dev->bs->spec);
; 686  :     }
; 687  : 
; 688  :     release_lock( &dev->lock );

  00464	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00469	48 83 c0 38	 add	 rax, 56			; 00000038H
  0046d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168381
  00474	48 8b c8	 mov	 rcx, rax
  00477	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 689  : 
; 690  :     return NULL;

  0047d	33 c0		 xor	 eax, eax

; 691  : 
; 692  : } /* end function spthread */

  0047f	48 8b 8c 24 e0
	40 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00487	48 33 cc	 xor	 rcx, rsp
  0048a	e8 00 00 00 00	 call	 __security_check_cookie
  0048f	48 81 c4 f8 40
	00 00		 add	 rsp, 16632		; 000040f8H
  00496	c3		 ret	 0
spthread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
rc$ = 32
tv68 = 36
tv93 = 40
dev$ = 64
code$ = 72
unitstat$ = 80
DoSpaceOrSkip PROC

; 586  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 587  :     BYTE rc;
; 588  : 
; 589  :     dev->skpimmed = ISSKPIMMED( code );

  00012	0f b6 44 24 48	 movzx	 eax, BYTE PTR code$[rsp]
  00017	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0001c	85 c0		 test	 eax, eax
  0001e	74 0a		 je	 SHORT $LN5@DoSpaceOrS
  00020	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN6@DoSpaceOrS
$LN5@DoSpaceOrS:
  0002a	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN6@DoSpaceOrS:
  00032	8b 44 24 24	 mov	 eax, DWORD PTR tv68[rsp]
  00036	83 e0 01	 and	 eax, 1
  00039	c1 e0 08	 shl	 eax, 8
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00041	8b 89 84 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1924]
  00047	0f ba f1 08	 btr	 ecx, 8
  0004b	0b c8		 or	 ecx, eax
  0004d	8b c1		 mov	 eax, ecx
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00054	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 590  : 
; 591  :     if (code <= 0x80)

  0005a	0f b6 44 24 48	 movzx	 eax, BYTE PTR code$[rsp]
  0005f	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00064	7f 26		 jg	 SHORT $LN2@DoSpaceOrS

; 592  :         rc = SpaceLines( dev, unitstat, CCWOP2LINES( code ));

  00066	0f b6 44 24 48	 movzx	 eax, BYTE PTR code$[rsp]
  0006b	99		 cdq
  0006c	83 e2 07	 and	 edx, 7
  0006f	03 c2		 add	 eax, edx
  00071	c1 f8 03	 sar	 eax, 3
  00074	44 8b c0	 mov	 r8d, eax
  00077	48 8b 54 24 50	 mov	 rdx, QWORD PTR unitstat$[rsp]
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00081	e8 00 00 00 00	 call	 SpaceLines
  00086	88 44 24 20	 mov	 BYTE PTR rc$[rsp], al
  0008a	eb 2e		 jmp	 SHORT $LN3@DoSpaceOrS
$LN2@DoSpaceOrS:

; 593  :     else
; 594  :         rc = SkipToChannel( dev, code, unitstat, CCWOP2CHAN( code ));

  0008c	0f b6 44 24 48	 movzx	 eax, BYTE PTR code$[rsp]
  00091	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  00096	99		 cdq
  00097	83 e2 07	 and	 edx, 7
  0009a	03 c2		 add	 eax, edx
  0009c	c1 f8 03	 sar	 eax, 3
  0009f	44 8b c8	 mov	 r9d, eax
  000a2	4c 8b 44 24 50	 mov	 r8, QWORD PTR unitstat$[rsp]
  000a7	0f b6 54 24 48	 movzx	 edx, BYTE PTR code$[rsp]
  000ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000b1	e8 00 00 00 00	 call	 SkipToChannel
  000b6	88 44 24 20	 mov	 BYTE PTR rc$[rsp], al
$LN3@DoSpaceOrS:

; 595  : 
; 596  :     return rc ? *unitstat : 0;

  000ba	0f b6 44 24 20	 movzx	 eax, BYTE PTR rc$[rsp]
  000bf	85 c0		 test	 eax, eax
  000c1	74 0e		 je	 SHORT $LN7@DoSpaceOrS
  000c3	48 8b 44 24 50	 mov	 rax, QWORD PTR unitstat$[rsp]
  000c8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000cb	89 44 24 28	 mov	 DWORD PTR tv93[rsp], eax
  000cf	eb 08		 jmp	 SHORT $LN8@DoSpaceOrS
$LN7@DoSpaceOrS:
  000d1	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN8@DoSpaceOrS:
  000d9	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv93[rsp]

; 597  : }

  000de	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e2	c3		 ret	 0
DoSpaceOrSkip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
found$ = 32
chan_mask$1 = 36
line$ = 40
destline$ = 44
newlines$2 = 48
tv274 = 52
dev$ = 80
code$ = 88
unitstat$ = 96
chan$ = 104
SkipToChannel PROC

; 444  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 445  :     int  line, destline;
; 446  :     U8   found  = FALSE;     /* TRUE/FALSE whether channel was found */

  00017	c6 44 24 20 00	 mov	 BYTE PTR found$[rsp], 0
$LN4@SkipToChan:

; 447  : 
; 448  :     UNREFERENCED( code );

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN4@SkipToChan

; 449  : 
; 450  :     if (dev->devtype == 0x1403)

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00027	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0002b	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  00030	0f 85 bb 00 00
	00		 jne	 $LN20@SkipToChan

; 451  :     {
; 452  :         /* 1403: Search carriage control tape for channel punch */
; 453  : 
; 454  :         U16  chan_mask  = 0x8000 >> (chan - 1);

  00036	8b 44 24 68	 mov	 eax, DWORD PTR chan$[rsp]
  0003a	ff c8		 dec	 eax
  0003c	b9 00 80 00 00	 mov	 ecx, 32768		; 00008000H
  00041	89 4c 24 34	 mov	 DWORD PTR tv274[rsp], ecx
  00045	0f b6 c8	 movzx	 ecx, al
  00048	8b 44 24 34	 mov	 eax, DWORD PTR tv274[rsp]
  0004c	d3 f8		 sar	 eax, cl
  0004e	66 89 44 24 24	 mov	 WORD PTR chan_mask$1[rsp], ax

; 455  : 
; 456  :         for (line = LINENUM( dev->currline + 1);

  00053	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00058	8b 80 a8 0d 00
	00		 mov	 eax, DWORD PTR [rax+3496]
  0005e	99		 cdq
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00064	f7 b9 90 07 00
	00		 idiv	 DWORD PTR [rcx+1936]
  0006a	8b c2		 mov	 eax, edx
  0006c	ff c0		 inc	 eax
  0006e	89 44 24 28	 mov	 DWORD PTR line$[rsp], eax
  00072	eb 18		 jmp	 SHORT $LN7@SkipToChan
$LN5@SkipToChan:

; 458  :             line = LINENUM( line+1 )

  00074	8b 44 24 28	 mov	 eax, DWORD PTR line$[rsp]
  00078	99		 cdq
  00079	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0007e	f7 b9 90 07 00
	00		 idiv	 DWORD PTR [rcx+1936]
  00084	8b c2		 mov	 eax, edx
  00086	ff c0		 inc	 eax
  00088	89 44 24 28	 mov	 DWORD PTR line$[rsp], eax
$LN7@SkipToChan:

; 457  :             !(dev->cctape[ line-1 ] & chan_mask) && line != dev->currline;

  0008c	8b 44 24 28	 mov	 eax, DWORD PTR line$[rsp]
  00090	ff c8		 dec	 eax
  00092	48 98		 cdqe
  00094	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00099	0f b7 84 41 a0
	0b 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+2976]
  000a1	0f b7 4c 24 24	 movzx	 ecx, WORD PTR chan_mask$1[rsp]
  000a6	23 c1		 and	 eax, ecx
  000a8	85 c0		 test	 eax, eax
  000aa	75 13		 jne	 SHORT $LN6@SkipToChan
  000ac	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000b1	8b 80 a8 0d 00
	00		 mov	 eax, DWORD PTR [rax+3496]
  000b7	39 44 24 28	 cmp	 DWORD PTR line$[rsp], eax
  000bb	74 02		 je	 SHORT $LN6@SkipToChan

; 459  :         )
; 460  :             ;   /* (do nothing) */

  000bd	eb b5		 jmp	 SHORT $LN5@SkipToChan
$LN6@SkipToChan:

; 461  : 
; 462  :         if (dev->cctape[ line-1 ] & chan_mask)

  000bf	8b 44 24 28	 mov	 eax, DWORD PTR line$[rsp]
  000c3	ff c8		 dec	 eax
  000c5	48 98		 cdqe
  000c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000cc	0f b7 84 41 a0
	0b 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+2976]
  000d4	0f b7 4c 24 24	 movzx	 ecx, WORD PTR chan_mask$1[rsp]
  000d9	23 c1		 and	 eax, ecx
  000db	85 c0		 test	 eax, eax
  000dd	74 0d		 je	 SHORT $LN22@SkipToChan

; 463  :         {
; 464  :             found = TRUE;

  000df	c6 44 24 20 01	 mov	 BYTE PTR found$[rsp], 1

; 465  :             destline = line;

  000e4	8b 44 24 28	 mov	 eax, DWORD PTR line$[rsp]
  000e8	89 44 24 2c	 mov	 DWORD PTR destline$[rsp], eax
$LN22@SkipToChan:

; 466  :         }
; 467  :     }

  000ec	e9 87 00 00 00	 jmp	 $LN21@SkipToChan
$LN20@SkipToChan:

; 468  :     else /* 3203/3211: Search FCB image for channel number */
; 469  :     {
; 470  :         for (line = LINENUM( dev->currline + 1 );

  000f1	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000f6	8b 80 a8 0d 00
	00		 mov	 eax, DWORD PTR [rax+3496]
  000fc	99		 cdq
  000fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00102	f7 b9 90 07 00
	00		 idiv	 DWORD PTR [rcx+1936]
  00108	8b c2		 mov	 eax, edx
  0010a	ff c0		 inc	 eax
  0010c	89 44 24 28	 mov	 DWORD PTR line$[rsp], eax
  00110	eb 18		 jmp	 SHORT $LN10@SkipToChan
$LN8@SkipToChan:

; 472  :             line = LINENUM( line+1 )

  00112	8b 44 24 28	 mov	 eax, DWORD PTR line$[rsp]
  00116	99		 cdq
  00117	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0011c	f7 b9 90 07 00
	00		 idiv	 DWORD PTR [rcx+1936]
  00122	8b c2		 mov	 eax, edx
  00124	ff c0		 inc	 eax
  00126	89 44 24 28	 mov	 DWORD PTR line$[rsp], eax
$LN10@SkipToChan:

; 471  :             dev->fcb[ line ] != chan && line != dev->currline;

  0012a	48 63 44 24 28	 movsxd	 rax, DWORD PTR line$[rsp]
  0012f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00134	8b 54 24 68	 mov	 edx, DWORD PTR chan$[rsp]
  00138	39 94 81 94 07
	00 00		 cmp	 DWORD PTR [rcx+rax*4+1940], edx
  0013f	74 13		 je	 SHORT $LN9@SkipToChan
  00141	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00146	8b 80 a8 0d 00
	00		 mov	 eax, DWORD PTR [rax+3496]
  0014c	39 44 24 28	 cmp	 DWORD PTR line$[rsp], eax
  00150	74 02		 je	 SHORT $LN9@SkipToChan

; 473  :         )
; 474  :             ;   /* (do nothing) */

  00152	eb be		 jmp	 SHORT $LN8@SkipToChan
$LN9@SkipToChan:

; 475  : 
; 476  :         if (dev->fcb[ line ] == chan)

  00154	48 63 44 24 28	 movsxd	 rax, DWORD PTR line$[rsp]
  00159	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0015e	8b 54 24 68	 mov	 edx, DWORD PTR chan$[rsp]
  00162	39 94 81 94 07
	00 00		 cmp	 DWORD PTR [rcx+rax*4+1940], edx
  00169	75 0d		 jne	 SHORT $LN23@SkipToChan

; 477  :         {
; 478  :             found = TRUE;

  0016b	c6 44 24 20 01	 mov	 BYTE PTR found$[rsp], 1

; 479  :             destline = line;

  00170	8b 44 24 28	 mov	 eax, DWORD PTR line$[rsp]
  00174	89 44 24 2c	 mov	 DWORD PTR destline$[rsp], eax
$LN23@SkipToChan:
$LN21@SkipToChan:

; 480  :         }
; 481  :     }
; 482  : 
; 483  :     if (found)

  00178	0f b6 44 24 20	 movzx	 eax, BYTE PTR found$[rsp]
  0017d	85 c0		 test	 eax, eax
  0017f	0f 84 63 01 00
	00		 je	 $LN24@SkipToChan

; 484  :     {
; 485  :         /*  Write and skip:
; 486  : 
; 487  :               If a 'write and skip' command orders the carriage to go
; 488  :               to the channel at which it is presently located, the
; 489  :               carriage moves until that channel is again detected.
; 490  : 
; 491  :             Skip immediate:
; 492  : 
; 493  :               If the carriage is at the channel, the command does not
; 494  :               cause  any carriage motion unless the previous command
; 495  :               was 'write without spacing'.
; 496  :         */
; 497  :         if (1
; 498  :             && dev->skpimmed
; 499  :             && destline == dev->currline
; 500  :             && !dev->sp0after

  00185	33 c0		 xor	 eax, eax
  00187	83 f8 01	 cmp	 eax, 1
  0018a	74 62		 je	 SHORT $LN26@SkipToChan
  0018c	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00191	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  00197	c1 e8 08	 shr	 eax, 8
  0019a	83 e0 01	 and	 eax, 1
  0019d	85 c0		 test	 eax, eax
  0019f	74 4d		 je	 SHORT $LN26@SkipToChan
  001a1	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001a6	8b 80 a8 0d 00
	00		 mov	 eax, DWORD PTR [rax+3496]
  001ac	39 44 24 2c	 cmp	 DWORD PTR destline$[rsp], eax
  001b0	75 3c		 jne	 SHORT $LN26@SkipToChan
  001b2	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001b7	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  001bd	c1 e8 07	 shr	 eax, 7
  001c0	83 e0 01	 and	 eax, 1
  001c3	85 c0		 test	 eax, eax
  001c5	75 27		 jne	 SHORT $LN26@SkipToChan

; 501  :         )
; 502  :         {
; 503  :             /* Already at desired channel; do nothing. */
; 504  :             *unitstat = CSW_CE | CSW_DE;

  001c7	48 8b 44 24 60	 mov	 rax, QWORD PTR unitstat$[rsp]
  001cc	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 505  :             dev->sp0after = 0;

  001cf	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001d4	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  001da	0f ba f0 07	 btr	 eax, 7
  001de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  001e3	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 506  :         }

  001e9	e9 f5 00 00 00	 jmp	 $LN27@SkipToChan
$LN26@SkipToChan:

; 507  :         else /* We need to perform this skip to channel */
; 508  :         {
; 509  :             dev->sp0after = 0;

  001ee	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001f3	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  001f9	0f ba f0 07	 btr	 eax, 7
  001fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00202	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 510  : 
; 511  :             if (destline <= dev->currline || dev->ffpend)

  00208	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0020d	8b 80 a8 0d 00
	00		 mov	 eax, DWORD PTR [rax+3496]
  00213	39 44 24 2c	 cmp	 DWORD PTR destline$[rsp], eax
  00217	7e 15		 jle	 SHORT $LN29@SkipToChan
  00219	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0021e	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  00224	c1 e8 06	 shr	 eax, 6
  00227	83 e0 01	 and	 eax, 1
  0022a	85 c0		 test	 eax, eax
  0022c	74 58		 je	 SHORT $LN28@SkipToChan
$LN29@SkipToChan:

; 512  :             {
; 513  :                 dev->ffpend = 0;

  0022e	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00233	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  00239	83 e0 bf	 and	 eax, -65		; ffffffbfH
  0023c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00241	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 514  : 
; 515  :                 if (write_buffer( dev, "\f", 1, unitstat ) != 0)

  00247	4c 8b 4c 24 60	 mov	 r9, QWORD PTR unitstat$[rsp]
  0024c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168297
  00259	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0025e	e8 00 00 00 00	 call	 write_buffer
  00263	0f b6 c0	 movzx	 eax, al
  00266	85 c0		 test	 eax, eax
  00268	74 0d		 je	 SHORT $LN30@SkipToChan

; 516  :                     return *unitstat; /* (I/O error) */

  0026a	48 8b 44 24 60	 mov	 rax, QWORD PTR unitstat$[rsp]
  0026f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00272	e9 f4 01 00 00	 jmp	 $LN1@SkipToChan
$LN30@SkipToChan:

; 517  : 
; 518  :                 dev->currline = 1;

  00277	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0027c	c7 80 a8 0d 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+3496], 1
$LN28@SkipToChan:

; 519  :             }
; 520  : 
; 521  :             for (; dev->currline < destline; dev->currline++ )

  00286	eb 18		 jmp	 SHORT $LN13@SkipToChan
$LN11@SkipToChan:
  00288	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0028d	8b 80 a8 0d 00
	00		 mov	 eax, DWORD PTR [rax+3496]
  00293	ff c0		 inc	 eax
  00295	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0029a	89 81 a8 0d 00
	00		 mov	 DWORD PTR [rcx+3496], eax
$LN13@SkipToChan:
  002a0	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002a5	8b 4c 24 2c	 mov	 ecx, DWORD PTR destline$[rsp]
  002a9	39 88 a8 0d 00
	00		 cmp	 DWORD PTR [rax+3496], ecx
  002af	7d 32		 jge	 SHORT $LN12@SkipToChan

; 522  :                 if (write_buffer( dev, "\n", 1, unitstat ) != 0)

  002b1	4c 8b 4c 24 60	 mov	 r9, QWORD PTR unitstat$[rsp]
  002b6	41 b8 01 00 00
	00		 mov	 r8d, 1
  002bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168299
  002c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  002c8	e8 00 00 00 00	 call	 write_buffer
  002cd	0f b6 c0	 movzx	 eax, al
  002d0	85 c0		 test	 eax, eax
  002d2	74 0d		 je	 SHORT $LN31@SkipToChan

; 523  :                     return *unitstat; /* (I/O error) */

  002d4	48 8b 44 24 60	 mov	 rax, QWORD PTR unitstat$[rsp]
  002d9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002dc	e9 8a 01 00 00	 jmp	 $LN1@SkipToChan
$LN31@SkipToChan:
  002e1	eb a5		 jmp	 SHORT $LN11@SkipToChan
$LN12@SkipToChan:
$LN27@SkipToChan:

; 524  :         }
; 525  :     }

  002e3	e9 79 01 00 00	 jmp	 $LN25@SkipToChan
$LN24@SkipToChan:

; 526  :     else /* Channel not found! */
; 527  :     {
; 528  :         if (dev->devtype == 0x1403)

  002e8	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002ed	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  002f1	3d 03 14 00 00	 cmp	 eax, 5123		; 00001403H
  002f6	75 34		 jne	 SHORT $LN32@SkipToChan

; 529  :         {
; 530  :             /*  PROGRAMMING NOTE: skipping to a channel that did not
; 531  :             **  exist on a 1403 printer's carriage control tape would
; 532  :             **  cause the printer to begin spewing page after page of
; 533  :             **  paper as the printer kept looking for the non-existent
; 534  :             **  channel punch missing from the carriage control tape
; 535  :             **  until the operator eventually noticed and pressed the
; 536  :             **  printer STOP button causing an Intervention Required.
; 537  :             */
; 538  :             dev->stopdev = TRUE;

  002f8	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002fd	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  00303	83 c8 04	 or	 eax, 4
  00306	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0030b	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 539  :             dev->sense[0] = SENSE_IR;

  00311	b8 01 00 00 00	 mov	 eax, 1
  00316	48 6b c0 00	 imul	 rax, rax, 0
  0031a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0031f	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 540  :         }

  00327	e9 f6 00 00 00	 jmp	 $LN33@SkipToChan
$LN32@SkipToChan:

; 541  :         else // 3211, 3203-5
; 542  :         {
; 543  :             /* This condition automatically halts the skip
; 544  :                at the SECOND occurrence of FCB address one. */
; 545  : 
; 546  :             /* TECHNIQUE: first, calculate the number of lines we
; 547  :                need to advance to reach line number 1 and then print
; 548  :                that many newlines. Then simply print a number of new-
; 549  :                lines equivalent to the number of lines per page thus
; 550  :                keeping us positioned on line number 1 of the FCB.
; 551  :             */
; 552  :             int newlines = (dev->lpp - dev->currline) + 1;

  0032c	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00331	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00336	8b 89 a8 0d 00
	00		 mov	 ecx, DWORD PTR [rcx+3496]
  0033c	8b 80 90 07 00
	00		 mov	 eax, DWORD PTR [rax+1936]
  00342	2b c1		 sub	 eax, ecx
  00344	ff c0		 inc	 eax
  00346	89 44 24 30	 mov	 DWORD PTR newlines$2[rsp], eax

; 553  : 
; 554  :             for (line=0; line < newlines; line++)

  0034a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR line$[rsp], 0
  00352	eb 0a		 jmp	 SHORT $LN16@SkipToChan
$LN14@SkipToChan:
  00354	8b 44 24 28	 mov	 eax, DWORD PTR line$[rsp]
  00358	ff c0		 inc	 eax
  0035a	89 44 24 28	 mov	 DWORD PTR line$[rsp], eax
$LN16@SkipToChan:
  0035e	8b 44 24 30	 mov	 eax, DWORD PTR newlines$2[rsp]
  00362	39 44 24 28	 cmp	 DWORD PTR line$[rsp], eax
  00366	7d 32		 jge	 SHORT $LN15@SkipToChan

; 555  :                 if (write_buffer( dev, "\n", 1, unitstat ) != 0)

  00368	4c 8b 4c 24 60	 mov	 r9, QWORD PTR unitstat$[rsp]
  0036d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00373	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168303
  0037a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0037f	e8 00 00 00 00	 call	 write_buffer
  00384	0f b6 c0	 movzx	 eax, al
  00387	85 c0		 test	 eax, eax
  00389	74 0d		 je	 SHORT $LN34@SkipToChan

; 556  :                     return *unitstat; /* (I/O error) */

  0038b	48 8b 44 24 60	 mov	 rax, QWORD PTR unitstat$[rsp]
  00390	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00393	e9 d3 00 00 00	 jmp	 $LN1@SkipToChan
$LN34@SkipToChan:
  00398	eb ba		 jmp	 SHORT $LN14@SkipToChan
$LN15@SkipToChan:

; 557  : 
; 558  :             newlines = dev->lpp;

  0039a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0039f	8b 80 90 07 00
	00		 mov	 eax, DWORD PTR [rax+1936]
  003a5	89 44 24 30	 mov	 DWORD PTR newlines$2[rsp], eax

; 559  : 
; 560  :             for (line=0; line < newlines; line++)

  003a9	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR line$[rsp], 0
  003b1	eb 0a		 jmp	 SHORT $LN19@SkipToChan
$LN17@SkipToChan:
  003b3	8b 44 24 28	 mov	 eax, DWORD PTR line$[rsp]
  003b7	ff c0		 inc	 eax
  003b9	89 44 24 28	 mov	 DWORD PTR line$[rsp], eax
$LN19@SkipToChan:
  003bd	8b 44 24 30	 mov	 eax, DWORD PTR newlines$2[rsp]
  003c1	39 44 24 28	 cmp	 DWORD PTR line$[rsp], eax
  003c5	7d 2f		 jge	 SHORT $LN18@SkipToChan

; 561  :                 if (write_buffer( dev, "\n", 1, unitstat ) != 0)

  003c7	4c 8b 4c 24 60	 mov	 r9, QWORD PTR unitstat$[rsp]
  003cc	41 b8 01 00 00
	00		 mov	 r8d, 1
  003d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168305
  003d9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  003de	e8 00 00 00 00	 call	 write_buffer
  003e3	0f b6 c0	 movzx	 eax, al
  003e6	85 c0		 test	 eax, eax
  003e8	74 0a		 je	 SHORT $LN35@SkipToChan

; 562  :                     return *unitstat; /* (I/O error) */

  003ea	48 8b 44 24 60	 mov	 rax, QWORD PTR unitstat$[rsp]
  003ef	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003f2	eb 77		 jmp	 SHORT $LN1@SkipToChan
$LN35@SkipToChan:
  003f4	eb bd		 jmp	 SHORT $LN17@SkipToChan
$LN18@SkipToChan:

; 563  : 
; 564  :             /* Set the appropriate SENSE bits */
; 565  :             dev->sense[0] = SENSE_EC + SENSE_DC;

  003f6	b8 01 00 00 00	 mov	 eax, 1
  003fb	48 6b c0 00	 imul	 rax, rax, 0
  003ff	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00404	c6 84 01 64 03
	00 00 18	 mov	 BYTE PTR [rcx+rax+868], 24

; 566  :             dev->sense[1] = SENSE1_LPC;

  0040c	b8 01 00 00 00	 mov	 eax, 1
  00411	48 6b c0 01	 imul	 rax, rax, 1
  00415	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0041a	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16
$LN33@SkipToChan:

; 567  :         }
; 568  : 
; 569  :         dev->sp0after = 0;

  00422	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00427	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  0042d	0f ba f0 07	 btr	 eax, 7
  00431	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00436	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 570  :         dev->ffpend = 0;

  0043c	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00441	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  00447	83 e0 bf	 and	 eax, -65		; ffffffbfH
  0044a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0044f	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax

; 571  : 
; 572  :         /* Return unit check status */
; 573  :         return *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00455	48 8b 44 24 60	 mov	 rax, QWORD PTR unitstat$[rsp]
  0045a	c6 00 0e	 mov	 BYTE PTR [rax], 14
  0045d	b0 0e		 mov	 al, 14
  0045f	eb 0a		 jmp	 SHORT $LN1@SkipToChan
$LN25@SkipToChan:

; 574  :     }
; 575  : 
; 576  :     /* Set normal ending status */
; 577  :     *unitstat = CSW_CE | CSW_DE;

  00461	48 8b 44 24 60	 mov	 rax, QWORD PTR unitstat$[rsp]
  00466	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 578  : 
; 579  :     return 0;   /* Successful completion */

  00469	32 c0		 xor	 al, al
$LN1@SkipToChan:

; 580  : }

  0046b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0046f	c3		 ret	 0
SkipToChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
c$ = 32
i$ = 36
tv130 = 40
tv139 = 44
num$ = 48
tv216 = 52
dev$ = 80
code$ = 88
flags$ = 96
chained$ = 104
count$ = 112
iobuf$ = 120
unitstat$ = 128
residual$ = 136
WriteLine PROC

; 346  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 347  :     U32  i, num;
; 348  :     BYTE c;
; 349  : 
; 350  :     /* Start a new record if not data-chained from previous CCW */
; 351  :     if (!(chained & CCW_FLAGS_CD))

  00018	0f b6 44 24 68	 movzx	 eax, BYTE PTR chained$[rsp]
  0001d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00022	85 c0		 test	 eax, eax
  00024	75 35		 jne	 SHORT $LN11@WriteLine

; 352  :     {
; 353  :         dev->bufoff = 0;

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002b	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 354  :         dev->bufres = BUFF_SIZE;

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0003a	c7 80 e4 01 00
	00 b0 01 00 00	 mov	 DWORD PTR [rax+484], 432 ; 000001b0H

; 355  :         memset( dev->plb, 0, sizeof( dev->plb ));

  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 05 5c 0f 00
	00		 add	 rax, 3932		; 00000f5cH
  0004f	48 8b f8	 mov	 rdi, rax
  00052	33 c0		 xor	 eax, eax
  00054	b9 96 00 00 00	 mov	 ecx, 150		; 00000096H
  00059	f3 aa		 rep stosb
$LN11@WriteLine:

; 356  :     }
; 357  : 
; 358  :     /* Handle indexing. For compatibility with the 3211 Printer,
; 359  :        the optional indexing byte is accepted but ignored by the
; 360  :        3203-5.  Positive indexing (indent) is handled here.
; 361  :        Negative indexing (chop) is handled further below.
; 362  :     */
; 363  :     if (dev->index > 0 && dev->devtype != 0x3203)

  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00060	83 b8 8c 07 00
	00 00		 cmp	 DWORD PTR [rax+1932], 0
  00067	0f 8e 83 00 00
	00		 jle	 $LN12@WriteLine
  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00072	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00076	3d 03 32 00 00	 cmp	 eax, 12803		; 00003203H
  0007b	74 73		 je	 SHORT $LN12@WriteLine

; 364  :     {
; 365  :         for (i=1; i < (U32) dev->index; i++)

  0007d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00085	eb 0a		 jmp	 SHORT $LN4@WriteLine
$LN2@WriteLine:
  00087	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0008b	ff c0		 inc	 eax
  0008d	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@WriteLine:
  00091	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00096	8b 80 8c 07 00
	00		 mov	 eax, DWORD PTR [rax+1932]
  0009c	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  000a0	73 4e		 jae	 SHORT $LN3@WriteLine

; 366  :         {
; 367  :             dev->buf[ dev->bufoff ] = SPACE;

  000a2	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000a7	48 63 80 e0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+480]
  000ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000b3	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  000ba	c6 04 01 20	 mov	 BYTE PTR [rcx+rax], 32	; 00000020H

; 368  :             dev->bufoff++;

  000be	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000c3	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  000c9	ff c0		 inc	 eax
  000cb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000d0	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax

; 369  :             dev->bufres--;

  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000db	8b 80 e4 01 00
	00		 mov	 eax, DWORD PTR [rax+484]
  000e1	ff c8		 dec	 eax
  000e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000e8	89 81 e4 01 00
	00		 mov	 DWORD PTR [rcx+484], eax

; 370  :         }

  000ee	eb 97		 jmp	 SHORT $LN2@WriteLine
$LN3@WriteLine:
$LN12@WriteLine:

; 371  :     }
; 372  : 
; 373  :     /* Calculate number of bytes to write and set residual count */
; 374  :     num = (count < (U32) dev->bufres) ? count : (U32) dev->bufres;

  000f0	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000f5	8b 80 e4 01 00
	00		 mov	 eax, DWORD PTR [rax+484]
  000fb	39 44 24 70	 cmp	 DWORD PTR count$[rsp], eax
  000ff	73 0a		 jae	 SHORT $LN23@WriteLine
  00101	8b 44 24 70	 mov	 eax, DWORD PTR count$[rsp]
  00105	89 44 24 28	 mov	 DWORD PTR tv130[rsp], eax
  00109	eb 0f		 jmp	 SHORT $LN24@WriteLine
$LN23@WriteLine:
  0010b	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00110	8b 80 e4 01 00
	00		 mov	 eax, DWORD PTR [rax+484]
  00116	89 44 24 28	 mov	 DWORD PTR tv130[rsp], eax
$LN24@WriteLine:
  0011a	8b 44 24 28	 mov	 eax, DWORD PTR tv130[rsp]
  0011e	89 44 24 30	 mov	 DWORD PTR num$[rsp], eax

; 375  :     *residual = count - num;

  00122	8b 44 24 30	 mov	 eax, DWORD PTR num$[rsp]
  00126	8b 4c 24 70	 mov	 ecx, DWORD PTR count$[rsp]
  0012a	2b c8		 sub	 ecx, eax
  0012c	8b c1		 mov	 eax, ecx
  0012e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00136	89 01		 mov	 DWORD PTR [rcx], eax

; 376  : 
; 377  :     /* Copy data from the channel buffer to the device buffer.
; 378  :        Negative indexing (chop) is handled here.
; 379  :     */
; 380  :     i = (U32) ((dev->index < 0 && dev->devtype != 0x3203) ?

  00138	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0013d	83 b8 8c 07 00
	00 00		 cmp	 DWORD PTR [rax+1932], 0
  00144	7d 23		 jge	 SHORT $LN25@WriteLine
  00146	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0014b	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0014f	3d 03 32 00 00	 cmp	 eax, 12803		; 00003203H
  00154	74 13		 je	 SHORT $LN25@WriteLine
  00156	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0015b	8b 80 8c 07 00
	00		 mov	 eax, DWORD PTR [rax+1932]
  00161	f7 d8		 neg	 eax
  00163	89 44 24 2c	 mov	 DWORD PTR tv139[rsp], eax
  00167	eb 08		 jmp	 SHORT $LN26@WriteLine
$LN25@WriteLine:
  00169	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
$LN26@WriteLine:
  00171	8b 44 24 2c	 mov	 eax, DWORD PTR tv139[rsp]
  00175	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax

; 381  :                -dev->index : 0); /* Chop if requested */
; 382  :     for (; i < num; i++)

  00179	eb 0a		 jmp	 SHORT $LN7@WriteLine
$LN5@WriteLine:
  0017b	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0017f	ff c0		 inc	 eax
  00181	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@WriteLine:
  00185	8b 44 24 30	 mov	 eax, DWORD PTR num$[rsp]
  00189	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0018d	0f 83 d3 00 00
	00		 jae	 $LN6@WriteLine

; 383  :     {
; 384  :         /* Copy print line to PLB */
; 385  :         dev->plb[ dev->bufoff ] = iobuf[i];

  00193	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00197	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0019c	48 63 89 e0 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+480]
  001a3	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  001a8	48 8b 7c 24 78	 mov	 rdi, QWORD PTR iobuf$[rsp]
  001ad	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  001b1	88 84 0a 5c 0f
	00 00		 mov	 BYTE PTR [rdx+rcx+3932], al

; 386  : 
; 387  :         /* Translate EBCDIC to ASCII */
; 388  :         c = guest_to_host( dev->plb[ dev->bufoff ] );

  001b8	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001bd	48 63 80 e0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+480]
  001c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  001c9	0f b6 8c 01 5c
	0f 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+3932]
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  001d7	88 44 24 20	 mov	 BYTE PTR c$[rsp], al

; 389  : 
; 390  :         if (!c)

  001db	0f b6 44 24 20	 movzx	 eax, BYTE PTR c$[rsp]
  001e0	85 c0		 test	 eax, eax
  001e2	75 07		 jne	 SHORT $LN13@WriteLine

; 391  :             c = SPACE;

  001e4	c6 44 24 20 20	 mov	 BYTE PTR c$[rsp], 32	; 00000020H
  001e9	eb 26		 jmp	 SHORT $LN14@WriteLine
$LN13@WriteLine:

; 392  :         else if (dev->fold)

  001eb	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001f0	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  001f6	c1 e8 05	 shr	 eax, 5
  001f9	83 e0 01	 and	 eax, 1
  001fc	85 c0		 test	 eax, eax
  001fe	74 11		 je	 SHORT $LN15@WriteLine

; 393  :             c = toupper(c);

  00200	0f b6 44 24 20	 movzx	 eax, BYTE PTR c$[rsp]
  00205	8b c8		 mov	 ecx, eax
  00207	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  0020d	88 44 24 20	 mov	 BYTE PTR c$[rsp], al
$LN15@WriteLine:
$LN14@WriteLine:

; 394  : 
; 395  :         /* Copy to device output buffer */
; 396  :         dev->buf[ dev->bufoff ] = c;

  00211	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00216	48 63 80 e0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+480]
  0021d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00222	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  00229	0f b6 54 24 20	 movzx	 edx, BYTE PTR c$[rsp]
  0022e	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 397  : 
; 398  :         dev->bufoff++;

  00231	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00236	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  0023c	ff c0		 inc	 eax
  0023e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00243	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax

; 399  :         dev->bufres--;

  00249	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0024e	8b 80 e4 01 00
	00		 mov	 eax, DWORD PTR [rax+484]
  00254	ff c8		 dec	 eax
  00256	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0025b	89 81 e4 01 00
	00		 mov	 DWORD PTR [rcx+484], eax

; 400  :     }

  00261	e9 15 ff ff ff	 jmp	 $LN5@WriteLine
$LN6@WriteLine:

; 401  : 
; 402  :     /* Perform end of record processing if not data-chaining */
; 403  :     if (!(flags & CCW_FLAGS_CD))

  00266	0f b6 44 24 60	 movzx	 eax, BYTE PTR flags$[rsp]
  0026b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00270	85 c0		 test	 eax, eax
  00272	0f 85 10 01 00
	00		 jne	 $LN16@WriteLine

; 404  :     {
; 405  :         /* (trim trailing blanks...) */
; 406  : 
; 407  :         for (i = dev->bufoff; i > 0; i--)

  00278	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0027d	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  00283	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
  00287	eb 0a		 jmp	 SHORT $LN10@WriteLine
$LN8@WriteLine:
  00289	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0028d	ff c8		 dec	 eax
  0028f	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN10@WriteLine:
  00293	83 7c 24 24 00	 cmp	 DWORD PTR i$[rsp], 0
  00298	76 21		 jbe	 SHORT $LN9@WriteLine

; 408  :             if (dev->buf[ i - 1 ] != SPACE)

  0029a	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0029e	ff c8		 dec	 eax
  002a0	8b c0		 mov	 eax, eax
  002a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  002a7	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  002ae	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002b2	83 f8 20	 cmp	 eax, 32			; 00000020H
  002b5	74 02		 je	 SHORT $LN17@WriteLine

; 409  :                 break;

  002b7	eb 02		 jmp	 SHORT $LN9@WriteLine
$LN17@WriteLine:
  002b9	eb ce		 jmp	 SHORT $LN8@WriteLine
$LN9@WriteLine:

; 410  : 
; 411  :         /* Print the line unless this is a Diagnostic Write.
; 412  :            Diagnostic Writes update the Print Line buffer (PLB)
; 413  :            but otherwise don't actually print anything nor move
; 414  :            the carriage. They're like Write Without Spacing but
; 415  :            without the write.
; 416  :         */
; 417  :         if (code != 0x05)    /* If NOT diagnostic write... */

  002bb	0f b6 44 24 58	 movzx	 eax, BYTE PTR code$[rsp]
  002c0	83 f8 05	 cmp	 eax, 5
  002c3	74 7f		 je	 SHORT $LN18@WriteLine

; 418  :         {
; 419  :             /* Write print line... */
; 420  :             if (write_buffer( dev, (char*) dev->buf, i, unitstat ) != 0)

  002c5	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  002cd	44 8b 44 24 24	 mov	 r8d, DWORD PTR i$[rsp]
  002d2	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002d7	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  002de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  002e3	e8 00 00 00 00	 call	 write_buffer
  002e8	0f b6 c0	 movzx	 eax, al
  002eb	85 c0		 test	 eax, eax
  002ed	74 10		 je	 SHORT $LN19@WriteLine

; 421  :                 return *unitstat; /* (I/O error) */

  002ef	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  002f7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002fa	e9 8b 00 00 00	 jmp	 $LN1@WriteLine
$LN19@WriteLine:

; 422  : 
; 423  :             if (dev->crlf)

  002ff	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00304	8b 80 84 07 00
	00		 mov	 eax, DWORD PTR [rax+1924]
  0030a	83 e0 01	 and	 eax, 1
  0030d	85 c0		 test	 eax, eax
  0030f	74 33		 je	 SHORT $LN20@WriteLine

; 424  :                 if (write_buffer( dev, "\r", 1, unitstat ) != 0)

  00311	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  00319	41 b8 01 00 00
	00		 mov	 r8d, 1
  0031f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168252
  00326	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0032b	e8 00 00 00 00	 call	 write_buffer
  00330	0f b6 c0	 movzx	 eax, al
  00333	85 c0		 test	 eax, eax
  00335	74 0d		 je	 SHORT $LN21@WriteLine

; 425  :                     return *unitstat; /* (I/O error) */

  00337	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0033f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00342	eb 46		 jmp	 SHORT $LN1@WriteLine
$LN21@WriteLine:
$LN20@WriteLine:
$LN18@WriteLine:

; 426  :         }
; 427  : 
; 428  :         dev->sp0after = (code == 0x01) ? 1 : 0;

  00344	0f b6 44 24 58	 movzx	 eax, BYTE PTR code$[rsp]
  00349	83 f8 01	 cmp	 eax, 1
  0034c	75 0a		 jne	 SHORT $LN27@WriteLine
  0034e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv216[rsp], 1
  00356	eb 08		 jmp	 SHORT $LN28@WriteLine
$LN27@WriteLine:
  00358	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv216[rsp], 0
$LN28@WriteLine:
  00360	8b 44 24 34	 mov	 eax, DWORD PTR tv216[rsp]
  00364	83 e0 01	 and	 eax, 1
  00367	c1 e0 07	 shl	 eax, 7
  0036a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0036f	8b 89 84 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1924]
  00375	0f ba f1 07	 btr	 ecx, 7
  00379	0b c8		 or	 ecx, eax
  0037b	8b c1		 mov	 eax, ecx
  0037d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00382	89 81 84 07 00
	00		 mov	 DWORD PTR [rcx+1924], eax
$LN16@WriteLine:

; 429  :     }
; 430  : 
; 431  :     return 0;   /* Successful completion */

  00388	32 c0		 xor	 al, al
$LN1@WriteLine:

; 432  : }

  0038a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0038e	5f		 pop	 rdi
  0038f	c3		 ret	 0
WriteLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
len$ = 32
oldline$ = 36
newline$ = 40
tv154 = 44
buf$ = 48
dev$ = 80
unitstat$ = 88
spaceamt$ = 96
SpaceLines PROC

; 280  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 281  :     const char* buf;
; 282  :     int         len;
; 283  :     int         newline, oldline = dev->currline;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00018	8b 80 a8 0d 00
	00		 mov	 eax, DWORD PTR [rax+3496]
  0001e	89 44 24 24	 mov	 DWORD PTR oldline$[rsp], eax
$LN4@SpaceLines:

; 284  : 
; 285  :     ASSERT( spaceamt >= 0 && spaceamt <= 3 );   // (sanity check)

  00022	83 7c 24 60 00	 cmp	 DWORD PTR spaceamt$[rsp], 0
  00027	7c 07		 jl	 SHORT $LN9@SpaceLines
  00029	83 7c 24 60 03	 cmp	 DWORD PTR spaceamt$[rsp], 3
  0002e	7e 5c		 jle	 SHORT $LN8@SpaceLines
$LN9@SpaceLines:
$LN7@SpaceLines:
  00030	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168191
  00037	41 b8 1d 01 00
	00		 mov	 r8d, 285		; 0000011dH
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168192
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168193
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00057	85 c0		 test	 eax, eax
  00059	74 20		 je	 SHORT $LN10@SpaceLines
  0005b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168195
  00062	41 b8 1d 01 00
	00		 mov	 r8d, 285		; 0000011dH
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168196
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168197
  00076	e8 00 00 00 00	 call	 DebuggerTrace
$LN10@SpaceLines:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 af		 jne	 SHORT $LN7@SpaceLines
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00087	85 c0		 test	 eax, eax
  00089	74 01		 je	 SHORT $LN11@SpaceLines
  0008b	cc		 int	 3
$LN11@SpaceLines:
$LN8@SpaceLines:
  0008c	33 c0		 xor	 eax, eax
  0008e	85 c0		 test	 eax, eax
  00090	75 90		 jne	 SHORT $LN4@SpaceLines

; 286  : 
; 287  :     if (!(len = spaceamt))

  00092	8b 44 24 60	 mov	 eax, DWORD PTR spaceamt$[rsp]
  00096	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
  0009a	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  0009f	75 16		 jne	 SHORT $LN12@SpaceLines

; 288  :     {
; 289  :         buf = "\r";

  000a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168201
  000a8	48 89 44 24 30	 mov	 QWORD PTR buf$[rsp], rax

; 290  :         len = 1;

  000ad	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR len$[rsp], 1

; 291  :     }

  000b5	eb 0c		 jmp	 SHORT $LN13@SpaceLines
$LN12@SpaceLines:

; 292  :     else
; 293  :         buf = "\n\n\n";

  000b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168202
  000be	48 89 44 24 30	 mov	 QWORD PTR buf$[rsp], rax
$LN13@SpaceLines:

; 294  : 
; 295  :     /* Space the requested number of lines */
; 296  :     if (write_buffer( dev, buf, len, unitstat ) != 0)

  000c3	4c 8b 4c 24 58	 mov	 r9, QWORD PTR unitstat$[rsp]
  000c8	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  000cd	48 8b 54 24 30	 mov	 rdx, QWORD PTR buf$[rsp]
  000d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000d7	e8 00 00 00 00	 call	 write_buffer
  000dc	0f b6 c0	 movzx	 eax, al
  000df	85 c0		 test	 eax, eax
  000e1	74 0d		 je	 SHORT $LN14@SpaceLines

; 297  :         return *unitstat;  /* I/O error */

  000e3	48 8b 44 24 58	 mov	 rax, QWORD PTR unitstat$[rsp]
  000e8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000eb	e9 0b 01 00 00	 jmp	 $LN1@SpaceLines
$LN14@SpaceLines:

; 298  : 
; 299  :     /* Start with normal status */
; 300  :     *unitstat = CSW_CE | CSW_DE;

  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR unitstat$[rsp]
  000f5	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 301  : 
; 302  :     /* Bump current line number and save */
; 303  :     newline = oldline + spaceamt;

  000f8	8b 44 24 60	 mov	 eax, DWORD PTR spaceamt$[rsp]
  000fc	8b 4c 24 24	 mov	 ecx, DWORD PTR oldline$[rsp]
  00100	03 c8		 add	 ecx, eax
  00102	8b c1		 mov	 eax, ecx
  00104	89 44 24 28	 mov	 DWORD PTR newline$[rsp], eax

; 304  :     dev->currline = LINENUM( newline );

  00108	8b 44 24 28	 mov	 eax, DWORD PTR newline$[rsp]
  0010c	ff c8		 dec	 eax
  0010e	99		 cdq
  0010f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00114	f7 b9 90 07 00
	00		 idiv	 DWORD PTR [rcx+1936]
  0011a	8b c2		 mov	 eax, edx
  0011c	ff c0		 inc	 eax
  0011e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00123	89 81 a8 0d 00
	00		 mov	 DWORD PTR [rcx+3496], eax

; 305  : 
; 306  :     /* Check if channel 12 was passed */
; 307  :     if (1
; 308  :         &&            dev->chan12line
; 309  :         && oldline <  dev->chan12line
; 310  :         && newline >= dev->chan12line

  00129	33 c0		 xor	 eax, eax
  0012b	83 f8 01	 cmp	 eax, 1
  0012e	74 42		 je	 SHORT $LN15@SpaceLines
  00130	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00135	83 b8 a4 0d 00
	00 00		 cmp	 DWORD PTR [rax+3492], 0
  0013c	74 34		 je	 SHORT $LN15@SpaceLines
  0013e	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00143	8b 80 a4 0d 00
	00		 mov	 eax, DWORD PTR [rax+3492]
  00149	39 44 24 24	 cmp	 DWORD PTR oldline$[rsp], eax
  0014d	7d 23		 jge	 SHORT $LN15@SpaceLines
  0014f	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00154	8b 80 a4 0d 00
	00		 mov	 eax, DWORD PTR [rax+3492]
  0015a	39 44 24 28	 cmp	 DWORD PTR newline$[rsp], eax
  0015e	7c 12		 jl	 SHORT $LN15@SpaceLines

; 311  :     )
; 312  :     {
; 313  :         *unitstat |= CSW_UX;    /* Unit Exception */

  00160	48 8b 44 24 58	 mov	 rax, QWORD PTR unitstat$[rsp]
  00165	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00168	83 c8 01	 or	 eax, 1
  0016b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR unitstat$[rsp]
  00170	88 01		 mov	 BYTE PTR [rcx], al
$LN15@SpaceLines:

; 314  :     }
; 315  : 
; 316  :     /* Check if channel 9 was passed */
; 317  :     if (1
; 318  :         &&            dev->chan9line
; 319  :         && oldline <  dev->chan9line
; 320  :         && newline >= dev->chan9line

  00172	33 c0		 xor	 eax, eax
  00174	83 f8 01	 cmp	 eax, 1
  00177	74 58		 je	 SHORT $LN16@SpaceLines
  00179	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0017e	83 b8 a0 0d 00
	00 00		 cmp	 DWORD PTR [rax+3488], 0
  00185	74 4a		 je	 SHORT $LN16@SpaceLines
  00187	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0018c	8b 80 a0 0d 00
	00		 mov	 eax, DWORD PTR [rax+3488]
  00192	39 44 24 24	 cmp	 DWORD PTR oldline$[rsp], eax
  00196	7d 39		 jge	 SHORT $LN16@SpaceLines
  00198	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0019d	8b 80 a0 0d 00
	00		 mov	 eax, DWORD PTR [rax+3488]
  001a3	39 44 24 28	 cmp	 DWORD PTR newline$[rsp], eax
  001a7	7c 28		 jl	 SHORT $LN16@SpaceLines

; 321  :     )
; 322  :     {
; 323  :         /* Set unit check with channel-9 */
; 324  :         *unitstat |= CSW_UC;

  001a9	48 8b 44 24 58	 mov	 rax, QWORD PTR unitstat$[rsp]
  001ae	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001b1	83 c8 02	 or	 eax, 2
  001b4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR unitstat$[rsp]
  001b9	88 01		 mov	 BYTE PTR [rcx], al

; 325  :         dev->sense[0] = SENSE_CH9;

  001bb	b8 01 00 00 00	 mov	 eax, 1
  001c0	48 6b c0 00	 imul	 rax, rax, 0
  001c4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  001c9	c6 84 01 64 03
	00 00 01	 mov	 BYTE PTR [rcx+rax+868], 1
$LN16@SpaceLines:

; 326  :     }
; 327  : 
; 328  :     /* Return success or failure */
; 329  :     return (*unitstat & CSW_UC) ? *unitstat : 0;

  001d1	48 8b 44 24 58	 mov	 rax, QWORD PTR unitstat$[rsp]
  001d6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d9	83 e0 02	 and	 eax, 2
  001dc	85 c0		 test	 eax, eax
  001de	74 0e		 je	 SHORT $LN18@SpaceLines
  001e0	48 8b 44 24 58	 mov	 rax, QWORD PTR unitstat$[rsp]
  001e5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001e8	89 44 24 2c	 mov	 DWORD PTR tv154[rsp], eax
  001ec	eb 08		 jmp	 SHORT $LN19@SpaceLines
$LN18@SpaceLines:
  001ee	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv154[rsp], 0
$LN19@SpaceLines:
  001f6	0f b6 44 24 2c	 movzx	 eax, BYTE PTR tv154[rsp]
$LN1@SpaceLines:

; 330  : }

  001fb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ff	c3		 ret	 0
SpaceLines ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\printer.c
_TEXT	SEGMENT
rc$ = 96
tv89 = 100
tv95 = 104
tv158 = 108
tv164 = 112
fd$1 = 116
tv151 = 120
tv180 = 128
tv179 = 136
tv178 = 144
dev$ = 176
buf$ = 184
len$ = 192
unitstat$ = 200
write_buffer PROC

; 231  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 232  : int rc;
; 233  : 
; 234  :     /* Write data to the printer file */
; 235  :     if (dev->bs)

  0001b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00023	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  0002b	0f 84 c7 01 00
	00		 je	 $LN2@write_buff

; 236  :     {
; 237  :         /* Write data to socket, check for error */
; 238  :         if ((rc = write_socket( dev->fd, buf, len )) < len)

  00031	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00039	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00041	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write_socket
  00055	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax
  00059	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00060	39 44 24 60	 cmp	 DWORD PTR rc$[rsp], eax
  00064	0f 8d 89 01 00
	00		 jge	 $LN4@write_buff

; 239  :         {
; 240  :             /* Close the connection */
; 241  :             if (dev->fd != -1)

  0006a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00072	83 b8 ac 01 00
	00 ff		 cmp	 DWORD PTR [rax+428], -1
  00079	0f 84 49 01 00
	00		 je	 $LN5@write_buff

; 242  :             {
; 243  :                 int fd = dev->fd;

  0007f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00087	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [rax+428]
  0008d	89 44 24 74	 mov	 DWORD PTR fd$1[rsp], eax

; 244  :                 dev->fd = -1;

  00091	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 245  :                 close_socket( fd );

  000a3	8b 4c 24 74	 mov	 ecx, DWORD PTR fd$1[rsp]
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 246  :                 // "%1d:%04X Printer: client %s, IP %s disconnected from device %s"
; 247  :                 WRMSG( HHC01100, "I", LCSS_DEVNUM,

  000ad	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000b6	74 12		 je	 SHORT $LN8@write_buff
  000b8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000c4	89 44 24 64	 mov	 DWORD PTR tv89[rsp], eax
  000c8	eb 08		 jmp	 SHORT $LN9@write_buff
$LN8@write_buff:
  000ca	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv89[rsp], 0
$LN9@write_buff:
  000d2	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000db	74 14		 je	 SHORT $LN10@write_buff
  000dd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000e9	d1 f8		 sar	 eax, 1
  000eb	89 44 24 68	 mov	 DWORD PTR tv95[rsp], eax
  000ef	eb 08		 jmp	 SHORT $LN11@write_buff
$LN10@write_buff:
  000f1	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN11@write_buff:
  000f9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00101	48 8b 80 b8 01
	00 00		 mov	 rax, QWORD PTR [rax+440]
  00108	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv180[rsp], rax
  00110	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00118	48 8b 89 b8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+440]
  0011f	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv179[rsp], rcx
  00127	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0012f	48 8b 92 b8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+440]
  00136	48 89 94 24 90
	00 00 00	 mov	 QWORD PTR tv178[rsp], rdx
  0013e	b9 01 00 00 00	 mov	 ecx, 1
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00149	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv180[rsp]
  00151	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00155	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0015a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv179[rsp]
  00162	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00166	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0016b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv178[rsp]
  00173	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00177	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0017c	8b 4c 24 64	 mov	 ecx, DWORD PTR tv89[rsp]
  00180	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00184	8b 4c 24 68	 mov	 ecx, DWORD PTR tv95[rsp]
  00188	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168159
  00193	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168160
  0019f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a9	41 b9 03 00 00
	00		 mov	 r9d, 3
  001af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168161
  001b6	ba f8 00 00 00	 mov	 edx, 248		; 000000f8H
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168162
  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@write_buff:

; 248  :                     dev->bs->clientname, dev->bs->clientip, dev->bs->spec );
; 249  :             }
; 250  : 
; 251  :             /* Set unit check with intervention required */
; 252  :             dev->sense[0] = SENSE_IR;

  001c8	b8 01 00 00 00	 mov	 eax, 1
  001cd	48 6b c0 00	 imul	 rax, rax, 0
  001d1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001d9	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 253  :             return *unitstat = CSW_CE | CSW_DE | CSW_UC;

  001e1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  001e9	c6 00 0e	 mov	 BYTE PTR [rax], 14
  001ec	b0 0e		 mov	 al, 14
  001ee	e9 55 01 00 00	 jmp	 $LN1@write_buff
$LN4@write_buff:

; 254  :         }
; 255  :     }

  001f3	e9 4e 01 00 00	 jmp	 $LN3@write_buff
$LN2@write_buff:

; 256  :     else
; 257  :     {
; 258  :         /* Write data to the printer file, check for error */
; 259  :         if ((rc = write( dev->fd, buf, len )) < len)

  001f8	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00200	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00208	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00210	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0021c	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax
  00220	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00227	39 44 24 60	 cmp	 DWORD PTR rc$[rsp], eax
  0022b	0f 8d 15 01 00
	00		 jge	 $LN6@write_buff

; 260  :         {
; 261  :             // "%1d:%04X %s: error in function %s: %s"
; 262  :             WRMSG( HHC01250, "E", LCSS_DEVNUM,

  00231	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00236	7d 15		 jge	 SHORT $LN12@write_buff
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0023e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00246	48 89 44 24 78	 mov	 QWORD PTR tv151[rsp], rax
  0024b	eb 0c		 jmp	 SHORT $LN13@write_buff
$LN12@write_buff:
  0024d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168164
  00254	48 89 44 24 78	 mov	 QWORD PTR tv151[rsp], rax
$LN13@write_buff:
  00259	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00262	74 12		 je	 SHORT $LN14@write_buff
  00264	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0026c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00270	89 44 24 6c	 mov	 DWORD PTR tv158[rsp], eax
  00274	eb 08		 jmp	 SHORT $LN15@write_buff
$LN14@write_buff:
  00276	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
$LN15@write_buff:
  0027e	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00287	74 14		 je	 SHORT $LN16@write_buff
  00289	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00291	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00295	d1 f8		 sar	 eax, 1
  00297	89 44 24 70	 mov	 DWORD PTR tv164[rsp], eax
  0029b	eb 08		 jmp	 SHORT $LN17@write_buff
$LN16@write_buff:
  0029d	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv164[rsp], 0
$LN17@write_buff:
  002a5	b9 01 00 00 00	 mov	 ecx, 1
  002aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv151[rsp]
  002b5	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168165
  002c1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168166
  002cd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002d2	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv158[rsp]
  002d6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002da	8b 4c 24 70	 mov	 ecx, DWORD PTR tv164[rsp]
  002de	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168167
  002e9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168168
  002f5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ff	41 b9 03 00 00
	00		 mov	 r9d, 3
  00305	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168169
  0030c	ba 09 01 00 00	 mov	 edx, 265		; 00000109H
  00311	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168170
  00318	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 263  :                    "Printer", "write()",
; 264  :                    rc < 0 ? strerror( errno )
; 265  :                           : "incomplete record written");
; 266  : 
; 267  :             /* Set Equipment Check */
; 268  :             dev->sense[0] = SENSE_EC;

  0031e	b8 01 00 00 00	 mov	 eax, 1
  00323	48 6b c0 00	 imul	 rax, rax, 0
  00327	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0032f	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 269  :             return *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00337	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0033f	c6 00 0e	 mov	 BYTE PTR [rax], 14
  00342	b0 0e		 mov	 al, 14
  00344	eb 02		 jmp	 SHORT $LN1@write_buff
$LN6@write_buff:
$LN3@write_buff:

; 270  :         }
; 271  :     }
; 272  : 
; 273  :     return 0;   /* Successful completion */

  00346	32 c0		 xor	 al, al
$LN1@write_buff:

; 274  : }

  00348	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0034f	c3		 ret	 0
write_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
