; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	loadcore_cmd
PUBLIC	loadtext_cmd
EXTRN	__imp__errno:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp__stat64:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_ptyp2short:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	load_main:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$loadcore_cmd DD imagerel $LN13
	DD	imagerel $LN13+1318
	DD	imagerel $unwind$loadcore_cmd
$pdata$loadtext_cmd DD imagerel $LN86
	DD	imagerel $LN86+6718
	DD	imagerel $unwind$loadtext_cmd
pdata	ENDS
_DATA	SEGMENT
$SG159075 DB	'E', 00H
	ORG $+14
$SG159076 DB	'HHC02202%s Missing argument(s). Type ''help %s'' for ass'
	DB	'istance.', 0aH, 00H
$SG159077 DB	'loadcore_cmd', 00H
	ORG $+3
$SG159078 DB	'loadmem.c', 00H
	ORG $+2
$SG159080 DB	'stat()', 00H
	ORG $+1
$SG159081 DB	'E', 00H
	ORG $+2
$SG159082 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159083 DB	'loadcore_cmd', 00H
	ORG $+3
$SG159084 DB	'loadmem.c', 00H
	ORG $+2
$SG159088 DB	'%llx', 00H
	ORG $+3
$SG159090 DB	'E', 00H
	ORG $+2
$SG159089 DB	': invalid address', 00H
	ORG $+2
$SG159097 DB	'online', 00H
	ORG $+1
$SG159098 DB	'W', 00H
	ORG $+2
$SG159091 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+2
$SG159104 DB	'E', 00H
	ORG $+2
$SG159092 DB	'loadcore_cmd', 00H
	ORG $+3
$SG159093 DB	'loadmem.c', 00H
	ORG $+2
$SG159109 DB	'I', 00H
	ORG $+2
$SG159094 DB	'loadmem.c:61', 00H
	ORG $+3
$SG159096 DB	'loadmem.c:65', 00H
	ORG $+3
$SG159099 DB	'HHC00816%s Processor %s%02X: processor is not %s', 0aH, 00H
	ORG $+2
$SG159114 DB	'I', 00H
	ORG $+2
$SG159100 DB	'loadcore_cmd', 00H
	ORG $+3
$SG159101 DB	'loadmem.c', 00H
	ORG $+2
$SG159217 DB	0c3H, 0d7H, 0c2H
	ORG $+1
$SG159103 DB	'loadmem.c:74', 00H
	ORG $+3
$SG159105 DB	'HHC02247%s Operation rejected: CPU not stopped', 0aH, 00H
$SG159106 DB	'loadcore_cmd', 00H
	ORG $+3
$SG159107 DB	'loadmem.c', 00H
	ORG $+2
$SG159108 DB	'%llX', 00H
	ORG $+3
$SG159219 DB	0c4H, 0d5H, 0d3H
	ORG $+1
$SG159110 DB	'HHC02250%s Loading file %s to location %s', 0aH, 00H
	ORG $+1
$SG159221 DB	0c9H, 0c3H, 0e2H
	ORG $+1
$SG159111 DB	'loadcore_cmd', 00H
	ORG $+3
$SG159112 DB	'loadmem.c', 00H
	ORG $+2
$SG159223 DB	0d3H, 0c4H, 0e3H
	ORG $+1
$SG159113 DB	'loadmem.c:88', 00H
	ORG $+3
$SG159115 DB	'HHC02249%s Operation complete', 0aH, 00H
	ORG $+1
$SG159116 DB	'loadcore_cmd', 00H
	ORG $+3
$SG159117 DB	'loadmem.c', 00H
	ORG $+2
$SG159225 DB	0d7H, 0c1H, 0c4H
	ORG $+1
$SG159205 DB	'@@@@@@@@'
	ORG $+4
$SG159227 DB	0d7H, 0d8H, 0e3H
	ORG $+1
$SG159207 DB	0c5H, 0e2H, 0c4H, '@@@@@@'
	ORG $+3
$SG159209 DB	0e3H, 0e7H, 0e3H, '@'
	ORG $+4
$SG159229 DB	0d7H, 0d8H, 0d4H
	ORG $+1
$SG159211 DB	0d9H, 0d3H, 0c4H, '@@@@@@'
	ORG $+3
$SG159213 DB	0c5H, 0d5H, 0c4H, '@'
	ORG $+4
$SG159231 DB	0d9H, 0c5H, 0d7H
	ORG $+1
$SG159215 DB	0e2H, 0e8H, 0d4H, '@@@@@@'
	ORG $+3
$SG159233 DB	0e2H, 0d3H, 0c3H
	ORG $+1
$SG159235 DB	0e1H, 0d7H, 0c2H
	ORG $+1
$SG159237 DB	0e1H, 0e8H, 0e1H
	ORG $+1
$SG159239 DB	0e4H, 0d7H, 0c2H
	ORG $+1
$SG159241 DB	0e5H, 0c5H, 0d8H
	ORG $+1
$SG159243 DB	'E', 00H
	ORG $+6
$SG159245 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159250 DB	'%llx', 00H
	ORG $+3
$SG159244 DB	'HHC02202%s Missing argument(s). Type ''help %s'' for ass'
	DB	'istance.', 0aH, 00H
$SG159246 DB	'loadmem.c', 00H
	ORG $+2
$SG159252 DB	'E', 00H
	ORG $+2
$SG159251 DB	': invalid address', 00H
	ORG $+2
$SG159257 DB	'E', 00H
	ORG $+2
$SG159253 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+2
$SG159262 DB	'E', 00H
	ORG $+2
$SG159254 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159255 DB	'loadmem.c', 00H
	ORG $+2
$SG159269 DB	'online', 00H
	ORG $+1
$SG159270 DB	'W', 00H
	ORG $+2
$SG159258 DB	'HHC02251%s Address exceeds main storage size', 0aH, 00H
	ORG $+2
$SG159259 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159260 DB	'loadmem.c', 00H
	ORG $+2
$SG159276 DB	'E', 00H
	ORG $+2
$SG159263 DB	'HHC02306%s %s: Address %s not on quadword boundary', 0aH
	DB	00H
$SG159282 DB	'E', 00H
	ORG $+2
$SG159264 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159265 DB	'loadmem.c', 00H
	ORG $+2
$SG159288 DB	'open()', 00H
	ORG $+1
$SG159289 DB	'E', 00H
	ORG $+2
$SG159266 DB	'loadmem.c:231', 00H
	ORG $+2
$SG159268 DB	'loadmem.c:235', 00H
	ORG $+2
$SG159271 DB	'HHC00816%s Processor %s%02X: processor is not %s', 0aH, 00H
	ORG $+2
$SG159297 DB	'E', 00H
	ORG $+2
$SG159272 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159273 DB	'loadmem.c', 00H
	ORG $+2
$SG159303 DB	'E', 00H
	ORG $+2
$SG159275 DB	'loadmem.c:243', 00H
	ORG $+2
$SG159277 DB	'HHC02251%s Address exceeds main storage size', 0aH, 00H
	ORG $+2
$SG159278 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159279 DB	'loadmem.c', 00H
	ORG $+2
$SG159312 DB	'E', 00H
	ORG $+2
$SG159281 DB	'loadmem.c:251', 00H
	ORG $+2
$SG159283 DB	'HHC02247%s Operation rejected: CPU not stopped', 0aH, 00H
$SG159284 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159285 DB	'loadmem.c', 00H
	ORG $+2
$SG159330 DB	'W', 00H
	ORG $+2
$SG159287 DB	'loadmem.c:260', 00H
	ORG $+2
$SG159290 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159291 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159292 DB	'loadmem.c', 00H
	ORG $+2
$SG159343 DB	'W', 00H
	ORG $+2
$SG159296 DB	'loadtext read()', 00H
$SG159298 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG159299 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159300 DB	'loadmem.c', 00H
	ORG $+6
$SG159304 DB	'HHC02301%s %s: Unexpected read length at record %d; expe'
	DB	'cted %d-byte record', 0aH, 00H
	ORG $+3
$SG159305 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159306 DB	'loadmem.c', 00H
	ORG $+6
$SG159313 DB	'HHC02307%s %s: Record %d relocation value %6.6llX addres'
	DB	's exceeds main storage size', 0aH, 00H
	ORG $+3
$SG159314 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159315 DB	'loadmem.c', 00H
	ORG $+6
$SG159332 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159352 DB	'W', 00H
	ORG $+6
$SG159331 DB	'HHC02307%s %s: Record %d relocation value %6.6llX addres'
	DB	's exceeds main storage size', 0aH, 00H
	ORG $+3
$SG159333 DB	'loadmem.c', 00H
	ORG $+6
$SG159345 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159356 DB	'W', 00H
	ORG $+6
$SG159344 DB	'HHC02307%s %s: Record %d relocation value %6.6llX addres'
	DB	's exceeds main storage size', 0aH, 00H
	ORG $+3
$SG159346 DB	'loadmem.c', 00H
	ORG $+6
$SG159354 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159361 DB	'E', 00H
	ORG $+6
$SG159353 DB	'HHC02309%s %s: Record %d is unsupported record type %s; '
	DB	'skipped', 0aH, 00H
	ORG $+3
$SG159367 DB	'W', 00H
	ORG $+2
$SG159355 DB	'loadmem.c', 00H
	ORG $+2
$SG159372 DB	'E', 00H
	ORG $+2
$SG159357 DB	'HHC02302%s %s: Record %d is unknown record type %s; skip'
	DB	'ped', 0aH, 00H
	ORG $+3
$SG159358 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159359 DB	'loadmem.c', 00H
	ORG $+2
$SG159378 DB	'W', 00H
	ORG $+2
$SG159362 DB	'HHC02303%s %s: GOFF object found at record %d; aborting', 0aH
	DB	00H
	ORG $+3
$SG159382 DB	'I', 00H
	ORG $+2
$SG159363 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159364 DB	'loadmem.c', 00H
	ORG $+6
$SG159368 DB	'HHC02304%s %s: Record %d is unknown record type; skipped'
	DB	0aH, 00H
	ORG $+6
$SG159369 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159370 DB	'loadmem.c', 00H
	ORG $+6
$SG159373 DB	'HHC02305%s %s: Record %d is unknown record type; abortin'
	DB	'g', 0aH, 00H
	ORG $+5
$SG159374 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159375 DB	'loadmem.c', 00H
	ORG $+14
$SG159379 DB	'HHC02308%s %s: Warning messages issued, review before ex'
	DB	'ecuting', 0aH, 00H
	ORG $+7
$SG159380 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159381 DB	'loadmem.c', 00H
	ORG $+6
$SG159383 DB	'HHC02249%s Operation complete', 0aH, 00H
	ORG $+1
$SG159384 DB	'loadtext_cmd', 00H
	ORG $+3
$SG159385 DB	'loadmem.c', 00H
	ORG $+6
$SG159386 DB	'loadmem.c:625', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:loadtext_cmd
	DD	021H
	DD	01a24H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:loadcore_cmd
	DD	01fH
	DD	050eH
voltbl	ENDS
xdata	SEGMENT
$unwind$loadcore_cmd DD 022719H
	DD	0430115H
	DD	imagerel __GSHandlerCheck
	DD	0200H
$unwind$loadtext_cmd DD 042919H
	DD	0710117H
	DD	0600f7010H
	DD	imagerel __GSHandlerCheck
	DD	0370H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadmem.c
_TEXT	SEGMENT
rc$ = 80
recno$ = 84
n$1 = 88
reloc$2 = 96
aaddr$ = 104
v$3 = 112
count$4 = 120
acl$5 = 124
msgbuf$6 = 128
msgbuf$7 = 132
tv538 = 136
rlen$8 = 140
len$9 = 144
aarel$10 = 148
seglength$11 = 152
fd$ = 156
ahighaddr$ = 160
n$12 = 168
tv778 = 172
terminate$ = 176
c_ObjectPAD$ = 180
c_ObjectSPB$ = 184
c_ObjectLDT$ = 188
c_ObjectCPB$ = 192
c_ObjectDEL$ = 196
c_ObjectICS$ = 200
c_ObjectPRT$ = 204
c_ObjectPRM$ = 208
c_ObjectREP$ = 212
c_ObjectSLC$ = 216
c_ObjectSYS$ = 220
c_ObjectUPB$ = 224
c_ObjectVER$ = 228
lastbyte$13 = 232
regs$ = 240
pesdid$14 = 248
resdid$15 = 252
c_ObjectTXT$ = 256
tv740 = 260
tv739 = 264
c_ObjectEND$ = 268
tv756 = 272
loadaddr$ = 280
tv896 = 288
tv607 = 296
rstart$16 = 304
vc$17 = 312
tv263 = 320
work64$ = 328
tv310 = 336
tv345 = 344
fname$ = 352
tv443 = 360
tv504 = 368
tv523 = 376
tv594 = 384
rend$18 = 392
tv758 = 400
tv761 = 408
tv903 = 416
tv1035 = 424
tv1071 = 432
tv1084 = 440
tv1097 = 448
tv1110 = 456
tv1132 = 464
blanks$ = 472
buf$ = 480
c_ObjectRLD$ = 560
c_ObjectESD$ = 576
c_ObjectSYM$ = 592
pathname$ = 608
__$ArrayPad$ = 880
argc$ = 928
argv$ = 936
cmdline$ = 944
loadtext_cmd PROC

; 101  : {

$LN86:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 88 03
	00 00		 sub	 rsp, 904		; 00000388H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 70
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 102  :     const char blanks[8]     = {"\x40\x40\x40\x40\x40\x40\x40\x40"};

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR $SG159205
  00030	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR blanks$[rsp], rax

; 103  : 
; 104  : 
; 105  :     /* Object deck record format headers                             */
; 106  :     /* (names chosen not to conflict with future GOFF support)       */
; 107  : 
; 108  :     const char c_ObjectESD[9] = {"\xC5\xE2\xC4\x40\x40\x40\x40\x40\x40"};       // ESD - External Symbol Dictionary

  00038	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR c_ObjectESD$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159207
  00047	48 8b f8	 mov	 rdi, rax
  0004a	48 8b f1	 mov	 rsi, rcx
  0004d	b9 09 00 00 00	 mov	 ecx, 9
  00052	f3 a4		 rep movsb

; 109  :     const char c_ObjectTXT[4]  = {"\xE3\xE7\xE3\x40"};                          // TXT - Text

  00054	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR $SG159209
  0005a	89 84 24 00 01
	00 00		 mov	 DWORD PTR c_ObjectTXT$[rsp], eax

; 110  :     const char c_ObjectRLD[9] = {"\xD9\xD3\xC4\x40\x40\x40\x40\x40\x40"};       // RLD - Relocation Dictionary

  00061	48 8d 84 24 30
	02 00 00	 lea	 rax, QWORD PTR c_ObjectRLD$[rsp]
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159211
  00070	48 8b f8	 mov	 rdi, rax
  00073	48 8b f1	 mov	 rsi, rcx
  00076	b9 09 00 00 00	 mov	 ecx, 9
  0007b	f3 a4		 rep movsb

; 111  :     const char c_ObjectEND[4]  = {"\xC5\xD5\xC4\x40"};                          // END - End

  0007d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR $SG159213
  00083	89 84 24 0c 01
	00 00		 mov	 DWORD PTR c_ObjectEND$[rsp], eax

; 112  :     const char c_ObjectSYM[9] = {"\xE2\xE8\xD4\x40\x40\x40\x40\x40\x40"};       // SYM - Symbol

  0008a	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR c_ObjectSYM$[rsp]
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159215
  00099	48 8b f8	 mov	 rdi, rax
  0009c	48 8b f1	 mov	 rsi, rcx
  0009f	b9 09 00 00 00	 mov	 ecx, 9
  000a4	f3 a4		 rep movsb

; 113  : 
; 114  : 
; 115  :     /* Special control directives from VM                            */
; 116  : 
; 117  :     const char c_ObjectCPB[3]  = {"\xC3\xD7\xC2"};                              // CPB - Conditional Page Boundary

  000a6	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR c_ObjectCPB$[rsp]
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159217
  000b5	48 8b f8	 mov	 rdi, rax
  000b8	48 8b f1	 mov	 rsi, rcx
  000bb	b9 03 00 00 00	 mov	 ecx, 3
  000c0	f3 a4		 rep movsb

; 118  :     const char c_ObjectDEL[3]  = {"\xC4\xD5\xD3"};                              // DEL - Delete

  000c2	48 8d 84 24 c4
	00 00 00	 lea	 rax, QWORD PTR c_ObjectDEL$[rsp]
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159219
  000d1	48 8b f8	 mov	 rdi, rax
  000d4	48 8b f1	 mov	 rsi, rcx
  000d7	b9 03 00 00 00	 mov	 ecx, 3
  000dc	f3 a4		 rep movsb

; 119  :     const char c_ObjectICS[3]  = {"\xC9\xC3\xE2"};                              // ICS - Include Control Section

  000de	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR c_ObjectICS$[rsp]
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159221
  000ed	48 8b f8	 mov	 rdi, rax
  000f0	48 8b f1	 mov	 rsi, rcx
  000f3	b9 03 00 00 00	 mov	 ecx, 3
  000f8	f3 a4		 rep movsb

; 120  :     const char c_ObjectLDT[3]  = {"\xD3\xC4\xE3"};                              // LDT - Loader Termination

  000fa	48 8d 84 24 bc
	00 00 00	 lea	 rax, QWORD PTR c_ObjectLDT$[rsp]
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159223
  00109	48 8b f8	 mov	 rdi, rax
  0010c	48 8b f1	 mov	 rsi, rcx
  0010f	b9 03 00 00 00	 mov	 ecx, 3
  00114	f3 a4		 rep movsb

; 121  :     const char c_ObjectPAD[3]  = {"\xD7\xC1\xC4"};                              // PAD - Padding

  00116	48 8d 84 24 b4
	00 00 00	 lea	 rax, QWORD PTR c_ObjectPAD$[rsp]
  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159225
  00125	48 8b f8	 mov	 rdi, rax
  00128	48 8b f1	 mov	 rsi, rcx
  0012b	b9 03 00 00 00	 mov	 ecx, 3
  00130	f3 a4		 rep movsb

; 122  :     const char c_ObjectPRT[3]  = {"\xD7\xD8\xE3"};                              // PRT - Printer

  00132	48 8d 84 24 cc
	00 00 00	 lea	 rax, QWORD PTR c_ObjectPRT$[rsp]
  0013a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159227
  00141	48 8b f8	 mov	 rdi, rax
  00144	48 8b f1	 mov	 rsi, rcx
  00147	b9 03 00 00 00	 mov	 ecx, 3
  0014c	f3 a4		 rep movsb

; 123  :     const char c_ObjectPRM[3]  = {"\xD7\xD8\xD4"};                              // PRM - Parameter

  0014e	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR c_ObjectPRM$[rsp]
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159229
  0015d	48 8b f8	 mov	 rdi, rax
  00160	48 8b f1	 mov	 rsi, rcx
  00163	b9 03 00 00 00	 mov	 ecx, 3
  00168	f3 a4		 rep movsb

; 124  :     const char c_ObjectREP[3]  = {"\xD9\xC5\xD7"};                              // REP - Replace

  0016a	48 8d 84 24 d4
	00 00 00	 lea	 rax, QWORD PTR c_ObjectREP$[rsp]
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159231
  00179	48 8b f8	 mov	 rdi, rax
  0017c	48 8b f1	 mov	 rsi, rcx
  0017f	b9 03 00 00 00	 mov	 ecx, 3
  00184	f3 a4		 rep movsb

; 125  :     const char c_ObjectSLC[3]  = {"\xE2\xD3\xC3"};                              // SLC - Set Location Counter

  00186	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR c_ObjectSLC$[rsp]
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159233
  00195	48 8b f8	 mov	 rdi, rax
  00198	48 8b f1	 mov	 rsi, rcx
  0019b	b9 03 00 00 00	 mov	 ecx, 3
  001a0	f3 a4		 rep movsb

; 126  :     const char c_ObjectSPB[3]  = {"\xE1\xD7\xC2"};                              // SPB - Set Page Boundary

  001a2	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR c_ObjectSPB$[rsp]
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159235
  001b1	48 8b f8	 mov	 rdi, rax
  001b4	48 8b f1	 mov	 rsi, rcx
  001b7	b9 03 00 00 00	 mov	 ecx, 3
  001bc	f3 a4		 rep movsb

; 127  :     const char c_ObjectSYS[3]  = {"\xE1\xE8\xE1"};                              // SYS - Subsystem

  001be	48 8d 84 24 dc
	00 00 00	 lea	 rax, QWORD PTR c_ObjectSYS$[rsp]
  001c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159237
  001cd	48 8b f8	 mov	 rdi, rax
  001d0	48 8b f1	 mov	 rsi, rcx
  001d3	b9 03 00 00 00	 mov	 ecx, 3
  001d8	f3 a4		 rep movsb

; 128  :     const char c_ObjectUPB[3]  = {"\xE4\xD7\xC2"};                              // UPB - Unconditional Page Boundary

  001da	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR c_ObjectUPB$[rsp]
  001e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159239
  001e9	48 8b f8	 mov	 rdi, rax
  001ec	48 8b f1	 mov	 rsi, rcx
  001ef	b9 03 00 00 00	 mov	 ecx, 3
  001f4	f3 a4		 rep movsb

; 129  :     const char c_ObjectVER[3]  = {"\xE5\xC5\xD8"};                              // VER - Verify

  001f6	48 8d 84 24 e4
	00 00 00	 lea	 rax, QWORD PTR c_ObjectVER$[rsp]
  001fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159241
  00205	48 8b f8	 mov	 rdi, rax
  00208	48 8b f1	 mov	 rsi, rcx
  0020b	b9 03 00 00 00	 mov	 ecx, 3
  00210	f3 a4		 rep movsb

; 130  : 
; 131  : 
; 132  :     /* Define byte tests for general record types                    */
; 133  : 
; 134  : #define TextRecord              0x02
; 135  : #define GOFFRecord              0x03
; 136  : #define CommentRecord           0x5C
; 137  : #define LoaderBinderRecord      0x40
; 138  : 
; 139  : 
; 140  :     /* Define directive tests                                        */
; 141  : 
; 142  : #define ObjectTest(n) (NCMP(c_Object##n, buf+1, sizeof(c_Object##n)))
; 143  : 
; 144  : #define ObjectESD (ObjectTest(ESD) && \
; 145  :                    NCMP(buf+12, blanks, 2) && \
; 146  :                    NCMP(buf+64, blanks, 8))
; 147  : 
; 148  : #define ObjectTXT (ObjectTest(TXT) && \
; 149  :                    NCMP(buf+8, blanks, 2) && \
; 150  :                    NCMP(buf+12, blanks, 2))
; 151  : 
; 152  : #define ObjectRLD (ObjectTest(RLD) && \
; 153  :                    NCMP(buf+12, blanks, 4))
; 154  : 
; 155  : #define ObjectEND (ObjectTest(END) && \
; 156  :                    NCMP(buf+8, blanks, 6) && \
; 157  :                    NCMP(buf+24, blanks, 4) && \
; 158  :                    NCMP(buf+71, blanks, 1))
; 159  : 
; 160  : #define ObjectSYM (ObjectTest(SYM) && \
; 161  :                    NCMP(buf+12, blanks, 4))
; 162  : 
; 163  : 
; 164  : #define ObjectCPB (ObjectTest(CPB))
; 165  : #define ObjectDEL (ObjectTest(DEL))
; 166  : #define ObjectICS (ObjectTest(ICS))
; 167  : #define ObjectLDT (ObjectTest(LDT))
; 168  : #define ObjectPAD (ObjectTest(PAD))
; 169  : #define ObjectPRT (ObjectTest(PRT))
; 170  : #define ObjectPRM (ObjectTest(PRM))
; 171  : #define ObjectREP (ObjectTest(REP))
; 172  : #define ObjectSLC (ObjectTest(SLC))
; 173  : #define ObjectSPB (ObjectTest(SPB))
; 174  : #define ObjectSYS (ObjectTest(SYS))
; 175  : #define ObjectUPB (ObjectTest(UPB))
; 176  : #define ObjectVER (ObjectTest(VER))
; 177  : 
; 178  : 
; 179  :     char   *fname;                      /* -> File name (ASCIIZ)     */
; 180  :     char   *loadaddr;                   /* loadcore memory address   */
; 181  :     U64     work64;                     /* 64-bit work variable      */
; 182  :     RADR    aaddr;                      /* Absolute storage address  */
; 183  :     RADR    ahighaddr;                  /* Absolute high address     */
; 184  :     int     fd;                         /* File descriptor           */
; 185  :     BYTE    buf[80];                    /* Read buffer               */
; 186  :     int     recno;                      /* Record number             */
; 187  :     int     rc = 0;                     /* Return code               */

  00212	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 188  :     int     terminate = 0;              /* Terminate load process    */

  0021a	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR terminate$[rsp], 0
$LN4@loadtext_c:

; 189  :     REGS   *regs;
; 190  :     char    pathname[MAX_PATH];
; 191  : 
; 192  :     UNREFERENCED(cmdline);

  00225	33 c0		 xor	 eax, eax
  00227	85 c0		 test	 eax, eax
  00229	75 fa		 jne	 SHORT $LN4@loadtext_c

; 193  : 
; 194  :     if (argc < 2)

  0022b	83 bc 24 a0 03
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00233	7d 7b		 jge	 SHORT $LN25@loadtext_c

; 195  :     {
; 196  :         WRMSG(HHC02202, "E", argv[0] );

  00235	b8 08 00 00 00	 mov	 eax, 8
  0023a	48 6b c0 00	 imul	 rax, rax, 0
  0023e	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv263[rsp], rax
  00246	b9 01 00 00 00	 mov	 ecx, 1
  0024b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00251	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00259	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR tv263[rsp]
  00261	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00265	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0026a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159243
  00271	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159244
  0027d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00282	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00287	41 b9 03 00 00
	00		 mov	 r9d, 3
  0028d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159245
  00294	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  00299	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159246
  002a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 197  :         return -1;

  002a6	b8 ff ff ff ff	 mov	 eax, -1
  002ab	e9 74 17 00 00	 jmp	 $LN1@loadtext_c
$LN25@loadtext_c:

; 198  :     }
; 199  : 
; 200  :     fname = argv[1];

  002b0	b8 08 00 00 00	 mov	 eax, 8
  002b5	48 6b c0 01	 imul	 rax, rax, 1
  002b9	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002c1	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  002c5	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR fname$[rsp], rax

; 201  : 
; 202  :     if (argc < 3)

  002cd	83 bc 24 a0 03
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  002d5	7d 0e		 jge	 SHORT $LN26@loadtext_c

; 203  :         aaddr = 0;

  002d7	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR aaddr$[rsp], 0
  002e0	e9 b5 01 00 00	 jmp	 $LN27@loadtext_c
$LN26@loadtext_c:

; 204  :     else
; 205  :     {
; 206  :         loadaddr = argv[2];

  002e5	b8 08 00 00 00	 mov	 eax, 8
  002ea	48 6b c0 02	 imul	 rax, rax, 2
  002ee	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002f6	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  002fa	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR loadaddr$[rsp], rax

; 207  : 
; 208  :         if (sscanf(loadaddr, "%"SCNx64, &work64) !=1)

  00302	4c 8d 84 24 48
	01 00 00	 lea	 r8, QWORD PTR work64$[rsp]
  0030a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159250
  00311	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR loadaddr$[rsp]
  00319	e8 00 00 00 00	 call	 sscanf
  0031e	83 f8 01	 cmp	 eax, 1
  00321	74 6a		 je	 SHORT $LN28@loadtext_c

; 209  :         {
; 210  :             WRMSG(HHC02205, "E", loadaddr, ": invalid address" );

  00323	b9 01 00 00 00	 mov	 ecx, 1
  00328	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0032e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159251
  00335	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0033a	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR loadaddr$[rsp]
  00342	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00347	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159252
  0034e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00353	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159253
  0035a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0035f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00364	41 b9 03 00 00
	00		 mov	 r9d, 3
  0036a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159254
  00371	ba d2 00 00 00	 mov	 edx, 210		; 000000d2H
  00376	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159255
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 211  :             return -1;

  00383	b8 ff ff ff ff	 mov	 eax, -1
  00388	e9 97 16 00 00	 jmp	 $LN1@loadtext_c
$LN28@loadtext_c:

; 212  :         }
; 213  :         aaddr = (RADR) work64;

  0038d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR work64$[rsp]
  00395	48 89 44 24 68	 mov	 QWORD PTR aaddr$[rsp], rax

; 214  : 
; 215  :         if (aaddr >= sysblk.mainsize)

  0039a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003a1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  003a8	48 39 44 24 68	 cmp	 QWORD PTR aaddr$[rsp], rax
  003ad	72 51		 jb	 SHORT $LN29@loadtext_c

; 216  :         {
; 217  :             WRMSG( HHC02251, "E" );

  003af	b9 01 00 00 00	 mov	 ecx, 1
  003b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159257
  003c1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159258
  003cd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003d7	41 b9 03 00 00
	00		 mov	 r9d, 3
  003dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159259
  003e4	ba d9 00 00 00	 mov	 edx, 217		; 000000d9H
  003e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159260
  003f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 218  :             return -1;

  003f6	b8 ff ff ff ff	 mov	 eax, -1
  003fb	e9 24 16 00 00	 jmp	 $LN1@loadtext_c
$LN29@loadtext_c:

; 219  :         }
; 220  : 
; 221  :         /* Address must be on quadword boundary to maintain alignment */
; 222  :         if (aaddr & 0x0F)

  00400	48 8b 44 24 68	 mov	 rax, QWORD PTR aaddr$[rsp]
  00405	48 83 e0 0f	 and	 rax, 15
  00409	48 85 c0	 test	 rax, rax
  0040c	0f 84 88 00 00
	00		 je	 $LN30@loadtext_c

; 223  :         {
; 224  :             WRMSG( HHC02306, "E", argv[0], loadaddr);

  00412	b8 08 00 00 00	 mov	 eax, 8
  00417	48 6b c0 00	 imul	 rax, rax, 0
  0041b	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv310[rsp], rax
  00423	b9 01 00 00 00	 mov	 ecx, 1
  00428	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0042e	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR loadaddr$[rsp]
  00436	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0043b	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00443	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR tv310[rsp]
  0044b	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0044f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00454	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159262
  0045b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00460	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159263
  00467	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0046c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00471	41 b9 03 00 00
	00		 mov	 r9d, 3
  00477	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159264
  0047e	ba e0 00 00 00	 mov	 edx, 224		; 000000e0H
  00483	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159265
  0048a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 225  :             return -1;

  00490	b8 ff ff ff ff	 mov	 eax, -1
  00495	e9 8a 15 00 00	 jmp	 $LN1@loadtext_c
$LN30@loadtext_c:
$LN27@loadtext_c:

; 226  :         }
; 227  :     }
; 228  : 
; 229  :     ahighaddr = aaddr;

  0049a	48 8b 44 24 68	 mov	 rax, QWORD PTR aaddr$[rsp]
  0049f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR ahighaddr$[rsp], rax

; 230  : 
; 231  :     obtain_lock(&sysblk.cpulock[sysblk.pcpu]);

  004a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004ae	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  004b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004bc	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  004c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159266
  004cb	48 8b c8	 mov	 rcx, rax
  004ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 232  : 
; 233  :     if (!IS_CPU_ONLINE(sysblk.pcpu))

  004d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004db	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  004e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004e9	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  004f2	0f 85 d0 00 00
	00		 jne	 $LN31@loadtext_c

; 234  :     {
; 235  :         release_lock(&sysblk.cpulock[sysblk.pcpu]);

  004f8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004ff	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00506	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0050d	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00515	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159268
  0051c	48 8b c8	 mov	 rcx, rax
  0051f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 236  :         WRMSG(HHC00816, "W", PTYPSTR(sysblk.pcpu), sysblk.pcpu, "online");

  00525	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0052c	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00533	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0053a	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  00542	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00548	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv345[rsp], rax
  00550	b9 01 00 00 00	 mov	 ecx, 1
  00555	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0055b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159269
  00562	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00567	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0056e	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  00574	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00578	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv345[rsp]
  00580	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00585	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159270
  0058c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00591	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159271
  00598	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0059d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005a2	41 b9 03 00 00
	00		 mov	 r9d, 3
  005a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159272
  005af	ba ec 00 00 00	 mov	 edx, 236		; 000000ecH
  005b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159273
  005bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 237  :         return 0;

  005c1	33 c0		 xor	 eax, eax
  005c3	e9 5c 14 00 00	 jmp	 $LN1@loadtext_c
$LN31@loadtext_c:

; 238  :     }
; 239  :     regs = sysblk.regs[sysblk.pcpu];

  005c8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005cf	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  005d6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005dd	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  005e5	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR regs$[rsp], rax

; 240  : 
; 241  :     if (aaddr > regs->mainlim)

  005ed	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005f5	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  005fc	48 39 44 24 68	 cmp	 QWORD PTR aaddr$[rsp], rax
  00601	76 7e		 jbe	 SHORT $LN32@loadtext_c

; 242  :     {
; 243  :         release_lock(&sysblk.cpulock[sysblk.pcpu]);

  00603	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0060a	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00611	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00618	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00620	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159275
  00627	48 8b c8	 mov	 rcx, rax
  0062a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 244  :         WRMSG(HHC02251, "E");

  00630	b9 01 00 00 00	 mov	 ecx, 1
  00635	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0063b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159276
  00642	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00647	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159277
  0064e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00653	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00658	41 b9 03 00 00
	00		 mov	 r9d, 3
  0065e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159278
  00665	ba f4 00 00 00	 mov	 edx, 244		; 000000f4H
  0066a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159279
  00671	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 245  :         return -1;

  00677	b8 ff ff ff ff	 mov	 eax, -1
  0067c	e9 a3 13 00 00	 jmp	 $LN1@loadtext_c
$LN32@loadtext_c:

; 246  :     }
; 247  : 
; 248  :     /* Command is valid only when CPU is stopped */
; 249  :     if (CPUSTATE_STOPPED != regs->cpustate)

  00681	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00689	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  0068d	83 f8 03	 cmp	 eax, 3
  00690	74 7e		 je	 SHORT $LN33@loadtext_c

; 250  :     {
; 251  :         release_lock(&sysblk.cpulock[sysblk.pcpu]);

  00692	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00699	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  006a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006a7	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  006af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159281
  006b6	48 8b c8	 mov	 rcx, rax
  006b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 252  :         WRMSG(HHC02247, "E");

  006bf	b9 01 00 00 00	 mov	 ecx, 1
  006c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159282
  006d1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159283
  006dd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006e7	41 b9 03 00 00
	00		 mov	 r9d, 3
  006ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159284
  006f4	ba fc 00 00 00	 mov	 edx, 252		; 000000fcH
  006f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159285
  00700	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 253  :         return -1;

  00706	b8 ff ff ff ff	 mov	 eax, -1
  0070b	e9 14 13 00 00	 jmp	 $LN1@loadtext_c
$LN33@loadtext_c:

; 254  :     }
; 255  : 
; 256  :     /* Open the specified file name */
; 257  :     hostpath(pathname, fname, sizeof(pathname));

  00710	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00716	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  0071e	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00726	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 258  :     if ((fd = HOPEN (pathname, O_RDONLY | O_BINARY)) < 0)

  0072c	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00731	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00739	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  0073f	89 84 24 9c 00
	00 00		 mov	 DWORD PTR fd$[rsp], eax
  00746	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR fd$[rsp], 0
  0074e	0f 8d ad 00 00
	00		 jge	 $LN34@loadtext_c

; 259  :     {
; 260  :         release_lock(&sysblk.cpulock[sysblk.pcpu]);

  00754	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0075b	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00762	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00769	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00771	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159287
  00778	48 8b c8	 mov	 rcx, rax
  0077b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 261  :         WRMSG(HHC02219,"E", "open()", strerror(errno));

  00781	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00787	8b 08		 mov	 ecx, DWORD PTR [rax]
  00789	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0078f	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv443[rsp], rax
  00797	b9 01 00 00 00	 mov	 ecx, 1
  0079c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007a2	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv443[rsp]
  007aa	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  007af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159288
  007b6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  007bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159289
  007c2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159290
  007ce	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007d8	41 b9 03 00 00
	00		 mov	 r9d, 3
  007de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159291
  007e5	ba 05 01 00 00	 mov	 edx, 261		; 00000105H
  007ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159292
  007f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 262  :         return -1;

  007f7	b8 ff ff ff ff	 mov	 eax, -1
  007fc	e9 23 12 00 00	 jmp	 $LN1@loadtext_c
$LN34@loadtext_c:

; 263  :     }
; 264  : 
; 265  :     for ( recno = 1; rc == 0 || terminate; recno++ )

  00801	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR recno$[rsp], 1
  00809	eb 0a		 jmp	 SHORT $LN7@loadtext_c
$LN5@loadtext_c:
  0080b	8b 44 24 54	 mov	 eax, DWORD PTR recno$[rsp]
  0080f	ff c0		 inc	 eax
  00811	89 44 24 54	 mov	 DWORD PTR recno$[rsp], eax
$LN7@loadtext_c:
  00815	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0081a	74 0e		 je	 SHORT $LN35@loadtext_c
  0081c	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR terminate$[rsp], 0
  00824	0f 84 e7 10 00
	00		 je	 $LN6@loadtext_c
$LN35@loadtext_c:

; 266  :     {
; 267  :         int rlen;                               /* Record Length */
; 268  : 
; 269  :         /* Read 80 bytes into buffer */
; 270  :         rlen = read( fd, buf, sizeof(buf) );

  0082a	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  00830	48 8d 94 24 e0
	01 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00838	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  0083f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00845	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rlen$8[rsp], eax

; 271  : 
; 272  :         /* Handle file read error conditions */
; 273  :         if ( rlen < 0 )

  0084c	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rlen$8[rsp], 0
  00854	0f 8d 88 00 00
	00		 jge	 $LN36@loadtext_c

; 274  :         {
; 275  :             WRMSG(HHC02219,"E", "loadtext read()", strerror(errno));

  0085a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00860	8b 08		 mov	 ecx, DWORD PTR [rax]
  00862	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00868	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv504[rsp], rax
  00870	b9 01 00 00 00	 mov	 ecx, 1
  00875	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0087b	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv504[rsp]
  00883	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00888	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159296
  0088f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00894	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159297
  0089b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159298
  008a7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008b1	41 b9 03 00 00
	00		 mov	 r9d, 3
  008b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159299
  008be	ba 13 01 00 00	 mov	 edx, 275		; 00000113H
  008c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159300
  008ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 276  :             rc = -1;

  008d0	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 277  :             break;

  008d8	e9 34 10 00 00	 jmp	 $LN6@loadtext_c

; 278  :         }

  008dd	e9 ae 00 00 00	 jmp	 $LN37@loadtext_c
$LN36@loadtext_c:

; 279  : 
; 280  :         /* if record length is not 80; leave */
; 281  :         else if ( rlen != sizeof(buf) )

  008e2	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR rlen$8[rsp]
  008ea	48 83 f8 50	 cmp	 rax, 80			; 00000050H
  008ee	0f 84 9c 00 00
	00		 je	 $LN38@loadtext_c

; 282  :         {
; 283  :             if (rlen > 0)

  008f4	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rlen$8[rsp], 0
  008fc	0f 8e 89 00 00
	00		 jle	 $LN39@loadtext_c

; 284  :             {
; 285  :                 WRMSG( HHC02301, "E", argv[0], recno, (int)sizeof(buf) );

  00902	b8 08 00 00 00	 mov	 eax, 8
  00907	48 6b c0 00	 imul	 rax, rax, 0
  0090b	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv523[rsp], rax
  00913	b9 01 00 00 00	 mov	 ecx, 1
  00918	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0091e	c7 44 24 48 50
	00 00 00	 mov	 DWORD PTR [rsp+72], 80	; 00000050H
  00926	8b 4c 24 54	 mov	 ecx, DWORD PTR recno$[rsp]
  0092a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0092e	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00936	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR tv523[rsp]
  0093e	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00942	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00947	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159303
  0094e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00953	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159304
  0095a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0095f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00964	41 b9 03 00 00
	00		 mov	 r9d, 3
  0096a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159305
  00971	ba 1d 01 00 00	 mov	 edx, 285		; 0000011dH
  00976	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159306
  0097d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 286  :                 rc = -1;

  00983	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN39@loadtext_c:

; 287  :             }
; 288  :             break;

  0098b	e9 81 0f 00 00	 jmp	 $LN6@loadtext_c
$LN38@loadtext_c:
$LN37@loadtext_c:

; 289  :         }
; 290  : 
; 291  : 
; 292  :         /*************************************************************/
; 293  :         /*                                                           */
; 294  :         /*      Process valid Object Deck Records by type (0x02,     */
; 295  :         /*      0x03, *, and blank)                                  */
; 296  :         /*                                                           */
; 297  :         /*************************************************************/
; 298  : 
; 299  :         switch (buf[0])

  00990	b8 01 00 00 00	 mov	 eax, 1
  00995	48 6b c0 00	 imul	 rax, rax, 0
  00999	0f b6 84 04 e0
	01 00 00	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  009a1	88 84 24 88 00
	00 00		 mov	 BYTE PTR tv538[rsp], al
  009a8	80 bc 24 88 00
	00 00 02	 cmp	 BYTE PTR tv538[rsp], 2
  009b0	74 2f		 je	 SHORT $LN40@loadtext_c
  009b2	80 bc 24 88 00
	00 00 03	 cmp	 BYTE PTR tv538[rsp], 3
  009ba	0f 84 ba 0d 00
	00		 je	 $LN73@loadtext_c
  009c0	80 bc 24 88 00
	00 00 40	 cmp	 BYTE PTR tv538[rsp], 64	; 00000040H
  009c8	0f 84 37 0e 00
	00		 je	 $LN75@loadtext_c
  009ce	80 bc 24 88 00
	00 00 5c	 cmp	 BYTE PTR tv538[rsp], 92	; 0000005cH
  009d6	0f 84 24 0e 00
	00		 je	 $LN74@loadtext_c
  009dc	e9 aa 0e 00 00	 jmp	 $LN76@loadtext_c
$LN40@loadtext_c:

; 300  :         {
; 301  : 
; 302  :             case TextRecord:
; 303  : 
; 304  :                 /*****************************************************/
; 305  :                 /*                                                   */
; 306  :                 /*   Process valid Object Deck Records by            */
; 307  :                 /*   occurrence priority                             */
; 308  :                 /*                                                   */
; 309  :                 /*   - Columns 73-80 (Deck ID, sequence number,      */
; 310  :                 /*     or both) are ignored for 0x02 compiler        */
; 311  :                 /*     generated records.                            */
; 312  :                 /*                                                   */
; 313  :                 /*****************************************************/
; 314  : 
; 315  :                 /* if record is "TXT" then copy bytes to mainstore */
; 316  :                 if (ObjectTXT)

  009e1	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  009e9	41 b8 04 00 00
	00		 mov	 r8d, 4
  009ef	48 8b d0	 mov	 rdx, rax
  009f2	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR c_ObjectTXT$[rsp]
  009fa	e8 00 00 00 00	 call	 memcmp
  009ff	85 c0		 test	 eax, eax
  00a01	0f 85 2a 02 00
	00		 jne	 $LN41@loadtext_c
  00a07	48 8d 84 24 e8
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+8]
  00a0f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00a15	48 8d 94 24 d8
	01 00 00	 lea	 rdx, QWORD PTR blanks$[rsp]
  00a1d	48 8b c8	 mov	 rcx, rax
  00a20	e8 00 00 00 00	 call	 memcmp
  00a25	85 c0		 test	 eax, eax
  00a27	0f 85 04 02 00
	00		 jne	 $LN41@loadtext_c
  00a2d	48 8d 84 24 ec
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+12]
  00a35	41 b8 02 00 00
	00		 mov	 r8d, 2
  00a3b	48 8d 94 24 d8
	01 00 00	 lea	 rdx, QWORD PTR blanks$[rsp]
  00a43	48 8b c8	 mov	 rcx, rax
  00a46	e8 00 00 00 00	 call	 memcmp
  00a4b	85 c0		 test	 eax, eax
  00a4d	0f 85 de 01 00
	00		 jne	 $LN41@loadtext_c

; 317  :                 {
; 318  :                     u_int n   = ((((buf[5] << 8) | buf[6])<<8) | buf[7]);        // Relative address (positive)

  00a53	b8 01 00 00 00	 mov	 eax, 1
  00a58	48 6b c0 05	 imul	 rax, rax, 5
  00a5c	0f b6 84 04 e0
	01 00 00	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  00a64	c1 e0 08	 shl	 eax, 8
  00a67	b9 01 00 00 00	 mov	 ecx, 1
  00a6c	48 6b c9 06	 imul	 rcx, rcx, 6
  00a70	0f b6 8c 0c e0
	01 00 00	 movzx	 ecx, BYTE PTR buf$[rsp+rcx]
  00a78	0b c1		 or	 eax, ecx
  00a7a	c1 e0 08	 shl	 eax, 8
  00a7d	b9 01 00 00 00	 mov	 ecx, 1
  00a82	48 6b c9 07	 imul	 rcx, rcx, 7
  00a86	0f b6 8c 0c e0
	01 00 00	 movzx	 ecx, BYTE PTR buf$[rsp+rcx]
  00a8e	0b c1		 or	 eax, ecx
  00a90	89 84 24 a8 00
	00 00		 mov	 DWORD PTR n$12[rsp], eax

; 319  :                     u_int len = (buf[10] << 8) | buf[11];                        // Byte count

  00a97	b8 01 00 00 00	 mov	 eax, 1
  00a9c	48 6b c0 0a	 imul	 rax, rax, 10
  00aa0	0f b6 84 04 e0
	01 00 00	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  00aa8	c1 e0 08	 shl	 eax, 8
  00aab	b9 01 00 00 00	 mov	 ecx, 1
  00ab0	48 6b c9 0b	 imul	 rcx, rcx, 11
  00ab4	0f b6 8c 0c e0
	01 00 00	 movzx	 ecx, BYTE PTR buf$[rsp+rcx]
  00abc	0b c1		 or	 eax, ecx
  00abe	89 84 24 90 00
	00 00		 mov	 DWORD PTR len$9[rsp], eax

; 320  :                     if (len <= 56)                                              // Process if useable count

  00ac5	83 bc 24 90 00
	00 00 38	 cmp	 DWORD PTR len$9[rsp], 56 ; 00000038H
  00acd	0f 87 59 01 00
	00		 ja	 $LN43@loadtext_c

; 321  :                     {
; 322  :                        RADR lastbyte = aaddr + n + len - 1;

  00ad3	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR n$12[rsp]
  00ada	48 8b 4c 24 68	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00adf	48 03 c8	 add	 rcx, rax
  00ae2	48 8b c1	 mov	 rax, rcx
  00ae5	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR len$9[rsp]
  00aec	48 8d 44 08 ff	 lea	 rax, QWORD PTR [rax+rcx-1]
  00af1	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR lastbyte$13[rsp], rax

; 323  :                        if (lastbyte >= sysblk.mainsize)                         // Bytes must fit into storage

  00af9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b00	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00b07	48 39 84 24 e8
	00 00 00	 cmp	 QWORD PTR lastbyte$13[rsp], rax
  00b0f	0f 82 93 00 00
	00		 jb	 $LN44@loadtext_c

; 324  :                        {
; 325  :                           WRMSG(HHC02307,"E", argv[0], recno, (U64)lastbyte);

  00b15	b8 08 00 00 00	 mov	 eax, 8
  00b1a	48 6b c0 00	 imul	 rax, rax, 0
  00b1e	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv594[rsp], rax
  00b26	b9 01 00 00 00	 mov	 ecx, 1
  00b2b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b31	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR lastbyte$13[rsp]
  00b39	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b3e	8b 4c 24 54	 mov	 ecx, DWORD PTR recno$[rsp]
  00b42	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b46	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00b4e	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR tv594[rsp]
  00b56	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00b5a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b5f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159312
  00b66	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b6b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159313
  00b72	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b77	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b7c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b82	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159314
  00b89	ba 45 01 00 00	 mov	 edx, 325		; 00000145H
  00b8e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159315
  00b95	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 326  :                           rc = -1;

  00b9b	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 327  :                           break;

  00ba3	e9 64 0d 00 00	 jmp	 $LN8@loadtext_c
$LN44@loadtext_c:

; 328  :                        }
; 329  :                        ahighaddr = MAX(ahighaddr, lastbyte);                    // Keep track of highsest byte used

  00ba8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR lastbyte$13[rsp]
  00bb0	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR ahighaddr$[rsp], rax
  00bb8	76 12		 jbe	 SHORT $LN80@loadtext_c
  00bba	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR ahighaddr$[rsp]
  00bc2	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv607[rsp], rax
  00bca	eb 10		 jmp	 SHORT $LN81@loadtext_c
$LN80@loadtext_c:
  00bcc	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR lastbyte$13[rsp]
  00bd4	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv607[rsp], rax
$LN81@loadtext_c:
  00bdc	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR tv607[rsp]
  00be4	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR ahighaddr$[rsp], rax

; 330  :                        memcpy(regs->mainstor + aaddr + n, &buf[16], len);

  00bec	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR len$9[rsp]
  00bf3	b9 01 00 00 00	 mov	 ecx, 1
  00bf8	48 6b c9 10	 imul	 rcx, rcx, 16
  00bfc	48 8d 8c 0c e0
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rcx]
  00c04	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c0c	48 8b 92 48 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2120]
  00c13	48 03 54 24 68	 add	 rdx, QWORD PTR aaddr$[rsp]
  00c18	8b bc 24 a8 00
	00 00		 mov	 edi, DWORD PTR n$12[rsp]
  00c1f	48 03 d7	 add	 rdx, rdi
  00c22	48 8b fa	 mov	 rdi, rdx
  00c25	48 8b f1	 mov	 rsi, rcx
  00c28	8b c8		 mov	 ecx, eax
  00c2a	f3 a4		 rep movsb
$LN43@loadtext_c:

; 331  :                     }
; 332  :                 }

  00c2c	e9 44 0b 00 00	 jmp	 $LN42@loadtext_c
$LN41@loadtext_c:

; 333  : 
; 334  :                 /* if record is "RLD" then process */
; 335  :                 else if (ObjectRLD)

  00c31	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  00c39	41 b8 09 00 00
	00		 mov	 r8d, 9
  00c3f	48 8b d0	 mov	 rdx, rax
  00c42	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR c_ObjectRLD$[rsp]
  00c4a	e8 00 00 00 00	 call	 memcmp
  00c4f	85 c0		 test	 eax, eax
  00c51	0f 85 a5 04 00
	00		 jne	 $LN45@loadtext_c
  00c57	48 8d 84 24 ec
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+12]
  00c5f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00c65	48 8d 94 24 d8
	01 00 00	 lea	 rdx, QWORD PTR blanks$[rsp]
  00c6d	48 8b c8	 mov	 rcx, rax
  00c70	e8 00 00 00 00	 call	 memcmp
  00c75	85 c0		 test	 eax, eax
  00c77	0f 85 7f 04 00
	00		 jne	 $LN45@loadtext_c

; 336  :                 {
; 337  : 
; 338  :                     /* Define local macros for relocation tests              */
; 339  : 
; 340  : #define RLD_RELOC_A     ((reloc[4] & 0x30) == 0x00)             // A-constant
; 341  : #define RLD_RELOC_V     ((reloc[4] & 0x30) == 0x10)             // V-constant
; 342  : #define RLD_RELOC_Q     ((reloc[4] & 0x30) == 0x20)             // Q-constant
; 343  : #define RLD_RELOC_CXD   ((reloc[4] & 0x30) == 0x30)             // CXD-constant
; 344  : #define RLD_RELOC_RI2   ((reloc[4] & 0x7C) == 0x70)             // 2-byte Relative-Immediate reference
; 345  : #define RLD_RELOC_RI4   ((reloc[4] & 0x7C) == 0x78)             // 4-byte Relative-Immediate reference
; 346  : #define RLD_RELOC_RI    (RLD_RELOC_RI2 || RLD_RELOC_RI4)        // Relative-Immediate reference
; 347  : #define RLD_RELOC_NEG   ((reloc[4] & 0x02) == 0x02)             // Negative relocation
; 348  : #define RLD_RELOC_POS   ((reloc[4] & 0x02) == 0x00)             // Positive relocation
; 349  : 
; 350  : 
; 351  :                     U16  count = (buf[10] << 8) | buf[11];

  00c7d	b8 01 00 00 00	 mov	 eax, 1
  00c82	48 6b c0 0a	 imul	 rax, rax, 10
  00c86	0f b6 84 04 e0
	01 00 00	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  00c8e	c1 e0 08	 shl	 eax, 8
  00c91	b9 01 00 00 00	 mov	 ecx, 1
  00c96	48 6b c9 0b	 imul	 rcx, rcx, 11
  00c9a	0f b6 8c 0c e0
	01 00 00	 movzx	 ecx, BYTE PTR buf$[rsp+rcx]
  00ca2	0b c1		 or	 eax, ecx
  00ca4	66 89 44 24 78	 mov	 WORD PTR count$4[rsp], ax

; 352  :                     BYTE *rstart = buf + 16;            // Start of relocation entries

  00ca9	48 8d 84 24 f0
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+16]
  00cb1	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR rstart$16[rsp], rax

; 353  :                     BYTE *rend;                         // End of relocation entries
; 354  :                     BYTE *reloc;                        // Current relocation entry
; 355  :                     u_int seglength = 8;                // Set initial segment length

  00cb9	c7 84 24 98 00
	00 00 08 00 00
	00		 mov	 DWORD PTR seglength$11[rsp], 8

; 356  :                     U16  resdid;                        // Relocation ESDID
; 357  :                     U16  pesdid;                        // Position ESDID
; 358  : 
; 359  :                     if (count > 56)

  00cc4	0f b7 44 24 78	 movzx	 eax, WORD PTR count$4[rsp]
  00cc9	83 f8 38	 cmp	 eax, 56			; 00000038H
  00ccc	7e 05		 jle	 SHORT $LN47@loadtext_c

; 360  :                        continue;                        // Skip if bad count

  00cce	e9 38 fb ff ff	 jmp	 $LN5@loadtext_c
$LN47@loadtext_c:

; 361  : 
; 362  :                     rend = rstart + count;              // End of relocation

  00cd3	0f b7 44 24 78	 movzx	 eax, WORD PTR count$4[rsp]
  00cd8	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR rstart$16[rsp]
  00ce0	48 03 c8	 add	 rcx, rax
  00ce3	48 8b c1	 mov	 rax, rcx
  00ce6	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR rend$18[rsp], rax

; 363  : 
; 364  :                     /* Process Relocation Dictionary Entries                          */
; 365  : 
; 366  :                     /* Note: All relocations are presently considered to only have    */
; 367  :                     /*       relocation within a single object deck (ESDIDs ignored). */
; 368  : 
; 369  :                     for (reloc = rstart; reloc < rend;)

  00cee	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR rstart$16[rsp]
  00cf6	48 89 44 24 60	 mov	 QWORD PTR reloc$2[rsp], rax
$LN10@loadtext_c:
  00cfb	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR rend$18[rsp]
  00d03	48 39 44 24 60	 cmp	 QWORD PTR reloc$2[rsp], rax
  00d08	0f 83 e9 03 00
	00		 jae	 $LN11@loadtext_c

; 370  :                     {
; 371  :                        u_int acl;                       // Address constant length
; 372  :                        u_int aarel;                     // Load relocation address
; 373  :                        u_int n;                         // Working length
; 374  :                        BYTE *vc;                        // Pointer to relocation constant
; 375  :                        U64 v = 0;                       // Variable contents for relocation

  00d0e	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR v$3[rsp], 0

; 376  : 
; 377  : 
; 378  :                        /* Load new Relocation ESDID and Position ESDID                      */
; 379  :                        /* (the first entry on record always contains a R-ESDID and P-ESDID) */
; 380  : 
; 381  :                        if (seglength > 4)

  00d17	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR seglength$11[rsp], 4
  00d1f	76 62		 jbe	 SHORT $LN48@loadtext_c

; 382  :                        {
; 383  :                           resdid = (reloc[0] << 8) | reloc[1];

  00d21	b8 01 00 00 00	 mov	 eax, 1
  00d26	48 6b c0 00	 imul	 rax, rax, 0
  00d2a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reloc$2[rsp]
  00d2f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d33	c1 e0 08	 shl	 eax, 8
  00d36	b9 01 00 00 00	 mov	 ecx, 1
  00d3b	48 6b c9 01	 imul	 rcx, rcx, 1
  00d3f	48 8b 54 24 60	 mov	 rdx, QWORD PTR reloc$2[rsp]
  00d44	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00d48	0b c1		 or	 eax, ecx
  00d4a	66 89 84 24 fc
	00 00 00	 mov	 WORD PTR resdid$15[rsp], ax

; 384  :                           pesdid = (reloc[2] << 8) | reloc[3];

  00d52	b8 01 00 00 00	 mov	 eax, 1
  00d57	48 6b c0 02	 imul	 rax, rax, 2
  00d5b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reloc$2[rsp]
  00d60	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d64	c1 e0 08	 shl	 eax, 8
  00d67	b9 01 00 00 00	 mov	 ecx, 1
  00d6c	48 6b c9 03	 imul	 rcx, rcx, 3
  00d70	48 8b 54 24 60	 mov	 rdx, QWORD PTR reloc$2[rsp]
  00d75	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00d79	0b c1		 or	 eax, ecx
  00d7b	66 89 84 24 f8
	00 00 00	 mov	 WORD PTR pesdid$14[rsp], ax
$LN48@loadtext_c:
$LN15@loadtext_c:

; 385  :                        }
; 386  : 
; 387  :                        UNREFERENCED(resdid);  // relocation will be added later

  00d83	33 c0		 xor	 eax, eax
  00d85	85 c0		 test	 eax, eax
  00d87	75 fa		 jne	 SHORT $LN15@loadtext_c
$LN18@loadtext_c:

; 388  :                        UNREFERENCED(pesdid);  // relocation will be added later

  00d89	33 c0		 xor	 eax, eax
  00d8b	85 c0		 test	 eax, eax
  00d8d	75 fa		 jne	 SHORT $LN18@loadtext_c

; 389  : 
; 390  :                        if (!(RLD_RELOC_Q || RLD_RELOC_CXD))     // Relocate all except Q/CXD-constants

  00d8f	b8 01 00 00 00	 mov	 eax, 1
  00d94	48 6b c0 04	 imul	 rax, rax, 4
  00d98	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reloc$2[rsp]
  00d9d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00da1	83 e0 30	 and	 eax, 48			; 00000030H
  00da4	83 f8 20	 cmp	 eax, 32			; 00000020H
  00da7	0f 84 ef 02 00
	00		 je	 $LN49@loadtext_c
  00dad	b8 01 00 00 00	 mov	 eax, 1
  00db2	48 6b c0 04	 imul	 rax, rax, 4
  00db6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reloc$2[rsp]
  00dbb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00dbf	83 e0 30	 and	 eax, 48			; 00000030H
  00dc2	83 f8 30	 cmp	 eax, 48			; 00000030H
  00dc5	0f 84 d1 02 00
	00		 je	 $LN49@loadtext_c

; 391  :                        {
; 392  : 
; 393  :                           /* Determine address constant length - 1 */
; 394  : 
; 395  :                           if (RLD_RELOC_RI)                        // Relative-Immediate?

  00dcb	b8 01 00 00 00	 mov	 eax, 1
  00dd0	48 6b c0 04	 imul	 rax, rax, 4
  00dd4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reloc$2[rsp]
  00dd9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ddd	83 e0 7c	 and	 eax, 124		; 0000007cH
  00de0	83 f8 70	 cmp	 eax, 112		; 00000070H
  00de3	74 1a		 je	 SHORT $LN52@loadtext_c
  00de5	b8 01 00 00 00	 mov	 eax, 1
  00dea	48 6b c0 04	 imul	 rax, rax, 4
  00dee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reloc$2[rsp]
  00df3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00df7	83 e0 7c	 and	 eax, 124		; 0000007cH
  00dfa	83 f8 78	 cmp	 eax, 120		; 00000078H
  00dfd	75 20		 jne	 SHORT $LN50@loadtext_c
$LN52@loadtext_c:

; 396  :                              acl = ((reloc[4] & 0x08) >> 2) + 1;   // Set 2/4-byte Relative-Immediate length

  00dff	b8 01 00 00 00	 mov	 eax, 1
  00e04	48 6b c0 04	 imul	 rax, rax, 4
  00e08	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reloc$2[rsp]
  00e0d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e11	83 e0 08	 and	 eax, 8
  00e14	c1 f8 02	 sar	 eax, 2
  00e17	ff c0		 inc	 eax
  00e19	89 44 24 7c	 mov	 DWORD PTR acl$5[rsp], eax
  00e1d	eb 36		 jmp	 SHORT $LN51@loadtext_c
$LN50@loadtext_c:

; 397  :                           else                                     // Else set address constant length
; 398  :                              acl = ((reloc[4] & 0x40) >> 4) + ((reloc[4] & 0x0C) >> 2);

  00e1f	b8 01 00 00 00	 mov	 eax, 1
  00e24	48 6b c0 04	 imul	 rax, rax, 4
  00e28	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reloc$2[rsp]
  00e2d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e31	83 e0 40	 and	 eax, 64			; 00000040H
  00e34	c1 f8 04	 sar	 eax, 4
  00e37	b9 01 00 00 00	 mov	 ecx, 1
  00e3c	48 6b c9 04	 imul	 rcx, rcx, 4
  00e40	48 8b 54 24 60	 mov	 rdx, QWORD PTR reloc$2[rsp]
  00e45	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00e49	83 e1 0c	 and	 ecx, 12
  00e4c	c1 f9 02	 sar	 ecx, 2
  00e4f	03 c1		 add	 eax, ecx
  00e51	89 44 24 7c	 mov	 DWORD PTR acl$5[rsp], eax
$LN51@loadtext_c:

; 399  : 
; 400  : 
; 401  :                           /* Load relocation address */
; 402  : 
; 403  :                           aarel = (((reloc[5] << 8) | reloc[6]) << 8) | reloc[7];

  00e55	b8 01 00 00 00	 mov	 eax, 1
  00e5a	48 6b c0 05	 imul	 rax, rax, 5
  00e5e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reloc$2[rsp]
  00e63	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e67	c1 e0 08	 shl	 eax, 8
  00e6a	b9 01 00 00 00	 mov	 ecx, 1
  00e6f	48 6b c9 06	 imul	 rcx, rcx, 6
  00e73	48 8b 54 24 60	 mov	 rdx, QWORD PTR reloc$2[rsp]
  00e78	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00e7c	0b c1		 or	 eax, ecx
  00e7e	c1 e0 08	 shl	 eax, 8
  00e81	b9 01 00 00 00	 mov	 ecx, 1
  00e86	48 6b c9 07	 imul	 rcx, rcx, 7
  00e8a	48 8b 54 24 60	 mov	 rdx, QWORD PTR reloc$2[rsp]
  00e8f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00e93	0b c1		 or	 eax, ecx
  00e95	89 84 24 94 00
	00 00		 mov	 DWORD PTR aarel$10[rsp], eax

; 404  : 
; 405  : 
; 406  :                           /* Relocate address */
; 407  : 
; 408  :                           if ((aaddr + aarel + acl) < sysblk.mainsize)

  00e9c	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR aarel$10[rsp]
  00ea3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00ea8	48 03 c8	 add	 rcx, rax
  00eab	48 8b c1	 mov	 rax, rcx
  00eae	8b 4c 24 7c	 mov	 ecx, DWORD PTR acl$5[rsp]
  00eb2	48 03 c1	 add	 rax, rcx
  00eb5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00ebc	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  00ec3	0f 83 36 01 00
	00		 jae	 $LN53@loadtext_c

; 409  :                           {
; 410  : 
; 411  :                              /* Fetch variable length constant */
; 412  : 
; 413  :                              vc = (BYTE *)regs->mainstor + aaddr + aarel;

  00ec9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ed1	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00ed8	48 03 44 24 68	 add	 rax, QWORD PTR aaddr$[rsp]
  00edd	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR aarel$10[rsp]
  00ee4	48 03 c1	 add	 rax, rcx
  00ee7	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR vc$17[rsp], rax

; 414  :                              v = 0;

  00eef	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR v$3[rsp], 0

; 415  :                              for (n = 0;;)

  00ef8	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
$LN19@loadtext_c:

; 416  :                              {
; 417  :                                 v |=  vc[n];

  00f00	8b 44 24 58	 mov	 eax, DWORD PTR n$1[rsp]
  00f04	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR vc$17[rsp]
  00f0c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f10	48 8b 4c 24 70	 mov	 rcx, QWORD PTR v$3[rsp]
  00f15	48 0b c8	 or	 rcx, rax
  00f18	48 8b c1	 mov	 rax, rcx
  00f1b	48 89 44 24 70	 mov	 QWORD PTR v$3[rsp], rax

; 418  :                                 if (n++ >= acl)

  00f20	8b 44 24 58	 mov	 eax, DWORD PTR n$1[rsp]
  00f24	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv739[rsp], eax
  00f2b	8b 44 24 7c	 mov	 eax, DWORD PTR acl$5[rsp]
  00f2f	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv740[rsp], eax
  00f36	8b 44 24 58	 mov	 eax, DWORD PTR n$1[rsp]
  00f3a	ff c0		 inc	 eax
  00f3c	89 44 24 58	 mov	 DWORD PTR n$1[rsp], eax
  00f40	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR tv740[rsp]
  00f47	39 84 24 08 01
	00 00		 cmp	 DWORD PTR tv739[rsp], eax
  00f4e	72 02		 jb	 SHORT $LN55@loadtext_c

; 419  :                                    break;

  00f50	eb 10		 jmp	 SHORT $LN20@loadtext_c
$LN55@loadtext_c:

; 420  :                                 v <<= 8;

  00f52	48 8b 44 24 70	 mov	 rax, QWORD PTR v$3[rsp]
  00f57	48 c1 e0 08	 shl	 rax, 8
  00f5b	48 89 44 24 70	 mov	 QWORD PTR v$3[rsp], rax

; 421  :                              }

  00f60	eb 9e		 jmp	 SHORT $LN19@loadtext_c
$LN20@loadtext_c:

; 422  : 
; 423  :                              /* Relocate value */
; 424  : 
; 425  :                              if (RLD_RELOC_POS)         /* Positive relocation */

  00f62	b8 01 00 00 00	 mov	 eax, 1
  00f67	48 6b c0 04	 imul	 rax, rax, 4
  00f6b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reloc$2[rsp]
  00f70	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f74	83 e0 02	 and	 eax, 2
  00f77	85 c0		 test	 eax, eax
  00f79	75 17		 jne	 SHORT $LN56@loadtext_c

; 426  :                                 v += aaddr;

  00f7b	48 8b 44 24 68	 mov	 rax, QWORD PTR aaddr$[rsp]
  00f80	48 8b 4c 24 70	 mov	 rcx, QWORD PTR v$3[rsp]
  00f85	48 03 c8	 add	 rcx, rax
  00f88	48 8b c1	 mov	 rax, rcx
  00f8b	48 89 44 24 70	 mov	 QWORD PTR v$3[rsp], rax
  00f90	eb 15		 jmp	 SHORT $LN57@loadtext_c
$LN56@loadtext_c:

; 427  :                              else                       /* Negative relocation */
; 428  :                                 v = aaddr - v;

  00f92	48 8b 44 24 70	 mov	 rax, QWORD PTR v$3[rsp]
  00f97	48 8b 4c 24 68	 mov	 rcx, QWORD PTR aaddr$[rsp]
  00f9c	48 2b c8	 sub	 rcx, rax
  00f9f	48 8b c1	 mov	 rax, rcx
  00fa2	48 89 44 24 70	 mov	 QWORD PTR v$3[rsp], rax
$LN57@loadtext_c:

; 429  : 
; 430  : 
; 431  :                              /* Store variable length constant */
; 432  : 
; 433  :                              for (n = acl;;)

  00fa7	8b 44 24 7c	 mov	 eax, DWORD PTR acl$5[rsp]
  00fab	89 44 24 58	 mov	 DWORD PTR n$1[rsp], eax
$LN22@loadtext_c:

; 434  :                              {
; 435  :                                 vc[n] = v & 0xFF;

  00faf	48 8b 44 24 70	 mov	 rax, QWORD PTR v$3[rsp]
  00fb4	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  00fba	8b 4c 24 58	 mov	 ecx, DWORD PTR n$1[rsp]
  00fbe	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR vc$17[rsp]
  00fc6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 436  :                                 if (n-- <= 0)

  00fc9	8b 44 24 58	 mov	 eax, DWORD PTR n$1[rsp]
  00fcd	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv756[rsp], eax
  00fd4	8b 44 24 58	 mov	 eax, DWORD PTR n$1[rsp]
  00fd8	ff c8		 dec	 eax
  00fda	89 44 24 58	 mov	 DWORD PTR n$1[rsp], eax
  00fde	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR tv756[rsp], 0
  00fe6	77 02		 ja	 SHORT $LN58@loadtext_c

; 437  :                                    break;

  00fe8	eb 10		 jmp	 SHORT $LN23@loadtext_c
$LN58@loadtext_c:

; 438  :                                 v >>= 8;

  00fea	48 8b 44 24 70	 mov	 rax, QWORD PTR v$3[rsp]
  00fef	48 c1 e8 08	 shr	 rax, 8
  00ff3	48 89 44 24 70	 mov	 QWORD PTR v$3[rsp], rax

; 439  :                              }

  00ff8	eb b5		 jmp	 SHORT $LN22@loadtext_c
$LN23@loadtext_c:

; 440  :                           }

  00ffa	e9 9d 00 00 00	 jmp	 $LN54@loadtext_c
$LN53@loadtext_c:

; 441  :                           else
; 442  :                           {
; 443  :                              WRMSG(HHC02307,"W", argv[0], recno, (RADR)aarel);

  00fff	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR aarel$10[rsp]
  01006	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv758[rsp], rax
  0100e	b9 08 00 00 00	 mov	 ecx, 8
  01013	48 6b c9 00	 imul	 rcx, rcx, 0
  01017	48 89 8c 24 98
	01 00 00	 mov	 QWORD PTR tv761[rsp], rcx
  0101f	b9 01 00 00 00	 mov	 ecx, 1
  01024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0102a	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR tv758[rsp]
  01032	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01037	8b 4c 24 54	 mov	 ecx, DWORD PTR recno$[rsp]
  0103b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0103f	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  01047	48 8b 94 24 98
	01 00 00	 mov	 rdx, QWORD PTR tv761[rsp]
  0104f	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  01053	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159330
  0105f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159331
  0106b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01070	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01075	41 b9 03 00 00
	00		 mov	 r9d, 3
  0107b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159332
  01082	ba bb 01 00 00	 mov	 edx, 443		; 000001bbH
  01087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159333
  0108e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 444  :                              rc = 4;

  01094	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR rc$[rsp], 4
$LN54@loadtext_c:
$LN49@loadtext_c:

; 445  :                           }
; 446  :                        }
; 447  : 
; 448  : 
; 449  :                        /* Set length based on using last ESDID entries */
; 450  : 
; 451  :                        reloc += seglength = (reloc[4] & 0x01) ? 4 : 8;

  0109c	b8 01 00 00 00	 mov	 eax, 1
  010a1	48 6b c0 04	 imul	 rax, rax, 4
  010a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reloc$2[rsp]
  010aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  010ae	83 e0 01	 and	 eax, 1
  010b1	85 c0		 test	 eax, eax
  010b3	74 0d		 je	 SHORT $LN82@loadtext_c
  010b5	c7 84 24 ac 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv778[rsp], 4
  010c0	eb 0b		 jmp	 SHORT $LN83@loadtext_c
$LN82@loadtext_c:
  010c2	c7 84 24 ac 00
	00 00 08 00 00
	00		 mov	 DWORD PTR tv778[rsp], 8
$LN83@loadtext_c:
  010cd	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv778[rsp]
  010d4	89 84 24 98 00
	00 00		 mov	 DWORD PTR seglength$11[rsp], eax
  010db	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR seglength$11[rsp]
  010e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR reloc$2[rsp]
  010e7	48 03 c8	 add	 rcx, rax
  010ea	48 8b c1	 mov	 rax, rcx
  010ed	48 89 44 24 60	 mov	 QWORD PTR reloc$2[rsp], rax

; 452  :                     }

  010f2	e9 04 fc ff ff	 jmp	 $LN10@loadtext_c
$LN11@loadtext_c:

; 453  : 
; 454  :                     /* Undefine local macros for relocation tests            */
; 455  : 
; 456  : #undef RLD_RELOC_A      // A-constant
; 457  : #undef RLD_RELOC_V      // V-constant
; 458  : #undef RLD_RELOC_Q      // Q-constant
; 459  : #undef RLD_RELOC_CXD    // CXD-constant
; 460  : #undef RLD_RELOC_RI2    // 2-byte Relative-Immediate reference
; 461  : #undef RLD_RELOC_RI4    // 4-byte Relative-Immediate reference
; 462  : #undef RLD_RELOC_RI     // Relative-Immediate reference
; 463  : #undef RLD_RELOC_NEG    // Negative relocation
; 464  : #undef RLD_RELOC_POS    // Positive relocation
; 465  : 
; 466  :                 }

  010f7	e9 79 06 00 00	 jmp	 $LN46@loadtext_c
$LN45@loadtext_c:

; 467  : 
; 468  :                 /* if record is "ESD" then process */
; 469  :                 else if (ObjectESD)

  010fc	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  01104	41 b8 09 00 00
	00		 mov	 r8d, 9
  0110a	48 8b d0	 mov	 rdx, rax
  0110d	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR c_ObjectESD$[rsp]
  01115	e8 00 00 00 00	 call	 memcmp
  0111a	85 c0		 test	 eax, eax
  0111c	75 4e		 jne	 SHORT $LN59@loadtext_c
  0111e	48 8d 84 24 ec
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+12]
  01126	41 b8 02 00 00
	00		 mov	 r8d, 2
  0112c	48 8d 94 24 d8
	01 00 00	 lea	 rdx, QWORD PTR blanks$[rsp]
  01134	48 8b c8	 mov	 rcx, rax
  01137	e8 00 00 00 00	 call	 memcmp
  0113c	85 c0		 test	 eax, eax
  0113e	75 2c		 jne	 SHORT $LN59@loadtext_c
  01140	48 8d 84 24 20
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp+64]
  01148	41 b8 08 00 00
	00		 mov	 r8d, 8
  0114e	48 8d 94 24 d8
	01 00 00	 lea	 rdx, QWORD PTR blanks$[rsp]
  01156	48 8b c8	 mov	 rcx, rax
  01159	e8 00 00 00 00	 call	 memcmp
  0115e	85 c0		 test	 eax, eax
  01160	75 0a		 jne	 SHORT $LN59@loadtext_c

; 470  :                     continue;    // For now, fill in later

  01162	e9 a4 f6 ff ff	 jmp	 $LN5@loadtext_c
  01167	e9 09 06 00 00	 jmp	 $LN60@loadtext_c
$LN59@loadtext_c:

; 471  : 
; 472  :                 /* if record is "END" then process */
; 473  :                 else if (ObjectEND)

  0116c	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  01174	41 b8 04 00 00
	00		 mov	 r8d, 4
  0117a	48 8b d0	 mov	 rdx, rax
  0117d	48 8d 8c 24 0c
	01 00 00	 lea	 rcx, QWORD PTR c_ObjectEND$[rsp]
  01185	e8 00 00 00 00	 call	 memcmp
  0118a	85 c0		 test	 eax, eax
  0118c	0f 85 82 00 00
	00		 jne	 $LN61@loadtext_c
  01192	48 8d 84 24 e8
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+8]
  0119a	41 b8 06 00 00
	00		 mov	 r8d, 6
  011a0	48 8d 94 24 d8
	01 00 00	 lea	 rdx, QWORD PTR blanks$[rsp]
  011a8	48 8b c8	 mov	 rcx, rax
  011ab	e8 00 00 00 00	 call	 memcmp
  011b0	85 c0		 test	 eax, eax
  011b2	75 60		 jne	 SHORT $LN61@loadtext_c
  011b4	48 8d 84 24 f8
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+24]
  011bc	41 b8 04 00 00
	00		 mov	 r8d, 4
  011c2	48 8d 94 24 d8
	01 00 00	 lea	 rdx, QWORD PTR blanks$[rsp]
  011ca	48 8b c8	 mov	 rcx, rax
  011cd	e8 00 00 00 00	 call	 memcmp
  011d2	85 c0		 test	 eax, eax
  011d4	75 3e		 jne	 SHORT $LN61@loadtext_c
  011d6	48 8d 84 24 27
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp+71]
  011de	41 b8 01 00 00
	00		 mov	 r8d, 1
  011e4	48 8d 94 24 d8
	01 00 00	 lea	 rdx, QWORD PTR blanks$[rsp]
  011ec	48 8b c8	 mov	 rcx, rax
  011ef	e8 00 00 00 00	 call	 memcmp
  011f4	85 c0		 test	 eax, eax
  011f6	75 1c		 jne	 SHORT $LN61@loadtext_c

; 474  :                 {
; 475  :                     /* Bump to next quadword boundary */
; 476  :                     aaddr = (ahighaddr + 15) & 0xFFFFF0;

  011f8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR ahighaddr$[rsp]
  01200	48 83 c0 0f	 add	 rax, 15
  01204	48 25 f0 ff ff
	00		 and	 rax, 16777200		; 00fffff0H
  0120a	48 89 44 24 68	 mov	 QWORD PTR aaddr$[rsp], rax

; 477  : 
; 478  :                     // Future processing may be to take start address
; 479  :                     // from END card and place in PSW
; 480  : 
; 481  :                 }

  0120f	e9 61 05 00 00	 jmp	 $LN62@loadtext_c
$LN61@loadtext_c:

; 482  : 
; 483  :                 /* if record is "SYM" then process */
; 484  :                 else if (ObjectSYM)

  01214	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  0121c	41 b8 09 00 00
	00		 mov	 r8d, 9
  01222	48 8b d0	 mov	 rdx, rax
  01225	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR c_ObjectSYM$[rsp]
  0122d	e8 00 00 00 00	 call	 memcmp
  01232	85 c0		 test	 eax, eax
  01234	75 2c		 jne	 SHORT $LN63@loadtext_c
  01236	48 8d 84 24 ec
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+12]
  0123e	41 b8 04 00 00
	00		 mov	 r8d, 4
  01244	48 8d 94 24 d8
	01 00 00	 lea	 rdx, QWORD PTR blanks$[rsp]
  0124c	48 8b c8	 mov	 rcx, rax
  0124f	e8 00 00 00 00	 call	 memcmp
  01254	85 c0		 test	 eax, eax
  01256	75 0a		 jne	 SHORT $LN63@loadtext_c

; 485  :                     continue;    // For now, fill in later

  01258	e9 ae f5 ff ff	 jmp	 $LN5@loadtext_c
  0125d	e9 13 05 00 00	 jmp	 $LN64@loadtext_c
$LN63@loadtext_c:

; 486  : 
; 487  : 
; 488  :                 /*****************************************************/
; 489  :                 /*                                                   */
; 490  :                 /*      Process VM loader directives                 */
; 491  :                 /*                                                   */
; 492  :                 /*****************************************************/
; 493  : 
; 494  :                 /* if record is "SPB" then process */
; 495  :                 else if (ObjectSPB)

  01262	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  0126a	41 b8 03 00 00
	00		 mov	 r8d, 3
  01270	48 8b d0	 mov	 rdx, rax
  01273	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR c_ObjectSPB$[rsp]
  0127b	e8 00 00 00 00	 call	 memcmp
  01280	85 c0		 test	 eax, eax
  01282	0f 85 f2 00 00
	00		 jne	 $LN65@loadtext_c

; 496  :                 {
; 497  :                     aaddr = (MAX(aaddr, ahighaddr) + 4093) & 0xFFFFF000;

  01288	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR ahighaddr$[rsp]
  01290	48 39 44 24 68	 cmp	 QWORD PTR aaddr$[rsp], rax
  01295	76 0f		 jbe	 SHORT $LN84@loadtext_c
  01297	48 8b 44 24 68	 mov	 rax, QWORD PTR aaddr$[rsp]
  0129c	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv896[rsp], rax
  012a4	eb 10		 jmp	 SHORT $LN85@loadtext_c
$LN84@loadtext_c:
  012a6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR ahighaddr$[rsp]
  012ae	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv896[rsp], rax
$LN85@loadtext_c:
  012b6	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR tv896[rsp]
  012be	48 05 fd 0f 00
	00		 add	 rax, 4093		; 00000ffdH
  012c4	b9 00 f0 ff ff	 mov	 ecx, -4096		; fffff000H
  012c9	48 23 c1	 and	 rax, rcx
  012cc	48 89 44 24 68	 mov	 QWORD PTR aaddr$[rsp], rax

; 498  : 
; 499  :                     /* Warn if further action may exceed storage */
; 500  : 
; 501  :                     if (aaddr >= sysblk.mainsize)

  012d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012d8	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  012df	48 39 44 24 68	 cmp	 QWORD PTR aaddr$[rsp], rax
  012e4	0f 82 8b 00 00
	00		 jb	 $LN67@loadtext_c

; 502  :                     {
; 503  :                         WRMSG(HHC02307,"W", argv[0], recno, aaddr);

  012ea	b8 08 00 00 00	 mov	 eax, 8
  012ef	48 6b c0 00	 imul	 rax, rax, 0
  012f3	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv903[rsp], rax
  012fb	b9 01 00 00 00	 mov	 ecx, 1
  01300	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01306	48 8b 4c 24 68	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0130b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01310	8b 4c 24 54	 mov	 ecx, DWORD PTR recno$[rsp]
  01314	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01318	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  01320	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR tv903[rsp]
  01328	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0132c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01331	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159343
  01338	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0133d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159344
  01344	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01349	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0134e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01354	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159345
  0135b	ba f7 01 00 00	 mov	 edx, 503		; 000001f7H
  01360	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159346
  01367	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 504  :                         rc = 4;

  0136d	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR rc$[rsp], 4
$LN67@loadtext_c:

; 505  :                     }
; 506  :                 }

  01375	e9 fb 03 00 00	 jmp	 $LN66@loadtext_c
$LN65@loadtext_c:

; 507  : 
; 508  :                 /* if record is "LDT" then process and break out of loop */
; 509  :                 else if (ObjectLDT)

  0137a	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  01382	41 b8 03 00 00
	00		 mov	 r8d, 3
  01388	48 8b d0	 mov	 rdx, rax
  0138b	48 8d 8c 24 bc
	00 00 00	 lea	 rcx, QWORD PTR c_ObjectLDT$[rsp]
  01393	e8 00 00 00 00	 call	 memcmp
  01398	85 c0		 test	 eax, eax
  0139a	75 10		 jne	 SHORT $LN68@loadtext_c

; 510  :                 {
; 511  :                     terminate = 1;      // Terminate process, leave RC alone

  0139c	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR terminate$[rsp], 1

; 512  :                 }

  013a7	e9 c9 03 00 00	 jmp	 $LN69@loadtext_c
$LN68@loadtext_c:

; 513  : 
; 514  :                 /* If unsupported VM record, just warn */
; 515  :                 else if (ObjectCPB ||
; 516  :                          ObjectDEL ||
; 517  :                          ObjectICS ||
; 518  :                          ObjectPAD ||
; 519  :                          ObjectPRT ||
; 520  :                          ObjectPRM ||
; 521  :                          ObjectREP ||
; 522  :                          ObjectSLC ||
; 523  :                          ObjectSYS ||
; 524  :                          ObjectUPB ||

  013ac	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  013b4	41 b8 03 00 00
	00		 mov	 r8d, 3
  013ba	48 8b d0	 mov	 rdx, rax
  013bd	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR c_ObjectCPB$[rsp]
  013c5	e8 00 00 00 00	 call	 memcmp
  013ca	85 c0		 test	 eax, eax
  013cc	0f 84 70 01 00
	00		 je	 $LN72@loadtext_c
  013d2	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  013da	41 b8 03 00 00
	00		 mov	 r8d, 3
  013e0	48 8b d0	 mov	 rdx, rax
  013e3	48 8d 8c 24 c4
	00 00 00	 lea	 rcx, QWORD PTR c_ObjectDEL$[rsp]
  013eb	e8 00 00 00 00	 call	 memcmp
  013f0	85 c0		 test	 eax, eax
  013f2	0f 84 4a 01 00
	00		 je	 $LN72@loadtext_c
  013f8	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  01400	41 b8 03 00 00
	00		 mov	 r8d, 3
  01406	48 8b d0	 mov	 rdx, rax
  01409	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR c_ObjectICS$[rsp]
  01411	e8 00 00 00 00	 call	 memcmp
  01416	85 c0		 test	 eax, eax
  01418	0f 84 24 01 00
	00		 je	 $LN72@loadtext_c
  0141e	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  01426	41 b8 03 00 00
	00		 mov	 r8d, 3
  0142c	48 8b d0	 mov	 rdx, rax
  0142f	48 8d 8c 24 b4
	00 00 00	 lea	 rcx, QWORD PTR c_ObjectPAD$[rsp]
  01437	e8 00 00 00 00	 call	 memcmp
  0143c	85 c0		 test	 eax, eax
  0143e	0f 84 fe 00 00
	00		 je	 $LN72@loadtext_c
  01444	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  0144c	41 b8 03 00 00
	00		 mov	 r8d, 3
  01452	48 8b d0	 mov	 rdx, rax
  01455	48 8d 8c 24 cc
	00 00 00	 lea	 rcx, QWORD PTR c_ObjectPRT$[rsp]
  0145d	e8 00 00 00 00	 call	 memcmp
  01462	85 c0		 test	 eax, eax
  01464	0f 84 d8 00 00
	00		 je	 $LN72@loadtext_c
  0146a	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  01472	41 b8 03 00 00
	00		 mov	 r8d, 3
  01478	48 8b d0	 mov	 rdx, rax
  0147b	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR c_ObjectPRM$[rsp]
  01483	e8 00 00 00 00	 call	 memcmp
  01488	85 c0		 test	 eax, eax
  0148a	0f 84 b2 00 00
	00		 je	 $LN72@loadtext_c
  01490	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  01498	41 b8 03 00 00
	00		 mov	 r8d, 3
  0149e	48 8b d0	 mov	 rdx, rax
  014a1	48 8d 8c 24 d4
	00 00 00	 lea	 rcx, QWORD PTR c_ObjectREP$[rsp]
  014a9	e8 00 00 00 00	 call	 memcmp
  014ae	85 c0		 test	 eax, eax
  014b0	0f 84 8c 00 00
	00		 je	 $LN72@loadtext_c
  014b6	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  014be	41 b8 03 00 00
	00		 mov	 r8d, 3
  014c4	48 8b d0	 mov	 rdx, rax
  014c7	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR c_ObjectSLC$[rsp]
  014cf	e8 00 00 00 00	 call	 memcmp
  014d4	85 c0		 test	 eax, eax
  014d6	74 6a		 je	 SHORT $LN72@loadtext_c
  014d8	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  014e0	41 b8 03 00 00
	00		 mov	 r8d, 3
  014e6	48 8b d0	 mov	 rdx, rax
  014e9	48 8d 8c 24 dc
	00 00 00	 lea	 rcx, QWORD PTR c_ObjectSYS$[rsp]
  014f1	e8 00 00 00 00	 call	 memcmp
  014f6	85 c0		 test	 eax, eax
  014f8	74 48		 je	 SHORT $LN72@loadtext_c
  014fa	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  01502	41 b8 03 00 00
	00		 mov	 r8d, 3
  01508	48 8b d0	 mov	 rdx, rax
  0150b	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR c_ObjectUPB$[rsp]
  01513	e8 00 00 00 00	 call	 memcmp
  01518	85 c0		 test	 eax, eax
  0151a	74 26		 je	 SHORT $LN72@loadtext_c
  0151c	48 8d 84 24 e1
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+1]
  01524	41 b8 03 00 00
	00		 mov	 r8d, 3
  0152a	48 8b d0	 mov	 rdx, rax
  0152d	48 8d 8c 24 e4
	00 00 00	 lea	 rcx, QWORD PTR c_ObjectVER$[rsp]
  01535	e8 00 00 00 00	 call	 memcmp
  0153a	85 c0		 test	 eax, eax
  0153c	0f 85 1c 01 00
	00		 jne	 $LN70@loadtext_c
$LN72@loadtext_c:

; 525  :                          ObjectVER)
; 526  :                 {
; 527  :                     char msgbuf[4];
; 528  : 
; 529  :                     memset(msgbuf, 0, sizeof(msgbuf));

  01542	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR msgbuf$6[rsp]
  0154a	48 8b f8	 mov	 rdi, rax
  0154d	33 c0		 xor	 eax, eax
  0154f	b9 04 00 00 00	 mov	 ecx, 4
  01554	f3 aa		 rep stosb

; 530  :                     msgbuf[0] = guest_to_host(buf[1]);

  01556	b8 01 00 00 00	 mov	 eax, 1
  0155b	48 6b c0 01	 imul	 rax, rax, 1
  0155f	0f b6 8c 04 e0
	01 00 00	 movzx	 ecx, BYTE PTR buf$[rsp+rax]
  01567	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  0156d	b9 01 00 00 00	 mov	 ecx, 1
  01572	48 6b c9 00	 imul	 rcx, rcx, 0
  01576	88 84 0c 80 00
	00 00		 mov	 BYTE PTR msgbuf$6[rsp+rcx], al

; 531  :                     msgbuf[1] = guest_to_host(buf[2]);

  0157d	b8 01 00 00 00	 mov	 eax, 1
  01582	48 6b c0 02	 imul	 rax, rax, 2
  01586	0f b6 8c 04 e0
	01 00 00	 movzx	 ecx, BYTE PTR buf$[rsp+rax]
  0158e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  01594	b9 01 00 00 00	 mov	 ecx, 1
  01599	48 6b c9 01	 imul	 rcx, rcx, 1
  0159d	88 84 0c 80 00
	00 00		 mov	 BYTE PTR msgbuf$6[rsp+rcx], al

; 532  :                     msgbuf[2] = guest_to_host(buf[3]);

  015a4	b8 01 00 00 00	 mov	 eax, 1
  015a9	48 6b c0 03	 imul	 rax, rax, 3
  015ad	0f b6 8c 04 e0
	01 00 00	 movzx	 ecx, BYTE PTR buf$[rsp+rax]
  015b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  015bb	b9 01 00 00 00	 mov	 ecx, 1
  015c0	48 6b c9 02	 imul	 rcx, rcx, 2
  015c4	88 84 0c 80 00
	00 00		 mov	 BYTE PTR msgbuf$6[rsp+rcx], al

; 533  :                     WRMSG( HHC02309, "W", argv[0], recno, msgbuf );

  015cb	b8 08 00 00 00	 mov	 eax, 8
  015d0	48 6b c0 00	 imul	 rax, rax, 0
  015d4	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv1035[rsp], rax
  015dc	b9 01 00 00 00	 mov	 ecx, 1
  015e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  015e7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$6[rsp]
  015ef	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  015f4	8b 4c 24 54	 mov	 ecx, DWORD PTR recno$[rsp]
  015f8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  015fc	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  01604	48 8b 94 24 a8
	01 00 00	 mov	 rdx, QWORD PTR tv1035[rsp]
  0160c	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  01610	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01615	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159352
  0161c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01621	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159353
  01628	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0162d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01632	41 b9 03 00 00
	00		 mov	 r9d, 3
  01638	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159354
  0163f	ba 15 02 00 00	 mov	 edx, 533		; 00000215H
  01644	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159355
  0164b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 534  :                     rc = 4;

  01651	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR rc$[rsp], 4

; 535  :                 }

  01659	e9 17 01 00 00	 jmp	 $LN71@loadtext_c
$LN70@loadtext_c:

; 536  : 
; 537  : 
; 538  :                 /*****************************************************/
; 539  :                 /*                                                   */
; 540  :                 /*      Handle unknown loader directive              */
; 541  :                 /*                                                   */
; 542  :                 /*****************************************************/
; 543  : 
; 544  :                 /* If unknown object record, complain */
; 545  :                 else
; 546  :                 {
; 547  :                     char msgbuf[4];
; 548  : 
; 549  :                     memset(msgbuf, 0, sizeof(msgbuf));

  0165e	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR msgbuf$7[rsp]
  01666	48 8b f8	 mov	 rdi, rax
  01669	33 c0		 xor	 eax, eax
  0166b	b9 04 00 00 00	 mov	 ecx, 4
  01670	f3 aa		 rep stosb

; 550  :                     msgbuf[0] = guest_to_host(buf[1]);

  01672	b8 01 00 00 00	 mov	 eax, 1
  01677	48 6b c0 01	 imul	 rax, rax, 1
  0167b	0f b6 8c 04 e0
	01 00 00	 movzx	 ecx, BYTE PTR buf$[rsp+rax]
  01683	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  01689	b9 01 00 00 00	 mov	 ecx, 1
  0168e	48 6b c9 00	 imul	 rcx, rcx, 0
  01692	88 84 0c 84 00
	00 00		 mov	 BYTE PTR msgbuf$7[rsp+rcx], al

; 551  :                     msgbuf[1] = guest_to_host(buf[2]);

  01699	b8 01 00 00 00	 mov	 eax, 1
  0169e	48 6b c0 02	 imul	 rax, rax, 2
  016a2	0f b6 8c 04 e0
	01 00 00	 movzx	 ecx, BYTE PTR buf$[rsp+rax]
  016aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  016b0	b9 01 00 00 00	 mov	 ecx, 1
  016b5	48 6b c9 01	 imul	 rcx, rcx, 1
  016b9	88 84 0c 84 00
	00 00		 mov	 BYTE PTR msgbuf$7[rsp+rcx], al

; 552  :                     msgbuf[2] = guest_to_host(buf[3]);

  016c0	b8 01 00 00 00	 mov	 eax, 1
  016c5	48 6b c0 03	 imul	 rax, rax, 3
  016c9	0f b6 8c 04 e0
	01 00 00	 movzx	 ecx, BYTE PTR buf$[rsp+rax]
  016d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  016d7	b9 01 00 00 00	 mov	 ecx, 1
  016dc	48 6b c9 02	 imul	 rcx, rcx, 2
  016e0	88 84 0c 84 00
	00 00		 mov	 BYTE PTR msgbuf$7[rsp+rcx], al

; 553  :                     WRMSG( HHC02302, "W", argv[0], recno, msgbuf );

  016e7	b8 08 00 00 00	 mov	 eax, 8
  016ec	48 6b c0 00	 imul	 rax, rax, 0
  016f0	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv1071[rsp], rax
  016f8	b9 01 00 00 00	 mov	 ecx, 1
  016fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01703	48 8d 8c 24 84
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$7[rsp]
  0170b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01710	8b 4c 24 54	 mov	 ecx, DWORD PTR recno$[rsp]
  01714	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01718	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  01720	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR tv1071[rsp]
  01728	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0172c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01731	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159356
  01738	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0173d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159357
  01744	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01749	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0174e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01754	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159358
  0175b	ba 29 02 00 00	 mov	 edx, 553		; 00000229H
  01760	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159359
  01767	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 554  :                     rc = 4;

  0176d	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR rc$[rsp], 4
$LN71@loadtext_c:
$LN69@loadtext_c:
$LN66@loadtext_c:
$LN64@loadtext_c:
$LN62@loadtext_c:
$LN60@loadtext_c:
$LN46@loadtext_c:
$LN42@loadtext_c:

; 555  :                 }
; 556  : 
; 557  :                 /* End of original object format handling */
; 558  :                 break;

  01775	e9 92 01 00 00	 jmp	 $LN8@loadtext_c
$LN73@loadtext_c:

; 559  : 
; 560  : 
; 561  :             /*********************************************************/
; 562  :             /*                                                       */
; 563  :             /*      Process GOFF records                             */
; 564  :             /*                                                       */
; 565  :             /*********************************************************/
; 566  : 
; 567  :             case GOFFRecord:
; 568  : 
; 569  :                 /* Error if GOFF object (not handled yet) */
; 570  :                 WRMSG( HHC02303, "E", argv[0], recno );

  0177a	b8 08 00 00 00	 mov	 eax, 8
  0177f	48 6b c0 00	 imul	 rax, rax, 0
  01783	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv1084[rsp], rax
  0178b	b9 01 00 00 00	 mov	 ecx, 1
  01790	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01796	8b 4c 24 54	 mov	 ecx, DWORD PTR recno$[rsp]
  0179a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0179e	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  017a6	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR tv1084[rsp]
  017ae	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  017b2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  017b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159361
  017be	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  017c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159362
  017ca	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  017cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  017d4	41 b9 03 00 00
	00		 mov	 r9d, 3
  017da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159363
  017e1	ba 3a 02 00 00	 mov	 edx, 570		; 0000023aH
  017e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159364
  017ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 571  :                 rc = -1;

  017f3	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 572  :                 break;

  017fb	e9 0c 01 00 00	 jmp	 $LN8@loadtext_c
$LN74@loadtext_c:

; 573  : 
; 574  : 
; 575  :             /*********************************************************/
; 576  :             /*                                                       */
; 577  :             /*      Process VM comment record                        */
; 578  :             /*                                                       */
; 579  :             /*********************************************************/
; 580  : 
; 581  :             case CommentRecord:
; 582  :                 break;              // Ignore record

  01800	e9 07 01 00 00	 jmp	 $LN8@loadtext_c
$LN75@loadtext_c:

; 583  : 
; 584  : 
; 585  :             /*********************************************************/
; 586  :             /*                                                       */
; 587  :             /*      Process Linkage Editor / Loader / Binder         */
; 588  :             /*      directives                                       */
; 589  :             /*                                                       */
; 590  :             /*********************************************************/
; 591  : 
; 592  :             /* Skip if possible loader card, but complain anyways */
; 593  :             case LoaderBinderRecord:
; 594  :                 WRMSG( HHC02304, "W", argv[0], recno );

  01805	b8 08 00 00 00	 mov	 eax, 8
  0180a	48 6b c0 00	 imul	 rax, rax, 0
  0180e	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv1097[rsp], rax
  01816	b9 01 00 00 00	 mov	 ecx, 1
  0181b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01821	8b 4c 24 54	 mov	 ecx, DWORD PTR recno$[rsp]
  01825	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01829	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  01831	48 8b 94 24 c0
	01 00 00	 mov	 rdx, QWORD PTR tv1097[rsp]
  01839	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0183d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01842	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159367
  01849	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0184e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159368
  01855	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0185a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0185f	41 b9 03 00 00
	00		 mov	 r9d, 3
  01865	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159369
  0186c	ba 52 02 00 00	 mov	 edx, 594		; 00000252H
  01871	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159370
  01878	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 595  :                 rc = 4;

  0187e	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR rc$[rsp], 4

; 596  :                 break;

  01886	e9 81 00 00 00	 jmp	 $LN8@loadtext_c
$LN76@loadtext_c:

; 597  : 
; 598  : 
; 599  :             /*********************************************************/
; 600  :             /*                                                       */
; 601  :             /*      Process unknown/unsupported records and          */
; 602  :             /*      directives                                       */
; 603  :             /*                                                       */
; 604  :             /*********************************************************/
; 605  : 
; 606  :             default:
; 607  :                 WRMSG( HHC02305, "E", argv[0], recno );

  0188b	b8 08 00 00 00	 mov	 eax, 8
  01890	48 6b c0 00	 imul	 rax, rax, 0
  01894	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv1110[rsp], rax
  0189c	b9 01 00 00 00	 mov	 ecx, 1
  018a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  018a7	8b 4c 24 54	 mov	 ecx, DWORD PTR recno$[rsp]
  018ab	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  018af	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  018b7	48 8b 94 24 c8
	01 00 00	 mov	 rdx, QWORD PTR tv1110[rsp]
  018bf	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  018c3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  018c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159372
  018cf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  018d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159373
  018db	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  018e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  018e5	41 b9 03 00 00
	00		 mov	 r9d, 3
  018eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159374
  018f2	ba 5f 02 00 00	 mov	 edx, 607		; 0000025fH
  018f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159375
  018fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 608  :                 rc = -1;

  01904	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN8@loadtext_c:

; 609  :         }
; 610  : 
; 611  :     }

  0190c	e9 fa ee ff ff	 jmp	 $LN5@loadtext_c
$LN6@loadtext_c:

; 612  : 
; 613  :     /* Close file and issue status message */
; 614  :     close (fd);

  01911	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  01918	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 615  : 
; 616  :     if (rc >= 0 && rc < 8)

  0191e	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  01923	0f 8c ca 00 00
	00		 jl	 $LN77@loadtext_c
  01929	83 7c 24 50 08	 cmp	 DWORD PTR rc$[rsp], 8
  0192e	0f 8d bf 00 00
	00		 jge	 $LN77@loadtext_c

; 617  :     {
; 618  :         if (rc > 0)

  01934	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  01939	7e 71		 jle	 SHORT $LN78@loadtext_c

; 619  :             WRMSG(HHC02308, "W", argv[0] );

  0193b	b8 08 00 00 00	 mov	 eax, 8
  01940	48 6b c0 00	 imul	 rax, rax, 0
  01944	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv1132[rsp], rax
  0194c	b9 01 00 00 00	 mov	 ecx, 1
  01951	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01957	48 8b 8c 24 a8
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0195f	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR tv1132[rsp]
  01967	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0196b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01970	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159378
  01977	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0197c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159379
  01983	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01988	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0198d	41 b9 03 00 00
	00		 mov	 r9d, 3
  01993	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159380
  0199a	ba 6b 02 00 00	 mov	 edx, 619		; 0000026bH
  0199f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159381
  019a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN78@loadtext_c:

; 620  :         // "Operation complete"
; 621  :         WRMSG(HHC02249, "I");

  019ac	b9 01 00 00 00	 mov	 ecx, 1
  019b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  019b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159382
  019be	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  019c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159383
  019ca	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  019cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  019d4	41 b9 03 00 00
	00		 mov	 r9d, 3
  019da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159384
  019e1	ba 6d 02 00 00	 mov	 edx, 621		; 0000026dH
  019e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159385
  019ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN77@loadtext_c:

; 622  :     }
; 623  : 
; 624  : 
; 625  :     release_lock(&sysblk.cpulock[sysblk.pcpu]);

  019f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  019fa	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  01a01	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01a08	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  01a10	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159386
  01a17	48 8b c8	 mov	 rcx, rax
  01a1a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 626  : 
; 627  :     return rc;

  01a20	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@loadtext_c:

; 628  : 
; 629  :     /* Undefine macros for routine                                   */
; 630  : 
; 631  : #undef TextRecord
; 632  : #undef GOFFRecord
; 633  : #undef CommentRecord
; 634  : #undef LoaderBinderRecord
; 635  : #undef ObjectTest
; 636  : #undef ObjectESD
; 637  : #undef ObjectTXT
; 638  : #undef ObjectRLD
; 639  : #undef ObjectEND
; 640  : #undef ObjectSYM
; 641  : #undef ObjectCPB
; 642  : #undef ObjectDEL
; 643  : #undef ObjectICS
; 644  : #undef ObjectLDT
; 645  : #undef ObjectPAD
; 646  : #undef ObjectPRT
; 647  : #undef ObjectPRM
; 648  : #undef ObjectREP
; 649  : #undef ObjectSLC
; 650  : #undef ObjectSPB
; 651  : #undef ObjectSYS
; 652  : #undef ObjectUPB
; 653  : #undef ObjectVER
; 654  : 
; 655  : }

  01a24	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01a2c	48 33 cc	 xor	 rcx, rsp
  01a2f	e8 00 00 00 00	 call	 __security_check_cookie
  01a34	48 81 c4 88 03
	00 00		 add	 rsp, 904		; 00000388H
  01a3b	5f		 pop	 rdi
  01a3c	5e		 pop	 rsi
  01a3d	c3		 ret	 0
loadtext_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\loadmem.c
_TEXT	SEGMENT
aaddr$ = 80
fname$ = 88
loadaddr$ = 96
tv66 = 104
tv87 = 112
work64$ = 120
tv175 = 128
regs$ = 136
statbuff$ = 144
buf1$1 = 200
pathname$ = 240
__$ArrayPad$ = 512
argc$ = 544
argv$ = 552
cmdline$ = 560
loadcore_cmd PROC

; 21   : {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec 18 02
	00 00		 sub	 rsp, 536		; 00000218H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@loadcore_c:

; 22   : REGS *regs;
; 23   : 
; 24   :     char   *fname;                      /* -> File name (ASCIIZ)     */
; 25   :     struct stat statbuff;               /* Buffer for file status    */
; 26   :     char   *loadaddr;                   /* loadcore memory address   */
; 27   :     U64     work64;                     /* 64-bit work variable      */
; 28   :     RADR    aaddr;                      /* Absolute storage address  */
; 29   :     char    pathname[MAX_PATH];         /* file in host path format  */
; 30   : 
; 31   :     UNREFERENCED(cmdline);

  00027	33 c0		 xor	 eax, eax
  00029	85 c0		 test	 eax, eax
  0002b	75 fa		 jne	 SHORT $LN4@loadcore_c

; 32   : 
; 33   :     if (argc < 2)

  0002d	83 bc 24 20 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00035	7d 75		 jge	 SHORT $LN5@loadcore_c

; 34   :     {
; 35   :         WRMSG(HHC02202, "E", argv[0] );

  00037	b8 08 00 00 00	 mov	 eax, 8
  0003c	48 6b c0 00	 imul	 rax, rax, 0
  00040	48 89 44 24 68	 mov	 QWORD PTR tv66[rsp], rax
  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00050	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00058	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv66[rsp]
  0005d	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00061	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159075
  0006d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159076
  00079	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0007e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00083	41 b9 03 00 00
	00		 mov	 r9d, 3
  00089	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159077
  00090	ba 23 00 00 00	 mov	 edx, 35			; 00000023H
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159078
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 36   :         return -1;

  000a2	b8 ff ff ff ff	 mov	 eax, -1
  000a7	e9 62 04 00 00	 jmp	 $LN1@loadcore_c
$LN5@loadcore_c:

; 37   :     }
; 38   : 
; 39   :     fname = argv[1];

  000ac	b8 08 00 00 00	 mov	 eax, 8
  000b1	48 6b c0 01	 imul	 rax, rax, 1
  000b5	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000bd	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000c1	48 89 44 24 58	 mov	 QWORD PTR fname$[rsp], rax

; 40   :     hostpath(pathname, fname, sizeof(pathname));

  000c6	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000cc	48 8b 54 24 58	 mov	 rdx, QWORD PTR fname$[rsp]
  000d1	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 41   : 
; 42   :     if (stat(pathname, &statbuff) < 0)

  000df	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR statbuff$[rsp]
  000e7	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64
  000f5	85 c0		 test	 eax, eax
  000f7	7d 7a		 jge	 SHORT $LN6@loadcore_c

; 43   :     {
; 44   :         WRMSG(HHC02219, "E", "stat()", strerror(errno));

  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ff	8b 08		 mov	 ecx, DWORD PTR [rax]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00107	48 89 44 24 70	 mov	 QWORD PTR tv87[rsp], rax
  0010c	b9 01 00 00 00	 mov	 ecx, 1
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00117	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv87[rsp]
  0011c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159080
  00128	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159081
  00134	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159082
  00140	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00145	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00150	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159083
  00157	ba 2c 00 00 00	 mov	 edx, 44			; 0000002cH
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159084
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 45   :         return -1;

  00169	b8 ff ff ff ff	 mov	 eax, -1
  0016e	e9 9b 03 00 00	 jmp	 $LN1@loadcore_c
$LN6@loadcore_c:

; 46   :     }
; 47   : 
; 48   :     if (argc < 3) aaddr = 0;

  00173	83 bc 24 20 02
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  0017b	7d 0e		 jge	 SHORT $LN7@loadcore_c
  0017d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR aaddr$[rsp], 0
  00186	e9 a6 00 00 00	 jmp	 $LN8@loadcore_c
$LN7@loadcore_c:

; 49   :     else
; 50   :     {
; 51   :         loadaddr = argv[2];

  0018b	b8 08 00 00 00	 mov	 eax, 8
  00190	48 6b c0 02	 imul	 rax, rax, 2
  00194	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0019c	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  001a0	48 89 44 24 60	 mov	 QWORD PTR loadaddr$[rsp], rax

; 52   : 
; 53   :         if (sscanf(loadaddr, "%"SCNx64, &work64) !=1)

  001a5	4c 8d 44 24 78	 lea	 r8, QWORD PTR work64$[rsp]
  001aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159088
  001b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR loadaddr$[rsp]
  001b6	e8 00 00 00 00	 call	 sscanf
  001bb	83 f8 01	 cmp	 eax, 1
  001be	74 67		 je	 SHORT $LN9@loadcore_c

; 54   :         {
; 55   :             WRMSG(HHC02205, "E", loadaddr, ": invalid address" );

  001c0	b9 01 00 00 00	 mov	 ecx, 1
  001c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159089
  001d2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001d7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR loadaddr$[rsp]
  001dc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159090
  001e8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159091
  001f4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fe	41 b9 03 00 00
	00		 mov	 r9d, 3
  00204	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159092
  0020b	ba 37 00 00 00	 mov	 edx, 55			; 00000037H
  00210	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159093
  00217	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 56   :             return -1;

  0021d	b8 ff ff ff ff	 mov	 eax, -1
  00222	e9 e7 02 00 00	 jmp	 $LN1@loadcore_c
$LN9@loadcore_c:

; 57   :         }
; 58   :         aaddr = (RADR) work64;

  00227	48 8b 44 24 78	 mov	 rax, QWORD PTR work64$[rsp]
  0022c	48 89 44 24 50	 mov	 QWORD PTR aaddr$[rsp], rax
$LN8@loadcore_c:

; 59   :     }
; 60   : 
; 61   :     obtain_lock(&sysblk.cpulock[sysblk.pcpu]);

  00231	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00238	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  0023f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00246	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  0024e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159094
  00255	48 8b c8	 mov	 rcx, rax
  00258	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 62   : 
; 63   :     if (!IS_CPU_ONLINE(sysblk.pcpu))

  0025e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00265	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  0026c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00273	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0027c	0f 85 d0 00 00
	00		 jne	 $LN10@loadcore_c

; 64   :     {
; 65   :         release_lock(&sysblk.cpulock[sysblk.pcpu]);

  00282	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00289	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00290	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00297	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  0029f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159096
  002a6	48 8b c8	 mov	 rcx, rax
  002a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 66   :         WRMSG(HHC00816, "W", PTYPSTR(sysblk.pcpu), sysblk.pcpu, "online");

  002af	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002b6	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  002bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002c4	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  002d2	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv175[rsp], rax
  002da	b9 01 00 00 00	 mov	 ecx, 1
  002df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159097
  002ec	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002f8	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  002fe	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00302	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv175[rsp]
  0030a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0030f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159098
  00316	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0031b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159099
  00322	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00327	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0032c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00332	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159100
  00339	ba 42 00 00 00	 mov	 edx, 66			; 00000042H
  0033e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159101
  00345	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 67   :         return 0;

  0034b	33 c0		 xor	 eax, eax
  0034d	e9 bc 01 00 00	 jmp	 $LN1@loadcore_c
$LN10@loadcore_c:

; 68   :     }
; 69   :     regs = sysblk.regs[sysblk.pcpu];

  00352	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00359	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00360	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00367	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0036f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR regs$[rsp], rax

; 70   : 
; 71   :     /* Command is valid only when CPU is stopped */
; 72   :     if (CPUSTATE_STOPPED != regs->cpustate)

  00377	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0037f	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00383	83 f8 03	 cmp	 eax, 3
  00386	74 7e		 je	 SHORT $LN11@loadcore_c

; 73   :     {
; 74   :         release_lock(&sysblk.cpulock[sysblk.pcpu]);

  00388	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0038f	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  00396	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0039d	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  003a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159103
  003ac	48 8b c8	 mov	 rcx, rax
  003af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 75   :         WRMSG(HHC02247, "E");

  003b5	b9 01 00 00 00	 mov	 ecx, 1
  003ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159104
  003c7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159105
  003d3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003dd	41 b9 03 00 00
	00		 mov	 r9d, 3
  003e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159106
  003ea	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  003ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159107
  003f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 76   :         return -1;

  003fc	b8 ff ff ff ff	 mov	 eax, -1
  00401	e9 08 01 00 00	 jmp	 $LN1@loadcore_c
$LN11@loadcore_c:

; 77   :     }
; 78   : 
; 79   :     // "Loading file %s to location %s"
; 80   :     {
; 81   :         char buf1[32];
; 82   :         MSGBUF( buf1, "%"PRIX64, (U64) aaddr );

  00406	4c 8b 4c 24 50	 mov	 r9, QWORD PTR aaddr$[rsp]
  0040b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159108
  00412	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00417	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR buf1$1[rsp]
  0041f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 83   :         WRMSG(HHC02250, "I", fname, buf1 );

  00425	b9 01 00 00 00	 mov	 ecx, 1
  0042a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00430	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR buf1$1[rsp]
  00438	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0043d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR fname$[rsp]
  00442	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00447	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159109
  0044e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00453	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159110
  0045a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0045f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00464	41 b9 03 00 00
	00		 mov	 r9d, 3
  0046a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159111
  00471	ba 53 00 00 00	 mov	 edx, 83			; 00000053H
  00476	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159112
  0047d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 84   :     }
; 85   : 
; 86   :     (void)load_main(fname, aaddr, 1);

  00483	41 b8 01 00 00
	00		 mov	 r8d, 1
  00489	48 8b 54 24 50	 mov	 rdx, QWORD PTR aaddr$[rsp]
  0048e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR fname$[rsp]
  00493	e8 00 00 00 00	 call	 load_main

; 87   : 
; 88   :     release_lock(&sysblk.cpulock[sysblk.pcpu]);

  00498	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0049f	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  004a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004ad	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  004b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159113
  004bc	48 8b c8	 mov	 rcx, rax
  004bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 89   : 
; 90   :     // "Operation complete"
; 91   :     WRMSG(HHC02249, "I");

  004c5	b9 01 00 00 00	 mov	 ecx, 1
  004ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159114
  004d7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159115
  004e3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ed	41 b9 03 00 00
	00		 mov	 r9d, 3
  004f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159116
  004fa	ba 5b 00 00 00	 mov	 edx, 91			; 0000005bH
  004ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159117
  00506	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 92   : 
; 93   :     return 0;

  0050c	33 c0		 xor	 eax, eax
$LN1@loadcore_c:

; 94   : }

  0050e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00516	48 33 cc	 xor	 rcx, rsp
  00519	e8 00 00 00 00	 call	 __security_check_cookie
  0051e	48 81 c4 18 02
	00 00		 add	 rsp, 536		; 00000218H
  00525	c3		 ret	 0
loadcore_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
END
