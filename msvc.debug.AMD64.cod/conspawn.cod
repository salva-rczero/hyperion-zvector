; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	main
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	strcat:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_ShellExecuteA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_perror:PROC
EXTRN	__imp_system:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__ImageBase:BYTE
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$main DD	imagerel $LN50
	DD	imagerel $LN50+1601
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG159094 DB	'startgui', 00H
	ORG $+7
$SG159099 DB	'conspawn', 00H
	ORG $+3
$SG159101 DB	'"', 00H
	ORG $+2
$SG159103 DB	'"', 00H
	ORG $+2
$SG159105 DB	' ', 00H
	ORG $+2
$SG159109 DB	'The operating system is out of memory or resources', 00H
	ORG $+1
$SG159144 DB	'"', 00H
	ORG $+2
$SG159111 DB	'The specified file was not found', 00H
	ORG $+3
$SG159146 DB	'"', 00H
	ORG $+2
$SG159113 DB	'The specified path was not found', 00H
	ORG $+3
$SG159148 DB	' ', 00H
	ORG $+2
$SG159115 DB	'The operating system denied access to the specified file'
	DB	00H
	ORG $+7
$SG159117 DB	'The .exe file is invalid (non-Microsoft Win32 .exe or er'
	DB	'ror in .exe image)', 00H
	ORG $+5
$SG159119 DB	'There was not enough memory to complete the operation', 00H
	ORG $+2
$SG159121 DB	'The specified dynamic-link library (DLL) was not found', 00H
	ORG $+1
$SG159123 DB	'A sharing violation occurred', 00H
	ORG $+3
$SG159125 DB	'The file name association is incomplete or invalid', 00H
	ORG $+13
$SG159127 DB	'The DDE transaction could not be completed because the r'
	DB	'equest timed out', 00H
	ORG $+7
$SG159129 DB	'The DDE transaction failed', 00H
	ORG $+5
$SG159131 DB	'The Dynamic Data Exchange (DDE) transaction could not be'
	DB	' completed because other DDE transactions were being processe'
	DB	'd', 00H
	ORG $+9
$SG159133 DB	'There is no application associated with the given file n'
	DB	'ame extension. This error will also be returned if you attemp'
	DB	't to print a file that is not printable', 00H
	ORG $+3
$SG159135 DB	'conspawn: ShellExecute("%s", "%s",...) failed: Unknown e'
	DB	'rror; rc=%d (0x%8.8X).', 0aH, 00H
$SG159136 DB	'conspawn: ShellExecute("%s", "%s",...) failed: %s.', 0aH
	DB	00H
	ORG $+4
$SG159139 DB	'conspawn', 00H
	ORG $+7
$SG159140 DB	'conspawn: Usage: command [args]', 0aH, 00H
	ORG $+7
$SG159142 DB	'conspawn', 00H
	ORG $+7
$SG159150 DB	'conspawn', 00H
_DATA	ENDS
xdata	SEGMENT
$unwind$main DD	021001H
	DD	0130110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\conspawn.c
_TEXT	SEGMENT
i$ = 48
p$ = 56
rc$ = 64
pszErrMsg$1 = 72
k$ = 80
tv171 = 88
lpParameters$2 = 96
nShowCmd$3 = 104
lpFile$4 = 112
lpDirectory$5 = 120
lpOperation$6 = 128
hwnd$7 = 136
argc$ = 160
argv$ = 168
main	PROC

; 26   : {

$LN50:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 27   :     int i, rc;
; 28   :     size_t k;
; 29   :     char* p;
; 30   : 
; 31   : #ifdef _MSVC_
; 32   : #pragma comment(lib,"shell32.lib")   // (need ShellExecute)
; 33   :     // --------------------------------------------------------
; 34   :     // PROGRAMMING NOTE: We MUST use "ShellExecute" for Windows
; 35   :     // GUI programs since: 1) GUI programs don't use stdio,
; 36   :     // 2) they never exit until the user manually closes them.
; 37   :     //
; 38   :     // Erroneously using the 'system()' function to start a GUI
; 39   :     // program causes HercGUI to hang at PowerOff as it waits
; 40   :     // for its child process to close its stdio handles which
; 41   :     // GUI programs never do until they exit (which they never
; 42   :     // do until the user manually closes them).
; 43   :     //
; 44   :     // The reason this phenomenon occurs even though Hercules
; 45   :     // does indeed close ITS OWN stdio handles when it ends is
; 46   :     // because its child processes that it creates ALSO inherit
; 47   :     // the same stdio handles! (I.e. the GUI programs that Herc
; 48   :     // starts end up never closing "Herc's" [inherited] stdio
; 49   :     // handles, which are the same handles that HercGUI waits
; 50   :     // on! Thus GUI programs started by Herc using the 'system'
; 51   :     // API end up hanging HercGUI! (during Herc PowerOff))
; 52   :     //
; 53   :     // Thus, for GUI apps, we MUST use "ShellExecute" here
; 54   :     // to prevent HercGUI from hanging at PowerOff. Also note
; 55   :     // that this hang obviously does not occur when Hercules
; 56   :     // is run in command-line (non-HercGUI) mode even when
; 57   :     // the 'system()' API is erroneously used, since Herc is
; 58   :     // obviously (duh!) not being run under the control of an
; 59   :     // external GUI in such a situation.   -- Fish, Aug. 2006
; 60   :     // --------------------------------------------------------
; 61   : 
; 62   :     if (argc >= 2 && strcasecmp(argv[1],"startgui") == 0)

  00010	83 bc 24 a0 00
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00018	0f 8c d0 03 00
	00		 jl	 $LN16@main
  0001e	b8 08 00 00 00	 mov	 eax, 8
  00023	48 6b c0 01	 imul	 rax, rax, 1
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159094
  0002e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00036	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00040	85 c0		 test	 eax, eax
  00042	0f 85 a6 03 00
	00		 jne	 $LN16@main

; 63   :     {
; 64   :         ////////////////////////////////////////////////////////
; 65   :         // Windows GUI program; no stdio; use 'ShellExecute'...
; 66   :         ////////////////////////////////////////////////////////
; 67   : 
; 68   :         // REFERENCE: upon entry:
; 69   : 
; 70   :         //   argv[0]       "conspawn"
; 71   :         //   argv[1]       "startgui"
; 72   :         //   argv[2]       (program to start)
; 73   :         //   argv[3..n]    (arguments for program)
; 74   : 
; 75   :         HWND     hwnd          = NULL;

  00048	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR hwnd$7[rsp], 0

; 76   :         LPCTSTR  lpOperation   = NULL;

  00054	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR lpOperation$6[rsp], 0

; 77   :         LPCTSTR  lpFile        = argv[2];

  00060	b8 08 00 00 00	 mov	 eax, 8
  00065	48 6b c0 02	 imul	 rax, rax, 2
  00069	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00071	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00075	48 89 44 24 70	 mov	 QWORD PTR lpFile$4[rsp], rax

; 78   :         LPCTSTR  lpParameters  = NULL;

  0007a	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR lpParameters$2[rsp], 0

; 79   :         LPCTSTR  lpDirectory   = NULL;

  00083	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR lpDirectory$5[rsp], 0

; 80   :         INT      nShowCmd      = SW_SHOWNORMAL;

  0008c	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR nShowCmd$3[rsp], 1

; 81   :         char*    pszErrMsg     = NULL;

  00094	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR pszErrMsg$1[rsp], 0

; 82   : 
; 83   :         // Build arguments string from passed args...
; 84   : 
; 85   :         for (i=3, k=0; i < argc; i++)

  0009d	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR i$[rsp], 3
  000a5	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR k$[rsp], 0
  000ae	eb 0a		 jmp	 SHORT $LN4@main
$LN2@main:
  000b0	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000b4	ff c0		 inc	 eax
  000b6	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@main:
  000ba	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  000c1	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  000c5	7d 55		 jge	 SHORT $LN3@main

; 86   :         {
; 87   :             k += strlen(argv[i]) + 1;

  000c7	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000cc	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000d4	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000d8	e8 00 00 00 00	 call	 strlen
  000dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR k$[rsp]
  000e2	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  000e7	48 89 44 24 50	 mov	 QWORD PTR k$[rsp], rax

; 88   :             if (strchr(argv[i],' ')) k += 2;

  000ec	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000f1	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000f6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000fe	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00102	e8 00 00 00 00	 call	 strchr
  00107	48 85 c0	 test	 rax, rax
  0010a	74 0e		 je	 SHORT $LN17@main
  0010c	48 8b 44 24 50	 mov	 rax, QWORD PTR k$[rsp]
  00111	48 83 c0 02	 add	 rax, 2
  00115	48 89 44 24 50	 mov	 QWORD PTR k$[rsp], rax
$LN17@main:

; 89   :         }

  0011a	eb 94		 jmp	 SHORT $LN2@main
$LN3@main:

; 90   : 
; 91   :         if (k)

  0011c	48 83 7c 24 50
	00		 cmp	 QWORD PTR k$[rsp], 0
  00122	0f 84 16 01 00
	00		 je	 $LN18@main

; 92   :         {
; 93   :             // (allocate room for arguments string)
; 94   : 
; 95   :             if (!(p = malloc(sizeof(char)*k)))

  00128	48 8b 4c 24 50	 mov	 rcx, QWORD PTR k$[rsp]
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00133	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
  00138	48 83 7c 24 38
	00		 cmp	 QWORD PTR p$[rsp], 0
  0013e	75 23		 jne	 SHORT $LN20@main

; 96   :             {
; 97   :                 errno = ENOMEM;

  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00146	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12

; 98   :                 perror( PGMNAME );

  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159099
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_perror

; 99   :                 return -1;

  00159	b8 ff ff ff ff	 mov	 eax, -1
  0015e	e9 7d 04 00 00	 jmp	 $LN1@main
$LN20@main:

; 100  :             }
; 101  :             *p = 0;

  00163	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  00168	c6 00 00	 mov	 BYTE PTR [rax], 0

; 102  : 
; 103  :             // (build arguments string from args)
; 104  : 
; 105  :             for (i=3; i < argc; ++i)

  0016b	c7 44 24 30 03
	00 00 00	 mov	 DWORD PTR i$[rsp], 3
  00173	eb 0a		 jmp	 SHORT $LN7@main
$LN5@main:
  00175	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00179	ff c0		 inc	 eax
  0017b	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@main:
  0017f	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00186	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0018a	0f 8d a2 00 00
	00		 jge	 $LN6@main

; 106  :             {
; 107  :                 if (strchr(argv[i],' ')) strcat(p,"\"");

  00190	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00195	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0019a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001a2	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  001a6	e8 00 00 00 00	 call	 strchr
  001ab	48 85 c0	 test	 rax, rax
  001ae	74 11		 je	 SHORT $LN21@main
  001b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159101
  001b7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  001bc	e8 00 00 00 00	 call	 strcat
$LN21@main:

; 108  :                 strcat(p,argv[i]);

  001c1	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  001c6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001ce	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  001d2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  001d7	e8 00 00 00 00	 call	 strcat

; 109  :                 if (strchr(argv[i],' ')) strcat(p,"\"");

  001dc	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  001e1	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001e6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001ee	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  001f2	e8 00 00 00 00	 call	 strchr
  001f7	48 85 c0	 test	 rax, rax
  001fa	74 11		 je	 SHORT $LN22@main
  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159103
  00203	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00208	e8 00 00 00 00	 call	 strcat
$LN22@main:

; 110  :                 if (i != (argc-1)) strcat(p," ");

  0020d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00214	ff c8		 dec	 eax
  00216	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0021a	74 11		 je	 SHORT $LN23@main
  0021c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159105
  00223	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00228	e8 00 00 00 00	 call	 strcat
$LN23@main:

; 111  :             }

  0022d	e9 43 ff ff ff	 jmp	 $LN5@main
$LN6@main:

; 112  : 
; 113  :             lpParameters = p;

  00232	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  00237	48 89 44 24 60	 mov	 QWORD PTR lpParameters$2[rsp], rax

; 114  :         }

  0023c	eb 09		 jmp	 SHORT $LN19@main
$LN18@main:

; 115  :         else
; 116  :             p = NULL;

  0023e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR p$[rsp], 0
$LN19@main:

; 117  : 
; 118  :         rc = (intptr_t) ShellExecute( hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd );

  00247	8b 44 24 68	 mov	 eax, DWORD PTR nShowCmd$3[rsp]
  0024b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0024f	48 8b 44 24 78	 mov	 rax, QWORD PTR lpDirectory$5[rsp]
  00254	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00259	4c 8b 4c 24 60	 mov	 r9, QWORD PTR lpParameters$2[rsp]
  0025e	4c 8b 44 24 70	 mov	 r8, QWORD PTR lpFile$4[rsp]
  00263	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR lpOperation$6[rsp]
  0026b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR hwnd$7[rsp]
  00273	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ShellExecuteA
  00279	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 119  : 
; 120  :         if (p)

  0027d	48 83 7c 24 38
	00		 cmp	 QWORD PTR p$[rsp], 0
  00283	74 0b		 je	 SHORT $LN24@main

; 121  :             free(p);

  00285	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  0028a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN24@main:

; 122  : 
; 123  :         if ( rc > 32)

  00290	83 7c 24 40 20	 cmp	 DWORD PTR rc$[rsp], 32	; 00000020H
  00295	7e 07		 jle	 SHORT $LN25@main

; 124  :             return 0;       // rc > greater than 32 == success...

  00297	33 c0		 xor	 eax, eax
  00299	e9 42 03 00 00	 jmp	 $LN1@main
$LN25@main:

; 125  : 
; 126  :         // rc <= less than or equal 32 == error...
; 127  : 
; 128  :         switch (rc)

  0029e	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]
  002a2	89 44 24 58	 mov	 DWORD PTR tv171[rsp], eax
  002a6	83 7c 24 58 20	 cmp	 DWORD PTR tv171[rsp], 32 ; 00000020H
  002ab	0f 87 eb 00 00
	00		 ja	 $LN39@main
  002b1	48 63 44 24 58	 movsxd	 rax, DWORD PTR tv171[rsp]
  002b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  002bd	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN48@main[rcx+rax]
  002c5	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN49@main[rcx+rax*4]
  002cc	48 03 c1	 add	 rax, rcx
  002cf	ff e0		 jmp	 rax
$LN26@main:

; 129  :         {
; 130  :             case 0:                      pszErrMsg = "The operating system is out of memory or resources"; break;

  002d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159109
  002d8	48 89 44 24 48	 mov	 QWORD PTR pszErrMsg$1[rsp], rax
  002dd	e9 e7 00 00 00	 jmp	 $LN8@main
$LN27@main:

; 131  :             case SE_ERR_FNF:             pszErrMsg = "The specified file was not found"; break;

  002e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159111
  002e9	48 89 44 24 48	 mov	 QWORD PTR pszErrMsg$1[rsp], rax
  002ee	e9 d6 00 00 00	 jmp	 $LN8@main
$LN28@main:

; 132  :             case SE_ERR_PNF:             pszErrMsg = "The specified path was not found"; break;

  002f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159113
  002fa	48 89 44 24 48	 mov	 QWORD PTR pszErrMsg$1[rsp], rax
  002ff	e9 c5 00 00 00	 jmp	 $LN8@main
$LN29@main:

; 133  :             case SE_ERR_ACCESSDENIED:    pszErrMsg = "The operating system denied access to the specified file"; break;

  00304	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159115
  0030b	48 89 44 24 48	 mov	 QWORD PTR pszErrMsg$1[rsp], rax
  00310	e9 b4 00 00 00	 jmp	 $LN8@main
$LN30@main:

; 134  :             case ERROR_BAD_FORMAT:       pszErrMsg = "The .exe file is invalid (non-Microsoft Win32 .exe or error in .exe image)"; break;

  00315	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159117
  0031c	48 89 44 24 48	 mov	 QWORD PTR pszErrMsg$1[rsp], rax
  00321	e9 a3 00 00 00	 jmp	 $LN8@main
$LN31@main:

; 135  :             case SE_ERR_OOM:             pszErrMsg = "There was not enough memory to complete the operation"; break;

  00326	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159119
  0032d	48 89 44 24 48	 mov	 QWORD PTR pszErrMsg$1[rsp], rax
  00332	e9 92 00 00 00	 jmp	 $LN8@main
$LN32@main:

; 136  :             case SE_ERR_DLLNOTFOUND:     pszErrMsg = "The specified dynamic-link library (DLL) was not found"; break;

  00337	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159121
  0033e	48 89 44 24 48	 mov	 QWORD PTR pszErrMsg$1[rsp], rax
  00343	e9 81 00 00 00	 jmp	 $LN8@main
$LN33@main:

; 137  :             case SE_ERR_SHARE:           pszErrMsg = "A sharing violation occurred"; break;

  00348	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159123
  0034f	48 89 44 24 48	 mov	 QWORD PTR pszErrMsg$1[rsp], rax
  00354	eb 73		 jmp	 SHORT $LN8@main
$LN34@main:

; 138  :             case SE_ERR_ASSOCINCOMPLETE: pszErrMsg = "The file name association is incomplete or invalid"; break;

  00356	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159125
  0035d	48 89 44 24 48	 mov	 QWORD PTR pszErrMsg$1[rsp], rax
  00362	eb 65		 jmp	 SHORT $LN8@main
$LN35@main:

; 139  :             case SE_ERR_DDETIMEOUT:      pszErrMsg = "The DDE transaction could not be completed because the request timed out"; break;

  00364	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159127
  0036b	48 89 44 24 48	 mov	 QWORD PTR pszErrMsg$1[rsp], rax
  00370	eb 57		 jmp	 SHORT $LN8@main
$LN36@main:

; 140  :             case SE_ERR_DDEFAIL:         pszErrMsg = "The DDE transaction failed"; break;

  00372	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159129
  00379	48 89 44 24 48	 mov	 QWORD PTR pszErrMsg$1[rsp], rax
  0037e	eb 49		 jmp	 SHORT $LN8@main
$LN37@main:

; 141  :             case SE_ERR_DDEBUSY:         pszErrMsg = "The Dynamic Data Exchange (DDE) transaction could not be completed because other DDE transactions were being processed"; break;

  00380	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159131
  00387	48 89 44 24 48	 mov	 QWORD PTR pszErrMsg$1[rsp], rax
  0038c	eb 3b		 jmp	 SHORT $LN8@main
$LN38@main:

; 142  :             case SE_ERR_NOASSOC:         pszErrMsg = "There is no application associated with the given file name extension. This error will also be returned if you attempt to print a file that is not printable"; break;

  0038e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159133
  00395	48 89 44 24 48	 mov	 QWORD PTR pszErrMsg$1[rsp], rax
  0039a	eb 2d		 jmp	 SHORT $LN8@main
$LN39@main:

; 143  : 
; 144  :             default:
; 145  :                 printf(PGMNAME": ShellExecute(\"%s\", \"%s\",...) failed: Unknown error; rc=%d (0x%8.8X).\n",

  0039c	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]
  003a0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003a4	44 8b 4c 24 40	 mov	 r9d, DWORD PTR rc$[rsp]
  003a9	4c 8b 44 24 60	 mov	 r8, QWORD PTR lpParameters$2[rsp]
  003ae	48 8b 54 24 70	 mov	 rdx, QWORD PTR lpFile$4[rsp]
  003b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159135
  003ba	e8 00 00 00 00	 call	 printf

; 146  :                     lpFile, lpParameters, rc, rc );
; 147  :                 return -1;

  003bf	b8 ff ff ff ff	 mov	 eax, -1
  003c4	e9 17 02 00 00	 jmp	 $LN1@main
$LN8@main:

; 148  :         }
; 149  : 
; 150  :         printf( PGMNAME": ShellExecute(\"%s\", \"%s\",...) failed: %s.\n",

  003c9	4c 8b 4c 24 48	 mov	 r9, QWORD PTR pszErrMsg$1[rsp]
  003ce	4c 8b 44 24 60	 mov	 r8, QWORD PTR lpParameters$2[rsp]
  003d3	48 8b 54 24 70	 mov	 rdx, QWORD PTR lpFile$4[rsp]
  003d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159136
  003df	e8 00 00 00 00	 call	 printf

; 151  :             lpFile, lpParameters, pszErrMsg );
; 152  : 
; 153  :         return -1;

  003e4	b8 ff ff ff ff	 mov	 eax, -1
  003e9	e9 f2 01 00 00	 jmp	 $LN1@main
$LN16@main:

; 154  :     }
; 155  : #endif // _MSVC_
; 156  : 
; 157  :     ////////////////////////////////////////////////////////
; 158  :     // Command line program using stdio; use 'system()'...
; 159  :     ////////////////////////////////////////////////////////
; 160  : 
; 161  :     // Re-build a complete command line from passed args...
; 162  : 
; 163  :     for (i=1, k=0; i < argc; i++)

  003ee	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  003f6	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR k$[rsp], 0
  003ff	eb 0a		 jmp	 SHORT $LN12@main
$LN10@main:
  00401	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00405	ff c0		 inc	 eax
  00407	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN12@main:
  0040b	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00412	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00416	7d 55		 jge	 SHORT $LN11@main

; 164  :     {
; 165  :         k += strlen(argv[i]) + 1;

  00418	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0041d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00425	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00429	e8 00 00 00 00	 call	 strlen
  0042e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR k$[rsp]
  00433	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  00438	48 89 44 24 50	 mov	 QWORD PTR k$[rsp], rax

; 166  :         if (strchr(argv[i],' ')) k += 2;

  0043d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00442	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00447	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0044f	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00453	e8 00 00 00 00	 call	 strchr
  00458	48 85 c0	 test	 rax, rax
  0045b	74 0e		 je	 SHORT $LN40@main
  0045d	48 8b 44 24 50	 mov	 rax, QWORD PTR k$[rsp]
  00462	48 83 c0 02	 add	 rax, 2
  00466	48 89 44 24 50	 mov	 QWORD PTR k$[rsp], rax
$LN40@main:

; 167  :     }

  0046b	eb 94		 jmp	 SHORT $LN10@main
$LN11@main:

; 168  : 
; 169  :     if (!k)

  0046d	48 83 7c 24 50
	00		 cmp	 QWORD PTR k$[rsp], 0
  00473	75 2f		 jne	 SHORT $LN41@main

; 170  :     {
; 171  :         errno = EINVAL;

  00475	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0047b	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 172  :         perror( PGMNAME );

  00481	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159139
  00488	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_perror

; 173  :         printf( PGMNAME": Usage: command [args]\n");

  0048e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159140
  00495	e8 00 00 00 00	 call	 printf

; 174  :         return -1;

  0049a	b8 ff ff ff ff	 mov	 eax, -1
  0049f	e9 3c 01 00 00	 jmp	 $LN1@main
$LN41@main:

; 175  :     }
; 176  : 
; 177  :     // (allocate room for command line)
; 178  : 
; 179  :     if (!(p = malloc(sizeof(char)*k)))

  004a4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR k$[rsp]
  004a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  004af	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
  004b4	48 83 7c 24 38
	00		 cmp	 QWORD PTR p$[rsp], 0
  004ba	75 23		 jne	 SHORT $LN42@main

; 180  :     {
; 181  :         errno = ENOMEM;

  004bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  004c2	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12

; 182  :         perror( PGMNAME );

  004c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159142
  004cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_perror

; 183  :         return -1;

  004d5	b8 ff ff ff ff	 mov	 eax, -1
  004da	e9 01 01 00 00	 jmp	 $LN1@main
$LN42@main:

; 184  :     }
; 185  :     *p = 0;

  004df	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  004e4	c6 00 00	 mov	 BYTE PTR [rax], 0

; 186  : 
; 187  :     // (rebuild command-line from args)
; 188  : 
; 189  :     for (i=1; i < argc; ++i)

  004e7	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  004ef	eb 0a		 jmp	 SHORT $LN15@main
$LN13@main:
  004f1	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004f5	ff c0		 inc	 eax
  004f7	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN15@main:
  004fb	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00502	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00506	0f 8d a2 00 00
	00		 jge	 $LN14@main

; 190  :     {
; 191  :         if (strchr(argv[i],' ')) strcat(p,"\"");

  0050c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00511	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00516	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0051e	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00522	e8 00 00 00 00	 call	 strchr
  00527	48 85 c0	 test	 rax, rax
  0052a	74 11		 je	 SHORT $LN43@main
  0052c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159144
  00533	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00538	e8 00 00 00 00	 call	 strcat
$LN43@main:

; 192  :         strcat(p,argv[i]);

  0053d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00542	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0054a	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0054e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00553	e8 00 00 00 00	 call	 strcat

; 193  :         if (strchr(argv[i],' ')) strcat(p,"\"");

  00558	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0055d	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00562	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0056a	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0056e	e8 00 00 00 00	 call	 strchr
  00573	48 85 c0	 test	 rax, rax
  00576	74 11		 je	 SHORT $LN44@main
  00578	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159146
  0057f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00584	e8 00 00 00 00	 call	 strcat
$LN44@main:

; 194  :         if (i != (argc-1)) strcat(p," ");

  00589	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00590	ff c8		 dec	 eax
  00592	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00596	74 11		 je	 SHORT $LN45@main
  00598	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159148
  0059f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  005a4	e8 00 00 00 00	 call	 strcat
$LN45@main:

; 195  :     }

  005a9	e9 43 ff ff ff	 jmp	 $LN13@main
$LN14@main:

; 196  : 
; 197  :     // Ask system() to process command line...
; 198  : 
; 199  :     // NOTE: the below call WILL NOT RETURN
; 200  :     // until the program being called exits!
; 201  : 
; 202  :     rc = system(p);

  005ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  005b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_system
  005b9	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 203  : 
; 204  :     free(p);

  005bd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  005c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 205  : 
; 206  :     // --------------------------------------------------------
; 207  :     // PROGRAMMING NOTE: only rc == -1 need be reported since,
; 208  :     // if the command interpreter called a batch/cmd file for
; 209  :     // example, it could have set its own custom return code.
; 210  :     //
; 211  :     // Only -1 means the system() call itself failed, which
; 212  :     // is the only thing that actually needs to be reported.
; 213  :     // --------------------------------------------------------
; 214  : 
; 215  :     if ( -1 == rc )

  005c8	83 7c 24 40 ff	 cmp	 DWORD PTR rc$[rsp], -1
  005cd	75 0d		 jne	 SHORT $LN46@main

; 216  :         perror( PGMNAME );

  005cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159150
  005d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_perror
$LN46@main:

; 217  : 
; 218  :     return rc;

  005dc	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@main:

; 219  : }

  005e0	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  005e7	c3		 ret	 0
$LN49@main:
  005e8	00 00 00 00	 DD	 $LN26@main
  005ec	00 00 00 00	 DD	 $LN27@main
  005f0	00 00 00 00	 DD	 $LN28@main
  005f4	00 00 00 00	 DD	 $LN29@main
  005f8	00 00 00 00	 DD	 $LN31@main
  005fc	00 00 00 00	 DD	 $LN30@main
  00600	00 00 00 00	 DD	 $LN33@main
  00604	00 00 00 00	 DD	 $LN34@main
  00608	00 00 00 00	 DD	 $LN35@main
  0060c	00 00 00 00	 DD	 $LN36@main
  00610	00 00 00 00	 DD	 $LN37@main
  00614	00 00 00 00	 DD	 $LN38@main
  00618	00 00 00 00	 DD	 $LN32@main
  0061c	00 00 00 00	 DD	 $LN39@main
$LN48@main:
  00620	00		 DB	 0
  00621	0d		 DB	 13
  00622	01		 DB	 1
  00623	02		 DB	 2
  00624	0d		 DB	 13
  00625	03		 DB	 3
  00626	0d		 DB	 13
  00627	0d		 DB	 13
  00628	04		 DB	 4
  00629	0d		 DB	 13
  0062a	0d		 DB	 13
  0062b	05		 DB	 5
  0062c	0d		 DB	 13
  0062d	0d		 DB	 13
  0062e	0d		 DB	 13
  0062f	0d		 DB	 13
  00630	0d		 DB	 13
  00631	0d		 DB	 13
  00632	0d		 DB	 13
  00633	0d		 DB	 13
  00634	0d		 DB	 13
  00635	0d		 DB	 13
  00636	0d		 DB	 13
  00637	0d		 DB	 13
  00638	0d		 DB	 13
  00639	0d		 DB	 13
  0063a	06		 DB	 6
  0063b	07		 DB	 7
  0063c	08		 DB	 8
  0063d	09		 DB	 9
  0063e	0a		 DB	 10
  0063f	0b		 DB	 11
  00640	0c		 DB	 12
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 _vfprintf_l
  00042	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  00046	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
