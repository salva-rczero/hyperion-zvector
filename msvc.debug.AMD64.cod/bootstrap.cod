; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG159935 DB	'{98C1C303-2A9E-11d4-9FF5-0060677l8D04}', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	main
EXTRN	__imp__wcsicmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_CreateFileW:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_SetUnhandledExceptionFilter:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_SetErrorMode:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	__imp_GetCurrentProcess:PROC
EXTRN	__imp_GetCurrentProcessId:PROC
EXTRN	__imp_GetCurrentThreadId:PROC
EXTRN	__imp_GetModuleFileNameW:PROC
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_LoadLibraryA:PROC
EXTRN	__imp_IsWindowVisible:PROC
EXTRN	__imp_GetSystemMenu:PROC
EXTRN	__imp_EnableMenuItem:PROC
EXTRN	__imp_GetDesktopWindow:PROC
EXTRN	__imp_FindWindowA:PROC
EXTRN	__imp_SetConsoleMode:PROC
EXTRN	__imp_FillConsoleOutputCharacterA:PROC
EXTRN	__imp_FillConsoleOutputAttribute:PROC
EXTRN	__imp_GetConsoleScreenBufferInfo:PROC
EXTRN	__imp_SetConsoleCursorPosition:PROC
EXTRN	__imp_SetConsoleTextAttribute:PROC
EXTRN	__imp_GetConsoleTitleA:PROC
EXTRN	__imp_SetConsoleTitleA:PROC
EXTRN	__imp_timeBeginPeriod:PROC
EXTRN	__imp_timeEndPeriod:PROC
EXTRN	__imp__wmakepath:PROC
EXTRN	__imp__wsplitpath:PROC
EXTRN	__imp_isatty:PROC
EXTRN	__imp__CrtDbgReportW:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_hthread_set_thread_name:PROC
EXTRN	__imp_are_elevated:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_set_thread_name:PROC
EXTRN	__imp_DisableInvalidParameterHandling:PROC
EXTRN	__imp_log_read:PROC
EXTRN	__imp_log_line:PROC
EXTRN	__imp_impl:PROC
EXTRN	MessageBoxTimeoutA:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_cckdblk:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
g_pfnMiniDumpWriteDumpFunc DQ 01H DUP (?)
g_hDbgHelpDll DQ 01H DUP (?)
g_wszHercDrive DW 0cH DUP (?)
g_wszHercDir DW	0400H DUP (?)
g_wszFileDir DW	0400H DUP (?)
g_wszHercPath DW 0410H DUP (?)
g_wszDumpPath DW 0410H DUP (?)
g_wszFileName DW 0400H DUP (?)
g_szSaveTitle DB 0200H DUP (?)
g_itracen DD	01H DUP (?)
?bDidThis@?1??HerculesUnhandledExceptionFilter@@9@9 DD 01H DUP (?) ; `HerculesUnhandledExceptionFilter'::`2'::bDidThis
UserStreamArray DB 04000H DUP (?)
?buf@?8??BuildUserStreams@@9@9 DB 040H DUP (?)		; `BuildUserStreams'::`9'::buf
$SG160142 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$printf
pdata	ENDS
pdata	SEGMENT
$pdata$HerculesUnhandledExceptionFilter DD imagerel HerculesUnhandledExceptionFilter
	DD	imagerel HerculesUnhandledExceptionFilter+815
	DD	imagerel $unwind$HerculesUnhandledExceptionFilter
$pdata$ProcessException DD imagerel ProcessException
	DD	imagerel ProcessException+276
	DD	imagerel $unwind$ProcessException
$pdata$CreateMiniDump DD imagerel CreateMiniDump
	DD	imagerel CreateMiniDump+466
	DD	imagerel $unwind$CreateMiniDump
$pdata$BuildUserStreams DD imagerel BuildUserStreams
	DD	imagerel BuildUserStreams+1478
	DD	imagerel $unwind$BuildUserStreams
$pdata$IsDataSectionNeeded DD imagerel IsDataSectionNeeded
	DD	imagerel IsDataSectionNeeded+195
	DD	imagerel $unwind$IsDataSectionNeeded
$pdata$MyMiniDumpCallback DD imagerel MyMiniDumpCallback
	DD	imagerel MyMiniDumpCallback+215
	DD	imagerel $unwind$MyMiniDumpCallback
$pdata$FindConsoleHandle DD imagerel FindConsoleHandle
	DD	imagerel FindConsoleHandle+105
	DD	imagerel $unwind$FindConsoleHandle
$pdata$main DD	imagerel $LN11
	DD	imagerel $LN11+452
	DD	imagerel $unwind$main
$pdata$MsgBox DD imagerel MsgBox
	DD	imagerel MsgBox+72
	DD	imagerel $unwind$MsgBox
$pdata$StreamBufferSize DD imagerel StreamBufferSize
	DD	imagerel StreamBufferSize+47
	DD	imagerel $unwind$StreamBufferSize
pdata	ENDS
_DATA	SEGMENT
	ORG $+1
g_pszTempTitle DQ FLAT:$SG159935
$SG159987 DB	'bootstrap', 00H
	ORG $+2
$SG160012 DB	0aH, 0aH, 00H
	ORG $+1
$SG159988 DB	'bootstrap', 00H
	ORG $+2
$SG160016 DB	0aH, 00H
	ORG $+2
$SG159992 DB	'DbgHelp.dll', 00H
$SG160018 DB	0aH, 00H
	ORG $+2
$SG159993 DB	'MiniDumpWriteDump', 00H
	ORG $+2
$SG160020 DB	0aH, 00H
	ORG $+2
$SG160011 DB	']!OOPS!', 0aH, 00H
	ORG $+3
$SG160140 DB	'I', 00H
	ORG $+2
$SG160013 DB	'                      ***************', 0aH, 00H
	ORG $+1
$SG160014 DB	'                      *    OOPS!    *', 0aH, 00H
	ORG $+1
$SG160015 DB	'                      ***************', 0aH, 00H
	ORG $+1
$SG160017 DB	'                    Hercules has crashed!', 0aH, 00H
	ORG $+5
$SG160019 DB	'(you may or may not need to press ENTER if no ''oops!'' '
	DB	'dialog-box appears)', 0aH, 00H
	ORG $+1
$SG160141 DB	'W', 00H
	ORG $+2
$SG160051 DB	'OOPS!  Hercules has crashed!', 00H
	ORG $+3
$SG160052 DB	'The creation of a crash dump for analysis by the Hercule'
	DB	's development team is NOT possible', 0aH, 'because the requir'
	DB	'ed ''DbgHelp.dll'' is missing or is not installed or was othe'
	DB	'rwise not located.', 00H
	ORG $+5
$SG160055 DB	'OOPS!  Hercules has crashed!', 00H
	ORG $+3
$SG160056 DB	'The creation of a crash dump for further analysis by the'
	DB	' Hercules development team is strongly suggested.', 0aH, 0aH, 'W'
	DB	'ould you like to create a crash dump for the Hercules develop'
	DB	'ment team to analyze?', 00H
	ORG $+1
$SG160058 DB	'Dump Complete', 00H
	ORG $+2
$SG160059 DB	'Please send the dump to the Hercules development team fo'
	DB	'r analysis.', 00H
	ORG $+4
$SG160075 DB	'.', 00H, 'd', 00H, 'm', 00H, 'p', 00H, 00H, 00H
	ORG $+6
$SG160076 DB	'H', 00H, 'e', 00H, 'r', 00H, 'c', 00H, 'u', 00H, 'l', 00H
	DB	'e', 00H, 's', 00H, 00H, 00H
	ORG $+6
$SG160077 DB	'Creating crash dump "%ls"...', 0aH, 0aH, 00H
	ORG $+1
$SG160078 DB	'Please wait; this may take a few minutes...', 0aH, 0aH, 00H
	ORG $+2
$SG160079 DB	'(another message will appear when the dump is complete)', 0aH
	DB	0aH, 00H
	ORG $+6
$SG160084 DB	0aH, 'Dump "%ls" created.', 0aH, 0aH, 'Please forward the'
	DB	' dump to the Hercules team for analysis.', 0aH, 0aH, 00H
	ORG $+5
$SG160085 DB	0aH, 'MiniDumpWriteDump failed! Error: %u', 0aH, 0aH, 00H
	ORG $+1
$SG160086 DB	0aH, 'CreateFile failed! Error: %u', 0aH, 0aH, 00H
$SG160136 DB	'p', 00H, 'M', 00H, 'D', 00H, 'U', 00H, 'S', 00H, 'I', 00H
	DB	00H, 00H
	ORG $+2
$SG160137 DB	'%', 00H, 'l', 00H, 's', 00H, 00H, 00H
$SG160138 DB	'b', 00H, 'o', 00H, 'o', 00H, 't', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'a', 00H, 'p', 00H, '.', 00H, 'c', 00H, 00H, 00H
$SG160143 DB	'NOT ', 00H
	ORG $+3
$SG160144 DB	'HHC00018%s Hercules is %srunning in elevated mode', 00H
	ORG $+6
$SG160178 DB	'p', 00H, 'w', 00H, 's', 00H, 'z', 00H, 'M', 00H, 'o', 00H
	DB	'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H, 'N', 00H, 'a', 00H, 'm'
	DB	00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG160179 DB	'%', 00H, 'l', 00H, 's', 00H, 00H, 00H
$SG160180 DB	'b', 00H, 'o', 00H, 'o', 00H, 't', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'a', 00H, 'p', 00H, '.', 00H, 'c', 00H, 00H, 00H
$SG160183 DB	'n', 00H, 't', 00H, 'd', 00H, 'l', 00H, 'l', 00H, 00H, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:HerculesUnhandledExceptionFilter
	DD	013H
	DD	031dH
voltbl	ENDS
xdata	SEGMENT
$unwind$HerculesUnhandledExceptionFilter DD 011819H
	DD	0e209H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$ProcessException DD 010901H
	DD	08209H
$unwind$CreateMiniDump DD 020c01H
	DD	013010cH
$unwind$BuildUserStreams DD 020c01H
	DD	013010cH
$unwind$IsDataSectionNeeded DD 010901H
	DD	08209H
$unwind$MyMiniDumpCallback DD 011301H
	DD	06213H
$unwind$FindConsoleHandle DD 010401H
	DD	06204H
$unwind$main DD	010d01H
	DD	0820dH
$unwind$MsgBox DD 011801H
	DD	06218H
$unwind$StreamBufferSize DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\bootstrap.c
_TEXT	SEGMENT
tv65 = 0
len$ = 32
StreamBufferSize PROC

; 649  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 650  :     return (ULONG) (len < MAX_STREAM_BUFFERSIZE ? len : MAX_STREAM_BUFFERSIZE);

  00009	48 81 7c 24 20
	00 01 00 00	 cmp	 QWORD PTR len$[rsp], 256 ; 00000100H
  00012	73 0b		 jae	 SHORT $LN3@StreamBuff
  00014	48 8b 44 24 20	 mov	 rax, QWORD PTR len$[rsp]
  00019	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
  0001d	eb 08		 jmp	 SHORT $LN4@StreamBuff
$LN3@StreamBuff:
  0001f	48 c7 04 24 00
	01 00 00	 mov	 QWORD PTR tv65[rsp], 256 ; 00000100H
$LN4@StreamBuff:
  00027	8b 04 24	 mov	 eax, DWORD PTR tv65[rsp]

; 651  : }

  0002a	48 83 c4 18	 add	 rsp, 24
  0002e	c3		 ret	 0
StreamBufferSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\bootstrap.c
_TEXT	SEGMENT
hWnd$ = 64
pszText$ = 72
pszCaption$ = 80
uType$ = 88
wLanguageId$ = 96
dwMilliseconds$ = 104
MsgBox	PROC

; 481  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 482  :     return MESSAGEBOX( hWnd, pszText, pszCaption, uType

  00018	8b 44 24 68	 mov	 eax, DWORD PTR dwMilliseconds$[rsp]
  0001c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00020	0f b7 44 24 60	 movzx	 eax, WORD PTR wLanguageId$[rsp]
  00025	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  0002a	44 8b 4c 24 58	 mov	 r9d, DWORD PTR uType$[rsp]
  0002f	4c 8b 44 24 50	 mov	 r8, QWORD PTR pszCaption$[rsp]
  00034	48 8b 54 24 48	 mov	 rdx, QWORD PTR pszText$[rsp]
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR hWnd$[rsp]
  0003e	e8 00 00 00 00	 call	 MessageBoxTimeoutA

; 483  : #ifdef USE_MSGBOX_TIMEOUT
; 484  :         , wLanguageId
; 485  :         , dwMilliseconds
; 486  : #endif
; 487  :     );
; 488  : }

  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	c3		 ret	 0
MsgBox	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\bootstrap.c
_TEXT	SEGMENT
rc$ = 48
ac$ = 80
av$ = 88
main	PROC

; 267  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 268  :     int rc = 0;

  0000d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN4@main:

; 269  : 
; 270  :     SET_THREAD_NAME( BOOTSTRAP_NAME );

  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159987
  00022	8b c8		 mov	 ecx, eax
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_set_thread_name
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159988
  00037	8b c8		 mov	 ecx, eax
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_name
  0003f	33 c0		 xor	 eax, eax
  00041	85 c0		 test	 eax, eax
  00043	75 d0		 jne	 SHORT $LN4@main

; 271  : 
; 272  :     // Disable default invalid crt parameter handling
; 273  : 
; 274  :     DISABLE_CRT_INVALID_PARAMETER_HANDLER();

  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DisableInvalidParameterHandling

; 275  : 
; 276  :     // Request the highest possible time-interval accuracy...
; 277  : 
; 278  :     timeBeginPeriod( 1 );   // (one millisecond time interval accuracy)

  0004b	b9 01 00 00 00	 mov	 ecx, 1
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timeBeginPeriod

; 279  : 
; 280  :     // If we're being debugged, then let the debugger
; 281  :     // catch the exception. Otherwise, let our exception
; 282  :     // handler catch it...
; 283  : 
; 284  :     if (!IsDebuggerPresent())

  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0005c	85 c0		 test	 eax, eax
  0005e	0f 85 e8 00 00
	00		 jne	 $LN5@main

; 285  :     {
; 286  :         // Normal panel mode?
; 287  : 
; 288  :         if (!sysblk.daemon_mode && isatty( STDERR_FILENO ))

  00064	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00071	c1 e8 02	 shr	 eax, 2
  00074	83 e0 01	 and	 eax, 1
  00077	85 c0		 test	 eax, eax
  00079	75 33		 jne	 SHORT $LN6@main
  0007b	b9 02 00 00 00	 mov	 ecx, 2
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  00086	85 c0		 test	 eax, eax
  00088	74 24		 je	 SHORT $LN6@main

; 289  :         {
; 290  :             // Then disable the [x] Close button for safety
; 291  : 
; 292  :             EnableMenuItem( GetSystemMenu( FindConsoleHandle(), FALSE ),

  0008a	e8 00 00 00 00	 call	 FindConsoleHandle
  0008f	33 d2		 xor	 edx, edx
  00091	48 8b c8	 mov	 rcx, rax
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemMenu
  0009a	41 b8 01 00 00
	00		 mov	 r8d, 1
  000a0	ba 60 f0 00 00	 mov	 edx, 61536		; 0000f060H
  000a5	48 8b c8	 mov	 rcx, rax
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnableMenuItem
$LN6@main:

; 293  :                             SC_CLOSE, MF_BYCOMMAND | MF_GRAYED );
; 294  :         }
; 295  : 
; 296  :         // Load the debugging helper library...
; 297  : 
; 298  :         if (1
; 299  :             && (g_hDbgHelpDll = LoadLibrary(_T("DbgHelp.dll")))
; 300  :             && (g_pfnMiniDumpWriteDumpFunc = (MINIDUMPWRITEDUMPFUNC*)

  000ae	33 c0		 xor	 eax, eax
  000b0	83 f8 01	 cmp	 eax, 1
  000b3	74 7f		 je	 SHORT $LN7@main
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159992
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  000c2	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_hDbgHelpDll, rax
  000c9	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_hDbgHelpDll, 0
  000d1	74 61		 je	 SHORT $LN7@main
  000d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159993
  000da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_hDbgHelpDll
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  000e7	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_pfnMiniDumpWriteDumpFunc, rax
  000ee	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_pfnMiniDumpWriteDumpFunc, 0
  000f6	74 3c		 je	 SHORT $LN7@main

; 301  :                 GetProcAddress( g_hDbgHelpDll, _T("MiniDumpWriteDump")))
; 302  :         )
; 303  :         {
; 304  :             GetModuleFileNameW( NULL, g_wszHercPath, _countof( g_wszHercPath ) );

  000f8	41 b8 10 04 00
	00		 mov	 r8d, 1040		; 00000410H
  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:g_wszHercPath
  00105	33 c9		 xor	 ecx, ecx
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleFileNameW

; 305  :             _wsplitpath( g_wszHercPath, g_wszHercDrive, g_wszHercDir, NULL, NULL );

  0010d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00116	45 33 c9	 xor	 r9d, r9d
  00119	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:g_wszHercDir
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:g_wszHercDrive
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_wszHercPath
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wsplitpath
$LN7@main:

; 306  :         }
; 307  : 
; 308  :         // Enable exception handling...
; 309  : 
; 310  :         SetUnhandledExceptionFilter( HerculesUnhandledExceptionFilter );

  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:HerculesUnhandledExceptionFilter
  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetUnhandledExceptionFilter

; 311  :         SetErrorMode( SEM_NOGPFAULTERRORBOX );

  00141	b9 02 00 00 00	 mov	 ecx, 2
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetErrorMode
$LN5@main:

; 312  :     }
; 313  : 
; 314  :     rc = impl(ac,av);       // (Hercules, do your thing!)

  0014c	48 8b 54 24 58	 mov	 rdx, QWORD PTR av$[rsp]
  00151	8b 4c 24 50	 mov	 ecx, DWORD PTR ac$[rsp]
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_impl
  0015b	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax

; 315  : 
; 316  :     // Each call to "timeBeginPeriod" must be matched with a call to "timeEndPeriod"
; 317  : 
; 318  :     timeEndPeriod( 1 );     // (no longer care about accurate time intervals)

  0015f	b9 01 00 00 00	 mov	 ecx, 1
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timeEndPeriod

; 319  : 
; 320  :     if (!IsDebuggerPresent())

  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00170	85 c0		 test	 eax, eax
  00172	75 47		 jne	 SHORT $LN8@main

; 321  :     {
; 322  :         // Normal panel mode?
; 323  : 
; 324  :         if (!sysblk.daemon_mode && isatty( STDERR_FILENO ))

  00174	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0017b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00181	c1 e8 02	 shr	 eax, 2
  00184	83 e0 01	 and	 eax, 1
  00187	85 c0		 test	 eax, eax
  00189	75 30		 jne	 SHORT $LN9@main
  0018b	b9 02 00 00 00	 mov	 ecx, 2
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isatty
  00196	85 c0		 test	 eax, eax
  00198	74 21		 je	 SHORT $LN9@main

; 325  :         {
; 326  :             // Re-enable the [x] Close button
; 327  : 
; 328  :             EnableMenuItem( GetSystemMenu( FindConsoleHandle(), FALSE ),

  0019a	e8 00 00 00 00	 call	 FindConsoleHandle
  0019f	33 d2		 xor	 edx, edx
  001a1	48 8b c8	 mov	 rcx, rax
  001a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemMenu
  001aa	45 33 c0	 xor	 r8d, r8d
  001ad	ba 60 f0 00 00	 mov	 edx, 61536		; 0000f060H
  001b2	48 8b c8	 mov	 rcx, rax
  001b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnableMenuItem
$LN9@main:
$LN8@main:

; 329  :                         SC_CLOSE, MF_BYCOMMAND | MF_ENABLED );
; 330  :         }
; 331  :     }
; 332  : 
; 333  :     return rc;

  001bb	8b 44 24 30	 mov	 eax, DWORD PTR rc$[rsp]

; 334  : }

  001bf	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c3	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\bootstrap.c
_TEXT	SEGMENT
hWnd$ = 32
FindConsoleHandle PROC

; 455  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 456  :     HWND hWnd;
; 457  :     if (!GetConsoleTitle( g_szSaveTitle, _countof( g_szSaveTitle )))

  00004	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_szSaveTitle
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleTitleA
  00016	85 c0		 test	 eax, eax
  00018	75 04		 jne	 SHORT $LN2@FindConsol

; 458  :         return NULL;

  0001a	33 c0		 xor	 eax, eax
  0001c	eb 46		 jmp	 SHORT $LN1@FindConsol
$LN2@FindConsol:

; 459  :     if (!SetConsoleTitle( g_pszTempTitle ))

  0001e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_pszTempTitle
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTitleA
  0002b	85 c0		 test	 eax, eax
  0002d	75 04		 jne	 SHORT $LN3@FindConsol

; 460  :         return NULL;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 31		 jmp	 SHORT $LN1@FindConsol
$LN3@FindConsol:

; 461  :     Sleep(20);

  00033	b9 14 00 00 00	 mov	 ecx, 20
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 462  :     hWnd = FindWindow( NULL, g_pszTempTitle );

  0003e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR g_pszTempTitle
  00045	33 c9		 xor	 ecx, ecx
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindWindowA
  0004d	48 89 44 24 20	 mov	 QWORD PTR hWnd$[rsp], rax

; 463  :     SetConsoleTitle( g_szSaveTitle );

  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_szSaveTitle
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTitleA

; 464  :     return hWnd;

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR hWnd$[rsp]
$LN1@FindConsol:

; 465  : }

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
FindConsoleHandle ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\bootstrap.c
_TEXT	SEGMENT
bRet$ = 32
tv67 = 36
pParam$ = 64
pInput$ = 72
pOutput$ = 80
MyMiniDumpCallback PROC

; 768  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 769  :     BOOL bRet = FALSE;      // (default unless we decide otherwise)

  00013	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR bRet$[rsp], 0

; 770  : 
; 771  :     if ( !pInput || !pOutput )

  0001b	48 83 7c 24 48
	00		 cmp	 QWORD PTR pInput$[rsp], 0
  00021	74 08		 je	 SHORT $LN5@MyMiniDump
  00023	48 83 7c 24 50
	00		 cmp	 QWORD PTR pOutput$[rsp], 0
  00029	75 07		 jne	 SHORT $LN4@MyMiniDump
$LN5@MyMiniDump:

; 772  :         return FALSE;

  0002b	33 c0		 xor	 eax, eax
  0002d	e9 a0 00 00 00	 jmp	 $LN1@MyMiniDump
$LN4@MyMiniDump:

; 773  : 
; 774  :     switch ( pInput->CallbackType )

  00032	48 8b 44 24 48	 mov	 rax, QWORD PTR pInput$[rsp]
  00037	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0003a	89 44 24 24	 mov	 DWORD PTR tv67[rsp], eax
  0003e	83 7c 24 24 00	 cmp	 DWORD PTR tv67[rsp], 0
  00043	74 32		 je	 SHORT $LN8@MyMiniDump
  00045	83 7c 24 24 01	 cmp	 DWORD PTR tv67[rsp], 1
  0004a	74 66		 je	 SHORT $LN11@MyMiniDump
  0004c	83 7c 24 24 02	 cmp	 DWORD PTR tv67[rsp], 2
  00051	74 69		 je	 SHORT $LN12@MyMiniDump
  00053	83 7c 24 24 03	 cmp	 DWORD PTR tv67[rsp], 3
  00058	74 13		 je	 SHORT $LN7@MyMiniDump
  0005a	83 7c 24 24 04	 cmp	 DWORD PTR tv67[rsp], 4
  0005f	74 02		 je	 SHORT $LN6@MyMiniDump
  00061	eb 63		 jmp	 SHORT $LN13@MyMiniDump
$LN6@MyMiniDump:

; 775  :     {
; 776  :         case IncludeModuleCallback:
; 777  :         {
; 778  :             // Include the module into the dump
; 779  :             bRet = TRUE;

  00063	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR bRet$[rsp], 1

; 780  :         }
; 781  :         break;

  0006b	eb 61		 jmp	 SHORT $LN2@MyMiniDump
$LN7@MyMiniDump:

; 782  : 
; 783  :         case IncludeThreadCallback:
; 784  :         {
; 785  :             // Include the thread into the dump
; 786  :             bRet = TRUE;

  0006d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR bRet$[rsp], 1

; 787  :         }
; 788  :         break;

  00075	eb 57		 jmp	 SHORT $LN2@MyMiniDump
$LN8@MyMiniDump:

; 789  : 
; 790  :         case ModuleCallback:
; 791  :         {
; 792  :             // Are data sections available for this module ?
; 793  : 
; 794  :             if ( pOutput->ModuleWriteFlags & ModuleWriteDataSeg )

  00077	48 8b 44 24 50	 mov	 rax, QWORD PTR pOutput$[rsp]
  0007c	8b 00		 mov	 eax, DWORD PTR [rax]
  0007e	83 e0 02	 and	 eax, 2
  00081	85 c0		 test	 eax, eax
  00083	74 23		 je	 SHORT $LN9@MyMiniDump

; 795  :             {
; 796  :                 // Yes, but do we really need them?
; 797  : 
; 798  :                 if ( !IsDataSectionNeeded( pInput->Module.FullPath ) )

  00085	48 8b 44 24 48	 mov	 rax, QWORD PTR pInput$[rsp]
  0008a	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0008e	e8 00 00 00 00	 call	 IsDataSectionNeeded
  00093	85 c0		 test	 eax, eax
  00095	75 11		 jne	 SHORT $LN10@MyMiniDump

; 799  :                     pOutput->ModuleWriteFlags &= (~ModuleWriteDataSeg);

  00097	48 8b 44 24 50	 mov	 rax, QWORD PTR pOutput$[rsp]
  0009c	8b 00		 mov	 eax, DWORD PTR [rax]
  0009e	83 e0 fd	 and	 eax, -3			; fffffffdH
  000a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pOutput$[rsp]
  000a6	89 01		 mov	 DWORD PTR [rcx], eax
$LN10@MyMiniDump:
$LN9@MyMiniDump:

; 800  :             }
; 801  : 
; 802  :             bRet = TRUE;

  000a8	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR bRet$[rsp], 1

; 803  :         }
; 804  :         break;

  000b0	eb 1c		 jmp	 SHORT $LN2@MyMiniDump
$LN11@MyMiniDump:

; 805  : 
; 806  :         case ThreadCallback:
; 807  :         {
; 808  :             // Include all thread information into the minidump
; 809  :             bRet = TRUE;

  000b2	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR bRet$[rsp], 1

; 810  :         }
; 811  :         break;

  000ba	eb 12		 jmp	 SHORT $LN2@MyMiniDump
$LN12@MyMiniDump:

; 812  : 
; 813  :         case ThreadExCallback:
; 814  :         {
; 815  :             // Include this information
; 816  :             bRet = TRUE;

  000bc	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR bRet$[rsp], 1

; 817  :         }
; 818  :         break;

  000c4	eb 08		 jmp	 SHORT $LN2@MyMiniDump
$LN13@MyMiniDump:

; 819  : 
; 820  :         //-------------------------------------------------------------
; 821  :         //
; 822  :         //                  PROGRAMMING NOTE
; 823  :         //
; 824  :         // MemoryCallback is defined only for DbgHelp > 6.1.  Since we
; 825  :         // were returning FALSE for this callback anyway (which is our
; 826  :         // default), it was commented out altogether.
; 827  :         //
; 828  :         // This ensures our callback function will operate correctly
; 829  :         // even with future versions of DbgHelp DLL.
; 830  :         //
; 831  :         // -- Ivan
; 832  :         //
; 833  :         //-------------------------------------------------------------
; 834  : 
; 835  : //      case MemoryCallback:
; 836  : //      {
; 837  : //          // We do not include any information here -> return FALSE
; 838  : //          bRet = FALSE;
; 839  : //      }
; 840  : //      break;
; 841  : 
; 842  : 
; 843  :         // Following default block added by ISW 2005/05/06
; 844  : 
; 845  :         default:
; 846  :         {
; 847  :             // Do not return any information for
; 848  :             // any unrecognized callback types.
; 849  : 
; 850  :             bRet = FALSE;

  000c6	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR bRet$[rsp], 0
$LN2@MyMiniDump:

; 851  :         }
; 852  :         break;
; 853  :     }
; 854  : 
; 855  :     return bRet;

  000ce	8b 44 24 20	 mov	 eax, DWORD PTR bRet$[rsp]
$LN1@MyMiniDump:

; 856  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
MyMiniDumpCallback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\bootstrap.c
_TEXT	SEGMENT
bNeeded$ = 48
pwszModuleName$ = 80
IsDataSectionNeeded PROC

; 862  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 863  :     BOOL bNeeded = FALSE;

  00009	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR bNeeded$[rsp], 0

; 864  : 
; 865  :     _ASSERTE( pwszModuleName );

  00011	48 83 7c 24 50
	00		 cmp	 QWORD PTR pwszModuleName$[rsp], 0
  00017	75 3b		 jne	 SHORT $LN6@IsDataSect
  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160178
  00020	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00025	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160179
  0002c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00031	45 33 c9	 xor	 r9d, r9d
  00034	41 b8 61 03 00
	00		 mov	 r8d, 865		; 00000361H
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160180
  00041	b9 02 00 00 00	 mov	 ecx, 2
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReportW
  0004c	83 f8 01	 cmp	 eax, 1
  0004f	75 03		 jne	 SHORT $LN6@IsDataSect
  00051	cc		 int	 3
  00052	33 c0		 xor	 eax, eax
$LN6@IsDataSect:

; 866  : 
; 867  :     _wsplitpath( pwszModuleName, NULL, g_wszFileDir, g_wszFileName, NULL );

  00054	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0005d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:g_wszFileName
  00064	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:g_wszFileDir
  0006b	33 d2		 xor	 edx, edx
  0006d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pwszModuleName$[rsp]
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wsplitpath

; 868  : 
; 869  :     if ( _wcsicmp( g_wszFileName, L"ntdll" ) == 0 )

  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160183
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_wszFileName
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wcsicmp
  0008c	85 c0		 test	 eax, eax
  0008e	75 0a		 jne	 SHORT $LN2@IsDataSect

; 870  :     {
; 871  :         bNeeded = TRUE;

  00090	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR bNeeded$[rsp], 1

; 872  :     }

  00098	eb 20		 jmp	 SHORT $LN3@IsDataSect
$LN2@IsDataSect:

; 873  :     else if ( _wcsicmp( g_wszFileDir, g_wszHercDir ) == 0 )

  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:g_wszHercDir
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_wszFileDir
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wcsicmp
  000ae	85 c0		 test	 eax, eax
  000b0	75 08		 jne	 SHORT $LN4@IsDataSect

; 874  :     {
; 875  :         bNeeded = TRUE;

  000b2	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR bNeeded$[rsp], 1
$LN4@IsDataSect:
$LN3@IsDataSect:

; 876  :     }
; 877  : 
; 878  :     return bNeeded;

  000ba	8b 44 24 30	 mov	 eax, DWORD PTR bNeeded$[rsp]

; 879  : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
IsDataSectionNeeded ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\bootstrap.c
_TEXT	SEGMENT
StreamNum$ = 48
evelated$1 = 52
pstr$ = 56
i$2 = 64
p$3 = 72
tv212 = 80
k$4 = 84
logbuf_bytes$5 = 88
logbuf_idx$6 = 92
tv177 = 96
tv180 = 104
is_or_not$7 = 112
severity$8 = 120
logbuf_ptr$9 = 128
pMDUSI$ = 160
BuildUserStreams PROC

; 664  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 665  :     const char** pstr;
; 666  :     ULONG StreamNum = 0;

  0000c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR StreamNum$[rsp], 0

; 667  : 
; 668  :     _ASSERTE( pMDUSI );

  00014	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR pMDUSI$[rsp], 0
  0001d	75 3b		 jne	 SHORT $LN24@BuildUserS
  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160136
  00026	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160137
  00032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00037	45 33 c9	 xor	 r9d, r9d
  0003a	41 b8 9c 02 00
	00		 mov	 r8d, 668		; 0000029cH
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160138
  00047	b9 02 00 00 00	 mov	 ecx, 2
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReportW
  00052	83 f8 01	 cmp	 eax, 1
  00055	75 03		 jne	 SHORT $LN24@BuildUserS
  00057	cc		 int	 3
  00058	33 c0		 xor	 eax, eax
$LN24@BuildUserS:

; 669  : 
; 670  :     pMDUSI->UserStreamArray = UserStreamArray;

  0005a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pMDUSI$[rsp]
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UserStreamArray
  00069	48 89 48 04	 mov	 QWORD PTR [rax+4], rcx

; 671  : 
; 672  :     // Save version information
; 673  : 
; 674  :     BUILD_SYSBLK_USER_STREAM( sysblk.vers_info   );

  0006d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00074	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00078	48 89 44 24 38	 mov	 QWORD PTR pstr$[rsp], rax
  0007d	eb 18		 jmp	 SHORT $LN4@BuildUserS
$LN2@BuildUserS:
  0007f	48 8b 44 24 38	 mov	 rax, QWORD PTR pstr$[rsp]
  00084	48 83 c0 08	 add	 rax, 8
  00088	48 89 44 24 38	 mov	 QWORD PTR pstr$[rsp], rax
  0008d	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  00091	ff c0		 inc	 eax
  00093	89 44 24 30	 mov	 DWORD PTR StreamNum$[rsp], eax
$LN4@BuildUserS:
  00097	48 8b 44 24 38	 mov	 rax, QWORD PTR pstr$[rsp]
  0009c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000a0	74 6c		 je	 SHORT $LN3@BuildUserS
  000a2	81 7c 24 30 00
	04 00 00	 cmp	 DWORD PTR StreamNum$[rsp], 1024 ; 00000400H
  000aa	73 62		 jae	 SHORT $LN3@BuildUserS
  000ac	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  000b0	48 6b c0 10	 imul	 rax, rax, 16
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UserStreamArray
  000bb	c7 04 01 0a 00
	00 00		 mov	 DWORD PTR [rcx+rax], 10
  000c2	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  000c6	48 6b c0 10	 imul	 rax, rax, 16
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UserStreamArray
  000d1	48 8b 54 24 38	 mov	 rdx, QWORD PTR pstr$[rsp]
  000d6	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000d9	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx
  000de	48 8b 44 24 38	 mov	 rax, QWORD PTR pstr$[rsp]
  000e3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e6	e8 00 00 00 00	 call	 strlen
  000eb	48 ff c0	 inc	 rax
  000ee	48 8b c8	 mov	 rcx, rax
  000f1	e8 00 00 00 00	 call	 StreamBufferSize
  000f6	8b 4c 24 30	 mov	 ecx, DWORD PTR StreamNum$[rsp]
  000fa	48 6b c9 10	 imul	 rcx, rcx, 16
  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:UserStreamArray
  00105	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax
  00109	e9 71 ff ff ff	 jmp	 $LN2@BuildUserS
$LN3@BuildUserS:

; 675  :     BUILD_SYSBLK_USER_STREAM( sysblk.bld_opts    );

  0010e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00115	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00119	48 89 44 24 38	 mov	 QWORD PTR pstr$[rsp], rax
  0011e	eb 18		 jmp	 SHORT $LN7@BuildUserS
$LN5@BuildUserS:
  00120	48 8b 44 24 38	 mov	 rax, QWORD PTR pstr$[rsp]
  00125	48 83 c0 08	 add	 rax, 8
  00129	48 89 44 24 38	 mov	 QWORD PTR pstr$[rsp], rax
  0012e	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  00132	ff c0		 inc	 eax
  00134	89 44 24 30	 mov	 DWORD PTR StreamNum$[rsp], eax
$LN7@BuildUserS:
  00138	48 8b 44 24 38	 mov	 rax, QWORD PTR pstr$[rsp]
  0013d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00141	74 6c		 je	 SHORT $LN6@BuildUserS
  00143	81 7c 24 30 00
	04 00 00	 cmp	 DWORD PTR StreamNum$[rsp], 1024 ; 00000400H
  0014b	73 62		 jae	 SHORT $LN6@BuildUserS
  0014d	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  00151	48 6b c0 10	 imul	 rax, rax, 16
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UserStreamArray
  0015c	c7 04 01 0a 00
	00 00		 mov	 DWORD PTR [rcx+rax], 10
  00163	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  00167	48 6b c0 10	 imul	 rax, rax, 16
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UserStreamArray
  00172	48 8b 54 24 38	 mov	 rdx, QWORD PTR pstr$[rsp]
  00177	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0017a	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx
  0017f	48 8b 44 24 38	 mov	 rax, QWORD PTR pstr$[rsp]
  00184	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00187	e8 00 00 00 00	 call	 strlen
  0018c	48 ff c0	 inc	 rax
  0018f	48 8b c8	 mov	 rcx, rax
  00192	e8 00 00 00 00	 call	 StreamBufferSize
  00197	8b 4c 24 30	 mov	 ecx, DWORD PTR StreamNum$[rsp]
  0019b	48 6b c9 10	 imul	 rcx, rcx, 16
  0019f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:UserStreamArray
  001a6	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax
  001aa	e9 71 ff ff ff	 jmp	 $LN5@BuildUserS
$LN6@BuildUserS:

; 676  :     BUILD_SYSBLK_USER_STREAM( sysblk.extpkg_vers );

  001af	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b6	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001ba	48 89 44 24 38	 mov	 QWORD PTR pstr$[rsp], rax
  001bf	eb 18		 jmp	 SHORT $LN10@BuildUserS
$LN8@BuildUserS:
  001c1	48 8b 44 24 38	 mov	 rax, QWORD PTR pstr$[rsp]
  001c6	48 83 c0 08	 add	 rax, 8
  001ca	48 89 44 24 38	 mov	 QWORD PTR pstr$[rsp], rax
  001cf	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  001d3	ff c0		 inc	 eax
  001d5	89 44 24 30	 mov	 DWORD PTR StreamNum$[rsp], eax
$LN10@BuildUserS:
  001d9	48 8b 44 24 38	 mov	 rax, QWORD PTR pstr$[rsp]
  001de	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001e2	74 6c		 je	 SHORT $LN9@BuildUserS
  001e4	81 7c 24 30 00
	04 00 00	 cmp	 DWORD PTR StreamNum$[rsp], 1024 ; 00000400H
  001ec	73 62		 jae	 SHORT $LN9@BuildUserS
  001ee	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  001f2	48 6b c0 10	 imul	 rax, rax, 16
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UserStreamArray
  001fd	c7 04 01 0a 00
	00 00		 mov	 DWORD PTR [rcx+rax], 10
  00204	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  00208	48 6b c0 10	 imul	 rax, rax, 16
  0020c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UserStreamArray
  00213	48 8b 54 24 38	 mov	 rdx, QWORD PTR pstr$[rsp]
  00218	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0021b	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx
  00220	48 8b 44 24 38	 mov	 rax, QWORD PTR pstr$[rsp]
  00225	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00228	e8 00 00 00 00	 call	 strlen
  0022d	48 ff c0	 inc	 rax
  00230	48 8b c8	 mov	 rcx, rax
  00233	e8 00 00 00 00	 call	 StreamBufferSize
  00238	8b 4c 24 30	 mov	 ecx, DWORD PTR StreamNum$[rsp]
  0023c	48 6b c9 10	 imul	 rcx, rcx, 16
  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:UserStreamArray
  00247	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax
  0024b	e9 71 ff ff ff	 jmp	 $LN8@BuildUserS
$LN9@BuildUserS:

; 677  : 
; 678  :     // Save whether Hercules is running in "elevated" mode or not
; 679  : 
; 680  :     if (StreamNum < MAX_MINIDUMP_USER_STREAMS)

  00250	81 7c 24 30 00
	04 00 00	 cmp	 DWORD PTR StreamNum$[rsp], 1024 ; 00000400H
  00258	0f 83 08 01 00
	00		 jae	 $LN17@BuildUserS

; 681  :     {
; 682  :         static char   buf[64]    = {0};
; 683  :         const  char*  severity   = NULL;

  0025e	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR severity$8[rsp], 0

; 684  :         const  char*  is_or_not  = NULL;

  00267	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR is_or_not$7[rsp], 0

; 685  :         bool          evelated   = false;

  00270	c6 44 24 34 00	 mov	 BYTE PTR evelated$1[rsp], 0

; 686  : 
; 687  :         evelated  = are_elevated();

  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_are_elevated
  0027b	88 44 24 34	 mov	 BYTE PTR evelated$1[rsp], al

; 688  :         severity  = evelated ? "I" : "W";

  0027f	0f b6 44 24 34	 movzx	 eax, BYTE PTR evelated$1[rsp]
  00284	85 c0		 test	 eax, eax
  00286	74 0e		 je	 SHORT $LN25@BuildUserS
  00288	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160140
  0028f	48 89 44 24 60	 mov	 QWORD PTR tv177[rsp], rax
  00294	eb 0c		 jmp	 SHORT $LN26@BuildUserS
$LN25@BuildUserS:
  00296	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160141
  0029d	48 89 44 24 60	 mov	 QWORD PTR tv177[rsp], rax
$LN26@BuildUserS:
  002a2	48 8b 44 24 60	 mov	 rax, QWORD PTR tv177[rsp]
  002a7	48 89 44 24 78	 mov	 QWORD PTR severity$8[rsp], rax

; 689  :         is_or_not = evelated ? ""  : "NOT ";

  002ac	0f b6 44 24 34	 movzx	 eax, BYTE PTR evelated$1[rsp]
  002b1	85 c0		 test	 eax, eax
  002b3	74 0e		 je	 SHORT $LN27@BuildUserS
  002b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160142
  002bc	48 89 44 24 68	 mov	 QWORD PTR tv180[rsp], rax
  002c1	eb 0c		 jmp	 SHORT $LN28@BuildUserS
$LN27@BuildUserS:
  002c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160143
  002ca	48 89 44 24 68	 mov	 QWORD PTR tv180[rsp], rax
$LN28@BuildUserS:
  002cf	48 8b 44 24 68	 mov	 rax, QWORD PTR tv180[rsp]
  002d4	48 89 44 24 70	 mov	 QWORD PTR is_or_not$7[rsp], rax

; 690  : 
; 691  :         // "Hercules is %srunning in elevated mode"
; 692  :         MSGBUF( buf, MSG_C( HHC00018, severity, is_or_not ));

  002d9	48 8b 44 24 70	 mov	 rax, QWORD PTR is_or_not$7[rsp]
  002de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e3	4c 8b 4c 24 78	 mov	 r9, QWORD PTR severity$8[rsp]
  002e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160144
  002ef	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  002f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?buf@?8??BuildUserStreams@@9@9
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 693  : 
; 694  :         UserStreamArray[ StreamNum ].Type       = CommentStreamA;

  00301	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  00305	48 6b c0 10	 imul	 rax, rax, 16
  00309	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UserStreamArray
  00310	c7 04 01 0a 00
	00 00		 mov	 DWORD PTR [rcx+rax], 10

; 695  :         UserStreamArray[ StreamNum ].Buffer     = (PVOID)                      buf;

  00317	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  0031b	48 6b c0 10	 imul	 rax, rax, 16
  0031f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UserStreamArray
  00326	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?buf@?8??BuildUserStreams@@9@9
  0032d	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 696  :         UserStreamArray[ StreamNum ].BufferSize = StreamBufferSize( strlen( (const char*) buf ) + 1 );

  00332	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?buf@?8??BuildUserStreams@@9@9
  00339	e8 00 00 00 00	 call	 strlen
  0033e	48 ff c0	 inc	 rax
  00341	48 8b c8	 mov	 rcx, rax
  00344	e8 00 00 00 00	 call	 StreamBufferSize
  00349	8b 4c 24 30	 mov	 ecx, DWORD PTR StreamNum$[rsp]
  0034d	48 6b c9 10	 imul	 rcx, rcx, 16
  00351	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:UserStreamArray
  00358	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax

; 697  :         StreamNum++;

  0035c	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  00360	ff c0		 inc	 eax
  00362	89 44 24 30	 mov	 DWORD PTR StreamNum$[rsp], eax
$LN17@BuildUserS:

; 698  :     }
; 699  : 
; 700  :     // Save last few entries of CCKD internal trace table
; 701  : 
; 702  :     if (1
; 703  :         && StreamNum < MAX_MINIDUMP_USER_STREAMS
; 704  :         && g_itracen && cckdblk.itrace    // (do we have a table?)

  00366	33 c0		 xor	 eax, eax
  00368	83 f8 01	 cmp	 eax, 1
  0036b	0f 84 a2 01 00
	00		 je	 $LN18@BuildUserS
  00371	81 7c 24 30 00
	04 00 00	 cmp	 DWORD PTR StreamNum$[rsp], 1024 ; 00000400H
  00379	0f 83 94 01 00
	00		 jae	 $LN18@BuildUserS
  0037f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR g_itracen, 0
  00386	0f 84 87 01 00
	00		 je	 $LN18@BuildUserS
  0038c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_cckdblk
  00393	48 83 b8 f8 02
	00 00 00	 cmp	 QWORD PTR [rax+760], 0
  0039b	0f 84 72 01 00
	00		 je	 $LN18@BuildUserS

; 705  :     )
; 706  :     {
; 707  :         // itrace       ptr to beginning of table (first entry)
; 708  :         // itracep      ptr to "current" entry" (ptr to the entry that
; 709  :         //              should be used next, i.e. the "oldest" entry)
; 710  :         // itracex      ptr to end of table (i.e. points to the entry
; 711  :         //              just PAST the very last entry in the table)
; 712  :         // itracen      the number of entries there are in the table
; 713  :         // itracec      how many of those entries are actively in use
; 714  : 
; 715  :         int i, k = min( NUM_CCKD_TRACE_STRINGS, cckdblk.itracec );

  003a1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_cckdblk
  003a8	83 b8 14 03 00
	00 40		 cmp	 DWORD PTR [rax+788], 64	; 00000040H
  003af	7e 0a		 jle	 SHORT $LN29@BuildUserS
  003b1	c7 44 24 50 40
	00 00 00	 mov	 DWORD PTR tv212[rsp], 64 ; 00000040H
  003b9	eb 11		 jmp	 SHORT $LN30@BuildUserS
$LN29@BuildUserS:
  003bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_cckdblk
  003c2	8b 80 14 03 00
	00		 mov	 eax, DWORD PTR [rax+788]
  003c8	89 44 24 50	 mov	 DWORD PTR tv212[rsp], eax
$LN30@BuildUserS:
  003cc	8b 44 24 50	 mov	 eax, DWORD PTR tv212[rsp]
  003d0	89 44 24 54	 mov	 DWORD PTR k$4[rsp], eax

; 716  :         CCKD_ITRACE* p = cckdblk.itracep;

  003d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_cckdblk
  003db	48 8b 80 00 03
	00 00		 mov	 rax, QWORD PTR [rax+768]
  003e2	48 89 44 24 48	 mov	 QWORD PTR p$3[rsp], rax

; 717  : 
; 718  :         // Backup 'k' entries...   (note pointer arithmetic)
; 719  : 
; 720  :         for (i=0; i < k; ++i)

  003e7	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  003ef	eb 0a		 jmp	 SHORT $LN13@BuildUserS
$LN11@BuildUserS:
  003f1	8b 44 24 40	 mov	 eax, DWORD PTR i$2[rsp]
  003f5	ff c0		 inc	 eax
  003f7	89 44 24 40	 mov	 DWORD PTR i$2[rsp], eax
$LN13@BuildUserS:
  003fb	8b 44 24 54	 mov	 eax, DWORD PTR k$4[rsp]
  003ff	39 44 24 40	 cmp	 DWORD PTR i$2[rsp], eax
  00403	7d 40		 jge	 SHORT $LN12@BuildUserS

; 721  :             if (--p < cckdblk.itrace)

  00405	48 8b 44 24 48	 mov	 rax, QWORD PTR p$3[rsp]
  0040a	48 2d 00 01 00
	00		 sub	 rax, 256		; 00000100H
  00410	48 89 44 24 48	 mov	 QWORD PTR p$3[rsp], rax
  00415	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_cckdblk
  0041c	48 8b 80 f8 02
	00 00		 mov	 rax, QWORD PTR [rax+760]
  00423	48 39 44 24 48	 cmp	 QWORD PTR p$3[rsp], rax
  00428	73 19		 jae	 SHORT $LN19@BuildUserS

; 722  :                 p = cckdblk.itracex - 1;

  0042a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_cckdblk
  00431	48 8b 80 08 03
	00 00		 mov	 rax, QWORD PTR [rax+776]
  00438	48 2d 00 01 00
	00		 sub	 rax, 256		; 00000100H
  0043e	48 89 44 24 48	 mov	 QWORD PTR p$3[rsp], rax
$LN19@BuildUserS:
  00443	eb ac		 jmp	 SHORT $LN11@BuildUserS
$LN12@BuildUserS:

; 723  : 
; 724  :         // Dump 'k' entries starting from there...
; 725  : 
; 726  :         for (i=0; i < k && StreamNum < MAX_MINIDUMP_USER_STREAMS; ++i, ++p, ++StreamNum)

  00445	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  0044d	eb 24		 jmp	 SHORT $LN16@BuildUserS
$LN14@BuildUserS:
  0044f	8b 44 24 40	 mov	 eax, DWORD PTR i$2[rsp]
  00453	ff c0		 inc	 eax
  00455	89 44 24 40	 mov	 DWORD PTR i$2[rsp], eax
  00459	48 8b 44 24 48	 mov	 rax, QWORD PTR p$3[rsp]
  0045e	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  00464	48 89 44 24 48	 mov	 QWORD PTR p$3[rsp], rax
  00469	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  0046d	ff c0		 inc	 eax
  0046f	89 44 24 30	 mov	 DWORD PTR StreamNum$[rsp], eax
$LN16@BuildUserS:
  00473	8b 44 24 54	 mov	 eax, DWORD PTR k$4[rsp]
  00477	39 44 24 40	 cmp	 DWORD PTR i$2[rsp], eax
  0047b	0f 8d 92 00 00
	00		 jge	 $LN15@BuildUserS
  00481	81 7c 24 30 00
	04 00 00	 cmp	 DWORD PTR StreamNum$[rsp], 1024 ; 00000400H
  00489	0f 83 84 00 00
	00		 jae	 $LN15@BuildUserS

; 727  :         {
; 728  :             if (p >= cckdblk.itracex)

  0048f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_cckdblk
  00496	48 8b 80 08 03
	00 00		 mov	 rax, QWORD PTR [rax+776]
  0049d	48 39 44 24 48	 cmp	 QWORD PTR p$3[rsp], rax
  004a2	72 13		 jb	 SHORT $LN20@BuildUserS

; 729  :                 p = cckdblk.itrace;

  004a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_cckdblk
  004ab	48 8b 80 f8 02
	00 00		 mov	 rax, QWORD PTR [rax+760]
  004b2	48 89 44 24 48	 mov	 QWORD PTR p$3[rsp], rax
$LN20@BuildUserS:

; 730  : 
; 731  :             UserStreamArray[ StreamNum ].Type       = CommentStreamA;

  004b7	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  004bb	48 6b c0 10	 imul	 rax, rax, 16
  004bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UserStreamArray
  004c6	c7 04 01 0a 00
	00 00		 mov	 DWORD PTR [rcx+rax], 10

; 732  :             UserStreamArray[ StreamNum ].Buffer     = (PVOID)                      p;

  004cd	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  004d1	48 6b c0 10	 imul	 rax, rax, 16
  004d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UserStreamArray
  004dc	48 8b 54 24 48	 mov	 rdx, QWORD PTR p$3[rsp]
  004e1	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 733  :             UserStreamArray[ StreamNum ].BufferSize = StreamBufferSize( strlen( (const char*) p ) + 1 );

  004e6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$3[rsp]
  004eb	e8 00 00 00 00	 call	 strlen
  004f0	48 ff c0	 inc	 rax
  004f3	48 8b c8	 mov	 rcx, rax
  004f6	e8 00 00 00 00	 call	 StreamBufferSize
  004fb	8b 4c 24 30	 mov	 ecx, DWORD PTR StreamNum$[rsp]
  004ff	48 6b c9 10	 imul	 rcx, rcx, 16
  00503	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:UserStreamArray
  0050a	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax

; 734  :         }

  0050e	e9 3c ff ff ff	 jmp	 $LN14@BuildUserS
$LN15@BuildUserS:
$LN18@BuildUserS:

; 735  :     }
; 736  : 
; 737  :     // Save last few log messages
; 738  : 
; 739  :     if (StreamNum < MAX_MINIDUMP_USER_STREAMS)

  00513	81 7c 24 30 00
	04 00 00	 cmp	 DWORD PTR StreamNum$[rsp], 1024 ; 00000400H
  0051b	0f 83 8f 00 00
	00		 jae	 $LN21@BuildUserS

; 740  :     {
; 741  :         char* logbuf_ptr;
; 742  :         int   logbuf_idx;
; 743  :         int   logbuf_bytes;
; 744  : 
; 745  :         logbuf_idx = log_line( NUM_LOGFILE_MESSAGES );

  00521	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00526	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_log_line
  0052c	89 44 24 5c	 mov	 DWORD PTR logbuf_idx$6[rsp], eax

; 746  : 
; 747  :         if ((logbuf_bytes = log_read( &logbuf_ptr, &logbuf_idx, LOG_NOBLOCK )) > 0)

  00530	45 33 c0	 xor	 r8d, r8d
  00533	48 8d 54 24 5c	 lea	 rdx, QWORD PTR logbuf_idx$6[rsp]
  00538	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR logbuf_ptr$9[rsp]
  00540	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_log_read
  00546	89 44 24 58	 mov	 DWORD PTR logbuf_bytes$5[rsp], eax
  0054a	83 7c 24 58 00	 cmp	 DWORD PTR logbuf_bytes$5[rsp], 0
  0054f	7e 5f		 jle	 SHORT $LN22@BuildUserS

; 748  :         {
; 749  :             UserStreamArray[ StreamNum ].Type       = CommentStreamA;

  00551	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  00555	48 6b c0 10	 imul	 rax, rax, 16
  00559	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UserStreamArray
  00560	c7 04 01 0a 00
	00 00		 mov	 DWORD PTR [rcx+rax], 10

; 750  :             UserStreamArray[ StreamNum ].Buffer     = (PVOID) logbuf_ptr;

  00567	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  0056b	48 6b c0 10	 imul	 rax, rax, 16
  0056f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UserStreamArray
  00576	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR logbuf_ptr$9[rsp]
  0057e	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 751  :             UserStreamArray[ StreamNum ].BufferSize = StreamBufferSize( logbuf_bytes - 1 );

  00583	8b 44 24 58	 mov	 eax, DWORD PTR logbuf_bytes$5[rsp]
  00587	ff c8		 dec	 eax
  00589	48 98		 cdqe
  0058b	48 8b c8	 mov	 rcx, rax
  0058e	e8 00 00 00 00	 call	 StreamBufferSize
  00593	8b 4c 24 30	 mov	 ecx, DWORD PTR StreamNum$[rsp]
  00597	48 6b c9 10	 imul	 rcx, rcx, 16
  0059b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:UserStreamArray
  005a2	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax

; 752  :             StreamNum++;

  005a6	8b 44 24 30	 mov	 eax, DWORD PTR StreamNum$[rsp]
  005aa	ff c0		 inc	 eax
  005ac	89 44 24 30	 mov	 DWORD PTR StreamNum$[rsp], eax
$LN22@BuildUserS:
$LN21@BuildUserS:

; 753  :         }
; 754  :     }
; 755  : 
; 756  :     pMDUSI->UserStreamCount = StreamNum;

  005b0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pMDUSI$[rsp]
  005b8	8b 4c 24 30	 mov	 ecx, DWORD PTR StreamNum$[rsp]
  005bc	89 08		 mov	 DWORD PTR [rax], ecx

; 757  : }

  005be	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  005c5	c3		 ret	 0
BuildUserStreams ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\bootstrap.c
_TEXT	SEGMENT
bSuccess$ = 64
mdt$1 = 68
tv93 = 72
hDumpFile$ = 80
tv89 = 88
mdusi$2 = 96
mdei$3 = 112
mci$4 = 128
pExceptionPtrs$ = 160
CreateMiniDump PROC

; 566  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 567  :     BOOL bSuccess = FALSE;

  0000c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR bSuccess$[rsp], 0

; 568  :     HANDLE hDumpFile;
; 569  : 
; 570  :     _wmakepath( g_wszDumpPath, g_wszHercDrive, g_wszHercDir, L"Hercules", L".dmp" );

  00014	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160075
  0001b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00020	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160076
  00027	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:g_wszHercDir
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:g_wszHercDrive
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_wszDumpPath
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__wmakepath

; 571  : 
; 572  :     _tprintf( _T("Creating crash dump \"%ls\"...\n\n"), g_wszDumpPath );

  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:g_wszDumpPath
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160077
  00050	e8 00 00 00 00	 call	 printf

; 573  :     _tprintf( _T("Please wait; this may take a few minutes...\n\n") );

  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160078
  0005c	e8 00 00 00 00	 call	 printf

; 574  :     _tprintf( _T("(another message will appear when the dump is complete)\n\n") );

  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160079
  00068	e8 00 00 00 00	 call	 printf

; 575  : 
; 576  :     hDumpFile = CreateFileW

  0006d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00076	c7 44 24 28 80
	00 00 00	 mov	 DWORD PTR [rsp+40], 128	; 00000080H
  0007e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00086	45 33 c9	 xor	 r9d, r9d
  00089	45 33 c0	 xor	 r8d, r8d
  0008c	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_wszDumpPath
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileW
  0009e	48 89 44 24 50	 mov	 QWORD PTR hDumpFile$[rsp], rax

; 577  :     (
; 578  :         g_wszDumpPath,
; 579  :         GENERIC_WRITE,
; 580  :         0, NULL, CREATE_ALWAYS,
; 581  :         FILE_ATTRIBUTE_NORMAL, NULL
; 582  :     );
; 583  : 
; 584  :     if ( hDumpFile && INVALID_HANDLE_VALUE != hDumpFile )

  000a3	48 83 7c 24 50
	00		 cmp	 QWORD PTR hDumpFile$[rsp], 0
  000a9	0f 84 03 01 00
	00		 je	 $LN2@CreateMini
  000af	48 83 7c 24 50
	ff		 cmp	 QWORD PTR hDumpFile$[rsp], -1
  000b5	0f 84 f7 00 00
	00		 je	 $LN2@CreateMini

; 585  :     {
; 586  :         // Create the minidump
; 587  : 
; 588  :         MINIDUMP_EXCEPTION_INFORMATION    mdei;
; 589  :         MINIDUMP_USER_STREAM_INFORMATION  mdusi;
; 590  :         MINIDUMP_CALLBACK_INFORMATION     mci;
; 591  :         MINIDUMP_TYPE                     mdt;
; 592  : 
; 593  :         BuildUserStreams( &mdusi );

  000bb	48 8d 4c 24 60	 lea	 rcx, QWORD PTR mdusi$2[rsp]
  000c0	e8 00 00 00 00	 call	 BuildUserStreams

; 594  : 
; 595  :         mdei.ThreadId           = GetCurrentThreadId();

  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  000cb	89 44 24 70	 mov	 DWORD PTR mdei$3[rsp], eax

; 596  :         mdei.ExceptionPointers  = pExceptionPtrs;

  000cf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pExceptionPtrs$[rsp]
  000d7	48 89 44 24 74	 mov	 QWORD PTR mdei$3[rsp+4], rax

; 597  :         mdei.ClientPointers     = FALSE;

  000dc	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR mdei$3[rsp+12], 0

; 598  : 
; 599  :         mci.CallbackRoutine     = (MINIDUMP_CALLBACK_ROUTINE) MyMiniDumpCallback;

  000e4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:MyMiniDumpCallback
  000eb	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR mci$4[rsp], rax

; 600  :         mci.CallbackParam       = 0;

  000f3	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR mci$4[rsp+8], 0

; 601  : 
; 602  :         // Ref: "EFFECTIVE MINIDUMPS"
; 603  :         //      http://www.debuginfo.com/articles/effminidumps.html
; 604  :         //      http://www.debuginfo.com/articles/effminidumps2.html
; 605  : 
; 606  :         mdt = (MINIDUMP_TYPE)

  000ff	c7 44 24 44 65
	02 00 00	 mov	 DWORD PTR mdt$1[rsp], 613 ; 00000265H

; 607  :         (0
; 608  :             | MiniDumpWithPrivateReadWriteMemory        // Needed to also dump heap
; 609  :             | MiniDumpWithIndirectlyReferencedMemory    // Dump portions of the heap
; 610  :                                                         // only if referenced in stack
; 611  :             | MiniDumpWithDataSegs                      // Include global variables
; 612  :             | MiniDumpWithHandleData                    // Dump all file handles too
; 613  :             | MiniDumpWithUnloadedModules               // Tell us about unloaded DLLs
; 614  :         );
; 615  : 
; 616  :         bSuccess = g_pfnMiniDumpWriteDumpFunc( GetCurrentProcess(), GetCurrentProcessId(),

  00107	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR pExceptionPtrs$[rsp], 0
  00110	74 0c		 je	 SHORT $LN7@CreateMini
  00112	48 8d 44 24 70	 lea	 rax, QWORD PTR mdei$3[rsp]
  00117	48 89 44 24 58	 mov	 QWORD PTR tv89[rsp], rax
  0011c	eb 09		 jmp	 SHORT $LN8@CreateMini
$LN7@CreateMini:
  0011e	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv89[rsp], 0
$LN8@CreateMini:
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcessId
  0012d	89 44 24 48	 mov	 DWORD PTR tv93[rsp], eax
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcess
  00137	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR mci$4[rsp]
  0013f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00144	48 8d 4c 24 60	 lea	 rcx, QWORD PTR mdusi$2[rsp]
  00149	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv89[rsp]
  00153	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00158	44 8b 4c 24 44	 mov	 r9d, DWORD PTR mdt$1[rsp]
  0015d	4c 8b 44 24 50	 mov	 r8, QWORD PTR hDumpFile$[rsp]
  00162	8b 4c 24 48	 mov	 ecx, DWORD PTR tv93[rsp]
  00166	8b d1		 mov	 edx, ecx
  00168	48 8b c8	 mov	 rcx, rax
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR g_pfnMiniDumpWriteDumpFunc
  00171	89 44 24 40	 mov	 DWORD PTR bSuccess$[rsp], eax

; 617  :             hDumpFile, mdt, (pExceptionPtrs != 0) ? &mdei : 0, &mdusi, &mci );
; 618  : 
; 619  :         CloseHandle( hDumpFile );

  00175	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hDumpFile$[rsp]
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 620  : 
; 621  :         if ( bSuccess )

  00180	83 7c 24 40 00	 cmp	 DWORD PTR bSuccess$[rsp], 0
  00185	74 15		 je	 SHORT $LN4@CreateMini

; 622  :         {
; 623  :             _tprintf( _T("\nDump \"%ls\" created.\n\n"

  00187	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:g_wszDumpPath
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160084
  00195	e8 00 00 00 00	 call	 printf

; 624  :                          "Please forward the dump to the Hercules team for analysis.\n\n"),
; 625  :                          g_wszDumpPath );
; 626  :         }

  0019a	eb 14		 jmp	 SHORT $LN5@CreateMini
$LN4@CreateMini:

; 627  :         else
; 628  :             _tprintf( _T("\nMiniDumpWriteDump failed! Error: %u\n\n"), GetLastError() );

  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  001a2	8b d0		 mov	 edx, eax
  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160085
  001ab	e8 00 00 00 00	 call	 printf
$LN5@CreateMini:

; 629  :     }

  001b0	eb 14		 jmp	 SHORT $LN3@CreateMini
$LN2@CreateMini:

; 630  :     else
; 631  :     {
; 632  :         _tprintf( _T("\nCreateFile failed! Error: %u\n\n"), GetLastError() );

  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  001b8	8b d0		 mov	 edx, eax
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160086
  001c1	e8 00 00 00 00	 call	 printf
$LN3@CreateMini:

; 633  :     }
; 634  : 
; 635  :     return bSuccess;

  001c6	8b 44 24 40	 mov	 eax, DWORD PTR bSuccess$[rsp]

; 636  : }

  001ca	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001d1	c3		 ret	 0
CreateMiniDump ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\bootstrap.c
_TEXT	SEGMENT
rc$ = 48
uiMBFlags$ = 52
hwndMBOwner$ = 56
pExceptionPtrs$ = 80
ProcessException PROC

; 494  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 495  :     int rc;
; 496  :     UINT uiMBFlags =

  00009	c7 44 24 34 00
	10 05 00	 mov	 DWORD PTR uiMBFlags$[rsp], 331776 ; 00051000H

; 497  :         0
; 498  :         | MB_SYSTEMMODAL
; 499  :         | MB_TOPMOST
; 500  :         | MB_SETFOREGROUND
; 501  :         ;
; 502  : 
; 503  :     HWND hwndMBOwner = FindConsoleHandle();

  00011	e8 00 00 00 00	 call	 FindConsoleHandle
  00016	48 89 44 24 38	 mov	 QWORD PTR hwndMBOwner$[rsp], rax

; 504  : 
; 505  :     if (!hwndMBOwner || !IsWindowVisible(hwndMBOwner))

  0001b	48 83 7c 24 38
	00		 cmp	 QWORD PTR hwndMBOwner$[rsp], 0
  00021	74 0f		 je	 SHORT $LN3@ProcessExc
  00023	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hwndMBOwner$[rsp]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsWindowVisible
  0002e	85 c0		 test	 eax, eax
  00030	75 0b		 jne	 SHORT $LN2@ProcessExc
$LN3@ProcessExc:

; 506  :         hwndMBOwner = GetDesktopWindow();

  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetDesktopWindow
  00038	48 89 44 24 38	 mov	 QWORD PTR hwndMBOwner$[rsp], rax
$LN2@ProcessExc:

; 507  : 
; 508  :     if ( !g_pfnMiniDumpWriteDumpFunc )

  0003d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_pfnMiniDumpWriteDumpFunc, 0
  00045	75 36		 jne	 SHORT $LN4@ProcessExc

; 509  :     {
; 510  :         MsgBox

  00047	8b 44 24 34	 mov	 eax, DWORD PTR uiMBFlags$[rsp]
  0004b	83 c8 10	 or	 eax, 16
  0004e	c7 44 24 28 98
	3a 00 00	 mov	 DWORD PTR [rsp+40], 15000 ; 00003a98H
  00056	66 c7 44 24 20
	00 00		 mov	 WORD PTR [rsp+32], 0
  0005d	44 8b c8	 mov	 r9d, eax
  00060	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160051
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160052
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hwndMBOwner$[rsp]
  00073	e8 00 00 00 00	 call	 MsgBox

; 511  :         (
; 512  :             hwndMBOwner,
; 513  :             _T("The creation of a crash dump for analysis by the Hercules ")
; 514  :             _T("development team is NOT possible\nbecause the required 'DbgHelp.dll' ")
; 515  :             _T("is missing or is not installed or was otherwise not located.")
; 516  :             ,_T("OOPS!  Hercules has crashed!"),
; 517  :             uiMBFlags
; 518  :                 | MB_ICONERROR
; 519  :                 | MB_OK
; 520  :             ,0                  // (default/neutral language)
; 521  :             ,(15 * 1000)        // (timeout == 15 seconds)
; 522  :         );
; 523  : 
; 524  :         return;

  00078	e9 92 00 00 00	 jmp	 $LN1@ProcessExc
$LN4@ProcessExc:

; 525  :     }
; 526  : 
; 527  :     if ( IDYES == ( rc = MsgBox
; 528  :     (
; 529  :         hwndMBOwner,
; 530  :         _T("The creation of a crash dump for further analysis by ")
; 531  :         _T("the Hercules development team is strongly suggested.\n\n")
; 532  :         _T("Would you like to create a crash dump for ")
; 533  :         _T("the Hercules development team to analyze?")
; 534  :         ,_T("OOPS!  Hercules has crashed!"),
; 535  :         uiMBFlags
; 536  :             | MB_ICONERROR
; 537  :             | MB_YESNO
; 538  :         ,0                      // (default/neutral language)
; 539  :         ,(10 * 1000)            // (timeout == 10 seconds)
; 540  :     ))
; 541  :         || MB_TIMEDOUT == rc

  0007d	8b 44 24 34	 mov	 eax, DWORD PTR uiMBFlags$[rsp]
  00081	83 c8 10	 or	 eax, 16
  00084	83 c8 04	 or	 eax, 4
  00087	c7 44 24 28 10
	27 00 00	 mov	 DWORD PTR [rsp+40], 10000 ; 00002710H
  0008f	66 c7 44 24 20
	00 00		 mov	 WORD PTR [rsp+32], 0
  00096	44 8b c8	 mov	 r9d, eax
  00099	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160055
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160056
  000a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hwndMBOwner$[rsp]
  000ac	e8 00 00 00 00	 call	 MsgBox
  000b1	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax
  000b5	83 7c 24 30 06	 cmp	 DWORD PTR rc$[rsp], 6
  000ba	74 0a		 je	 SHORT $LN6@ProcessExc
  000bc	81 7c 24 30 00
	7d 00 00	 cmp	 DWORD PTR rc$[rsp], 32000 ; 00007d00H
  000c4	75 49		 jne	 SHORT $LN5@ProcessExc
$LN6@ProcessExc:

; 542  :     )
; 543  :     {
; 544  :         if ( CreateMiniDump( pExceptionPtrs ) && MB_TIMEDOUT != rc )

  000c6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pExceptionPtrs$[rsp]
  000cb	e8 00 00 00 00	 call	 CreateMiniDump
  000d0	85 c0		 test	 eax, eax
  000d2	74 3b		 je	 SHORT $LN7@ProcessExc
  000d4	81 7c 24 30 00
	7d 00 00	 cmp	 DWORD PTR rc$[rsp], 32000 ; 00007d00H
  000dc	74 31		 je	 SHORT $LN7@ProcessExc

; 545  :         {
; 546  :             MsgBox

  000de	8b 44 24 34	 mov	 eax, DWORD PTR uiMBFlags$[rsp]
  000e2	83 c8 30	 or	 eax, 48			; 00000030H
  000e5	c7 44 24 28 88
	13 00 00	 mov	 DWORD PTR [rsp+40], 5000 ; 00001388H
  000ed	66 c7 44 24 20
	00 00		 mov	 WORD PTR [rsp+32], 0
  000f4	44 8b c8	 mov	 r9d, eax
  000f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160058
  000fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160059
  00105	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hwndMBOwner$[rsp]
  0010a	e8 00 00 00 00	 call	 MsgBox
$LN7@ProcessExc:
$LN5@ProcessExc:
$LN1@ProcessExc:

; 547  :             (
; 548  :                 hwndMBOwner,
; 549  :                 _T("Please send the dump to the Hercules development team for analysis.")
; 550  :                 ,_T("Dump Complete"),
; 551  :                 uiMBFlags
; 552  :                     | MB_ICONEXCLAMATION
; 553  :                     | MB_OK
; 554  :                 ,0              // (default/neutral language)
; 555  :                 ,(5 * 1000)     // (timeout == 5 seconds)
; 556  :             );
; 557  :         }
; 558  :     }
; 559  : }

  0010f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00113	c3		 ret	 0
ProcessException ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\bootstrap.c
_TEXT	SEGMENT
ptConsole$1 = 48
hStdErr$2 = 56
dwCellsWritten$3 = 64
hStdIn$4 = 72
csbi$5 = 80
__$ArrayPad$ = 104
pExceptionPtrs$ = 128
HerculesUnhandledExceptionFilter PROC

; 344  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 345  :     static BOOL bDidThis = FALSE;               // (if we did this once already)
; 346  :     if (bDidThis)

  00018	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDidThis@?1??HerculesUnhandledExceptionFilter@@9@9, 0
  0001f	74 0a		 je	 SHORT $LN2@HerculesUn

; 347  :         return EXCEPTION_EXECUTE_HANDLER;       // (quick exit to prevent loop)

  00021	b8 01 00 00 00	 mov	 eax, 1
  00026	e9 f2 02 00 00	 jmp	 $LN1@HerculesUn
$LN2@HerculesUn:

; 348  :     bDidThis = TRUE;

  0002b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDidThis@?1??HerculesUnhandledExceptionFilter@@9@9, 1

; 349  :     SetErrorMode( 0 );                          // (reset back to default handling)

  00035	33 c9		 xor	 ecx, ecx
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetErrorMode

; 350  : 
; 351  :     // Stop CCKD tracing right away to preserve existing trace entries
; 352  : 
; 353  :     g_itracen = cckdblk.itracen;                // (save existing value)

  0003d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_cckdblk
  00044	8b 80 10 03 00
	00		 mov	 eax, DWORD PTR [rax+784]
  0004a	89 05 00 00 00
	00		 mov	 DWORD PTR g_itracen, eax

; 354  :     cckdblk.itracen = 0;                        // (set table size to 0)

  00050	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_cckdblk
  00057	c7 80 10 03 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+784], 0

; 355  : 
; 356  :     // Is an external GUI in control?
; 357  : 
; 358  :     if (sysblk.daemon_mode)

  00061	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00068	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0006e	c1 e8 02	 shr	 eax, 2
  00071	83 e0 01	 and	 eax, 1
  00074	85 c0		 test	 eax, eax
  00076	74 7b		 je	 SHORT $LN3@HerculesUn

; 359  :     {
; 360  :         fflush( stdout );

  00078	b9 01 00 00 00	 mov	 ecx, 1
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00083	48 8b c8	 mov	 rcx, rax
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 361  :         fflush( stderr );

  0008c	b9 02 00 00 00	 mov	 ecx, 2
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00097	48 8b c8	 mov	 rcx, rax
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 362  : 
; 363  :         _ftprintf( stderr, _T("]!OOPS!\n") );   // (external GUI pre-processing...)

  000a0	b9 02 00 00 00	 mov	 ecx, 2
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160011
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf

; 364  : 
; 365  :         fflush( stdout );

  000bb	b9 01 00 00 00	 mov	 ecx, 1
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c6	48 8b c8	 mov	 rcx, rax
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 366  :         fflush( stderr );

  000cf	b9 02 00 00 00	 mov	 ecx, 2
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000da	48 8b c8	 mov	 rcx, rax
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 367  :         Sleep( 10 );

  000e3	b9 0a 00 00 00	 mov	 ecx, 10
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 368  :     }

  000ee	e9 3b 01 00 00	 jmp	 $LN4@HerculesUn
$LN3@HerculesUn:

; 369  :     else
; 370  :     {
; 371  :         // Normal panel mode: reset console mode and clear the screen...
; 372  : 
; 373  :         DWORD                       dwCellsWritten;
; 374  :         CONSOLE_SCREEN_BUFFER_INFO  csbi;
; 375  :         HANDLE                      hStdIn, hStdErr;
; 376  :         COORD                       ptConsole = { 0, 0 };

  000f3	33 c0		 xor	 eax, eax
  000f5	66 89 44 24 30	 mov	 WORD PTR ptConsole$1[rsp], ax
  000fa	33 c0		 xor	 eax, eax
  000fc	66 89 44 24 32	 mov	 WORD PTR ptConsole$1[rsp+2], ax

; 377  : 
; 378  :         EnableMenuItem( GetSystemMenu( FindConsoleHandle(), FALSE ),

  00101	e8 00 00 00 00	 call	 FindConsoleHandle
  00106	33 d2		 xor	 edx, edx
  00108	48 8b c8	 mov	 rcx, rax
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemMenu
  00111	45 33 c0	 xor	 r8d, r8d
  00114	ba 60 f0 00 00	 mov	 edx, 61536		; 0000f060H
  00119	48 8b c8	 mov	 rcx, rax
  0011c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnableMenuItem

; 379  :                     SC_CLOSE, MF_BYCOMMAND | MF_ENABLED );
; 380  : 
; 381  :         hStdIn  = GetStdHandle( STD_INPUT_HANDLE );

  00122	b9 f6 ff ff ff	 mov	 ecx, -10		; fffffff6H
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle
  0012d	48 89 44 24 48	 mov	 QWORD PTR hStdIn$4[rsp], rax

; 382  :         hStdErr = GetStdHandle( STD_ERROR_HANDLE );

  00132	b9 f4 ff ff ff	 mov	 ecx, -12		; fffffff4H
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle
  0013d	48 89 44 24 38	 mov	 QWORD PTR hStdErr$2[rsp], rax

; 383  : 
; 384  : #define DEFAULT_CONSOLE_ATTRIBUTES     (0   \
; 385  :         | FOREGROUND_RED                    \
; 386  :         | FOREGROUND_GREEN                  \
; 387  :         | FOREGROUND_BLUE                   \
; 388  :         )
; 389  : 
; 390  : /* FIXME these are defined in SDK V6+ */
; 391  : #ifndef ENABLE_INSERT_MODE
; 392  : #define ENABLE_INSERT_MODE 0
; 393  : #endif
; 394  : #ifndef ENABLE_QUICK_EDIT_MODE
; 395  : #define ENABLE_QUICK_EDIT_MODE 0
; 396  : #endif
; 397  : 
; 398  : #define DEFAULT_CONSOLE_INPUT_MODE     (0   \
; 399  :         | ENABLE_ECHO_INPUT                 \
; 400  :         | ENABLE_INSERT_MODE                \
; 401  :         | ENABLE_LINE_INPUT                 \
; 402  :         | ENABLE_MOUSE_INPUT                \
; 403  :         | ENABLE_PROCESSED_INPUT            \
; 404  :         | ENABLE_QUICK_EDIT_MODE            \
; 405  :         )
; 406  : 
; 407  : #define DEFAULT_CONSOLE_OUTPUT_MODE    (0   \
; 408  :         | ENABLE_PROCESSED_OUTPUT           \
; 409  :         | ENABLE_WRAP_AT_EOL_OUTPUT         \
; 410  :         )
; 411  : 
; 412  :         SetConsoleTextAttribute( hStdErr, DEFAULT_CONSOLE_ATTRIBUTES  );

  00142	66 ba 07 00	 mov	 dx, 7
  00146	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hStdErr$2[rsp]
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 413  :         SetConsoleMode         ( hStdIn,  DEFAULT_CONSOLE_INPUT_MODE  );

  00151	ba 77 00 00 00	 mov	 edx, 119		; 00000077H
  00156	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hStdIn$4[rsp]
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleMode

; 414  :         SetConsoleMode         ( hStdErr, DEFAULT_CONSOLE_OUTPUT_MODE );

  00161	ba 03 00 00 00	 mov	 edx, 3
  00166	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hStdErr$2[rsp]
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleMode

; 415  : 
; 416  :         GetConsoleScreenBufferInfo( hStdErr, &csbi );

  00171	48 8d 54 24 50	 lea	 rdx, QWORD PTR csbi$5[rsp]
  00176	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hStdErr$2[rsp]
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleScreenBufferInfo

; 417  :         FillConsoleOutputCharacter( hStdErr, ' ', csbi.dwSize.X * csbi.dwSize.Y, ptConsole, &dwCellsWritten );

  00181	0f bf 44 24 50	 movsx	 eax, WORD PTR csbi$5[rsp]
  00186	0f bf 4c 24 52	 movsx	 ecx, WORD PTR csbi$5[rsp+2]
  0018b	0f af c1	 imul	 eax, ecx
  0018e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR dwCellsWritten$3[rsp]
  00193	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00198	44 8b 4c 24 30	 mov	 r9d, DWORD PTR ptConsole$1[rsp]
  0019d	44 8b c0	 mov	 r8d, eax
  001a0	b2 20		 mov	 dl, 32			; 00000020H
  001a2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hStdErr$2[rsp]
  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FillConsoleOutputCharacterA

; 418  :         GetConsoleScreenBufferInfo( hStdErr, &csbi );

  001ad	48 8d 54 24 50	 lea	 rdx, QWORD PTR csbi$5[rsp]
  001b2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hStdErr$2[rsp]
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleScreenBufferInfo

; 419  :         FillConsoleOutputAttribute( hStdErr, csbi.wAttributes, csbi.dwSize.X * csbi.dwSize.Y, ptConsole, &dwCellsWritten );

  001bd	0f bf 44 24 50	 movsx	 eax, WORD PTR csbi$5[rsp]
  001c2	0f bf 4c 24 52	 movsx	 ecx, WORD PTR csbi$5[rsp+2]
  001c7	0f af c1	 imul	 eax, ecx
  001ca	48 8d 4c 24 40	 lea	 rcx, QWORD PTR dwCellsWritten$3[rsp]
  001cf	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001d4	44 8b 4c 24 30	 mov	 r9d, DWORD PTR ptConsole$1[rsp]
  001d9	44 8b c0	 mov	 r8d, eax
  001dc	0f b7 54 24 58	 movzx	 edx, WORD PTR csbi$5[rsp+8]
  001e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hStdErr$2[rsp]
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FillConsoleOutputAttribute

; 420  :         SetConsoleCursorPosition  ( hStdErr, ptConsole );

  001ec	8b 54 24 30	 mov	 edx, DWORD PTR ptConsole$1[rsp]
  001f0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hStdErr$2[rsp]
  001f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCursorPosition

; 421  : 
; 422  :         fflush( stdout );

  001fb	b9 01 00 00 00	 mov	 ecx, 1
  00200	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00206	48 8b c8	 mov	 rcx, rax
  00209	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 423  :         fflush( stderr );

  0020f	b9 02 00 00 00	 mov	 ecx, 2
  00214	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0021a	48 8b c8	 mov	 rcx, rax
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 424  :         Sleep( 10 );

  00223	b9 0a 00 00 00	 mov	 ecx, 10
  00228	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
$LN4@HerculesUn:

; 425  :     }
; 426  : 
; 427  :     _tprintf( _T("\n\n") );

  0022e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160012
  00235	e8 00 00 00 00	 call	 printf

; 428  :     _tprintf( _T("                      ***************\n") );

  0023a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160013
  00241	e8 00 00 00 00	 call	 printf

; 429  :     _tprintf( _T("                      *    OOPS!    *\n") );

  00246	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160014
  0024d	e8 00 00 00 00	 call	 printf

; 430  :     _tprintf( _T("                      ***************\n") );

  00252	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160015
  00259	e8 00 00 00 00	 call	 printf

; 431  :     _tprintf( _T("\n") );

  0025e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160016
  00265	e8 00 00 00 00	 call	 printf

; 432  :     _tprintf( _T("                    Hercules has crashed!\n") );

  0026a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160017
  00271	e8 00 00 00 00	 call	 printf

; 433  :     _tprintf( _T("\n") );

  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160018
  0027d	e8 00 00 00 00	 call	 printf

; 434  :     _tprintf( _T("(you may or may not need to press ENTER if no 'oops!' dialog-box appears)\n") );

  00282	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160019
  00289	e8 00 00 00 00	 call	 printf

; 435  :     _tprintf( _T("\n") );

  0028e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160020
  00295	e8 00 00 00 00	 call	 printf

; 436  : 
; 437  :     fflush( stdout );

  0029a	b9 01 00 00 00	 mov	 ecx, 1
  0029f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a5	48 8b c8	 mov	 rcx, rax
  002a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 438  :     fflush( stderr );

  002ae	b9 02 00 00 00	 mov	 ecx, 2
  002b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b9	48 8b c8	 mov	 rcx, rax
  002bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 439  :     Sleep( 10 );

  002c2	b9 0a 00 00 00	 mov	 ecx, 10
  002c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 440  : 
; 441  :     ProcessException( pExceptionPtrs );     // (create a minidump, if possible)

  002cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pExceptionPtrs$[rsp]
  002d5	e8 00 00 00 00	 call	 ProcessException

; 442  : 
; 443  :     fflush( stdout );

  002da	b9 01 00 00 00	 mov	 ecx, 1
  002df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002e5	48 8b c8	 mov	 rcx, rax
  002e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 444  :     fflush( stderr );

  002ee	b9 02 00 00 00	 mov	 ecx, 2
  002f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f9	48 8b c8	 mov	 rcx, rax
  002fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 445  :     Sleep( 10 );

  00302	b9 0a 00 00 00	 mov	 ecx, 10
  00307	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 446  : 
; 447  :     timeEndPeriod( 1 );                     // (reset to default time interval)

  0030d	b9 01 00 00 00	 mov	 ecx, 1
  00312	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timeEndPeriod

; 448  : 
; 449  :     return EXCEPTION_EXECUTE_HANDLER;       // (quite likely exits the process)

  00318	b8 01 00 00 00	 mov	 eax, 1
$LN1@HerculesUn:

; 450  : }

  0031d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00322	48 33 cc	 xor	 rcx, rsp
  00325	e8 00 00 00 00	 call	 __security_check_cookie
  0032a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0032e	c3		 ret	 0
HerculesUnhandledExceptionFilter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 _vfprintf_l
  00042	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  00046	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
