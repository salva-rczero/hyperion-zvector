; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG194080 DB	'TAC 0', 00H
	ORG $+2
$SG194081 DB	'(undefined Abort Code)', 00H
	ORG $+1
$SG194082 DB	'TAC 1', 00H
	ORG $+2
$SG194083 DB	'(undefined Abort Code)', 00H
	ORG $+1
$SG194084 DB	'TAC_EXT', 00H
$SG194085 DB	'External interruption', 00H
	ORG $+2
$SG194086 DB	'TAC 3', 00H
	ORG $+2
$SG194087 DB	'(undefined Abort Code)', 00H
	ORG $+1
$SG194088 DB	'TAC_UPGM', 00H
	ORG $+3
$SG194092 DB	'TAC_IO', 00H
	ORG $+1
$SG194510 DB	'z13', 00H
$SG194089 DB	'PGM Interruption (Unfiltered)', 00H
	ORG $+2
$SG194090 DB	'TAC_MCK', 00H
$SG194091 DB	'Machine-check Interruption', 00H
	ORG $+1
$SG194514 DB	'z14', 00H
$SG194093 DB	'I/O Interruption', 00H
	ORG $+3
$SG194114 DB	'TAC 17', 00H
	ORG $+1
$SG194518 DB	'z15', 00H
$SG194094 DB	'TAC_FETCH_OVF', 00H
	ORG $+2
$SG194095 DB	'Fetch overflow', 00H
	ORG $+1
$SG194096 DB	'TAC_STORE_OVF', 00H
	ORG $+2
$SG194097 DB	'Store overflow', 00H
	ORG $+1
$SG194098 DB	'TAC_FETCH_CNF', 00H
	ORG $+2
$SG194099 DB	'Fetch conflict', 00H
	ORG $+1
$SG194100 DB	'TAC_STORE_CNF', 00H
	ORG $+2
$SG194101 DB	'Store conflict', 00H
	ORG $+1
$SG194102 DB	'TAC_INSTR', 00H
	ORG $+2
$SG194116 DB	'TAC 18', 00H
	ORG $+1
$SG194522 DB	'z16', 00H
$SG194103 DB	'Restricted instruction', 00H
	ORG $+1
$SG194104 DB	'TAC_FPGM', 00H
	ORG $+3
$SG194516 DB	'z14ZR1', 00H
	ORG $+5
$SG194105 DB	'PGM Interruption (Filtered)', 00H
	ORG $+4
$SG194106 DB	'TAC_NESTING', 00H
	ORG $+4
$SG194107 DB	'Nesting Depth exceeded', 00H
	ORG $+1
$SG194108 DB	'TAC_FETCH_OTH', 00H
	ORG $+2
$SG194109 DB	'Cache (fetch related)', 00H
	ORG $+2
$SG194110 DB	'TAC_STORE_OTH', 00H
	ORG $+2
$SG194111 DB	'Cache (store related)', 00H
	ORG $+2
$SG194112 DB	'TAC_CACHE_OTH', 00H
	ORG $+2
$SG194113 DB	'Cache (other)', 00H
	ORG $+2
$SG194115 DB	'(undefined Abort Code)', 00H
	ORG $+1
$SG194117 DB	'(undefined Abort Code)', 00H
	ORG $+1
$SG194118 DB	'TAC_GUARDED', 00H
	ORG $+4
$SG194119 DB	'Guarded-Storage Event related', 00H
	ORG $+2
$SG194503 DB	'1090', 00H
	ORG $+3
$SG194504 DB	'zPDT', 00H
	ORG $+3
$SG194505 DB	'2827', 00H
	ORG $+3
$SG194506 DB	'EC12', 00H
	ORG $+3
$SG194507 DB	'2828', 00H
	ORG $+3
$SG194508 DB	'BC12', 00H
	ORG $+3
$SG194509 DB	'2964', 00H
	ORG $+3
$SG194511 DB	'2965', 00H
	ORG $+3
$SG194512 DB	'z13s', 00H
	ORG $+3
$SG194513 DB	'3906', 00H
	ORG $+3
$SG194515 DB	'3907', 00H
	ORG $+3
$SG194517 DB	'8561', 00H
	ORG $+3
$SG194519 DB	'8562', 00H
	ORG $+3
$SG194520 DB	'z15T02', 00H
	ORG $+1
$SG194521 DB	'3931', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
?racode@?BA@??z900_process_tbegin@@9@9 DB 07H		; `z900_process_tbegin'::`16'::racode
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	010H
	DB	0ffH
	ORG $+14
tac2cc	DD	03H
	DD	03H
	DD	02H
	DD	03H
	DD	03H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	02H
?skp@?1??dump_cache@@9@9 DQ 0000000000000000H		; `dump_cache'::`2'::skp
?amt@?1??dump_cache@@9@9 DQ 0000000000000100H		; `dump_cache'::`2'::amt
?bpg@?1??dump_cache@@9@9 DQ 0000000000000004H		; `dump_cache'::`2'::bpg
?gpl@?1??dump_cache@@9@9 DQ 0000000000000004H		; `dump_cache'::`2'::gpl
?skp@?2??dump_tdb@@9@9 DQ 0000000000000000H		; `dump_tdb'::`3'::skp
?amt@?2??dump_tdb@@9@9 DQ 0000000000000100H		; `dump_tdb'::`3'::amt
?adr@?2??dump_tdb@@9@9 DQ 0000000000000000H		; `dump_tdb'::`3'::adr
?bpg@?2??dump_tdb@@9@9 DQ 0000000000000008H		; `dump_tdb'::`3'::bpg
?gpl@?2??dump_tdb@@9@9 DQ 0000000000000002H		; `dump_tdb'::`3'::gpl
	ORG $+8
txf_models DW	01090H
	ORG $+6
	DQ	FLAT:$SG194503
	DQ	FLAT:$SG194504
	DW	02827H
	ORG $+6
	DQ	FLAT:$SG194505
	DQ	FLAT:$SG194506
	DW	02828H
	ORG $+6
	DQ	FLAT:$SG194507
	DQ	FLAT:$SG194508
	DW	02964H
	ORG $+6
	DQ	FLAT:$SG194509
	DQ	FLAT:$SG194510
	DW	02965H
	ORG $+6
	DQ	FLAT:$SG194511
	DQ	FLAT:$SG194512
	DW	03906H
	ORG $+6
	DQ	FLAT:$SG194513
	DQ	FLAT:$SG194514
	DW	03907H
	ORG $+6
	DQ	FLAT:$SG194515
	DQ	FLAT:$SG194516
	DW	08561H
	ORG $+6
	DQ	FLAT:$SG194517
	DQ	FLAT:$SG194518
	DW	08562H
	ORG $+6
	DQ	FLAT:$SG194519
	DQ	FLAT:$SG194520
	DW	03931H
	ORG $+6
	DQ	FLAT:$SG194521
	DQ	FLAT:$SG194522
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	tac2short
PUBLIC	tac2long
PUBLIC	dump_cache
PUBLIC	dump_tdb
PUBLIC	txf_why_str
PUBLIC	is_TXF_model
PUBLIC	defsym_TXF_models
PUBLIC	txf_model_warning
PUBLIC	txf_set_timerint
PUBLIC	txf_maddr_l
PUBLIC	s370_abort_transaction
PUBLIC	s390_abort_transaction
PUBLIC	z900_abort_transaction
PUBLIC	z900_txf_do_pi_filtering
PUBLIC	alloc_txfmap
PUBLIC	free_txfmap
PUBLIC	txf_abort_all
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	z900_perform_processor_assist
PUBLIC	z900_transaction_begin_constrained
PUBLIC	z900_transaction_end
PUBLIC	z900_extract_transaction_nesting_depth
PUBLIC	z900_transaction_abort
PUBLIC	z900_nontransactional_store
PUBLIC	z900_transaction_begin
PUBLIC	z900__or_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_or_storage_key
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_xcheck
PUBLIC	z900_per3_zero_xcheck2
PUBLIC	z900_maddr_l
PUBLIC	z900_vstore8_full
PUBLIC	z900_vstore8
PUBLIC	z900_validate_operand
PUBLIC	z900_reset_txf_aie
PUBLIC	z900_set_txf_aie
PUBLIC	z900_process_tbegin
EXTRN	__imp__errno:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp__aligned_free:PROC
EXTRN	__imp__aligned_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_rand:PROC
EXTRN	longjmp:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_broadcast_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_set_symbol:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_trimloc:PROC
EXTRN	__imp_rtrim:PROC
EXTRN	__imp_idx_snprintf:PROC
EXTRN	__imp_ptyp2short:PROC
EXTRN	__imp_PIC2Name:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	iprint_router_func:PROC
EXTRN	rubato_thread:PROC
EXTRN	copy_regs:PROC
EXTRN	z900_virt_to_real:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__imp_hexdumpew:PROC
EXTRN	z900_fix_program_interrupt_PSW:PROC
EXTRN	z900_trace_program_interrupt:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG192876 DB	01H DUP (?)
$SG192912 DB	01H DUP (?)
$SG192923 DB	01H DUP (?)
$SG192950 DB	01H DUP (?)
$SG193342 DB	01H DUP (?)
$SG193346 DB	01H DUP (?)
$SG193363 DB	01H DUP (?)
$SG193588 DB	01H DUP (?)
$SG193613 DB	01H DUP (?)
$SG193628 DB	01H DUP (?)
$SG193644 DB	01H DUP (?)
$SG193688 DB	01H DUP (?)
$SG194147 DB	01H DUP (?)
$SG194149 DB	01H DUP (?)
$SG194151 DB	01H DUP (?)
$SG194153 DB	01H DUP (?)
$SG194155 DB	01H DUP (?)
$SG194157 DB	01H DUP (?)
$SG194159 DB	01H DUP (?)
$SG194161 DB	01H DUP (?)
$SG194163 DB	01H DUP (?)
$SG194165 DB	01H DUP (?)
$SG194167 DB	01H DUP (?)
$SG194169 DB	01H DUP (?)
$SG194171 DB	01H DUP (?)
$SG194173 DB	01H DUP (?)
$SG194175 DB	01H DUP (?)
$SG194177 DB	01H DUP (?)
$SG194179 DB	01H DUP (?)
$SG194181 DB	01H DUP (?)
$SG194183 DB	01H DUP (?)
$SG194185 DB	01H DUP (?)
$SG194187 DB	01H DUP (?)
$SG194189 DB	01H DUP (?)
$SG194191 DB	01H DUP (?)
$SG194193 DB	01H DUP (?)
$SG194195 DB	01H DUP (?)
$SG194197 DB	01H DUP (?)
$SG194199 DB	01H DUP (?)
$SG194201 DB	01H DUP (?)
$SG194203 DB	01H DUP (?)
$SG194205 DB	01H DUP (?)
$SG194207 DB	01H DUP (?)
$SG194209 DB	01H DUP (?)
$SG194236 DB	01H DUP (?)
$SG194245 DB	01H DUP (?)
$SG194331 DB	01H DUP (?)
$SG194337 DB	01H DUP (?)
$SG194348 DB	01H DUP (?)
$SG194356 DB	01H DUP (?)
$SG194365 DB	01H DUP (?)
$SG194367 DB	01H DUP (?)
$SG194373 DB	01H DUP (?)
$SG194380 DB	01H DUP (?)
$SG194387 DB	01H DUP (?)
$SG194396 DB	01H DUP (?)
$SG194398 DB	01H DUP (?)
$SG194406 DB	01H DUP (?)
$SG194419 DB	01H DUP (?)
$SG194422 DB	01H DUP (?)
$SG194427 DB	01H DUP (?)
$SG194429 DB	01H DUP (?)
$SG194436 DB	01H DUP (?)
$SG194443 DB	01H DUP (?)
$SG194450 DB	01H DUP (?)
$SG194457 DB	01H DUP (?)
$SG194464 DB	01H DUP (?)
$SG194471 DB	01H DUP (?)
$SG194478 DB	01H DUP (?)
$SG194485 DB	01H DUP (?)
$SG194492 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$tac2short DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$tac2short
$pdata$tac2long DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$tac2long
$pdata$dump_cache DD imagerel $LN9
	DD	imagerel $LN9+754
	DD	imagerel $unwind$dump_cache
$pdata$dump_tdb DD imagerel $LN98
	DD	imagerel $LN98+8969
	DD	imagerel $unwind$dump_tdb
$pdata$txf_why_str DD imagerel $LN65
	DD	imagerel $LN65+2012
	DD	imagerel $unwind$txf_why_str
$pdata$is_TXF_model DD imagerel $LN7
	DD	imagerel $LN7+75
	DD	imagerel $unwind$is_TXF_model
$pdata$defsym_TXF_models DD imagerel $LN6
	DD	imagerel $LN6+95
	DD	imagerel $unwind$defsym_TXF_models
$pdata$txf_model_warning DD imagerel $LN4
	DD	imagerel $LN4+222
	DD	imagerel $unwind$txf_model_warning
$pdata$txf_set_timerint DD imagerel $LN11
	DD	imagerel $LN11+607
	DD	imagerel $unwind$txf_set_timerint
$pdata$txf_maddr_l DD imagerel $LN63
	DD	imagerel $LN63+2109
	DD	imagerel $unwind$txf_maddr_l
$pdata$s370_abort_transaction DD imagerel $LN18
	DD	imagerel $LN18+73
	DD	imagerel $unwind$s370_abort_transaction
$pdata$s390_abort_transaction DD imagerel $LN18
	DD	imagerel $LN18+73
	DD	imagerel $unwind$s390_abort_transaction
$pdata$z900_abort_transaction DD imagerel $LN217
	DD	imagerel $LN217+10070
	DD	imagerel $unwind$z900_abort_transaction
$pdata$z900_txf_do_pi_filtering DD imagerel $LN85
	DD	imagerel $LN85+1443
	DD	imagerel $unwind$z900_txf_do_pi_filtering
$pdata$alloc_txfmap DD imagerel $LN15
	DD	imagerel $LN15+404
	DD	imagerel $unwind$alloc_txfmap
$pdata$free_txfmap DD imagerel $LN14
	DD	imagerel $LN14+295
	DD	imagerel $unwind$free_txfmap
$pdata$txf_abort_all DD imagerel $LN18
	DD	imagerel $LN18+856
	DD	imagerel $unwind$txf_abort_all
$pdata$synchronize_cpus DD imagerel synchronize_cpus
	DD	imagerel synchronize_cpus+583
	DD	imagerel $unwind$synchronize_cpus
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
pdata	SEGMENT
$pdata$z900_perform_processor_assist DD imagerel $LN24
	DD	imagerel $LN24+385
	DD	imagerel $unwind$z900_perform_processor_assist
$pdata$z900_transaction_begin_constrained DD imagerel $LN31
	DD	imagerel $LN31+1111
	DD	imagerel $unwind$z900_transaction_begin_constrained
$pdata$z900_transaction_end DD imagerel $LN145
	DD	imagerel $LN145+7517
	DD	imagerel $unwind$z900_transaction_end
$pdata$z900_extract_transaction_nesting_depth DD imagerel $LN28
	DD	imagerel $LN28+840
	DD	imagerel $unwind$z900_extract_transaction_nesting_depth
$pdata$z900_transaction_abort DD imagerel $LN41
	DD	imagerel $LN41+1208
	DD	imagerel $unwind$z900_transaction_abort
$pdata$z900_nontransactional_store DD imagerel $LN25
	DD	imagerel $LN25+673
	DD	imagerel $unwind$z900_nontransactional_store
$pdata$z900_transaction_begin DD imagerel $LN33
	DD	imagerel $LN33+1211
	DD	imagerel $unwind$z900_transaction_begin
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck DD imagerel $LN6
	DD	imagerel $LN6+108
	DD	imagerel $unwind$z900_per3_zero_xcheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck2 DD imagerel $LN18
	DD	imagerel $LN18+485
	DD	imagerel $unwind$z900_per3_zero_xcheck2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8_full DD imagerel $LN3
	DD	imagerel $LN3+375
	DD	imagerel $unwind$z900_vstore8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8 DD imagerel $LN9
	DD	imagerel $LN9+174
	DD	imagerel $unwind$z900_vstore8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+195
	DD	imagerel $unwind$z900_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$z900_process_tbegin DD imagerel $LN88
	DD	imagerel $LN88+4665
	DD	imagerel $unwind$z900_process_tbegin
$pdata$tac2name DD imagerel tac2name
	DD	imagerel tac2name+241
	DD	imagerel $unwind$tac2name
pdata	ENDS
_DATA	SEGMENT
	ORG $+3
$SG192619 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:99', 00H
	ORG $+3
$SG192621 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:104', 00H
	ORG $+2
$SG192622 DB	'TXF PPA', 00H
$SG192669 DB	'ETND', 00H
	ORG $+3
$SG192670 DB	'D', 00H
	ORG $+2
$SG192836 DB	'D', 00H
	ORG $+2
$SG192671 DB	'HHC17715%s TXF: %s%02X: SIE: Intercepting %s instruction'
	DB	0aH, 00H
	ORG $+2
$SG192877 DB	'D', 00H
	ORG $+2
$SG192672 DB	'z900_extract_transaction_nesting_depth', 00H
	ORG $+1
$SG192673 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG192913 DB	'D', 00H
	ORG $+2
$SG192676 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:175', 00H
	ORG $+2
$SG192677 DB	'*TXF ETND', 00H
	ORG $+2
$SG192924 DB	'D', 00H
	ORG $+2
$SG192679 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:180', 00H
	ORG $+2
$SG192681 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:184', 00H
	ORG $+2
$SG192682 DB	'TXF ETND', 00H
	ORG $+3
$SG192835 DB	'TEND', 00H
	ORG $+3
$SG192875 DB	'SIE: ', 00H
	ORG $+2
$SG192951 DB	'D', 00H
	ORG $+2
$SG192837 DB	'HHC17715%s TXF: %s%02X: SIE: Intercepting %s instruction'
	DB	0aH, 00H
	ORG $+2
$SG193015 DB	'TABORT', 00H
	ORG $+1
$SG193016 DB	'D', 00H
	ORG $+2
$SG192838 DB	'z900_transaction_end', 00H
	ORG $+3
$SG192839 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG193136 DB	'TBEGIN', 00H
	ORG $+1
$SG193137 DB	'D', 00H
	ORG $+2
$SG192843 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:246', 00H
	ORG $+2
$SG192844 DB	'*TXF end', 00H
	ORG $+3
$SG192911 DB	'SIE: ', 00H
	ORG $+2
$SG193207 DB	'D', 00H
	ORG $+2
$SG192847 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:253', 00H
	ORG $+2
$SG192848 DB	'*TXF end', 00H
	ORG $+3
$SG192922 DB	'SIE: ', 00H
	ORG $+2
$SG193341 DB	'C', 00H
	ORG $+2
$SG192849 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:255', 00H
	ORG $+2
$SG192852 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:266', 00H
	ORG $+2
$SG192853 DB	'*TXF end', 00H
	ORG $+3
$SG192949 DB	'SIE: ', 00H
	ORG $+2
$SG193343 DB	'nested', 00H
	ORG $+1
$SG193347 DB	'D', 00H
	ORG $+2
$SG192854 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:278', 00H
	ORG $+2
$SG192855 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:288', 00H
	ORG $+2
$SG192856 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:290', 00H
	ORG $+2
$SG192857 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:297', 00H
	ORG $+2
$SG192861 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:309', 00H
	ORG $+2
$SG192862 DB	'*TXF end', 00H
	ORG $+3
$SG193345 DB	'SIE: ', 00H
	ORG $+2
$SG193364 DB	'D', 00H
	ORG $+2
$SG192863 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:311', 00H
	ORG $+2
$SG192873 DB	'CONSTRAINED', 00H
$SG193589 DB	'D', 00H
	ORG $+2
$SG192874 DB	'UNconstrained', 00H
	ORG $+2
$SG192879 DB	'z900_transaction_end', 00H
	ORG $+3
$SG192878 DB	'HHC17700%s TXF: %s%02X: %sSuccessful %s Nested TEND for '
	DB	'TND %d => %d', 0aH, 00H
	ORG $+2
$SG192880 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG193607 DB	' ?', 00H
	ORG $+1
$SG192884 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:347', 00H
	ORG $+2
$SG192885 DB	'TXF end', 00H
$SG192886 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:348', 00H
	ORG $+2
$SG192889 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:361', 00H
	ORG $+2
$SG192890 DB	'*TXF end', 00H
	ORG $+3
$SG193362 DB	'SIE: ', 00H
	ORG $+2
$SG193610 DB	'Nested', 00H
	ORG $+1
$SG193614 DB	'D', 00H
	ORG $+2
$SG192891 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:364', 00H
	ORG $+2
$SG192897 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:430', 00H
	ORG $+2
$SG192898 DB	'*TXF end', 00H
	ORG $+3
$SG193587 DB	'SIE: ', 00H
	ORG $+2
$SG193625 DB	'%s%02X', 00H
	ORG $+1
$SG193629 DB	'D', 00H
	ORG $+2
$SG192899 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:441', 00H
	ORG $+2
$SG192909 DB	'CONSTRAINED', 00H
$SG193645 DB	'D', 00H
	ORG $+2
$SG192910 DB	'UNconstrained', 00H
	ORG $+2
$SG192914 DB	'HHC17701%s TXF: %s%02X: %sSuccessful Outermost %s TEND', 0aH
	DB	00H
$SG192915 DB	'z900_transaction_end', 00H
	ORG $+3
$SG192916 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG192925 DB	'HHC17704%s TXF: %s%02X: %svirt 0x%16.16llX, abs 0x%16.16'
	DB	'llX, alt 0x%16.16llX', 0aH, 00H
	ORG $+2
$SG192926 DB	'z900_transaction_end', 00H
	ORG $+3
$SG192927 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG193689 DB	'D', 00H
	ORG $+2
$SG192934 DB	'HHC17707D TXF: %s%02X: %sWe stored:  +', 00H
	ORG $+1
$SG192936 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:505', 00H
	ORG $+2
$SG192937 DB	'TXF end', 00H
$SG192947 DB	'CONSTRAINED', 00H
$SG194240 DB	'%s', 00H
	ORG $+1
$SG192948 DB	'UNconstrained', 00H
	ORG $+2
$SG192953 DB	'z900_transaction_end', 00H
	ORG $+3
$SG192952 DB	'HHC17718%s TXF: %s%02X: %s%s transaction succeeded after'
	DB	' %d retries', 0aH, 00H
	ORG $+3
$SG192954 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG194237 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG194246 DB	'E', 00H
	ORG $+2
$SG192957 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:549', 00H
	ORG $+2
$SG193017 DB	'HHC17715%s TXF: %s%02X: SIE: Intercepting %s instruction'
	DB	0aH, 00H
	ORG $+2
$SG194332 DB	'D', 00H
	ORG $+2
$SG193018 DB	'z900_transaction_abort', 00H
	ORG $+1
$SG193019 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG194338 DB	'D', 00H
	ORG $+2
$SG193021 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:575', 00H
	ORG $+2
$SG193025 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:580', 00H
	ORG $+2
$SG193026 DB	'*TXF TABORT', 00H
$SG194343 DB	'%s', 00H
	ORG $+1
$SG193029 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:587', 00H
	ORG $+2
$SG193030 DB	'*TXF TABORT', 00H
$SG194349 DB	'E', 00H
	ORG $+2
$SG193032 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:592', 00H
	ORG $+2
$SG193034 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:599', 00H
	ORG $+2
$SG193035 DB	'TXF TABORT', 00H
	ORG $+1
$SG194357 DB	'D', 00H
	ORG $+2
$SG193036 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:601', 00H
	ORG $+2
$SG193070 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:620', 00H
	ORG $+2
$SG193073 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:623', 00H
	ORG $+2
$SG193074 DB	'TXF NTSTG', 00H
	ORG $+2
$SG194340 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG194370 DB	',', 00H
	ORG $+2
$SG193138 DB	'HHC17715%s TXF: %s%02X: SIE: Intercepting %s instruction'
	DB	0aH, 00H
	ORG $+2
$SG194369 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG194374 DB	'D', 00H
	ORG $+2
$SG193139 DB	'z900_transaction_begin', 00H
	ORG $+1
$SG193140 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG194381 DB	'D', 00H
	ORG $+2
$SG193143 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:656', 00H
	ORG $+2
$SG193144 DB	'*TXF TBEGIN', 00H
$SG194388 DB	'D', 00H
	ORG $+2
$SG193148 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:666', 00H
	ORG $+2
$SG193149 DB	'*TXF TBEGIN', 00H
$SG194399 DB	'D', 00H
	ORG $+2
$SG193152 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:682', 00H
	ORG $+2
$SG193154 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:685', 00H
	ORG $+2
$SG193155 DB	'TXF TBEGIN', 00H
	ORG $+1
$SG194407 DB	'D', 00H
	ORG $+2
$SG193156 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:688', 00H
	ORG $+2
$SG193206 DB	'TBEGINC', 00H
$SG193208 DB	'HHC17715%s TXF: %s%02X: SIE: Intercepting %s instruction'
	DB	0aH, 00H
	ORG $+2
$SG194420 DB	' %s', 00H
$SG193209 DB	'z900_transaction_begin_constrained', 00H
	ORG $+1
$SG194423 DB	'D', 00H
	ORG $+2
$SG193210 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG194430 DB	'D', 00H
	ORG $+2
$SG193213 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:716', 00H
	ORG $+2
$SG193214 DB	'*TXF TBEGINC', 00H
	ORG $+3
$SG193218 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:726', 00H
	ORG $+2
$SG193219 DB	'*TXF TBEGINC', 00H
	ORG $+3
$SG193220 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:735', 00H
	ORG $+2
$SG193222 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:738', 00H
	ORG $+2
$SG193223 DB	'TXF TBEGINC', 00H
$SG194437 DB	'D', 00H
	ORG $+2
$SG193224 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:741', 00H
	ORG $+2
$SG193295 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:760', 00H
	ORG $+2
$SG193298 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:767', 00H
	ORG $+2
$SG193299 DB	'*TXF beg', 00H
	ORG $+3
$SG193612 DB	'SIE: ', 00H
	ORG $+2
$SG194444 DB	'D', 00H
	ORG $+2
$SG193300 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:769', 00H
	ORG $+2
$SG193302 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:776', 00H
	ORG $+2
$SG193303 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:781', 00H
	ORG $+2
$SG193304 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:785', 00H
	ORG $+2
$SG193320 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:929', 00H
	ORG $+2
$SG193321 DB	'*TXF begc', 00H
	ORG $+2
$SG194451 DB	'D', 00H
	ORG $+2
$SG193322 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:931', 00H
	ORG $+2
$SG193330 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:980', 00H
	ORG $+2
$SG193331 DB	'TXF beg', 00H
$SG193344 DB	'outermost', 00H
	ORG $+2
$SG194458 DB	'D', 00H
	ORG $+2
$SG193348 DB	'HHC17702%s TXF: %s%02X: %sSuccessful %s TBEGIN%s; TND no'
	DB	'w %d', 0aH, 00H
	ORG $+2
$SG193349 DB	'z900_process_tbegin', 00H
$SG194465 DB	'D', 00H
	ORG $+2
$SG193350 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG194472 DB	'D', 00H
	ORG $+2
$SG193360 DB	'CONSTRAINED', 00H
$SG194479 DB	'D', 00H
	ORG $+2
$SG193361 DB	'UNconstrained', 00H
	ORG $+2
$SG193365 DB	'HHC17717%s TXF: %s%02X: %s%s transaction retry #%d...', 0aH
	DB	00H
	ORG $+1
$SG193366 DB	'z900_process_tbegin', 00H
$SG194486 DB	'D', 00H
	ORG $+2
$SG193367 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG194493 DB	'D', 00H
	ORG $+2
$SG193561 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1100', 00H
	ORG $+1
$SG193562 DB	'*TXF abort', 00H
	ORG $+1
$SG194540 DB	'W', 00H
	ORG $+2
$SG193568 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1121', 00H
	ORG $+1
$SG193569 DB	'TXF ATIA', 00H
	ORG $+3
$SG193627 DB	'SIE: ', 00H
	ORG $+2
$SG194555 DB	'W', 00H
	ORG $+2
$SG193571 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1128', 00H
	ORG $+1
$SG193572 DB	'TXF ATIA', 00H
	ORG $+3
$SG193643 DB	'SIE: ', 00H
	ORG $+2
$SG194564 DB	'E', 00H
	ORG $+2
$SG193575 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1136', 00H
	ORG $+1
$SG193585 DB	'CONSTRAINED', 00H
	ORG $+4
$SG193586 DB	'UNconstrained', 00H
	ORG $+2
$SG193590 DB	'HHC17719%s TXF: %s%02X: %s%s transaction retry #%d FAILE'
	DB	'D!', 0aH, 00H
	ORG $+4
$SG193591 DB	'z900_abort_transaction', 00H
	ORG $+1
$SG193592 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG193608 DB	'CONSTRAINED', 00H
	ORG $+4
$SG193609 DB	'UNconstrained', 00H
	ORG $+2
$SG193611 DB	'Outermost', 00H
	ORG $+6
$SG193615 DB	'HHC17703%s TXF: %s%02X: %sFailed %s %s Transaction for T'
	DB	'ND %d: %s = %s, why =%s', 0aH, 00H
	ORG $+7
$SG193616 DB	'z900_abort_transaction', 00H
	ORG $+1
$SG193617 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG193621 DB	'channel', 00H
$SG193624 DB	'ourself', 00H
$SG193630 DB	'HHC17720%s TXF: %s%02X: %sAbort set by %s at %s', 0aH, 00H
	ORG $+7
$SG193631 DB	'z900_abort_transaction', 00H
	ORG $+1
$SG193632 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG193646 DB	'HHC17704%s TXF: %s%02X: %svirt 0x%16.16llX, abs 0x%16.16'
	DB	'llX, alt 0x%16.16llX', 0aH, 00H
	ORG $+2
$SG193647 DB	'z900_abort_transaction', 00H
	ORG $+1
$SG193648 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG193655 DB	'HHC17705D TXF: %s%02X: %sThere now:  +', 00H
	ORG $+1
$SG193658 DB	'HHC17706D TXF: %s%02X: %sWe fetched: +', 00H
	ORG $+1
$SG193659 DB	'HHC17707D TXF: %s%02X: %sWe stored:  +', 00H
	ORG $+1
$SG193660 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1291', 00H
	ORG $+1
$SG193661 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1295', 00H
	ORG $+1
$SG193666 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1332', 00H
	ORG $+1
$SG193667 DB	'TXF trpi+ilc', 00H
	ORG $+3
$SG193669 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1343', 00H
	ORG $+1
$SG193670 DB	'TXF trpi', 00H
	ORG $+7
$SG193684 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1429', 00H
	ORG $+1
$SG193685 DB	'*TXF vrfail', 00H
$SG193687 DB	'SIE: ', 00H
	ORG $+6
$SG193691 DB	'z900_abort_transaction', 00H
	ORG $+1
$SG193690 DB	'HHC17713%s TXF: %s%02X: %sTranslation exception %4.4hX ('
	DB	'%s) for TBEGIN tdba 0x%16.16llx', 0aH, 00H
	ORG $+7
$SG193692 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG193711 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1526', 00H
	ORG $+1
$SG193714 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1541', 00H
	ORG $+1
$SG193715 DB	'*TXF abrtret', 00H
	ORG $+3
$SG193718 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1562', 00H
	ORG $+1
$SG193719 DB	'*TXF abrtjmp', 00H
	ORG $+3
$SG193721 DB	'z900_abort_transaction', 00H
	ORG $+1
$SG193722 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG193725 DB	'z900_abort_transaction', 00H
	ORG $+1
$SG193723 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG193726 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG193730 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1581', 00H
	ORG $+1
$SG194128 DB	'(undefined Abort Code)', 00H
	ORG $+1
$SG193727 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG193731 DB	'*TXF abrtpgm', 00H
	ORG $+3
$SG193780 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1621', 00H
	ORG $+1
$SG193781 DB	'TXF filt?', 00H
	ORG $+6
$SG193834 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1788', 00H
	ORG $+1
$SG193835 DB	'TXF filt!', 00H
	ORG $+6
$SG193836 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1790', 00H
	ORG $+1
$SG193838 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1800', 00H
	ORG $+1
$SG193839 DB	'TXF unfilt!', 00H
	ORG $+4
$SG193840 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1802', 00H
	ORG $+1
$SG193868 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1841', 00H
	ORG $+1
$SG193869 DB	'TXF alloc', 00H
	ORG $+6
$SG193897 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1875', 00H
	ORG $+1
$SG193898 DB	'TXF free', 00H
	ORG $+7
$SG193933 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1917', 00H
	ORG $+1
$SG193936 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1929', 00H
	ORG $+1
$SG193937 DB	'*TXF h delay', 00H
	ORG $+3
$SG193940 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1945', 00H
	ORG $+1
$SG193941 DB	'*TXF g delay', 00H
	ORG $+3
$SG193942 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:1948', 00H
	ORG $+1
$SG194042 DB	'txf_maddr_l', 00H
	ORG $+4
$SG194043 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194046 DB	'txf_maddr_l', 00H
$SG194235 DB	'SIE: ', 00H
	ORG $+6
$SG194044 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG194047 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194052 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2032', 00H
	ORG $+1
$SG194130 DB	'Miscellaneous condition', 00H
$SG194048 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG194053 DB	'*TXF mad TAC', 00H
	ORG $+3
$SG194055 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2037', 00H
	ORG $+1
$SG194056 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2039', 00H
	ORG $+1
$SG194059 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2057', 00H
	ORG $+1
$SG194060 DB	'*TXF mad len', 00H
	ORG $+3
$SG194061 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2058', 00H
	ORG $+1
$SG194067 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2119', 00H
	ORG $+1
$SG194068 DB	'*TXF mad max', 00H
	ORG $+3
$SG194069 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2120', 00H
	ORG $+1
$SG194071 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2143', 00H
	ORG $+1
$SG194072 DB	'TXF maddr_l:', 00H
	ORG $+3
$SG194077 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2182', 00H
	ORG $+1
$SG194078 DB	'TXF maddr_l', 00H
$SG194244 DB	'SIE: ', 00H
	ORG $+6
tac_names DQ	FLAT:$SG194080
	DQ	FLAT:$SG194081
	DQ	FLAT:$SG194082
	DQ	FLAT:$SG194083
	DQ	FLAT:$SG194084
	DQ	FLAT:$SG194085
	DQ	FLAT:$SG194086
	DQ	FLAT:$SG194087
	DQ	FLAT:$SG194088
	DQ	FLAT:$SG194089
	DQ	FLAT:$SG194090
	DQ	FLAT:$SG194091
	DQ	FLAT:$SG194092
	DQ	FLAT:$SG194093
	DQ	FLAT:$SG194094
	DQ	FLAT:$SG194095
	DQ	FLAT:$SG194096
	DQ	FLAT:$SG194097
	DQ	FLAT:$SG194098
	DQ	FLAT:$SG194099
	DQ	FLAT:$SG194100
	DQ	FLAT:$SG194101
	DQ	FLAT:$SG194102
	DQ	FLAT:$SG194103
	DQ	FLAT:$SG194104
	DQ	FLAT:$SG194105
	DQ	FLAT:$SG194106
	DQ	FLAT:$SG194107
	DQ	FLAT:$SG194108
	DQ	FLAT:$SG194109
	DQ	FLAT:$SG194110
	DQ	FLAT:$SG194111
	DQ	FLAT:$SG194112
	DQ	FLAT:$SG194113
	DQ	FLAT:$SG194114
	DQ	FLAT:$SG194115
	DQ	FLAT:$SG194116
	DQ	FLAT:$SG194117
	DQ	FLAT:$SG194118
	DQ	FLAT:$SG194119
$SG194129 DB	'TAC_?????', 00H
	ORG $+6
$SG194131 DB	'TAC_MISC', 00H
	ORG $+7
$SG194132 DB	'TABORT instruction', 00H
	ORG $+5
$SG194133 DB	'TAC_TABORT', 00H
	ORG $+5
$SG194148 DB	' TXF_WHY_CONSTRAINT_4', 00H
	ORG $+2
$SG194150 DB	' TXF_WHY_IDTE_INSTR', 00H
	ORG $+4
$SG194152 DB	' TXF_WHY_IPTE_INSTR', 00H
	ORG $+4
$SG194154 DB	' TXF_WHY_STORKEY', 00H
	ORG $+7
$SG194156 DB	' TXF_WHY_NESTING', 00H
	ORG $+7
$SG194158 DB	' TXF_WHY_TRAN_MISC_INSTR', 00H
	ORG $+7
$SG194160 DB	' TXF_WHY_TRAN_SET_ADDRESSING_MODE', 00H
	ORG $+6
$SG194162 DB	' TXF_WHY_TRAN_BRANCH_SET_MODE', 00H
	ORG $+2
$SG194164 DB	' TXF_WHY_TRAN_NONRELATIVE_BRANCH', 00H
	ORG $+7
$SG194166 DB	' TXF_WHY_TRAN_ACCESS_INSTR', 00H
	ORG $+5
$SG194168 DB	' TXF_WHY_TRAN_FLOAT_INSTR', 00H
	ORG $+6
$SG194170 DB	' TXF_WHY_TRAN_INSTR', 00H
	ORG $+4
$SG194172 DB	' TXF_WHY_CONTRAN_RELATIVE_BRANCH', 00H
	ORG $+7
$SG194174 DB	' TXF_WHY_CONTRAN_BRANCH', 00H
$SG194176 DB	' TXF_WHY_CONTRAN_INSTR', 00H
	ORG $+1
$SG194178 DB	' TXF_WHY_TABORT_INSTR', 00H
	ORG $+2
$SG194180 DB	' TXF_WHY_DELAYED_ABORT', 00H
	ORG $+1
$SG194182 DB	' TXF_WHY_MCK_INT', 00H
	ORG $+7
$SG194184 DB	' TXF_WHY_IO_INT', 00H
$SG194186 DB	' TXF_WHY_RESTART_INT', 00H
	ORG $+3
$SG194188 DB	' TXF_WHY_FILT_INT', 00H
	ORG $+6
$SG194190 DB	' TXF_WHY_UNFILT_INT', 00H
	ORG $+4
$SG194192 DB	' TXF_WHY_EXT_INT', 00H
	ORG $+7
$SG194194 DB	' TXF_WHY_MAX_PAGES', 00H
	ORG $+5
$SG194196 DB	' TXF_WHY_CONFLICT', 00H
	ORG $+6
$SG194198 DB	' TXF_WHY_SIE_EXIT', 00H
	ORG $+6
$SG194200 DB	' TXF_WHY_CSPG_INSTR', 00H
	ORG $+4
$SG194202 DB	' TXF_WHY_CSP_INSTR', 00H
	ORG $+5
$SG194204 DB	' TXF_WHY_RAND_ABORT', 00H
	ORG $+4
$SG194206 DB	' TXF_WHY_INSTRCOUNT', 00H
	ORG $+4
$SG194208 DB	' TXF_WHY_INSTRADDR', 00H
	ORG $+5
$SG194243 DB	'dump_cache()', 00H
	ORG $+3
$SG194247 DB	'HHC17708%s TXF: %s%02X: %sError in function %s: %s', 0aH
	DB	00H
	ORG $+4
$SG194210 DB	'%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s'
	DB	'%s%s%s%s', 00H
	ORG $+7
$SG194241 DB	'dump_cache', 00H
	ORG $+5
$SG194242 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194248 DB	'dump_cache', 00H
	ORG $+5
$SG194249 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194329 DB	'Storage', 00H
$SG194330 DB	'SIE: ', 00H
	ORG $+2
$SG194333 DB	'HHC17709%s TXF: %s%02X: %s%s dump of TDB:', 0aH, 00H
	ORG $+5
$SG194334 DB	'dump_tdb', 00H
	ORG $+7
$SG194335 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG194336 DB	'SIE: ', 00H
	ORG $+6
$SG194339 DB	'HHC17710%s TXF: %s%02X: %s+', 0aH, 00H
	ORG $+3
$SG194344 DB	'dump_tdb', 00H
	ORG $+7
$SG194345 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194346 DB	'dump_tdb()', 00H
	ORG $+1
$SG194347 DB	'SIE: ', 00H
	ORG $+6
$SG194350 DB	'HHC17708%s TXF: %s%02X: %sError in function %s: %s', 0aH
	DB	00H
	ORG $+4
$SG194351 DB	'dump_tdb', 00H
	ORG $+7
$SG194352 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194354 DB	'Formatted', 00H
	ORG $+2
$SG194355 DB	'SIE: ', 00H
	ORG $+6
$SG194358 DB	'HHC17709%s TXF: %s%02X: %s%s dump of TDB:', 0aH, 00H
	ORG $+5
$SG194359 DB	'dump_tdb', 00H
	ORG $+7
$SG194360 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG194363 DB	'none', 00H
	ORG $+7
$SG194364 DB	'TDB_CTI, ', 00H
	ORG $+6
$SG194366 DB	'TDB_CTV, ', 00H
	ORG $+2
$SG194368 DB	'%s%s', 00H
	ORG $+3
$SG194372 DB	'SIE: ', 00H
	ORG $+6
$SG194371 DB	'Fmt: %u, TND: %hu, EAID: %02X, DXC/VXC: %02X, PIID: %08X'
	DB	', Flags: (%s)', 00H
	ORG $+2
$SG194375 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194376 DB	'dump_tdb', 00H
	ORG $+7
$SG194377 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194378 DB	'TAC:   0x%16.16llX: %s = %s', 00H
$SG194379 DB	'SIE: ', 00H
	ORG $+6
$SG194382 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194383 DB	'dump_tdb', 00H
	ORG $+7
$SG194384 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194385 DB	'Token: 0x%16.16llX, ATIA:  0x%16.16llX', 00H
	ORG $+1
$SG194386 DB	'SIE: ', 00H
	ORG $+2
$SG194389 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194390 DB	'dump_tdb', 00H
	ORG $+7
$SG194391 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG194397 DB	'SIE: ', 00H
	ORG $+6
$SG194400 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194401 DB	'dump_tdb', 00H
	ORG $+7
$SG194402 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194404 DB	'%s code %4.4X ilc %d', 00H
	ORG $+3
$SG194405 DB	'SIE: ', 00H
	ORG $+2
$SG194408 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194409 DB	'dump_tdb', 00H
	ORG $+7
$SG194410 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194411 DB	'%16.16llX ', 00H
	ORG $+5
$SG194412 DB	'INST=%2.2X%2.2X', 00H
$SG194414 DB	'%2.2X%2.2X', 00H
	ORG $+5
$SG194416 DB	'%2.2X%2.2X', 00H
	ORG $+5
$SG194417 DB	'        ', 00H
	ORG $+3
$SG194418 DB	'    ', 00H
	ORG $+3
$SG194421 DB	'SIE: ', 00H
	ORG $+6
$SG194424 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194425 DB	'dump_tdb', 00H
	ORG $+7
$SG194426 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+2
$SG194428 DB	'SIE: ', 00H
	ORG $+6
$SG194431 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194432 DB	'dump_tdb', 00H
	ORG $+7
$SG194433 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194434 DB	'TEID:  0x%16.16llX, BEA:   0x%16.16llX', 00H
	ORG $+1
$SG194435 DB	'SIE: ', 00H
	ORG $+2
$SG194438 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194439 DB	'dump_tdb', 00H
	ORG $+7
$SG194440 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194441 DB	'GR %02u: 0x%16.16llX, GR %02u: 0x%16.16llX', 00H
	ORG $+1
$SG194442 DB	'SIE: ', 00H
	ORG $+6
$SG194445 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194446 DB	'dump_tdb', 00H
	ORG $+7
$SG194447 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194448 DB	'GR %02u: 0x%16.16llX, GR %02u: 0x%16.16llX', 00H
	ORG $+1
$SG194449 DB	'SIE: ', 00H
	ORG $+6
$SG194452 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194453 DB	'dump_tdb', 00H
	ORG $+7
$SG194454 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194455 DB	'GR %02u: 0x%16.16llX, GR %02u: 0x%16.16llX', 00H
	ORG $+1
$SG194456 DB	'SIE: ', 00H
	ORG $+6
$SG194459 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194460 DB	'dump_tdb', 00H
	ORG $+7
$SG194461 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194462 DB	'GR %02u: 0x%16.16llX, GR %02u: 0x%16.16llX', 00H
	ORG $+1
$SG194463 DB	'SIE: ', 00H
	ORG $+6
$SG194466 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194467 DB	'dump_tdb', 00H
	ORG $+7
$SG194468 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194469 DB	'GR %02u: 0x%16.16llX, GR %02u: 0x%16.16llX', 00H
	ORG $+1
$SG194470 DB	'SIE: ', 00H
	ORG $+6
$SG194473 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194474 DB	'dump_tdb', 00H
	ORG $+7
$SG194475 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194476 DB	'GR %02u: 0x%16.16llX, GR %02u: 0x%16.16llX', 00H
	ORG $+1
$SG194477 DB	'SIE: ', 00H
	ORG $+6
$SG194480 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194481 DB	'dump_tdb', 00H
	ORG $+7
$SG194482 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194483 DB	'GR %02u: 0x%16.16llX, GR %02u: 0x%16.16llX', 00H
	ORG $+1
$SG194484 DB	'SIE: ', 00H
	ORG $+6
$SG194487 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194488 DB	'dump_tdb', 00H
	ORG $+7
$SG194489 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194490 DB	'GR %02u: 0x%16.16llX, GR %02u: 0x%16.16llX', 00H
	ORG $+1
$SG194491 DB	'SIE: ', 00H
	ORG $+6
$SG194494 DB	'HHC17721%s TXF: %s%02X: %s%s', 0aH, 00H
	ORG $+2
$SG194495 DB	'dump_tdb', 00H
	ORG $+7
$SG194496 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194541 DB	'HHC02385%s CPUMODEL %04X does not technically support TX'
	DB	'F', 0aH, 00H
	ORG $+5
$SG194542 DB	'txf_model_warning', 00H
	ORG $+6
$SG194543 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194557 DB	'txf_set_timerint', 00H
	ORG $+7
$SG194556 DB	'HHC17736%s TXF: TIMERINT %d is too small; using default '
	DB	'of %d instead', 0aH, 00H
	ORG $+1
$SG194558 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194559 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2593', 00H
	ORG $+1
$SG194561 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2598', 00H
	ORG $+1
$SG194562 DB	'rubato_thread', 00H
	ORG $+2
$SG194565 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG194566 DB	'txf_set_timerint', 00H
	ORG $+7
$SG194567 DB	'C:\papa\MyGit\hyperion-zvector\transact.c', 00H
	ORG $+6
$SG194568 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2604', 00H
	ORG $+1
$SG194569 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2609', 00H
	ORG $+1
$SG194570 DB	'C:\papa\MyGit\hyperion-zvector\transact.c:2614', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_validate_operand DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8 DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	0163H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8_full DD 032919H
	DD	07016c21aH
	DD	06015H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck2 DD 011201H
	DD	0a212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:atomic_update64
	DD	014H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:atomic_update32
	DD	012H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_process_tbegin
	DD	027H
	DD	0121fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_abort_transaction
	DD	026H
	DD	0273cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dump_tdb
	DD	01dH
	DD	022efH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dump_cache
	DD	026H
	DD	02d9H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$tac2short DD 010901H
	DD	04209H
$unwind$tac2long DD 010901H
	DD	04209H
$unwind$dump_cache DD 032e19H
	DD	01e011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$dump_tdb DD 042519H
	DD	0870113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0420H
$unwind$txf_why_str DD 021501H
	DD	0450115H
$unwind$is_TXF_model DD 010901H
	DD	02209H
$unwind$defsym_TXF_models DD 010401H
	DD	06204H
$unwind$txf_model_warning DD 010801H
	DD	0a208H
$unwind$txf_set_timerint DD 010801H
	DD	0c208H
$unwind$txf_maddr_l DD 041d01H
	DD	01d011dH
	DD	060157016H
$unwind$s370_abort_transaction DD 011701H
	DD	02217H
$unwind$s390_abort_transaction DD 011701H
	DD	02217H
$unwind$z900_abort_transaction DD 042e19H
	DD	067011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0320H
$unwind$z900_txf_do_pi_filtering DD 021001H
	DD	0110110H
$unwind$alloc_txfmap DD 020a01H
	DD	07006d20aH
$unwind$free_txfmap DD 020a01H
	DD	07006b20aH
$unwind$txf_abort_all DD 011201H
	DD	0a212H
$unwind$synchronize_cpus DD 010e01H
	DD	0a20eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$z900_perform_processor_assist DD 010e01H
	DD	0c20eH
$unwind$z900_transaction_begin_constrained DD 010e01H
	DD	0e20eH
$unwind$z900_transaction_end DD 041301H
	DD	02f0113H
	DD	0600b700cH
$unwind$z900_extract_transaction_nesting_depth DD 010e01H
	DD	0e20eH
$unwind$z900_transaction_abort DD 010e01H
	DD	0e20eH
$unwind$z900_nontransactional_store DD 010e01H
	DD	0c20eH
$unwind$z900_transaction_begin DD 010e01H
	DD	0e20eH
$unwind$z900_process_tbegin DD 042f19H
	DD	025011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0118H
$unwind$tac2name DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
tv68 = 0
tv76 = 8
tv80 = 16
tv83 = 24
tv84 = 32
tac$ = 64
bLong$ = 72
tac2name PROC

; 2231 : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2232 :     if (tac < (_countof( tac_names )/2))

  0000d	48 83 7c 24 40
	14		 cmp	 QWORD PTR tac$[rsp], 20
  00013	73 36		 jae	 SHORT $LN2@tac2name

; 2233 :         return tac_names[ (tac * 2) + (bLong ? 1 : 0) ];

  00015	0f b6 44 24 48	 movzx	 eax, BYTE PTR bLong$[rsp]
  0001a	85 c0		 test	 eax, eax
  0001c	74 09		 je	 SHORT $LN5@tac2name
  0001e	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv68[rsp], 1
  00025	eb 07		 jmp	 SHORT $LN6@tac2name
$LN5@tac2name:
  00027	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
$LN6@tac2name:
  0002e	48 63 04 24	 movsxd	 rax, DWORD PTR tv68[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tac$[rsp]
  00037	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tac_names
  00042	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00046	e9 a1 00 00 00	 jmp	 $LN1@tac2name
$LN2@tac2name:

; 2234 :     if (tac < 255) return (bLong ? "(undefined Abort Code)"  : "TAC_?????"  );

  0004b	48 81 7c 24 40
	ff 00 00 00	 cmp	 QWORD PTR tac$[rsp], 255 ; 000000ffH
  00054	73 2a		 jae	 SHORT $LN3@tac2name
  00056	0f b6 44 24 48	 movzx	 eax, BYTE PTR bLong$[rsp]
  0005b	85 c0		 test	 eax, eax
  0005d	74 0e		 je	 SHORT $LN7@tac2name
  0005f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194128
  00066	48 89 44 24 08	 mov	 QWORD PTR tv76[rsp], rax
  0006b	eb 0c		 jmp	 SHORT $LN8@tac2name
$LN7@tac2name:
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194129
  00074	48 89 44 24 08	 mov	 QWORD PTR tv76[rsp], rax
$LN8@tac2name:
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR tv76[rsp]
  0007e	eb 6c		 jmp	 SHORT $LN1@tac2name
$LN3@tac2name:

; 2235 :     return (tac == 255) ? (bLong ? "Miscellaneous condition" : "TAC_MISC"   )

  00080	48 81 7c 24 40
	ff 00 00 00	 cmp	 QWORD PTR tac$[rsp], 255 ; 000000ffH
  00089	75 2f		 jne	 SHORT $LN13@tac2name
  0008b	0f b6 44 24 48	 movzx	 eax, BYTE PTR bLong$[rsp]
  00090	85 c0		 test	 eax, eax
  00092	74 0e		 je	 SHORT $LN9@tac2name
  00094	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194130
  0009b	48 89 44 24 10	 mov	 QWORD PTR tv80[rsp], rax
  000a0	eb 0c		 jmp	 SHORT $LN10@tac2name
$LN9@tac2name:
  000a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194131
  000a9	48 89 44 24 10	 mov	 QWORD PTR tv80[rsp], rax
$LN10@tac2name:
  000ae	48 8b 44 24 10	 mov	 rax, QWORD PTR tv80[rsp]
  000b3	48 89 44 24 20	 mov	 QWORD PTR tv84[rsp], rax
  000b8	eb 2d		 jmp	 SHORT $LN14@tac2name
$LN13@tac2name:
  000ba	0f b6 44 24 48	 movzx	 eax, BYTE PTR bLong$[rsp]
  000bf	85 c0		 test	 eax, eax
  000c1	74 0e		 je	 SHORT $LN11@tac2name
  000c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194132
  000ca	48 89 44 24 18	 mov	 QWORD PTR tv83[rsp], rax
  000cf	eb 0c		 jmp	 SHORT $LN12@tac2name
$LN11@tac2name:
  000d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194133
  000d8	48 89 44 24 18	 mov	 QWORD PTR tv83[rsp], rax
$LN12@tac2name:
  000dd	48 8b 44 24 18	 mov	 rax, QWORD PTR tv83[rsp]
  000e2	48 89 44 24 20	 mov	 QWORD PTR tv84[rsp], rax
$LN14@tac2name:
  000e7	48 8b 44 24 20	 mov	 rax, QWORD PTR tv84[rsp]
$LN1@tac2name:

; 2236 :                         : (bLong ? "TABORT instruction"      : "TAC_TABORT" );
; 2237 : }

  000ec	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f0	c3		 ret	 0
tac2name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
n$ = 112
tv177 = 116
tv242 = 120
tv251 = 124
tv268 = 128
tv321 = 132
tv427 = 136
pmap$ = 144
tdc$ = 152
tv322 = 156
tv506 = 160
tv525 = 164
tv626 = 168
tv319 = 176
tv511 = 184
tv516 = 192
tv522 = 200
tv617 = 208
tv623 = 216
tv527 = 224
tv628 = 232
origpsw$1 = 240
__$ArrayPad$ = 280
txf_contran$ = 320
regs$ = 328
i2$ = 336
tdba$ = 344
b1$ = 352
z900_process_tbegin PROC

; 754  : {

$LN88:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 755  : int         n, tdc;
; 756  : TPAGEMAP   *pmap;
; 757  : 
; 758  :     /* Temporarily pause other CPUs while TBEGIN/TBEGINC is processed.
; 759  :        NOTE: this *must* be done *BEFORE* checking nesting depth. */
; 760  :     SYNCHRONIZE_CPUS( regs );

  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193295
  00036	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003e	e8 00 00 00 00	 call	 synchronize_cpus

; 761  : 
; 762  :     PERFORM_SERIALIZATION( regs );

  00043	0f ae f0	 mfence

; 763  : 
; 764  :     /* Check for maximum nesting depth exceeded */
; 765  :     if (regs->txf_tnd >= MAX_TXF_TND)

  00046	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00055	83 f8 0f	 cmp	 eax, 15
  00058	0f 8c ac 00 00
	00		 jl	 $LN22@z900_proce
$LN4@z900_proce:

; 766  :     {
; 767  :         PTT_TXF( "*TXF beg", MAX_TXF_TND, regs->txf_contran, regs->txf_tnd );

  0005e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00065	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00068	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  0006e	48 85 c0	 test	 rax, rax
  00071	74 53		 je	 SHORT $LN23@z900_proce
  00073	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00082	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008a	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00091	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0009a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193298
  000a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ab	44 8b c9	 mov	 r9d, ecx
  000ae	41 b8 0f 00 00
	00		 mov	 r8d, 15
  000b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193299
  000bb	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN23@z900_proce:
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 92		 jne	 SHORT $LN4@z900_proce

; 768  :         regs->txf_why |= TXF_WHY_NESTING;

  000cc	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000da	83 c8 20	 or	 eax, 32			; 00000020H
  000dd	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 769  :         ABORT_TRANS( regs, ABORT_RETRY_PGMCHK, TAC_NESTING );

  000eb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193300
  000f2	41 b8 0d 00 00
	00		 mov	 r8d, 13
  000f8	ba 02 00 00 00	 mov	 edx, 2
  000fd	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00105	e8 00 00 00 00	 call	 z900_abort_transaction
$LN22@z900_proce:

; 770  :         UNREACHABLE_CODE( return );
; 771  :     }
; 772  : 
; 773  :     /* Count transaction */
; 774  :     atomic_update32( &sysblk.txf_counter, +1 );

  0010a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00111	48 05 70 05 00
	00		 add	 rax, 1392		; 00000570H
  00117	ba 01 00 00 00	 mov	 edx, 1
  0011c	48 8b c8	 mov	 rcx, rax
  0011f	e8 00 00 00 00	 call	 atomic_update32
$LN7@z900_proce:

; 775  : 
; 776  :     TXFC_INSTR_CHECK( regs );    /* Unallowed in CONSTRAINED mode */

  00124	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00133	85 c0		 test	 eax, eax
  00135	74 3f		 je	 SHORT $LN24@z900_proce
  00137	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00145	0f ba e8 0f	 bts	 eax, 15
  00149	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00151	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00157	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193302
  0015e	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00164	ba 02 00 00 00	 mov	 edx, 2
  00169	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00171	e8 00 00 00 00	 call	 z900_abort_transaction
$LN24@z900_proce:
  00176	33 c0		 xor	 eax, eax
  00178	85 c0		 test	 eax, eax
  0017a	75 a8		 jne	 SHORT $LN7@z900_proce

; 777  : 
; 778  :     /*---------------------------------------------*/
; 779  :     /*  Increase nesting depth                     */
; 780  :     /*---------------------------------------------*/
; 781  :     OBTAIN_TXFLOCK( regs );

  0017c	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00184	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0018b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00192	48 8d 84 c1 48
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+840]
  0019a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193303
  001a1	48 8b c8	 mov	 rcx, rax
  001a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 782  :     {
; 783  :         regs->txf_tnd++;

  001aa	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b2	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  001b9	fe c0		 inc	 al
  001bb	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c3	88 81 58 0e 00
	00		 mov	 BYTE PTR [rcx+3672], al

; 784  :     }
; 785  :     RELEASE_TXFLOCK( regs );

  001c9	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d1	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  001d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001df	48 8d 84 c1 48
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+840]
  001e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193304
  001ee	48 8b c8	 mov	 rcx, rax
  001f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 786  : 
; 787  :     /* set cc=0 at transaction start */
; 788  :     regs->psw.cc = TXF_CC_SUCCESS;

  001f7	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ff	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN10@z900_proce:

; 789  : 
; 790  :     TXF_TRACE_INIT( regs );

  00203	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020b	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00213	8b 89 84 af 00
	00		 mov	 ecx, DWORD PTR [rcx+44932]
  00219	89 88 ac af 00
	00		 mov	 DWORD PTR [rax+44972], ecx
  0021f	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00227	0f bf 80 3c 08
	00 00		 movsx	 eax, WORD PTR [rax+2108]
  0022e	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00236	89 81 b0 af 00
	00		 mov	 DWORD PTR [rcx+44976], eax
  0023c	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00244	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0024b	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00253	89 81 b4 af 00
	00		 mov	 DWORD PTR [rcx+44980], eax
  00259	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00261	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00269	8b 89 08 af 00
	00		 mov	 ecx, DWORD PTR [rcx+44808]
  0026f	89 88 b8 af 00
	00		 mov	 DWORD PTR [rax+44984], ecx
  00275	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0027d	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	8b 89 50 0e 00
	00		 mov	 ecx, DWORD PTR [rcx+3664]
  0028b	89 88 bc af 00
	00		 mov	 DWORD PTR [rax+44988], ecx
  00291	33 c0		 xor	 eax, eax
  00293	85 c0		 test	 eax, eax
  00295	0f 85 68 ff ff
	ff		 jne	 $LN10@z900_proce

; 791  : 
; 792  :     /* first/outermost transaction? */
; 793  :     if (regs->txf_tnd == 1)

  0029b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a3	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  002aa	83 f8 01	 cmp	 eax, 1
  002ad	0f 85 6e 05 00
	00		 jne	 $LN25@z900_proce

; 794  :     {
; 795  :         /*-----------------------------------------------------------*/
; 796  :         /*              BEGIN OUTERMOST TRANSACTION                  */
; 797  :         /*-----------------------------------------------------------*/
; 798  : 
; 799  :         /* Count total transactions */
; 800  :         if (!regs->txf_aborts)

  002b3	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bb	83 b8 50 0e 00
	00 00		 cmp	 DWORD PTR [rax+3664], 0
  002c2	75 46		 jne	 SHORT $LN27@z900_proce

; 801  :             TXF_STATS( trans, txf_contran );

  002c4	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  002cc	85 c0		 test	 eax, eax
  002ce	74 0a		 je	 SHORT $LN66@z900_proce
  002d0	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv177[rsp], 1
  002d8	eb 08		 jmp	 SHORT $LN67@z900_proce
$LN66@z900_proce:
  002da	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv177[rsp], 0
$LN67@z900_proce:
  002e2	48 63 44 24 74	 movsxd	 rax, DWORD PTR tv177[rsp]
  002e7	48 69 c0 e8 00
	00 00		 imul	 rax, rax, 232		; 000000e8H
  002ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002f5	48 8d 84 01 78
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax+1400]
  002fd	ba 01 00 00 00	 mov	 edx, 1
  00302	48 8b c8	 mov	 rcx, rax
  00305	e8 00 00 00 00	 call	 atomic_update64
$LN27@z900_proce:

; 802  : 
; 803  :         /* Set internal TDB to invalid until it's actually populated */
; 804  :         memset( &regs->txf_tdb, 0, sizeof( TDB ));

  0030a	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00312	48 05 4b 0d 00
	00		 add	 rax, 3403		; 00000d4bH
  00318	48 8b f8	 mov	 rdi, rax
  0031b	33 c0		 xor	 eax, eax
  0031d	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00322	f3 aa		 rep stosb

; 805  : 
; 806  :         /* Initialize the page map */
; 807  : 
; 808  :         pmap = regs->txf_pagesmap;

  00324	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0032c	48 05 80 0e 00
	00		 add	 rax, 3712		; 00000e80H
  00332	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pmap$[rsp], rax

; 809  :         regs->txf_pgcnt = 0;

  0033a	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00342	c7 80 80 ae 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+44672], 0

; 810  : 
; 811  :         for (n=0; n < MAX_TXF_PAGES; n++, pmap++)

  0034c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00354	eb 1e		 jmp	 SHORT $LN13@z900_proce
$LN11@z900_proce:
  00356	8b 44 24 70	 mov	 eax, DWORD PTR n$[rsp]
  0035a	ff c0		 inc	 eax
  0035c	89 44 24 70	 mov	 DWORD PTR n$[rsp], eax
  00360	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pmap$[rsp]
  00368	48 83 c0 28	 add	 rax, 40			; 00000028H
  0036c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pmap$[rsp], rax
$LN13@z900_proce:
  00374	81 7c 24 70 00
	04 00 00	 cmp	 DWORD PTR n$[rsp], 1024	; 00000400H
  0037c	7d 2a		 jge	 SHORT $LN12@z900_proce

; 812  :         {
; 813  :             pmap->mainpageaddr = NULL;

  0037e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pmap$[rsp]
  00386	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 814  :             memset( pmap->cachemap, CM_CLEAN, sizeof( pmap->cachemap ));

  0038e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pmap$[rsp]
  00396	48 83 c0 18	 add	 rax, 24
  0039a	48 8b f8	 mov	 rdi, rax
  0039d	33 c0		 xor	 eax, eax
  0039f	b9 10 00 00 00	 mov	 ecx, 16
  003a4	f3 aa		 rep stosb

; 815  :         }

  003a6	eb ae		 jmp	 SHORT $LN11@z900_proce
$LN12@z900_proce:

; 816  : 
; 817  :         /* Initialize other fields */
; 818  : 
; 819  :         regs->txf_UPGM_abort = false;      /* reset flag             */

  003a8	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b0	c6 80 4d 0e 00
	00 00		 mov	 BYTE PTR [rax+3661], 0

; 820  :         regs->txf_contran    = txf_contran;/* set transaction type   */

  003b7	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003bf	0f b6 8c 24 40
	01 00 00	 movzx	 ecx, BYTE PTR txf_contran$[rsp]
  003c7	88 88 4c 0e 00
	00		 mov	 BYTE PTR [rax+3660], cl

; 821  :         regs->txf_instctr    = 0;          /* instruction counter    */

  003cd	33 c0		 xor	 eax, eax
  003cf	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d7	66 89 81 5e 0e
	00 00		 mov	 WORD PTR [rcx+3678], ax

; 822  :         regs->txf_abortctr   = 0;          /* abort instr count      */

  003de	33 c0		 xor	 eax, eax
  003e0	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e8	66 89 81 60 0e
	00 00		 mov	 WORD PTR [rcx+3680], ax

; 823  :         regs->txf_tac        = 0;          /* clear the abort code   */

  003ef	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f7	c7 80 08 af 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+44808], 0

; 824  :         regs->txf_conflict   = 0;          /* clear conflict address */

  00401	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00409	48 c7 80 78 0e
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+3704], 0

; 825  :         regs->txf_piid       = 0;          /* program interrupt id   */

  00414	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0041c	c7 80 7c af 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+44924], 0

; 826  :         regs->txf_lastarn    = 0;          /* last access arn        */

  00426	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0042e	c7 80 88 af 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+44936], 0

; 827  :         regs->txf_why        = 0;          /* no abort cause (yet)   */

  00438	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00440	c7 80 84 af 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+44932], 0

; 828  : 
; 829  :         memcpy( regs->txf_savedgr, regs->gr, sizeof( regs->txf_savedgr ));

  0044a	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00452	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045a	48 8d b8 88 ae
	00 00		 lea	 rdi, QWORD PTR [rax+44680]
  00461	48 8d b1 80 02
	00 00		 lea	 rsi, QWORD PTR [rcx+640]
  00468	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0046d	f3 a4		 rep movsb

; 830  :         memset( regs->txf_pifctab, 0, sizeof( regs->txf_pifctab ));

  0046f	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00477	48 05 8c af 00
	00		 add	 rax, 44940		; 0000af8cH
  0047d	48 8b f8	 mov	 rdi, rax
  00480	33 c0		 xor	 eax, eax
  00482	b9 1e 00 00 00	 mov	 ecx, 30
  00487	f3 aa		 rep stosb

; 831  : 
; 832  :         regs->txf_ctlflag      = (i2 >> 0) & (TXF_CTL_AR | TXF_CTL_FLOAT);

  00489	0f bf 84 24 50
	01 00 00	 movsx	 eax, WORD PTR i2$[rsp]
  00491	83 e0 0c	 and	 eax, 12
  00494	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049c	88 81 59 0e 00
	00		 mov	 BYTE PTR [rcx+3673], al

; 833  :         regs->txf_pifc         = (i2 >> 0) & (TXF_CTL_PIFC);

  004a2	0f bf 84 24 50
	01 00 00	 movsx	 eax, WORD PTR i2$[rsp]
  004aa	83 e0 03	 and	 eax, 3
  004ad	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b5	66 89 81 62 0e
	00 00		 mov	 WORD PTR [rcx+3682], ax

; 834  :         regs->txf_gprmask      = (i2 >> 8) & (0xFF);

  004bc	0f bf 84 24 50
	01 00 00	 movsx	 eax, WORD PTR i2$[rsp]
  004c4	c1 f8 08	 sar	 eax, 8
  004c7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004cc	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d4	88 81 84 ae 00
	00		 mov	 BYTE PTR [rcx+44676], al

; 835  :         regs->txf_higharchange = (regs->txf_ctlflag & TXF_CTL_AR)    ? regs->txf_tnd : 0;

  004da	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e2	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  004e9	83 e0 08	 and	 eax, 8
  004ec	85 c0		 test	 eax, eax
  004ee	74 15		 je	 SHORT $LN68@z900_proce
  004f0	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f8	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  004ff	89 44 24 78	 mov	 DWORD PTR tv242[rsp], eax
  00503	eb 08		 jmp	 SHORT $LN69@z900_proce
$LN68@z900_proce:
  00505	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv242[rsp], 0
$LN69@z900_proce:
  0050d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00515	0f b7 4c 24 78	 movzx	 ecx, WORD PTR tv242[rsp]
  0051a	66 89 88 5a 0e
	00 00		 mov	 WORD PTR [rax+3674], cx

; 836  :         regs->txf_highfloat    = (regs->txf_ctlflag & TXF_CTL_FLOAT) ? regs->txf_tnd : 0;

  00521	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00529	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00530	83 e0 04	 and	 eax, 4
  00533	85 c0		 test	 eax, eax
  00535	74 15		 je	 SHORT $LN70@z900_proce
  00537	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0053f	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00546	89 44 24 7c	 mov	 DWORD PTR tv251[rsp], eax
  0054a	eb 08		 jmp	 SHORT $LN71@z900_proce
$LN70@z900_proce:
  0054c	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv251[rsp], 0
$LN71@z900_proce:
  00554	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0055c	0f b7 4c 24 7c	 movzx	 ecx, WORD PTR tv251[rsp]
  00561	66 89 88 5c 0e
	00 00		 mov	 WORD PTR [rax+3676], cx

; 837  :         regs->txf_tdba         = tdba;

  00568	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00570	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tdba$[rsp]
  00578	48 89 88 68 0e
	00 00		 mov	 QWORD PTR [rax+3688], rcx

; 838  :         regs->txf_tdba_b1      = b1;

  0057f	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00587	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR b1$[rsp]
  0058e	89 88 70 0e 00
	00		 mov	 DWORD PTR [rax+3696], ecx

; 839  : 
; 840  :         /* Set CONSTRAINED trans instruction fetch constraint */
; 841  :         if (txf_contran)

  00594	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  0059c	85 c0		 test	 eax, eax
  0059e	74 0d		 je	 SHORT $LN28@z900_proce

; 842  :             ARCH_DEP( set_txf_aie )( regs );

  005a0	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a8	e8 00 00 00 00	 call	 z900_set_txf_aie
$LN28@z900_proce:

; 843  : 
; 844  :         /*----------------------------------*/
; 845  :         /*  Save the Transaction Abort PSW  */
; 846  :         /*----------------------------------*/
; 847  :         {
; 848  :             PSW origpsw;
; 849  :             memcpy( &origpsw, &regs->psw, sizeof( PSW ));

  005ad	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR origpsw$1[rsp]
  005b5	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005bd	48 8b f8	 mov	 rdi, rax
  005c0	48 8d 71 78	 lea	 rsi, QWORD PTR [rcx+120]
  005c4	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  005c9	f3 a4		 rep movsb

; 850  :             {
; 851  :                 n = txf_contran ? -6 : 0;

  005cb	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  005d3	85 c0		 test	 eax, eax
  005d5	74 0d		 je	 SHORT $LN72@z900_proce
  005d7	c7 84 24 80 00
	00 00 fa ff ff
	ff		 mov	 DWORD PTR tv268[rsp], -6
  005e2	eb 0b		 jmp	 SHORT $LN73@z900_proce
$LN72@z900_proce:
  005e4	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv268[rsp], 0
$LN73@z900_proce:
  005ef	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv268[rsp]
  005f6	89 44 24 70	 mov	 DWORD PTR n$[rsp], eax

; 852  :                 regs->psw.IA = PSW_IA_FROM_IP( regs, n );

  005fa	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00602	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0060a	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00611	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00615	48 2b c1	 sub	 rax, rcx
  00618	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00620	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00627	48 03 c8	 add	 rcx, rax
  0062a	48 8b c1	 mov	 rax, rcx
  0062d	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR n$[rsp]
  00632	48 03 c1	 add	 rax, rcx
  00635	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0063d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00644	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0064c	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 853  :                 memcpy( &regs->txf_tapsw, &regs->psw, sizeof( PSW ));

  00653	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0065b	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00663	48 8d b8 20 af
	00 00		 lea	 rdi, QWORD PTR [rax+44832]
  0066a	48 8d 71 78	 lea	 rsi, QWORD PTR [rcx+120]
  0066e	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00673	f3 a4		 rep movsb

; 854  :                 regs->txf_ip  = regs->ip;

  00675	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0067d	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00685	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00689	48 89 88 48 af
	00 00		 mov	 QWORD PTR [rax+44872], rcx

; 855  :                 regs->txf_aip = regs->aip;

  00690	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00698	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a0	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  006a7	48 89 88 50 af
	00 00		 mov	 QWORD PTR [rax+44880], rcx

; 856  :                 regs->txf_aiv = regs->aiv;

  006ae	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006b6	48 8b 80 10 02
	00 00		 mov	 rax, QWORD PTR [rax+528]
  006bd	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c5	48 89 81 58 af
	00 00		 mov	 QWORD PTR [rcx+44888], rax

; 857  :             }
; 858  :             memcpy( &regs->psw, &origpsw, sizeof( PSW ));

  006cc	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006d4	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR origpsw$1[rsp]
  006dc	48 8d 78 78	 lea	 rdi, QWORD PTR [rax+120]
  006e0	48 8b f1	 mov	 rsi, rcx
  006e3	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  006e8	f3 a4		 rep movsb

; 859  :         }
; 860  : 
; 861  :         /* Honor TDC (Transaction Diagnostic Control) setting */
; 862  : 
; 863  :         tdc = (int)

  006ea	33 c0		 xor	 eax, eax
  006ec	83 f8 01	 cmp	 eax, 1
  006ef	74 43		 je	 SHORT $LN74@z900_proce
  006f1	b8 08 00 00 00	 mov	 eax, 8
  006f6	48 6b c0 03	 imul	 rax, rax, 3
  006fa	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00702	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0070a	48 83 e0 04	 and	 rax, 4
  0070e	48 85 c0	 test	 rax, rax
  00711	74 21		 je	 SHORT $LN74@z900_proce
  00713	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0071b	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0071f	83 e0 01	 and	 eax, 1
  00722	85 c0		 test	 eax, eax
  00724	75 0e		 jne	 SHORT $LN74@z900_proce
  00726	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv319[rsp], 0
  00732	eb 25		 jmp	 SHORT $LN75@z900_proce
$LN74@z900_proce:
  00734	b8 08 00 00 00	 mov	 eax, 8
  00739	48 6b c0 03	 imul	 rax, rax, 3
  0073d	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00745	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0074d	48 83 e0 03	 and	 rax, 3
  00751	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv319[rsp], rax
$LN75@z900_proce:
  00759	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv319[rsp]
  00760	89 84 24 98 00
	00 00		 mov	 DWORD PTR tdc$[rsp], eax

; 864  :         (1
; 865  :          && (regs->CR(2) & CR2_TDS)     /* TDC applies ONLY in problem state */
; 866  :          && !PROBSTATE( &regs->psw )    /* but CPU is *NOT* in problem state */
; 867  :         )
; 868  :         ? TDC_NORMAL                    /* Treat as if TDC contained zero    */
; 869  :         : (regs->CR(2) & CR2_TDC);      /* Otherwise, honor the TDC value    */
; 870  : 
; 871  :         switch (tdc)

  00767	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tdc$[rsp]
  0076e	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv321[rsp], eax
  00775	83 bc 24 84 00
	00 00 01	 cmp	 DWORD PTR tv321[rsp], 1
  0077d	74 2f		 je	 SHORT $LN34@z900_proce
  0077f	83 bc 24 84 00
	00 00 02	 cmp	 DWORD PTR tv321[rsp], 2
  00787	74 05		 je	 SHORT $LN32@z900_proce

; 872  :         {
; 873  :             default:
; 874  :             case TDC_NORMAL:                /* NEVER randomly abort */
; 875  :             case TDC_RESERVED:
; 876  : 
; 877  :                 break;

  00789	e9 8e 00 00 00	 jmp	 $LN14@z900_proce
$LN32@z900_proce:

; 878  : 
; 879  :             case TDC_MAYBE_RANDOM:          /* MAYBE randomly abort */
; 880  : 
; 881  :                 if (rand() >= rand())

  0078e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00794	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv322[rsp], eax
  0079b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  007a1	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv322[rsp]
  007a8	3b c8		 cmp	 ecx, eax
  007aa	7c 02		 jl	 SHORT $LN33@z900_proce

; 882  :                     break;

  007ac	eb 6e		 jmp	 SHORT $LN14@z900_proce
$LN33@z900_proce:
$LN34@z900_proce:

; 883  : 
; 884  :                 /* Fall through to choose when to randomly abort */
; 885  :                 /* FALLTHRU */
; 886  : 
; 887  :             case TDC_ALWAYS_RANDOM:         /* ALWAYS randomly abort */
; 888  :             {
; 889  :                 /* Choose a random instruction to abort at */
; 890  :                 regs->txf_abortctr = (U16) (rand() % MAX_TXF_CONTRAN_INSTR);

  007ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  007b4	99		 cdq
  007b5	83 e2 1f	 and	 edx, 31
  007b8	03 c2		 add	 eax, edx
  007ba	83 e0 1f	 and	 eax, 31
  007bd	2b c2		 sub	 eax, edx
  007bf	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007c7	66 89 81 60 0e
	00 00		 mov	 WORD PTR [rcx+3680], ax

; 891  : 
; 892  :                 if (!txf_contran)

  007ce	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  007d6	85 c0		 test	 eax, eax
  007d8	75 14		 jne	 SHORT $LN35@z900_proce

; 893  :                     regs->txf_random_tac = (U16) 0;

  007da	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007e2	c7 80 0c af 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+44812], 0
  007ec	eb 2e		 jmp	 SHORT $LN36@z900_proce
$LN35@z900_proce:

; 894  :                 else
; 895  :                 {
; 896  :                     /* Randomly chosen abort codes */
; 897  :                     static const BYTE racode[10] =
; 898  :                     {
; 899  :                         TAC_FETCH_OVF,
; 900  :                         TAC_STORE_OVF,
; 901  :                         TAC_FETCH_CNF,
; 902  :                         TAC_STORE_CNF,
; 903  :                         TAC_INSTR,
; 904  :                         TAC_NESTING,
; 905  :                         TAC_FETCH_OTH,
; 906  :                         TAC_STORE_OTH,
; 907  :                         TAC_CACHE_OTH,
; 908  :                         TAC_MISC,
; 909  :                     };
; 910  : 
; 911  :                     /* Choose a random abort code */
; 912  :                     regs->txf_random_tac = (U16) racode[ rand() % _countof( racode ) ];

  007ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  007f4	48 98		 cdqe
  007f6	33 d2		 xor	 edx, edx
  007f8	b9 0a 00 00 00	 mov	 ecx, 10
  007fd	48 f7 f1	 div	 rcx
  00800	48 8b c2	 mov	 rax, rdx
  00803	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?racode@?BA@??z900_process_tbegin@@9@9
  0080a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0080e	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00816	89 81 0c af 00
	00		 mov	 DWORD PTR [rcx+44812], eax
$LN36@z900_proce:
$LN14@z900_proce:

; 913  :                 }
; 914  :                 break;
; 915  :             }
; 916  :         }
; 917  :     }

  0081c	e9 81 02 00 00	 jmp	 $LN26@z900_proce
$LN25@z900_proce:

; 918  :     else /* (nested transaction) */
; 919  :     {
; 920  :         /*------------------------------------------------------*/
; 921  :         /*              BEGIN NESTED TRANSACTION                */
; 922  :         /*------------------------------------------------------*/
; 923  : 
; 924  :         if (txf_contran)

  00821	0f b6 84 24 40
	01 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  00829	85 c0		 test	 eax, eax
  0082b	0f 84 f9 00 00
	00		 je	 $LN37@z900_proce

; 925  :         {
; 926  :             /* Nested CONSTRAINED transactions are not allowed */
; 927  :             if (regs->txf_contran)

  00831	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00839	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00840	85 c0		 test	 eax, eax
  00842	0f 84 ac 00 00
	00		 je	 $LN38@z900_proce
$LN18@z900_proce:

; 928  :             {
; 929  :                 PTT_TXF( "*TXF begc", MAX_TXF_TND, regs->txf_contran, regs->txf_tnd );

  00848	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0084f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00852	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00858	48 85 c0	 test	 rax, rax
  0085b	74 53		 je	 SHORT $LN39@z900_proce
  0085d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00865	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0086c	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00874	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  0087b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00884	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00889	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193320
  00890	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00895	44 8b c9	 mov	 r9d, ecx
  00898	41 b8 0f 00 00
	00		 mov	 r8d, 15
  0089e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193321
  008a5	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  008aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@z900_proce:
  008b0	33 c0		 xor	 eax, eax
  008b2	85 c0		 test	 eax, eax
  008b4	75 92		 jne	 SHORT $LN18@z900_proce

; 930  :                 regs->txf_why |= TXF_WHY_NESTING;

  008b6	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008be	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  008c4	83 c8 20	 or	 eax, 32			; 00000020H
  008c7	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008cf	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 931  :                 ABORT_TRANS( regs, ABORT_RETRY_PGMCHK, TAC_NESTING );

  008d5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193322
  008dc	41 b8 0d 00 00
	00		 mov	 r8d, 13
  008e2	ba 02 00 00 00	 mov	 edx, 2
  008e7	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ef	e8 00 00 00 00	 call	 z900_abort_transaction
$LN38@z900_proce:

; 932  :                 UNREACHABLE_CODE( return );
; 933  :             }
; 934  : 
; 935  :             /* CONSTRAINED nested within unconstrained... */
; 936  : 
; 937  :             /* For CONSTRAINED transactions, if the transaction
; 938  :                nesting depth is already greater than zero (i.e.
; 939  :                the CPU is already in the unconstrained TX mode),
; 940  :                then execution simply proceeds as if this were a
; 941  :                unconstrained transaction. (The TX mode does NOT
; 942  :                switch to constrained mode)
; 943  : 
; 944  :                In this case, the effective F control is zeroed,
; 945  :                and the effective PIFC remains unchanged. This
; 946  :                allows an outer, nonconstrained transaction to
; 947  :                call a service function that may use constrained
; 948  :                TX mode.
; 949  :             */
; 950  :             i2 &= ~(TXF_CTL_FLOAT | TXF_CTL_PIFC);

  008f4	0f bf 84 24 50
	01 00 00	 movsx	 eax, WORD PTR i2$[rsp]
  008fc	83 e0 f8	 and	 eax, -8
  008ff	66 89 84 24 50
	01 00 00	 mov	 WORD PTR i2$[rsp], ax

; 951  :             i2 |= regs->txf_pifc;

  00907	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0090f	0f b7 80 62 0e
	00 00		 movzx	 eax, WORD PTR [rax+3682]
  00916	0f bf 8c 24 50
	01 00 00	 movsx	 ecx, WORD PTR i2$[rsp]
  0091e	0b c8		 or	 ecx, eax
  00920	8b c1		 mov	 eax, ecx
  00922	66 89 84 24 50
	01 00 00	 mov	 WORD PTR i2$[rsp], ax
$LN37@z900_proce:

; 952  :         }
; 953  : 
; 954  :         /*------------------------------------------------------*/
; 955  :         /* Update highest nesting level that allowed AR changes */
; 956  :         /*------------------------------------------------------*/
; 957  : 
; 958  :         if (!(i2 & TXF_CTL_AR))

  0092a	0f bf 84 24 50
	01 00 00	 movsx	 eax, WORD PTR i2$[rsp]
  00932	83 e0 08	 and	 eax, 8
  00935	85 c0		 test	 eax, eax
  00937	75 22		 jne	 SHORT $LN40@z900_proce

; 959  :             regs->txf_ctlflag &= ~TXF_CTL_AR;

  00939	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00941	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00948	83 e0 f7	 and	 eax, -9
  0094b	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00953	88 81 59 0e 00
	00		 mov	 BYTE PTR [rcx+3673], al
  00959	eb 42		 jmp	 SHORT $LN41@z900_proce
$LN40@z900_proce:

; 960  :         else if (regs->txf_higharchange == (regs->txf_tnd - 1))

  0095b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00963	0f b7 80 5a 0e
	00 00		 movzx	 eax, WORD PTR [rax+3674]
  0096a	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00972	0f b6 89 58 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3672]
  00979	ff c9		 dec	 ecx
  0097b	3b c1		 cmp	 eax, ecx
  0097d	75 1e		 jne	 SHORT $LN42@z900_proce

; 961  :             regs->txf_higharchange = regs->txf_tnd;

  0097f	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00987	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0098e	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00996	66 89 81 5a 0e
	00 00		 mov	 WORD PTR [rcx+3674], ax
$LN42@z900_proce:
$LN41@z900_proce:

; 962  : 
; 963  :         /*--------------------------------------------------------------*/
; 964  :         /* Update highest nesting level that allowed float instructions */
; 965  :         /*--------------------------------------------------------------*/
; 966  : 
; 967  :         if (!(i2 & TXF_CTL_FLOAT))

  0099d	0f bf 84 24 50
	01 00 00	 movsx	 eax, WORD PTR i2$[rsp]
  009a5	83 e0 04	 and	 eax, 4
  009a8	85 c0		 test	 eax, eax
  009aa	75 22		 jne	 SHORT $LN43@z900_proce

; 968  :             regs->txf_ctlflag &= ~TXF_CTL_FLOAT;

  009ac	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009b4	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  009bb	83 e0 fb	 and	 eax, -5
  009be	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009c6	88 81 59 0e 00
	00		 mov	 BYTE PTR [rcx+3673], al
  009cc	eb 42		 jmp	 SHORT $LN44@z900_proce
$LN43@z900_proce:

; 969  :         else if (regs->txf_highfloat == (regs->txf_tnd - 1))

  009ce	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009d6	0f b7 80 5c 0e
	00 00		 movzx	 eax, WORD PTR [rax+3676]
  009dd	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009e5	0f b6 89 58 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3672]
  009ec	ff c9		 dec	 ecx
  009ee	3b c1		 cmp	 eax, ecx
  009f0	75 1e		 jne	 SHORT $LN45@z900_proce

; 970  :             regs->txf_highfloat = regs->txf_tnd;

  009f2	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009fa	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00a01	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a09	66 89 81 5c 0e
	00 00		 mov	 WORD PTR [rcx+3676], ax
$LN45@z900_proce:
$LN44@z900_proce:

; 971  : 
; 972  :         /*-----------------------------*/
; 973  :         /* Update program filter level */
; 974  :         /*-----------------------------*/
; 975  : 
; 976  :         regs->txf_pifctab[ regs->txf_tnd - 2 ] = regs->txf_pifc;

  00a10	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a18	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00a1f	83 e8 02	 sub	 eax, 2
  00a22	48 98		 cdqe
  00a24	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a2c	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a34	0f b7 92 62 0e
	00 00		 movzx	 edx, WORD PTR [rdx+3682]
  00a3b	66 89 94 41 8c
	af 00 00	 mov	 WORD PTR [rcx+rax*2+44940], dx

; 977  :         regs->txf_pifc = MAX( regs->txf_pifc, (i2 & TXF_CTL_PIFC) );

  00a43	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a4b	0f b7 80 62 0e
	00 00		 movzx	 eax, WORD PTR [rax+3682]
  00a52	0f bf 8c 24 50
	01 00 00	 movsx	 ecx, WORD PTR i2$[rsp]
  00a5a	83 e1 03	 and	 ecx, 3
  00a5d	3b c1		 cmp	 eax, ecx
  00a5f	7e 18		 jle	 SHORT $LN76@z900_proce
  00a61	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a69	0f b7 80 62 0e
	00 00		 movzx	 eax, WORD PTR [rax+3682]
  00a70	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv427[rsp], eax
  00a77	eb 12		 jmp	 SHORT $LN77@z900_proce
$LN76@z900_proce:
  00a79	0f bf 84 24 50
	01 00 00	 movsx	 eax, WORD PTR i2$[rsp]
  00a81	83 e0 03	 and	 eax, 3
  00a84	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv427[rsp], eax
$LN77@z900_proce:
  00a8b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a93	0f b7 8c 24 88
	00 00 00	 movzx	 ecx, WORD PTR tv427[rsp]
  00a9b	66 89 88 62 0e
	00 00		 mov	 WORD PTR [rax+3682], cx
$LN26@z900_proce:
$LN21@z900_proce:

; 978  :     }
; 979  : 
; 980  :     PTT_TXF( "TXF beg", 0, regs->txf_contran, regs->txf_tnd );

  00aa2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00aa9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00aac	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00ab2	48 85 c0	 test	 rax, rax
  00ab5	74 50		 je	 SHORT $LN46@z900_proce
  00ab7	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00abf	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00ac6	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ace	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00ad5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00ade	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00ae3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193330
  00aea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00aef	44 8b c9	 mov	 r9d, ecx
  00af2	45 33 c0	 xor	 r8d, r8d
  00af5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193331
  00afc	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00b01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN46@z900_proce:
  00b07	33 c0		 xor	 eax, eax
  00b09	85 c0		 test	 eax, eax
  00b0b	75 95		 jne	 SHORT $LN21@z900_proce

; 981  : 
; 982  :     if (TXF_TRACE( regs, SUCCESS, regs->txf_contran ))

  00b0d	33 c0		 xor	 eax, eax
  00b0f	83 f8 01	 cmp	 eax, 1
  00b12	0f 84 89 03 00
	00		 je	 $LN47@z900_proce
  00b18	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b1f	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00b25	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00b2a	85 c0		 test	 eax, eax
  00b2c	0f 84 6f 03 00
	00		 je	 $LN47@z900_proce
  00b32	33 c0		 xor	 eax, eax
  00b34	83 f8 01	 cmp	 eax, 1
  00b37	0f 84 64 03 00
	00		 je	 $LN47@z900_proce
  00b3d	33 c0		 xor	 eax, eax
  00b3f	85 c0		 test	 eax, eax
  00b41	75 37		 jne	 SHORT $LN48@z900_proce
  00b43	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b4a	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00b50	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00b55	85 c0		 test	 eax, eax
  00b57	74 21		 je	 SHORT $LN48@z900_proce
  00b59	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b61	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00b68	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  00b6e	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00b74	0f 85 27 03 00
	00		 jne	 $LN47@z900_proce
$LN48@z900_proce:
  00b7a	33 c0		 xor	 eax, eax
  00b7c	85 c0		 test	 eax, eax
  00b7e	75 37		 jne	 SHORT $LN49@z900_proce
  00b80	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b87	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00b8d	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00b92	85 c0		 test	 eax, eax
  00b94	74 21		 je	 SHORT $LN49@z900_proce
  00b96	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b9e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00ba5	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  00bab	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  00bb1	0f 8c ea 02 00
	00		 jl	 $LN47@z900_proce
$LN49@z900_proce:
  00bb7	33 c0		 xor	 eax, eax
  00bb9	85 c0		 test	 eax, eax
  00bbb	75 73		 jne	 SHORT $LN50@z900_proce
  00bbd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00bc4	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00bca	25 00 00 00 0c	 and	 eax, 201326592		; 0c000000H
  00bcf	3d 00 00 00 0c	 cmp	 eax, 201326592		; 0c000000H
  00bd4	74 5a		 je	 SHORT $LN50@z900_proce
  00bd6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00bdd	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00be3	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00be8	85 c0		 test	 eax, eax
  00bea	74 13		 je	 SHORT $LN51@z900_proce
  00bec	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bf4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00bfb	85 c0		 test	 eax, eax
  00bfd	75 31		 jne	 SHORT $LN50@z900_proce
$LN51@z900_proce:
  00bff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c06	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00c0c	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00c11	85 c0		 test	 eax, eax
  00c13	0f 84 88 02 00
	00		 je	 $LN47@z900_proce
  00c19	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c21	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00c28	85 c0		 test	 eax, eax
  00c2a	0f 85 71 02 00
	00		 jne	 $LN47@z900_proce
$LN50@z900_proce:
  00c30	33 c0		 xor	 eax, eax
  00c32	85 c0		 test	 eax, eax
  00c34	0f 85 e0 00 00
	00		 jne	 $LN52@z900_proce
  00c3a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c41	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00c47	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00c4c	85 c0		 test	 eax, eax
  00c4e	0f 84 c6 00 00
	00		 je	 $LN52@z900_proce
  00c54	33 c0		 xor	 eax, eax
  00c56	83 f8 01	 cmp	 eax, 1
  00c59	0f 84 42 02 00
	00		 je	 $LN47@z900_proce
  00c5f	33 c0		 xor	 eax, eax
  00c61	85 c0		 test	 eax, eax
  00c63	75 3b		 jne	 SHORT $LN53@z900_proce
  00c65	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c6c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00c72	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00c77	85 c0		 test	 eax, eax
  00c79	74 25		 je	 SHORT $LN53@z900_proce
  00c7b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c83	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00c8a	8b 89 50 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1360]
  00c90	8b 80 ac af 00
	00		 mov	 eax, DWORD PTR [rax+44972]
  00c96	23 c1		 and	 eax, ecx
  00c98	85 c0		 test	 eax, eax
  00c9a	0f 84 01 02 00
	00		 je	 $LN47@z900_proce
$LN53@z900_proce:
  00ca0	33 c0		 xor	 eax, eax
  00ca2	85 c0		 test	 eax, eax
  00ca4	75 37		 jne	 SHORT $LN54@z900_proce
  00ca6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00cad	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00cb3	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00cb8	85 c0		 test	 eax, eax
  00cba	74 21		 je	 SHORT $LN54@z900_proce
  00cbc	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cc4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00ccb	8b 89 54 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1364]
  00cd1	39 88 b8 af 00
	00		 cmp	 DWORD PTR [rax+44984], ecx
  00cd7	0f 85 c4 01 00
	00		 jne	 $LN47@z900_proce
$LN54@z900_proce:
  00cdd	33 c0		 xor	 eax, eax
  00cdf	85 c0		 test	 eax, eax
  00ce1	75 37		 jne	 SHORT $LN55@z900_proce
  00ce3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00cea	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00cf0	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00cf5	85 c0		 test	 eax, eax
  00cf7	74 21		 je	 SHORT $LN55@z900_proce
  00cf9	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d01	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d08	8b 89 5c 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1372]
  00d0e	39 88 bc af 00
	00		 cmp	 DWORD PTR [rax+44988], ecx
  00d14	0f 8c 87 01 00
	00		 jl	 $LN47@z900_proce
$LN55@z900_proce:
$LN52@z900_proce:

; 983  :     {
; 984  :         // "TXF: %s%02X: %sSuccessful %s TBEGIN%s; TND now %d"
; 985  :         WRMSG( HHC17702, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),

  00d1a	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d22	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00d29	85 c0		 test	 eax, eax
  00d2b	74 11		 je	 SHORT $LN78@z900_proce
  00d2d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193341
  00d34	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv511[rsp], rax
  00d3c	eb 0f		 jmp	 SHORT $LN79@z900_proce
$LN78@z900_proce:
  00d3e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193342
  00d45	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv511[rsp], rax
$LN79@z900_proce:
  00d4d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d55	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00d5c	83 f8 01	 cmp	 eax, 1
  00d5f	7e 11		 jle	 SHORT $LN80@z900_proce
  00d61	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193343
  00d68	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv516[rsp], rax
  00d70	eb 0f		 jmp	 SHORT $LN81@z900_proce
$LN80@z900_proce:
  00d72	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193344
  00d79	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv516[rsp], rax
$LN81@z900_proce:
  00d81	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d89	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00d8f	d1 e8		 shr	 eax, 1
  00d91	83 e0 01	 and	 eax, 1
  00d94	85 c0		 test	 eax, eax
  00d96	74 11		 je	 SHORT $LN82@z900_proce
  00d98	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193345
  00d9f	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv522[rsp], rax
  00da7	eb 0f		 jmp	 SHORT $LN83@z900_proce
$LN82@z900_proce:
  00da9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193346
  00db0	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv522[rsp], rax
$LN83@z900_proce:
  00db8	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dc0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00dc7	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv506[rsp], eax
  00dce	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00dd6	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00ddd	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv525[rsp], ecx
  00de4	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00dec	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  00df3	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00dfa	0f b6 8c 17 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdi+rdx+2888]
  00e02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00e08	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv527[rsp], rax
  00e10	b9 01 00 00 00	 mov	 ecx, 1
  00e15	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e1b	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv506[rsp]
  00e22	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00e26	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv511[rsp]
  00e2e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00e33	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv516[rsp]
  00e3b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00e40	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv522[rsp]
  00e48	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e4d	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv525[rsp]
  00e54	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e58	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv527[rsp]
  00e60	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e65	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193347
  00e6c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e71	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193348
  00e78	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e7d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e82	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e88	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193349
  00e8f	ba db 03 00 00	 mov	 edx, 987		; 000003dbH
  00e94	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193350
  00e9b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN47@z900_proce:

; 986  :             regs->txf_tnd > 1 ? "nested" : "outermost",
; 987  :             regs->txf_contran ? "C" : "", regs->txf_tnd );
; 988  :     }
; 989  : 
; 990  :     /*--------------------------------------------------------------*/
; 991  :     /*           Report failed transaction retries                  */
; 992  :     /*--------------------------------------------------------------*/
; 993  :     if (1
; 994  :         && MLVL( VERBOSE )
; 995  :         && regs->txf_aborts
; 996  :         && TXF_TRACE( regs, FAILURE, regs->txf_contran )

  00ea1	33 c0		 xor	 eax, eax
  00ea3	83 f8 01	 cmp	 eax, 1
  00ea6	0f 84 73 03 00
	00		 je	 $LN56@z900_proce
  00eac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00eb3	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00eb9	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00ebe	85 c0		 test	 eax, eax
  00ec0	0f 84 59 03 00
	00		 je	 $LN56@z900_proce
  00ec6	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ece	83 b8 50 0e 00
	00 00		 cmp	 DWORD PTR [rax+3664], 0
  00ed5	0f 84 44 03 00
	00		 je	 $LN56@z900_proce
  00edb	33 c0		 xor	 eax, eax
  00edd	83 f8 01	 cmp	 eax, 1
  00ee0	0f 84 39 03 00
	00		 je	 $LN56@z900_proce
  00ee6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00eed	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00ef3	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00ef8	85 c0		 test	 eax, eax
  00efa	0f 84 1f 03 00
	00		 je	 $LN56@z900_proce
  00f00	33 c0		 xor	 eax, eax
  00f02	83 f8 01	 cmp	 eax, 1
  00f05	0f 84 14 03 00
	00		 je	 $LN56@z900_proce
  00f0b	33 c0		 xor	 eax, eax
  00f0d	85 c0		 test	 eax, eax
  00f0f	75 37		 jne	 SHORT $LN57@z900_proce
  00f11	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f18	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00f1e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00f23	85 c0		 test	 eax, eax
  00f25	74 21		 je	 SHORT $LN57@z900_proce
  00f27	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f2f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00f36	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  00f3c	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00f42	0f 85 d7 02 00
	00		 jne	 $LN56@z900_proce
$LN57@z900_proce:
  00f48	33 c0		 xor	 eax, eax
  00f4a	85 c0		 test	 eax, eax
  00f4c	75 37		 jne	 SHORT $LN58@z900_proce
  00f4e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f55	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00f5b	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00f60	85 c0		 test	 eax, eax
  00f62	74 21		 je	 SHORT $LN58@z900_proce
  00f64	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f6c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00f73	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  00f79	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  00f7f	0f 8c 9a 02 00
	00		 jl	 $LN56@z900_proce
$LN58@z900_proce:
  00f85	33 c0		 xor	 eax, eax
  00f87	85 c0		 test	 eax, eax
  00f89	75 73		 jne	 SHORT $LN59@z900_proce
  00f8b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f92	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00f98	25 00 00 00 0c	 and	 eax, 201326592		; 0c000000H
  00f9d	3d 00 00 00 0c	 cmp	 eax, 201326592		; 0c000000H
  00fa2	74 5a		 je	 SHORT $LN59@z900_proce
  00fa4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fab	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00fb1	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00fb6	85 c0		 test	 eax, eax
  00fb8	74 13		 je	 SHORT $LN60@z900_proce
  00fba	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fc2	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00fc9	85 c0		 test	 eax, eax
  00fcb	75 31		 jne	 SHORT $LN59@z900_proce
$LN60@z900_proce:
  00fcd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fd4	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00fda	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00fdf	85 c0		 test	 eax, eax
  00fe1	0f 84 38 02 00
	00		 je	 $LN56@z900_proce
  00fe7	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fef	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00ff6	85 c0		 test	 eax, eax
  00ff8	0f 85 21 02 00
	00		 jne	 $LN56@z900_proce
$LN59@z900_proce:
  00ffe	33 c0		 xor	 eax, eax
  01000	85 c0		 test	 eax, eax
  01002	0f 85 e0 00 00
	00		 jne	 $LN61@z900_proce
  01008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0100f	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01015	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  0101a	85 c0		 test	 eax, eax
  0101c	0f 84 c6 00 00
	00		 je	 $LN61@z900_proce
  01022	33 c0		 xor	 eax, eax
  01024	83 f8 01	 cmp	 eax, 1
  01027	0f 84 f2 01 00
	00		 je	 $LN56@z900_proce
  0102d	33 c0		 xor	 eax, eax
  0102f	85 c0		 test	 eax, eax
  01031	75 3b		 jne	 SHORT $LN62@z900_proce
  01033	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0103a	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01040	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  01045	85 c0		 test	 eax, eax
  01047	74 25		 je	 SHORT $LN62@z900_proce
  01049	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01058	8b 89 50 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1360]
  0105e	8b 80 ac af 00
	00		 mov	 eax, DWORD PTR [rax+44972]
  01064	23 c1		 and	 eax, ecx
  01066	85 c0		 test	 eax, eax
  01068	0f 84 b1 01 00
	00		 je	 $LN56@z900_proce
$LN62@z900_proce:
  0106e	33 c0		 xor	 eax, eax
  01070	85 c0		 test	 eax, eax
  01072	75 37		 jne	 SHORT $LN63@z900_proce
  01074	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0107b	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01081	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  01086	85 c0		 test	 eax, eax
  01088	74 21		 je	 SHORT $LN63@z900_proce
  0108a	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01099	8b 89 54 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1364]
  0109f	39 88 b8 af 00
	00		 cmp	 DWORD PTR [rax+44984], ecx
  010a5	0f 85 74 01 00
	00		 jne	 $LN56@z900_proce
$LN63@z900_proce:
  010ab	33 c0		 xor	 eax, eax
  010ad	85 c0		 test	 eax, eax
  010af	75 37		 jne	 SHORT $LN64@z900_proce
  010b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  010b8	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  010be	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  010c3	85 c0		 test	 eax, eax
  010c5	74 21		 je	 SHORT $LN64@z900_proce
  010c7	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  010d6	8b 89 5c 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1372]
  010dc	39 88 bc af 00
	00		 cmp	 DWORD PTR [rax+44988], ecx
  010e2	0f 8c 37 01 00
	00		 jl	 $LN56@z900_proce
$LN64@z900_proce:
$LN61@z900_proce:

; 997  :     )
; 998  :     {
; 999  :         // "TXF: %s%02X: %s%s transaction retry #%d..."
; 1000 :         WRMSG( HHC17717, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),

  010e8	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010f0	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  010f7	85 c0		 test	 eax, eax
  010f9	74 11		 je	 SHORT $LN84@z900_proce
  010fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193360
  01102	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv617[rsp], rax
  0110a	eb 0f		 jmp	 SHORT $LN85@z900_proce
$LN84@z900_proce:
  0110c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193361
  01113	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv617[rsp], rax
$LN85@z900_proce:
  0111b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01123	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01129	d1 e8		 shr	 eax, 1
  0112b	83 e0 01	 and	 eax, 1
  0112e	85 c0		 test	 eax, eax
  01130	74 11		 je	 SHORT $LN86@z900_proce
  01132	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193362
  01139	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv623[rsp], rax
  01141	eb 0f		 jmp	 SHORT $LN87@z900_proce
$LN86@z900_proce:
  01143	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193363
  0114a	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv623[rsp], rax
$LN87@z900_proce:
  01152	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0115a	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01161	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv626[rsp], eax
  01168	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01170	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01177	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0117e	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  01186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0118c	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv628[rsp], rax
  01194	b9 01 00 00 00	 mov	 ecx, 1
  01199	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0119f	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011a7	8b 89 50 0e 00
	00		 mov	 ecx, DWORD PTR [rcx+3664]
  011ad	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  011b1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv617[rsp]
  011b9	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  011be	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv623[rsp]
  011c6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  011cb	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv626[rsp]
  011d2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  011d6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv628[rsp]
  011de	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  011e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193364
  011ea	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  011ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193365
  011f6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  011fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01200	41 b9 03 00 00
	00		 mov	 r9d, 3
  01206	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193366
  0120d	ba e9 03 00 00	 mov	 edx, 1001		; 000003e9H
  01212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193367
  01219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN56@z900_proce:
$LN65@z900_proce:

; 1001 :             TXF_CONSTRAINED( regs->txf_contran ), regs->txf_aborts );
; 1002 :     }
; 1003 : 
; 1004 : } /* end ARCH_DEP( process_tbegin ) */

  0121f	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01227	48 33 cc	 xor	 rcx, rsp
  0122a	e8 00 00 00 00	 call	 __security_check_cookie
  0122f	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  01236	5f		 pop	 rdi
  01237	5e		 pop	 rsi
  01238	c3		 ret	 0
z900_process_tbegin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
regs$ = 8
z900_set_txf_aie PROC

; 204  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 205  :     regs->txf_contran  = true;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0000a	c6 80 4c 0e 00
	00 01		 mov	 BYTE PTR [rax+3660], 1

; 206  :     regs->txf_aie      = regs->ip - 6 + 256; // (minus-6 for TBEGINC)

  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00016	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0001a	48 05 fa 00 00
	00		 add	 rax, 250		; 000000faH
  00020	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00025	48 89 81 60 af
	00 00		 mov	 QWORD PTR [rcx+44896], rax

; 207  :     regs->txf_aie_aiv  = regs->AIV;

  0002c	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00031	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0003d	48 89 88 68 af
	00 00		 mov	 QWORD PTR [rax+44904], rcx

; 208  : 
; 209  :     /* Is aie in next page? */
; 210  :     if (regs->txf_aie >= (regs->aip + ZPAGEFRAME_PAGESIZE))

  00044	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00049	48 8b 80 00 02
	00 00		 mov	 rax, QWORD PTR [rax+512]
  00050	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00056	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	48 39 81 60 af
	00 00		 cmp	 QWORD PTR [rcx+44896], rax
  00062	72 4f		 jb	 SHORT $LN2@z900_set_t

; 211  :     {
; 212  :         /* Define aie offset into next page for vstore.h */
; 213  :         regs->txf_aie_aiv2 = regs->txf_aie_aiv + ZPAGEFRAME_PAGESIZE;

  00064	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00069	48 8b 80 68 af
	00 00		 mov	 rax, QWORD PTR [rax+44904]
  00070	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00076	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	48 89 81 70 af
	00 00		 mov	 QWORD PTR [rcx+44912], rax

; 214  :         regs->txf_aie_off2 = regs->txf_aie - (regs->aip + ZPAGEFRAME_PAGESIZE);

  00082	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00087	48 8b 80 00 02
	00 00		 mov	 rax, QWORD PTR [rax+512]
  0008e	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00094	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00099	48 8b 89 60 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44896]
  000a0	48 2b c8	 sub	 rcx, rax
  000a3	48 8b c1	 mov	 rax, rcx
  000a6	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	89 81 78 af 00
	00		 mov	 DWORD PTR [rcx+44920], eax

; 215  :     }

  000b1	eb 1b		 jmp	 SHORT $LN3@z900_set_t
$LN2@z900_set_t:

; 216  :     else
; 217  :     {
; 218  :         /* Prevent vstore.h next page offset match */
; 219  :         regs->txf_aie_aiv2 = ~regs->txf_aie_aiv;

  000b3	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	48 8b 80 68 af
	00 00		 mov	 rax, QWORD PTR [rax+44904]
  000bf	48 f7 d0	 not	 rax
  000c2	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  000c7	48 89 81 70 af
	00 00		 mov	 QWORD PTR [rcx+44912], rax
$LN3@z900_set_t:

; 220  :     }
; 221  : }

  000ce	c3		 ret	 0
z900_set_txf_aie ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
regs$ = 8
z900_reset_txf_aie PROC

; 192  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 193  :     regs->txf_contran  = false;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0000a	c6 80 4c 0e 00
	00 00		 mov	 BYTE PTR [rax+3660], 0

; 194  :     regs->txf_aie      = NULL;

  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00016	48 c7 80 60 af
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+44896], 0

; 195  :     regs->txf_aie_aiv  = 0;

  00021	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00026	48 c7 80 68 af
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+44904], 0

; 196  :     regs->txf_aie_aiv2 = 0;

  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00036	48 c7 80 70 af
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+44912], 0

; 197  :     regs->txf_aie_off2 = 0;

  00041	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00046	c7 80 78 af 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+44920], 0

; 198  : }

  00050	c3		 ret	 0
z900_reset_txf_aie ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_validate_operand
_TEXT	SEGMENT
tv81 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
z900_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00028	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  0004a	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00050	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00055	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00059	3b c1		 cmp	 eax, ecx
  0005b	7e 0a		 jle	 SHORT $LN6@z900_valid
  0005d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00065	eb 08		 jmp	 SHORT $LN7@z900_valid
$LN6@z900_valid:
  00067	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN7@z900_valid:
  0006f	83 7c 24 30 00	 cmp	 DWORD PTR tv81[rsp], 0
  00074	74 48		 je	 SHORT $LN2@z900_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00076	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00092	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0009b	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0009f	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  000a3	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000a7	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000ac	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000b1	ba 01 00 00 00	 mov	 edx, 1
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 z900_maddr_l
$LN2@z900_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore8 PROC					; COMDAT

; 577  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 578  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 579  :     /* Check alignement. If aligned then we are guaranteed
; 580  :        not to cross a page boundary */
; 581  :     if (likely(!((VADR_L)addr & 0x07)))
; 582  :     {
; 583  :         /* Most common case : Aligned */
; 584  :         U64 *mn;
; 585  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );
; 586  :         if (regs->cpubit == regs->sysblk->started_mask)
; 587  :             *mn = CSWAP64( value );
; 588  :         else
; 589  :             STORE_DW( mn, value );
; 590  :     }
; 591  :     else
; 592  : #endif
; 593  :     {
; 594  :         /* We're not aligned. So we have to check whether we are
; 595  :            crossing a page boundary. This cannot be the same
; 596  :            code as above because casting U64* to a non aligned
; 597  :            pointer may break on those architectures mandating
; 598  :            strict alignement */
; 599  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00023	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00029	77 0a		 ja	 SHORT $LN7@z900_vstor
  0002b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00033	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00035	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN8@z900_vstor:
  0003d	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00042	74 4c		 je	 SHORT $LN2@z900_vstor

; 600  :         {
; 601  :             /* Non aligned but not crossing page boundary */
; 602  :             BYTE *mn;
; 603  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00044	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00049	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0004d	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00051	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00059	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0005e	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00063	ba 08 00 00 00	 mov	 edx, 8
  00068	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  0006d	e8 00 00 00 00	 call	 z900_maddr_l
  00072	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 604  :             /* invoking STORE_DW ensures endianness correctness */
; 605  :             STORE_DW( mn, value );

  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  0007c	e8 00 00 00 00	 call	 _byteswap_uint64
  00081	48 8b d0	 mov	 rdx, rax
  00084	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00089	e8 00 00 00 00	 call	 store_dw_noswap

; 606  :         }

  0008e	eb 19		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 607  :         else
; 608  :             /* Crossing page boundary */
; 609  :             ARCH_DEP( vstore8_full )( value, addr, arn, regs );

  00090	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  0009a	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  000a4	e8 00 00 00 00	 call	 z900_vstore8_full
$LN3@z900_vstor:

; 610  :     }
; 611  :     ITIMER_UPDATE( addr, 8-1, regs );
; 612  : }

  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
z900_vstore8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8_full
_TEXT	SEGMENT
len$ = 48
sk$ = 56
main1$ = 64
main2$ = 72
temp$ = 80
__$ArrayPad$ = 88
value$ = 128
addr$ = 136
arn$ = 144
regs$ = 152
z900_vstore8_full PROC					; COMDAT

; 369  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 371  : BYTE   *sk;                             /* Storage key addresses     */
; 372  : int     len;                            /* Length to end of page     */
; 373  : BYTE    temp[8];                        /* Copied value              */
; 374  : 
; 375  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00029	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00031	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00037	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0003c	48 2b c8	 sub	 rcx, rax
  0003f	48 8b c1	 mov	 rax, rcx
  00042	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 376  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00046	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0004b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00057	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0005b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00063	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0006b	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00073	48 8b d0	 mov	 rdx, rax
  00076	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0007e	e8 00 00 00 00	 call	 z900_maddr_l
  00083	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 377  :     sk = regs->dat.storkey;

  00088	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00097	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 378  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8-len, arn, regs,

  0009c	b8 08 00 00 00	 mov	 eax, 8
  000a1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000a5	48 98		 cdqe
  000a7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000ac	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000b4	48 03 d1	 add	 rdx, rcx
  000b7	48 8b ca	 mov	 rcx, rdx
  000ba	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000c9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000d1	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000d5	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000d9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000e1	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e9	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f1	48 8b d0	 mov	 rdx, rax
  000f4	e8 00 00 00 00	 call	 z900_maddr_l
  000f9	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 379  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 380  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000fe	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00103	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00106	83 c8 06	 or	 eax, 6
  00109	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  0010e	88 01		 mov	 BYTE PTR [rcx], al

; 381  :     STORE_DW( temp, value );

  00110	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  00118	e8 00 00 00 00	 call	 _byteswap_uint64
  0011d	48 8b d0	 mov	 rdx, rax
  00120	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00125	e8 00 00 00 00	 call	 store_dw_noswap

; 382  :     memcpy( main1, temp,       len );

  0012a	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0012f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00134	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00139	48 8b f1	 mov	 rsi, rcx
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	f3 a4		 rep movsb

; 383  :     memcpy( main2, temp+len, 8-len );

  00141	b8 08 00 00 00	 mov	 eax, 8
  00146	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0014a	48 98		 cdqe
  0014c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00151	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00156	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0015b	48 8b f1	 mov	 rsi, rcx
  0015e	48 8b c8	 mov	 rcx, rax
  00161	f3 a4		 rep movsb

; 384  : }

  00163	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00168	48 33 cc	 xor	 rcx, rsp
  0016b	e8 00 00 00 00	 call	 __security_check_cookie
  00170	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00174	5f		 pop	 rdi
  00175	5e		 pop	 rsi
  00176	c3		 ret	 0
z900_vstore8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck2
_TEXT	SEGMENT
tv81 = 32
tv131 = 40
tv150 = 48
tv181 = 56
tv166 = 64
regs$ = 96
x2$ = 104
b2$ = 112
z900_per3_zero_xcheck2 PROC				; COMDAT

; 765  : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 766  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 767  :     if (0
; 768  :         || (!b2 && x2 && GR_A( x2, regs ) == 0)
; 769  :         || (!x2 && b2 && GR_A( b2, regs ) == 0)
; 770  :         || ( b2 && x2 && (0

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	0f 85 ba 01 00
	00		 jne	 $LN3@z900_per3_
  0001c	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00021	75 54		 jne	 SHORT $LN4@z900_per3_
  00023	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  00028	74 4d		 je	 SHORT $LN4@z900_per3_
  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0002f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 19		 je	 SHORT $LN8@z900_per3_
  0003c	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00041	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00046	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0004e	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
  00053	eb 16		 jmp	 SHORT $LN9@z900_per3_
$LN8@z900_per3_:
  00055	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00066	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
$LN9@z900_per3_:
  0006b	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv81[rsp], 0
  00071	0f 84 5f 01 00
	00		 je	 $LN3@z900_per3_
$LN4@z900_per3_:
  00077	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  0007c	75 54		 jne	 SHORT $LN5@z900_per3_
  0007e	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 4d		 je	 SHORT $LN5@z900_per3_
  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00090	83 e0 01	 and	 eax, 1
  00093	85 c0		 test	 eax, eax
  00095	74 19		 je	 SHORT $LN10@z900_per3_
  00097	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a9	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
  000ae	eb 16		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  000b0	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000ba	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c1	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
$LN11@z900_per3_:
  000c6	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv131[rsp], 0
  000cc	0f 84 04 01 00
	00		 je	 $LN3@z900_per3_
$LN5@z900_per3_:
  000d2	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  000d7	0f 84 03 01 00
	00		 je	 $LN2@z900_per3_
  000dd	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  000e2	0f 84 f8 00 00
	00		 je	 $LN2@z900_per3_
  000e8	33 c0		 xor	 eax, eax
  000ea	85 c0		 test	 eax, eax
  000ec	0f 85 e4 00 00
	00		 jne	 $LN6@z900_per3_
  000f2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 19		 je	 SHORT $LN12@z900_per3_
  00104	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00109	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00116	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
  0011b	eb 16		 jmp	 SHORT $LN13@z900_per3_
$LN12@z900_per3_:
  0011d	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0012e	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
$LN13@z900_per3_:
  00133	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv150[rsp], 0
  00139	0f 84 97 00 00
	00		 je	 $LN6@z900_per3_
  0013f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00144	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0014a	83 e0 01	 and	 eax, 1
  0014d	85 c0		 test	 eax, eax
  0014f	74 19		 je	 SHORT $LN14@z900_per3_
  00151	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00156	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0015b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00163	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
  00168	eb 16		 jmp	 SHORT $LN15@z900_per3_
$LN14@z900_per3_:
  0016a	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00174	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0017b	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
$LN15@z900_per3_:
  00180	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00185	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0018b	83 e0 01	 and	 eax, 1
  0018e	85 c0		 test	 eax, eax
  00190	74 19		 je	 SHORT $LN16@z900_per3_
  00192	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00197	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0019c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001a4	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
  001a9	eb 16		 jmp	 SHORT $LN17@z900_per3_
$LN16@z900_per3_:
  001ab	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  001b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001bc	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
$LN17@z900_per3_:
  001c1	48 8b 44 24 38	 mov	 rax, QWORD PTR tv181[rsp]
  001c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv166[rsp]
  001cb	48 03 c8	 add	 rcx, rax
  001ce	48 8b c1	 mov	 rax, rcx
  001d1	48 85 c0	 test	 rax, rax
  001d4	75 0a		 jne	 SHORT $LN2@z900_per3_
$LN6@z900_per3_:
$LN3@z900_per3_:

; 771  :                           || GR_A( b2, regs ) == 0
; 772  :                           || GR_A( b2, regs ) + GR_A( x2, regs ) == 0
; 773  :                          )
; 774  :            )
; 775  :     )
; 776  :         ARCH_DEP( per3_zero )( regs );

  001d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 777  : #else
; 778  :     UNREFERENCED( regs );
; 779  :     UNREFERENCED( x2 );
; 780  :     UNREFERENCED( b2 );
; 781  : #endif
; 782  : }

  001e0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e4	c3		 ret	 0
z900_per3_zero_xcheck2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck
_TEXT	SEGMENT
tv79 = 32
regs$ = 64
b1$ = 72
z900_per3_zero_xcheck PROC				; COMDAT

; 754  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 755  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 756  :     if (b1 && GR_A( b1, regs ) == 0)

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  00012	74 53		 je	 SHORT $LN2@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 19		 je	 SHORT $LN4@z900_per3_
  00026	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00030	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00038	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  0003d	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  0003f	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00050	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN5@z900_per3_:
  00055	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  0005b	75 0a		 jne	 SHORT $LN2@z900_per3_

; 757  :         ARCH_DEP( per3_zero )( regs );

  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 758  : #else
; 759  :     UNREFERENCED( regs );
; 760  :     UNREFERENCED( b1 );
; 761  : #endif
; 762  : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
z900_per3_zero_xcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
i2$ = 80
b1$ = 84
temp$1 = 88
tv142 = 92
effective_addr1$ = 96
tv144 = 104
inst$ = 128
regs$ = 136
z900_transaction_begin PROC

; 644  : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 645  : S16     i2;                             /* 16-bit immediate value    */
; 646  : int     b1;                             /* Base of effective addr    */
; 647  : VADR    effective_addr1;                /* Effective address         */
; 648  : 
; 649  :     SIL( inst, regs, i2, b1, effective_addr1 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001f	48 03 c8	 add	 rcx, rax
  00022	48 8b c1	 mov	 rax, rcx
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 _byteswap_ulong
  00034	89 44 24 58	 mov	 DWORD PTR temp$1[rsp], eax
  00038	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00041	66 89 44 24 50	 mov	 WORD PTR i2$[rsp], ax
  00046	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 10	 shr	 eax, 16
  0004d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00052	8b c0		 mov	 eax, eax
  00054	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00059	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  0005d	c1 e8 1c	 shr	 eax, 28
  00060	83 e0 0f	 and	 eax, 15
  00063	89 44 24 54	 mov	 DWORD PTR b1$[rsp], eax
  00067	83 7c 24 54 00	 cmp	 DWORD PTR b1$[rsp], 0
  0006c	74 44		 je	 SHORT $LN20@z900_trans
  0006e	48 63 44 24 54	 movsxd	 rax, DWORD PTR b1$[rsp]
  00073	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00083	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00093	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000a7	48 23 c8	 and	 rcx, rax
  000aa	48 8b c1	 mov	 rax, rcx
  000ad	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN20@z900_trans:
$LN4@z900_trans:
  000b2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000be	48 83 c0 06	 add	 rax, 6
  000c2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000ce	33 c0		 xor	 eax, eax
  000d0	83 f8 06	 cmp	 eax, 6
  000d3	74 0f		 je	 SHORT $LN21@z900_trans
  000d5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN21@z900_trans:
  000e4	33 c0		 xor	 eax, eax
  000e6	85 c0		 test	 eax, eax
  000e8	75 c8		 jne	 SHORT $LN4@z900_trans

; 650  :     PER_ZEROADDR_XCHECK( regs, b1 );

  000ea	8b 54 24 54	 mov	 edx, DWORD PTR b1$[rsp]
  000ee	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_trans:

; 651  : 
; 652  :     TXF_SIE_INTERCEPT( regs, TBEGIN );

  000fb	33 c0		 xor	 eax, eax
  000fd	83 f8 01	 cmp	 eax, 1
  00100	0f 84 13 01 00
	00		 je	 $LN22@z900_trans
  00106	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00114	d1 e8		 shr	 eax, 1
  00116	83 e0 01	 and	 eax, 1
  00119	85 c0		 test	 eax, eax
  0011b	0f 84 f8 00 00
	00		 je	 $LN22@z900_trans
  00121	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00129	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00130	b9 01 00 00 00	 mov	 ecx, 1
  00135	48 6b c9 01	 imul	 rcx, rcx, 1
  00139	0f b6 44 08 60	 movzx	 eax, BYTE PTR [rax+rcx+96]
  0013e	83 e0 10	 and	 eax, 16
  00141	85 c0		 test	 eax, eax
  00143	0f 85 d0 00 00
	00		 jne	 $LN22@z900_trans
  00149	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00150	83 b8 4c 05 00
	00 00		 cmp	 DWORD PTR [rax+1356], 0
  00157	0f 84 a1 00 00
	00		 je	 $LN23@z900_trans
  0015d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00165	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0016c	89 44 24 5c	 mov	 DWORD PTR tv142[rsp], eax
  00170	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00178	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0017f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00186	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00194	48 89 44 24 68	 mov	 QWORD PTR tv144[rsp], rax
  00199	b9 01 00 00 00	 mov	 ecx, 1
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193136
  001ab	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001b0	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv142[rsp]
  001b4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001b8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv144[rsp]
  001bd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193137
  001c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193138
  001d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001df	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193139
  001ec	ba 8c 02 00 00	 mov	 edx, 652		; 0000028cH
  001f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193140
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@z900_trans:
  001fe	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00206	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0020c	ba fc ff ff ff	 mov	 edx, -4
  00211	48 8b c8	 mov	 rcx, rax
  00214	e8 00 00 00 00	 call	 longjmp
$LN22@z900_trans:
  00219	33 c0		 xor	 eax, eax
  0021b	85 c0		 test	 eax, eax
  0021d	0f 85 d8 fe ff
	ff		 jne	 $LN7@z900_trans

; 653  : 
; 654  :     if (!(regs->CR(0) & CR0_TXC))

  00223	b8 08 00 00 00	 mov	 eax, 8
  00228	48 6b c0 01	 imul	 rax, rax, 1
  0022c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00234	48 ba 00 00 00
	00 00 00 80 00	 mov	 rdx, 36028797018963968	; 0080000000000000H
  0023e	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00246	48 23 c2	 and	 rax, rdx
  00249	48 85 c0	 test	 rax, rax
  0024c	0f 85 97 00 00
	00		 jne	 $LN24@z900_trans
$LN10@z900_trans:

; 655  :     {
; 656  :         PTT_TXF( "*TXF TBEGIN", regs->CR(0), regs->txf_contran, regs->txf_tnd );

  00252	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00259	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0025c	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00262	48 85 c0	 test	 rax, rax
  00265	74 66		 je	 SHORT $LN25@z900_trans
  00267	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026f	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00276	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027e	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00285	ba 08 00 00 00	 mov	 edx, 8
  0028a	48 6b d2 01	 imul	 rdx, rdx, 1
  0028e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00297	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0029c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193143
  002a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a8	44 8b c9	 mov	 r9d, ecx
  002ab	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b3	4c 8b 84 10 00
	06 00 00	 mov	 r8, QWORD PTR [rax+rdx+1536]
  002bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193144
  002c2	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  002c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN25@z900_trans:
  002cd	33 c0		 xor	 eax, eax
  002cf	85 c0		 test	 eax, eax
  002d1	0f 85 7b ff ff
	ff		 jne	 $LN10@z900_trans

; 657  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIAL_OPERATION_EXCEPTION );

  002d7	ba 13 00 00 00	 mov	 edx, 19
  002dc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e4	e8 00 00 00 00	 call	 z900_program_interrupt
$LN24@z900_trans:
$LN13@z900_trans:

; 658  :         UNREACHABLE_CODE( return );
; 659  :     }
; 660  : 
; 661  :     TXF_EXECUTE_INSTR_CHECK( regs );

  002e9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002f1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002f7	83 e0 01	 and	 eax, 1
  002fa	85 c0		 test	 eax, eax
  002fc	74 12		 je	 SHORT $LN26@z900_trans
  002fe	ba 03 00 00 00	 mov	 edx, 3
  00303	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030b	e8 00 00 00 00	 call	 z900_program_interrupt
$LN26@z900_trans:
  00310	33 c0		 xor	 eax, eax
  00312	85 c0		 test	 eax, eax
  00314	75 d3		 jne	 SHORT $LN13@z900_trans

; 662  : 
; 663  :     /* Unconstrained: PIFC of 3 is invalid */
; 664  :     if ((i2 & TXF_CTL_PIFC) == 3)

  00316	0f bf 44 24 50	 movsx	 eax, WORD PTR i2$[rsp]
  0031b	83 e0 03	 and	 eax, 3
  0031e	83 f8 03	 cmp	 eax, 3
  00321	0f 85 83 00 00
	00		 jne	 $LN27@z900_trans
$LN16@z900_trans:

; 665  :     {
; 666  :         PTT_TXF( "*TXF TBEGIN", i2, regs->txf_contran, regs->txf_tnd );

  00327	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0032e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00331	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00337	48 85 c0	 test	 rax, rax
  0033a	74 56		 je	 SHORT $LN28@z900_trans
  0033c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00344	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0034b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00353	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  0035a	48 0f bf 54 24
	50		 movsx	 rdx, WORD PTR i2$[rsp]
  00360	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00369	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0036e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193148
  00375	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0037a	44 8b c9	 mov	 r9d, ecx
  0037d	4c 8b c2	 mov	 r8, rdx
  00380	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193149
  00387	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0038c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN28@z900_trans:
  00392	33 c0		 xor	 eax, eax
  00394	85 c0		 test	 eax, eax
  00396	75 8f		 jne	 SHORT $LN16@z900_trans

; 667  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  00398	ba 06 00 00 00	 mov	 edx, 6
  0039d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a5	e8 00 00 00 00	 call	 z900_program_interrupt
$LN27@z900_trans:

; 668  :         UNREACHABLE_CODE( return );
; 669  :     }
; 670  : 
; 671  :     /* Unconstrained: if b1 non-zero TDB must be aligned else ignore */
; 672  :     if (b1)

  003aa	83 7c 24 54 00	 cmp	 DWORD PTR b1$[rsp], 0
  003af	74 50		 je	 SHORT $LN29@z900_trans

; 673  :     {
; 674  :         DW_CHECK( effective_addr1, regs );

  003b1	48 8b 44 24 60	 mov	 rax, QWORD PTR effective_addr1$[rsp]
  003b6	48 83 e0 07	 and	 rax, 7
  003ba	48 85 c0	 test	 rax, rax
  003bd	74 1b		 je	 SHORT $LN30@z900_trans
  003bf	ba 06 00 00 00	 mov	 edx, 6
  003c4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003cc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d4	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN30@z900_trans:

; 675  : 
; 676  :         /* Check that all bytes of the TDB are accessible */
; 677  :         ARCH_DEP( validate_operand )( effective_addr1, b1,

  003da	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e7	41 b9 02 00 00
	00		 mov	 r9d, 2
  003ed	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  003f3	8b 54 24 54	 mov	 edx, DWORD PTR b1$[rsp]
  003f7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  003fc	e8 00 00 00 00	 call	 z900_validate_operand
$LN29@z900_trans:

; 678  :                                       sizeof( TDB ) - 1,
; 679  :                                       ACCTYPE_WRITE, regs );
; 680  :     }
; 681  : 
; 682  :     OBTAIN_INTLOCK( regs );

  00401	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193152
  00408	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00410	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN19@z900_trans:

; 683  :     {
; 684  :         /* Let our helper function do all the grunt work */
; 685  :         PTT_TXF( "TXF TBEGIN", 0, regs->txf_contran, regs->txf_tnd );

  00415	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0041c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0041f	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00425	48 85 c0	 test	 rax, rax
  00428	74 50		 je	 SHORT $LN31@z900_trans
  0042a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00432	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00439	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00441	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00448	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00451	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00456	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193154
  0045d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00462	44 8b c9	 mov	 r9d, ecx
  00465	45 33 c0	 xor	 r8d, r8d
  00468	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193155
  0046f	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00474	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN31@z900_trans:
  0047a	33 c0		 xor	 eax, eax
  0047c	85 c0		 test	 eax, eax
  0047e	75 95		 jne	 SHORT $LN19@z900_trans

; 686  :         ARCH_DEP( process_tbegin )( false, regs, i2, effective_addr1, b1 );

  00480	8b 44 24 54	 mov	 eax, DWORD PTR b1$[rsp]
  00484	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00488	4c 8b 4c 24 60	 mov	 r9, QWORD PTR effective_addr1$[rsp]
  0048d	44 0f b7 44 24
	50		 movzx	 r8d, WORD PTR i2$[rsp]
  00493	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0049b	33 c9		 xor	 ecx, ecx
  0049d	e8 00 00 00 00	 call	 z900_process_tbegin

; 687  :     }
; 688  :     RELEASE_INTLOCK( regs );

  004a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193156
  004a9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b1	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN32@z900_trans:

; 689  : 
; 690  : } /* end DEF_INST( transaction_begin ) */

  004b6	48 83 c4 78	 add	 rsp, 120		; 00000078H
  004ba	c3		 ret	 0
z900_transaction_begin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
disp2$1 = 64
temp$2 = 68
b2$ = 72
x2$ = 76
tv131 = 80
r1$ = 84
effective_addr2$ = 88
inst$ = 112
regs$ = 120
z900_nontransactional_store PROC

; 611  : {

$LN25:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 612  : int     r1;                             /* Value of r1 field         */
; 613  : int     b2;                             /* Base of effective address */
; 614  : int     x2;                             /* Index register            */
; 615  : VADR    effective_addr2;                /* Effective address         */
; 616  : 
; 617  :     RXY( inst, regs, r1, x2, b2, effective_addr2 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 44	 mov	 DWORD PTR temp$2[rsp], eax
  00023	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], 0
  0002c	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  00030	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00035	89 44 24 40	 mov	 DWORD PTR disp2$1[rsp], eax
  00039	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	c1 e8 10	 shr	 eax, 16
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 4c	 mov	 DWORD PTR x2$[rsp], eax
  00047	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  0004b	c1 e8 14	 shr	 eax, 20
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 54	 mov	 DWORD PTR r1$[rsp], eax
  00055	83 7c 24 4c 00	 cmp	 DWORD PTR x2$[rsp], 0
  0005a	74 22		 je	 SHORT $LN11@z900_nontr
  0005c	48 63 44 24 4c	 movsxd	 rax, DWORD PTR x2$[rsp]
  00061	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0006e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN11@z900_nontr:
  0007e	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  00082	c1 e8 0c	 shr	 eax, 12
  00085	83 e0 0f	 and	 eax, 15
  00088	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  0008c	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  00091	74 22		 je	 SHORT $LN12@z900_nontr
  00093	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  00098	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	48 03 c8	 add	 rcx, rax
  000ad	48 8b c1	 mov	 rax, rcx
  000b0	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN12@z900_nontr:
  000b5	b8 01 00 00 00	 mov	 eax, 1
  000ba	48 6b c0 04	 imul	 rax, rax, 4
  000be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  000c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c7	85 c0		 test	 eax, eax
  000c9	74 0a		 je	 SHORT $LN23@z900_nontr
  000cb	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN24@z900_nontr
$LN23@z900_nontr:
  000d5	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN24@z900_nontr:
  000dd	83 7c 24 50 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 3b		 je	 SHORT $LN13@z900_nontr
  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 04	 imul	 rax, rax, 4
  000ed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  000f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f6	c1 e0 0c	 shl	 eax, 12
  000f9	8b 4c 24 40	 mov	 ecx, DWORD PTR disp2$1[rsp]
  000fd	0b c8		 or	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	89 44 24 40	 mov	 DWORD PTR disp2$1[rsp], eax
  00105	8b 44 24 40	 mov	 eax, DWORD PTR disp2$1[rsp]
  00109	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0010e	85 c0		 test	 eax, eax
  00110	74 0d		 je	 SHORT $LN14@z900_nontr
  00112	8b 44 24 40	 mov	 eax, DWORD PTR disp2$1[rsp]
  00116	0d 00 00 f0 ff	 or	 eax, -1048576		; fff00000H
  0011b	89 44 24 40	 mov	 DWORD PTR disp2$1[rsp], eax
$LN14@z900_nontr:
$LN13@z900_nontr:
  0011f	48 63 44 24 40	 movsxd	 rax, DWORD PTR disp2$1[rsp]
  00124	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00129	48 03 c8	 add	 rcx, rax
  0012c	48 8b c1	 mov	 rax, rcx
  0012f	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00134	33 c0		 xor	 eax, eax
  00136	83 f8 06	 cmp	 eax, 6
  00139	74 1c		 je	 SHORT $LN15@z900_nontr
  0013b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00140	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00147	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0014c	48 23 c8	 and	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN15@z900_nontr:
$LN4@z900_nontr:
  00157	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00160	48 83 c0 06	 add	 rax, 6
  00164	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00169	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0016d	33 c0		 xor	 eax, eax
  0016f	83 f8 06	 cmp	 eax, 6
  00172	74 0c		 je	 SHORT $LN16@z900_nontr
  00174	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00179	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN16@z900_nontr:
  00180	33 c0		 xor	 eax, eax
  00182	85 c0		 test	 eax, eax
  00184	75 d1		 jne	 SHORT $LN4@z900_nontr

; 618  :     PER_ZEROADDR_XCHECK2( regs, x2, b2 );

  00186	44 8b 44 24 48	 mov	 r8d, DWORD PTR b2$[rsp]
  0018b	8b 54 24 4c	 mov	 edx, DWORD PTR x2$[rsp]
  0018f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2
$LN7@z900_nontr:

; 619  : 
; 620  :     TXFC_INSTR_CHECK( regs );

  00199	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  001a5	85 c0		 test	 eax, eax
  001a7	74 36		 je	 SHORT $LN17@z900_nontr
  001a9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001ae	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  001b4	0f ba e8 0f	 bts	 eax, 15
  001b8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001bd	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  001c3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193070
  001ca	41 b8 0b 00 00
	00		 mov	 r8d, 11
  001d0	ba 02 00 00 00	 mov	 edx, 2
  001d5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001da	e8 00 00 00 00	 call	 z900_abort_transaction
$LN17@z900_nontr:
  001df	33 c0		 xor	 eax, eax
  001e1	85 c0		 test	 eax, eax
  001e3	75 b4		 jne	 SHORT $LN7@z900_nontr

; 621  :     DW_CHECK( effective_addr2, regs );

  001e5	48 8b 44 24 58	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001ea	48 83 e0 07	 and	 rax, 7
  001ee	48 85 c0	 test	 rax, rax
  001f1	74 15		 je	 SHORT $LN18@z900_nontr
  001f3	ba 06 00 00 00	 mov	 edx, 6
  001f8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001fd	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00202	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN18@z900_nontr:
$LN10@z900_nontr:

; 622  : 
; 623  :     PTT_TXF( "TXF NTSTG", regs->GR_G( r1 ), effective_addr2, 0 );

  00208	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0020f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00212	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00218	48 85 c0	 test	 rax, rax
  0021b	74 47		 je	 SHORT $LN19@z900_nontr
  0021d	48 63 44 24 54	 movsxd	 rax, DWORD PTR r1$[rsp]
  00222	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0022b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00234	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193073
  0023b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00240	4c 8b 4c 24 58	 mov	 r9, QWORD PTR effective_addr2$[rsp]
  00245	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0024a	4c 8b 84 c1 80
	02 00 00	 mov	 r8, QWORD PTR [rcx+rax*8+640]
  00252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193074
  00259	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0025e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN19@z900_nontr:
  00264	33 c0		 xor	 eax, eax
  00266	85 c0		 test	 eax, eax
  00268	75 9e		 jne	 SHORT $LN10@z900_nontr

; 624  : 
; 625  :     /* Nontransactionally store register contents at operand address */
; 626  :     regs->txf_NTSTG = true;

  0026a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0026f	c6 80 4b 0e 00
	00 01		 mov	 BYTE PTR [rax+3659], 1

; 627  :     ARCH_DEP( vstore8 )( regs->GR_G( r1 ), effective_addr2, b2, regs );

  00276	48 63 44 24 54	 movsxd	 rax, DWORD PTR r1$[rsp]
  0027b	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00280	44 8b 44 24 48	 mov	 r8d, DWORD PTR b2$[rsp]
  00285	48 8b 54 24 58	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0028a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0028f	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00297	e8 00 00 00 00	 call	 z900_vstore8

; 628  : 
; 629  : } /* end DEF_INST( nontransactional_store ) */

  0029c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002a0	c3		 ret	 0
z900_nontransactional_store ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
temp$1 = 80
b2$ = 84
tv222 = 88
tv135 = 92
effective_addr2$ = 96
tv137 = 104
inst$ = 128
regs$ = 136
z900_transaction_abort PROC

; 567  : {

$LN41:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 568  : int     b2;                             /* Base of effective addr    */
; 569  : VADR    effective_addr2;                /* Effective address         */
; 570  : 
; 571  :     S( inst, regs, b2, effective_addr2 );

  0000e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00016	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001b	8b c8		 mov	 ecx, eax
  0001d	e8 00 00 00 00	 call	 _byteswap_ulong
  00022	89 44 24 50	 mov	 DWORD PTR temp$1[rsp], eax
  00026	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  0002a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002f	8b c0		 mov	 eax, eax
  00031	48 89 44 24 60	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00036	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 0c	 shr	 eax, 12
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 54	 mov	 DWORD PTR b2$[rsp], eax
  00044	83 7c 24 54 00	 cmp	 DWORD PTR b2$[rsp], 0
  00049	74 44		 je	 SHORT $LN26@z900_trans
  0004b	48 63 44 24 54	 movsxd	 rax, DWORD PTR b2$[rsp]
  00050	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00058	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00060	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00065	48 03 c8	 add	 rcx, rax
  00068	48 8b c1	 mov	 rax, rcx
  0006b	48 89 44 24 60	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00070	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0007f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00084	48 23 c8	 and	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	48 89 44 24 60	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN26@z900_trans:
$LN4@z900_trans:
  0008f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009b	48 83 c0 04	 add	 rax, 4
  0009f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000ab	33 c0		 xor	 eax, eax
  000ad	83 f8 04	 cmp	 eax, 4
  000b0	74 0f		 je	 SHORT $LN27@z900_trans
  000b2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN27@z900_trans:
  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 c8		 jne	 SHORT $LN4@z900_trans
$LN7@z900_trans:

; 572  : 
; 573  :     TXF_SIE_INTERCEPT( regs, TABORT );

  000c7	33 c0		 xor	 eax, eax
  000c9	83 f8 01	 cmp	 eax, 1
  000cc	0f 84 13 01 00
	00		 je	 $LN28@z900_trans
  000d2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e0	d1 e8		 shr	 eax, 1
  000e2	83 e0 01	 and	 eax, 1
  000e5	85 c0		 test	 eax, eax
  000e7	0f 84 f8 00 00
	00		 je	 $LN28@z900_trans
  000ed	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000fc	b9 01 00 00 00	 mov	 ecx, 1
  00101	48 6b c9 01	 imul	 rcx, rcx, 1
  00105	0f b6 44 08 60	 movzx	 eax, BYTE PTR [rax+rcx+96]
  0010a	83 e0 10	 and	 eax, 16
  0010d	85 c0		 test	 eax, eax
  0010f	0f 85 d0 00 00
	00		 jne	 $LN28@z900_trans
  00115	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011c	83 b8 4c 05 00
	00 00		 cmp	 DWORD PTR [rax+1356], 0
  00123	0f 84 a1 00 00
	00		 je	 $LN29@z900_trans
  00129	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00131	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00138	89 44 24 5c	 mov	 DWORD PTR tv135[rsp], eax
  0013c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0014b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00152	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00160	48 89 44 24 68	 mov	 QWORD PTR tv137[rsp], rax
  00165	b9 01 00 00 00	 mov	 ecx, 1
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00170	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193015
  00177	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0017c	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv135[rsp]
  00180	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00184	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv137[rsp]
  00189	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0018e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193016
  00195	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0019a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193017
  001a1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ab	41 b9 03 00 00
	00		 mov	 r9d, 3
  001b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193018
  001b8	ba 3d 02 00 00	 mov	 edx, 573		; 0000023dH
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193019
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN29@z900_trans:
  001ca	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d2	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  001d8	ba fc ff ff ff	 mov	 edx, -4
  001dd	48 8b c8	 mov	 rcx, rax
  001e0	e8 00 00 00 00	 call	 longjmp
$LN28@z900_trans:
  001e5	33 c0		 xor	 eax, eax
  001e7	85 c0		 test	 eax, eax
  001e9	0f 85 d8 fe ff
	ff		 jne	 $LN7@z900_trans
$LN10@z900_trans:

; 574  : 
; 575  :     TXFC_INSTR_CHECK( regs );

  001ef	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f7	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  001fe	85 c0		 test	 eax, eax
  00200	74 3f		 je	 SHORT $LN30@z900_trans
  00202	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020a	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00210	0f ba e8 0f	 bts	 eax, 15
  00214	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021c	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00222	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193021
  00229	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0022f	ba 02 00 00 00	 mov	 edx, 2
  00234	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023c	e8 00 00 00 00	 call	 z900_abort_transaction
$LN30@z900_trans:
  00241	33 c0		 xor	 eax, eax
  00243	85 c0		 test	 eax, eax
  00245	75 a8		 jne	 SHORT $LN10@z900_trans
$LN13@z900_trans:

; 576  :     TXF_EXECUTE_INSTR_CHECK( regs );

  00247	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00255	83 e0 01	 and	 eax, 1
  00258	85 c0		 test	 eax, eax
  0025a	74 12		 je	 SHORT $LN31@z900_trans
  0025c	ba 03 00 00 00	 mov	 edx, 3
  00261	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00269	e8 00 00 00 00	 call	 z900_program_interrupt
$LN31@z900_trans:
  0026e	33 c0		 xor	 eax, eax
  00270	85 c0		 test	 eax, eax
  00272	75 d3		 jne	 SHORT $LN13@z900_trans

; 577  : 
; 578  :     if (effective_addr2 <= 255)

  00274	48 81 7c 24 60
	ff 00 00 00	 cmp	 QWORD PTR effective_addr2$[rsp], 255 ; 000000ffH
  0027d	77 7f		 ja	 SHORT $LN32@z900_trans
$LN16@z900_trans:

; 579  :     {
; 580  :         PTT_TXF( "*TXF TABORT", effective_addr2, regs->txf_contran, regs->txf_tnd );

  0027f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00286	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00289	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  0028f	48 85 c0	 test	 rax, rax
  00292	74 52		 je	 SHORT $LN33@z900_trans
  00294	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0029c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  002a3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ab	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  002b2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002bb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193025
  002c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002cc	44 8b c9	 mov	 r9d, ecx
  002cf	4c 8b 44 24 60	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  002d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193026
  002db	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  002e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN33@z900_trans:
  002e6	33 c0		 xor	 eax, eax
  002e8	85 c0		 test	 eax, eax
  002ea	75 93		 jne	 SHORT $LN16@z900_trans

; 581  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  002ec	ba 06 00 00 00	 mov	 edx, 6
  002f1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f9	e8 00 00 00 00	 call	 z900_program_interrupt
$LN32@z900_trans:

; 582  :         UNREACHABLE_CODE( return );
; 583  :     }
; 584  : 
; 585  :     if (!regs->txf_tnd)

  002fe	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00306	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0030d	85 c0		 test	 eax, eax
  0030f	75 6c		 jne	 SHORT $LN34@z900_trans
$LN19@z900_trans:

; 586  :     {
; 587  :         PTT_TXF( "*TXF TABORT", 0, 0, 0 );

  00311	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00318	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0031b	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00321	48 85 c0	 test	 rax, rax
  00324	74 36		 je	 SHORT $LN35@z900_trans
  00326	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0032f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00338	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193029
  0033f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00344	45 33 c9	 xor	 r9d, r9d
  00347	45 33 c0	 xor	 r8d, r8d
  0034a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193030
  00351	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00356	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN35@z900_trans:
  0035c	33 c0		 xor	 eax, eax
  0035e	85 c0		 test	 eax, eax
  00360	75 af		 jne	 SHORT $LN19@z900_trans

; 588  :         regs->program_interrupt( regs, PGM_SPECIAL_OPERATION_EXCEPTION );

  00362	ba 13 00 00 00	 mov	 edx, 19
  00367	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00377	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN34@z900_trans:
$LN22@z900_trans:

; 589  :         UNREACHABLE_CODE( return );
; 590  :     }
; 591  : 
; 592  :     TXFC_INSTR_CHECK( regs );

  0037d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00385	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0038c	85 c0		 test	 eax, eax
  0038e	74 3f		 je	 SHORT $LN36@z900_trans
  00390	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00398	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0039e	0f ba e8 0f	 bts	 eax, 15
  003a2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003aa	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  003b0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193032
  003b7	41 b8 0b 00 00
	00		 mov	 r8d, 11
  003bd	ba 02 00 00 00	 mov	 edx, 2
  003c2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ca	e8 00 00 00 00	 call	 z900_abort_transaction
$LN36@z900_trans:
  003cf	33 c0		 xor	 eax, eax
  003d1	85 c0		 test	 eax, eax
  003d3	75 a8		 jne	 SHORT $LN22@z900_trans

; 593  : 
; 594  :     /* CC in transaction abort PSW = 2 or 3 based on operand2 bit 63 */
; 595  :     regs->txf_tapsw.cc = (effective_addr2 & 0x1) == 0 ? 2 : 3;

  003d5	48 8b 44 24 60	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  003da	48 83 e0 01	 and	 rax, 1
  003de	48 85 c0	 test	 rax, rax
  003e1	75 0a		 jne	 SHORT $LN39@z900_trans
  003e3	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR tv222[rsp], 2
  003eb	eb 08		 jmp	 SHORT $LN40@z900_trans
$LN39@z900_trans:
  003ed	c7 44 24 58 03
	00 00 00	 mov	 DWORD PTR tv222[rsp], 3
$LN40@z900_trans:
  003f5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003fd	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR tv222[rsp]
  00402	88 88 24 af 00
	00		 mov	 BYTE PTR [rax+44836], cl
$LN25@z900_trans:

; 596  : 
; 597  :     /* Abort the transaction */
; 598  : 
; 599  :     PTT_TXF( "TXF TABORT", effective_addr2, regs->txf_contran, regs->txf_tnd );

  00408	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0040f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00412	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00418	48 85 c0	 test	 rax, rax
  0041b	74 52		 je	 SHORT $LN37@z900_trans
  0041d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00425	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0042c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00434	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  0043b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00444	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00449	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193034
  00450	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00455	44 8b c9	 mov	 r9d, ecx
  00458	4c 8b 44 24 60	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  0045d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193035
  00464	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00469	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN37@z900_trans:
  0046f	33 c0		 xor	 eax, eax
  00471	85 c0		 test	 eax, eax
  00473	75 93		 jne	 SHORT $LN25@z900_trans

; 600  :     regs->txf_why |= TXF_WHY_TABORT_INSTR;

  00475	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047d	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00483	0f ba e8 10	 bts	 eax, 16
  00487	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0048f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 601  :     ABORT_TRANS( regs, ABORT_RETRY_CC, (int) effective_addr2 );

  00495	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193036
  0049c	44 8b 44 24 60	 mov	 r8d, DWORD PTR effective_addr2$[rsp]
  004a1	ba 01 00 00 00	 mov	 edx, 1
  004a6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ae	e8 00 00 00 00	 call	 z900_abort_transaction
$LN38@z900_trans:

; 602  :     UNREACHABLE_CODE( return );
; 603  : 
; 604  : } /* end DEF_INST( transaction_abort ) */

  004b3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  004b7	c3		 ret	 0
z900_transaction_abort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
i$1 = 80
tv93 = 84
r1$ = 88
r2$ = 92
tv95 = 96
inst$ = 128
regs$ = 136
z900_extract_transaction_nesting_depth PROC

; 164  : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 165  : int     r1, r2;                         /* Operand register numbers  */
; 166  : 
; 167  :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00023	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
  00027	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  0002b	83 e0 0f	 and	 eax, 15
  0002e	89 44 24 5c	 mov	 DWORD PTR r2$[rsp], eax
  00032	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00036	c1 f8 04	 sar	 eax, 4
  00039	83 e0 0f	 and	 eax, 15
  0003c	89 44 24 58	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_extra:
  00040	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00048	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0004c	48 83 c0 04	 add	 rax, 4
  00050	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00058	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0005c	33 c0		 xor	 eax, eax
  0005e	83 f8 04	 cmp	 eax, 4
  00061	74 0f		 je	 SHORT $LN20@z900_extra
  00063	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN20@z900_extra:
  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 c8		 jne	 SHORT $LN4@z900_extra
$LN7@z900_extra:

; 168  : 
; 169  :     UNREFERENCED( r2 );

  00078	33 c0		 xor	 eax, eax
  0007a	85 c0		 test	 eax, eax
  0007c	75 fa		 jne	 SHORT $LN7@z900_extra
$LN10@z900_extra:

; 170  : 
; 171  :     TXF_SIE_INTERCEPT( regs, ETND );

  0007e	33 c0		 xor	 eax, eax
  00080	83 f8 01	 cmp	 eax, 1
  00083	0f 84 13 01 00
	00		 je	 $LN21@z900_extra
  00089	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00091	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00097	d1 e8		 shr	 eax, 1
  00099	83 e0 01	 and	 eax, 1
  0009c	85 c0		 test	 eax, eax
  0009e	0f 84 f8 00 00
	00		 je	 $LN21@z900_extra
  000a4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000b3	b9 01 00 00 00	 mov	 ecx, 1
  000b8	48 6b c9 01	 imul	 rcx, rcx, 1
  000bc	0f b6 44 08 60	 movzx	 eax, BYTE PTR [rax+rcx+96]
  000c1	83 e0 10	 and	 eax, 16
  000c4	85 c0		 test	 eax, eax
  000c6	0f 85 d0 00 00
	00		 jne	 $LN21@z900_extra
  000cc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d3	83 b8 4c 05 00
	00 00		 cmp	 DWORD PTR [rax+1356], 0
  000da	0f 84 a1 00 00
	00		 je	 $LN22@z900_extra
  000e0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ef	89 44 24 54	 mov	 DWORD PTR tv93[rsp], eax
  000f3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fb	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00102	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00109	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00117	48 89 44 24 60	 mov	 QWORD PTR tv95[rsp], rax
  0011c	b9 01 00 00 00	 mov	 ecx, 1
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192669
  0012e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00133	8b 4c 24 54	 mov	 ecx, DWORD PTR tv93[rsp]
  00137	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0013b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv95[rsp]
  00140	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192670
  0014c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192671
  00158	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00162	41 b9 03 00 00
	00		 mov	 r9d, 3
  00168	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG192672
  0016f	ba ab 00 00 00	 mov	 edx, 171		; 000000abH
  00174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192673
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN22@z900_extra:
  00181	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00189	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0018f	ba fc ff ff ff	 mov	 edx, -4
  00194	48 8b c8	 mov	 rcx, rax
  00197	e8 00 00 00 00	 call	 longjmp
$LN21@z900_extra:
  0019c	33 c0		 xor	 eax, eax
  0019e	85 c0		 test	 eax, eax
  001a0	0f 85 d8 fe ff
	ff		 jne	 $LN10@z900_extra

; 172  : 
; 173  :     if (!(regs->CR(0) & CR0_TXC))

  001a6	b8 08 00 00 00	 mov	 eax, 8
  001ab	48 6b c0 01	 imul	 rax, rax, 1
  001af	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b7	48 ba 00 00 00
	00 00 00 80 00	 mov	 rdx, 36028797018963968	; 0080000000000000H
  001c1	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  001c9	48 23 c2	 and	 rax, rdx
  001cc	48 85 c0	 test	 rax, rax
  001cf	0f 85 97 00 00
	00		 jne	 $LN23@z900_extra
$LN13@z900_extra:

; 174  :     {
; 175  :         PTT_TXF( "*TXF ETND", regs->CR(0), regs->txf_contran, regs->txf_tnd );

  001d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001df	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  001e5	48 85 c0	 test	 rax, rax
  001e8	74 66		 je	 SHORT $LN24@z900_extra
  001ea	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f2	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  001f9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00201	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00208	ba 08 00 00 00	 mov	 edx, 8
  0020d	48 6b d2 01	 imul	 rdx, rdx, 1
  00211	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0021a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0021f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192676
  00226	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022b	44 8b c9	 mov	 r9d, ecx
  0022e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00236	4c 8b 84 10 00
	06 00 00	 mov	 r8, QWORD PTR [rax+rdx+1536]
  0023e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192677
  00245	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0024a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN24@z900_extra:
  00250	33 c0		 xor	 eax, eax
  00252	85 c0		 test	 eax, eax
  00254	0f 85 7b ff ff
	ff		 jne	 $LN13@z900_extra

; 176  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIAL_OPERATION_EXCEPTION );

  0025a	ba 13 00 00 00	 mov	 edx, 19
  0025f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00267	e8 00 00 00 00	 call	 z900_program_interrupt
$LN23@z900_extra:
$LN16@z900_extra:

; 177  :         UNREACHABLE_CODE( return );
; 178  :     }
; 179  : 
; 180  :     TXFC_INSTR_CHECK( regs );

  0026c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00274	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0027b	85 c0		 test	 eax, eax
  0027d	74 3f		 je	 SHORT $LN25@z900_extra
  0027f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00287	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0028d	0f ba e8 0f	 bts	 eax, 15
  00291	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00299	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0029f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192679
  002a6	41 b8 0b 00 00
	00		 mov	 r8d, 11
  002ac	ba 02 00 00 00	 mov	 edx, 2
  002b1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b9	e8 00 00 00 00	 call	 z900_abort_transaction
$LN25@z900_extra:
  002be	33 c0		 xor	 eax, eax
  002c0	85 c0		 test	 eax, eax
  002c2	75 a8		 jne	 SHORT $LN16@z900_extra

; 181  : 
; 182  :     regs->GR_L(r1) = (U32) regs->txf_tnd;

  002c4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002cc	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  002d3	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR r1$[rsp]
  002d8	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002e0	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN19@z900_extra:

; 183  : 
; 184  :     PTT_TXF( "TXF ETND", 0, 0, regs->txf_tnd );

  002e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002ee	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002f1	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  002f7	48 85 c0	 test	 rax, rax
  002fa	74 41		 je	 SHORT $LN26@z900_extra
  002fc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00304	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0030b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00314	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00319	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192681
  00320	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00325	45 33 c9	 xor	 r9d, r9d
  00328	45 33 c0	 xor	 r8d, r8d
  0032b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192682
  00332	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00337	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN26@z900_extra:
  0033d	33 c0		 xor	 eax, eax
  0033f	85 c0		 test	 eax, eax
  00341	75 a4		 jne	 SHORT $LN19@z900_extra
$LN27@z900_extra:

; 185  : 
; 186  : } /* end DEF_INST( extract_transaction_nesting_depth ) */

  00343	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00347	c3		 ret	 0
z900_extract_transaction_nesting_depth ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
txf_contran$1 = 112
j$ = 116
refchg$2 = 120
txf_tnd$ = 124
per_tend$ = 128
txf_tac$ = 132
pmap$ = 136
i$ = 144
txf_abortctr$3 = 148
temp$4 = 152
b2$ = 156
tv542 = 160
tv915 = 164
tv920 = 168
tv957 = 172
effective_addr2$ = 176
tv370 = 184
txf_aie_off2$5 = 188
tv644 = 192
tv716 = 196
tv893 = 200
slot$ = 204
tv135 = 208
tv356 = 212
mainaddr$ = 216
tv361 = 224
tv367 = 232
tv635 = 240
tv641 = 248
tv713 = 256
altaddr$ = 264
tv884 = 272
tv890 = 280
tv137 = 288
tv372 = 296
saveaddr$ = 304
txf_aie$6 = 312
txf_aie_aiv$7 = 320
txf_aie_aiv2$8 = 328
tv646 = 336
tv705 = 344
tv718 = 352
tv895 = 360
inst$ = 400
regs$ = 408
z900_transaction_end PROC

; 227  : {

$LN145:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H

; 228  : int         i, j;                       /* (work)                    */
; 229  : int         b2;                         /* Base of effective addr    */
; 230  : VADR        effective_addr2;            /* Effective address         */
; 231  : BYTE       *altaddr;
; 232  : BYTE       *saveaddr;
; 233  : BYTE       *mainaddr;
; 234  : TPAGEMAP   *pmap;
; 235  : int         txf_tnd, txf_tac, slot;
; 236  : bool        per_tend = false;           /* true = check for PER TEND */

  00013	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR per_tend$[rsp], 0

; 237  : 
; 238  :     S( inst, regs, b2, effective_addr2 );

  0001b	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00023	e8 00 00 00 00	 call	 fetch_fw_noswap
  00028	8b c8		 mov	 ecx, eax
  0002a	e8 00 00 00 00	 call	 _byteswap_ulong
  0002f	89 84 24 98 00
	00 00		 mov	 DWORD PTR temp$4[rsp], eax
  00036	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR temp$4[rsp]
  0003d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00042	8b c0		 mov	 eax, eax
  00044	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR temp$4[rsp]
  00053	c1 e8 0c	 shr	 eax, 12
  00056	83 e0 0f	 and	 eax, 15
  00059	89 84 24 9c 00
	00 00		 mov	 DWORD PTR b2$[rsp], eax
  00060	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR b2$[rsp], 0
  00068	74 53		 je	 SHORT $LN53@z900_trans
  0006a	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR b2$[rsp]
  00072	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00082	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0008a	48 03 c8	 add	 rcx, rax
  0008d	48 8b c1	 mov	 rax, rcx
  00090	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00098	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000a7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000af	48 23 c8	 and	 rcx, rax
  000b2	48 8b c1	 mov	 rax, rcx
  000b5	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN53@z900_trans:
$LN4@z900_trans:
  000bd	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c9	48 83 c0 04	 add	 rax, 4
  000cd	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000d9	33 c0		 xor	 eax, eax
  000db	83 f8 04	 cmp	 eax, 4
  000de	74 0f		 je	 SHORT $LN54@z900_trans
  000e0	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN54@z900_trans:
  000ef	33 c0		 xor	 eax, eax
  000f1	85 c0		 test	 eax, eax
  000f3	75 c8		 jne	 SHORT $LN4@z900_trans
$LN7@z900_trans:

; 239  : 
; 240  :     TXF_SIE_INTERCEPT( regs, TEND );

  000f5	33 c0		 xor	 eax, eax
  000f7	83 f8 01	 cmp	 eax, 1
  000fa	0f 84 1f 01 00
	00		 je	 $LN55@z900_trans
  00100	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00108	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010e	d1 e8		 shr	 eax, 1
  00110	83 e0 01	 and	 eax, 1
  00113	85 c0		 test	 eax, eax
  00115	0f 84 04 01 00
	00		 je	 $LN55@z900_trans
  0011b	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00123	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0012a	b9 01 00 00 00	 mov	 ecx, 1
  0012f	48 6b c9 01	 imul	 rcx, rcx, 1
  00133	0f b6 44 08 60	 movzx	 eax, BYTE PTR [rax+rcx+96]
  00138	83 e0 10	 and	 eax, 16
  0013b	85 c0		 test	 eax, eax
  0013d	0f 85 dc 00 00
	00		 jne	 $LN55@z900_trans
  00143	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014a	83 b8 4c 05 00
	00 00		 cmp	 DWORD PTR [rax+1356], 0
  00151	0f 84 ad 00 00
	00		 je	 $LN56@z900_trans
  00157	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015f	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00166	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv135[rsp], eax
  0016d	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00175	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0017c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00183	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00191	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv137[rsp], rax
  00199	b9 01 00 00 00	 mov	 ecx, 1
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192835
  001ab	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001b0	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv135[rsp]
  001b7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001bb	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv137[rsp]
  001c3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192836
  001cf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192837
  001db	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e5	41 b9 03 00 00
	00		 mov	 r9d, 3
  001eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG192838
  001f2	ba f0 00 00 00	 mov	 edx, 240		; 000000f0H
  001f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192839
  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN56@z900_trans:
  00204	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00212	ba fc ff ff ff	 mov	 edx, -4
  00217	48 8b c8	 mov	 rcx, rax
  0021a	e8 00 00 00 00	 call	 longjmp
$LN55@z900_trans:
  0021f	33 c0		 xor	 eax, eax
  00221	85 c0		 test	 eax, eax
  00223	0f 85 cc fe ff
	ff		 jne	 $LN7@z900_trans
$LN10@z900_trans:

; 241  : 
; 242  :     TXF_EXECUTE_INSTR_CHECK( regs );

  00229	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00231	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00237	83 e0 01	 and	 eax, 1
  0023a	85 c0		 test	 eax, eax
  0023c	74 12		 je	 SHORT $LN57@z900_trans
  0023e	ba 03 00 00 00	 mov	 edx, 3
  00243	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0024b	e8 00 00 00 00	 call	 z900_program_interrupt
$LN57@z900_trans:
  00250	33 c0		 xor	 eax, eax
  00252	85 c0		 test	 eax, eax
  00254	75 d3		 jne	 SHORT $LN10@z900_trans

; 243  : 
; 244  :     if (!(regs->CR(0) & CR0_TXC))

  00256	b8 08 00 00 00	 mov	 eax, 8
  0025b	48 6b c0 01	 imul	 rax, rax, 1
  0025f	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00267	48 ba 00 00 00
	00 00 00 80 00	 mov	 rdx, 36028797018963968	; 0080000000000000H
  00271	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00279	48 23 c2	 and	 rax, rdx
  0027c	48 85 c0	 test	 rax, rax
  0027f	0f 85 97 00 00
	00		 jne	 $LN58@z900_trans
$LN13@z900_trans:

; 245  :     {
; 246  :         PTT_TXF( "*TXF end", regs->CR(0), regs->txf_contran, regs->txf_tnd );

  00285	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0028c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0028f	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00295	48 85 c0	 test	 rax, rax
  00298	74 66		 je	 SHORT $LN59@z900_trans
  0029a	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a2	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  002a9	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b1	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  002b8	ba 08 00 00 00	 mov	 edx, 8
  002bd	48 6b d2 01	 imul	 rdx, rdx, 1
  002c1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002ca	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192843
  002d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002db	44 8b c9	 mov	 r9d, ecx
  002de	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e6	4c 8b 84 10 00
	06 00 00	 mov	 r8, QWORD PTR [rax+rdx+1536]
  002ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192844
  002f5	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  002fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN59@z900_trans:
  00300	33 c0		 xor	 eax, eax
  00302	85 c0		 test	 eax, eax
  00304	0f 85 7b ff ff
	ff		 jne	 $LN13@z900_trans

; 247  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIAL_OPERATION_EXCEPTION );

  0030a	ba 13 00 00 00	 mov	 edx, 19
  0030f	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00317	e8 00 00 00 00	 call	 z900_program_interrupt
$LN58@z900_trans:

; 248  :         UNREACHABLE_CODE( return );
; 249  :     }
; 250  : 
; 251  :     if (regs->txf_abortctr)

  0031c	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00324	0f b7 80 60 0e
	00 00		 movzx	 eax, WORD PTR [rax+3680]
  0032b	85 c0		 test	 eax, eax
  0032d	0f 84 c2 00 00
	00		 je	 $LN60@z900_trans
$LN16@z900_trans:

; 252  :     {
; 253  :         PTT_TXF( "*TXF end", regs->txf_abortctr, regs->txf_contran, regs->txf_tnd );

  00333	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0033a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0033d	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00343	48 85 c0	 test	 rax, rax
  00346	74 5f		 je	 SHORT $LN61@z900_trans
  00348	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00350	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00357	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0035f	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00366	48 8b 94 24 98
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0036e	0f b7 92 60 0e
	00 00		 movzx	 edx, WORD PTR [rdx+3680]
  00375	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0037e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00383	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192847
  0038a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0038f	44 8b c9	 mov	 r9d, ecx
  00392	44 8b c2	 mov	 r8d, edx
  00395	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192848
  0039c	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  003a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN61@z900_trans:
  003a7	33 c0		 xor	 eax, eax
  003a9	85 c0		 test	 eax, eax
  003ab	75 86		 jne	 SHORT $LN16@z900_trans

; 254  :         regs->txf_why |= TXF_WHY_RAND_ABORT;

  003ad	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b5	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  003bb	0f ba e8 1d	 bts	 eax, 29
  003bf	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c7	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 255  :         ABORT_TRANS( regs, ABORT_RETRY_PGMCHK, regs->txf_random_tac );

  003cd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192849
  003d4	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003dc	44 8b 80 0c af
	00 00		 mov	 r8d, DWORD PTR [rax+44812]
  003e3	ba 02 00 00 00	 mov	 edx, 2
  003e8	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f0	e8 00 00 00 00	 call	 z900_abort_transaction
$LN60@z900_trans:

; 256  :         UNREACHABLE_CODE( return );
; 257  :     }
; 258  : 
; 259  :     /* Set condition code based on CURRENT transaction level */
; 260  :     if (!regs->txf_tnd)

  003f5	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003fd	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00404	85 c0		 test	 eax, eax
  00406	75 62		 jne	 SHORT $LN62@z900_trans
$LN19@z900_trans:

; 261  :     {
; 262  :         /* Not currently in transactional-execution mode.
; 263  :            Set CC 2 and treat as no-op (i.e. just return
; 264  :            since there is no active transaction to end)
; 265  :         */
; 266  :         PTT_TXF( "*TXF end", 0, 0, 0 );

  00408	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0040f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00412	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00418	48 85 c0	 test	 rax, rax
  0041b	74 36		 je	 SHORT $LN63@z900_trans
  0041d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00426	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0042f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192852
  00436	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0043b	45 33 c9	 xor	 r9d, r9d
  0043e	45 33 c0	 xor	 r8d, r8d
  00441	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192853
  00448	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0044d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN63@z900_trans:
  00453	33 c0		 xor	 eax, eax
  00455	85 c0		 test	 eax, eax
  00457	75 af		 jne	 SHORT $LN19@z900_trans

; 267  :         regs->psw.cc = 2;   /* CPU wasn't in transaction mode */

  00459	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00461	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 268  :         return;             /* Nothing to do. Just return. */

  00465	e9 e9 18 00 00	 jmp	 $LN1@z900_trans
$LN62@z900_trans:

; 269  :     }
; 270  : 
; 271  :     /* CPU was in transaction-execution mode at start of operation */
; 272  :     regs->psw.cc = 0;

  0046a	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00472	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 273  : 
; 274  :     /*-----------------------------------------------------*/
; 275  :     /*  Serialize TEND processing by obtaining INTLOCK     */
; 276  :     /*  and synchronizing the CPUS.                        */
; 277  :     /*-----------------------------------------------------*/
; 278  :     OBTAIN_INTLOCK( regs );

  00476	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192854
  0047d	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00485	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 279  :     {
; 280  :         bool   txf_contran;      /* (saved original value) */
; 281  :         U16    txf_abortctr;     /* (saved original value) */
; 282  :         BYTE*  txf_aie;          /* (saved original value) */
; 283  :         U64    txf_aie_aiv;      /* (saved original value) */
; 284  :         U64    txf_aie_aiv2;     /* (saved original value) */
; 285  :         int    txf_aie_off2;     /* (saved original value) */
; 286  :         BYTE   refchg;           /* (storagekey work flag) */
; 287  : 
; 288  :         SYNCHRONIZE_CPUS( regs );

  0048a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192855
  00491	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00499	e8 00 00 00 00	 call	 synchronize_cpus

; 289  : 
; 290  :         OBTAIN_TXFLOCK( regs );

  0049e	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004a6	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  004ad	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004b4	48 8d 84 c1 48
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+840]
  004bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192856
  004c3	48 8b c8	 mov	 rcx, rax
  004c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 291  :         {
; 292  :             regs->txf_tnd--;

  004cc	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d4	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  004db	fe c8		 dec	 al
  004dd	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e5	88 81 58 0e 00
	00		 mov	 BYTE PTR [rcx+3672], al

; 293  : 
; 294  :             txf_tnd = regs->txf_tnd;

  004eb	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f3	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  004fa	89 44 24 7c	 mov	 DWORD PTR txf_tnd$[rsp], eax

; 295  :             txf_tac = regs->txf_tac;

  004fe	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00506	8b 80 08 af 00
	00		 mov	 eax, DWORD PTR [rax+44808]
  0050c	89 84 24 84 00
	00 00		 mov	 DWORD PTR txf_tac$[rsp], eax

; 296  :         }
; 297  :         RELEASE_TXFLOCK( regs );

  00513	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0051b	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00522	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00529	48 8d 84 c1 48
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+840]
  00531	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192857
  00538	48 8b c8	 mov	 rcx, rax
  0053b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN22@z900_trans:

; 298  : 
; 299  :         TXF_TRACE_INIT( regs );

  00541	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00549	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00551	8b 89 84 af 00
	00		 mov	 ecx, DWORD PTR [rcx+44932]
  00557	89 88 ac af 00
	00		 mov	 DWORD PTR [rax+44972], ecx
  0055d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00565	0f bf 80 3c 08
	00 00		 movsx	 eax, WORD PTR [rax+2108]
  0056c	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00574	89 81 b0 af 00
	00		 mov	 DWORD PTR [rcx+44976], eax
  0057a	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00582	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00589	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00591	89 81 b4 af 00
	00		 mov	 DWORD PTR [rcx+44980], eax
  00597	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0059f	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a7	8b 89 08 af 00
	00		 mov	 ecx, DWORD PTR [rcx+44808]
  005ad	89 88 b8 af 00
	00		 mov	 DWORD PTR [rax+44984], ecx
  005b3	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005bb	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c3	8b 89 50 0e 00
	00		 mov	 ecx, DWORD PTR [rcx+3664]
  005c9	89 88 bc af 00
	00		 mov	 DWORD PTR [rax+44988], ecx
  005cf	33 c0		 xor	 eax, eax
  005d1	85 c0		 test	 eax, eax
  005d3	0f 85 68 ff ff
	ff		 jne	 $LN22@z900_trans

; 300  : 
; 301  :         /* Still in transaction-execution mode? */
; 302  :         if (txf_tnd)

  005d9	83 7c 24 7c 00	 cmp	 DWORD PTR txf_tnd$[rsp], 0
  005de	0f 84 3e 05 00
	00		 je	 $LN64@z900_trans

; 303  :         {
; 304  :             /*---------------------------------------------------------*/
; 305  :             /* Abort transaction if abort code already set by someone. */
; 306  :             /*---------------------------------------------------------*/
; 307  :             if (txf_tac)

  005e4	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR txf_tac$[rsp], 0
  005ec	0f 84 aa 00 00
	00		 je	 $LN65@z900_trans
$LN25@z900_trans:

; 308  :             {
; 309  :                 PTT_TXF( "*TXF end", txf_tac, regs->txf_contran, txf_tnd );

  005f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005f9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005fc	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00602	48 85 c0	 test	 rax, rax
  00605	74 4e		 je	 SHORT $LN66@z900_trans
  00607	48 63 44 24 7c	 movsxd	 rax, DWORD PTR txf_tnd$[rsp]
  0060c	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00614	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  0061b	48 63 94 24 84
	00 00 00	 movsxd	 rdx, DWORD PTR txf_tac$[rsp]
  00623	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0062c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00631	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192861
  00638	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0063d	44 8b c9	 mov	 r9d, ecx
  00640	4c 8b c2	 mov	 r8, rdx
  00643	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192862
  0064a	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0064f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN66@z900_trans:
  00655	33 c0		 xor	 eax, eax
  00657	85 c0		 test	 eax, eax
  00659	75 97		 jne	 SHORT $LN25@z900_trans

; 310  :                 regs->txf_why |= TXF_WHY_DELAYED_ABORT;

  0065b	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00663	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00669	0f ba e8 11	 bts	 eax, 17
  0066d	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00675	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 311  :                 ABORT_TRANS( regs, ABORT_RETRY_CC, txf_tac );

  0067b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192863
  00682	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR txf_tac$[rsp]
  0068a	ba 01 00 00 00	 mov	 edx, 1
  0068f	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00697	e8 00 00 00 00	 call	 z900_abort_transaction
$LN65@z900_trans:

; 312  :                 UNREACHABLE_CODE( return );
; 313  :             }
; 314  : 
; 315  :             /*--------------------------------------------*/
; 316  :             /*           NESTED TRANSACTION END           */
; 317  :             /*--------------------------------------------*/
; 318  : 
; 319  :             if (TXF_TRACE( regs, SUCCESS, regs->txf_contran ))

  0069c	33 c0		 xor	 eax, eax
  0069e	83 f8 01	 cmp	 eax, 1
  006a1	0f 84 48 03 00
	00		 je	 $LN67@z900_trans
  006a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006ae	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  006b4	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  006b9	85 c0		 test	 eax, eax
  006bb	0f 84 2e 03 00
	00		 je	 $LN67@z900_trans
  006c1	33 c0		 xor	 eax, eax
  006c3	83 f8 01	 cmp	 eax, 1
  006c6	0f 84 23 03 00
	00		 je	 $LN67@z900_trans
  006cc	33 c0		 xor	 eax, eax
  006ce	85 c0		 test	 eax, eax
  006d0	75 37		 jne	 SHORT $LN68@z900_trans
  006d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006d9	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  006df	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  006e4	85 c0		 test	 eax, eax
  006e6	74 21		 je	 SHORT $LN68@z900_trans
  006e8	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006f0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006f7	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  006fd	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00703	0f 85 e6 02 00
	00		 jne	 $LN67@z900_trans
$LN68@z900_trans:
  00709	33 c0		 xor	 eax, eax
  0070b	85 c0		 test	 eax, eax
  0070d	75 37		 jne	 SHORT $LN69@z900_trans
  0070f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00716	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0071c	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00721	85 c0		 test	 eax, eax
  00723	74 21		 je	 SHORT $LN69@z900_trans
  00725	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0072d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00734	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  0073a	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  00740	0f 8c a9 02 00
	00		 jl	 $LN67@z900_trans
$LN69@z900_trans:
  00746	33 c0		 xor	 eax, eax
  00748	85 c0		 test	 eax, eax
  0074a	75 73		 jne	 SHORT $LN70@z900_trans
  0074c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00753	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00759	25 00 00 00 0c	 and	 eax, 201326592		; 0c000000H
  0075e	3d 00 00 00 0c	 cmp	 eax, 201326592		; 0c000000H
  00763	74 5a		 je	 SHORT $LN70@z900_trans
  00765	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0076c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00772	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00777	85 c0		 test	 eax, eax
  00779	74 13		 je	 SHORT $LN71@z900_trans
  0077b	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00783	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0078a	85 c0		 test	 eax, eax
  0078c	75 31		 jne	 SHORT $LN70@z900_trans
$LN71@z900_trans:
  0078e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00795	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0079b	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  007a0	85 c0		 test	 eax, eax
  007a2	0f 84 47 02 00
	00		 je	 $LN67@z900_trans
  007a8	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007b0	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  007b7	85 c0		 test	 eax, eax
  007b9	0f 85 30 02 00
	00		 jne	 $LN67@z900_trans
$LN70@z900_trans:
  007bf	33 c0		 xor	 eax, eax
  007c1	85 c0		 test	 eax, eax
  007c3	0f 85 e0 00 00
	00		 jne	 $LN72@z900_trans
  007c9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007d0	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  007d6	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  007db	85 c0		 test	 eax, eax
  007dd	0f 84 c6 00 00
	00		 je	 $LN72@z900_trans
  007e3	33 c0		 xor	 eax, eax
  007e5	83 f8 01	 cmp	 eax, 1
  007e8	0f 84 01 02 00
	00		 je	 $LN67@z900_trans
  007ee	33 c0		 xor	 eax, eax
  007f0	85 c0		 test	 eax, eax
  007f2	75 3b		 jne	 SHORT $LN73@z900_trans
  007f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007fb	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00801	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00806	85 c0		 test	 eax, eax
  00808	74 25		 je	 SHORT $LN73@z900_trans
  0080a	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00812	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00819	8b 89 50 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1360]
  0081f	8b 80 ac af 00
	00		 mov	 eax, DWORD PTR [rax+44972]
  00825	23 c1		 and	 eax, ecx
  00827	85 c0		 test	 eax, eax
  00829	0f 84 c0 01 00
	00		 je	 $LN67@z900_trans
$LN73@z900_trans:
  0082f	33 c0		 xor	 eax, eax
  00831	85 c0		 test	 eax, eax
  00833	75 37		 jne	 SHORT $LN74@z900_trans
  00835	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0083c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00842	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00847	85 c0		 test	 eax, eax
  00849	74 21		 je	 SHORT $LN74@z900_trans
  0084b	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00853	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0085a	8b 89 54 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1364]
  00860	39 88 b8 af 00
	00		 cmp	 DWORD PTR [rax+44984], ecx
  00866	0f 85 83 01 00
	00		 jne	 $LN67@z900_trans
$LN74@z900_trans:
  0086c	33 c0		 xor	 eax, eax
  0086e	85 c0		 test	 eax, eax
  00870	75 37		 jne	 SHORT $LN75@z900_trans
  00872	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00879	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0087f	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00884	85 c0		 test	 eax, eax
  00886	74 21		 je	 SHORT $LN75@z900_trans
  00888	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00890	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00897	8b 89 5c 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1372]
  0089d	39 88 bc af 00
	00		 cmp	 DWORD PTR [rax+44988], ecx
  008a3	0f 8c 46 01 00
	00		 jl	 $LN67@z900_trans
$LN75@z900_trans:
$LN72@z900_trans:

; 320  :             {
; 321  :                 // "TXF: %s%02X: %sSuccessful %s Nested TEND for TND %d => %d"
; 322  :                 WRMSG( HHC17700, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),

  008a9	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  008b8	85 c0		 test	 eax, eax
  008ba	74 11		 je	 SHORT $LN121@z900_trans
  008bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192873
  008c3	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv361[rsp], rax
  008cb	eb 0f		 jmp	 SHORT $LN122@z900_trans
$LN121@z900_trans:
  008cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192874
  008d4	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv361[rsp], rax
$LN122@z900_trans:
  008dc	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008e4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  008ea	d1 e8		 shr	 eax, 1
  008ec	83 e0 01	 and	 eax, 1
  008ef	85 c0		 test	 eax, eax
  008f1	74 11		 je	 SHORT $LN123@z900_trans
  008f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192875
  008fa	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv367[rsp], rax
  00902	eb 0f		 jmp	 SHORT $LN124@z900_trans
$LN123@z900_trans:
  00904	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192876
  0090b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv367[rsp], rax
$LN124@z900_trans:
  00913	8b 44 24 7c	 mov	 eax, DWORD PTR txf_tnd$[rsp]
  00917	ff c0		 inc	 eax
  00919	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv356[rsp], eax
  00920	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00928	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0092f	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv370[rsp], ecx
  00936	48 8b 94 24 98
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0093e	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  00945	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  0094c	41 0f b6 8c 10
	48 0b 00 00	 movzx	 ecx, BYTE PTR [r8+rdx+2888]
  00955	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0095b	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv372[rsp], rax
  00963	b9 01 00 00 00	 mov	 ecx, 1
  00968	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0096e	8b 4c 24 7c	 mov	 ecx, DWORD PTR txf_tnd$[rsp]
  00972	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00976	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv356[rsp]
  0097d	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00981	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv361[rsp]
  00989	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0098e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv367[rsp]
  00996	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0099b	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv370[rsp]
  009a2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  009a6	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv372[rsp]
  009ae	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  009b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192877
  009ba	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192878
  009c6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009cb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009d0	41 b9 03 00 00
	00		 mov	 r9d, 3
  009d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG192879
  009dd	ba 43 01 00 00	 mov	 edx, 323		; 00000143H
  009e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192880
  009e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN67@z900_trans:

; 323  :                     TXF_CONSTRAINED( regs->txf_contran ), txf_tnd + 1, txf_tnd );
; 324  :             }
; 325  : 
; 326  :             /* If we're now at or below the highest nesting level
; 327  :                that allowed AR changes or float instructions, then
; 328  :                enable (set) the corresponding control flag.
; 329  :                Otherwise leave it alone (should already be off).
; 330  :             */
; 331  :             if (txf_tnd <= regs->txf_higharchange)

  009ef	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009f7	0f b7 80 5a 0e
	00 00		 movzx	 eax, WORD PTR [rax+3674]
  009fe	39 44 24 7c	 cmp	 DWORD PTR txf_tnd$[rsp], eax
  00a02	7f 34		 jg	 SHORT $LN76@z900_trans

; 332  :             {
; 333  :                 regs->txf_higharchange = txf_tnd;

  00a04	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a0c	0f b7 4c 24 7c	 movzx	 ecx, WORD PTR txf_tnd$[rsp]
  00a11	66 89 88 5a 0e
	00 00		 mov	 WORD PTR [rax+3674], cx

; 334  :                 regs->txf_ctlflag |= TXF_CTL_AR;

  00a18	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a20	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00a27	83 c8 08	 or	 eax, 8
  00a2a	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a32	88 81 59 0e 00
	00		 mov	 BYTE PTR [rcx+3673], al
$LN76@z900_trans:

; 335  :             }
; 336  : 
; 337  :             if (txf_tnd <= regs->txf_highfloat)

  00a38	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a40	0f b7 80 5c 0e
	00 00		 movzx	 eax, WORD PTR [rax+3676]
  00a47	39 44 24 7c	 cmp	 DWORD PTR txf_tnd$[rsp], eax
  00a4b	7f 34		 jg	 SHORT $LN77@z900_trans

; 338  :             {
; 339  :                 regs->txf_highfloat = txf_tnd;

  00a4d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a55	0f b7 4c 24 7c	 movzx	 ecx, WORD PTR txf_tnd$[rsp]
  00a5a	66 89 88 5c 0e
	00 00		 mov	 WORD PTR [rax+3676], cx

; 340  :                 regs->txf_ctlflag |= TXF_CTL_FLOAT;

  00a61	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a69	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  00a70	83 c8 04	 or	 eax, 4
  00a73	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a7b	88 81 59 0e 00
	00		 mov	 BYTE PTR [rcx+3673], al
$LN77@z900_trans:

; 341  :             }
; 342  : 
; 343  :             /* Set PIFC for this nesting level */
; 344  :             regs->txf_pifc = regs->txf_pifctab[ txf_tnd - 1 ];

  00a81	8b 44 24 7c	 mov	 eax, DWORD PTR txf_tnd$[rsp]
  00a85	ff c8		 dec	 eax
  00a87	48 98		 cdqe
  00a89	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a91	48 8b 94 24 98
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a99	0f b7 84 42 8c
	af 00 00	 movzx	 eax, WORD PTR [rdx+rax*2+44940]
  00aa1	66 89 81 62 0e
	00 00		 mov	 WORD PTR [rcx+3682], ax
$LN28@z900_trans:

; 345  : 
; 346  :             /* Remain in transactional-execution mode */
; 347  :             PTT_TXF( "TXF end", 0, regs->txf_contran, txf_tnd );

  00aa8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00aaf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00ab2	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00ab8	48 85 c0	 test	 rax, rax
  00abb	74 46		 je	 SHORT $LN78@z900_trans
  00abd	48 63 44 24 7c	 movsxd	 rax, DWORD PTR txf_tnd$[rsp]
  00ac2	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aca	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00ad1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00ada	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00adf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192884
  00ae6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00aeb	44 8b c9	 mov	 r9d, ecx
  00aee	45 33 c0	 xor	 r8d, r8d
  00af1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192885
  00af8	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00afd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN78@z900_trans:
  00b03	33 c0		 xor	 eax, eax
  00b05	85 c0		 test	 eax, eax
  00b07	75 9f		 jne	 SHORT $LN28@z900_trans

; 348  :             RELEASE_INTLOCK( regs );

  00b09	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192886
  00b10	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b18	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 349  :             return;

  00b1d	e9 31 12 00 00	 jmp	 $LN1@z900_trans
$LN64@z900_trans:

; 350  :         }
; 351  : 
; 352  :         /*---------------------------------------------------------*/
; 353  :         /*         THE OUTERMOST TRANSACTION HAS ENDED             */
; 354  :         /*---------------------------------------------------------*/
; 355  : 
; 356  :         /*---------------------------------------------------------*/
; 357  :         /* Abort transaction if abort code already set by someone. */
; 358  :         /*---------------------------------------------------------*/
; 359  :         if (txf_tac)

  00b22	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR txf_tac$[rsp], 0
  00b2a	0f 84 c9 00 00
	00		 je	 $LN79@z900_trans
$LN31@z900_trans:

; 360  :         {
; 361  :             PTT_TXF( "*TXF end", txf_tac, regs->txf_contran, txf_tnd );

  00b30	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00b37	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00b3a	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00b40	48 85 c0	 test	 rax, rax
  00b43	74 4e		 je	 SHORT $LN80@z900_trans
  00b45	48 63 44 24 7c	 movsxd	 rax, DWORD PTR txf_tnd$[rsp]
  00b4a	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b52	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00b59	48 63 94 24 84
	00 00 00	 movsxd	 rdx, DWORD PTR txf_tac$[rsp]
  00b61	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00b6a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00b6f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192889
  00b76	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b7b	44 8b c9	 mov	 r9d, ecx
  00b7e	4c 8b c2	 mov	 r8, rdx
  00b81	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192890
  00b88	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00b8d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN80@z900_trans:
  00b93	33 c0		 xor	 eax, eax
  00b95	85 c0		 test	 eax, eax
  00b97	75 97		 jne	 SHORT $LN31@z900_trans

; 362  :             regs->txf_why |= TXF_WHY_DELAYED_ABORT;

  00b99	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ba1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00ba7	0f ba e8 11	 bts	 eax, 17
  00bab	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bb3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 363  :             regs->txf_tnd++; // (prevent 'abort_transaction' crash)

  00bb9	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bc1	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00bc8	fe c0		 inc	 al
  00bca	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bd2	88 81 58 0e 00
	00		 mov	 BYTE PTR [rcx+3672], al

; 364  :             ABORT_TRANS( regs, ABORT_RETRY_CC, txf_tac );

  00bd8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192891
  00bdf	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR txf_tac$[rsp]
  00be7	ba 01 00 00 00	 mov	 edx, 1
  00bec	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bf4	e8 00 00 00 00	 call	 z900_abort_transaction
$LN79@z900_trans:

; 365  :             UNREACHABLE_CODE( return );
; 366  :         }
; 367  : 
; 368  :         /*---------------------------------------------------------*/
; 369  :         /*  End the transaction normally if no conflicts detected  */
; 370  :         /*---------------------------------------------------------*/
; 371  : 
; 372  :         txf_contran  = regs->txf_contran;        /* save */

  00bf9	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c01	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00c08	88 44 24 70	 mov	 BYTE PTR txf_contran$1[rsp], al

; 373  :         txf_abortctr = regs->txf_abortctr;       /* save */

  00c0c	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c14	0f b7 80 60 0e
	00 00		 movzx	 eax, WORD PTR [rax+3680]
  00c1b	66 89 84 24 94
	00 00 00	 mov	 WORD PTR txf_abortctr$3[rsp], ax

; 374  :         txf_aie      = regs->txf_aie;            /* save */

  00c23	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c2b	48 8b 80 60 af
	00 00		 mov	 rax, QWORD PTR [rax+44896]
  00c32	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR txf_aie$6[rsp], rax

; 375  :         txf_aie_aiv  = regs->txf_aie_aiv;        /* save */

  00c3a	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c42	48 8b 80 68 af
	00 00		 mov	 rax, QWORD PTR [rax+44904]
  00c49	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR txf_aie_aiv$7[rsp], rax

; 376  :         txf_aie_aiv2 = regs->txf_aie_aiv2;       /* save */

  00c51	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c59	48 8b 80 70 af
	00 00		 mov	 rax, QWORD PTR [rax+44912]
  00c60	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR txf_aie_aiv2$8[rsp], rax

; 377  :         txf_aie_off2 = regs->txf_aie_off2;       /* save */

  00c68	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c70	8b 80 78 af 00
	00		 mov	 eax, DWORD PTR [rax+44920]
  00c76	89 84 24 bc 00
	00 00		 mov	 DWORD PTR txf_aie_off2$5[rsp], eax

; 378  : 
; 379  :         regs->txf_contran  = false;              /* reset */

  00c7d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c85	c6 80 4c 0e 00
	00 00		 mov	 BYTE PTR [rax+3660], 0

; 380  :         regs->txf_abortctr = 0;                  /* reset */

  00c8c	33 c0		 xor	 eax, eax
  00c8e	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c96	66 89 81 60 0e
	00 00		 mov	 WORD PTR [rcx+3680], ax

; 381  :         regs->txf_aie      = NULL;               /* reset */

  00c9d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ca5	48 c7 80 60 af
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+44896], 0

; 382  :         regs->txf_aie_aiv  = 0;                  /* reset */

  00cb0	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cb8	48 c7 80 68 af
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+44904], 0

; 383  :         regs->txf_aie_aiv2 = 0;                  /* reset */

  00cc3	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ccb	48 c7 80 70 af
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+44912], 0

; 384  :         regs->txf_aie_off2 = 0;                  /* reset */

  00cd6	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cde	c7 80 78 af 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+44920], 0

; 385  : 
; 386  :         /*---------------------------------------------------------*/
; 387  :         /*                 Scan for conflicts                      */
; 388  :         /*---------------------------------------------------------*/
; 389  :         /*  Scan the page map table.  There is one entry in the    */
; 390  :         /*  page map table for each page referenced while in       */
; 391  :         /*  transaction mode.  There is also a cache line map      */
; 392  :         /*  that keeps track of what cache lines within the        */
; 393  :         /*  page have been referenced and whether the reference    */
; 394  :         /*  was a store or a fetch.  The current data in the       */
; 395  :         /*  cache line is saved when the alternate entry is        */
; 396  :         /*  created. This saved data MUST match what is in main    */
; 397  :         /*  storage now, or the transation will be aborted with    */
; 398  :         /*  a conflict, since that means that some other CPU or    */
; 399  :         /*  the channel subsystem has stored into the cache line.  */
; 400  :         /*---------------------------------------------------------*/
; 401  : 
; 402  :         regs->txf_conflict = 0;

  00ce8	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cf0	48 c7 80 78 0e
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+3704], 0

; 403  :         pmap = regs->txf_pagesmap;

  00cfb	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d03	48 05 80 0e 00
	00		 add	 rax, 3712		; 00000e80H
  00d09	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pmap$[rsp], rax

; 404  : 
; 405  :         for (i=0; i < regs->txf_pgcnt; i++, pmap++)

  00d11	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00d1c	eb 24		 jmp	 SHORT $LN34@z900_trans
$LN32@z900_trans:
  00d1e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00d25	ff c0		 inc	 eax
  00d27	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00d2e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pmap$[rsp]
  00d36	48 83 c0 28	 add	 rax, 40			; 00000028H
  00d3a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pmap$[rsp], rax
$LN34@z900_trans:
  00d42	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d4a	8b 80 80 ae 00
	00		 mov	 eax, DWORD PTR [rax+44672]
  00d50	39 84 24 90 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00d57	0f 8d 6d 02 00
	00		 jge	 $LN33@z900_trans

; 406  :         {
; 407  :             for (j=0; j < ZCACHE_LINE_PAGE; j++)

  00d5d	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00d65	eb 0a		 jmp	 SHORT $LN37@z900_trans
$LN35@z900_trans:
  00d67	8b 44 24 74	 mov	 eax, DWORD PTR j$[rsp]
  00d6b	ff c0		 inc	 eax
  00d6d	89 44 24 74	 mov	 DWORD PTR j$[rsp], eax
$LN37@z900_trans:
  00d71	83 7c 24 74 10	 cmp	 DWORD PTR j$[rsp], 16
  00d76	0f 8d 49 02 00
	00		 jge	 $LN36@z900_trans

; 408  :             {
; 409  :                 if (pmap->cachemap[j] == CM_CLEAN)

  00d7c	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$[rsp]
  00d81	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pmap$[rsp]
  00d89	0f b6 44 01 18	 movzx	 eax, BYTE PTR [rcx+rax+24]
  00d8e	85 c0		 test	 eax, eax
  00d90	75 02		 jne	 SHORT $LN81@z900_trans

; 410  :                     continue;

  00d92	eb d3		 jmp	 SHORT $LN35@z900_trans
$LN81@z900_trans:

; 411  : 
; 412  :                 mainaddr = pmap->mainpageaddr + (j << ZCACHE_LINE_SHIFT);

  00d94	8b 44 24 74	 mov	 eax, DWORD PTR j$[rsp]
  00d98	c1 e0 08	 shl	 eax, 8
  00d9b	48 98		 cdqe
  00d9d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pmap$[rsp]
  00da5	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00da9	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR mainaddr$[rsp], rax

; 413  :                 saveaddr = pmap->altpageaddr  + (j << ZCACHE_LINE_SHIFT) + ZPAGEFRAME_PAGESIZE;

  00db1	8b 44 24 74	 mov	 eax, DWORD PTR j$[rsp]
  00db5	c1 e0 08	 shl	 eax, 8
  00db8	48 98		 cdqe
  00dba	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pmap$[rsp]
  00dc2	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00dc6	48 8d 84 01 00
	10 00 00	 lea	 rax, QWORD PTR [rcx+rax+4096]
  00dce	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR saveaddr$[rsp], rax

; 414  : 
; 415  :                 if (memcmp( saveaddr, mainaddr, ZCACHE_LINE_SIZE ) == 0)

  00dd6	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00ddc	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR mainaddr$[rsp]
  00de4	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR saveaddr$[rsp]
  00dec	e8 00 00 00 00	 call	 memcmp
  00df1	85 c0		 test	 eax, eax
  00df3	75 05		 jne	 SHORT $LN82@z900_trans

; 416  :                     continue;

  00df5	e9 6d ff ff ff	 jmp	 $LN35@z900_trans
$LN82@z900_trans:

; 417  : 
; 418  :                 /*--------------------------------------*/
; 419  :                 /*          TRANSACTION FAILURE         */
; 420  :                 /*--------------------------------------*/
; 421  : 
; 422  :                 if (pmap->virtpageaddr)

  00dfa	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pmap$[rsp]
  00e02	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00e06	74 25		 je	 SHORT $LN83@z900_trans

; 423  :                     regs->txf_conflict = pmap->virtpageaddr + (j << ZCACHE_LINE_SHIFT);

  00e08	8b 44 24 74	 mov	 eax, DWORD PTR j$[rsp]
  00e0c	c1 e0 08	 shl	 eax, 8
  00e0f	48 98		 cdqe
  00e11	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pmap$[rsp]
  00e19	48 03 01	 add	 rax, QWORD PTR [rcx]
  00e1c	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e24	48 89 81 78 0e
	00 00		 mov	 QWORD PTR [rcx+3704], rax
  00e2b	eb 13		 jmp	 SHORT $LN84@z900_trans
$LN83@z900_trans:

; 424  :                 else
; 425  :                     regs->txf_conflict = 0;

  00e2d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e35	48 c7 80 78 0e
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+3704], 0
$LN84@z900_trans:

; 426  : 
; 427  :                 txf_tac = (pmap->cachemap[j] == CM_STORED) ?

  00e40	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$[rsp]
  00e45	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pmap$[rsp]
  00e4d	0f b6 44 01 18	 movzx	 eax, BYTE PTR [rcx+rax+24]
  00e52	83 f8 02	 cmp	 eax, 2
  00e55	75 0d		 jne	 SHORT $LN125@z900_trans
  00e57	c7 84 24 a0 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR tv542[rsp], 10
  00e62	eb 0b		 jmp	 SHORT $LN126@z900_trans
$LN125@z900_trans:
  00e64	c7 84 24 a0 00
	00 00 09 00 00
	00		 mov	 DWORD PTR tv542[rsp], 9
$LN126@z900_trans:
  00e6f	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv542[rsp]
  00e76	89 84 24 84 00
	00 00		 mov	 DWORD PTR txf_tac$[rsp], eax
$LN40@z900_trans:

; 428  :                     TAC_STORE_CNF : TAC_FETCH_CNF;
; 429  : 
; 430  :                 PTT_TXF( "*TXF end", txf_tac, txf_contran, txf_tnd );

  00e7d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00e84	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00e87	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00e8d	48 85 c0	 test	 rax, rax
  00e90	74 44		 je	 SHORT $LN85@z900_trans
  00e92	48 63 44 24 7c	 movsxd	 rax, DWORD PTR txf_tnd$[rsp]
  00e97	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR txf_contran$1[rsp]
  00e9c	48 63 94 24 84
	00 00 00	 movsxd	 rdx, DWORD PTR txf_tac$[rsp]
  00ea4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00ead	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00eb2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192897
  00eb9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ebe	44 8b c9	 mov	 r9d, ecx
  00ec1	4c 8b c2	 mov	 r8, rdx
  00ec4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192898
  00ecb	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00ed0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN85@z900_trans:
  00ed6	33 c0		 xor	 eax, eax
  00ed8	85 c0		 test	 eax, eax
  00eda	75 a1		 jne	 SHORT $LN40@z900_trans

; 431  : 
; 432  :                 regs->txf_contran  = txf_contran;      /* restore */

  00edc	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ee4	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR txf_contran$1[rsp]
  00ee9	88 88 4c 0e 00
	00		 mov	 BYTE PTR [rax+3660], cl

; 433  :                 regs->txf_abortctr = txf_abortctr;     /* restore */

  00eef	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ef7	0f b7 8c 24 94
	00 00 00	 movzx	 ecx, WORD PTR txf_abortctr$3[rsp]
  00eff	66 89 88 60 0e
	00 00		 mov	 WORD PTR [rax+3680], cx

; 434  :                 regs->txf_aie      = txf_aie;          /* restore */

  00f06	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f0e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR txf_aie$6[rsp]
  00f16	48 89 88 60 af
	00 00		 mov	 QWORD PTR [rax+44896], rcx

; 435  :                 regs->txf_aie_aiv  = txf_aie_aiv;      /* restore */

  00f1d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f25	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR txf_aie_aiv$7[rsp]
  00f2d	48 89 88 68 af
	00 00		 mov	 QWORD PTR [rax+44904], rcx

; 436  :                 regs->txf_aie_aiv2 = txf_aie_aiv2;     /* restore */

  00f34	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f3c	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR txf_aie_aiv2$8[rsp]
  00f44	48 89 88 70 af
	00 00		 mov	 QWORD PTR [rax+44912], rcx

; 437  :                 regs->txf_aie_off2 = txf_aie_off2;     /* restore */

  00f4b	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f53	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR txf_aie_off2$5[rsp]
  00f5a	89 88 78 af 00
	00		 mov	 DWORD PTR [rax+44920], ecx

; 438  : 
; 439  :                 regs->txf_why |= TXF_WHY_CONFLICT;

  00f60	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f68	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00f6e	0f ba e8 19	 bts	 eax, 25
  00f72	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f7a	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 440  :                 regs->txf_tnd++; // (prevent 'abort_transaction' crash)

  00f80	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f88	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00f8f	fe c0		 inc	 al
  00f91	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f99	88 81 58 0e 00
	00		 mov	 BYTE PTR [rcx+3672], al

; 441  :                 ABORT_TRANS( regs, ABORT_RETRY_CC, txf_tac );

  00f9f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192899
  00fa6	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR txf_tac$[rsp]
  00fae	ba 01 00 00 00	 mov	 edx, 1
  00fb3	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fbb	e8 00 00 00 00	 call	 z900_abort_transaction

; 442  :                 UNREACHABLE_CODE( return );
; 443  :             }

  00fc0	e9 a2 fd ff ff	 jmp	 $LN35@z900_trans
$LN36@z900_trans:

; 444  :         }

  00fc5	e9 54 fd ff ff	 jmp	 $LN32@z900_trans
$LN33@z900_trans:

; 445  : 
; 446  :         /*---------------------------------------------------------*/
; 447  :         /*                 TRANSACTION SUCCESS                     */
; 448  :         /*---------------------------------------------------------*/
; 449  :         /*  We have now validated all of the cache lines that we   */
; 450  :         /*  touched, and all other CPUs are dormant.  Now update   */
; 451  :         /*  the real cache lines from the shadow cache lines.      */
; 452  :         /*---------------------------------------------------------*/
; 453  : 
; 454  :         if (TXF_TRACE( regs, SUCCESS, txf_contran ))

  00fca	33 c0		 xor	 eax, eax
  00fcc	83 f8 01	 cmp	 eax, 1
  00fcf	0f 84 09 03 00
	00		 je	 $LN86@z900_trans
  00fd5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fdc	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00fe2	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00fe7	85 c0		 test	 eax, eax
  00fe9	0f 84 ef 02 00
	00		 je	 $LN86@z900_trans
  00fef	33 c0		 xor	 eax, eax
  00ff1	83 f8 01	 cmp	 eax, 1
  00ff4	0f 84 e4 02 00
	00		 je	 $LN86@z900_trans
  00ffa	33 c0		 xor	 eax, eax
  00ffc	85 c0		 test	 eax, eax
  00ffe	75 37		 jne	 SHORT $LN87@z900_trans
  01000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01007	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0100d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  01012	85 c0		 test	 eax, eax
  01014	74 21		 je	 SHORT $LN87@z900_trans
  01016	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0101e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01025	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  0102b	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  01031	0f 85 a7 02 00
	00		 jne	 $LN86@z900_trans
$LN87@z900_trans:
  01037	33 c0		 xor	 eax, eax
  01039	85 c0		 test	 eax, eax
  0103b	75 37		 jne	 SHORT $LN88@z900_trans
  0103d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01044	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0104a	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0104f	85 c0		 test	 eax, eax
  01051	74 21		 je	 SHORT $LN88@z900_trans
  01053	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0105b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01062	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  01068	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  0106e	0f 8c 6a 02 00
	00		 jl	 $LN86@z900_trans
$LN88@z900_trans:
  01074	33 c0		 xor	 eax, eax
  01076	85 c0		 test	 eax, eax
  01078	75 5f		 jne	 SHORT $LN89@z900_trans
  0107a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01081	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01087	25 00 00 00 0c	 and	 eax, 201326592		; 0c000000H
  0108c	3d 00 00 00 0c	 cmp	 eax, 201326592		; 0c000000H
  01091	74 46		 je	 SHORT $LN89@z900_trans
  01093	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0109a	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  010a0	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  010a5	85 c0		 test	 eax, eax
  010a7	74 09		 je	 SHORT $LN90@z900_trans
  010a9	0f b6 44 24 70	 movzx	 eax, BYTE PTR txf_contran$1[rsp]
  010ae	85 c0		 test	 eax, eax
  010b0	75 27		 jne	 SHORT $LN89@z900_trans
$LN90@z900_trans:
  010b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  010b9	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  010bf	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  010c4	85 c0		 test	 eax, eax
  010c6	0f 84 12 02 00
	00		 je	 $LN86@z900_trans
  010cc	0f b6 44 24 70	 movzx	 eax, BYTE PTR txf_contran$1[rsp]
  010d1	85 c0		 test	 eax, eax
  010d3	0f 85 05 02 00
	00		 jne	 $LN86@z900_trans
$LN89@z900_trans:
  010d9	33 c0		 xor	 eax, eax
  010db	85 c0		 test	 eax, eax
  010dd	0f 85 e0 00 00
	00		 jne	 $LN91@z900_trans
  010e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  010ea	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  010f0	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  010f5	85 c0		 test	 eax, eax
  010f7	0f 84 c6 00 00
	00		 je	 $LN91@z900_trans
  010fd	33 c0		 xor	 eax, eax
  010ff	83 f8 01	 cmp	 eax, 1
  01102	0f 84 d6 01 00
	00		 je	 $LN86@z900_trans
  01108	33 c0		 xor	 eax, eax
  0110a	85 c0		 test	 eax, eax
  0110c	75 3b		 jne	 SHORT $LN92@z900_trans
  0110e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01115	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0111b	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  01120	85 c0		 test	 eax, eax
  01122	74 25		 je	 SHORT $LN92@z900_trans
  01124	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0112c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01133	8b 89 50 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1360]
  01139	8b 80 ac af 00
	00		 mov	 eax, DWORD PTR [rax+44972]
  0113f	23 c1		 and	 eax, ecx
  01141	85 c0		 test	 eax, eax
  01143	0f 84 95 01 00
	00		 je	 $LN86@z900_trans
$LN92@z900_trans:
  01149	33 c0		 xor	 eax, eax
  0114b	85 c0		 test	 eax, eax
  0114d	75 37		 jne	 SHORT $LN93@z900_trans
  0114f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01156	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0115c	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  01161	85 c0		 test	 eax, eax
  01163	74 21		 je	 SHORT $LN93@z900_trans
  01165	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0116d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01174	8b 89 54 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1364]
  0117a	39 88 b8 af 00
	00		 cmp	 DWORD PTR [rax+44984], ecx
  01180	0f 85 58 01 00
	00		 jne	 $LN86@z900_trans
$LN93@z900_trans:
  01186	33 c0		 xor	 eax, eax
  01188	85 c0		 test	 eax, eax
  0118a	75 37		 jne	 SHORT $LN94@z900_trans
  0118c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01193	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01199	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  0119e	85 c0		 test	 eax, eax
  011a0	74 21		 je	 SHORT $LN94@z900_trans
  011a2	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  011b1	8b 89 5c 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1372]
  011b7	39 88 bc af 00
	00		 cmp	 DWORD PTR [rax+44988], ecx
  011bd	0f 8c 1b 01 00
	00		 jl	 $LN86@z900_trans
$LN94@z900_trans:
$LN91@z900_trans:

; 455  :         {
; 456  :             // "TXF: %s%02X: %sSuccessful Outermost %s TEND"
; 457  :             WRMSG( HHC17701, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),

  011c3	0f b6 44 24 70	 movzx	 eax, BYTE PTR txf_contran$1[rsp]
  011c8	85 c0		 test	 eax, eax
  011ca	74 11		 je	 SHORT $LN127@z900_trans
  011cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192909
  011d3	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv635[rsp], rax
  011db	eb 0f		 jmp	 SHORT $LN128@z900_trans
$LN127@z900_trans:
  011dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192910
  011e4	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv635[rsp], rax
$LN128@z900_trans:
  011ec	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011f4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  011fa	d1 e8		 shr	 eax, 1
  011fc	83 e0 01	 and	 eax, 1
  011ff	85 c0		 test	 eax, eax
  01201	74 11		 je	 SHORT $LN129@z900_trans
  01203	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192911
  0120a	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv641[rsp], rax
  01212	eb 0f		 jmp	 SHORT $LN130@z900_trans
$LN129@z900_trans:
  01214	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192912
  0121b	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv641[rsp], rax
$LN130@z900_trans:
  01223	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0122b	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01232	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv644[rsp], eax
  01239	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01241	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01248	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0124f	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  01257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0125d	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv646[rsp], rax
  01265	b9 01 00 00 00	 mov	 ecx, 1
  0126a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01270	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv635[rsp]
  01278	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0127d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv641[rsp]
  01285	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0128a	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv644[rsp]
  01291	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01295	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv646[rsp]
  0129d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  012a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192913
  012a9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  012ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192914
  012b5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012bf	41 b9 03 00 00
	00		 mov	 r9d, 3
  012c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG192915
  012cc	ba ca 01 00 00	 mov	 edx, 458		; 000001caH
  012d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192916
  012d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN86@z900_trans:

; 458  :                 TXF_CONSTRAINED( txf_contran ));
; 459  :         }
; 460  : 
; 461  :         /* Commit all of our transactional changes */
; 462  :         pmap = regs->txf_pagesmap;

  012de	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012e6	48 05 80 0e 00
	00		 add	 rax, 3712		; 00000e80H
  012ec	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pmap$[rsp], rax

; 463  : 
; 464  :         for (i=0; i < regs->txf_pgcnt; i++, pmap++)

  012f4	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  012ff	eb 24		 jmp	 SHORT $LN43@z900_trans
$LN41@z900_trans:
  01301	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01308	ff c0		 inc	 eax
  0130a	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
  01311	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pmap$[rsp]
  01319	48 83 c0 28	 add	 rax, 40			; 00000028H
  0131d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pmap$[rsp], rax
$LN43@z900_trans:
  01325	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0132d	8b 80 80 ae 00
	00		 mov	 eax, DWORD PTR [rax+44672]
  01333	39 84 24 90 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  0133a	0f 8d 39 04 00
	00		 jge	 $LN42@z900_trans

; 465  :         {
; 466  :             refchg = STORKEY_REF; // (wouldn't be in map if it wasn't!)

  01340	c6 44 24 78 04	 mov	 BYTE PTR refchg$2[rsp], 4

; 467  : 
; 468  :             if (TXF_TRACE_PAGES( regs, txf_contran ))

  01345	33 c0		 xor	 eax, eax
  01347	83 f8 01	 cmp	 eax, 1
  0134a	0f 84 3e 02 00
	00		 je	 $LN95@z900_trans
  01350	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01357	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0135d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01362	85 c0		 test	 eax, eax
  01364	0f 84 24 02 00
	00		 je	 $LN95@z900_trans
  0136a	33 c0		 xor	 eax, eax
  0136c	83 f8 01	 cmp	 eax, 1
  0136f	0f 84 19 02 00
	00		 je	 $LN95@z900_trans
  01375	33 c0		 xor	 eax, eax
  01377	85 c0		 test	 eax, eax
  01379	75 37		 jne	 SHORT $LN96@z900_trans
  0137b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01382	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01388	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0138d	85 c0		 test	 eax, eax
  0138f	74 21		 je	 SHORT $LN96@z900_trans
  01391	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01399	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  013a0	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  013a6	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  013ac	0f 85 dc 01 00
	00		 jne	 $LN95@z900_trans
$LN96@z900_trans:
  013b2	33 c0		 xor	 eax, eax
  013b4	85 c0		 test	 eax, eax
  013b6	75 37		 jne	 SHORT $LN97@z900_trans
  013b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  013bf	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  013c5	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  013ca	85 c0		 test	 eax, eax
  013cc	74 21		 je	 SHORT $LN97@z900_trans
  013ce	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013d6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  013dd	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  013e3	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  013e9	0f 8c 9f 01 00
	00		 jl	 $LN95@z900_trans
$LN97@z900_trans:
  013ef	33 c0		 xor	 eax, eax
  013f1	85 c0		 test	 eax, eax
  013f3	75 5f		 jne	 SHORT $LN98@z900_trans
  013f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  013fc	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01402	25 00 00 00 0c	 and	 eax, 201326592		; 0c000000H
  01407	3d 00 00 00 0c	 cmp	 eax, 201326592		; 0c000000H
  0140c	74 46		 je	 SHORT $LN98@z900_trans
  0140e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01415	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0141b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  01420	85 c0		 test	 eax, eax
  01422	74 09		 je	 SHORT $LN99@z900_trans
  01424	0f b6 44 24 70	 movzx	 eax, BYTE PTR txf_contran$1[rsp]
  01429	85 c0		 test	 eax, eax
  0142b	75 27		 jne	 SHORT $LN98@z900_trans
$LN99@z900_trans:
  0142d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01434	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0143a	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0143f	85 c0		 test	 eax, eax
  01441	0f 84 47 01 00
	00		 je	 $LN95@z900_trans
  01447	0f b6 44 24 70	 movzx	 eax, BYTE PTR txf_contran$1[rsp]
  0144c	85 c0		 test	 eax, eax
  0144e	0f 85 3a 01 00
	00		 jne	 $LN95@z900_trans
$LN98@z900_trans:

; 469  :             {
; 470  :                 // "TXF: %s%02X: %svirt 0x%16.16"PRIX64", abs 0x%16.16"PRIX64", alt 0x%16.16"PRIX64
; 471  :                 WRMSG( HHC17704, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),

  01454	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0145c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01462	d1 e8		 shr	 eax, 1
  01464	83 e0 01	 and	 eax, 1
  01467	85 c0		 test	 eax, eax
  01469	74 11		 je	 SHORT $LN131@z900_trans
  0146b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192922
  01472	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv713[rsp], rax
  0147a	eb 0f		 jmp	 SHORT $LN132@z900_trans
$LN131@z900_trans:
  0147c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192923
  01483	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv713[rsp], rax
$LN132@z900_trans:
  0148b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pmap$[rsp]
  01493	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0149b	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  014a2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  014a6	48 2b c1	 sub	 rax, rcx
  014a9	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv705[rsp], rax
  014b1	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  014b9	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  014c0	89 8c 24 c4 00
	00 00		 mov	 DWORD PTR tv716[rsp], ecx
  014c7	48 8b 94 24 98
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  014cf	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  014d6	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  014dd	41 0f b6 8c 10
	48 0b 00 00	 movzx	 ecx, BYTE PTR [r8+rdx+2888]
  014e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  014ec	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv718[rsp], rax
  014f4	b9 01 00 00 00	 mov	 ecx, 1
  014f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  014ff	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pmap$[rsp]
  01507	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0150b	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  01510	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv705[rsp]
  01518	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0151d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pmap$[rsp]
  01525	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  01528	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0152d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv713[rsp]
  01535	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0153a	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv716[rsp]
  01541	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01545	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv718[rsp]
  0154d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01552	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192924
  01559	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0155e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192925
  01565	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0156a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0156f	41 b9 03 00 00
	00		 mov	 r9d, 3
  01575	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG192926
  0157c	ba da 01 00 00	 mov	 edx, 474		; 000001daH
  01581	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192927
  01588	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN95@z900_trans:

; 472  :                     (U64) pmap->virtpageaddr,
; 473  :                     (U64)(pmap->mainpageaddr - regs->mainstor),
; 474  :                     (U64) pmap->altpageaddr );
; 475  :             }
; 476  : 
; 477  :             for (j=0; j < ZCACHE_LINE_PAGE; j++)

  0158e	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  01596	eb 0a		 jmp	 SHORT $LN46@z900_trans
$LN44@z900_trans:
  01598	8b 44 24 74	 mov	 eax, DWORD PTR j$[rsp]
  0159c	ff c0		 inc	 eax
  0159e	89 44 24 74	 mov	 DWORD PTR j$[rsp], eax
$LN46@z900_trans:
  015a2	83 7c 24 74 10	 cmp	 DWORD PTR j$[rsp], 16
  015a7	0f 8d 9d 01 00
	00		 jge	 $LN45@z900_trans

; 478  :             {
; 479  :                 if (pmap->cachemap[j] != CM_STORED)

  015ad	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$[rsp]
  015b2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pmap$[rsp]
  015ba	0f b6 44 01 18	 movzx	 eax, BYTE PTR [rcx+rax+24]
  015bf	83 f8 02	 cmp	 eax, 2
  015c2	74 02		 je	 SHORT $LN100@z900_trans

; 480  :                     continue;

  015c4	eb d2		 jmp	 SHORT $LN44@z900_trans
$LN100@z900_trans:

; 481  : 
; 482  :                 mainaddr = pmap->mainpageaddr + (j << ZCACHE_LINE_SHIFT);

  015c6	8b 44 24 74	 mov	 eax, DWORD PTR j$[rsp]
  015ca	c1 e0 08	 shl	 eax, 8
  015cd	48 98		 cdqe
  015cf	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pmap$[rsp]
  015d7	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  015db	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR mainaddr$[rsp], rax

; 483  :                 altaddr  = pmap->altpageaddr  + (j << ZCACHE_LINE_SHIFT);

  015e3	8b 44 24 74	 mov	 eax, DWORD PTR j$[rsp]
  015e7	c1 e0 08	 shl	 eax, 8
  015ea	48 98		 cdqe
  015ec	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pmap$[rsp]
  015f4	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  015f8	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR altaddr$[rsp], rax

; 484  : 
; 485  :                 memcpy( mainaddr, altaddr, ZCACHE_LINE_SIZE );

  01600	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR mainaddr$[rsp]
  01608	48 8b b4 24 08
	01 00 00	 mov	 rsi, QWORD PTR altaddr$[rsp]
  01610	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  01615	f3 a4		 rep movsb

; 486  :                 refchg |= STORKEY_CHANGE;

  01617	0f b6 44 24 78	 movzx	 eax, BYTE PTR refchg$2[rsp]
  0161c	83 c8 02	 or	 eax, 2
  0161f	88 44 24 78	 mov	 BYTE PTR refchg$2[rsp], al

; 487  : 
; 488  :                 if (TXF_TRACE_LINES( regs, txf_contran ))

  01623	33 c0		 xor	 eax, eax
  01625	83 f8 01	 cmp	 eax, 1
  01628	0f 84 17 01 00
	00		 je	 $LN101@z900_trans
  0162e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01635	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0163b	83 e0 40	 and	 eax, 64			; 00000040H
  0163e	85 c0		 test	 eax, eax
  01640	0f 84 ff 00 00
	00		 je	 $LN101@z900_trans
  01646	33 c0		 xor	 eax, eax
  01648	83 f8 01	 cmp	 eax, 1
  0164b	0f 84 f4 00 00
	00		 je	 $LN101@z900_trans
  01651	33 c0		 xor	 eax, eax
  01653	85 c0		 test	 eax, eax
  01655	75 37		 jne	 SHORT $LN102@z900_trans
  01657	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0165e	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01664	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  01669	85 c0		 test	 eax, eax
  0166b	74 21		 je	 SHORT $LN102@z900_trans
  0166d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01675	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0167c	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  01682	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  01688	0f 85 b7 00 00
	00		 jne	 $LN101@z900_trans
$LN102@z900_trans:
  0168e	33 c0		 xor	 eax, eax
  01690	85 c0		 test	 eax, eax
  01692	75 33		 jne	 SHORT $LN103@z900_trans
  01694	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0169b	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  016a1	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  016a6	85 c0		 test	 eax, eax
  016a8	74 1d		 je	 SHORT $LN103@z900_trans
  016aa	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  016b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  016b9	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  016bf	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  016c5	7c 7e		 jl	 SHORT $LN101@z900_trans
$LN103@z900_trans:
  016c7	33 c0		 xor	 eax, eax
  016c9	85 c0		 test	 eax, eax
  016cb	75 57		 jne	 SHORT $LN104@z900_trans
  016cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  016d4	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  016da	25 00 00 00 0c	 and	 eax, 201326592		; 0c000000H
  016df	3d 00 00 00 0c	 cmp	 eax, 201326592		; 0c000000H
  016e4	74 3e		 je	 SHORT $LN104@z900_trans
  016e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  016ed	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  016f3	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  016f8	85 c0		 test	 eax, eax
  016fa	74 09		 je	 SHORT $LN105@z900_trans
  016fc	0f b6 44 24 70	 movzx	 eax, BYTE PTR txf_contran$1[rsp]
  01701	85 c0		 test	 eax, eax
  01703	75 1f		 jne	 SHORT $LN104@z900_trans
$LN105@z900_trans:
  01705	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0170c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01712	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  01717	85 c0		 test	 eax, eax
  01719	74 2a		 je	 SHORT $LN101@z900_trans
  0171b	0f b6 44 24 70	 movzx	 eax, BYTE PTR txf_contran$1[rsp]
  01720	85 c0		 test	 eax, eax
  01722	75 21		 jne	 SHORT $LN101@z900_trans
$LN104@z900_trans:

; 489  :                 {
; 490  :                     // "TXF: %s%02X: %sWe stored:  +"
; 491  :                     dump_cache( regs, TXF_DUMP_PFX( HHC17707 ), j, altaddr );

  01724	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR altaddr$[rsp]
  0172c	44 8b 44 24 74	 mov	 r8d, DWORD PTR j$[rsp]
  01731	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192934
  01738	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01740	e8 00 00 00 00	 call	 dump_cache
$LN101@z900_trans:

; 492  :                 }
; 493  :             }

  01745	e9 4e fe ff ff	 jmp	 $LN44@z900_trans
$LN45@z900_trans:

; 494  : 
; 495  :             ARCH_DEP( or_storage_key )( MAIN_TO_ABS( pmap->mainpageaddr ), refchg );

  0174a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pmap$[rsp]
  01752	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01759	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  01760	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  01764	48 2b c1	 sub	 rax, rcx
  01767	0f b6 54 24 78	 movzx	 edx, BYTE PTR refchg$2[rsp]
  0176c	48 8b c8	 mov	 rcx, rax
  0176f	e8 00 00 00 00	 call	 z900_or_storage_key

; 496  :         }

  01774	e9 88 fb ff ff	 jmp	 $LN41@z900_trans
$LN42@z900_trans:

; 497  : 
; 498  :         /* Mark the page map as now being empty */
; 499  :         regs->txf_pgcnt = 0;

  01779	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01781	c7 80 80 ae 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+44672], 0
$LN49@z900_trans:

; 500  : 
; 501  :         /*------------------------------------------*/
; 502  :         /*  We are done. Release INTLOCK and exit.  */
; 503  :         /*------------------------------------------*/
; 504  : 
; 505  :         PTT_TXF( "TXF end", 0, 0, 0 );

  0178b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01792	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01795	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  0179b	48 85 c0	 test	 rax, rax
  0179e	74 36		 je	 SHORT $LN106@z900_trans
  017a0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  017a9	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  017b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192936
  017b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  017be	45 33 c9	 xor	 r9d, r9d
  017c1	45 33 c0	 xor	 r8d, r8d
  017c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192937
  017cb	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  017d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN106@z900_trans:
  017d6	33 c0		 xor	 eax, eax
  017d8	85 c0		 test	 eax, eax
  017da	75 af		 jne	 SHORT $LN49@z900_trans

; 506  : 
; 507  :         /*---------------------------------------------*/
; 508  :         /*          Trace failure retry success        */
; 509  :         /*---------------------------------------------*/
; 510  :         if (1
; 511  :             && MLVL( VERBOSE )
; 512  :             && regs->txf_aborts
; 513  :             && TXF_TRACE( regs, FAILURE, txf_contran )

  017dc	33 c0		 xor	 eax, eax
  017de	83 f8 01	 cmp	 eax, 1
  017e1	0f 84 55 03 00
	00		 je	 $LN107@z900_trans
  017e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  017ee	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  017f4	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  017f9	85 c0		 test	 eax, eax
  017fb	0f 84 3b 03 00
	00		 je	 $LN107@z900_trans
  01801	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01809	83 b8 50 0e 00
	00 00		 cmp	 DWORD PTR [rax+3664], 0
  01810	0f 84 26 03 00
	00		 je	 $LN107@z900_trans
  01816	33 c0		 xor	 eax, eax
  01818	83 f8 01	 cmp	 eax, 1
  0181b	0f 84 1b 03 00
	00		 je	 $LN107@z900_trans
  01821	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01828	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0182e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  01833	85 c0		 test	 eax, eax
  01835	0f 84 01 03 00
	00		 je	 $LN107@z900_trans
  0183b	33 c0		 xor	 eax, eax
  0183d	83 f8 01	 cmp	 eax, 1
  01840	0f 84 f6 02 00
	00		 je	 $LN107@z900_trans
  01846	33 c0		 xor	 eax, eax
  01848	85 c0		 test	 eax, eax
  0184a	75 37		 jne	 SHORT $LN108@z900_trans
  0184c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01853	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01859	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0185e	85 c0		 test	 eax, eax
  01860	74 21		 je	 SHORT $LN108@z900_trans
  01862	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0186a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01871	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  01877	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  0187d	0f 85 b9 02 00
	00		 jne	 $LN107@z900_trans
$LN108@z900_trans:
  01883	33 c0		 xor	 eax, eax
  01885	85 c0		 test	 eax, eax
  01887	75 37		 jne	 SHORT $LN109@z900_trans
  01889	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01890	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01896	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0189b	85 c0		 test	 eax, eax
  0189d	74 21		 je	 SHORT $LN109@z900_trans
  0189f	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  018a7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  018ae	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  018b4	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  018ba	0f 8c 7c 02 00
	00		 jl	 $LN107@z900_trans
$LN109@z900_trans:
  018c0	33 c0		 xor	 eax, eax
  018c2	85 c0		 test	 eax, eax
  018c4	75 5f		 jne	 SHORT $LN110@z900_trans
  018c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  018cd	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  018d3	25 00 00 00 0c	 and	 eax, 201326592		; 0c000000H
  018d8	3d 00 00 00 0c	 cmp	 eax, 201326592		; 0c000000H
  018dd	74 46		 je	 SHORT $LN110@z900_trans
  018df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  018e6	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  018ec	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  018f1	85 c0		 test	 eax, eax
  018f3	74 09		 je	 SHORT $LN111@z900_trans
  018f5	0f b6 44 24 70	 movzx	 eax, BYTE PTR txf_contran$1[rsp]
  018fa	85 c0		 test	 eax, eax
  018fc	75 27		 jne	 SHORT $LN110@z900_trans
$LN111@z900_trans:
  018fe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01905	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0190b	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  01910	85 c0		 test	 eax, eax
  01912	0f 84 24 02 00
	00		 je	 $LN107@z900_trans
  01918	0f b6 44 24 70	 movzx	 eax, BYTE PTR txf_contran$1[rsp]
  0191d	85 c0		 test	 eax, eax
  0191f	0f 85 17 02 00
	00		 jne	 $LN107@z900_trans
$LN110@z900_trans:
  01925	33 c0		 xor	 eax, eax
  01927	85 c0		 test	 eax, eax
  01929	0f 85 e0 00 00
	00		 jne	 $LN112@z900_trans
  0192f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01936	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0193c	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  01941	85 c0		 test	 eax, eax
  01943	0f 84 c6 00 00
	00		 je	 $LN112@z900_trans
  01949	33 c0		 xor	 eax, eax
  0194b	83 f8 01	 cmp	 eax, 1
  0194e	0f 84 e8 01 00
	00		 je	 $LN107@z900_trans
  01954	33 c0		 xor	 eax, eax
  01956	85 c0		 test	 eax, eax
  01958	75 3b		 jne	 SHORT $LN113@z900_trans
  0195a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01961	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01967	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  0196c	85 c0		 test	 eax, eax
  0196e	74 25		 je	 SHORT $LN113@z900_trans
  01970	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01978	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0197f	8b 89 50 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1360]
  01985	8b 80 ac af 00
	00		 mov	 eax, DWORD PTR [rax+44972]
  0198b	23 c1		 and	 eax, ecx
  0198d	85 c0		 test	 eax, eax
  0198f	0f 84 a7 01 00
	00		 je	 $LN107@z900_trans
$LN113@z900_trans:
  01995	33 c0		 xor	 eax, eax
  01997	85 c0		 test	 eax, eax
  01999	75 37		 jne	 SHORT $LN114@z900_trans
  0199b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  019a2	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  019a8	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  019ad	85 c0		 test	 eax, eax
  019af	74 21		 je	 SHORT $LN114@z900_trans
  019b1	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  019c0	8b 89 54 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1364]
  019c6	39 88 b8 af 00
	00		 cmp	 DWORD PTR [rax+44984], ecx
  019cc	0f 85 6a 01 00
	00		 jne	 $LN107@z900_trans
$LN114@z900_trans:
  019d2	33 c0		 xor	 eax, eax
  019d4	85 c0		 test	 eax, eax
  019d6	75 37		 jne	 SHORT $LN115@z900_trans
  019d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  019df	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  019e5	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  019ea	85 c0		 test	 eax, eax
  019ec	74 21		 je	 SHORT $LN115@z900_trans
  019ee	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  019fd	8b 89 5c 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1372]
  01a03	39 88 bc af 00
	00		 cmp	 DWORD PTR [rax+44988], ecx
  01a09	0f 8c 2d 01 00
	00		 jl	 $LN107@z900_trans
$LN115@z900_trans:
$LN112@z900_trans:

; 514  :         )
; 515  :         {
; 516  :             // "TXF: %s%02X: %s%s transaction succeeded after %d retries"
; 517  :             WRMSG( HHC17718, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),

  01a0f	0f b6 44 24 70	 movzx	 eax, BYTE PTR txf_contran$1[rsp]
  01a14	85 c0		 test	 eax, eax
  01a16	74 11		 je	 SHORT $LN133@z900_trans
  01a18	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192947
  01a1f	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv884[rsp], rax
  01a27	eb 0f		 jmp	 SHORT $LN134@z900_trans
$LN133@z900_trans:
  01a29	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192948
  01a30	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv884[rsp], rax
$LN134@z900_trans:
  01a38	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a40	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01a46	d1 e8		 shr	 eax, 1
  01a48	83 e0 01	 and	 eax, 1
  01a4b	85 c0		 test	 eax, eax
  01a4d	74 11		 je	 SHORT $LN135@z900_trans
  01a4f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192949
  01a56	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv890[rsp], rax
  01a5e	eb 0f		 jmp	 SHORT $LN136@z900_trans
$LN135@z900_trans:
  01a60	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192950
  01a67	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv890[rsp], rax
$LN136@z900_trans:
  01a6f	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a77	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01a7e	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv893[rsp], eax
  01a85	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01a8d	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01a94	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01a9b	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  01aa3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01aa9	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv895[rsp], rax
  01ab1	b9 01 00 00 00	 mov	 ecx, 1
  01ab6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01abc	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01ac4	8b 89 50 0e 00
	00		 mov	 ecx, DWORD PTR [rcx+3664]
  01aca	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  01ace	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv884[rsp]
  01ad6	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01adb	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv890[rsp]
  01ae3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01ae8	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv893[rsp]
  01aef	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01af3	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv895[rsp]
  01afb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01b00	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192951
  01b07	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01b0c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192952
  01b13	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b18	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b1d	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b23	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG192953
  01b2a	ba 06 02 00 00	 mov	 edx, 518		; 00000206H
  01b2f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192954
  01b36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN107@z900_trans:

; 518  :                 TXF_CONSTRAINED( txf_contran ), regs->txf_aborts );
; 519  :         }
; 520  : 
; 521  :         /* Track TXF statistics */
; 522  :         slot = regs->txf_aborts < TXF_STATS_RETRY_SLOTS ?

  01b3c	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b44	83 b8 50 0e 00
	00 09		 cmp	 DWORD PTR [rax+3664], 9
  01b4b	7d 17		 jge	 SHORT $LN137@z900_trans
  01b4d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b55	8b 80 50 0e 00
	00		 mov	 eax, DWORD PTR [rax+3664]
  01b5b	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv915[rsp], eax
  01b62	eb 0b		 jmp	 SHORT $LN138@z900_trans
$LN137@z900_trans:
  01b64	c7 84 24 a4 00
	00 00 08 00 00
	00		 mov	 DWORD PTR tv915[rsp], 8
$LN138@z900_trans:
  01b6f	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv915[rsp]
  01b76	89 84 24 cc 00
	00 00		 mov	 DWORD PTR slot$[rsp], eax

; 523  :                regs->txf_aborts : TXF_STATS_RETRY_SLOTS - 1;
; 524  :         TXF_STATS( retries[ slot ], txf_contran );

  01b7d	0f b6 44 24 70	 movzx	 eax, BYTE PTR txf_contran$1[rsp]
  01b82	85 c0		 test	 eax, eax
  01b84	74 0d		 je	 SHORT $LN139@z900_trans
  01b86	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv920[rsp], 1
  01b91	eb 0b		 jmp	 SHORT $LN140@z900_trans
$LN139@z900_trans:
  01b93	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv920[rsp], 0
$LN140@z900_trans:
  01b9e	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR tv920[rsp]
  01ba6	48 69 c0 e8 00
	00 00		 imul	 rax, rax, 232		; 000000e8H
  01bad	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01bb4	48 8d 84 01 78
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax+1400]
  01bbc	48 63 8c 24 cc
	00 00 00	 movsxd	 rcx, DWORD PTR slot$[rsp]
  01bc4	48 8d 84 c8 98
	00 00 00	 lea	 rax, QWORD PTR [rax+rcx*8+152]
  01bcc	ba 01 00 00 00	 mov	 edx, 1
  01bd1	48 8b c8	 mov	 rcx, rax
  01bd4	e8 00 00 00 00	 call	 atomic_update64

; 525  : 
; 526  :         /* Track retries high watermark */
; 527  :         if ((U64)regs->txf_aborts > sysblk.txf_stats[ txf_contran ].txf_retries_hwm)

  01bd9	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01be1	48 63 80 50 0e
	00 00		 movsxd	 rax, DWORD PTR [rax+3664]
  01be8	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR txf_contran$1[rsp]
  01bed	48 69 c9 e8 00
	00 00		 imul	 rcx, rcx, 232		; 000000e8H
  01bf4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01bfb	48 3b 84 0a 58
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1624]
  01c03	76 2a		 jbe	 SHORT $LN116@z900_trans

; 528  :             sysblk.txf_stats[ txf_contran ].txf_retries_hwm = (U64)regs->txf_aborts;

  01c05	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c0d	48 63 80 50 0e
	00 00		 movsxd	 rax, DWORD PTR [rax+3664]
  01c14	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR txf_contran$1[rsp]
  01c19	48 69 c9 e8 00
	00 00		 imul	 rcx, rcx, 232		; 000000e8H
  01c20	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01c27	48 89 84 0a 58
	06 00 00	 mov	 QWORD PTR [rdx+rcx+1624], rax
$LN116@z900_trans:

; 529  : 
; 530  :         /* Reset abort count */
; 531  :         regs->txf_aborts = 0;

  01c2f	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c37	c7 80 50 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+3664], 0

; 532  : 
; 533  :         /* Reset PPA assistance */
; 534  :         regs->txf_PPA = 0;

  01c41	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c49	c7 80 54 0e 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+3668], 0

; 535  : 
; 536  :         /* Reset CONSTRAINED trans instruction fetch constraint */
; 537  :         ARCH_DEP( reset_txf_aie )( regs );

  01c53	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01c5b	e8 00 00 00 00	 call	 z900_reset_txf_aie

; 538  : 
; 539  :         PERFORM_SERIALIZATION( regs );

  01c60	0f ae f0	 mfence

; 540  : 
; 541  :         /* Check if a transaction-end PER event is wanted */
; 542  :         if (EN_IC_PER_TEND( regs ))

  01c63	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c6b	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01c71	c1 e8 02	 shr	 eax, 2
  01c74	83 e0 01	 and	 eax, 1
  01c77	85 c0		 test	 eax, eax
  01c79	74 0d		 je	 SHORT $LN143@z900_trans
  01c7b	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv957[rsp], 1
  01c86	eb 0b		 jmp	 SHORT $LN144@z900_trans
$LN143@z900_trans:
  01c88	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv957[rsp], 0
$LN144@z900_trans:
  01c93	83 bc 24 ac 00
	00 00 00	 cmp	 DWORD PTR tv957[rsp], 0
  01c9b	74 5a		 je	 SHORT $LN117@z900_trans
  01c9d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ca5	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01ca8	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  01cad	85 c0		 test	 eax, eax
  01caf	74 46		 je	 SHORT $LN117@z900_trans

; 543  :         {
; 544  :             regs->peradr = regs->periaddr;

  01cb1	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01cb9	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01cc1	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  01cc8	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN52@z900_trans:

; 545  :             ON_IC_PER_TEND( regs );

  01ccf	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01cd7	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01cda	0f ba e8 11	 bts	 eax, 17
  01cde	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01ce6	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  01ce9	33 c0		 xor	 eax, eax
  01ceb	85 c0		 test	 eax, eax
  01ced	75 e0		 jne	 SHORT $LN52@z900_trans

; 546  :             per_tend = true;

  01cef	c6 84 24 80 00
	00 00 01	 mov	 BYTE PTR per_tend$[rsp], 1
$LN117@z900_trans:

; 547  :         }
; 548  :     }
; 549  :     RELEASE_INTLOCK( regs );

  01cf7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192957
  01cfe	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01d06	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 550  : 
; 551  :     /* If a PER TEND event was generated, check to
; 552  :        see if we can take the interrupt right away.
; 553  :     */
; 554  :     if (per_tend)

  01d0b	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR per_tend$[rsp]
  01d13	85 c0		 test	 eax, eax
  01d15	74 3c		 je	 SHORT $LN118@z900_trans

; 555  :     {
; 556  :         if (OPEN_IC_PER_TEND( regs ))

  01d17	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d1f	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01d27	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01d2a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01d2d	23 c1		 and	 eax, ecx
  01d2f	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  01d34	85 c0		 test	 eax, eax
  01d36	74 1b		 je	 SHORT $LN119@z900_trans

; 557  :             RETURN_INTCHECK( regs );

  01d38	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d40	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  01d46	ba ff ff ff ff	 mov	 edx, -1
  01d4b	48 8b c8	 mov	 rcx, rax
  01d4e	e8 00 00 00 00	 call	 longjmp
$LN119@z900_trans:
$LN118@z900_trans:
$LN1@z900_trans:
$LN120@z900_trans:

; 558  :     }
; 559  : 
; 560  : } /* end DEF_INST( transaction_end ) */

  01d53	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  01d5a	5f		 pop	 rdi
  01d5b	5e		 pop	 rsi
  01d5c	c3		 ret	 0
z900_transaction_end ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
i2$ = 80
b1$ = 84
temp$1 = 88
tv140 = 92
effective_addr1$ = 96
tv142 = 104
inst$ = 128
regs$ = 136
z900_transaction_begin_constrained PROC

; 705  : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 706  : S16     i2;                             /* 16-bit immediate value    */
; 707  : int     b1;                             /* Base of effective addr    */
; 708  : VADR    effective_addr1;                /* Effective address         */
; 709  : 
; 710  :     SIL( inst, regs, i2, b1, effective_addr1 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 02	 imul	 rax, rax, 2
  00017	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0001f	48 03 c8	 add	 rcx, rax
  00022	48 8b c1	 mov	 rax, rcx
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 _byteswap_ulong
  00034	89 44 24 58	 mov	 DWORD PTR temp$1[rsp], eax
  00038	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00041	66 89 44 24 50	 mov	 WORD PTR i2$[rsp], ax
  00046	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  0004a	c1 e8 10	 shr	 eax, 16
  0004d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00052	8b c0		 mov	 eax, eax
  00054	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00059	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  0005d	c1 e8 1c	 shr	 eax, 28
  00060	83 e0 0f	 and	 eax, 15
  00063	89 44 24 54	 mov	 DWORD PTR b1$[rsp], eax
  00067	83 7c 24 54 00	 cmp	 DWORD PTR b1$[rsp], 0
  0006c	74 44		 je	 SHORT $LN20@z900_trans
  0006e	48 63 44 24 54	 movsxd	 rax, DWORD PTR b1$[rsp]
  00073	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00083	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00088	48 03 c8	 add	 rcx, rax
  0008b	48 8b c1	 mov	 rax, rcx
  0008e	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00093	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000a7	48 23 c8	 and	 rcx, rax
  000aa	48 8b c1	 mov	 rax, rcx
  000ad	48 89 44 24 60	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN20@z900_trans:
$LN4@z900_trans:
  000b2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000be	48 83 c0 06	 add	 rax, 6
  000c2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000ce	33 c0		 xor	 eax, eax
  000d0	83 f8 06	 cmp	 eax, 6
  000d3	74 0f		 je	 SHORT $LN21@z900_trans
  000d5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN21@z900_trans:
  000e4	33 c0		 xor	 eax, eax
  000e6	85 c0		 test	 eax, eax
  000e8	75 c8		 jne	 SHORT $LN4@z900_trans
$LN7@z900_trans:

; 711  : 
; 712  :     TXF_SIE_INTERCEPT( regs, TBEGINC );

  000ea	33 c0		 xor	 eax, eax
  000ec	83 f8 01	 cmp	 eax, 1
  000ef	0f 84 13 01 00
	00		 je	 $LN22@z900_trans
  000f5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00103	d1 e8		 shr	 eax, 1
  00105	83 e0 01	 and	 eax, 1
  00108	85 c0		 test	 eax, eax
  0010a	0f 84 f8 00 00
	00		 je	 $LN22@z900_trans
  00110	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00118	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0011f	b9 01 00 00 00	 mov	 ecx, 1
  00124	48 6b c9 01	 imul	 rcx, rcx, 1
  00128	0f b6 44 08 60	 movzx	 eax, BYTE PTR [rax+rcx+96]
  0012d	83 e0 10	 and	 eax, 16
  00130	85 c0		 test	 eax, eax
  00132	0f 85 d0 00 00
	00		 jne	 $LN22@z900_trans
  00138	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0013f	83 b8 4c 05 00
	00 00		 cmp	 DWORD PTR [rax+1356], 0
  00146	0f 84 a1 00 00
	00		 je	 $LN23@z900_trans
  0014c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00154	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0015b	89 44 24 5c	 mov	 DWORD PTR tv140[rsp], eax
  0015f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00167	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0016e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00175	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00183	48 89 44 24 68	 mov	 QWORD PTR tv142[rsp], rax
  00188	b9 01 00 00 00	 mov	 ecx, 1
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193206
  0019a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0019f	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv140[rsp]
  001a3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001a7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv142[rsp]
  001ac	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193207
  001b8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193208
  001c4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ce	41 b9 03 00 00
	00		 mov	 r9d, 3
  001d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193209
  001db	ba c8 02 00 00	 mov	 edx, 712		; 000002c8H
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193210
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@z900_trans:
  001ed	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f5	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  001fb	ba fc ff ff ff	 mov	 edx, -4
  00200	48 8b c8	 mov	 rcx, rax
  00203	e8 00 00 00 00	 call	 longjmp
$LN22@z900_trans:
  00208	33 c0		 xor	 eax, eax
  0020a	85 c0		 test	 eax, eax
  0020c	0f 85 d8 fe ff
	ff		 jne	 $LN7@z900_trans

; 713  : 
; 714  :     if (!(regs->CR(0) & CR0_TXC))

  00212	b8 08 00 00 00	 mov	 eax, 8
  00217	48 6b c0 01	 imul	 rax, rax, 1
  0021b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00223	48 ba 00 00 00
	00 00 00 80 00	 mov	 rdx, 36028797018963968	; 0080000000000000H
  0022d	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00235	48 23 c2	 and	 rax, rdx
  00238	48 85 c0	 test	 rax, rax
  0023b	0f 85 97 00 00
	00		 jne	 $LN24@z900_trans
$LN10@z900_trans:

; 715  :     {
; 716  :         PTT_TXF( "*TXF TBEGINC", regs->CR(0), regs->txf_contran, regs->txf_tnd );

  00241	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00248	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0024b	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00251	48 85 c0	 test	 rax, rax
  00254	74 66		 je	 SHORT $LN25@z900_trans
  00256	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00265	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026d	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00274	ba 08 00 00 00	 mov	 edx, 8
  00279	48 6b d2 01	 imul	 rdx, rdx, 1
  0027d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00286	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0028b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193213
  00292	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00297	44 8b c9	 mov	 r9d, ecx
  0029a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a2	4c 8b 84 10 00
	06 00 00	 mov	 r8, QWORD PTR [rax+rdx+1536]
  002aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193214
  002b1	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  002b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN25@z900_trans:
  002bc	33 c0		 xor	 eax, eax
  002be	85 c0		 test	 eax, eax
  002c0	0f 85 7b ff ff
	ff		 jne	 $LN10@z900_trans

; 717  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIAL_OPERATION_EXCEPTION );

  002c6	ba 13 00 00 00	 mov	 edx, 19
  002cb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d3	e8 00 00 00 00	 call	 z900_program_interrupt
$LN24@z900_trans:
$LN13@z900_trans:

; 718  :         UNREACHABLE_CODE( return );
; 719  :     }
; 720  : 
; 721  :     TXF_EXECUTE_INSTR_CHECK( regs );

  002d8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e0	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002e6	83 e0 01	 and	 eax, 1
  002e9	85 c0		 test	 eax, eax
  002eb	74 12		 je	 SHORT $LN26@z900_trans
  002ed	ba 03 00 00 00	 mov	 edx, 3
  002f2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fa	e8 00 00 00 00	 call	 z900_program_interrupt
$LN26@z900_trans:
  002ff	33 c0		 xor	 eax, eax
  00301	85 c0		 test	 eax, eax
  00303	75 d3		 jne	 SHORT $LN13@z900_trans

; 722  : 
; 723  :     /* CONSTRAINED: Specification Exception if b1 is non-zero */
; 724  :     if (b1)

  00305	83 7c 24 54 00	 cmp	 DWORD PTR b1$[rsp], 0
  0030a	0f 84 82 00 00
	00		 je	 $LN27@z900_trans
$LN16@z900_trans:

; 725  :     {
; 726  :         PTT_TXF( "*TXF TBEGINC", b1, regs->txf_contran, regs->txf_tnd );

  00310	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00317	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0031a	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00320	48 85 c0	 test	 rax, rax
  00323	74 55		 je	 SHORT $LN28@z900_trans
  00325	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0032d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00334	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033c	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00343	48 63 54 24 54	 movsxd	 rdx, DWORD PTR b1$[rsp]
  00348	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00351	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00356	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193218
  0035d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00362	44 8b c9	 mov	 r9d, ecx
  00365	4c 8b c2	 mov	 r8, rdx
  00368	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193219
  0036f	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00374	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN28@z900_trans:
  0037a	33 c0		 xor	 eax, eax
  0037c	85 c0		 test	 eax, eax
  0037e	75 90		 jne	 SHORT $LN16@z900_trans

; 727  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  00380	ba 06 00 00 00	 mov	 edx, 6
  00385	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038d	e8 00 00 00 00	 call	 z900_program_interrupt
$LN27@z900_trans:

; 728  :         UNREACHABLE_CODE( return );
; 729  :     }
; 730  : 
; 731  :     /* CONSTRAINED: ignore some i2 bits */
; 732  :     i2 &= ~(TXF_CTL_FLOAT | TXF_CTL_PIFC);

  00392	0f bf 44 24 50	 movsx	 eax, WORD PTR i2$[rsp]
  00397	83 e0 f8	 and	 eax, -8
  0039a	66 89 44 24 50	 mov	 WORD PTR i2$[rsp], ax

; 733  : 
; 734  :     /* Obtain interrupt lock so "process_tbegin" can do SYNCHRONIZE_CPUS */
; 735  :     OBTAIN_INTLOCK( regs );

  0039f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193220
  003a6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ae	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN19@z900_trans:

; 736  :     {
; 737  :         /* Let our helper function do all the grunt work */
; 738  :         PTT_TXF( "TXF TBEGINC", 0, regs->txf_contran, regs->txf_tnd );

  003b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003ba	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003bd	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  003c3	48 85 c0	 test	 rax, rax
  003c6	74 50		 je	 SHORT $LN29@z900_trans
  003c8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d0	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  003d7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003df	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  003e6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003ef	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003f4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193222
  003fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00400	44 8b c9	 mov	 r9d, ecx
  00403	45 33 c0	 xor	 r8d, r8d
  00406	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193223
  0040d	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00412	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@z900_trans:
  00418	33 c0		 xor	 eax, eax
  0041a	85 c0		 test	 eax, eax
  0041c	75 95		 jne	 SHORT $LN19@z900_trans

; 739  :         ARCH_DEP( process_tbegin )( true, regs, i2, 0, 0 );

  0041e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00426	45 33 c9	 xor	 r9d, r9d
  00429	44 0f b7 44 24
	50		 movzx	 r8d, WORD PTR i2$[rsp]
  0042f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00437	b1 01		 mov	 cl, 1
  00439	e8 00 00 00 00	 call	 z900_process_tbegin

; 740  :     }
; 741  :     RELEASE_INTLOCK( regs );

  0043e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193224
  00445	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044d	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN30@z900_trans:

; 742  : 
; 743  : } /* end DEF_INST( transaction_begin_constrained ) */

  00452	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00456	c3		 ret	 0
z900_transaction_begin_constrained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
temp$1 = 64
m3$ = 68
tv140 = 72
abort_count$ = 76
r1$ = 80
r2$ = 84
inst$ = 112
regs$ = 120
z900_perform_processor_assist PROC

; 90   : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 91   : int     r1, r2;                         /* Operand register numbers  */
; 92   : int     m3;                             /* M3 Mask value             */
; 93   : U32     abort_count;                    /* Transaction Abort count   */
; 94   : 
; 95   :     RRF_M( inst, regs, r1, r2, m3 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 54	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 50	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 44	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_perfo:
  0004a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN16@z900_perfo
  00067	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN16@z900_perfo:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_perfo
$LN7@z900_perfo:

; 96   : 
; 97   :     UNREFERENCED( r2 );

  00079	33 c0		 xor	 eax, eax
  0007b	85 c0		 test	 eax, eax
  0007d	75 fa		 jne	 SHORT $LN7@z900_perfo
$LN10@z900_perfo:

; 98   : 
; 99   :     TXF_INSTR_CHECK( regs );

  0007f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00084	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0008b	85 c0		 test	 eax, eax
  0008d	74 36		 je	 SHORT $LN17@z900_perfo
  0008f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00094	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0009a	0f ba e8 0c	 bts	 eax, 12
  0009e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000a9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG192619
  000b0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000b6	ba 02 00 00 00	 mov	 edx, 2
  000bb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	e8 00 00 00 00	 call	 z900_abort_transaction
$LN17@z900_perfo:
  000c5	33 c0		 xor	 eax, eax
  000c7	85 c0		 test	 eax, eax
  000c9	75 b4		 jne	 SHORT $LN10@z900_perfo

; 100  : 
; 101  :     /* Retrieve abort count */
; 102  :     abort_count = regs->GR_L( r1 );

  000cb	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  000d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000dc	89 44 24 4c	 mov	 DWORD PTR abort_count$[rsp], eax
$LN13@z900_perfo:

; 103  : 
; 104  :     PTT_TXF( "TXF PPA", m3, abort_count, 0 );

  000e0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000e7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ea	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  000f0	48 85 c0	 test	 rax, rax
  000f3	74 3f		 je	 SHORT $LN18@z900_perfo
  000f5	8b 44 24 4c	 mov	 eax, DWORD PTR abort_count$[rsp]
  000f9	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m3$[rsp]
  000fe	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00107	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192621
  00117	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0011c	44 8b c8	 mov	 r9d, eax
  0011f	4c 8b c1	 mov	 r8, rcx
  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192622
  00129	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@z900_perfo:
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	75 a6		 jne	 SHORT $LN13@z900_perfo

; 105  : 
; 106  :     switch (m3)

  0013a	8b 44 24 44	 mov	 eax, DWORD PTR m3$[rsp]
  0013e	89 44 24 48	 mov	 DWORD PTR tv140[rsp], eax
  00142	83 7c 24 48 01	 cmp	 DWORD PTR tv140[rsp], 1
  00147	74 09		 je	 SHORT $LN19@z900_perfo
  00149	83 7c 24 48 0f	 cmp	 DWORD PTR tv140[rsp], 15
  0014e	74 13		 je	 SHORT $LN20@z900_perfo
  00150	eb 2a		 jmp	 SHORT $LN22@z900_perfo
$LN19@z900_perfo:

; 107  :     {
; 108  :     case 1: // Transaction Abort Assist
; 109  :     {
; 110  :         regs->txf_PPA = abort_count;

  00152	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00157	8b 4c 24 4c	 mov	 ecx, DWORD PTR abort_count$[rsp]
  0015b	89 88 54 0e 00
	00		 mov	 DWORD PTR [rax+3668], ecx

; 111  :         return;

  00161	eb 19		 jmp	 SHORT $LN1@z900_perfo
$LN20@z900_perfo:

; 112  :     }
; 113  : #if defined( FEATURE_081_PPA_IN_ORDER_FACILITY )
; 114  :     case 15: // In-order Execution Assist
; 115  :     {
; 116  :         if (FACILITY_ENABLED( 081_PPA_IN_ORDER, regs ))

  00163	b8 01 00 00 00	 mov	 eax, 1
  00168	48 6b c0 0a	 imul	 rax, rax, 10
  0016c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00171	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00179	83 e0 40	 and	 eax, 64			; 00000040H
$LN22@z900_perfo:
$LN1@z900_perfo:

; 117  :         {
; 118  :             /*
; 119  :                "When the function code in the M3 field is 15 and the
; 120  :                 PPA-in-order facility is installed, the processor is
; 121  :                 requested to complete processing all instructions prior
; 122  :                 to this PPA instruction, as observed by this CPU, before
; 123  :                 attempting storage-operand references for any instruction
; 124  :                 after this PPA instruction."
; 125  : 
; 126  :                "The R1 and R2 fields are ignored and the instruction is
; 127  :                 executed as a no-operation."
; 128  : 
; 129  :                "The in-order-execution assist does not necessarily perform
; 130  :                 any of the steps for architectural serialization described
; 131  :                 in the section "CPU Serialization" on page 5-130."
; 132  :             */
; 133  : 
; 134  :             /* NOTE: Hercules does not currently support this assist,
; 135  :                but if we ever do add code to support it this is where
; 136  :                such code should go...
; 137  :             */
; 138  : 
; 139  :             // TODO: add PPA-in-order Facility support code here...
; 140  : 
; 141  :             return;
; 142  :         }
; 143  : 
; 144  :         return;  /* (ignore unsupported assists) */
; 145  :     }
; 146  : #endif // defined(  FEATURE_081_PPA_IN_ORDER_FACILITY )
; 147  : 
; 148  :     default:     /* (unknown/unsupported assist) */
; 149  :         return;  /* (ignore unsupported assists) */
; 150  :     }
; 151  : 
; 152  :     UNREACHABLE_CODE( return );
; 153  : 
; 154  : } /* end DEF_INST( perform_processor_assist ) */

  0017c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00180	c3		 ret	 0
z900_perform_processor_assist ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
p$ = 8
count$ = 16
atomic_update64 PROC

; 425  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 426  : #if defined( _MSVC_ )
; 427  :     InterlockedExchangeAdd64( p, count );

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR p$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR count$[rsp]
  00014	f0 48 01 08	 lock add QWORD PTR [rax], rcx

; 428  : #else // GCC (and CLANG?)
; 429  :   #if defined( HAVE_SYNC_BUILTINS )
; 430  :     __sync_fetch_and_add( p, count );
; 431  :   #else
; 432  :     *p += count;  /* (N.B. non-atomic!) */
; 433  :   #endif
; 434  : #endif
; 435  : }

  00018	c3		 ret	 0
atomic_update64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
p$ = 8
count$ = 16
atomic_update32 PROC

; 413  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 414  : #if defined( _MSVC_ )
; 415  :     InterlockedExchangeAdd( p, count );

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR p$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR count$[rsp]
  00012	f0 01 08	 lock add DWORD PTR [rax], ecx

; 416  : #else // GCC (and CLANG?)
; 417  :   #if defined( HAVE_SYNC_BUILTINS )
; 418  :     __sync_fetch_and_add( p, count );
; 419  :   #else
; 420  :     *p += count;  /* (N.B. non-atomic!) */
; 421  :   #endif
; 422  : #endif
; 423  : }

  00015	c3		 ret	 0
atomic_update32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
i$ = 32
n$ = 36
mask$ = 40
i_regs$ = 48
tv176 = 56
tv181 = 64
regs$ = 96
location$ = 104
synchronize_cpus PROC

; 201  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 202  :     int i, n = 0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 203  :     REGS*  i_regs;
; 204  : 
; 205  :     CPU_BITMAP mask = sysblk.started_mask;

  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001d	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00024	48 89 44 24 28	 mov	 QWORD PTR mask$[rsp], rax

; 206  : 
; 207  :     /* Deselect current processor and waiting processors from mask */
; 208  :     mask &= ~(sysblk.waiting_mask | HOSTREGS->cpubit);

  00029	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 8b 89 b8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4792]
  00047	48 0b c8	 or	 rcx, rax
  0004a	48 8b c1	 mov	 rax, rcx
  0004d	48 f7 d0	 not	 rax
  00050	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mask$[rsp]
  00055	48 23 c8	 and	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 44 24 28	 mov	 QWORD PTR mask$[rsp], rax

; 209  : 
; 210  :     /* Deselect processors at a syncpoint and count active processors
; 211  :      */
; 212  :     for (i=0; mask && i < sysblk.hicpu; ++i)

  00060	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00068	eb 0a		 jmp	 SHORT $LN4@synchroniz
$LN2@synchroniz:
  0006a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0006e	ff c0		 inc	 eax
  00070	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@synchroniz:
  00074	48 83 7c 24 28
	00		 cmp	 QWORD PTR mask$[rsp], 0
  0007a	0f 84 04 01 00
	00		 je	 $LN3@synchroniz
  00080	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00087	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  0008d	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00091	0f 8d ed 00 00
	00		 jge	 $LN3@synchroniz

; 213  :     {
; 214  :         i_regs = sysblk.regs[i];

  00097	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0009c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a3	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000ab	48 89 44 24 30	 mov	 QWORD PTR i_regs$[rsp], rax

; 215  : 
; 216  :         if (mask & CPU_BIT( i ))

  000b0	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	48 89 4c 24 38	 mov	 QWORD PTR tv176[rsp], rcx
  000be	0f b6 c8	 movzx	 ecx, al
  000c1	48 8b 44 24 38	 mov	 rax, QWORD PTR tv176[rsp]
  000c6	48 d3 e0	 shl	 rax, cl
  000c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mask$[rsp]
  000ce	48 23 c8	 and	 rcx, rax
  000d1	48 8b c1	 mov	 rax, rcx
  000d4	48 85 c0	 test	 rax, rax
  000d7	0f 84 a2 00 00
	00		 je	 $LN11@synchroniz

; 217  :         {
; 218  :             if (AT_SYNCPOINT( i_regs ))

  000dd	48 8b 44 24 30	 mov	 rax, QWORD PTR i_regs$[rsp]
  000e2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e9	0f b6 80 f0 08
	00 00		 movzx	 eax, BYTE PTR [rax+2288]
  000f0	85 c0		 test	 eax, eax
  000f2	74 2b		 je	 SHORT $LN12@synchroniz

; 219  :             {
; 220  :                 /* Remove CPU already at syncpoint */
; 221  :                 mask ^= CPU_BIT(i);

  000f4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000f8	b9 01 00 00 00	 mov	 ecx, 1
  000fd	48 89 4c 24 40	 mov	 QWORD PTR tv181[rsp], rcx
  00102	0f b6 c8	 movzx	 ecx, al
  00105	48 8b 44 24 40	 mov	 rax, QWORD PTR tv181[rsp]
  0010a	48 d3 e0	 shl	 rax, cl
  0010d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mask$[rsp]
  00112	48 33 c8	 xor	 rcx, rax
  00115	48 8b c1	 mov	 rax, rcx
  00118	48 89 44 24 28	 mov	 QWORD PTR mask$[rsp], rax

; 222  :             }

  0011d	eb 60		 jmp	 SHORT $LN13@synchroniz
$LN12@synchroniz:

; 223  :             else
; 224  :             {
; 225  :                 /* Update count of active processors */
; 226  :                 ++n;

  0011f	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  00123	ff c0		 inc	 eax
  00125	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax
$LN7@synchroniz:

; 227  : 
; 228  :                 /* Test and set interrupt pending conditions */
; 229  :                 ON_IC_INTERRUPT( i_regs );

  00129	48 8b 44 24 30	 mov	 rax, QWORD PTR i_regs$[rsp]
  0012e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00131	0f ba e8 1f	 bts	 eax, 31
  00135	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i_regs$[rsp]
  0013a	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0013d	33 c0		 xor	 eax, eax
  0013f	85 c0		 test	 eax, eax
  00141	75 e6		 jne	 SHORT $LN7@synchroniz

; 230  : 
; 231  :                 if (SIE_MODE( i_regs ))

  00143	48 8b 44 24 30	 mov	 rax, QWORD PTR i_regs$[rsp]
  00148	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0014e	d1 e8		 shr	 eax, 1
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 28		 je	 SHORT $LN14@synchroniz
$LN10@synchroniz:

; 232  :                     ON_IC_INTERRUPT( GUEST( i_regs ));

  00157	48 8b 44 24 30	 mov	 rax, QWORD PTR i_regs$[rsp]
  0015c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00163	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00166	0f ba e8 1f	 bts	 eax, 31
  0016a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR i_regs$[rsp]
  0016f	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00176	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00179	33 c0		 xor	 eax, eax
  0017b	85 c0		 test	 eax, eax
  0017d	75 d8		 jne	 SHORT $LN10@synchroniz
$LN14@synchroniz:
$LN13@synchroniz:
$LN11@synchroniz:

; 233  :             }
; 234  :         }
; 235  :     }

  0017f	e9 e6 fe ff ff	 jmp	 $LN2@synchroniz
$LN3@synchroniz:

; 236  : 
; 237  :     /* If any interrupts are pending with active processors, other than
; 238  :      * self, open an interrupt window for those processors prior to
; 239  :      * considering self as synchronized.
; 240  :      */
; 241  :     if (n && mask)

  00184	83 7c 24 24 00	 cmp	 DWORD PTR n$[rsp], 0
  00189	0f 84 b3 00 00
	00		 je	 $LN15@synchroniz
  0018f	48 83 7c 24 28
	00		 cmp	 QWORD PTR mask$[rsp], 0
  00195	0f 84 a7 00 00
	00		 je	 $LN15@synchroniz

; 242  :     {
; 243  :         sysblk.sync_mask = mask;

  0019b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mask$[rsp]
  001a7	48 89 88 80 13
	00 00		 mov	 QWORD PTR [rax+4992], rcx

; 244  :         sysblk.syncing   = true;

  001ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b5	c6 80 7c 13 00
	00 01		 mov	 BYTE PTR [rax+4988], 1

; 245  : 
; 246  :         sysblk.intowner  = LOCK_OWNER_NONE;

  001bc	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  001c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001c8	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 247  :         {
; 248  :             hthread_wait_condition( &sysblk.all_synced_cond, &sysblk.intlock, location );

  001cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001d6	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  001dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001e3	48 81 c1 88 13
	00 00		 add	 rcx, 5000		; 00001388H
  001ea	4c 8b 44 24 68	 mov	 r8, QWORD PTR location$[rsp]
  001ef	48 8b d0	 mov	 rdx, rax
  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 249  :         }
; 250  :         sysblk.intowner  = HOSTREGS->cpuad;

  001f8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00204	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0020b	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00212	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 251  : 
; 252  :         sysblk.syncing   = false;

  00219	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00220	c6 80 7c 13 00
	00 00		 mov	 BYTE PTR [rax+4988], 0

; 253  :         hthread_broadcast_condition( &sysblk.sync_done_cond, location );

  00227	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0022e	48 05 90 13 00
	00		 add	 rax, 5008		; 00001390H
  00234	48 8b 54 24 68	 mov	 rdx, QWORD PTR location$[rsp]
  00239	48 8b c8	 mov	 rcx, rax
  0023c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN15@synchroniz:

; 254  :     }
; 255  :     /* All active processors other than self, are now waiting at their
; 256  :      * respective sync point. We may now safely proceed doing whatever
; 257  :      * it is we need to do.
; 258  :      */
; 259  : }

  00242	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00246	c3		 ret	 0
synchronize_cpus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
cpu$ = 64
regs$ = 72
cpuad$ = 96
why$ = 104
location$ = 112
txf_abort_all PROC

; 1898 : {

$LN18:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1899 :     int    cpu;
; 1900 :     REGS*  regs;
; 1901 : 
; 1902 :     why |= TXF_WHY_DELAYED_ABORT;

  00012	8b 44 24 68	 mov	 eax, DWORD PTR why$[rsp]
  00016	0f ba e8 11	 bts	 eax, 17
  0001a	89 44 24 68	 mov	 DWORD PTR why$[rsp], eax

; 1903 : 
; 1904 :     for (cpu=0, regs = sysblk.regs[ 0 ];

  0001e	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  00026	b8 08 00 00 00	 mov	 eax, 8
  0002b	48 6b c0 00	 imul	 rax, rax, 0
  0002f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00036	48 8b 84 01 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax+2968]
  0003e	48 89 44 24 48	 mov	 QWORD PTR regs$[rsp], rax
  00043	eb 23		 jmp	 SHORT $LN4@txf_abort_
$LN2@txf_abort_:

; 1905 :         cpu < sysblk.maxcpu; regs = sysblk.regs[ ++cpu ])

  00045	8b 44 24 40	 mov	 eax, DWORD PTR cpu$[rsp]
  00049	ff c0		 inc	 eax
  0004b	89 44 24 40	 mov	 DWORD PTR cpu$[rsp], eax
  0004f	48 63 44 24 40	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00054	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005b	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00063	48 89 44 24 48	 mov	 QWORD PTR regs$[rsp], rax
$LN4@txf_abort_:
  00068	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00075	39 44 24 40	 cmp	 DWORD PTR cpu$[rsp], eax
  00079	0f 8d d4 02 00
	00		 jge	 $LN3@txf_abort_

; 1906 :     {
; 1907 :         /* Skip ourselves or any CPU that isn't online */
; 1908 :         if (0
; 1909 :             || !IS_CPU_ONLINE( cpu )
; 1910 :             || regs->cpuad == cpuad

  0007f	33 c0		 xor	 eax, eax
  00081	85 c0		 test	 eax, eax
  00083	75 2c		 jne	 SHORT $LN12@txf_abort_
  00085	48 63 44 24 40	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00091	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0009a	74 15		 je	 SHORT $LN12@txf_abort_
  0009c	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000a1	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000a8	0f b7 4c 24 60	 movzx	 ecx, WORD PTR cpuad$[rsp]
  000ad	3b c1		 cmp	 eax, ecx
  000af	75 02		 jne	 SHORT $LN11@txf_abort_
$LN12@txf_abort_:

; 1911 :         )
; 1912 :             continue;

  000b1	eb 92		 jmp	 SHORT $LN2@txf_abort_
$LN11@txf_abort_:

; 1913 : 
; 1914 :         /* If this CPU is executing a transaction, then force it
; 1915 :            to eventually fail by setting a transation abort code.
; 1916 :         */
; 1917 :         OBTAIN_TXFLOCK( regs );

  000b3	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000b8	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c6	48 8d 84 c1 48
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+840]
  000ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193933
  000d5	48 8b c8	 mov	 rcx, rax
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1918 :         {
; 1919 :             if (1
; 1920 :                 &&  regs->txf_tnd
; 1921 :                 && !regs->txf_tac

  000de	33 c0		 xor	 eax, eax
  000e0	83 f8 01	 cmp	 eax, 1
  000e3	0f 84 e9 00 00
	00		 je	 $LN13@txf_abort_
  000e9	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000ee	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000f5	85 c0		 test	 eax, eax
  000f7	0f 84 d5 00 00
	00		 je	 $LN13@txf_abort_
  000fd	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00102	83 b8 08 af 00
	00 00		 cmp	 DWORD PTR [rax+44808], 0
  00109	0f 85 c3 00 00
	00		 jne	 $LN13@txf_abort_

; 1922 :             )
; 1923 :             {
; 1924 :                 regs->txf_tac   =  TAC_MISC;

  0010f	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00114	c7 80 08 af 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+44808], 255 ; 000000ffH

; 1925 :                 regs->txf_why  |=  why;

  0011e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00123	8b 4c 24 68	 mov	 ecx, DWORD PTR why$[rsp]
  00127	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0012d	0b c1		 or	 eax, ecx
  0012f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 1926 :                 regs->txf_who   =  cpuad;

  0013a	0f b7 44 24 60	 movzx	 eax, WORD PTR cpuad$[rsp]
  0013f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	89 81 10 af 00
	00		 mov	 DWORD PTR [rcx+44816], eax

; 1927 :                 regs->txf_loc   =  TRIMLOC( location );

  0014a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR location$[rsp]
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trimloc
  00155	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0015a	48 89 81 18 af
	00 00		 mov	 QWORD PTR [rcx+44824], rax
$LN7@txf_abort_:

; 1928 : 
; 1929 :                 PTT_TXF( "*TXF h delay", regs->cpuad, regs->txf_contran, regs->txf_tnd );

  00161	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00168	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0016b	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00171	48 85 c0	 test	 rax, rax
  00174	74 56		 je	 SHORT $LN14@txf_abort_
  00176	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0017b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00182	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  0018e	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  00193	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  0019a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001a3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193936
  001af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b4	44 8b c9	 mov	 r9d, ecx
  001b7	44 8b c2	 mov	 r8d, edx
  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193937
  001c1	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  001c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN14@txf_abort_:
  001cc	33 c0		 xor	 eax, eax
  001ce	85 c0		 test	 eax, eax
  001d0	75 8f		 jne	 SHORT $LN7@txf_abort_
$LN13@txf_abort_:

; 1930 :             }
; 1931 : 
; 1932 :             /* (check guestregs too just to be sure) */
; 1933 : 
; 1934 :             if (1
; 1935 :                 &&  GUESTREGS
; 1936 :                 &&  GUESTREGS->txf_tnd
; 1937 :                 && !GUESTREGS->txf_tac

  001d2	33 c0		 xor	 eax, eax
  001d4	83 f8 01	 cmp	 eax, 1
  001d7	0f 84 46 01 00
	00		 je	 $LN15@txf_abort_
  001dd	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  001e2	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  001ea	0f 84 33 01 00
	00		 je	 $LN15@txf_abort_
  001f0	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  001f5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  001fc	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00203	85 c0		 test	 eax, eax
  00205	0f 84 18 01 00
	00		 je	 $LN15@txf_abort_
  0020b	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00210	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00217	83 b8 08 af 00
	00 00		 cmp	 DWORD PTR [rax+44808], 0
  0021e	0f 85 ff 00 00
	00		 jne	 $LN15@txf_abort_

; 1938 :             )
; 1939 :             {
; 1940 :                 GUESTREGS->txf_tac   =  TAC_MISC;

  00224	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00229	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00230	c7 80 08 af 00
	00 ff 00 00 00	 mov	 DWORD PTR [rax+44808], 255 ; 000000ffH

; 1941 :                 GUESTREGS->txf_why  |=  why;

  0023a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0023f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00246	8b 4c 24 68	 mov	 ecx, DWORD PTR why$[rsp]
  0024a	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00250	0b c1		 or	 eax, ecx
  00252	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00257	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0025e	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 1942 :                 GUESTREGS->txf_who   =  cpuad;

  00264	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00269	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00270	0f b7 4c 24 60	 movzx	 ecx, WORD PTR cpuad$[rsp]
  00275	89 88 10 af 00
	00		 mov	 DWORD PTR [rax+44816], ecx

; 1943 :                 GUESTREGS->txf_loc   =  TRIMLOC( location );

  0027b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR location$[rsp]
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trimloc
  00286	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0028b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00292	48 89 81 18 af
	00 00		 mov	 QWORD PTR [rcx+44824], rax
$LN10@txf_abort_:

; 1944 : 
; 1945 :                 PTT_TXF( "*TXF g delay", GUESTREGS->cpuad, GUESTREGS->txf_contran, GUESTREGS->txf_tnd );

  00299	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002a0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002a3	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  002a9	48 85 c0	 test	 rax, rax
  002ac	74 6b		 je	 SHORT $LN16@txf_abort_
  002ae	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  002b3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  002ba	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  002c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  002c6	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  002cd	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  002d4	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  002d9	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  002e0	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  002e7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002f0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193940
  002fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00301	44 8b c9	 mov	 r9d, ecx
  00304	44 8b c2	 mov	 r8d, edx
  00307	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193941
  0030e	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00313	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@txf_abort_:
  00319	33 c0		 xor	 eax, eax
  0031b	85 c0		 test	 eax, eax
  0031d	0f 85 76 ff ff
	ff		 jne	 $LN10@txf_abort_
$LN15@txf_abort_:

; 1946 :             }
; 1947 :         }
; 1948 :         RELEASE_TXFLOCK( regs );

  00323	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00328	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0032f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00336	48 8d 84 c1 48
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+840]
  0033e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193942
  00345	48 8b c8	 mov	 rcx, rax
  00348	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1949 :     }

  0034e	e9 f2 fc ff ff	 jmp	 $LN2@txf_abort_
$LN3@txf_abort_:

; 1950 : }

  00353	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00357	c3		 ret	 0
txf_abort_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
i$ = 64
pmap$ = 72
p$1 = 80
regs$ = 112
free_txfmap PROC

; 1871 : {

$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1872 : int        i;
; 1873 : TPAGEMAP*  pmap = regs->txf_pagesmap;

  0000a	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0000f	48 05 80 0e 00
	00		 add	 rax, 3712		; 00000e80H
  00015	48 89 44 24 48	 mov	 QWORD PTR pmap$[rsp], rax
$LN4@free_txfma:

; 1874 : 
; 1875 :     PTT_TXF( "TXF free", 0, 0, 0 );

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00021	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00024	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  0002a	48 85 c0	 test	 rax, rax
  0002d	74 36		 je	 SHORT $LN11@free_txfma
  0002f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00038	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00041	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193897
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	45 33 c9	 xor	 r9d, r9d
  00050	45 33 c0	 xor	 r8d, r8d
  00053	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193898
  0005a	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN11@free_txfma:
  00065	33 c0		 xor	 eax, eax
  00067	85 c0		 test	 eax, eax
  00069	75 af		 jne	 SHORT $LN4@free_txfma

; 1876 : 
; 1877 :     /* LOGIC ERROR if CPU still executing a transaction */
; 1878 :     if (!sysblk.shutdown && regs->txf_tnd)

  0006b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00072	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00078	c1 e8 0b	 shr	 eax, 11
  0007b	83 e0 01	 and	 eax, 1
  0007e	85 c0		 test	 eax, eax
  00080	75 27		 jne	 SHORT $LN12@free_txfma
  00082	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00087	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0008e	85 c0		 test	 eax, eax
  00090	74 17		 je	 SHORT $LN12@free_txfma
$LN7@free_txfma:

; 1879 :         CRASH();

  00092	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  0009b	48 8b 44 24 50	 mov	 rax, QWORD PTR p$1[rsp]
  000a0	c6 00 00	 mov	 BYTE PTR [rax], 0
  000a3	33 c0		 xor	 eax, eax
  000a5	85 c0		 test	 eax, eax
  000a7	75 e9		 jne	 SHORT $LN7@free_txfma
$LN12@free_txfma:

; 1880 : 
; 1881 :     /* Free TXF pages */
; 1882 :     free_aligned( pmap->altpageaddr );

  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  000ae	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 1883 : 
; 1884 :     /* Clear/reset/re-initialize all pages map entries */
; 1885 :     for (i=0; i < MAX_TXF_PAGES; i++, pmap++)

  000b8	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000c0	eb 18		 jmp	 SHORT $LN10@free_txfma
$LN8@free_txfma:
  000c2	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  000c6	ff c0		 inc	 eax
  000c8	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  000cc	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  000d1	48 83 c0 28	 add	 rax, 40			; 00000028H
  000d5	48 89 44 24 48	 mov	 QWORD PTR pmap$[rsp], rax
$LN10@free_txfma:
  000da	81 7c 24 40 00
	04 00 00	 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  000e2	7d 3d		 jge	 SHORT $LN9@free_txfma

; 1886 :     {
; 1887 :         pmap->virtpageaddr = 0;

  000e4	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  000e9	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1888 :         pmap->mainpageaddr = NULL;

  000f0	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  000f5	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1889 :         pmap->altpageaddr  = NULL;

  000fd	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  00102	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 1890 :         memset( pmap->cachemap, CM_CLEAN, sizeof( pmap->cachemap ));

  0010a	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  0010f	48 83 c0 18	 add	 rax, 24
  00113	48 8b f8	 mov	 rdi, rax
  00116	33 c0		 xor	 eax, eax
  00118	b9 10 00 00 00	 mov	 ecx, 16
  0011d	f3 aa		 rep stosb

; 1891 :     }

  0011f	eb a1		 jmp	 SHORT $LN8@free_txfma
$LN9@free_txfma:

; 1892 : }

  00121	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00125	5f		 pop	 rdi
  00126	c3		 ret	 0
free_txfmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
i$ = 64
pmap$ = 72
altpage$ = 80
p$1 = 88
msize$ = 96
regs$ = 128
alloc_txfmap PROC

; 1835 : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 1836 : int        i;
; 1837 : size_t     msize;
; 1838 : BYTE*      altpage;
; 1839 : TPAGEMAP*  pmap = regs->txf_pagesmap;

  0000a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00012	48 05 80 0e 00
	00		 add	 rax, 3712		; 00000e80H
  00018	48 89 44 24 48	 mov	 QWORD PTR pmap$[rsp], rax
$LN4@alloc_txfm:

; 1840 : 
; 1841 :     PTT_TXF( "TXF alloc", 0, 0, 0 );

  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00024	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00027	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  0002d	48 85 c0	 test	 rax, rax
  00030	74 36		 je	 SHORT $LN11@alloc_txfm
  00032	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0003b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00044	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193868
  0004b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00050	45 33 c9	 xor	 r9d, r9d
  00053	45 33 c0	 xor	 r8d, r8d
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193869
  0005d	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN11@alloc_txfm:
  00068	33 c0		 xor	 eax, eax
  0006a	85 c0		 test	 eax, eax
  0006c	75 af		 jne	 SHORT $LN4@alloc_txfm

; 1842 : 
; 1843 :     /* LOGIC ERROR if map still exists (memory leak; old map not freed)
; 1844 :        or if a transaction is still being executed on this CPU */
; 1845 :     if (pmap->altpageaddr || regs->txf_tnd)

  0006e	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  00073	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00078	75 13		 jne	 SHORT $LN13@alloc_txfm
  0007a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00089	85 c0		 test	 eax, eax
  0008b	74 17		 je	 SHORT $LN12@alloc_txfm
$LN13@alloc_txfm:
$LN7@alloc_txfm:

; 1846 :         CRASH();

  0008d	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00096	48 8b 44 24 58	 mov	 rax, QWORD PTR p$1[rsp]
  0009b	c6 00 00	 mov	 BYTE PTR [rax], 0
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 e9		 jne	 SHORT $LN7@alloc_txfm
$LN12@alloc_txfm:

; 1847 : 
; 1848 :     msize = ZPAGEFRAME_PAGESIZE * MAX_TXF_PAGES * 2;

  000a4	48 c7 44 24 60
	00 00 80 00	 mov	 QWORD PTR msize$[rsp], 8388608 ; 00800000H

; 1849 :     altpage = (BYTE*) malloc_aligned( msize, ZPAGEFRAME_PAGESIZE );

  000ad	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  000b2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR msize$[rsp]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  000bd	48 89 44 24 50	 mov	 QWORD PTR altpage$[rsp], rax

; 1850 : 
; 1851 :     /* Initialize all page map entries */
; 1852 :     for (i=0; i < MAX_TXF_PAGES; i++, pmap++, altpage += (ZPAGEFRAME_PAGESIZE * 2))

  000c2	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ca	eb 28		 jmp	 SHORT $LN10@alloc_txfm
$LN8@alloc_txfm:
  000cc	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  000d0	ff c0		 inc	 eax
  000d2	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  000d6	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  000db	48 83 c0 28	 add	 rax, 40			; 00000028H
  000df	48 89 44 24 48	 mov	 QWORD PTR pmap$[rsp], rax
  000e4	48 8b 44 24 50	 mov	 rax, QWORD PTR altpage$[rsp]
  000e9	48 05 00 20 00
	00		 add	 rax, 8192		; 00002000H
  000ef	48 89 44 24 50	 mov	 QWORD PTR altpage$[rsp], rax
$LN10@alloc_txfm:
  000f4	81 7c 24 40 00
	04 00 00	 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  000fc	7d 3e		 jge	 SHORT $LN9@alloc_txfm

; 1853 :     {
; 1854 :         pmap->virtpageaddr = 0;

  000fe	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  00103	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1855 :         pmap->mainpageaddr = NULL;

  0010a	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  0010f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 1856 :         pmap->altpageaddr  = altpage;

  00117	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  0011c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR altpage$[rsp]
  00121	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 1857 :         memset( pmap->cachemap, CM_CLEAN, sizeof( pmap->cachemap ));

  00125	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  0012a	48 83 c0 18	 add	 rax, 24
  0012e	48 8b f8	 mov	 rdi, rax
  00131	33 c0		 xor	 eax, eax
  00133	b9 10 00 00 00	 mov	 ecx, 16
  00138	f3 aa		 rep stosb

; 1858 :     }

  0013a	eb 90		 jmp	 SHORT $LN8@alloc_txfm
$LN9@alloc_txfm:

; 1859 : 
; 1860 :     regs->txf_tnd      = 0;

  0013c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00144	c6 80 58 0e 00
	00 00		 mov	 BYTE PTR [rax+3672], 0

; 1861 :     regs->txf_abortctr = 0;

  0014b	33 c0		 xor	 eax, eax
  0014d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00155	66 89 81 60 0e
	00 00		 mov	 WORD PTR [rcx+3680], ax

; 1862 :     regs->txf_contran  = false;

  0015c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00164	c6 80 4c 0e 00
	00 00		 mov	 BYTE PTR [rax+3660], 0

; 1863 :     regs->txf_instctr  = 0;

  0016b	33 c0		 xor	 eax, eax
  0016d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00175	66 89 81 5e 0e
	00 00		 mov	 WORD PTR [rcx+3678], ax

; 1864 :     regs->txf_pgcnt    = 0;

  0017c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00184	c7 80 80 ae 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+44672], 0

; 1865 : }

  0018e	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00192	5f		 pop	 rdi
  00193	c3		 ret	 0
alloc_txfmap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
filt$ = 64
txclass$ = 68
ucc$ = 72
fcc$ = 76
tv84 = 80
tv88 = 84
tv140 = 88
tv142 = 92
tv144 = 96
tv147 = 100
tv149 = 104
p$1 = 112
regs$ = 144
pcode$ = 152
z900_txf_do_pi_filtering PROC

; 1616 : {

$LN85:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
$LN4@z900_txf_d:

; 1617 : bool    filt;                   /* true == filter the interrupt      */
; 1618 : int     txclass;                /* Transactional Execution Class     */
; 1619 : int     fcc, ucc;               /* Filtered/Unfiltered conditon code */
; 1620 : 
; 1621 :     PTT_TXF( "TXF filt?", pcode, regs->txf_contran, regs->txf_tnd );

  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00017	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001a	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00020	48 85 c0	 test	 rax, rax
  00023	74 58		 je	 SHORT $LN20@z900_txf_d
  00025	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00034	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003c	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00043	48 63 94 24 98
	00 00 00	 movsxd	 rdx, DWORD PTR pcode$[rsp]
  0004b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00054	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00059	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193780
  00060	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00065	44 8b c9	 mov	 r9d, ecx
  00068	4c 8b c2	 mov	 r8, rdx
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193781
  00072	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN20@z900_txf_d:
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 8d		 jne	 SHORT $LN4@z900_txf_d

; 1622 : 
; 1623 :     /* We shouldn't even be called if no transaction is active */
; 1624 :     if (!regs->txf_tnd)

  00083	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00092	85 c0		 test	 eax, eax
  00094	75 17		 jne	 SHORT $LN21@z900_txf_d
$LN7@z900_txf_d:

; 1625 :         CRASH();

  00096	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  0009f	48 8b 44 24 70	 mov	 rax, QWORD PTR p$1[rsp]
  000a4	c6 00 00	 mov	 BYTE PTR [rax], 0
  000a7	33 c0		 xor	 eax, eax
  000a9	85 c0		 test	 eax, eax
  000ab	75 e9		 jne	 SHORT $LN7@z900_txf_d
$LN21@z900_txf_d:

; 1626 : 
; 1627 :     switch (pcode & 0xFF)  // (interrupt code)

  000ad	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  000b4	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b9	89 44 24 50	 mov	 DWORD PTR tv84[rsp], eax
  000bd	8b 44 24 50	 mov	 eax, DWORD PTR tv84[rsp]
  000c1	ff c8		 dec	 eax
  000c3	89 44 24 50	 mov	 DWORD PTR tv84[rsp], eax
  000c7	83 7c 24 50 3a	 cmp	 DWORD PTR tv84[rsp], 58	; 0000003aH
  000cc	0f 87 5c 01 00
	00		 ja	 $LN61@z900_txf_d
  000d2	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv84[rsp]
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000de	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN83@z900_txf_d[rcx+rax]
  000e6	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN84@z900_txf_d[rcx+rax*4]
  000ed	48 03 c1	 add	 rax, rcx
  000f0	ff e0		 jmp	 rax
$LN22@z900_txf_d:
$LN23@z900_txf_d:
$LN24@z900_txf_d:

; 1628 :     {
; 1629 :     case PGM_OPERATION_EXCEPTION:
; 1630 :     case PGM_PRIVILEGED_OPERATION_EXCEPTION:
; 1631 :     case PGM_EXECUTE_EXCEPTION:
; 1632 : 
; 1633 :         txclass = 1;        /* Class 1 can't be filtered */

  000f2	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR txclass$[rsp], 1

; 1634 :         filt = false;

  000fa	c6 44 24 40 00	 mov	 BYTE PTR filt$[rsp], 0

; 1635 :         ucc = TXF_CC_PERSISTENT;

  000ff	c7 44 24 48 03
	00 00 00	 mov	 DWORD PTR ucc$[rsp], 3

; 1636 :         break;

  00107	e9 37 01 00 00	 jmp	 $LN8@z900_txf_d
$LN25@z900_txf_d:

; 1637 : 
; 1638 :     case PGM_SPECIFICATION_EXCEPTION:
; 1639 : 
; 1640 :         txclass = 3;

  0010c	c7 44 24 44 03
	00 00 00	 mov	 DWORD PTR txclass$[rsp], 3

; 1641 :         filt = true;

  00114	c6 44 24 40 01	 mov	 BYTE PTR filt$[rsp], 1

; 1642 :         ucc = TXF_CC_TRANSIENT, fcc = TXF_CC_PERSISTENT;

  00119	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR ucc$[rsp], 2
  00121	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR fcc$[rsp], 3

; 1643 :         break;

  00129	e9 15 01 00 00	 jmp	 $LN8@z900_txf_d
$LN26@z900_txf_d:
$LN27@z900_txf_d:
$LN28@z900_txf_d:
$LN29@z900_txf_d:
$LN30@z900_txf_d:
$LN31@z900_txf_d:
$LN32@z900_txf_d:
$LN33@z900_txf_d:

; 1644 : 
; 1645 :     case PGM_PROTECTION_EXCEPTION:
; 1646 :     case PGM_ADDRESSING_EXCEPTION:
; 1647 :     case PGM_SEGMENT_TRANSLATION_EXCEPTION:
; 1648 :     case PGM_PAGE_TRANSLATION_EXCEPTION:
; 1649 :     case PGM_ASCE_TYPE_EXCEPTION:
; 1650 :     case PGM_REGION_FIRST_TRANSLATION_EXCEPTION:
; 1651 :     case PGM_REGION_SECOND_TRANSLATION_EXCEPTION:
; 1652 :     case PGM_REGION_THIRD_TRANSLATION_EXCEPTION:
; 1653 : 
; 1654 :         /* Did interrupt occur during instruction fetch? */
; 1655 :         if (regs->txf_lastarn == USE_INST_SPACE)

  0012e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00136	83 b8 88 af 00
	00 ff		 cmp	 DWORD PTR [rax+44936], -1
  0013d	75 0f		 jne	 SHORT $LN34@z900_txf_d

; 1656 :         {
; 1657 :             txclass = 1;        /* Class 1 can't be filtered */

  0013f	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR txclass$[rsp], 1

; 1658 :             filt = false;

  00147	c6 44 24 40 00	 mov	 BYTE PTR filt$[rsp], 0

; 1659 :         }

  0014c	eb 0d		 jmp	 SHORT $LN35@z900_txf_d
$LN34@z900_txf_d:

; 1660 :         else
; 1661 :         {
; 1662 :             txclass = 2;

  0014e	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR txclass$[rsp], 2

; 1663 :             filt = true;

  00156	c6 44 24 40 01	 mov	 BYTE PTR filt$[rsp], 1
$LN35@z900_txf_d:

; 1664 :         }
; 1665 :         ucc = TXF_CC_TRANSIENT, fcc = TXF_CC_PERSISTENT;

  0015b	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR ucc$[rsp], 2
  00163	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR fcc$[rsp], 3

; 1666 :         break;

  0016b	e9 d3 00 00 00	 jmp	 $LN8@z900_txf_d
$LN36@z900_txf_d:

; 1667 : 
; 1668 :     case PGM_DATA_EXCEPTION:
; 1669 : 
; 1670 :         /* Check Data Exception Code (DXC) */
; 1671 :         switch (regs->dxc)

  00170	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00178	8b 80 08 07 00
	00		 mov	 eax, DWORD PTR [rax+1800]
  0017e	89 44 24 54	 mov	 DWORD PTR tv88[rsp], eax
  00182	83 7c 24 54 01	 cmp	 DWORD PTR tv88[rsp], 1
  00187	74 1a		 je	 SHORT $LN37@z900_txf_d
  00189	83 7c 24 54 02	 cmp	 DWORD PTR tv88[rsp], 2
  0018e	74 13		 je	 SHORT $LN38@z900_txf_d
  00190	83 7c 24 54 03	 cmp	 DWORD PTR tv88[rsp], 3
  00195	74 0c		 je	 SHORT $LN39@z900_txf_d
  00197	81 7c 24 54 fe
	00 00 00	 cmp	 DWORD PTR tv88[rsp], 254 ; 000000feH
  0019f	74 02		 je	 SHORT $LN40@z900_txf_d
  001a1	eb 17		 jmp	 SHORT $LN41@z900_txf_d
$LN37@z900_txf_d:
$LN38@z900_txf_d:
$LN39@z900_txf_d:
$LN40@z900_txf_d:

; 1672 :         {
; 1673 :         case DXC_AFP_REGISTER:
; 1674 :         case DXC_BFP_INSTRUCTION:
; 1675 :         case DXC_DFP_INSTRUCTION:
; 1676 :         case DXC_VECTOR_INSTRUCTION:
; 1677 : 
; 1678 :             txclass = 1;        /* Class 1 can't be filtered */

  001a3	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR txclass$[rsp], 1

; 1679 :             filt = false;

  001ab	c6 44 24 40 00	 mov	 BYTE PTR filt$[rsp], 0

; 1680 :             ucc = TXF_CC_TRANSIENT;

  001b0	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR ucc$[rsp], 2

; 1681 :             break;

  001b8	eb 1d		 jmp	 SHORT $LN10@z900_txf_d
$LN41@z900_txf_d:

; 1682 : 
; 1683 :         default:
; 1684 : 
; 1685 :             txclass = 3;

  001ba	c7 44 24 44 03
	00 00 00	 mov	 DWORD PTR txclass$[rsp], 3

; 1686 :             filt = true;

  001c2	c6 44 24 40 01	 mov	 BYTE PTR filt$[rsp], 1

; 1687 :             ucc = TXF_CC_TRANSIENT, fcc = TXF_CC_PERSISTENT;

  001c7	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR ucc$[rsp], 2
  001cf	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR fcc$[rsp], 3
$LN10@z900_txf_d:

; 1688 :             break;
; 1689 : 
; 1690 :         } /* end switch (regs->dxc) */
; 1691 :         break;

  001d7	eb 6a		 jmp	 SHORT $LN8@z900_txf_d
$LN42@z900_txf_d:
$LN43@z900_txf_d:
$LN44@z900_txf_d:
$LN45@z900_txf_d:
$LN46@z900_txf_d:
$LN47@z900_txf_d:
$LN48@z900_txf_d:
$LN49@z900_txf_d:
$LN50@z900_txf_d:
$LN51@z900_txf_d:

; 1692 : 
; 1693 :     case PGM_FIXED_POINT_OVERFLOW_EXCEPTION:
; 1694 :     case PGM_FIXED_POINT_DIVIDE_EXCEPTION:
; 1695 :     case PGM_DECIMAL_OVERFLOW_EXCEPTION:
; 1696 :     case PGM_DECIMAL_DIVIDE_EXCEPTION:
; 1697 :     case PGM_EXPONENT_OVERFLOW_EXCEPTION:
; 1698 :     case PGM_EXPONENT_UNDERFLOW_EXCEPTION:
; 1699 :     case PGM_SIGNIFICANCE_EXCEPTION:
; 1700 :     case PGM_FLOATING_POINT_DIVIDE_EXCEPTION:
; 1701 :     case PGM_VECTOR_PROCESSING_EXCEPTION:
; 1702 :     case PGM_SQUARE_ROOT_EXCEPTION:
; 1703 : 
; 1704 :         txclass = 3;

  001d9	c7 44 24 44 03
	00 00 00	 mov	 DWORD PTR txclass$[rsp], 3

; 1705 :         filt = true;

  001e1	c6 44 24 40 01	 mov	 BYTE PTR filt$[rsp], 1

; 1706 :         ucc = TXF_CC_TRANSIENT, fcc = TXF_CC_PERSISTENT;

  001e6	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR ucc$[rsp], 2
  001ee	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR fcc$[rsp], 3

; 1707 :         break;

  001f6	eb 4b		 jmp	 SHORT $LN8@z900_txf_d
$LN52@z900_txf_d:
$LN53@z900_txf_d:
$LN54@z900_txf_d:

; 1708 : 
; 1709 :     case PGM_TRANSLATION_SPECIFICATION_EXCEPTION:
; 1710 :     case PGM_SPECIAL_OPERATION_EXCEPTION:
; 1711 :     case PGM_TRANSACTION_CONSTRAINT_EXCEPTION:
; 1712 : 
; 1713 :         txclass = 1;        /* Class 1 can't be filtered */

  001f8	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR txclass$[rsp], 1

; 1714 :         filt = false;

  00200	c6 44 24 40 00	 mov	 BYTE PTR filt$[rsp], 0

; 1715 :         ucc = TXF_CC_PERSISTENT;

  00205	c7 44 24 48 03
	00 00 00	 mov	 DWORD PTR ucc$[rsp], 3

; 1716 :         break;

  0020d	eb 34		 jmp	 SHORT $LN8@z900_txf_d
$LN55@z900_txf_d:
$LN56@z900_txf_d:
$LN57@z900_txf_d:
$LN58@z900_txf_d:
$LN59@z900_txf_d:
$LN60@z900_txf_d:

; 1717 : 
; 1718 :     case PGM_ALET_SPECIFICATION_EXCEPTION:
; 1719 :     case PGM_ALEN_TRANSLATION_EXCEPTION:
; 1720 :     case PGM_ALE_SEQUENCE_EXCEPTION:
; 1721 :     case PGM_ASTE_VALIDITY_EXCEPTION:
; 1722 :     case PGM_ASTE_SEQUENCE_EXCEPTION:
; 1723 :     case PGM_EXTENDED_AUTHORITY_EXCEPTION:
; 1724 : 
; 1725 :         txclass = 2;

  0020f	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR txclass$[rsp], 2

; 1726 :         filt = true;

  00217	c6 44 24 40 01	 mov	 BYTE PTR filt$[rsp], 1

; 1727 :         ucc = TXF_CC_TRANSIENT, fcc = TXF_CC_PERSISTENT;

  0021c	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR ucc$[rsp], 2
  00224	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR fcc$[rsp], 3

; 1728 :         break;

  0022c	eb 15		 jmp	 SHORT $LN8@z900_txf_d
$LN61@z900_txf_d:

; 1729 : 
; 1730 :     default:
; 1731 : 
; 1732 :         txclass = 0;        /* Class 0 can't be filtered */

  0022e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR txclass$[rsp], 0

; 1733 :         filt = false;

  00236	c6 44 24 40 00	 mov	 BYTE PTR filt$[rsp], 0

; 1734 :         ucc = TXF_CC_SUCCESS;

  0023b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR ucc$[rsp], 0
$LN8@z900_txf_d:

; 1735 :         break;
; 1736 : 
; 1737 :     } /* end switch (pcode & 0xFF) */
; 1738 : 
; 1739 :     /* CONSTRAINED transactions cannot be filtered */
; 1740 :     if (regs->txf_contran)

  00243	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024b	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00252	85 c0		 test	 eax, eax
  00254	74 05		 je	 SHORT $LN62@z900_txf_d

; 1741 :         filt = false;

  00256	c6 44 24 40 00	 mov	 BYTE PTR filt$[rsp], 0
$LN62@z900_txf_d:

; 1742 : 
; 1743 :     /*---------------------------------------*/
; 1744 :     /*  Can interrupt POSSIBLY be filtered?  */
; 1745 :     /*---------------------------------------*/
; 1746 : 
; 1747 :     if (filt)

  0025b	0f b6 44 24 40	 movzx	 eax, BYTE PTR filt$[rsp]
  00260	85 c0		 test	 eax, eax
  00262	0f 84 e5 00 00
	00		 je	 $LN63@z900_txf_d

; 1748 :     {
; 1749 :         /* Is Program-Interruption-Filtering Overide enabled? */
; 1750 :         if (regs->CR(0) & CR0_PIFO)

  00268	b8 08 00 00 00	 mov	 eax, 8
  0026d	48 6b c0 01	 imul	 rax, rax, 1
  00271	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00279	48 ba 00 00 00
	00 00 00 40 00	 mov	 rdx, 18014398509481984	; 0040000000000000H
  00283	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0028b	48 23 c2	 and	 rax, rdx
  0028e	48 85 c0	 test	 rax, rax
  00291	74 0a		 je	 SHORT $LN64@z900_txf_d

; 1751 :             filt = false; /* Then interrupt cannot be filtered */

  00293	c6 44 24 40 00	 mov	 BYTE PTR filt$[rsp], 0
  00298	e9 b0 00 00 00	 jmp	 $LN65@z900_txf_d
$LN64@z900_txf_d:

; 1752 :         else
; 1753 :         {
; 1754 :             /* Check PIFC (see Fig. 5-15 on page 5-104) */
; 1755 :             switch (regs->txf_pifc)

  0029d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a5	0f b7 80 62 0e
	00 00		 movzx	 eax, WORD PTR [rax+3682]
  002ac	89 44 24 58	 mov	 DWORD PTR tv140[rsp], eax
  002b0	83 7c 24 58 00	 cmp	 DWORD PTR tv140[rsp], 0
  002b5	74 17		 je	 SHORT $LN66@z900_txf_d
  002b7	83 7c 24 58 01	 cmp	 DWORD PTR tv140[rsp], 1
  002bc	74 17		 je	 SHORT $LN67@z900_txf_d
  002be	83 7c 24 58 02	 cmp	 DWORD PTR tv140[rsp], 2
  002c3	74 4d		 je	 SHORT $LN68@z900_txf_d
  002c5	83 7c 24 58 03	 cmp	 DWORD PTR tv140[rsp], 3
  002ca	74 46		 je	 SHORT $LN69@z900_txf_d
  002cc	eb 44		 jmp	 SHORT $LN70@z900_txf_d
$LN66@z900_txf_d:

; 1756 :             {
; 1757 :             case TXF_PIFC_NONE:
; 1758 : 
; 1759 :                 filt = false;

  002ce	c6 44 24 40 00	 mov	 BYTE PTR filt$[rsp], 0

; 1760 :                 break;

  002d3	eb 78		 jmp	 SHORT $LN12@z900_txf_d
$LN67@z900_txf_d:

; 1761 : 
; 1762 :             case TXF_PIFC_LIMITED:
; 1763 : 
; 1764 :                 filt = (txclass >= 3) ? true : false;

  002d5	83 7c 24 44 03	 cmp	 DWORD PTR txclass$[rsp], 3
  002da	7c 0a		 jl	 SHORT $LN75@z900_txf_d
  002dc	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  002e4	eb 08		 jmp	 SHORT $LN76@z900_txf_d
$LN75@z900_txf_d:
  002e6	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN76@z900_txf_d:
  002ee	83 7c 24 5c 00	 cmp	 DWORD PTR tv142[rsp], 0
  002f3	75 0a		 jne	 SHORT $LN77@z900_txf_d
  002f5	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv144[rsp], 0
  002fd	eb 08		 jmp	 SHORT $LN78@z900_txf_d
$LN77@z900_txf_d:
  002ff	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv144[rsp], 1
$LN78@z900_txf_d:
  00307	0f b6 44 24 60	 movzx	 eax, BYTE PTR tv144[rsp]
  0030c	88 44 24 40	 mov	 BYTE PTR filt$[rsp], al

; 1765 :                 break;

  00310	eb 3b		 jmp	 SHORT $LN12@z900_txf_d
$LN68@z900_txf_d:
$LN69@z900_txf_d:
$LN70@z900_txf_d:

; 1766 : 
; 1767 :             case TXF_PIFC_MODERATE:
; 1768 :             case TXF_PIFC_RESERVED:
; 1769 :             default:
; 1770 : 
; 1771 :                 filt = (txclass >= 2) ? true : false;

  00312	83 7c 24 44 02	 cmp	 DWORD PTR txclass$[rsp], 2
  00317	7c 0a		 jl	 SHORT $LN79@z900_txf_d
  00319	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv147[rsp], 1
  00321	eb 08		 jmp	 SHORT $LN80@z900_txf_d
$LN79@z900_txf_d:
  00323	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN80@z900_txf_d:
  0032b	83 7c 24 64 00	 cmp	 DWORD PTR tv147[rsp], 0
  00330	75 0a		 jne	 SHORT $LN81@z900_txf_d
  00332	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
  0033a	eb 08		 jmp	 SHORT $LN82@z900_txf_d
$LN81@z900_txf_d:
  0033c	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv149[rsp], 1
$LN82@z900_txf_d:
  00344	0f b6 44 24 68	 movzx	 eax, BYTE PTR tv149[rsp]
  00349	88 44 24 40	 mov	 BYTE PTR filt$[rsp], al
$LN12@z900_txf_d:
$LN65@z900_txf_d:
$LN63@z900_txf_d:

; 1772 :                 break;
; 1773 :             }
; 1774 :         }
; 1775 :     }
; 1776 : 
; 1777 :     /*-------------------------------------------*/
; 1778 :     /*   Can interrupt ABSOLUTELY be filtered?   */
; 1779 :     /*-------------------------------------------*/
; 1780 : 
; 1781 :     if (filt)  /* NOW we can rely this flag */

  0034d	0f b6 44 24 40	 movzx	 eax, BYTE PTR filt$[rsp]
  00352	85 c0		 test	 eax, eax
  00354	0f 84 c2 00 00
	00		 je	 $LN71@z900_txf_d

; 1782 :     {
; 1783 :         /*--------------------------------------*/
; 1784 :         /* TAC_FPGM: filtered Program Interrupt */
; 1785 :         /*--------------------------------------*/
; 1786 : 
; 1787 :         regs->psw.cc = fcc;

  0035a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00362	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR fcc$[rsp]
  00367	88 48 7c	 mov	 BYTE PTR [rax+124], cl
$LN16@z900_txf_d:

; 1788 :         PTT_TXF( "TXF filt!", pcode, regs->txf_contran, regs->txf_tnd );

  0036a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00371	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00374	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  0037a	48 85 c0	 test	 rax, rax
  0037d	74 58		 je	 SHORT $LN72@z900_txf_d
  0037f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00387	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0038e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00396	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  0039d	48 63 94 24 98
	00 00 00	 movsxd	 rdx, DWORD PTR pcode$[rsp]
  003a5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003ae	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193834
  003ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003bf	44 8b c9	 mov	 r9d, ecx
  003c2	4c 8b c2	 mov	 r8, rdx
  003c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193835
  003cc	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  003d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN72@z900_txf_d:
  003d7	33 c0		 xor	 eax, eax
  003d9	85 c0		 test	 eax, eax
  003db	75 8d		 jne	 SHORT $LN16@z900_txf_d

; 1789 :         regs->txf_why |= TXF_WHY_FILT_INT;

  003dd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e5	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  003eb	0f ba e8 15	 bts	 eax, 21
  003ef	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f7	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 1790 :         ABORT_TRANS( regs, ABORT_RETRY_CC, TAC_FPGM );

  003fd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193836
  00404	41 b8 0c 00 00
	00		 mov	 r8d, 12
  0040a	ba 01 00 00 00	 mov	 edx, 1
  0040f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00417	e8 00 00 00 00	 call	 z900_abort_transaction
$LN71@z900_txf_d:

; 1791 :         UNREACHABLE_CODE( return );
; 1792 :     }
; 1793 : 
; 1794 :     /*---------------------------------------------*/
; 1795 :     /*  TAC_UPGM: unfilterable Program Interrupt   */
; 1796 :     /*---------------------------------------------*/
; 1797 : 
; 1798 :     /* Abort the transaction and return to the caller */
; 1799 :     regs->psw.cc = ucc;

  0041c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00424	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR ucc$[rsp]
  00429	88 48 7c	 mov	 BYTE PTR [rax+124], cl
$LN19@z900_txf_d:

; 1800 :     PTT_TXF( "TXF unfilt!", pcode, regs->txf_contran, regs->txf_tnd );

  0042c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00433	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00436	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  0043c	48 85 c0	 test	 rax, rax
  0043f	74 58		 je	 SHORT $LN73@z900_txf_d
  00441	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00449	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00450	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00458	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  0045f	48 63 94 24 98
	00 00 00	 movsxd	 rdx, DWORD PTR pcode$[rsp]
  00467	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00470	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00475	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193838
  0047c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00481	44 8b c9	 mov	 r9d, ecx
  00484	4c 8b c2	 mov	 r8, rdx
  00487	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193839
  0048e	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00493	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN73@z900_txf_d:
  00499	33 c0		 xor	 eax, eax
  0049b	85 c0		 test	 eax, eax
  0049d	75 8d		 jne	 SHORT $LN19@z900_txf_d

; 1801 :     regs->txf_why |= TXF_WHY_UNFILT_INT;

  0049f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004a7	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  004ad	0f ba e8 16	 bts	 eax, 22
  004b1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b9	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 1802 :     ABORT_TRANS( regs, ABORT_RETRY_RETURN, TAC_UPGM );

  004bf	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193840
  004c6	41 b8 04 00 00
	00		 mov	 r8d, 4
  004cc	33 d2		 xor	 edx, edx
  004ce	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d6	e8 00 00 00 00	 call	 z900_abort_transaction
$LN74@z900_txf_d:

; 1803 : 
; 1804 : } /* end txf_do_pi_filtering */

  004db	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  004e2	c3		 ret	 0
  004e3	90		 npad	 1
$LN84@z900_txf_d:
  004e4	00 00 00 00	 DD	 $LN22@z900_txf_d
  004e8	00 00 00 00	 DD	 $LN23@z900_txf_d
  004ec	00 00 00 00	 DD	 $LN24@z900_txf_d
  004f0	00 00 00 00	 DD	 $LN26@z900_txf_d
  004f4	00 00 00 00	 DD	 $LN27@z900_txf_d
  004f8	00 00 00 00	 DD	 $LN25@z900_txf_d
  004fc	00 00 00 00	 DD	 $LN36@z900_txf_d
  00500	00 00 00 00	 DD	 $LN42@z900_txf_d
  00504	00 00 00 00	 DD	 $LN43@z900_txf_d
  00508	00 00 00 00	 DD	 $LN44@z900_txf_d
  0050c	00 00 00 00	 DD	 $LN45@z900_txf_d
  00510	00 00 00 00	 DD	 $LN46@z900_txf_d
  00514	00 00 00 00	 DD	 $LN47@z900_txf_d
  00518	00 00 00 00	 DD	 $LN48@z900_txf_d
  0051c	00 00 00 00	 DD	 $LN49@z900_txf_d
  00520	00 00 00 00	 DD	 $LN28@z900_txf_d
  00524	00 00 00 00	 DD	 $LN29@z900_txf_d
  00528	00 00 00 00	 DD	 $LN52@z900_txf_d
  0052c	00 00 00 00	 DD	 $LN53@z900_txf_d
  00530	00 00 00 00	 DD	 $LN54@z900_txf_d
  00534	00 00 00 00	 DD	 $LN50@z900_txf_d
  00538	00 00 00 00	 DD	 $LN51@z900_txf_d
  0053c	00 00 00 00	 DD	 $LN55@z900_txf_d
  00540	00 00 00 00	 DD	 $LN56@z900_txf_d
  00544	00 00 00 00	 DD	 $LN57@z900_txf_d
  00548	00 00 00 00	 DD	 $LN58@z900_txf_d
  0054c	00 00 00 00	 DD	 $LN59@z900_txf_d
  00550	00 00 00 00	 DD	 $LN60@z900_txf_d
  00554	00 00 00 00	 DD	 $LN30@z900_txf_d
  00558	00 00 00 00	 DD	 $LN31@z900_txf_d
  0055c	00 00 00 00	 DD	 $LN32@z900_txf_d
  00560	00 00 00 00	 DD	 $LN33@z900_txf_d
  00564	00 00 00 00	 DD	 $LN61@z900_txf_d
$LN83@z900_txf_d:
  00568	00		 DB	 0
  00569	01		 DB	 1
  0056a	02		 DB	 2
  0056b	03		 DB	 3
  0056c	04		 DB	 4
  0056d	05		 DB	 5
  0056e	06		 DB	 6
  0056f	07		 DB	 7
  00570	08		 DB	 8
  00571	09		 DB	 9
  00572	0a		 DB	 10
  00573	0b		 DB	 11
  00574	0c		 DB	 12
  00575	0d		 DB	 13
  00576	0e		 DB	 14
  00577	0f		 DB	 15
  00578	10		 DB	 16
  00579	11		 DB	 17
  0057a	12		 DB	 18
  0057b	20		 DB	 32			; 00000020H
  0057c	20		 DB	 32			; 00000020H
  0057d	20		 DB	 32			; 00000020H
  0057e	20		 DB	 32			; 00000020H
  0057f	13		 DB	 19
  00580	20		 DB	 32			; 00000020H
  00581	20		 DB	 32			; 00000020H
  00582	14		 DB	 20
  00583	20		 DB	 32			; 00000020H
  00584	15		 DB	 21
  00585	20		 DB	 32			; 00000020H
  00586	20		 DB	 32			; 00000020H
  00587	20		 DB	 32			; 00000020H
  00588	20		 DB	 32			; 00000020H
  00589	20		 DB	 32			; 00000020H
  0058a	20		 DB	 32			; 00000020H
  0058b	20		 DB	 32			; 00000020H
  0058c	20		 DB	 32			; 00000020H
  0058d	20		 DB	 32			; 00000020H
  0058e	20		 DB	 32			; 00000020H
  0058f	16		 DB	 22
  00590	17		 DB	 23
  00591	18		 DB	 24
  00592	19		 DB	 25
  00593	1a		 DB	 26
  00594	1b		 DB	 27
  00595	20		 DB	 32			; 00000020H
  00596	20		 DB	 32			; 00000020H
  00597	20		 DB	 32			; 00000020H
  00598	20		 DB	 32			; 00000020H
  00599	20		 DB	 32			; 00000020H
  0059a	20		 DB	 32			; 00000020H
  0059b	20		 DB	 32			; 00000020H
  0059c	20		 DB	 32			; 00000020H
  0059d	20		 DB	 32			; 00000020H
  0059e	20		 DB	 32			; 00000020H
  0059f	1c		 DB	 28
  005a0	1d		 DB	 29
  005a1	1e		 DB	 30
  005a2	1f		 DB	 31
z900_txf_do_pi_filtering ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
txf_contran$ = 128
txf_gprmask$ = 129
i$ = 132
had_INTLOCK$ = 136
j$1 = 140
ilc$2 = 144
txf_piid$ = 148
txf_tnd$ = 152
retry$ = 156
xcode$3 = 160
pmap$4 = 168
i$5 = 176
pcode$6 = 180
pi_tdba$7 = 184
tv150 = 192
tv157 = 196
tv159 = 200
tv171 = 204
tv178 = 208
tv185 = 212
tv187 = 216
tv338 = 220
tv347 = 224
tv353 = 228
tv789 = 232
tv790 = 236
tv1020 = 240
tv1027 = 244
tv133 = 248
tv143 = 252
real_tdb$8 = 256
txf_atia$ = 264
pi_tdb$ = 272
tb_tdb$ = 280
tv994 = 288
tv303 = 292
slot$9 = 296
tv466 = 300
tv532 = 304
tv669 = 308
tv953 = 312
tv294 = 320
tv300 = 328
tv454 = 336
tv457 = 344
tv463 = 352
tv529 = 360
tv666 = 368
altaddr$10 = 376
tv905 = 384
tv930 = 392
tv959 = 400
txf_conflict$ = 408
stid$11 = 416
p$12 = 424
tv305 = 432
tv443 = 440
tv447 = 448
tv468 = 456
tv520 = 464
tv534 = 472
tv658 = 480
tv671 = 488
mainaddr$13 = 496
tv950 = 504
tv996 = 512
txf_bea$ = 520
who$14 = 528
why$15 = 544
__$ArrayPad$ = 800
regs$ = 848
raw_retry$ = 856
txf_tac$ = 864
loc$ = 872
z900_abort_transaction PROC

; 1073 : {

$LN217:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 38 03
	00 00		 sub	 rsp, 824		; 00000338H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1074 : #if !defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1075 : 
; 1076 :     /* S370 and S390 don't support Transactional-Execution Facility */
; 1077 : 
; 1078 :     UNREFERENCED( regs      );
; 1079 :     UNREFERENCED( raw_retry );
; 1080 :     UNREFERENCED( txf_tac   );
; 1081 :     UNREFERENCED( loc       );
; 1082 : 
; 1083 :     CRASH();   /* Should NEVER be called for S/370 or S/390 */
; 1084 : 
; 1085 : #else /* only Z900 supports Transactional-Execution Facility */
; 1086 : 
; 1087 : BYTE       txf_gprmask;
; 1088 : int        txf_tnd, i;
; 1089 : bool       txf_contran, had_INTLOCK;
; 1090 : U32        txf_piid;
; 1091 : U64        txf_conflict;
; 1092 : U64        txf_bea;
; 1093 : TDB*       pi_tdb   = NULL; /* Program Interrupt TDB @ fixed 0x1800  */

  0002e	48 c7 84 24 10
	01 00 00 00 00
	00 00		 mov	 QWORD PTR pi_tdb$[rsp], 0

; 1094 : TDB*       tb_tdb   = NULL; /* TBEGIN-specified TDB @ operand-1 addr */

  0003a	48 c7 84 24 18
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tb_tdb$[rsp], 0
$LN4@z900_abort:

; 1095 : VADR       txf_atia;        /* Aborted Transaction Instruction Addr. */
; 1096 : int        retry;           /* Actual retry code                     */
; 1097 : 
; 1098 :     UNREFERENCED( loc );

  00046	33 c0		 xor	 eax, eax
  00048	85 c0		 test	 eax, eax
  0004a	75 fa		 jne	 SHORT $LN4@z900_abort
$LN7@z900_abort:

; 1099 : 
; 1100 :     PTT_TXF( "*TXF abort", raw_retry, txf_tac, regs->txf_contran );

  0004c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00053	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00056	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  0005c	48 85 c0	 test	 rax, rax
  0005f	74 51		 je	 SHORT $LN59@z900_abort
  00061	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00069	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00070	48 63 8c 24 60
	03 00 00	 movsxd	 rcx, DWORD PTR txf_tac$[rsp]
  00078	48 63 94 24 58
	03 00 00	 movsxd	 rdx, DWORD PTR raw_retry$[rsp]
  00080	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00089	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193561
  00095	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009a	4c 8b c9	 mov	 r9, rcx
  0009d	4c 8b c2	 mov	 r8, rdx
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193562
  000a7	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN59@z900_abort:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 94		 jne	 SHORT $LN7@z900_abort

; 1101 : 
; 1102 :     /* Set the initial Transaction Abort Code */
; 1103 :     if (!regs->txf_tac)

  000b8	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	83 b8 08 af 00
	00 00		 cmp	 DWORD PTR [rax+44808], 0
  000c7	75 15		 jne	 SHORT $LN60@z900_abort

; 1104 :         regs->txf_tac = txf_tac;

  000c9	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR txf_tac$[rsp]
  000d8	89 88 08 af 00
	00		 mov	 DWORD PTR [rax+44808], ecx
$LN60@z900_abort:
$LN10@z900_abort:

; 1105 : 
; 1106 :     TXF_TRACE_INIT( regs );

  000de	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e6	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ee	8b 89 84 af 00
	00		 mov	 ecx, DWORD PTR [rcx+44932]
  000f4	89 88 ac af 00
	00		 mov	 DWORD PTR [rax+44972], ecx
  000fa	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	0f bf 80 3c 08
	00 00		 movsx	 eax, WORD PTR [rax+2108]
  00109	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00111	89 81 b0 af 00
	00		 mov	 DWORD PTR [rcx+44976], eax
  00117	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011f	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00126	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	89 81 b4 af 00
	00		 mov	 DWORD PTR [rcx+44980], eax
  00134	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013c	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	8b 89 08 af 00
	00		 mov	 ecx, DWORD PTR [rcx+44808]
  0014a	89 88 b8 af 00
	00		 mov	 DWORD PTR [rax+44984], ecx
  00150	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00158	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00160	8b 89 50 0e 00
	00		 mov	 ecx, DWORD PTR [rcx+3664]
  00166	89 88 bc af 00
	00		 mov	 DWORD PTR [rax+44988], ecx
  0016c	33 c0		 xor	 eax, eax
  0016e	85 c0		 test	 eax, eax
  00170	0f 85 68 ff ff
	ff		 jne	 $LN10@z900_abort

; 1107 : 
; 1108 :     // LOGIC ERROR if CPU not in transactional-execution mode
; 1109 :     if (!regs->txf_tnd)

  00176	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00185	85 c0		 test	 eax, eax
  00187	75 1d		 jne	 SHORT $LN61@z900_abort
$LN13@z900_abort:

; 1110 :         CRASH();

  00189	48 c7 84 24 a8
	01 00 00 00 00
	00 00		 mov	 QWORD PTR p$12[rsp], 0
  00195	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR p$12[rsp]
  0019d	c6 00 00	 mov	 BYTE PTR [rax], 0
  001a0	33 c0		 xor	 eax, eax
  001a2	85 c0		 test	 eax, eax
  001a4	75 e3		 jne	 SHORT $LN13@z900_abort
$LN61@z900_abort:

; 1111 : 
; 1112 :     /* Get the ACTUAL 'retry' code */
; 1113 :     retry = ((raw_retry < 0) ? -raw_retry : raw_retry);

  001a6	83 bc 24 58 03
	00 00 00	 cmp	 DWORD PTR raw_retry$[rsp], 0
  001ae	7d 12		 jge	 SHORT $LN161@z900_abort
  001b0	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR raw_retry$[rsp]
  001b7	f7 d8		 neg	 eax
  001b9	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv133[rsp], eax
  001c0	eb 0e		 jmp	 SHORT $LN162@z900_abort
$LN161@z900_abort:
  001c2	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR raw_retry$[rsp]
  001c9	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv133[rsp], eax
$LN162@z900_abort:
  001d0	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR tv133[rsp]
  001d7	89 84 24 9c 00
	00 00		 mov	 DWORD PTR retry$[rsp], eax

; 1114 : 
; 1115 :     /* Normal abort? Or special instruction dispatch abort? */
; 1116 :     if (raw_retry >= 0)

  001de	83 bc 24 58 03
	00 00 00	 cmp	 DWORD PTR raw_retry$[rsp], 0
  001e6	0f 8c 1f 02 00
	00		 jl	 $LN62@z900_abort

; 1117 :     {
; 1118 :         /* Normal instruction abort: the PREVIOUS instruction
; 1119 :            is the one where the abort actually occurred at. */
; 1120 :         txf_atia = PSW_IA_FROM_IP( regs, -REAL_ILC( regs ));

  001ec	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f4	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001fa	83 e0 01	 and	 eax, 1
  001fd	85 c0		 test	 eax, eax
  001ff	75 0d		 jne	 SHORT $LN163@z900_abort
  00201	c7 84 24 fc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv143[rsp], 1
  0020c	eb 0b		 jmp	 SHORT $LN164@z900_abort
$LN163@z900_abort:
  0020e	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv143[rsp], 0
$LN164@z900_abort:
  00219	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR tv143[rsp], 0
  00221	74 0d		 je	 SHORT $LN167@z900_abort
  00223	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv150[rsp], 1
  0022e	eb 0b		 jmp	 SHORT $LN168@z900_abort
$LN167@z900_abort:
  00230	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv150[rsp], 0
$LN168@z900_abort:
  0023b	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR tv150[rsp], 0
  00243	74 18		 je	 SHORT $LN171@z900_abort
  00245	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  00254	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv159[rsp], eax
  0025b	eb 3d		 jmp	 SHORT $LN172@z900_abort
$LN171@z900_abort:
  0025d	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00265	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0026b	d1 e8		 shr	 eax, 1
  0026d	83 e0 01	 and	 eax, 1
  00270	85 c0		 test	 eax, eax
  00272	74 0d		 je	 SHORT $LN169@z900_abort
  00274	c7 84 24 c4 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv157[rsp], 6
  0027f	eb 0b		 jmp	 SHORT $LN170@z900_abort
$LN169@z900_abort:
  00281	c7 84 24 c4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv157[rsp], 4
$LN170@z900_abort:
  0028c	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv157[rsp]
  00293	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv159[rsp], eax
$LN172@z900_abort:
  0029a	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a2	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002aa	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  002b1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  002b5	48 2b c1	 sub	 rax, rcx
  002b8	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c0	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  002c7	48 03 c8	 add	 rcx, rax
  002ca	48 8b c1	 mov	 rax, rcx
  002cd	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv159[rsp]
  002d4	f7 d9		 neg	 ecx
  002d6	48 63 c9	 movsxd	 rcx, ecx
  002d9	48 03 c1	 add	 rax, rcx
  002dc	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e4	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  002eb	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR txf_atia$[rsp], rax
$LN16@z900_abort:

; 1121 :         PTT_TXF( "TXF ATIA", txf_atia, 0, -REAL_ILC( regs ) );

  002f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002fa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002fd	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00303	48 85 c0	 test	 rax, rax
  00306	0f 84 f0 00 00
	00		 je	 $LN64@z900_abort
  0030c	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00314	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0031a	83 e0 01	 and	 eax, 1
  0031d	85 c0		 test	 eax, eax
  0031f	75 0d		 jne	 SHORT $LN173@z900_abort
  00321	c7 84 24 cc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv171[rsp], 1
  0032c	eb 0b		 jmp	 SHORT $LN174@z900_abort
$LN173@z900_abort:
  0032e	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv171[rsp], 0
$LN174@z900_abort:
  00339	83 bc 24 cc 00
	00 00 00	 cmp	 DWORD PTR tv171[rsp], 0
  00341	74 0d		 je	 SHORT $LN177@z900_abort
  00343	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv178[rsp], 1
  0034e	eb 0b		 jmp	 SHORT $LN178@z900_abort
$LN177@z900_abort:
  00350	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv178[rsp], 0
$LN178@z900_abort:
  0035b	83 bc 24 d0 00
	00 00 00	 cmp	 DWORD PTR tv178[rsp], 0
  00363	74 18		 je	 SHORT $LN181@z900_abort
  00365	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0036d	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  00374	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv187[rsp], eax
  0037b	eb 3d		 jmp	 SHORT $LN182@z900_abort
$LN181@z900_abort:
  0037d	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00385	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0038b	d1 e8		 shr	 eax, 1
  0038d	83 e0 01	 and	 eax, 1
  00390	85 c0		 test	 eax, eax
  00392	74 0d		 je	 SHORT $LN179@z900_abort
  00394	c7 84 24 d4 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv185[rsp], 6
  0039f	eb 0b		 jmp	 SHORT $LN180@z900_abort
$LN179@z900_abort:
  003a1	c7 84 24 d4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv185[rsp], 4
$LN180@z900_abort:
  003ac	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv185[rsp]
  003b3	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv187[rsp], eax
$LN182@z900_abort:
  003ba	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv187[rsp]
  003c1	f7 d8		 neg	 eax
  003c3	48 98		 cdqe
  003c5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003ce	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193568
  003da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003df	45 33 c9	 xor	 r9d, r9d
  003e2	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR txf_atia$[rsp]
  003ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193569
  003f1	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  003f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN64@z900_abort:
  003fc	33 c0		 xor	 eax, eax
  003fe	85 c0		 test	 eax, eax
  00400	0f 85 ed fe ff
	ff		 jne	 $LN16@z900_abort

; 1122 :     }

  00406	e9 a0 00 00 00	 jmp	 $LN63@z900_abort
$LN62@z900_abort:

; 1123 :     else // (raw_retry < 0)
; 1124 :     {
; 1125 :         /* Instruction dispatch abort: the CURRENT instruction
; 1126 :            address is where the abort actually occurred at. */
; 1127 :         txf_atia = PSW_IA_FROM_IP( regs, 0 );

  0040b	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00413	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041b	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00422	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00426	48 2b c1	 sub	 rax, rcx
  00429	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00431	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00438	48 03 c8	 add	 rcx, rax
  0043b	48 8b c1	 mov	 rax, rcx
  0043e	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00446	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0044d	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR txf_atia$[rsp], rax
$LN19@z900_abort:

; 1128 :         PTT_TXF( "TXF ATIA", txf_atia, 0, 0 );

  00455	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0045c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0045f	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00465	48 85 c0	 test	 rax, rax
  00468	74 3b		 je	 SHORT $LN65@z900_abort
  0046a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00473	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0047c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193571
  00483	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00488	45 33 c9	 xor	 r9d, r9d
  0048b	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR txf_atia$[rsp]
  00493	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193572
  0049a	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0049f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN65@z900_abort:
  004a5	33 c0		 xor	 eax, eax
  004a7	85 c0		 test	 eax, eax
  004a9	75 aa		 jne	 SHORT $LN19@z900_abort
$LN63@z900_abort:

; 1129 :     }
; 1130 : 
; 1131 :     /* Obtain the interrupt lock if we don't already have it */
; 1132 :     if (IS_INTLOCK_HELD( regs ))

  004ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004b2	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  004b9	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c1	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  004c8	3b c1		 cmp	 eax, ecx
  004ca	75 0a		 jne	 SHORT $LN66@z900_abort

; 1133 :         had_INTLOCK = true;

  004cc	c6 84 24 88 00
	00 00 01	 mov	 BYTE PTR had_INTLOCK$[rsp], 1
  004d4	eb 1c		 jmp	 SHORT $LN67@z900_abort
$LN66@z900_abort:

; 1134 :     else
; 1135 :     {
; 1136 :         OBTAIN_INTLOCK( regs );

  004d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193575
  004dd	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e5	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1137 :         had_INTLOCK = false;

  004ea	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR had_INTLOCK$[rsp], 0
$LN67@z900_abort:

; 1138 :     }
; 1139 : 
; 1140 :     PERFORM_SERIALIZATION( regs );

  004f2	0f ae f0	 mfence

; 1141 : 
; 1142 :     /*---------------------------------------------*/
; 1143 :     /*       Failure of transaction retry?         */
; 1144 :     /*---------------------------------------------*/
; 1145 :     if (1
; 1146 :         && MLVL( VERBOSE )
; 1147 :         && regs->txf_aborts
; 1148 :         && TXF_TRACE( regs, FAILURE, regs->txf_contran )

  004f5	33 c0		 xor	 eax, eax
  004f7	83 f8 01	 cmp	 eax, 1
  004fa	0f 84 73 03 00
	00		 je	 $LN68@z900_abort
  00500	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00507	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  0050d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00512	85 c0		 test	 eax, eax
  00514	0f 84 59 03 00
	00		 je	 $LN68@z900_abort
  0051a	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00522	83 b8 50 0e 00
	00 00		 cmp	 DWORD PTR [rax+3664], 0
  00529	0f 84 44 03 00
	00		 je	 $LN68@z900_abort
  0052f	33 c0		 xor	 eax, eax
  00531	83 f8 01	 cmp	 eax, 1
  00534	0f 84 39 03 00
	00		 je	 $LN68@z900_abort
  0053a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00541	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00547	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  0054c	85 c0		 test	 eax, eax
  0054e	0f 84 1f 03 00
	00		 je	 $LN68@z900_abort
  00554	33 c0		 xor	 eax, eax
  00556	83 f8 01	 cmp	 eax, 1
  00559	0f 84 14 03 00
	00		 je	 $LN68@z900_abort
  0055f	33 c0		 xor	 eax, eax
  00561	85 c0		 test	 eax, eax
  00563	75 37		 jne	 SHORT $LN69@z900_abort
  00565	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0056c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00572	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00577	85 c0		 test	 eax, eax
  00579	74 21		 je	 SHORT $LN69@z900_abort
  0057b	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00583	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0058a	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  00590	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00596	0f 85 d7 02 00
	00		 jne	 $LN68@z900_abort
$LN69@z900_abort:
  0059c	33 c0		 xor	 eax, eax
  0059e	85 c0		 test	 eax, eax
  005a0	75 37		 jne	 SHORT $LN70@z900_abort
  005a2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005a9	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  005af	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  005b4	85 c0		 test	 eax, eax
  005b6	74 21		 je	 SHORT $LN70@z900_abort
  005b8	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005c7	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  005cd	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  005d3	0f 8c 9a 02 00
	00		 jl	 $LN68@z900_abort
$LN70@z900_abort:
  005d9	33 c0		 xor	 eax, eax
  005db	85 c0		 test	 eax, eax
  005dd	75 73		 jne	 SHORT $LN71@z900_abort
  005df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005e6	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  005ec	25 00 00 00 0c	 and	 eax, 201326592		; 0c000000H
  005f1	3d 00 00 00 0c	 cmp	 eax, 201326592		; 0c000000H
  005f6	74 5a		 je	 SHORT $LN71@z900_abort
  005f8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005ff	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00605	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0060a	85 c0		 test	 eax, eax
  0060c	74 13		 je	 SHORT $LN72@z900_abort
  0060e	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00616	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0061d	85 c0		 test	 eax, eax
  0061f	75 31		 jne	 SHORT $LN71@z900_abort
$LN72@z900_abort:
  00621	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00628	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0062e	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00633	85 c0		 test	 eax, eax
  00635	0f 84 38 02 00
	00		 je	 $LN68@z900_abort
  0063b	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00643	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0064a	85 c0		 test	 eax, eax
  0064c	0f 85 21 02 00
	00		 jne	 $LN68@z900_abort
$LN71@z900_abort:
  00652	33 c0		 xor	 eax, eax
  00654	85 c0		 test	 eax, eax
  00656	0f 85 e0 00 00
	00		 jne	 $LN73@z900_abort
  0065c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00663	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00669	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  0066e	85 c0		 test	 eax, eax
  00670	0f 84 c6 00 00
	00		 je	 $LN73@z900_abort
  00676	33 c0		 xor	 eax, eax
  00678	83 f8 01	 cmp	 eax, 1
  0067b	0f 84 f2 01 00
	00		 je	 $LN68@z900_abort
  00681	33 c0		 xor	 eax, eax
  00683	85 c0		 test	 eax, eax
  00685	75 3b		 jne	 SHORT $LN74@z900_abort
  00687	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0068e	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00694	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00699	85 c0		 test	 eax, eax
  0069b	74 25		 je	 SHORT $LN74@z900_abort
  0069d	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006ac	8b 89 50 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1360]
  006b2	8b 80 ac af 00
	00		 mov	 eax, DWORD PTR [rax+44972]
  006b8	23 c1		 and	 eax, ecx
  006ba	85 c0		 test	 eax, eax
  006bc	0f 84 b1 01 00
	00		 je	 $LN68@z900_abort
$LN74@z900_abort:
  006c2	33 c0		 xor	 eax, eax
  006c4	85 c0		 test	 eax, eax
  006c6	75 37		 jne	 SHORT $LN75@z900_abort
  006c8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006cf	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  006d5	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  006da	85 c0		 test	 eax, eax
  006dc	74 21		 je	 SHORT $LN75@z900_abort
  006de	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006ed	8b 89 54 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1364]
  006f3	39 88 b8 af 00
	00		 cmp	 DWORD PTR [rax+44984], ecx
  006f9	0f 85 74 01 00
	00		 jne	 $LN68@z900_abort
$LN75@z900_abort:
  006ff	33 c0		 xor	 eax, eax
  00701	85 c0		 test	 eax, eax
  00703	75 37		 jne	 SHORT $LN76@z900_abort
  00705	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0070c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00712	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00717	85 c0		 test	 eax, eax
  00719	74 21		 je	 SHORT $LN76@z900_abort
  0071b	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00723	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0072a	8b 89 5c 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1372]
  00730	39 88 bc af 00
	00		 cmp	 DWORD PTR [rax+44988], ecx
  00736	0f 8c 37 01 00
	00		 jl	 $LN68@z900_abort
$LN76@z900_abort:
$LN73@z900_abort:

; 1149 :     )
; 1150 :     {
; 1151 :         // "TXF: %s%02X: %s%s transaction retry #%d FAILED!"
; 1152 :         WRMSG( HHC17719, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),

  0073c	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00744	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0074b	85 c0		 test	 eax, eax
  0074d	74 11		 je	 SHORT $LN183@z900_abort
  0074f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193585
  00756	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv294[rsp], rax
  0075e	eb 0f		 jmp	 SHORT $LN184@z900_abort
$LN183@z900_abort:
  00760	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193586
  00767	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv294[rsp], rax
$LN184@z900_abort:
  0076f	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00777	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0077d	d1 e8		 shr	 eax, 1
  0077f	83 e0 01	 and	 eax, 1
  00782	85 c0		 test	 eax, eax
  00784	74 11		 je	 SHORT $LN185@z900_abort
  00786	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193587
  0078d	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv300[rsp], rax
  00795	eb 0f		 jmp	 SHORT $LN186@z900_abort
$LN185@z900_abort:
  00797	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193588
  0079e	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv300[rsp], rax
$LN186@z900_abort:
  007a6	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ae	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  007b5	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv303[rsp], eax
  007bc	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007c4	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  007cb	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  007d2	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  007da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  007e0	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv305[rsp], rax
  007e8	b9 01 00 00 00	 mov	 ecx, 1
  007ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007f3	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007fb	8b 89 50 0e 00
	00		 mov	 ecx, DWORD PTR [rcx+3664]
  00801	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00805	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv294[rsp]
  0080d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00812	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv300[rsp]
  0081a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0081f	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR tv303[rsp]
  00826	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0082a	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR tv305[rsp]
  00832	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00837	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193589
  0083e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00843	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193590
  0084a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0084f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00854	41 b9 03 00 00
	00		 mov	 r9d, 3
  0085a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193591
  00861	ba 81 04 00 00	 mov	 edx, 1153		; 00000481H
  00866	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193592
  0086d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN68@z900_abort:

; 1153 :             TXF_CONSTRAINED( regs->txf_contran ), regs->txf_aborts );
; 1154 :     }
; 1155 : 
; 1156 :     /*---------------------------------------------*/
; 1157 :     /*          Count the abort/retry              */
; 1158 :     /*---------------------------------------------*/
; 1159 : 
; 1160 :     /* Count total retries for this transaction */
; 1161 :     regs->txf_aborts++;

  00873	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0087b	8b 80 50 0e 00
	00		 mov	 eax, DWORD PTR [rax+3664]
  00881	ff c0		 inc	 eax
  00883	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0088b	89 81 50 0e 00
	00		 mov	 DWORD PTR [rcx+3664], eax

; 1162 : 
; 1163 :     /* Provide PPA assist for constrained transactions too */
; 1164 :     if (regs->txf_contran)

  00891	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00899	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  008a0	85 c0		 test	 eax, eax
  008a2	74 1c		 je	 SHORT $LN77@z900_abort

; 1165 :         regs->txf_PPA = regs->txf_aborts;

  008a4	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008ac	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008b4	8b 89 50 0e 00
	00		 mov	 ecx, DWORD PTR [rcx+3664]
  008ba	89 88 54 0e 00
	00		 mov	 DWORD PTR [rax+3668], ecx
$LN77@z900_abort:

; 1166 : 
; 1167 :     /* Track total aborts by cause (TAC) */
; 1168 :     if (regs->txf_tac == TAC_MISC)

  008c0	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008c8	81 b8 08 af 00
	00 ff 00 00 00	 cmp	 DWORD PTR [rax+44808], 255 ; 000000ffH
  008d2	75 5b		 jne	 SHORT $LN78@z900_abort

; 1169 :         TXF_STATS( aborts_by_tac_misc, regs->txf_contran );

  008d4	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008dc	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  008e3	85 c0		 test	 eax, eax
  008e5	74 0d		 je	 SHORT $LN187@z900_abort
  008e7	c7 84 24 dc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv338[rsp], 1
  008f2	eb 0b		 jmp	 SHORT $LN188@z900_abort
$LN187@z900_abort:
  008f4	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv338[rsp], 0
$LN188@z900_abort:
  008ff	48 63 84 24 dc
	00 00 00	 movsxd	 rax, DWORD PTR tv338[rsp]
  00907	48 69 c0 e8 00
	00 00		 imul	 rax, rax, 232		; 000000e8H
  0090e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00915	48 8d 84 01 08
	06 00 00	 lea	 rax, QWORD PTR [rcx+rax+1544]
  0091d	ba 01 00 00 00	 mov	 edx, 1
  00922	48 8b c8	 mov	 rcx, rax
  00925	e8 00 00 00 00	 call	 atomic_update64
  0092a	e9 a4 00 00 00	 jmp	 $LN79@z900_abort
$LN78@z900_abort:

; 1170 :     else
; 1171 :     {
; 1172 :         int slot = regs->txf_tac < TXF_STATS_TAC_SLOTS ?

  0092f	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00937	83 b8 08 af 00
	00 11		 cmp	 DWORD PTR [rax+44808], 17
  0093e	7d 17		 jge	 SHORT $LN189@z900_abort
  00940	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00948	8b 80 08 af 00
	00		 mov	 eax, DWORD PTR [rax+44808]
  0094e	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv347[rsp], eax
  00955	eb 0b		 jmp	 SHORT $LN190@z900_abort
$LN189@z900_abort:
  00957	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv347[rsp], 0
$LN190@z900_abort:
  00962	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR tv347[rsp]
  00969	89 84 24 28 01
	00 00		 mov	 DWORD PTR slot$9[rsp], eax

; 1173 :                    regs->txf_tac : 0; // (0 == "other")
; 1174 :         TXF_STATS( aborts_by_tac[ slot ], regs->txf_contran );

  00970	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00978	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0097f	85 c0		 test	 eax, eax
  00981	74 0d		 je	 SHORT $LN191@z900_abort
  00983	c7 84 24 e4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv353[rsp], 1
  0098e	eb 0b		 jmp	 SHORT $LN192@z900_abort
$LN191@z900_abort:
  00990	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv353[rsp], 0
$LN192@z900_abort:
  0099b	48 63 84 24 e4
	00 00 00	 movsxd	 rax, DWORD PTR tv353[rsp]
  009a3	48 69 c0 e8 00
	00 00		 imul	 rax, rax, 232		; 000000e8H
  009aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  009b1	48 8d 84 01 78
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax+1400]
  009b9	48 63 8c 24 28
	01 00 00	 movsxd	 rcx, DWORD PTR slot$9[rsp]
  009c1	48 8d 44 c8 08	 lea	 rax, QWORD PTR [rax+rcx*8+8]
  009c6	ba 01 00 00 00	 mov	 edx, 1
  009cb	48 8b c8	 mov	 rcx, rax
  009ce	e8 00 00 00 00	 call	 atomic_update64
$LN79@z900_abort:

; 1175 :     }
; 1176 : 
; 1177 :     /*---------------------------------------------*/
; 1178 :     /*  Clean up the transaction flags             */
; 1179 :     /*---------------------------------------------*/
; 1180 : 
; 1181 :     txf_tnd      = regs->txf_tnd;        /* save orig value */

  009d3	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009db	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  009e2	89 84 24 98 00
	00 00		 mov	 DWORD PTR txf_tnd$[rsp], eax

; 1182 :     txf_contran  = regs->txf_contran;    /* save orig value */

  009e9	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009f1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  009f8	88 84 24 80 00
	00 00		 mov	 BYTE PTR txf_contran$[rsp], al

; 1183 :     txf_gprmask  = regs->txf_gprmask;    /* save orig value */

  009ff	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a07	0f b6 80 84 ae
	00 00		 movzx	 eax, BYTE PTR [rax+44676]
  00a0e	88 84 24 81 00
	00 00		 mov	 BYTE PTR txf_gprmask$[rsp], al

; 1184 :     txf_conflict = regs->txf_conflict;   /* save orig value */

  00a15	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a1d	48 8b 80 78 0e
	00 00		 mov	 rax, QWORD PTR [rax+3704]
  00a24	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR txf_conflict$[rsp], rax

; 1185 :     txf_piid     = regs->txf_piid;       /* save orig value */

  00a2c	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a34	8b 80 7c af 00
	00		 mov	 eax, DWORD PTR [rax+44924]
  00a3a	89 84 24 94 00
	00 00		 mov	 DWORD PTR txf_piid$[rsp], eax

; 1186 :     txf_bea      = regs->bear;           /* save orig value */

  00a41	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a49	48 8b 80 18 02
	00 00		 mov	 rax, QWORD PTR [rax+536]
  00a50	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR txf_bea$[rsp], rax

; 1187 : 
; 1188 :     /*---------------------------------------------*/
; 1189 :     /*  Log the failure if debugging enabled       */
; 1190 :     /*---------------------------------------------*/
; 1191 : 
; 1192 :     if (TXF_TRACE( regs, FAILURE, txf_contran ))

  00a58	33 c0		 xor	 eax, eax
  00a5a	83 f8 01	 cmp	 eax, 1
  00a5d	0f 84 20 0c 00
	00		 je	 $LN80@z900_abort
  00a63	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a6a	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00a70	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00a75	85 c0		 test	 eax, eax
  00a77	0f 84 06 0c 00
	00		 je	 $LN80@z900_abort
  00a7d	33 c0		 xor	 eax, eax
  00a7f	83 f8 01	 cmp	 eax, 1
  00a82	0f 84 fb 0b 00
	00		 je	 $LN80@z900_abort
  00a88	33 c0		 xor	 eax, eax
  00a8a	85 c0		 test	 eax, eax
  00a8c	75 37		 jne	 SHORT $LN81@z900_abort
  00a8e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a95	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00a9b	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00aa0	85 c0		 test	 eax, eax
  00aa2	74 21		 je	 SHORT $LN81@z900_abort
  00aa4	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00ab3	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  00ab9	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00abf	0f 85 be 0b 00
	00		 jne	 $LN80@z900_abort
$LN81@z900_abort:
  00ac5	33 c0		 xor	 eax, eax
  00ac7	85 c0		 test	 eax, eax
  00ac9	75 37		 jne	 SHORT $LN82@z900_abort
  00acb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ad2	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00ad8	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00add	85 c0		 test	 eax, eax
  00adf	74 21		 je	 SHORT $LN82@z900_abort
  00ae1	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ae9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00af0	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  00af6	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  00afc	0f 8c 81 0b 00
	00		 jl	 $LN80@z900_abort
$LN82@z900_abort:
  00b02	33 c0		 xor	 eax, eax
  00b04	85 c0		 test	 eax, eax
  00b06	75 65		 jne	 SHORT $LN83@z900_abort
  00b08	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b0f	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00b15	25 00 00 00 0c	 and	 eax, 201326592		; 0c000000H
  00b1a	3d 00 00 00 0c	 cmp	 eax, 201326592		; 0c000000H
  00b1f	74 4c		 je	 SHORT $LN83@z900_abort
  00b21	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b28	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00b2e	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00b33	85 c0		 test	 eax, eax
  00b35	74 0c		 je	 SHORT $LN84@z900_abort
  00b37	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  00b3f	85 c0		 test	 eax, eax
  00b41	75 2a		 jne	 SHORT $LN83@z900_abort
$LN84@z900_abort:
  00b43	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b4a	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00b50	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00b55	85 c0		 test	 eax, eax
  00b57	0f 84 26 0b 00
	00		 je	 $LN80@z900_abort
  00b5d	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  00b65	85 c0		 test	 eax, eax
  00b67	0f 85 16 0b 00
	00		 jne	 $LN80@z900_abort
$LN83@z900_abort:
  00b6d	33 c0		 xor	 eax, eax
  00b6f	85 c0		 test	 eax, eax
  00b71	0f 85 e0 00 00
	00		 jne	 $LN85@z900_abort
  00b77	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b7e	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00b84	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00b89	85 c0		 test	 eax, eax
  00b8b	0f 84 c6 00 00
	00		 je	 $LN85@z900_abort
  00b91	33 c0		 xor	 eax, eax
  00b93	83 f8 01	 cmp	 eax, 1
  00b96	0f 84 e7 0a 00
	00		 je	 $LN80@z900_abort
  00b9c	33 c0		 xor	 eax, eax
  00b9e	85 c0		 test	 eax, eax
  00ba0	75 3b		 jne	 SHORT $LN86@z900_abort
  00ba2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ba9	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00baf	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00bb4	85 c0		 test	 eax, eax
  00bb6	74 25		 je	 SHORT $LN86@z900_abort
  00bb8	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bc0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00bc7	8b 89 50 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1360]
  00bcd	8b 80 ac af 00
	00		 mov	 eax, DWORD PTR [rax+44972]
  00bd3	23 c1		 and	 eax, ecx
  00bd5	85 c0		 test	 eax, eax
  00bd7	0f 84 a6 0a 00
	00		 je	 $LN80@z900_abort
$LN86@z900_abort:
  00bdd	33 c0		 xor	 eax, eax
  00bdf	85 c0		 test	 eax, eax
  00be1	75 37		 jne	 SHORT $LN87@z900_abort
  00be3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00bea	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00bf0	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00bf5	85 c0		 test	 eax, eax
  00bf7	74 21		 je	 SHORT $LN87@z900_abort
  00bf9	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c01	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00c08	8b 89 54 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1364]
  00c0e	39 88 b8 af 00
	00		 cmp	 DWORD PTR [rax+44984], ecx
  00c14	0f 85 69 0a 00
	00		 jne	 $LN80@z900_abort
$LN87@z900_abort:
  00c1a	33 c0		 xor	 eax, eax
  00c1c	85 c0		 test	 eax, eax
  00c1e	75 37		 jne	 SHORT $LN88@z900_abort
  00c20	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c27	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00c2d	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00c32	85 c0		 test	 eax, eax
  00c34	74 21		 je	 SHORT $LN88@z900_abort
  00c36	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c3e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00c45	8b 89 5c 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1372]
  00c4b	39 88 bc af 00
	00		 cmp	 DWORD PTR [rax+44988], ecx
  00c51	0f 8c 2c 0a 00
	00		 jl	 $LN80@z900_abort
$LN88@z900_abort:
$LN85@z900_abort:

; 1193 :     {
; 1194 :         /* Report the reason WHY the transaction was aborted */
; 1195 :         char why[ 256 ] = {0};

  00c57	48 8d 84 24 20
	02 00 00	 lea	 rax, QWORD PTR why$15[rsp]
  00c5f	48 8b f8	 mov	 rdi, rax
  00c62	33 c0		 xor	 eax, eax
  00c64	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00c69	f3 aa		 rep stosb

; 1196 : 
; 1197 :         if (regs->txf_why)

  00c6b	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c73	83 b8 84 af 00
	00 00		 cmp	 DWORD PTR [rax+44932], 0
  00c7a	74 23		 je	 SHORT $LN89@z900_abort

; 1198 :             txf_why_str( why, sizeof( why ), regs->txf_why );

  00c7c	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c84	44 8b 80 84 af
	00 00		 mov	 r8d, DWORD PTR [rax+44932]
  00c8b	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00c90	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR why$15[rsp]
  00c98	e8 00 00 00 00	 call	 txf_why_str
  00c9d	eb 1b		 jmp	 SHORT $LN90@z900_abort
$LN89@z900_abort:

; 1199 :         else
; 1200 :             STRLCPY( why, " ?" );

  00c9f	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00ca5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193607
  00cac	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR why$15[rsp]
  00cb4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN90@z900_abort:

; 1201 : 
; 1202 :         // "TXF: %s%02X: %sFailed %s %s Transaction for TND %d: %s = %s, why =%s"
; 1203 :         WRMSG( HHC17703, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),

  00cba	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  00cc2	85 c0		 test	 eax, eax
  00cc4	74 11		 je	 SHORT $LN193@z900_abort
  00cc6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193608
  00ccd	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv454[rsp], rax
  00cd5	eb 0f		 jmp	 SHORT $LN194@z900_abort
$LN193@z900_abort:
  00cd7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193609
  00cde	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv454[rsp], rax
$LN194@z900_abort:
  00ce6	83 bc 24 98 00
	00 00 01	 cmp	 DWORD PTR txf_tnd$[rsp], 1
  00cee	7e 11		 jle	 SHORT $LN195@z900_abort
  00cf0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193610
  00cf7	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv457[rsp], rax
  00cff	eb 0f		 jmp	 SHORT $LN196@z900_abort
$LN195@z900_abort:
  00d01	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193611
  00d08	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv457[rsp], rax
$LN196@z900_abort:
  00d10	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d18	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00d1e	d1 e8		 shr	 eax, 1
  00d20	83 e0 01	 and	 eax, 1
  00d23	85 c0		 test	 eax, eax
  00d25	74 11		 je	 SHORT $LN197@z900_abort
  00d27	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193612
  00d2e	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv463[rsp], rax
  00d36	eb 0f		 jmp	 SHORT $LN198@z900_abort
$LN197@z900_abort:
  00d38	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193613
  00d3f	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv463[rsp], rax
$LN198@z900_abort:
  00d47	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR txf_tac$[rsp]
  00d4f	48 8b c8	 mov	 rcx, rax
  00d52	e8 00 00 00 00	 call	 tac2long
  00d57	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv443[rsp], rax
  00d5f	48 63 8c 24 60
	03 00 00	 movsxd	 rcx, DWORD PTR txf_tac$[rsp]
  00d67	e8 00 00 00 00	 call	 tac2short
  00d6c	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv447[rsp], rax
  00d74	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d7c	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00d83	89 8c 24 2c 01
	00 00		 mov	 DWORD PTR tv466[rsp], ecx
  00d8a	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00d92	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  00d99	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00da0	0f b6 8c 17 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdi+rdx+2888]
  00da8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00dae	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv468[rsp], rax
  00db6	b9 01 00 00 00	 mov	 ecx, 1
  00dbb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00dc1	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR why$15[rsp]
  00dc9	48 89 4c 24 78	 mov	 QWORD PTR [rsp+120], rcx
  00dce	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR tv443[rsp]
  00dd6	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  00ddb	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR tv447[rsp]
  00de3	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00de8	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR txf_tnd$[rsp]
  00def	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00df3	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv454[rsp]
  00dfb	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00e00	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv457[rsp]
  00e08	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00e0d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv463[rsp]
  00e15	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e1a	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR tv466[rsp]
  00e21	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e25	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR tv468[rsp]
  00e2d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e32	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193614
  00e39	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193615
  00e45	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e4a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e4f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e55	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193616
  00e5c	ba b6 04 00 00	 mov	 edx, 1206		; 000004b6H
  00e61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193617
  00e68	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1204 :             txf_tnd > 1 ? "Nested" : "Outermost",
; 1205 :             TXF_CONSTRAINED( txf_contran ), txf_tnd,
; 1206 :             tac2short( txf_tac ), tac2long( txf_tac ), why );
; 1207 : 
; 1208 :         /* If this is a delayed abort, log who detected/requested it */
; 1209 :         /* Delayed aborts are those detected by another CPU, not us. */
; 1210 :         if (regs->txf_why & TXF_WHY_DELAYED_ABORT)

  00e6e	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e76	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00e7c	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00e81	85 c0		 test	 eax, eax
  00e83	0f 84 0a 02 00
	00		 je	 $LN91@z900_abort

; 1211 :         {
; 1212 :             char who[16] = {0};

  00e89	48 8d 84 24 10
	02 00 00	 lea	 rax, QWORD PTR who$14[rsp]
  00e91	48 8b f8	 mov	 rdi, rax
  00e94	33 c0		 xor	 eax, eax
  00e96	b9 10 00 00 00	 mov	 ecx, 16
  00e9b	f3 aa		 rep stosb

; 1213 : 
; 1214 :             if (regs->txf_who < 0)

  00e9d	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ea5	83 b8 10 af 00
	00 00		 cmp	 DWORD PTR [rax+44816], 0
  00eac	7d 20		 jge	 SHORT $LN92@z900_abort

; 1215 :                 STRLCPY( who, "channel" );

  00eae	41 b8 10 00 00
	00		 mov	 r8d, 16
  00eb4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193621
  00ebb	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR who$14[rsp]
  00ec3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00ec9	e9 8f 00 00 00	 jmp	 $LN93@z900_abort
$LN92@z900_abort:

; 1216 :             else if (regs->txf_who == regs->cpuad) // (shouldn't occur)

  00ece	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ed6	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00edd	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ee5	39 81 10 af 00
	00		 cmp	 DWORD PTR [rcx+44816], eax
  00eeb	75 1d		 jne	 SHORT $LN94@z900_abort

; 1217 :                 STRLCPY( who, "ourself" );

  00eed	41 b8 10 00 00
	00		 mov	 r8d, 16
  00ef3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193624
  00efa	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR who$14[rsp]
  00f02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00f08	eb 53		 jmp	 SHORT $LN95@z900_abort
$LN94@z900_abort:

; 1218 :             else
; 1219 :                 MSGBUF( who, "%s%02X", PTYPSTR( regs->txf_who ), regs->txf_who );

  00f0a	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f12	48 63 80 10 af
	00 00		 movsxd	 rax, DWORD PTR [rax+44816]
  00f19	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00f20	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  00f28	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00f2e	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f36	8b 89 10 af 00
	00		 mov	 ecx, DWORD PTR [rcx+44816]
  00f3c	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00f40	4c 8b c8	 mov	 r9, rax
  00f43	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193625
  00f4a	ba 10 00 00 00	 mov	 edx, 16
  00f4f	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR who$14[rsp]
  00f57	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN95@z900_abort:
$LN93@z900_abort:

; 1220 : 
; 1221 :             if (MLVL( VERBOSE ))

  00f5d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f64	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00f6a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00f6f	85 c0		 test	 eax, eax
  00f71	0f 84 1c 01 00
	00		 je	 $LN96@z900_abort

; 1222 :             {
; 1223 :                 // "TXF: %s%02X: %sAbort set by %s at %s"
; 1224 :                 WRMSG( HHC17720, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),

  00f77	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f7f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00f85	d1 e8		 shr	 eax, 1
  00f87	83 e0 01	 and	 eax, 1
  00f8a	85 c0		 test	 eax, eax
  00f8c	74 11		 je	 SHORT $LN199@z900_abort
  00f8e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193627
  00f95	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv529[rsp], rax
  00f9d	eb 0f		 jmp	 SHORT $LN200@z900_abort
$LN199@z900_abort:
  00f9f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193628
  00fa6	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv529[rsp], rax
$LN200@z900_abort:
  00fae	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fb6	48 8b 88 18 af
	00 00		 mov	 rcx, QWORD PTR [rax+44824]
  00fbd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trimloc
  00fc3	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv520[rsp], rax
  00fcb	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fd3	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00fda	89 8c 24 30 01
	00 00		 mov	 DWORD PTR tv532[rsp], ecx
  00fe1	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00fe9	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  00ff0	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00ff7	0f b6 8c 17 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdi+rdx+2888]
  00fff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01005	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR tv534[rsp], rax
  0100d	b9 01 00 00 00	 mov	 ecx, 1
  01012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01018	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR tv520[rsp]
  01020	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01025	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR who$14[rsp]
  0102d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01032	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv529[rsp]
  0103a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0103f	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR tv532[rsp]
  01046	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0104a	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR tv534[rsp]
  01052	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193629
  0105e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193630
  0106a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0106f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01074	41 b9 03 00 00
	00		 mov	 r9d, 3
  0107a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193631
  01081	ba c9 04 00 00	 mov	 edx, 1225		; 000004c9H
  01086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193632
  0108d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN96@z900_abort:
$LN91@z900_abort:

; 1225 :                     who, TRIMLOC( regs->txf_loc ));
; 1226 :             }
; 1227 :         }
; 1228 : 
; 1229 :         /* Print page map if requested */
; 1230 :         if (TXF_TRACE_MAP( regs, txf_contran ))

  01093	33 c0		 xor	 eax, eax
  01095	83 f8 01	 cmp	 eax, 1
  01098	0f 84 e5 05 00
	00		 je	 $LN97@z900_abort
  0109e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  010a5	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  010ab	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  010b0	85 c0		 test	 eax, eax
  010b2	0f 84 cb 05 00
	00		 je	 $LN97@z900_abort
  010b8	33 c0		 xor	 eax, eax
  010ba	83 f8 01	 cmp	 eax, 1
  010bd	0f 84 c0 05 00
	00		 je	 $LN97@z900_abort
  010c3	33 c0		 xor	 eax, eax
  010c5	85 c0		 test	 eax, eax
  010c7	75 37		 jne	 SHORT $LN98@z900_abort
  010c9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  010d0	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  010d6	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  010db	85 c0		 test	 eax, eax
  010dd	74 21		 je	 SHORT $LN98@z900_abort
  010df	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  010ee	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  010f4	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  010fa	0f 85 83 05 00
	00		 jne	 $LN97@z900_abort
$LN98@z900_abort:
  01100	33 c0		 xor	 eax, eax
  01102	85 c0		 test	 eax, eax
  01104	75 37		 jne	 SHORT $LN99@z900_abort
  01106	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0110d	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01113	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  01118	85 c0		 test	 eax, eax
  0111a	74 21		 je	 SHORT $LN99@z900_abort
  0111c	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01124	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0112b	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  01131	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  01137	0f 8c 46 05 00
	00		 jl	 $LN97@z900_abort
$LN99@z900_abort:
  0113d	33 c0		 xor	 eax, eax
  0113f	85 c0		 test	 eax, eax
  01141	75 65		 jne	 SHORT $LN100@z900_abort
  01143	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0114a	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01150	25 00 00 00 0c	 and	 eax, 201326592		; 0c000000H
  01155	3d 00 00 00 0c	 cmp	 eax, 201326592		; 0c000000H
  0115a	74 4c		 je	 SHORT $LN100@z900_abort
  0115c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01163	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01169	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0116e	85 c0		 test	 eax, eax
  01170	74 0c		 je	 SHORT $LN101@z900_abort
  01172	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  0117a	85 c0		 test	 eax, eax
  0117c	75 2a		 jne	 SHORT $LN100@z900_abort
$LN101@z900_abort:
  0117e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01185	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0118b	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  01190	85 c0		 test	 eax, eax
  01192	0f 84 eb 04 00
	00		 je	 $LN97@z900_abort
  01198	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  011a0	85 c0		 test	 eax, eax
  011a2	0f 85 db 04 00
	00		 jne	 $LN97@z900_abort
$LN100@z900_abort:

; 1231 :         {
; 1232 :             TPAGEMAP*  pmap;
; 1233 :             BYTE*      mainaddr;
; 1234 :             BYTE*      altaddr;
; 1235 :             int        i, j;
; 1236 : 
; 1237 :             pmap = regs->txf_pagesmap;

  011a8	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011b0	48 05 80 0e 00
	00		 add	 rax, 3712		; 00000e80H
  011b6	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pmap$4[rsp], rax

; 1238 : 
; 1239 :             for (i=0; i < regs->txf_pgcnt; i++, pmap++)

  011be	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$5[rsp], 0
  011c9	eb 24		 jmp	 SHORT $LN22@z900_abort
$LN20@z900_abort:
  011cb	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR i$5[rsp]
  011d2	ff c0		 inc	 eax
  011d4	89 84 24 b0 00
	00 00		 mov	 DWORD PTR i$5[rsp], eax
  011db	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pmap$4[rsp]
  011e3	48 83 c0 28	 add	 rax, 40			; 00000028H
  011e7	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pmap$4[rsp], rax
$LN22@z900_abort:
  011ef	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011f7	8b 80 80 ae 00
	00		 mov	 eax, DWORD PTR [rax+44672]
  011fd	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR i$5[rsp], eax
  01204	0f 8d 79 04 00
	00		 jge	 $LN21@z900_abort

; 1240 :             {
; 1241 :                 if (TXF_TRACE_PAGES( regs, txf_contran ))

  0120a	33 c0		 xor	 eax, eax
  0120c	83 f8 01	 cmp	 eax, 1
  0120f	0f 84 43 02 00
	00		 je	 $LN102@z900_abort
  01215	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0121c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01222	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01227	85 c0		 test	 eax, eax
  01229	0f 84 29 02 00
	00		 je	 $LN102@z900_abort
  0122f	33 c0		 xor	 eax, eax
  01231	83 f8 01	 cmp	 eax, 1
  01234	0f 84 1e 02 00
	00		 je	 $LN102@z900_abort
  0123a	33 c0		 xor	 eax, eax
  0123c	85 c0		 test	 eax, eax
  0123e	75 37		 jne	 SHORT $LN103@z900_abort
  01240	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01247	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0124d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  01252	85 c0		 test	 eax, eax
  01254	74 21		 je	 SHORT $LN103@z900_abort
  01256	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0125e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01265	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  0126b	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  01271	0f 85 e1 01 00
	00		 jne	 $LN102@z900_abort
$LN103@z900_abort:
  01277	33 c0		 xor	 eax, eax
  01279	85 c0		 test	 eax, eax
  0127b	75 37		 jne	 SHORT $LN104@z900_abort
  0127d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01284	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0128a	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0128f	85 c0		 test	 eax, eax
  01291	74 21		 je	 SHORT $LN104@z900_abort
  01293	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0129b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  012a2	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  012a8	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  012ae	0f 8c a4 01 00
	00		 jl	 $LN102@z900_abort
$LN104@z900_abort:
  012b4	33 c0		 xor	 eax, eax
  012b6	85 c0		 test	 eax, eax
  012b8	75 65		 jne	 SHORT $LN105@z900_abort
  012ba	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012c1	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  012c7	25 00 00 00 0c	 and	 eax, 201326592		; 0c000000H
  012cc	3d 00 00 00 0c	 cmp	 eax, 201326592		; 0c000000H
  012d1	74 4c		 je	 SHORT $LN105@z900_abort
  012d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012da	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  012e0	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  012e5	85 c0		 test	 eax, eax
  012e7	74 0c		 je	 SHORT $LN106@z900_abort
  012e9	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  012f1	85 c0		 test	 eax, eax
  012f3	75 2a		 jne	 SHORT $LN105@z900_abort
$LN106@z900_abort:
  012f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012fc	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01302	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  01307	85 c0		 test	 eax, eax
  01309	0f 84 49 01 00
	00		 je	 $LN102@z900_abort
  0130f	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  01317	85 c0		 test	 eax, eax
  01319	0f 85 39 01 00
	00		 jne	 $LN102@z900_abort
$LN105@z900_abort:

; 1242 :                 {
; 1243 :                     // "TXF: %s%02X: %svirt 0x%16.16"PRIX64", abs 0x%16.16"PRIX64", alt 0x%16.16"PRIX64
; 1244 :                     WRMSG( HHC17704, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),

  0131f	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01327	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0132d	d1 e8		 shr	 eax, 1
  0132f	83 e0 01	 and	 eax, 1
  01332	85 c0		 test	 eax, eax
  01334	74 11		 je	 SHORT $LN201@z900_abort
  01336	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193643
  0133d	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv666[rsp], rax
  01345	eb 0f		 jmp	 SHORT $LN202@z900_abort
$LN201@z900_abort:
  01347	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193644
  0134e	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv666[rsp], rax
$LN202@z900_abort:
  01356	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pmap$4[rsp]
  0135e	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01366	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0136d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  01371	48 2b c1	 sub	 rax, rcx
  01374	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR tv658[rsp], rax
  0137c	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01384	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0138b	89 8c 24 34 01
	00 00		 mov	 DWORD PTR tv669[rsp], ecx
  01392	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0139a	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  013a1	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  013a8	0f b6 8c 17 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdi+rdx+2888]
  013b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  013b6	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR tv671[rsp], rax
  013be	b9 01 00 00 00	 mov	 ecx, 1
  013c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013c9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pmap$4[rsp]
  013d1	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  013d5	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  013da	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR tv658[rsp]
  013e2	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  013e7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pmap$4[rsp]
  013ef	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  013f2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  013f7	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv666[rsp]
  013ff	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01404	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR tv669[rsp]
  0140b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0140f	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR tv671[rsp]
  01417	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0141c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193645
  01423	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01428	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193646
  0142f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01434	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01439	41 b9 03 00 00
	00		 mov	 r9d, 3
  0143f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193647
  01446	ba df 04 00 00	 mov	 edx, 1247		; 000004dfH
  0144b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193648
  01452	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN102@z900_abort:

; 1245 :                         (U64) pmap->virtpageaddr,
; 1246 :                         (U64)(pmap->mainpageaddr - regs->mainstor),
; 1247 :                         (U64) pmap->altpageaddr );
; 1248 :                 }
; 1249 : 
; 1250 :                 if (TXF_TRACE_LINES( regs, txf_contran ))

  01458	33 c0		 xor	 eax, eax
  0145a	83 f8 01	 cmp	 eax, 1
  0145d	0f 84 1b 02 00
	00		 je	 $LN107@z900_abort
  01463	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0146a	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01470	83 e0 40	 and	 eax, 64			; 00000040H
  01473	85 c0		 test	 eax, eax
  01475	0f 84 03 02 00
	00		 je	 $LN107@z900_abort
  0147b	33 c0		 xor	 eax, eax
  0147d	83 f8 01	 cmp	 eax, 1
  01480	0f 84 f8 01 00
	00		 je	 $LN107@z900_abort
  01486	33 c0		 xor	 eax, eax
  01488	85 c0		 test	 eax, eax
  0148a	75 37		 jne	 SHORT $LN108@z900_abort
  0148c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01493	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01499	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0149e	85 c0		 test	 eax, eax
  014a0	74 21		 je	 SHORT $LN108@z900_abort
  014a2	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  014aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  014b1	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  014b7	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  014bd	0f 85 bb 01 00
	00		 jne	 $LN107@z900_abort
$LN108@z900_abort:
  014c3	33 c0		 xor	 eax, eax
  014c5	85 c0		 test	 eax, eax
  014c7	75 37		 jne	 SHORT $LN109@z900_abort
  014c9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  014d0	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  014d6	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  014db	85 c0		 test	 eax, eax
  014dd	74 21		 je	 SHORT $LN109@z900_abort
  014df	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  014e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  014ee	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  014f4	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  014fa	0f 8c 7e 01 00
	00		 jl	 $LN107@z900_abort
$LN109@z900_abort:
  01500	33 c0		 xor	 eax, eax
  01502	85 c0		 test	 eax, eax
  01504	75 65		 jne	 SHORT $LN110@z900_abort
  01506	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0150d	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01513	25 00 00 00 0c	 and	 eax, 201326592		; 0c000000H
  01518	3d 00 00 00 0c	 cmp	 eax, 201326592		; 0c000000H
  0151d	74 4c		 je	 SHORT $LN110@z900_abort
  0151f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01526	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0152c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  01531	85 c0		 test	 eax, eax
  01533	74 0c		 je	 SHORT $LN111@z900_abort
  01535	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  0153d	85 c0		 test	 eax, eax
  0153f	75 2a		 jne	 SHORT $LN110@z900_abort
$LN111@z900_abort:
  01541	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01548	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0154e	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  01553	85 c0		 test	 eax, eax
  01555	0f 84 23 01 00
	00		 je	 $LN107@z900_abort
  0155b	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  01563	85 c0		 test	 eax, eax
  01565	0f 85 13 01 00
	00		 jne	 $LN107@z900_abort
$LN110@z900_abort:

; 1251 :                 {
; 1252 :                     for (j=0; j < ZCACHE_LINE_PAGE; j++)

  0156b	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$1[rsp], 0
  01576	eb 10		 jmp	 SHORT $LN25@z900_abort
$LN23@z900_abort:
  01578	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR j$1[rsp]
  0157f	ff c0		 inc	 eax
  01581	89 84 24 8c 00
	00 00		 mov	 DWORD PTR j$1[rsp], eax
$LN25@z900_abort:
  01588	83 bc 24 8c 00
	00 00 10	 cmp	 DWORD PTR j$1[rsp], 16
  01590	0f 8d e8 00 00
	00		 jge	 $LN24@z900_abort

; 1253 :                     {
; 1254 :                         if (pmap->cachemap[j] == CM_CLEAN)

  01596	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$1[rsp]
  0159e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pmap$4[rsp]
  015a6	0f b6 44 01 18	 movzx	 eax, BYTE PTR [rcx+rax+24]
  015ab	85 c0		 test	 eax, eax
  015ad	75 02		 jne	 SHORT $LN112@z900_abort

; 1255 :                             continue;

  015af	eb c7		 jmp	 SHORT $LN23@z900_abort
$LN112@z900_abort:

; 1256 : 
; 1257 :                         mainaddr = pmap->mainpageaddr + (j << ZCACHE_LINE_SHIFT);

  015b1	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR j$1[rsp]
  015b8	c1 e0 08	 shl	 eax, 8
  015bb	48 98		 cdqe
  015bd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pmap$4[rsp]
  015c5	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  015c9	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR mainaddr$13[rsp], rax

; 1258 :                         altaddr  = pmap->altpageaddr  + (j << ZCACHE_LINE_SHIFT);

  015d1	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR j$1[rsp]
  015d8	c1 e0 08	 shl	 eax, 8
  015db	48 98		 cdqe
  015dd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pmap$4[rsp]
  015e5	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  015e9	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR altaddr$10[rsp], rax

; 1259 : 
; 1260 :                         // "TXF: %s%02X: %sThere now:  +"
; 1261 :                         dump_cache( regs, TXF_DUMP_PFX( HHC17705 ), j, mainaddr );

  015f1	4c 8b 8c 24 f0
	01 00 00	 mov	 r9, QWORD PTR mainaddr$13[rsp]
  015f9	44 8b 84 24 8c
	00 00 00	 mov	 r8d, DWORD PTR j$1[rsp]
  01601	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193655
  01608	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01610	e8 00 00 00 00	 call	 dump_cache

; 1262 : 
; 1263 :                         if (pmap->cachemap[j] == CM_FETCHED)

  01615	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$1[rsp]
  0161d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pmap$4[rsp]
  01625	0f b6 44 01 18	 movzx	 eax, BYTE PTR [rcx+rax+24]
  0162a	83 f8 01	 cmp	 eax, 1
  0162d	75 26		 jne	 SHORT $LN113@z900_abort

; 1264 :                             // "TXF: %s%02X: %sWe fetched: +"
; 1265 :                             dump_cache( regs, TXF_DUMP_PFX( HHC17706 ), j, altaddr );

  0162f	4c 8b 8c 24 78
	01 00 00	 mov	 r9, QWORD PTR altaddr$10[rsp]
  01637	44 8b 84 24 8c
	00 00 00	 mov	 r8d, DWORD PTR j$1[rsp]
  0163f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193658
  01646	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0164e	e8 00 00 00 00	 call	 dump_cache
  01653	eb 24		 jmp	 SHORT $LN114@z900_abort
$LN113@z900_abort:

; 1266 :                         else
; 1267 :                             // "TXF: %s%02X: %sWe stored:  +"
; 1268 :                             dump_cache( regs, TXF_DUMP_PFX( HHC17707 ), j, altaddr );

  01655	4c 8b 8c 24 78
	01 00 00	 mov	 r9, QWORD PTR altaddr$10[rsp]
  0165d	44 8b 84 24 8c
	00 00 00	 mov	 r8d, DWORD PTR j$1[rsp]
  01665	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193659
  0166c	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01674	e8 00 00 00 00	 call	 dump_cache
$LN114@z900_abort:

; 1269 :                     }

  01679	e9 fa fe ff ff	 jmp	 $LN23@z900_abort
$LN24@z900_abort:
$LN107@z900_abort:

; 1270 :                 }
; 1271 :             }

  0167e	e9 48 fb ff ff	 jmp	 $LN20@z900_abort
$LN21@z900_abort:
$LN97@z900_abort:
$LN80@z900_abort:

; 1272 :         }
; 1273 :     }
; 1274 : 
; 1275 :     /*---------------------------------------------*/
; 1276 :     /*  Clean up the transaction flags             */
; 1277 :     /*---------------------------------------------*/
; 1278 : 
; 1279 :     regs->txf_NTSTG     = false;

  01683	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0168b	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 1280 :     regs->txf_contran   = false;

  01692	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0169a	c6 80 4c 0e 00
	00 00		 mov	 BYTE PTR [rax+3660], 0

; 1281 :     regs->txf_tac       = 0;

  016a1	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  016a9	c7 80 08 af 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+44808], 0

; 1282 :     regs->txf_abortctr  = 0;

  016b3	33 c0		 xor	 eax, eax
  016b5	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  016bd	66 89 81 60 0e
	00 00		 mov	 WORD PTR [rcx+3680], ax

; 1283 :     regs->txf_instctr   = 0;

  016c4	33 c0		 xor	 eax, eax
  016c6	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  016ce	66 89 81 5e 0e
	00 00		 mov	 WORD PTR [rcx+3678], ax

; 1284 :     regs->txf_pgcnt     = 0;

  016d5	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  016dd	c7 80 80 ae 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+44672], 0

; 1285 :     regs->txf_conflict  = 0;

  016e7	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  016ef	48 c7 80 78 0e
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+3704], 0

; 1286 :     regs->txf_piid      = 0;

  016fa	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01702	c7 80 7c af 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+44924], 0

; 1287 : 
; 1288 :     /*---------------------------------------------*/
; 1289 :     /*  Reset transaction nesting depth            */
; 1290 :     /*---------------------------------------------*/
; 1291 :     OBTAIN_TXFLOCK( regs );

  0170c	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01714	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0171b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01722	48 8d 84 c1 48
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+840]
  0172a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193660
  01731	48 8b c8	 mov	 rcx, rax
  01734	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1292 :     {
; 1293 :         regs->txf_tnd = 0;

  0173a	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01742	c6 80 58 0e 00
	00 00		 mov	 BYTE PTR [rax+3672], 0

; 1294 :     }
; 1295 :     RELEASE_TXFLOCK( regs );

  01749	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01751	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01758	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0175f	48 8d 84 c1 48
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+840]
  01767	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193661
  0176e	48 8b c8	 mov	 rcx, rax
  01771	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1296 : 
; 1297 :     /* Reset CONSTRAINED trans instruction fetch constraint */
; 1298 :     ARCH_DEP( reset_txf_aie )( regs );

  01777	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0177f	e8 00 00 00 00	 call	 z900_reset_txf_aie

; 1299 : 
; 1300 :     /*-----------------------------------------------------*/
; 1301 :     /*    Trace program interrupt BEFORE updating PSW      */
; 1302 :     /*-----------------------------------------------------*/
; 1303 :     /*  If the retry code is ABORT_RETRY_PGMCHK, then we   */
; 1304 :     /*  will eventually be calling the program_interrupt   */
; 1305 :     /*  function for PGM_TRANSACTION_CONSTRAINT_EXCEPTION  */
; 1306 :     /*  so we MUST trace the program interrupt here. We    */
; 1307 :     /*  CANNOT let the program_interrupt function do that  */
; 1308 :     /*  for us like it normally does since it would report */
; 1309 :     /*  the wrong PSW. Thus we MUST do it ourselves here.  */
; 1310 :     /*-----------------------------------------------------*/
; 1311 : 
; 1312 :     if (retry == ABORT_RETRY_PGMCHK)

  01784	83 bc 24 9c 00
	00 00 02	 cmp	 DWORD PTR retry$[rsp], 2
  0178c	0f 85 09 02 00
	00		 jne	 $LN115@z900_abort

; 1313 :     {
; 1314 :         int pcode, ilc;
; 1315 : 
; 1316 :         pcode = PGM_TRANSACTION_CONSTRAINT_EXCEPTION | PGM_TXF_EVENT;

  01792	c7 84 24 b4 00
	00 00 18 02 00
	00		 mov	 DWORD PTR pcode$6[rsp], 536 ; 00000218H

; 1317 : 
; 1318 :         if (raw_retry == -ABORT_RETRY_PGMCHK) // (negative?)

  0179d	83 bc 24 58 03
	00 00 fe	 cmp	 DWORD PTR raw_retry$[rsp], -2
  017a5	0f 85 34 01 00
	00		 jne	 $LN116@z900_abort

; 1319 :         {
; 1320 :             /* Instruction dispatch program interrupt: since the
; 1321 :                instruction has not been decoded yet (and the PSW
; 1322 :                and 'ip' pointer bumped appropriately (instead,
; 1323 :                it is pointing directly AT the failing instruction
; 1324 :                and not past it like normal)), we must bump the ip
; 1325 :                past the instruction that program checked so that
; 1326 :                the 'trace_program_interrupt' function can then
; 1327 :                back it up to point to the correct instruction.
; 1328 :             */
; 1329 :             ilc = ILC( *regs->ip );

  017ab	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  017b3	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  017b7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  017ba	83 f8 40	 cmp	 eax, 64			; 00000040H
  017bd	7d 0d		 jge	 SHORT $LN205@z900_abort
  017bf	c7 84 24 ec 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv790[rsp], 2
  017ca	eb 3c		 jmp	 SHORT $LN206@z900_abort
$LN205@z900_abort:
  017cc	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  017d4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  017d8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  017db	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  017e0	7d 0d		 jge	 SHORT $LN203@z900_abort
  017e2	c7 84 24 e8 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv789[rsp], 4
  017ed	eb 0b		 jmp	 SHORT $LN204@z900_abort
$LN203@z900_abort:
  017ef	c7 84 24 e8 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv789[rsp], 6
$LN204@z900_abort:
  017fa	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR tv789[rsp]
  01801	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv790[rsp], eax
$LN206@z900_abort:
  01808	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR tv790[rsp]
  0180f	89 84 24 90 00
	00 00		 mov	 DWORD PTR ilc$2[rsp], eax

; 1330 :             regs->ip += ilc;

  01816	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ilc$2[rsp]
  0181e	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01826	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  0182a	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01832	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN28@z900_abort:

; 1331 :             {
; 1332 :                 PTT_TXF( "TXF trpi+ilc", regs->ip, ilc, 0 );

  01836	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0183d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01840	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  01846	48 85 c0	 test	 rax, rax
  01849	74 47		 je	 SHORT $LN118@z900_abort
  0184b	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ilc$2[rsp]
  01853	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0185c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01865	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193666
  0186c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01871	4c 8b c8	 mov	 r9, rax
  01874	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0187c	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  01880	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193667
  01887	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0188c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN118@z900_abort:
  01892	33 c0		 xor	 eax, eax
  01894	85 c0		 test	 eax, eax
  01896	75 9e		 jne	 SHORT $LN28@z900_abort

; 1333 :                 ARCH_DEP( trace_program_interrupt )( regs, pcode, ilc );

  01898	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR ilc$2[rsp]
  018a0	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR pcode$6[rsp]
  018a7	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  018af	e8 00 00 00 00	 call	 z900_trace_program_interrupt

; 1334 :             }
; 1335 :             regs->ip -= ilc;

  018b4	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ilc$2[rsp]
  018bc	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  018c4	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  018c8	48 2b c8	 sub	 rcx, rax
  018cb	48 8b c1	 mov	 rax, rcx
  018ce	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  018d6	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 1336 :         }

  018da	e9 92 00 00 00	 jmp	 $LN117@z900_abort
$LN116@z900_abort:

; 1337 :         else /* Normal program interrupt after instruction decode */
; 1338 :         {
; 1339 :             /* Fix PSW and get instruction length (ilc) */
; 1340 :             ilc = ARCH_DEP( fix_program_interrupt_PSW )( regs );

  018df	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  018e7	e8 00 00 00 00	 call	 z900_fix_program_interrupt_PSW
  018ec	89 84 24 90 00
	00 00		 mov	 DWORD PTR ilc$2[rsp], eax
$LN31@z900_abort:

; 1341 : 
; 1342 :             /* Trace program checks other than PER event */
; 1343 :             PTT_TXF( "TXF trpi", regs->ip, ilc, 0 );

  018f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  018fa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  018fd	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  01903	48 85 c0	 test	 rax, rax
  01906	74 47		 je	 SHORT $LN119@z900_abort
  01908	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR ilc$2[rsp]
  01910	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01919	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01922	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193669
  01929	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0192e	4c 8b c8	 mov	 r9, rax
  01931	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01939	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  0193d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193670
  01944	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  01949	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN119@z900_abort:
  0194f	33 c0		 xor	 eax, eax
  01951	85 c0		 test	 eax, eax
  01953	75 9e		 jne	 SHORT $LN31@z900_abort

; 1344 :             ARCH_DEP( trace_program_interrupt )( regs, pcode, ilc );

  01955	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR ilc$2[rsp]
  0195d	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR pcode$6[rsp]
  01964	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0196c	e8 00 00 00 00	 call	 z900_trace_program_interrupt
$LN117@z900_abort:

; 1345 :         }
; 1346 : 
; 1347 :         /* Save the program interrupt id */
; 1348 :         txf_piid   = pcode;

  01971	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR pcode$6[rsp]
  01978	89 84 24 94 00
	00 00		 mov	 DWORD PTR txf_piid$[rsp], eax

; 1349 :         txf_piid  |= (ilc << 16);

  0197f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR ilc$2[rsp]
  01986	c1 e0 10	 shl	 eax, 16
  01989	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR txf_piid$[rsp]
  01990	0b c8		 or	 ecx, eax
  01992	8b c1		 mov	 eax, ecx
  01994	89 84 24 94 00
	00 00		 mov	 DWORD PTR txf_piid$[rsp], eax
$LN115@z900_abort:
$LN34@z900_abort:

; 1350 :     }
; 1351 : 
; 1352 :     /*----------------------------------------------------*/
; 1353 :     /*  Set the current PSW to the Transaction Abort PSW  */
; 1354 :     /*----------------------------------------------------*/
; 1355 : 
; 1356 :     /* PROGRAMMING NOTE: it's CRITICAL to invalidate the aia BEFORE
; 1357 :        setting the current PSW to the Transaction Abort PSW, since
; 1358 :        INVALIDATE_AIA *might* update the PSW's instruction address
; 1359 :        to a value different from what txf_tapsw says it should be!
; 1360 :     */
; 1361 :     INVALIDATE_AIA( regs ); // (do *before* PSW memcpy!)

  0199b	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019a3	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  019ab	74 64		 je	 SHORT $LN120@z900_abort
  019ad	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019b5	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  019bd	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  019c4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  019c8	48 2b c1	 sub	 rax, rcx
  019cb	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  019d3	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  019da	48 03 c8	 add	 rcx, rax
  019dd	48 8b c1	 mov	 rax, rcx
  019e0	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  019e8	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  019ef	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  019f7	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  019fe	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a06	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN120@z900_abort:
  01a11	33 c0		 xor	 eax, eax
  01a13	85 c0		 test	 eax, eax
  01a15	75 84		 jne	 SHORT $LN34@z900_abort

; 1362 :     memcpy( &regs->psw, &regs->txf_tapsw, sizeof( PSW ));

  01a17	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a1f	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01a27	48 8d 78 78	 lea	 rdi, QWORD PTR [rax+120]
  01a2b	48 8d b1 20 af
	00 00		 lea	 rsi, QWORD PTR [rcx+44832]
  01a32	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  01a37	f3 a4		 rep movsb

; 1363 :     regs->ip  = regs->txf_ip;

  01a39	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a41	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01a49	48 8b 89 48 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44872]
  01a50	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 1364 :     regs->aip = regs->txf_aip;

  01a54	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a5c	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01a64	48 8b 89 50 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44880]
  01a6b	48 89 88 00 02
	00 00		 mov	 QWORD PTR [rax+512], rcx

; 1365 :     regs->aiv = regs->txf_aiv;

  01a72	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a7a	48 8b 80 58 af
	00 00		 mov	 rax, QWORD PTR [rax+44888]
  01a81	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01a89	48 89 81 10 02
	00 00		 mov	 QWORD PTR [rcx+528], rax

; 1366 : 
; 1367 :     /*---------------------------------------------*/
; 1368 :     /*     Set the condition code in the PSW       */
; 1369 :     /*---------------------------------------------*/
; 1370 : 
; 1371 :     if (txf_tac && txf_tac < (int) _countof( tac2cc ))

  01a90	83 bc 24 60 03
	00 00 00	 cmp	 DWORD PTR txf_tac$[rsp], 0
  01a98	74 2a		 je	 SHORT $LN121@z900_abort
  01a9a	83 bc 24 60 03
	00 00 14	 cmp	 DWORD PTR txf_tac$[rsp], 20
  01aa2	7d 20		 jge	 SHORT $LN121@z900_abort

; 1372 :                                     regs->psw.cc = tac2cc[ txf_tac ];

  01aa4	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR txf_tac$[rsp]
  01aac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tac2cc
  01ab3	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01abb	0f b6 04 81	 movzx	 eax, BYTE PTR [rcx+rax*4]
  01abf	88 42 7c	 mov	 BYTE PTR [rdx+124], al
  01ac2	eb 34		 jmp	 SHORT $LN122@z900_abort
$LN121@z900_abort:

; 1373 :     else if (txf_tac == TAC_MISC)   regs->psw.cc = TXF_CC_TRANSIENT;

  01ac4	81 bc 24 60 03
	00 00 ff 00 00
	00		 cmp	 DWORD PTR txf_tac$[rsp], 255 ; 000000ffH
  01acf	75 0e		 jne	 SHORT $LN123@z900_abort
  01ad1	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ad9	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2
  01add	eb 19		 jmp	 SHORT $LN124@z900_abort
$LN123@z900_abort:

; 1374 :     else if (txf_tac >= TAC_TABORT) regs->psw.cc = TXF_CC_INDETERMINATE;

  01adf	81 bc 24 60 03
	00 00 00 01 00
	00		 cmp	 DWORD PTR txf_tac$[rsp], 256 ; 00000100H
  01aea	7c 0c		 jl	 SHORT $LN125@z900_abort
  01aec	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01af4	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1
$LN125@z900_abort:
$LN124@z900_abort:
$LN122@z900_abort:

; 1375 : 
; 1376 :     /*---------------------------------------------*/
; 1377 :     /*      Put data/vector exception code         */
; 1378 :     /*    into byte 2 of FPCR if appropriate.      */
; 1379 :     /*---------------------------------------------*/
; 1380 : 
; 1381 :     if (1
; 1382 :         && (txf_piid & 0xFF) == PGM_DATA_EXCEPTION
; 1383 :         && regs->txf_ctlflag & TXF_CTL_FLOAT
; 1384 :         && regs->CR(0) & CR0_AFP

  01af8	33 c0		 xor	 eax, eax
  01afa	83 f8 01	 cmp	 eax, 1
  01afd	0f 84 a2 00 00
	00		 je	 $LN126@z900_abort
  01b03	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR txf_piid$[rsp]
  01b0a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01b0f	83 f8 07	 cmp	 eax, 7
  01b12	0f 85 8d 00 00
	00		 jne	 $LN126@z900_abort
  01b18	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b20	0f b6 80 59 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3673]
  01b27	83 e0 04	 and	 eax, 4
  01b2a	85 c0		 test	 eax, eax
  01b2c	74 77		 je	 SHORT $LN126@z900_abort
  01b2e	b8 08 00 00 00	 mov	 eax, 8
  01b33	48 6b c0 01	 imul	 rax, rax, 1
  01b37	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b3f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  01b47	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  01b4d	48 85 c0	 test	 rax, rax
  01b50	74 53		 je	 SHORT $LN126@z900_abort

; 1385 :     )
; 1386 :     {
; 1387 :         regs->fpc &= ~((U32) 0xFF              << 8);

  01b52	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b5a	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  01b60	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  01b65	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b6d	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1388 :         regs->fpc |=  ((U32) regs->txf_dxc_vxc << 8);

  01b73	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b7b	0f b6 80 80 af
	00 00		 movzx	 eax, BYTE PTR [rax+44928]
  01b82	c1 e0 08	 shl	 eax, 8
  01b85	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b8d	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  01b93	0b c8		 or	 ecx, eax
  01b95	8b c1		 mov	 eax, ecx
  01b97	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b9f	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN126@z900_abort:

; 1389 :     }
; 1390 : 
; 1391 :     /*------------------------------------------------*/
; 1392 :     /*               Populate TDBs                    */
; 1393 :     /*------------------------------------------------*/
; 1394 :     /*  Populate the TDBs. For program-interrupts,    */
; 1395 :     /*  the TDB is at fixed storage location 0x1800   */
; 1396 :     /*  in low core.  Additionally, the address of    */
; 1397 :     /*  a second TDB may be specified by the TBEGIN   */
; 1398 :     /*  instruction itself. (The operand-1 address    */
; 1399 :     /*  for TBEGINC is ignored.)                      */
; 1400 :     /*------------------------------------------------*/
; 1401 : 
; 1402 :     /* CONSTRAINED transaction or Program Interrupt?  */
; 1403 :     if (0
; 1404 :         || txf_contran          /* CONSTRAINED trans? */
; 1405 :         || txf_tac == TAC_UPGM  /* Unfiltered PGM?    */
; 1406 :         || txf_tac == TAC_FPGM  /* Filtered   PGM?    */

  01ba5	33 c0		 xor	 eax, eax
  01ba7	85 c0		 test	 eax, eax
  01ba9	75 24		 jne	 SHORT $LN128@z900_abort
  01bab	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  01bb3	85 c0		 test	 eax, eax
  01bb5	75 18		 jne	 SHORT $LN128@z900_abort
  01bb7	83 bc 24 60 03
	00 00 04	 cmp	 DWORD PTR txf_tac$[rsp], 4
  01bbf	74 0e		 je	 SHORT $LN128@z900_abort
  01bc1	83 bc 24 60 03
	00 00 0c	 cmp	 DWORD PTR txf_tac$[rsp], 12
  01bc9	0f 85 9e 00 00
	00		 jne	 $LN127@z900_abort
$LN128@z900_abort:

; 1407 :     )
; 1408 :     {
; 1409 :         RADR pi_tdba = 0x1800;

  01bcf	48 c7 84 24 b8
	00 00 00 00 18
	00 00		 mov	 QWORD PTR pi_tdba$7[rsp], 6144 ; 00001800H

; 1410 :         pi_tdba = APPLY_PREFIXING( pi_tdba, regs->PX );

  01bdb	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pi_tdba$7[rsp]
  01be3	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  01be9	48 85 c0	 test	 rax, rax
  01bec	74 2e		 je	 SHORT $LN207@z900_abort
  01bee	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pi_tdba$7[rsp]
  01bf6	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  01bfc	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01c04	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  01c08	74 12		 je	 SHORT $LN207@z900_abort
  01c0a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pi_tdba$7[rsp]
  01c12	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv905[rsp], rax
  01c1a	eb 22		 jmp	 SHORT $LN208@z900_abort
$LN207@z900_abort:
  01c1c	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c24	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  01c28	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pi_tdba$7[rsp]
  01c30	48 33 c8	 xor	 rcx, rax
  01c33	48 8b c1	 mov	 rax, rcx
  01c36	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv905[rsp], rax
$LN208@z900_abort:
  01c3e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR tv905[rsp]
  01c46	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pi_tdba$7[rsp], rax

; 1411 :         pi_tdb = (TDB*)(regs->mainstor + pi_tdba);

  01c4e	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c56	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  01c5d	48 03 84 24 b8
	00 00 00	 add	 rax, QWORD PTR pi_tdba$7[rsp]
  01c65	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR pi_tdb$[rsp], rax
$LN127@z900_abort:

; 1412 :     }
; 1413 : 
; 1414 :     /* TBEGIN-specified TDB? */
; 1415 :     if (!txf_contran && regs->txf_tdba_b1)

  01c6d	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  01c75	85 c0		 test	 eax, eax
  01c77	0f 85 be 02 00
	00		 jne	 $LN129@z900_abort
  01c7d	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c85	83 b8 70 0e 00
	00 00		 cmp	 DWORD PTR [rax+3696], 0
  01c8c	0f 84 a9 02 00
	00		 je	 $LN129@z900_abort

; 1416 :     {
; 1417 :         RADR  real_tdb;
; 1418 :         int   stid;
; 1419 :         int   xcode;
; 1420 : 
; 1421 :         /* Convert TDB address to absolute mainstor address */
; 1422 :         if ((xcode = ARCH_DEP( virt_to_real )( &real_tdb, &stid,
; 1423 :             regs->txf_tdba, regs->txf_tdba_b1, regs, ACCTYPE_WRITE )) == 0)

  01c92	c7 44 24 28 02
	00 00 00	 mov	 DWORD PTR [rsp+40], 2
  01c9a	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ca2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01ca7	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01caf	44 8b 88 70 0e
	00 00		 mov	 r9d, DWORD PTR [rax+3696]
  01cb6	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01cbe	4c 8b 80 68 0e
	00 00		 mov	 r8, QWORD PTR [rax+3688]
  01cc5	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR stid$11[rsp]
  01ccd	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR real_tdb$8[rsp]
  01cd5	e8 00 00 00 00	 call	 z900_virt_to_real
  01cda	89 84 24 a0 00
	00 00		 mov	 DWORD PTR xcode$3[rsp], eax
  01ce1	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR xcode$3[rsp], 0
  01ce9	0f 85 87 00 00
	00		 jne	 $LN130@z900_abort

; 1424 :         {
; 1425 :             tb_tdb = (TDB*)(regs->mainstor + APPLY_PREFIXING( real_tdb, regs->PX ));

  01cef	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR real_tdb$8[rsp]
  01cf7	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  01cfd	48 85 c0	 test	 rax, rax
  01d00	74 2e		 je	 SHORT $LN209@z900_abort
  01d02	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR real_tdb$8[rsp]
  01d0a	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  01d10	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01d18	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  01d1c	74 12		 je	 SHORT $LN209@z900_abort
  01d1e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR real_tdb$8[rsp]
  01d26	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv930[rsp], rax
  01d2e	eb 22		 jmp	 SHORT $LN210@z900_abort
$LN209@z900_abort:
  01d30	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d38	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  01d3c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR real_tdb$8[rsp]
  01d44	48 33 c8	 xor	 rcx, rax
  01d47	48 8b c1	 mov	 rax, rcx
  01d4a	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv930[rsp], rax
$LN210@z900_abort:
  01d52	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d5a	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  01d61	48 03 84 24 88
	01 00 00	 add	 rax, QWORD PTR tv930[rsp]
  01d69	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tb_tdb$[rsp], rax

; 1426 :         }

  01d71	e9 c5 01 00 00	 jmp	 $LN131@z900_abort
$LN130@z900_abort:
$LN37@z900_abort:

; 1427 :         else
; 1428 :         {
; 1429 :             PTT_TXF( "*TXF vrfail", xcode, regs->txf_tdba, regs->txf_tdba_b1 );

  01d76	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01d7d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01d80	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  01d86	48 85 c0	 test	 rax, rax
  01d89	74 55		 je	 SHORT $LN132@z900_abort
  01d8b	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d93	48 63 80 70 0e
	00 00		 movsxd	 rax, DWORD PTR [rax+3696]
  01d9a	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR xcode$3[rsp]
  01da2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01dab	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01db0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193684
  01db7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01dbc	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01dc4	4c 8b 88 68 0e
	00 00		 mov	 r9, QWORD PTR [rax+3688]
  01dcb	4c 8b c1	 mov	 r8, rcx
  01dce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193685
  01dd5	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  01dda	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN132@z900_abort:
  01de0	33 c0		 xor	 eax, eax
  01de2	85 c0		 test	 eax, eax
  01de4	75 90		 jne	 SHORT $LN37@z900_abort

; 1430 : 
; 1431 :             if (TXF_TRACING())

  01de6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01ded	83 b8 4c 05 00
	00 00		 cmp	 DWORD PTR [rax+1356], 0
  01df4	0f 84 35 01 00
	00		 je	 $LN133@z900_abort

; 1432 :             {
; 1433 :                 // "TXF: %s%02X: %sTranslation exception %4.4hX (%s) on TBEGIN tdba 0x%16.16"PRIx64
; 1434 :                 WRMSG( HHC17713, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),

  01dfa	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e02	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01e08	d1 e8		 shr	 eax, 1
  01e0a	83 e0 01	 and	 eax, 1
  01e0d	85 c0		 test	 eax, eax
  01e0f	74 11		 je	 SHORT $LN211@z900_abort
  01e11	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193687
  01e18	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv959[rsp], rax
  01e20	eb 0f		 jmp	 SHORT $LN212@z900_abort
$LN211@z900_abort:
  01e22	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193688
  01e29	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv959[rsp], rax
$LN212@z900_abort:
  01e31	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR xcode$3[rsp]
  01e38	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  01e3e	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR tv950[rsp], rax
  01e46	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR xcode$3[rsp]
  01e4e	89 8c 24 38 01
	00 00		 mov	 DWORD PTR tv953[rsp], ecx
  01e55	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01e5d	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  01e64	89 94 24 20 01
	00 00		 mov	 DWORD PTR tv994[rsp], edx
  01e6b	48 8b bc 24 50
	03 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  01e73	0f b7 bf 3c 08
	00 00		 movzx	 edi, WORD PTR [rdi+2108]
  01e7a	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR __imp_sysblk
  01e81	0f b6 8c 3e 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rsi+rdi+2888]
  01e89	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01e8f	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR tv996[rsp], rax
  01e97	b9 01 00 00 00	 mov	 ecx, 1
  01e9c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01ea2	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01eaa	48 8b 89 68 0e
	00 00		 mov	 rcx, QWORD PTR [rcx+3688]
  01eb1	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  01eb6	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR tv950[rsp]
  01ebe	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01ec3	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR tv953[rsp]
  01eca	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01ece	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR tv959[rsp]
  01ed6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01edb	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv994[rsp]
  01ee2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01ee6	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR tv996[rsp]
  01eee	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01ef3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193689
  01efa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01eff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193690
  01f06	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01f0b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01f10	41 b9 03 00 00
	00		 mov	 r9d, 3
  01f16	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193691
  01f1d	ba 9b 05 00 00	 mov	 edx, 1435		; 0000059bH
  01f22	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193692
  01f29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN133@z900_abort:

; 1435 :                     (U16)xcode, PIC2Name( xcode ), regs->txf_tdba );
; 1436 :             }
; 1437 : 
; 1438 :             /* Transaction Abort processing, Note 4: "If the TDBA is
; 1439 :                valid, but the block has become inaccessible subsequent
; 1440 :                to the execution of the outermost TBEGIN instruction,
; 1441 :                the TDB is not accessed and condition code 1 applies."
; 1442 :             */
; 1443 :             regs->psw.cc = TXF_CC_INDETERMINATE;

  01f2f	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f37	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1
$LN131@z900_abort:
$LN129@z900_abort:

; 1444 :         }
; 1445 :     }
; 1446 : 
; 1447 :     /*--------------------------------------------------*/
; 1448 :     /*             Populate our internal TDB            */
; 1449 :     /*--------------------------------------------------*/
; 1450 :     {
; 1451 :         regs->txf_tdb.tdb_format = 1;

  01f3b	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f43	c6 80 4b 0d 00
	00 01		 mov	 BYTE PTR [rax+3403], 1

; 1452 :         regs->txf_tdb.tdb_eaid   = regs->excarid;

  01f4a	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f52	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f5a	0f b6 89 3e 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2110]
  01f61	88 88 6b 0d 00
	00		 mov	 BYTE PTR [rax+3435], cl

; 1453 :         regs->txf_tdb.tdb_flags  = (txf_contran ? TDB_CTI : 0x00);

  01f67	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  01f6f	85 c0		 test	 eax, eax
  01f71	74 0d		 je	 SHORT $LN213@z900_abort
  01f73	c7 84 24 f0 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv1020[rsp], 64 ; 00000040H
  01f7e	eb 0b		 jmp	 SHORT $LN214@z900_abort
$LN213@z900_abort:
  01f80	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1020[rsp], 0
$LN214@z900_abort:
  01f8b	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f93	0f b6 8c 24 f0
	00 00 00	 movzx	 ecx, BYTE PTR tv1020[rsp]
  01f9b	88 88 4c 0d 00
	00		 mov	 BYTE PTR [rax+3404], cl

; 1454 : 
; 1455 :         if (0
; 1456 :             || txf_tac == TAC_FETCH_CNF
; 1457 :             || txf_tac == TAC_STORE_CNF

  01fa1	33 c0		 xor	 eax, eax
  01fa3	85 c0		 test	 eax, eax
  01fa5	75 14		 jne	 SHORT $LN135@z900_abort
  01fa7	83 bc 24 60 03
	00 00 09	 cmp	 DWORD PTR txf_tac$[rsp], 9
  01faf	74 0a		 je	 SHORT $LN135@z900_abort
  01fb1	83 bc 24 60 03
	00 00 0a	 cmp	 DWORD PTR txf_tac$[rsp], 10
  01fb9	75 47		 jne	 SHORT $LN134@z900_abort
$LN135@z900_abort:

; 1458 :         )
; 1459 :             regs->txf_tdb.tdb_flags |= (txf_conflict ? TDB_CTV : 0x00);

  01fbb	48 83 bc 24 98
	01 00 00 00	 cmp	 QWORD PTR txf_conflict$[rsp], 0
  01fc4	74 0d		 je	 SHORT $LN215@z900_abort
  01fc6	c7 84 24 f4 00
	00 00 80 00 00
	00		 mov	 DWORD PTR tv1027[rsp], 128 ; 00000080H
  01fd1	eb 0b		 jmp	 SHORT $LN216@z900_abort
$LN215@z900_abort:
  01fd3	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1027[rsp], 0
$LN216@z900_abort:
  01fde	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01fe6	0f b6 80 4c 0d
	00 00		 movzx	 eax, BYTE PTR [rax+3404]
  01fed	0b 84 24 f4 00
	00 00		 or	 eax, DWORD PTR tv1027[rsp]
  01ff4	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01ffc	88 81 4c 0d 00
	00		 mov	 BYTE PTR [rcx+3404], al
$LN134@z900_abort:

; 1460 : 
; 1461 :         if (0
; 1462 :             || (txf_piid & 0xFF) == PGM_DATA_EXCEPTION
; 1463 :             || (txf_piid & 0xFF) == PGM_VECTOR_PROCESSING_EXCEPTION

  02002	33 c0		 xor	 eax, eax
  02004	85 c0		 test	 eax, eax
  02006	75 22		 jne	 SHORT $LN137@z900_abort
  02008	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR txf_piid$[rsp]
  0200f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  02014	83 f8 07	 cmp	 eax, 7
  02017	74 11		 je	 SHORT $LN137@z900_abort
  02019	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR txf_piid$[rsp]
  02020	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  02025	83 f8 1b	 cmp	 eax, 27
  02028	75 1d		 jne	 SHORT $LN136@z900_abort
$LN137@z900_abort:

; 1464 :         )
; 1465 :             regs->txf_tdb.tdb_dxc = regs->txf_dxc_vxc;

  0202a	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02032	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0203a	0f b6 89 80 af
	00 00		 movzx	 ecx, BYTE PTR [rcx+44928]
  02041	88 88 6c 0d 00
	00		 mov	 BYTE PTR [rax+3436], cl
$LN136@z900_abort:

; 1466 : 
; 1467 :         STORE_HW( regs->txf_tdb.tdb_tnd,      (U16) txf_tnd      );

  02047	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR txf_tnd$[rsp]
  0204f	e8 00 00 00 00	 call	 _byteswap_ushort
  02054	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0205c	48 81 c1 51 0d
	00 00		 add	 rcx, 3409		; 00000d51H
  02063	0f b7 d0	 movzx	 edx, ax
  02066	e8 00 00 00 00	 call	 store_hw_noswap

; 1468 :         STORE_DW( regs->txf_tdb.tdb_tac,      (U64) txf_tac      );

  0206b	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR txf_tac$[rsp]
  02073	48 8b c8	 mov	 rcx, rax
  02076	e8 00 00 00 00	 call	 _byteswap_uint64
  0207b	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02083	48 81 c1 53 0d
	00 00		 add	 rcx, 3411		; 00000d53H
  0208a	48 8b d0	 mov	 rdx, rax
  0208d	e8 00 00 00 00	 call	 store_dw_noswap

; 1469 :         STORE_DW( regs->txf_tdb.tdb_teid,     (U64) regs->TEA    );

  02092	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0209a	48 8b 88 18 07
	00 00		 mov	 rcx, QWORD PTR [rax+1816]
  020a1	e8 00 00 00 00	 call	 _byteswap_uint64
  020a6	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  020ae	48 81 c1 73 0d
	00 00		 add	 rcx, 3443		; 00000d73H
  020b5	48 8b d0	 mov	 rdx, rax
  020b8	e8 00 00 00 00	 call	 store_dw_noswap

; 1470 :         STORE_FW( regs->txf_tdb.tdb_piid,     (U32) txf_piid     );

  020bd	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR txf_piid$[rsp]
  020c4	e8 00 00 00 00	 call	 _byteswap_ulong
  020c9	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  020d1	48 81 c1 6f 0d
	00 00		 add	 rcx, 3439		; 00000d6fH
  020d8	8b d0		 mov	 edx, eax
  020da	e8 00 00 00 00	 call	 store_fw_noswap

; 1471 :         STORE_DW( regs->txf_tdb.tdb_atia,     (U64) txf_atia     );

  020df	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR txf_atia$[rsp]
  020e7	e8 00 00 00 00	 call	 _byteswap_uint64
  020ec	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  020f4	48 81 c1 63 0d
	00 00		 add	 rcx, 3427		; 00000d63H
  020fb	48 8b d0	 mov	 rdx, rax
  020fe	e8 00 00 00 00	 call	 store_dw_noswap

; 1472 :         STORE_DW( regs->txf_tdb.tdb_conflict, (U64) txf_conflict );

  02103	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR txf_conflict$[rsp]
  0210b	e8 00 00 00 00	 call	 _byteswap_uint64
  02110	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02118	48 81 c1 5b 0d
	00 00		 add	 rcx, 3419		; 00000d5bH
  0211f	48 8b d0	 mov	 rdx, rax
  02122	e8 00 00 00 00	 call	 store_dw_noswap

; 1473 :         STORE_DW( regs->txf_tdb.tdb_bea,      (U64) txf_bea      );

  02127	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR txf_bea$[rsp]
  0212f	e8 00 00 00 00	 call	 _byteswap_uint64
  02134	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0213c	48 81 c1 7b 0d
	00 00		 add	 rcx, 3451		; 00000d7bH
  02143	48 8b d0	 mov	 rdx, rax
  02146	e8 00 00 00 00	 call	 store_dw_noswap

; 1474 : 
; 1475 :         for (i=0; i < 16; i++)

  0214b	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  02156	eb 10		 jmp	 SHORT $LN40@z900_abort
$LN38@z900_abort:
  02158	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0215f	ff c0		 inc	 eax
  02161	89 84 24 84 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN40@z900_abort:
  02168	83 bc 24 84 00
	00 00 10	 cmp	 DWORD PTR i$[rsp], 16
  02170	7d 3f		 jge	 SHORT $LN39@z900_abort

; 1476 :             STORE_DW( regs->txf_tdb.tdb_gpr[i], regs->GR_G( i ));

  02172	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0217a	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02182	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  0218a	e8 00 00 00 00	 call	 _byteswap_uint64
  0218f	48 63 8c 24 84
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  02197	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0219f	48 8d 8c ca cb
	0d 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*8+3531]
  021a7	48 8b d0	 mov	 rdx, rax
  021aa	e8 00 00 00 00	 call	 store_dw_noswap
  021af	eb a7		 jmp	 SHORT $LN38@z900_abort
$LN39@z900_abort:

; 1477 :     }
; 1478 : 
; 1479 :     /*----------------------------------------------------*/
; 1480 :     /*  Copy internal TDB to its proper storage location  */
; 1481 :     /*----------------------------------------------------*/
; 1482 : 
; 1483 :     if (pi_tdb)

  021b1	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR pi_tdb$[rsp], 0
  021ba	74 44		 je	 SHORT $LN138@z900_abort

; 1484 :     {
; 1485 :         memcpy( pi_tdb, &regs->txf_tdb, sizeof( TDB ));

  021bc	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  021c4	48 8b bc 24 10
	01 00 00	 mov	 rdi, QWORD PTR pi_tdb$[rsp]
  021cc	48 8d b0 4b 0d
	00 00		 lea	 rsi, QWORD PTR [rax+3403]
  021d3	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  021d8	f3 a4		 rep movsb

; 1486 :         ARCH_DEP( or_storage_key )( MAIN_TO_ABS( pi_tdb ), (STORKEY_REF | STORKEY_CHANGE) );

  021da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  021e1	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  021e8	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR pi_tdb$[rsp]
  021f0	48 2b c8	 sub	 rcx, rax
  021f3	48 8b c1	 mov	 rax, rcx
  021f6	b2 06		 mov	 dl, 6
  021f8	48 8b c8	 mov	 rcx, rax
  021fb	e8 00 00 00 00	 call	 z900_or_storage_key
$LN138@z900_abort:

; 1487 :     }
; 1488 : 
; 1489 :     if (tb_tdb)

  02200	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR tb_tdb$[rsp], 0
  02209	74 44		 je	 SHORT $LN139@z900_abort

; 1490 :     {
; 1491 :         memcpy( tb_tdb, &regs->txf_tdb, sizeof( TDB ));

  0220b	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02213	48 8b bc 24 18
	01 00 00	 mov	 rdi, QWORD PTR tb_tdb$[rsp]
  0221b	48 8d b0 4b 0d
	00 00		 lea	 rsi, QWORD PTR [rax+3403]
  02222	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  02227	f3 a4		 rep movsb

; 1492 :         ARCH_DEP( or_storage_key )( MAIN_TO_ABS( tb_tdb ), (STORKEY_REF | STORKEY_CHANGE) );

  02229	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02230	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  02237	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tb_tdb$[rsp]
  0223f	48 2b c8	 sub	 rcx, rax
  02242	48 8b c1	 mov	 rax, rcx
  02245	b2 06		 mov	 dl, 6
  02247	48 8b c8	 mov	 rcx, rax
  0224a	e8 00 00 00 00	 call	 z900_or_storage_key
$LN139@z900_abort:

; 1493 :     }
; 1494 : 
; 1495 :     /* Trace TDB if requested */
; 1496 :     if (TXF_TRACE_TDB( regs, txf_contran ))

  0224f	33 c0		 xor	 eax, eax
  02251	83 f8 01	 cmp	 eax, 1
  02254	0f 84 2f 02 00
	00		 je	 $LN140@z900_abort
  0225a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02261	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  02267	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0226c	85 c0		 test	 eax, eax
  0226e	0f 84 15 02 00
	00		 je	 $LN140@z900_abort
  02274	33 c0		 xor	 eax, eax
  02276	83 f8 01	 cmp	 eax, 1
  02279	0f 84 0a 02 00
	00		 je	 $LN140@z900_abort
  0227f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02286	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0228c	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  02291	85 c0		 test	 eax, eax
  02293	0f 84 f0 01 00
	00		 je	 $LN140@z900_abort
  02299	33 c0		 xor	 eax, eax
  0229b	83 f8 01	 cmp	 eax, 1
  0229e	0f 84 e5 01 00
	00		 je	 $LN140@z900_abort
  022a4	33 c0		 xor	 eax, eax
  022a6	85 c0		 test	 eax, eax
  022a8	75 37		 jne	 SHORT $LN141@z900_abort
  022aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  022b1	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  022b7	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  022bc	85 c0		 test	 eax, eax
  022be	74 21		 je	 SHORT $LN141@z900_abort
  022c0	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  022c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  022cf	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  022d5	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  022db	0f 85 a8 01 00
	00		 jne	 $LN140@z900_abort
$LN141@z900_abort:
  022e1	33 c0		 xor	 eax, eax
  022e3	85 c0		 test	 eax, eax
  022e5	75 37		 jne	 SHORT $LN142@z900_abort
  022e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  022ee	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  022f4	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  022f9	85 c0		 test	 eax, eax
  022fb	74 21		 je	 SHORT $LN142@z900_abort
  022fd	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02305	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0230c	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  02312	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  02318	0f 8c 6b 01 00
	00		 jl	 $LN140@z900_abort
$LN142@z900_abort:
  0231e	33 c0		 xor	 eax, eax
  02320	85 c0		 test	 eax, eax
  02322	75 65		 jne	 SHORT $LN143@z900_abort
  02324	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0232b	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  02331	25 00 00 00 0c	 and	 eax, 201326592		; 0c000000H
  02336	3d 00 00 00 0c	 cmp	 eax, 201326592		; 0c000000H
  0233b	74 4c		 je	 SHORT $LN143@z900_abort
  0233d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02344	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0234a	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0234f	85 c0		 test	 eax, eax
  02351	74 0c		 je	 SHORT $LN144@z900_abort
  02353	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  0235b	85 c0		 test	 eax, eax
  0235d	75 2a		 jne	 SHORT $LN143@z900_abort
$LN144@z900_abort:
  0235f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02366	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0236c	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  02371	85 c0		 test	 eax, eax
  02373	0f 84 10 01 00
	00		 je	 $LN140@z900_abort
  02379	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  02381	85 c0		 test	 eax, eax
  02383	0f 85 00 01 00
	00		 jne	 $LN140@z900_abort
$LN143@z900_abort:
  02389	33 c0		 xor	 eax, eax
  0238b	85 c0		 test	 eax, eax
  0238d	0f 85 d8 00 00
	00		 jne	 $LN145@z900_abort
  02393	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0239a	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  023a0	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  023a5	85 c0		 test	 eax, eax
  023a7	0f 84 be 00 00
	00		 je	 $LN145@z900_abort
  023ad	33 c0		 xor	 eax, eax
  023af	83 f8 01	 cmp	 eax, 1
  023b2	0f 84 d1 00 00
	00		 je	 $LN140@z900_abort
  023b8	33 c0		 xor	 eax, eax
  023ba	85 c0		 test	 eax, eax
  023bc	75 3b		 jne	 SHORT $LN146@z900_abort
  023be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  023c5	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  023cb	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  023d0	85 c0		 test	 eax, eax
  023d2	74 25		 je	 SHORT $LN146@z900_abort
  023d4	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  023dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  023e3	8b 89 50 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1360]
  023e9	8b 80 ac af 00
	00		 mov	 eax, DWORD PTR [rax+44972]
  023ef	23 c1		 and	 eax, ecx
  023f1	85 c0		 test	 eax, eax
  023f3	0f 84 90 00 00
	00		 je	 $LN140@z900_abort
$LN146@z900_abort:
  023f9	33 c0		 xor	 eax, eax
  023fb	85 c0		 test	 eax, eax
  023fd	75 33		 jne	 SHORT $LN147@z900_abort
  023ff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02406	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0240c	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  02411	85 c0		 test	 eax, eax
  02413	74 1d		 je	 SHORT $LN147@z900_abort
  02415	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0241d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  02424	8b 89 54 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1364]
  0242a	39 88 b8 af 00
	00		 cmp	 DWORD PTR [rax+44984], ecx
  02430	75 57		 jne	 SHORT $LN140@z900_abort
$LN147@z900_abort:
  02432	33 c0		 xor	 eax, eax
  02434	85 c0		 test	 eax, eax
  02436	75 33		 jne	 SHORT $LN148@z900_abort
  02438	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0243f	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  02445	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  0244a	85 c0		 test	 eax, eax
  0244c	74 1d		 je	 SHORT $LN148@z900_abort
  0244e	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02456	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0245d	8b 89 5c 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1372]
  02463	39 88 bc af 00
	00		 cmp	 DWORD PTR [rax+44988], ecx
  02469	7c 1e		 jl	 SHORT $LN140@z900_abort
$LN148@z900_abort:
$LN145@z900_abort:

; 1497 :         dump_tdb( regs, &regs->txf_tdb );

  0246b	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02473	48 05 4b 0d 00
	00		 add	 rax, 3403		; 00000d4bH
  02479	48 8b d0	 mov	 rdx, rax
  0247c	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02484	e8 00 00 00 00	 call	 dump_tdb
$LN140@z900_abort:

; 1498 : 
; 1499 :     /*----------------------------------------------------*/
; 1500 :     /*         Restore the requested registers            */
; 1501 :     /*----------------------------------------------------*/
; 1502 :     for (i=0; i < 16; i += 2, txf_gprmask <<= 1)

  02489	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  02494	eb 22		 jmp	 SHORT $LN43@z900_abort
$LN41@z900_abort:
  02496	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0249d	83 c0 02	 add	 eax, 2
  024a0	89 84 24 84 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
  024a7	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR txf_gprmask$[rsp]
  024af	d0 e0		 shl	 al, 1
  024b1	88 84 24 81 00
	00 00		 mov	 BYTE PTR txf_gprmask$[rsp], al
$LN43@z900_abort:
  024b8	83 bc 24 84 00
	00 00 10	 cmp	 DWORD PTR i$[rsp], 16
  024c0	0f 8d 80 00 00
	00		 jge	 $LN42@z900_abort

; 1503 :     {
; 1504 :         if (txf_gprmask & 0x80)

  024c6	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR txf_gprmask$[rsp]
  024ce	25 80 00 00 00	 and	 eax, 128		; 00000080H
  024d3	85 c0		 test	 eax, eax
  024d5	74 6a		 je	 SHORT $LN149@z900_abort

; 1505 :         {
; 1506 :             regs->gr[ i+0 ] = regs->txf_savedgr[ i+0 ];

  024d7	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  024de	48 98		 cdqe
  024e0	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  024e8	48 8b 84 c1 88
	ae 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+44680]
  024f0	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  024f7	48 63 c9	 movsxd	 rcx, ecx
  024fa	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  02502	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax

; 1507 :             regs->gr[ i+1 ] = regs->txf_savedgr[ i+1 ];

  0250a	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  02511	ff c0		 inc	 eax
  02513	48 98		 cdqe
  02515	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0251d	48 8b 84 c1 88
	ae 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+44680]
  02525	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  0252c	ff c1		 inc	 ecx
  0252e	48 63 c9	 movsxd	 rcx, ecx
  02531	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  02539	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
$LN149@z900_abort:

; 1508 :         }
; 1509 :     }

  02541	e9 50 ff ff ff	 jmp	 $LN41@z900_abort
$LN42@z900_abort:

; 1510 : 
; 1511 :     /*----------------------------------------------------*/
; 1512 :     /*                 Release INTLOCK                    */
; 1513 :     /*----------------------------------------------------*/
; 1514 :     /*  Release the interrupt lock if we obtained it, or  */
; 1515 :     /*  if we won't be directly returning. That is if we  */
; 1516 :     /*  will be jumping to progjmp via program_interrupt  */
; 1517 :     /*  or via SIE_NO_INTERCEPT, then we need to release  */
; 1518 :     /*  the interrupt lock beforehand. Otherwise if we    */
; 1519 :     /*  already held it when we were called, then we need */
; 1520 :     /*  to return to the caller with it still held.       */
; 1521 :     /*----------------------------------------------------*/
; 1522 : 
; 1523 :     if (!had_INTLOCK || retry != ABORT_RETRY_RETURN)

  02546	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR had_INTLOCK$[rsp]
  0254e	85 c0		 test	 eax, eax
  02550	74 0a		 je	 SHORT $LN151@z900_abort
  02552	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR retry$[rsp], 0
  0255a	74 17		 je	 SHORT $LN150@z900_abort
$LN151@z900_abort:

; 1524 :     {
; 1525 :         PERFORM_SERIALIZATION( regs );

  0255c	0f ae f0	 mfence

; 1526 :         RELEASE_INTLOCK( regs );

  0255f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193711
  02566	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0256e	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN150@z900_abort:

; 1527 :     }
; 1528 : 
; 1529 :     /*----------------------------------------------------*/
; 1530 :     /*       RETURN TO CALLER OR JUMP AS REQUESTED        */
; 1531 :     /*----------------------------------------------------*/
; 1532 : 
; 1533 :     if (retry == ABORT_RETRY_RETURN)

  02573	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR retry$[rsp], 0
  0257b	75 62		 jne	 SHORT $LN152@z900_abort
$LN46@z900_abort:

; 1534 :     {
; 1535 :         /* Caller requested that we return back to
; 1536 :            them so they can decide what to do next.
; 1537 :            This 'retry' code is typically used by
; 1538 :            the various interrupt handlers (external,
; 1539 :            machine check, restart, program and I/O).
; 1540 :         */
; 1541 :         PTT_TXF( "*TXF abrtret", 0, txf_contran, txf_tnd );

  0257d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02584	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02587	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  0258d	48 85 c0	 test	 rax, rax
  02590	74 42		 je	 SHORT $LN153@z900_abort
  02592	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR txf_tnd$[rsp]
  0259a	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR txf_contran$[rsp]
  025a2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  025ab	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  025b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193714
  025b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  025bc	44 8b c9	 mov	 r9d, ecx
  025bf	45 33 c0	 xor	 r8d, r8d
  025c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193715
  025c9	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  025ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN153@z900_abort:
  025d4	33 c0		 xor	 eax, eax
  025d6	85 c0		 test	 eax, eax
  025d8	75 a3		 jne	 SHORT $LN46@z900_abort

; 1542 :         return; // (caller decides what to do next)

  025da	e9 5d 01 00 00	 jmp	 $LN1@z900_abort
$LN152@z900_abort:

; 1543 :     }
; 1544 : 
; 1545 :     if (retry == ABORT_RETRY_CC)

  025df	83 bc 24 9c 00
	00 00 01	 cmp	 DWORD PTR retry$[rsp], 1
  025e7	75 78		 jne	 SHORT $LN154@z900_abort
$LN49@z900_abort:

; 1546 :     {
; 1547 :         /* Transaction failures have their PSW set to the
; 1548 :            Transaction Abort PSW, which for unconstrained
; 1549 :            transactions points to the instruction immediately
; 1550 :            following the TBEGIN instruction (so that the
; 1551 :            condition code can then be used to decide whether
; 1552 :            to bother retrying the transaction or not), and
; 1553 :            for constrained transactions points to the TBEGINC
; 1554 :            instruction itself (so that the transaction can
; 1555 :            then be unconditionally retried).
; 1556 : 
; 1557 :            Either way, we simply jump directly back to the
; 1558 :            'run_cpu' loop to redispatch this CPU, thereby
; 1559 :            causing it to continue executing instructions at
; 1560 :            where the Transaction Abort PSW said it should.
; 1561 :         */
; 1562 :         PTT_TXF( "*TXF abrtjmp", 0, txf_contran, txf_tnd );

  025e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  025f0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  025f3	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  025f9	48 85 c0	 test	 rax, rax
  025fc	74 42		 je	 SHORT $LN155@z900_abort
  025fe	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR txf_tnd$[rsp]
  02606	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR txf_contran$[rsp]
  0260e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02617	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0261c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193718
  02623	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02628	44 8b c9	 mov	 r9d, ecx
  0262b	45 33 c0	 xor	 r8d, r8d
  0262e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193719
  02635	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0263a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN155@z900_abort:
  02640	33 c0		 xor	 eax, eax
  02642	85 c0		 test	 eax, eax
  02644	75 a3		 jne	 SHORT $LN49@z900_abort

; 1563 :         longjmp( regs->progjmp, SIE_NO_INTERCEPT );

  02646	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0264e	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  02654	ba ff ff ff ff	 mov	 edx, -1
  02659	48 8b c8	 mov	 rcx, rax
  0265c	e8 00 00 00 00	 call	 longjmp
$LN154@z900_abort:
$LN52@z900_abort:

; 1564 :         UNREACHABLE_CODE( return );
; 1565 :     }
; 1566 : 
; 1567 :     /*   (a transaction constraint has been violated...)   */
; 1568 : 
; 1569 :     ASSERT( retry == ABORT_RETRY_PGMCHK );  // (sanity check)

  02661	83 bc 24 9c 00
	00 00 02	 cmp	 DWORD PTR retry$[rsp], 2
  02669	74 5c		 je	 SHORT $LN156@z900_abort
$LN55@z900_abort:
  0266b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193721
  02672	41 b8 21 06 00
	00		 mov	 r8d, 1569		; 00000621H
  02678	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193722
  0267f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193723
  02686	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0268c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  02692	85 c0		 test	 eax, eax
  02694	74 20		 je	 SHORT $LN157@z900_abort
  02696	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG193725
  0269d	41 b8 21 06 00
	00		 mov	 r8d, 1569		; 00000621H
  026a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193726
  026aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193727
  026b1	e8 00 00 00 00	 call	 DebuggerTrace
$LN157@z900_abort:
  026b6	33 c0		 xor	 eax, eax
  026b8	85 c0		 test	 eax, eax
  026ba	75 af		 jne	 SHORT $LN55@z900_abort
  026bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  026c2	85 c0		 test	 eax, eax
  026c4	74 01		 je	 SHORT $LN158@z900_abort
  026c6	cc		 int	 3
$LN158@z900_abort:
$LN156@z900_abort:
  026c7	33 c0		 xor	 eax, eax
  026c9	85 c0		 test	 eax, eax
  026cb	75 94		 jne	 SHORT $LN52@z900_abort
$LN58@z900_abort:

; 1570 : 
; 1571 :     /* The caller has requested via retry == ABORT_RETRY_PGMCHK
; 1572 :        that a program interrupt should be thrown for this aborted
; 1573 :        transaction. This of course implies an unfilterable program
; 1574 :        interrupt since transaction constraints cannot be ignored
; 1575 :        nor filtered. A program interrupt WILL occur. If it was a
; 1576 :        CONSTRAINED transaction, it will be retried at the TBEGINC
; 1577 :        instruction. For unconstrained transactions it will restart
; 1578 :        at the instruction immediately following TBEGIN instruction
; 1579 :        with a condition code of 3.
; 1580 :     */
; 1581 :     PTT_TXF( "*TXF abrtpgm", 0, txf_contran, txf_tnd );

  026cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  026d4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  026d7	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  026dd	48 85 c0	 test	 rax, rax
  026e0	74 42		 je	 SHORT $LN159@z900_abort
  026e2	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR txf_tnd$[rsp]
  026ea	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR txf_contran$[rsp]
  026f2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  026fb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  02700	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193730
  02707	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0270c	44 8b c9	 mov	 r9d, ecx
  0270f	45 33 c0	 xor	 r8d, r8d
  02712	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193731
  02719	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0271e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN159@z900_abort:
  02724	33 c0		 xor	 eax, eax
  02726	85 c0		 test	 eax, eax
  02728	75 a3		 jne	 SHORT $LN58@z900_abort

; 1582 :     ARCH_DEP( program_interrupt )( regs,

  0272a	ba 18 02 00 00	 mov	 edx, 536		; 00000218H
  0272f	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02737	e8 00 00 00 00	 call	 z900_program_interrupt
$LN1@z900_abort:
$LN160@z900_abort:

; 1583 :         PGM_TXF_EVENT | PGM_TRANSACTION_CONSTRAINT_EXCEPTION );
; 1584 :     UNREACHABLE_CODE( return );
; 1585 : 
; 1586 : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 1587 : 
; 1588 : } /* end ARCH_DEP( abort_transaction ) */

  0273c	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  02744	48 33 cc	 xor	 rcx, rsp
  02747	e8 00 00 00 00	 call	 __security_check_cookie
  0274c	48 81 c4 38 03
	00 00		 add	 rsp, 824		; 00000338H
  02753	5f		 pop	 rdi
  02754	5e		 pop	 rsi
  02755	c3		 ret	 0
z900_abort_transaction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
p$1 = 0
regs$ = 32
raw_retry$ = 40
txf_tac$ = 48
loc$ = 56
s390_abort_transaction PROC

; 1073 : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 18	 sub	 rsp, 24
$LN4@s390_abort:

; 1074 : #if !defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1075 : 
; 1076 :     /* S370 and S390 don't support Transactional-Execution Facility */
; 1077 : 
; 1078 :     UNREFERENCED( regs      );

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@s390_abort
$LN7@s390_abort:

; 1079 :     UNREFERENCED( raw_retry );

  0001d	33 c0		 xor	 eax, eax
  0001f	85 c0		 test	 eax, eax
  00021	75 fa		 jne	 SHORT $LN7@s390_abort
$LN10@s390_abort:

; 1080 :     UNREFERENCED( txf_tac   );

  00023	33 c0		 xor	 eax, eax
  00025	85 c0		 test	 eax, eax
  00027	75 fa		 jne	 SHORT $LN10@s390_abort
$LN13@s390_abort:

; 1081 :     UNREFERENCED( loc       );

  00029	33 c0		 xor	 eax, eax
  0002b	85 c0		 test	 eax, eax
  0002d	75 fa		 jne	 SHORT $LN13@s390_abort
$LN16@s390_abort:

; 1082 : 
; 1083 :     CRASH();   /* Should NEVER be called for S/370 or S/390 */

  0002f	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00037	48 8b 04 24	 mov	 rax, QWORD PTR p$1[rsp]
  0003b	c6 00 00	 mov	 BYTE PTR [rax], 0
  0003e	33 c0		 xor	 eax, eax
  00040	85 c0		 test	 eax, eax
  00042	75 eb		 jne	 SHORT $LN16@s390_abort

; 1084 : 
; 1085 : #else /* only Z900 supports Transactional-Execution Facility */
; 1086 : 
; 1087 : BYTE       txf_gprmask;
; 1088 : int        txf_tnd, i;
; 1089 : bool       txf_contran, had_INTLOCK;
; 1090 : U32        txf_piid;
; 1091 : U64        txf_conflict;
; 1092 : U64        txf_bea;
; 1093 : TDB*       pi_tdb   = NULL; /* Program Interrupt TDB @ fixed 0x1800  */
; 1094 : TDB*       tb_tdb   = NULL; /* TBEGIN-specified TDB @ operand-1 addr */
; 1095 : VADR       txf_atia;        /* Aborted Transaction Instruction Addr. */
; 1096 : int        retry;           /* Actual retry code                     */
; 1097 : 
; 1098 :     UNREFERENCED( loc );
; 1099 : 
; 1100 :     PTT_TXF( "*TXF abort", raw_retry, txf_tac, regs->txf_contran );
; 1101 : 
; 1102 :     /* Set the initial Transaction Abort Code */
; 1103 :     if (!regs->txf_tac)
; 1104 :         regs->txf_tac = txf_tac;
; 1105 : 
; 1106 :     TXF_TRACE_INIT( regs );
; 1107 : 
; 1108 :     // LOGIC ERROR if CPU not in transactional-execution mode
; 1109 :     if (!regs->txf_tnd)
; 1110 :         CRASH();
; 1111 : 
; 1112 :     /* Get the ACTUAL 'retry' code */
; 1113 :     retry = ((raw_retry < 0) ? -raw_retry : raw_retry);
; 1114 : 
; 1115 :     /* Normal abort? Or special instruction dispatch abort? */
; 1116 :     if (raw_retry >= 0)
; 1117 :     {
; 1118 :         /* Normal instruction abort: the PREVIOUS instruction
; 1119 :            is the one where the abort actually occurred at. */
; 1120 :         txf_atia = PSW_IA_FROM_IP( regs, -REAL_ILC( regs ));
; 1121 :         PTT_TXF( "TXF ATIA", txf_atia, 0, -REAL_ILC( regs ) );
; 1122 :     }
; 1123 :     else // (raw_retry < 0)
; 1124 :     {
; 1125 :         /* Instruction dispatch abort: the CURRENT instruction
; 1126 :            address is where the abort actually occurred at. */
; 1127 :         txf_atia = PSW_IA_FROM_IP( regs, 0 );
; 1128 :         PTT_TXF( "TXF ATIA", txf_atia, 0, 0 );
; 1129 :     }
; 1130 : 
; 1131 :     /* Obtain the interrupt lock if we don't already have it */
; 1132 :     if (IS_INTLOCK_HELD( regs ))
; 1133 :         had_INTLOCK = true;
; 1134 :     else
; 1135 :     {
; 1136 :         OBTAIN_INTLOCK( regs );
; 1137 :         had_INTLOCK = false;
; 1138 :     }
; 1139 : 
; 1140 :     PERFORM_SERIALIZATION( regs );
; 1141 : 
; 1142 :     /*---------------------------------------------*/
; 1143 :     /*       Failure of transaction retry?         */
; 1144 :     /*---------------------------------------------*/
; 1145 :     if (1
; 1146 :         && MLVL( VERBOSE )
; 1147 :         && regs->txf_aborts
; 1148 :         && TXF_TRACE( regs, FAILURE, regs->txf_contran )
; 1149 :     )
; 1150 :     {
; 1151 :         // "TXF: %s%02X: %s%s transaction retry #%d FAILED!"
; 1152 :         WRMSG( HHC17719, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),
; 1153 :             TXF_CONSTRAINED( regs->txf_contran ), regs->txf_aborts );
; 1154 :     }
; 1155 : 
; 1156 :     /*---------------------------------------------*/
; 1157 :     /*          Count the abort/retry              */
; 1158 :     /*---------------------------------------------*/
; 1159 : 
; 1160 :     /* Count total retries for this transaction */
; 1161 :     regs->txf_aborts++;
; 1162 : 
; 1163 :     /* Provide PPA assist for constrained transactions too */
; 1164 :     if (regs->txf_contran)
; 1165 :         regs->txf_PPA = regs->txf_aborts;
; 1166 : 
; 1167 :     /* Track total aborts by cause (TAC) */
; 1168 :     if (regs->txf_tac == TAC_MISC)
; 1169 :         TXF_STATS( aborts_by_tac_misc, regs->txf_contran );
; 1170 :     else
; 1171 :     {
; 1172 :         int slot = regs->txf_tac < TXF_STATS_TAC_SLOTS ?
; 1173 :                    regs->txf_tac : 0; // (0 == "other")
; 1174 :         TXF_STATS( aborts_by_tac[ slot ], regs->txf_contran );
; 1175 :     }
; 1176 : 
; 1177 :     /*---------------------------------------------*/
; 1178 :     /*  Clean up the transaction flags             */
; 1179 :     /*---------------------------------------------*/
; 1180 : 
; 1181 :     txf_tnd      = regs->txf_tnd;        /* save orig value */
; 1182 :     txf_contran  = regs->txf_contran;    /* save orig value */
; 1183 :     txf_gprmask  = regs->txf_gprmask;    /* save orig value */
; 1184 :     txf_conflict = regs->txf_conflict;   /* save orig value */
; 1185 :     txf_piid     = regs->txf_piid;       /* save orig value */
; 1186 :     txf_bea      = regs->bear;           /* save orig value */
; 1187 : 
; 1188 :     /*---------------------------------------------*/
; 1189 :     /*  Log the failure if debugging enabled       */
; 1190 :     /*---------------------------------------------*/
; 1191 : 
; 1192 :     if (TXF_TRACE( regs, FAILURE, txf_contran ))
; 1193 :     {
; 1194 :         /* Report the reason WHY the transaction was aborted */
; 1195 :         char why[ 256 ] = {0};
; 1196 : 
; 1197 :         if (regs->txf_why)
; 1198 :             txf_why_str( why, sizeof( why ), regs->txf_why );
; 1199 :         else
; 1200 :             STRLCPY( why, " ?" );
; 1201 : 
; 1202 :         // "TXF: %s%02X: %sFailed %s %s Transaction for TND %d: %s = %s, why =%s"
; 1203 :         WRMSG( HHC17703, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),
; 1204 :             txf_tnd > 1 ? "Nested" : "Outermost",
; 1205 :             TXF_CONSTRAINED( txf_contran ), txf_tnd,
; 1206 :             tac2short( txf_tac ), tac2long( txf_tac ), why );
; 1207 : 
; 1208 :         /* If this is a delayed abort, log who detected/requested it */
; 1209 :         /* Delayed aborts are those detected by another CPU, not us. */
; 1210 :         if (regs->txf_why & TXF_WHY_DELAYED_ABORT)
; 1211 :         {
; 1212 :             char who[16] = {0};
; 1213 : 
; 1214 :             if (regs->txf_who < 0)
; 1215 :                 STRLCPY( who, "channel" );
; 1216 :             else if (regs->txf_who == regs->cpuad) // (shouldn't occur)
; 1217 :                 STRLCPY( who, "ourself" );
; 1218 :             else
; 1219 :                 MSGBUF( who, "%s%02X", PTYPSTR( regs->txf_who ), regs->txf_who );
; 1220 : 
; 1221 :             if (MLVL( VERBOSE ))
; 1222 :             {
; 1223 :                 // "TXF: %s%02X: %sAbort set by %s at %s"
; 1224 :                 WRMSG( HHC17720, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),
; 1225 :                     who, TRIMLOC( regs->txf_loc ));
; 1226 :             }
; 1227 :         }
; 1228 : 
; 1229 :         /* Print page map if requested */
; 1230 :         if (TXF_TRACE_MAP( regs, txf_contran ))
; 1231 :         {
; 1232 :             TPAGEMAP*  pmap;
; 1233 :             BYTE*      mainaddr;
; 1234 :             BYTE*      altaddr;
; 1235 :             int        i, j;
; 1236 : 
; 1237 :             pmap = regs->txf_pagesmap;
; 1238 : 
; 1239 :             for (i=0; i < regs->txf_pgcnt; i++, pmap++)
; 1240 :             {
; 1241 :                 if (TXF_TRACE_PAGES( regs, txf_contran ))
; 1242 :                 {
; 1243 :                     // "TXF: %s%02X: %svirt 0x%16.16"PRIX64", abs 0x%16.16"PRIX64", alt 0x%16.16"PRIX64
; 1244 :                     WRMSG( HHC17704, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),
; 1245 :                         (U64) pmap->virtpageaddr,
; 1246 :                         (U64)(pmap->mainpageaddr - regs->mainstor),
; 1247 :                         (U64) pmap->altpageaddr );
; 1248 :                 }
; 1249 : 
; 1250 :                 if (TXF_TRACE_LINES( regs, txf_contran ))
; 1251 :                 {
; 1252 :                     for (j=0; j < ZCACHE_LINE_PAGE; j++)
; 1253 :                     {
; 1254 :                         if (pmap->cachemap[j] == CM_CLEAN)
; 1255 :                             continue;
; 1256 : 
; 1257 :                         mainaddr = pmap->mainpageaddr + (j << ZCACHE_LINE_SHIFT);
; 1258 :                         altaddr  = pmap->altpageaddr  + (j << ZCACHE_LINE_SHIFT);
; 1259 : 
; 1260 :                         // "TXF: %s%02X: %sThere now:  +"
; 1261 :                         dump_cache( regs, TXF_DUMP_PFX( HHC17705 ), j, mainaddr );
; 1262 : 
; 1263 :                         if (pmap->cachemap[j] == CM_FETCHED)
; 1264 :                             // "TXF: %s%02X: %sWe fetched: +"
; 1265 :                             dump_cache( regs, TXF_DUMP_PFX( HHC17706 ), j, altaddr );
; 1266 :                         else
; 1267 :                             // "TXF: %s%02X: %sWe stored:  +"
; 1268 :                             dump_cache( regs, TXF_DUMP_PFX( HHC17707 ), j, altaddr );
; 1269 :                     }
; 1270 :                 }
; 1271 :             }
; 1272 :         }
; 1273 :     }
; 1274 : 
; 1275 :     /*---------------------------------------------*/
; 1276 :     /*  Clean up the transaction flags             */
; 1277 :     /*---------------------------------------------*/
; 1278 : 
; 1279 :     regs->txf_NTSTG     = false;
; 1280 :     regs->txf_contran   = false;
; 1281 :     regs->txf_tac       = 0;
; 1282 :     regs->txf_abortctr  = 0;
; 1283 :     regs->txf_instctr   = 0;
; 1284 :     regs->txf_pgcnt     = 0;
; 1285 :     regs->txf_conflict  = 0;
; 1286 :     regs->txf_piid      = 0;
; 1287 : 
; 1288 :     /*---------------------------------------------*/
; 1289 :     /*  Reset transaction nesting depth            */
; 1290 :     /*---------------------------------------------*/
; 1291 :     OBTAIN_TXFLOCK( regs );
; 1292 :     {
; 1293 :         regs->txf_tnd = 0;
; 1294 :     }
; 1295 :     RELEASE_TXFLOCK( regs );
; 1296 : 
; 1297 :     /* Reset CONSTRAINED trans instruction fetch constraint */
; 1298 :     ARCH_DEP( reset_txf_aie )( regs );
; 1299 : 
; 1300 :     /*-----------------------------------------------------*/
; 1301 :     /*    Trace program interrupt BEFORE updating PSW      */
; 1302 :     /*-----------------------------------------------------*/
; 1303 :     /*  If the retry code is ABORT_RETRY_PGMCHK, then we   */
; 1304 :     /*  will eventually be calling the program_interrupt   */
; 1305 :     /*  function for PGM_TRANSACTION_CONSTRAINT_EXCEPTION  */
; 1306 :     /*  so we MUST trace the program interrupt here. We    */
; 1307 :     /*  CANNOT let the program_interrupt function do that  */
; 1308 :     /*  for us like it normally does since it would report */
; 1309 :     /*  the wrong PSW. Thus we MUST do it ourselves here.  */
; 1310 :     /*-----------------------------------------------------*/
; 1311 : 
; 1312 :     if (retry == ABORT_RETRY_PGMCHK)
; 1313 :     {
; 1314 :         int pcode, ilc;
; 1315 : 
; 1316 :         pcode = PGM_TRANSACTION_CONSTRAINT_EXCEPTION | PGM_TXF_EVENT;
; 1317 : 
; 1318 :         if (raw_retry == -ABORT_RETRY_PGMCHK) // (negative?)
; 1319 :         {
; 1320 :             /* Instruction dispatch program interrupt: since the
; 1321 :                instruction has not been decoded yet (and the PSW
; 1322 :                and 'ip' pointer bumped appropriately (instead,
; 1323 :                it is pointing directly AT the failing instruction
; 1324 :                and not past it like normal)), we must bump the ip
; 1325 :                past the instruction that program checked so that
; 1326 :                the 'trace_program_interrupt' function can then
; 1327 :                back it up to point to the correct instruction.
; 1328 :             */
; 1329 :             ilc = ILC( *regs->ip );
; 1330 :             regs->ip += ilc;
; 1331 :             {
; 1332 :                 PTT_TXF( "TXF trpi+ilc", regs->ip, ilc, 0 );
; 1333 :                 ARCH_DEP( trace_program_interrupt )( regs, pcode, ilc );
; 1334 :             }
; 1335 :             regs->ip -= ilc;
; 1336 :         }
; 1337 :         else /* Normal program interrupt after instruction decode */
; 1338 :         {
; 1339 :             /* Fix PSW and get instruction length (ilc) */
; 1340 :             ilc = ARCH_DEP( fix_program_interrupt_PSW )( regs );
; 1341 : 
; 1342 :             /* Trace program checks other than PER event */
; 1343 :             PTT_TXF( "TXF trpi", regs->ip, ilc, 0 );
; 1344 :             ARCH_DEP( trace_program_interrupt )( regs, pcode, ilc );
; 1345 :         }
; 1346 : 
; 1347 :         /* Save the program interrupt id */
; 1348 :         txf_piid   = pcode;
; 1349 :         txf_piid  |= (ilc << 16);
; 1350 :     }
; 1351 : 
; 1352 :     /*----------------------------------------------------*/
; 1353 :     /*  Set the current PSW to the Transaction Abort PSW  */
; 1354 :     /*----------------------------------------------------*/
; 1355 : 
; 1356 :     /* PROGRAMMING NOTE: it's CRITICAL to invalidate the aia BEFORE
; 1357 :        setting the current PSW to the Transaction Abort PSW, since
; 1358 :        INVALIDATE_AIA *might* update the PSW's instruction address
; 1359 :        to a value different from what txf_tapsw says it should be!
; 1360 :     */
; 1361 :     INVALIDATE_AIA( regs ); // (do *before* PSW memcpy!)
; 1362 :     memcpy( &regs->psw, &regs->txf_tapsw, sizeof( PSW ));
; 1363 :     regs->ip  = regs->txf_ip;
; 1364 :     regs->aip = regs->txf_aip;
; 1365 :     regs->aiv = regs->txf_aiv;
; 1366 : 
; 1367 :     /*---------------------------------------------*/
; 1368 :     /*     Set the condition code in the PSW       */
; 1369 :     /*---------------------------------------------*/
; 1370 : 
; 1371 :     if (txf_tac && txf_tac < (int) _countof( tac2cc ))
; 1372 :                                     regs->psw.cc = tac2cc[ txf_tac ];
; 1373 :     else if (txf_tac == TAC_MISC)   regs->psw.cc = TXF_CC_TRANSIENT;
; 1374 :     else if (txf_tac >= TAC_TABORT) regs->psw.cc = TXF_CC_INDETERMINATE;
; 1375 : 
; 1376 :     /*---------------------------------------------*/
; 1377 :     /*      Put data/vector exception code         */
; 1378 :     /*    into byte 2 of FPCR if appropriate.      */
; 1379 :     /*---------------------------------------------*/
; 1380 : 
; 1381 :     if (1
; 1382 :         && (txf_piid & 0xFF) == PGM_DATA_EXCEPTION
; 1383 :         && regs->txf_ctlflag & TXF_CTL_FLOAT
; 1384 :         && regs->CR(0) & CR0_AFP
; 1385 :     )
; 1386 :     {
; 1387 :         regs->fpc &= ~((U32) 0xFF              << 8);
; 1388 :         regs->fpc |=  ((U32) regs->txf_dxc_vxc << 8);
; 1389 :     }
; 1390 : 
; 1391 :     /*------------------------------------------------*/
; 1392 :     /*               Populate TDBs                    */
; 1393 :     /*------------------------------------------------*/
; 1394 :     /*  Populate the TDBs. For program-interrupts,    */
; 1395 :     /*  the TDB is at fixed storage location 0x1800   */
; 1396 :     /*  in low core.  Additionally, the address of    */
; 1397 :     /*  a second TDB may be specified by the TBEGIN   */
; 1398 :     /*  instruction itself. (The operand-1 address    */
; 1399 :     /*  for TBEGINC is ignored.)                      */
; 1400 :     /*------------------------------------------------*/
; 1401 : 
; 1402 :     /* CONSTRAINED transaction or Program Interrupt?  */
; 1403 :     if (0
; 1404 :         || txf_contran          /* CONSTRAINED trans? */
; 1405 :         || txf_tac == TAC_UPGM  /* Unfiltered PGM?    */
; 1406 :         || txf_tac == TAC_FPGM  /* Filtered   PGM?    */
; 1407 :     )
; 1408 :     {
; 1409 :         RADR pi_tdba = 0x1800;
; 1410 :         pi_tdba = APPLY_PREFIXING( pi_tdba, regs->PX );
; 1411 :         pi_tdb = (TDB*)(regs->mainstor + pi_tdba);
; 1412 :     }
; 1413 : 
; 1414 :     /* TBEGIN-specified TDB? */
; 1415 :     if (!txf_contran && regs->txf_tdba_b1)
; 1416 :     {
; 1417 :         RADR  real_tdb;
; 1418 :         int   stid;
; 1419 :         int   xcode;
; 1420 : 
; 1421 :         /* Convert TDB address to absolute mainstor address */
; 1422 :         if ((xcode = ARCH_DEP( virt_to_real )( &real_tdb, &stid,
; 1423 :             regs->txf_tdba, regs->txf_tdba_b1, regs, ACCTYPE_WRITE )) == 0)
; 1424 :         {
; 1425 :             tb_tdb = (TDB*)(regs->mainstor + APPLY_PREFIXING( real_tdb, regs->PX ));
; 1426 :         }
; 1427 :         else
; 1428 :         {
; 1429 :             PTT_TXF( "*TXF vrfail", xcode, regs->txf_tdba, regs->txf_tdba_b1 );
; 1430 : 
; 1431 :             if (TXF_TRACING())
; 1432 :             {
; 1433 :                 // "TXF: %s%02X: %sTranslation exception %4.4hX (%s) on TBEGIN tdba 0x%16.16"PRIx64
; 1434 :                 WRMSG( HHC17713, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),
; 1435 :                     (U16)xcode, PIC2Name( xcode ), regs->txf_tdba );
; 1436 :             }
; 1437 : 
; 1438 :             /* Transaction Abort processing, Note 4: "If the TDBA is
; 1439 :                valid, but the block has become inaccessible subsequent
; 1440 :                to the execution of the outermost TBEGIN instruction,
; 1441 :                the TDB is not accessed and condition code 1 applies."
; 1442 :             */
; 1443 :             regs->psw.cc = TXF_CC_INDETERMINATE;
; 1444 :         }
; 1445 :     }
; 1446 : 
; 1447 :     /*--------------------------------------------------*/
; 1448 :     /*             Populate our internal TDB            */
; 1449 :     /*--------------------------------------------------*/
; 1450 :     {
; 1451 :         regs->txf_tdb.tdb_format = 1;
; 1452 :         regs->txf_tdb.tdb_eaid   = regs->excarid;
; 1453 :         regs->txf_tdb.tdb_flags  = (txf_contran ? TDB_CTI : 0x00);
; 1454 : 
; 1455 :         if (0
; 1456 :             || txf_tac == TAC_FETCH_CNF
; 1457 :             || txf_tac == TAC_STORE_CNF
; 1458 :         )
; 1459 :             regs->txf_tdb.tdb_flags |= (txf_conflict ? TDB_CTV : 0x00);
; 1460 : 
; 1461 :         if (0
; 1462 :             || (txf_piid & 0xFF) == PGM_DATA_EXCEPTION
; 1463 :             || (txf_piid & 0xFF) == PGM_VECTOR_PROCESSING_EXCEPTION
; 1464 :         )
; 1465 :             regs->txf_tdb.tdb_dxc = regs->txf_dxc_vxc;
; 1466 : 
; 1467 :         STORE_HW( regs->txf_tdb.tdb_tnd,      (U16) txf_tnd      );
; 1468 :         STORE_DW( regs->txf_tdb.tdb_tac,      (U64) txf_tac      );
; 1469 :         STORE_DW( regs->txf_tdb.tdb_teid,     (U64) regs->TEA    );
; 1470 :         STORE_FW( regs->txf_tdb.tdb_piid,     (U32) txf_piid     );
; 1471 :         STORE_DW( regs->txf_tdb.tdb_atia,     (U64) txf_atia     );
; 1472 :         STORE_DW( regs->txf_tdb.tdb_conflict, (U64) txf_conflict );
; 1473 :         STORE_DW( regs->txf_tdb.tdb_bea,      (U64) txf_bea      );
; 1474 : 
; 1475 :         for (i=0; i < 16; i++)
; 1476 :             STORE_DW( regs->txf_tdb.tdb_gpr[i], regs->GR_G( i ));
; 1477 :     }
; 1478 : 
; 1479 :     /*----------------------------------------------------*/
; 1480 :     /*  Copy internal TDB to its proper storage location  */
; 1481 :     /*----------------------------------------------------*/
; 1482 : 
; 1483 :     if (pi_tdb)
; 1484 :     {
; 1485 :         memcpy( pi_tdb, &regs->txf_tdb, sizeof( TDB ));
; 1486 :         ARCH_DEP( or_storage_key )( MAIN_TO_ABS( pi_tdb ), (STORKEY_REF | STORKEY_CHANGE) );
; 1487 :     }
; 1488 : 
; 1489 :     if (tb_tdb)
; 1490 :     {
; 1491 :         memcpy( tb_tdb, &regs->txf_tdb, sizeof( TDB ));
; 1492 :         ARCH_DEP( or_storage_key )( MAIN_TO_ABS( tb_tdb ), (STORKEY_REF | STORKEY_CHANGE) );
; 1493 :     }
; 1494 : 
; 1495 :     /* Trace TDB if requested */
; 1496 :     if (TXF_TRACE_TDB( regs, txf_contran ))
; 1497 :         dump_tdb( regs, &regs->txf_tdb );
; 1498 : 
; 1499 :     /*----------------------------------------------------*/
; 1500 :     /*         Restore the requested registers            */
; 1501 :     /*----------------------------------------------------*/
; 1502 :     for (i=0; i < 16; i += 2, txf_gprmask <<= 1)
; 1503 :     {
; 1504 :         if (txf_gprmask & 0x80)
; 1505 :         {
; 1506 :             regs->gr[ i+0 ] = regs->txf_savedgr[ i+0 ];
; 1507 :             regs->gr[ i+1 ] = regs->txf_savedgr[ i+1 ];
; 1508 :         }
; 1509 :     }
; 1510 : 
; 1511 :     /*----------------------------------------------------*/
; 1512 :     /*                 Release INTLOCK                    */
; 1513 :     /*----------------------------------------------------*/
; 1514 :     /*  Release the interrupt lock if we obtained it, or  */
; 1515 :     /*  if we won't be directly returning. That is if we  */
; 1516 :     /*  will be jumping to progjmp via program_interrupt  */
; 1517 :     /*  or via SIE_NO_INTERCEPT, then we need to release  */
; 1518 :     /*  the interrupt lock beforehand. Otherwise if we    */
; 1519 :     /*  already held it when we were called, then we need */
; 1520 :     /*  to return to the caller with it still held.       */
; 1521 :     /*----------------------------------------------------*/
; 1522 : 
; 1523 :     if (!had_INTLOCK || retry != ABORT_RETRY_RETURN)
; 1524 :     {
; 1525 :         PERFORM_SERIALIZATION( regs );
; 1526 :         RELEASE_INTLOCK( regs );
; 1527 :     }
; 1528 : 
; 1529 :     /*----------------------------------------------------*/
; 1530 :     /*       RETURN TO CALLER OR JUMP AS REQUESTED        */
; 1531 :     /*----------------------------------------------------*/
; 1532 : 
; 1533 :     if (retry == ABORT_RETRY_RETURN)
; 1534 :     {
; 1535 :         /* Caller requested that we return back to
; 1536 :            them so they can decide what to do next.
; 1537 :            This 'retry' code is typically used by
; 1538 :            the various interrupt handlers (external,
; 1539 :            machine check, restart, program and I/O).
; 1540 :         */
; 1541 :         PTT_TXF( "*TXF abrtret", 0, txf_contran, txf_tnd );
; 1542 :         return; // (caller decides what to do next)
; 1543 :     }
; 1544 : 
; 1545 :     if (retry == ABORT_RETRY_CC)
; 1546 :     {
; 1547 :         /* Transaction failures have their PSW set to the
; 1548 :            Transaction Abort PSW, which for unconstrained
; 1549 :            transactions points to the instruction immediately
; 1550 :            following the TBEGIN instruction (so that the
; 1551 :            condition code can then be used to decide whether
; 1552 :            to bother retrying the transaction or not), and
; 1553 :            for constrained transactions points to the TBEGINC
; 1554 :            instruction itself (so that the transaction can
; 1555 :            then be unconditionally retried).
; 1556 : 
; 1557 :            Either way, we simply jump directly back to the
; 1558 :            'run_cpu' loop to redispatch this CPU, thereby
; 1559 :            causing it to continue executing instructions at
; 1560 :            where the Transaction Abort PSW said it should.
; 1561 :         */
; 1562 :         PTT_TXF( "*TXF abrtjmp", 0, txf_contran, txf_tnd );
; 1563 :         longjmp( regs->progjmp, SIE_NO_INTERCEPT );
; 1564 :         UNREACHABLE_CODE( return );
; 1565 :     }
; 1566 : 
; 1567 :     /*   (a transaction constraint has been violated...)   */
; 1568 : 
; 1569 :     ASSERT( retry == ABORT_RETRY_PGMCHK );  // (sanity check)
; 1570 : 
; 1571 :     /* The caller has requested via retry == ABORT_RETRY_PGMCHK
; 1572 :        that a program interrupt should be thrown for this aborted
; 1573 :        transaction. This of course implies an unfilterable program
; 1574 :        interrupt since transaction constraints cannot be ignored
; 1575 :        nor filtered. A program interrupt WILL occur. If it was a
; 1576 :        CONSTRAINED transaction, it will be retried at the TBEGINC
; 1577 :        instruction. For unconstrained transactions it will restart
; 1578 :        at the instruction immediately following TBEGIN instruction
; 1579 :        with a condition code of 3.
; 1580 :     */
; 1581 :     PTT_TXF( "*TXF abrtpgm", 0, txf_contran, txf_tnd );
; 1582 :     ARCH_DEP( program_interrupt )( regs,
; 1583 :         PGM_TXF_EVENT | PGM_TRANSACTION_CONSTRAINT_EXCEPTION );
; 1584 :     UNREACHABLE_CODE( return );
; 1585 : 
; 1586 : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 1587 : 
; 1588 : } /* end ARCH_DEP( abort_transaction ) */

  00044	48 83 c4 18	 add	 rsp, 24
  00048	c3		 ret	 0
s390_abort_transaction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
p$1 = 0
regs$ = 32
raw_retry$ = 40
txf_tac$ = 48
loc$ = 56
s370_abort_transaction PROC

; 1073 : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 18	 sub	 rsp, 24
$LN4@s370_abort:

; 1074 : #if !defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1075 : 
; 1076 :     /* S370 and S390 don't support Transactional-Execution Facility */
; 1077 : 
; 1078 :     UNREFERENCED( regs      );

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@s370_abort
$LN7@s370_abort:

; 1079 :     UNREFERENCED( raw_retry );

  0001d	33 c0		 xor	 eax, eax
  0001f	85 c0		 test	 eax, eax
  00021	75 fa		 jne	 SHORT $LN7@s370_abort
$LN10@s370_abort:

; 1080 :     UNREFERENCED( txf_tac   );

  00023	33 c0		 xor	 eax, eax
  00025	85 c0		 test	 eax, eax
  00027	75 fa		 jne	 SHORT $LN10@s370_abort
$LN13@s370_abort:

; 1081 :     UNREFERENCED( loc       );

  00029	33 c0		 xor	 eax, eax
  0002b	85 c0		 test	 eax, eax
  0002d	75 fa		 jne	 SHORT $LN13@s370_abort
$LN16@s370_abort:

; 1082 : 
; 1083 :     CRASH();   /* Should NEVER be called for S/370 or S/390 */

  0002f	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00037	48 8b 04 24	 mov	 rax, QWORD PTR p$1[rsp]
  0003b	c6 00 00	 mov	 BYTE PTR [rax], 0
  0003e	33 c0		 xor	 eax, eax
  00040	85 c0		 test	 eax, eax
  00042	75 eb		 jne	 SHORT $LN16@s370_abort

; 1084 : 
; 1085 : #else /* only Z900 supports Transactional-Execution Facility */
; 1086 : 
; 1087 : BYTE       txf_gprmask;
; 1088 : int        txf_tnd, i;
; 1089 : bool       txf_contran, had_INTLOCK;
; 1090 : U32        txf_piid;
; 1091 : U64        txf_conflict;
; 1092 : U64        txf_bea;
; 1093 : TDB*       pi_tdb   = NULL; /* Program Interrupt TDB @ fixed 0x1800  */
; 1094 : TDB*       tb_tdb   = NULL; /* TBEGIN-specified TDB @ operand-1 addr */
; 1095 : VADR       txf_atia;        /* Aborted Transaction Instruction Addr. */
; 1096 : int        retry;           /* Actual retry code                     */
; 1097 : 
; 1098 :     UNREFERENCED( loc );
; 1099 : 
; 1100 :     PTT_TXF( "*TXF abort", raw_retry, txf_tac, regs->txf_contran );
; 1101 : 
; 1102 :     /* Set the initial Transaction Abort Code */
; 1103 :     if (!regs->txf_tac)
; 1104 :         regs->txf_tac = txf_tac;
; 1105 : 
; 1106 :     TXF_TRACE_INIT( regs );
; 1107 : 
; 1108 :     // LOGIC ERROR if CPU not in transactional-execution mode
; 1109 :     if (!regs->txf_tnd)
; 1110 :         CRASH();
; 1111 : 
; 1112 :     /* Get the ACTUAL 'retry' code */
; 1113 :     retry = ((raw_retry < 0) ? -raw_retry : raw_retry);
; 1114 : 
; 1115 :     /* Normal abort? Or special instruction dispatch abort? */
; 1116 :     if (raw_retry >= 0)
; 1117 :     {
; 1118 :         /* Normal instruction abort: the PREVIOUS instruction
; 1119 :            is the one where the abort actually occurred at. */
; 1120 :         txf_atia = PSW_IA_FROM_IP( regs, -REAL_ILC( regs ));
; 1121 :         PTT_TXF( "TXF ATIA", txf_atia, 0, -REAL_ILC( regs ) );
; 1122 :     }
; 1123 :     else // (raw_retry < 0)
; 1124 :     {
; 1125 :         /* Instruction dispatch abort: the CURRENT instruction
; 1126 :            address is where the abort actually occurred at. */
; 1127 :         txf_atia = PSW_IA_FROM_IP( regs, 0 );
; 1128 :         PTT_TXF( "TXF ATIA", txf_atia, 0, 0 );
; 1129 :     }
; 1130 : 
; 1131 :     /* Obtain the interrupt lock if we don't already have it */
; 1132 :     if (IS_INTLOCK_HELD( regs ))
; 1133 :         had_INTLOCK = true;
; 1134 :     else
; 1135 :     {
; 1136 :         OBTAIN_INTLOCK( regs );
; 1137 :         had_INTLOCK = false;
; 1138 :     }
; 1139 : 
; 1140 :     PERFORM_SERIALIZATION( regs );
; 1141 : 
; 1142 :     /*---------------------------------------------*/
; 1143 :     /*       Failure of transaction retry?         */
; 1144 :     /*---------------------------------------------*/
; 1145 :     if (1
; 1146 :         && MLVL( VERBOSE )
; 1147 :         && regs->txf_aborts
; 1148 :         && TXF_TRACE( regs, FAILURE, regs->txf_contran )
; 1149 :     )
; 1150 :     {
; 1151 :         // "TXF: %s%02X: %s%s transaction retry #%d FAILED!"
; 1152 :         WRMSG( HHC17719, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),
; 1153 :             TXF_CONSTRAINED( regs->txf_contran ), regs->txf_aborts );
; 1154 :     }
; 1155 : 
; 1156 :     /*---------------------------------------------*/
; 1157 :     /*          Count the abort/retry              */
; 1158 :     /*---------------------------------------------*/
; 1159 : 
; 1160 :     /* Count total retries for this transaction */
; 1161 :     regs->txf_aborts++;
; 1162 : 
; 1163 :     /* Provide PPA assist for constrained transactions too */
; 1164 :     if (regs->txf_contran)
; 1165 :         regs->txf_PPA = regs->txf_aborts;
; 1166 : 
; 1167 :     /* Track total aborts by cause (TAC) */
; 1168 :     if (regs->txf_tac == TAC_MISC)
; 1169 :         TXF_STATS( aborts_by_tac_misc, regs->txf_contran );
; 1170 :     else
; 1171 :     {
; 1172 :         int slot = regs->txf_tac < TXF_STATS_TAC_SLOTS ?
; 1173 :                    regs->txf_tac : 0; // (0 == "other")
; 1174 :         TXF_STATS( aborts_by_tac[ slot ], regs->txf_contran );
; 1175 :     }
; 1176 : 
; 1177 :     /*---------------------------------------------*/
; 1178 :     /*  Clean up the transaction flags             */
; 1179 :     /*---------------------------------------------*/
; 1180 : 
; 1181 :     txf_tnd      = regs->txf_tnd;        /* save orig value */
; 1182 :     txf_contran  = regs->txf_contran;    /* save orig value */
; 1183 :     txf_gprmask  = regs->txf_gprmask;    /* save orig value */
; 1184 :     txf_conflict = regs->txf_conflict;   /* save orig value */
; 1185 :     txf_piid     = regs->txf_piid;       /* save orig value */
; 1186 :     txf_bea      = regs->bear;           /* save orig value */
; 1187 : 
; 1188 :     /*---------------------------------------------*/
; 1189 :     /*  Log the failure if debugging enabled       */
; 1190 :     /*---------------------------------------------*/
; 1191 : 
; 1192 :     if (TXF_TRACE( regs, FAILURE, txf_contran ))
; 1193 :     {
; 1194 :         /* Report the reason WHY the transaction was aborted */
; 1195 :         char why[ 256 ] = {0};
; 1196 : 
; 1197 :         if (regs->txf_why)
; 1198 :             txf_why_str( why, sizeof( why ), regs->txf_why );
; 1199 :         else
; 1200 :             STRLCPY( why, " ?" );
; 1201 : 
; 1202 :         // "TXF: %s%02X: %sFailed %s %s Transaction for TND %d: %s = %s, why =%s"
; 1203 :         WRMSG( HHC17703, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),
; 1204 :             txf_tnd > 1 ? "Nested" : "Outermost",
; 1205 :             TXF_CONSTRAINED( txf_contran ), txf_tnd,
; 1206 :             tac2short( txf_tac ), tac2long( txf_tac ), why );
; 1207 : 
; 1208 :         /* If this is a delayed abort, log who detected/requested it */
; 1209 :         /* Delayed aborts are those detected by another CPU, not us. */
; 1210 :         if (regs->txf_why & TXF_WHY_DELAYED_ABORT)
; 1211 :         {
; 1212 :             char who[16] = {0};
; 1213 : 
; 1214 :             if (regs->txf_who < 0)
; 1215 :                 STRLCPY( who, "channel" );
; 1216 :             else if (regs->txf_who == regs->cpuad) // (shouldn't occur)
; 1217 :                 STRLCPY( who, "ourself" );
; 1218 :             else
; 1219 :                 MSGBUF( who, "%s%02X", PTYPSTR( regs->txf_who ), regs->txf_who );
; 1220 : 
; 1221 :             if (MLVL( VERBOSE ))
; 1222 :             {
; 1223 :                 // "TXF: %s%02X: %sAbort set by %s at %s"
; 1224 :                 WRMSG( HHC17720, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),
; 1225 :                     who, TRIMLOC( regs->txf_loc ));
; 1226 :             }
; 1227 :         }
; 1228 : 
; 1229 :         /* Print page map if requested */
; 1230 :         if (TXF_TRACE_MAP( regs, txf_contran ))
; 1231 :         {
; 1232 :             TPAGEMAP*  pmap;
; 1233 :             BYTE*      mainaddr;
; 1234 :             BYTE*      altaddr;
; 1235 :             int        i, j;
; 1236 : 
; 1237 :             pmap = regs->txf_pagesmap;
; 1238 : 
; 1239 :             for (i=0; i < regs->txf_pgcnt; i++, pmap++)
; 1240 :             {
; 1241 :                 if (TXF_TRACE_PAGES( regs, txf_contran ))
; 1242 :                 {
; 1243 :                     // "TXF: %s%02X: %svirt 0x%16.16"PRIX64", abs 0x%16.16"PRIX64", alt 0x%16.16"PRIX64
; 1244 :                     WRMSG( HHC17704, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),
; 1245 :                         (U64) pmap->virtpageaddr,
; 1246 :                         (U64)(pmap->mainpageaddr - regs->mainstor),
; 1247 :                         (U64) pmap->altpageaddr );
; 1248 :                 }
; 1249 : 
; 1250 :                 if (TXF_TRACE_LINES( regs, txf_contran ))
; 1251 :                 {
; 1252 :                     for (j=0; j < ZCACHE_LINE_PAGE; j++)
; 1253 :                     {
; 1254 :                         if (pmap->cachemap[j] == CM_CLEAN)
; 1255 :                             continue;
; 1256 : 
; 1257 :                         mainaddr = pmap->mainpageaddr + (j << ZCACHE_LINE_SHIFT);
; 1258 :                         altaddr  = pmap->altpageaddr  + (j << ZCACHE_LINE_SHIFT);
; 1259 : 
; 1260 :                         // "TXF: %s%02X: %sThere now:  +"
; 1261 :                         dump_cache( regs, TXF_DUMP_PFX( HHC17705 ), j, mainaddr );
; 1262 : 
; 1263 :                         if (pmap->cachemap[j] == CM_FETCHED)
; 1264 :                             // "TXF: %s%02X: %sWe fetched: +"
; 1265 :                             dump_cache( regs, TXF_DUMP_PFX( HHC17706 ), j, altaddr );
; 1266 :                         else
; 1267 :                             // "TXF: %s%02X: %sWe stored:  +"
; 1268 :                             dump_cache( regs, TXF_DUMP_PFX( HHC17707 ), j, altaddr );
; 1269 :                     }
; 1270 :                 }
; 1271 :             }
; 1272 :         }
; 1273 :     }
; 1274 : 
; 1275 :     /*---------------------------------------------*/
; 1276 :     /*  Clean up the transaction flags             */
; 1277 :     /*---------------------------------------------*/
; 1278 : 
; 1279 :     regs->txf_NTSTG     = false;
; 1280 :     regs->txf_contran   = false;
; 1281 :     regs->txf_tac       = 0;
; 1282 :     regs->txf_abortctr  = 0;
; 1283 :     regs->txf_instctr   = 0;
; 1284 :     regs->txf_pgcnt     = 0;
; 1285 :     regs->txf_conflict  = 0;
; 1286 :     regs->txf_piid      = 0;
; 1287 : 
; 1288 :     /*---------------------------------------------*/
; 1289 :     /*  Reset transaction nesting depth            */
; 1290 :     /*---------------------------------------------*/
; 1291 :     OBTAIN_TXFLOCK( regs );
; 1292 :     {
; 1293 :         regs->txf_tnd = 0;
; 1294 :     }
; 1295 :     RELEASE_TXFLOCK( regs );
; 1296 : 
; 1297 :     /* Reset CONSTRAINED trans instruction fetch constraint */
; 1298 :     ARCH_DEP( reset_txf_aie )( regs );
; 1299 : 
; 1300 :     /*-----------------------------------------------------*/
; 1301 :     /*    Trace program interrupt BEFORE updating PSW      */
; 1302 :     /*-----------------------------------------------------*/
; 1303 :     /*  If the retry code is ABORT_RETRY_PGMCHK, then we   */
; 1304 :     /*  will eventually be calling the program_interrupt   */
; 1305 :     /*  function for PGM_TRANSACTION_CONSTRAINT_EXCEPTION  */
; 1306 :     /*  so we MUST trace the program interrupt here. We    */
; 1307 :     /*  CANNOT let the program_interrupt function do that  */
; 1308 :     /*  for us like it normally does since it would report */
; 1309 :     /*  the wrong PSW. Thus we MUST do it ourselves here.  */
; 1310 :     /*-----------------------------------------------------*/
; 1311 : 
; 1312 :     if (retry == ABORT_RETRY_PGMCHK)
; 1313 :     {
; 1314 :         int pcode, ilc;
; 1315 : 
; 1316 :         pcode = PGM_TRANSACTION_CONSTRAINT_EXCEPTION | PGM_TXF_EVENT;
; 1317 : 
; 1318 :         if (raw_retry == -ABORT_RETRY_PGMCHK) // (negative?)
; 1319 :         {
; 1320 :             /* Instruction dispatch program interrupt: since the
; 1321 :                instruction has not been decoded yet (and the PSW
; 1322 :                and 'ip' pointer bumped appropriately (instead,
; 1323 :                it is pointing directly AT the failing instruction
; 1324 :                and not past it like normal)), we must bump the ip
; 1325 :                past the instruction that program checked so that
; 1326 :                the 'trace_program_interrupt' function can then
; 1327 :                back it up to point to the correct instruction.
; 1328 :             */
; 1329 :             ilc = ILC( *regs->ip );
; 1330 :             regs->ip += ilc;
; 1331 :             {
; 1332 :                 PTT_TXF( "TXF trpi+ilc", regs->ip, ilc, 0 );
; 1333 :                 ARCH_DEP( trace_program_interrupt )( regs, pcode, ilc );
; 1334 :             }
; 1335 :             regs->ip -= ilc;
; 1336 :         }
; 1337 :         else /* Normal program interrupt after instruction decode */
; 1338 :         {
; 1339 :             /* Fix PSW and get instruction length (ilc) */
; 1340 :             ilc = ARCH_DEP( fix_program_interrupt_PSW )( regs );
; 1341 : 
; 1342 :             /* Trace program checks other than PER event */
; 1343 :             PTT_TXF( "TXF trpi", regs->ip, ilc, 0 );
; 1344 :             ARCH_DEP( trace_program_interrupt )( regs, pcode, ilc );
; 1345 :         }
; 1346 : 
; 1347 :         /* Save the program interrupt id */
; 1348 :         txf_piid   = pcode;
; 1349 :         txf_piid  |= (ilc << 16);
; 1350 :     }
; 1351 : 
; 1352 :     /*----------------------------------------------------*/
; 1353 :     /*  Set the current PSW to the Transaction Abort PSW  */
; 1354 :     /*----------------------------------------------------*/
; 1355 : 
; 1356 :     /* PROGRAMMING NOTE: it's CRITICAL to invalidate the aia BEFORE
; 1357 :        setting the current PSW to the Transaction Abort PSW, since
; 1358 :        INVALIDATE_AIA *might* update the PSW's instruction address
; 1359 :        to a value different from what txf_tapsw says it should be!
; 1360 :     */
; 1361 :     INVALIDATE_AIA( regs ); // (do *before* PSW memcpy!)
; 1362 :     memcpy( &regs->psw, &regs->txf_tapsw, sizeof( PSW ));
; 1363 :     regs->ip  = regs->txf_ip;
; 1364 :     regs->aip = regs->txf_aip;
; 1365 :     regs->aiv = regs->txf_aiv;
; 1366 : 
; 1367 :     /*---------------------------------------------*/
; 1368 :     /*     Set the condition code in the PSW       */
; 1369 :     /*---------------------------------------------*/
; 1370 : 
; 1371 :     if (txf_tac && txf_tac < (int) _countof( tac2cc ))
; 1372 :                                     regs->psw.cc = tac2cc[ txf_tac ];
; 1373 :     else if (txf_tac == TAC_MISC)   regs->psw.cc = TXF_CC_TRANSIENT;
; 1374 :     else if (txf_tac >= TAC_TABORT) regs->psw.cc = TXF_CC_INDETERMINATE;
; 1375 : 
; 1376 :     /*---------------------------------------------*/
; 1377 :     /*      Put data/vector exception code         */
; 1378 :     /*    into byte 2 of FPCR if appropriate.      */
; 1379 :     /*---------------------------------------------*/
; 1380 : 
; 1381 :     if (1
; 1382 :         && (txf_piid & 0xFF) == PGM_DATA_EXCEPTION
; 1383 :         && regs->txf_ctlflag & TXF_CTL_FLOAT
; 1384 :         && regs->CR(0) & CR0_AFP
; 1385 :     )
; 1386 :     {
; 1387 :         regs->fpc &= ~((U32) 0xFF              << 8);
; 1388 :         regs->fpc |=  ((U32) regs->txf_dxc_vxc << 8);
; 1389 :     }
; 1390 : 
; 1391 :     /*------------------------------------------------*/
; 1392 :     /*               Populate TDBs                    */
; 1393 :     /*------------------------------------------------*/
; 1394 :     /*  Populate the TDBs. For program-interrupts,    */
; 1395 :     /*  the TDB is at fixed storage location 0x1800   */
; 1396 :     /*  in low core.  Additionally, the address of    */
; 1397 :     /*  a second TDB may be specified by the TBEGIN   */
; 1398 :     /*  instruction itself. (The operand-1 address    */
; 1399 :     /*  for TBEGINC is ignored.)                      */
; 1400 :     /*------------------------------------------------*/
; 1401 : 
; 1402 :     /* CONSTRAINED transaction or Program Interrupt?  */
; 1403 :     if (0
; 1404 :         || txf_contran          /* CONSTRAINED trans? */
; 1405 :         || txf_tac == TAC_UPGM  /* Unfiltered PGM?    */
; 1406 :         || txf_tac == TAC_FPGM  /* Filtered   PGM?    */
; 1407 :     )
; 1408 :     {
; 1409 :         RADR pi_tdba = 0x1800;
; 1410 :         pi_tdba = APPLY_PREFIXING( pi_tdba, regs->PX );
; 1411 :         pi_tdb = (TDB*)(regs->mainstor + pi_tdba);
; 1412 :     }
; 1413 : 
; 1414 :     /* TBEGIN-specified TDB? */
; 1415 :     if (!txf_contran && regs->txf_tdba_b1)
; 1416 :     {
; 1417 :         RADR  real_tdb;
; 1418 :         int   stid;
; 1419 :         int   xcode;
; 1420 : 
; 1421 :         /* Convert TDB address to absolute mainstor address */
; 1422 :         if ((xcode = ARCH_DEP( virt_to_real )( &real_tdb, &stid,
; 1423 :             regs->txf_tdba, regs->txf_tdba_b1, regs, ACCTYPE_WRITE )) == 0)
; 1424 :         {
; 1425 :             tb_tdb = (TDB*)(regs->mainstor + APPLY_PREFIXING( real_tdb, regs->PX ));
; 1426 :         }
; 1427 :         else
; 1428 :         {
; 1429 :             PTT_TXF( "*TXF vrfail", xcode, regs->txf_tdba, regs->txf_tdba_b1 );
; 1430 : 
; 1431 :             if (TXF_TRACING())
; 1432 :             {
; 1433 :                 // "TXF: %s%02X: %sTranslation exception %4.4hX (%s) on TBEGIN tdba 0x%16.16"PRIx64
; 1434 :                 WRMSG( HHC17713, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ),
; 1435 :                     (U16)xcode, PIC2Name( xcode ), regs->txf_tdba );
; 1436 :             }
; 1437 : 
; 1438 :             /* Transaction Abort processing, Note 4: "If the TDBA is
; 1439 :                valid, but the block has become inaccessible subsequent
; 1440 :                to the execution of the outermost TBEGIN instruction,
; 1441 :                the TDB is not accessed and condition code 1 applies."
; 1442 :             */
; 1443 :             regs->psw.cc = TXF_CC_INDETERMINATE;
; 1444 :         }
; 1445 :     }
; 1446 : 
; 1447 :     /*--------------------------------------------------*/
; 1448 :     /*             Populate our internal TDB            */
; 1449 :     /*--------------------------------------------------*/
; 1450 :     {
; 1451 :         regs->txf_tdb.tdb_format = 1;
; 1452 :         regs->txf_tdb.tdb_eaid   = regs->excarid;
; 1453 :         regs->txf_tdb.tdb_flags  = (txf_contran ? TDB_CTI : 0x00);
; 1454 : 
; 1455 :         if (0
; 1456 :             || txf_tac == TAC_FETCH_CNF
; 1457 :             || txf_tac == TAC_STORE_CNF
; 1458 :         )
; 1459 :             regs->txf_tdb.tdb_flags |= (txf_conflict ? TDB_CTV : 0x00);
; 1460 : 
; 1461 :         if (0
; 1462 :             || (txf_piid & 0xFF) == PGM_DATA_EXCEPTION
; 1463 :             || (txf_piid & 0xFF) == PGM_VECTOR_PROCESSING_EXCEPTION
; 1464 :         )
; 1465 :             regs->txf_tdb.tdb_dxc = regs->txf_dxc_vxc;
; 1466 : 
; 1467 :         STORE_HW( regs->txf_tdb.tdb_tnd,      (U16) txf_tnd      );
; 1468 :         STORE_DW( regs->txf_tdb.tdb_tac,      (U64) txf_tac      );
; 1469 :         STORE_DW( regs->txf_tdb.tdb_teid,     (U64) regs->TEA    );
; 1470 :         STORE_FW( regs->txf_tdb.tdb_piid,     (U32) txf_piid     );
; 1471 :         STORE_DW( regs->txf_tdb.tdb_atia,     (U64) txf_atia     );
; 1472 :         STORE_DW( regs->txf_tdb.tdb_conflict, (U64) txf_conflict );
; 1473 :         STORE_DW( regs->txf_tdb.tdb_bea,      (U64) txf_bea      );
; 1474 : 
; 1475 :         for (i=0; i < 16; i++)
; 1476 :             STORE_DW( regs->txf_tdb.tdb_gpr[i], regs->GR_G( i ));
; 1477 :     }
; 1478 : 
; 1479 :     /*----------------------------------------------------*/
; 1480 :     /*  Copy internal TDB to its proper storage location  */
; 1481 :     /*----------------------------------------------------*/
; 1482 : 
; 1483 :     if (pi_tdb)
; 1484 :     {
; 1485 :         memcpy( pi_tdb, &regs->txf_tdb, sizeof( TDB ));
; 1486 :         ARCH_DEP( or_storage_key )( MAIN_TO_ABS( pi_tdb ), (STORKEY_REF | STORKEY_CHANGE) );
; 1487 :     }
; 1488 : 
; 1489 :     if (tb_tdb)
; 1490 :     {
; 1491 :         memcpy( tb_tdb, &regs->txf_tdb, sizeof( TDB ));
; 1492 :         ARCH_DEP( or_storage_key )( MAIN_TO_ABS( tb_tdb ), (STORKEY_REF | STORKEY_CHANGE) );
; 1493 :     }
; 1494 : 
; 1495 :     /* Trace TDB if requested */
; 1496 :     if (TXF_TRACE_TDB( regs, txf_contran ))
; 1497 :         dump_tdb( regs, &regs->txf_tdb );
; 1498 : 
; 1499 :     /*----------------------------------------------------*/
; 1500 :     /*         Restore the requested registers            */
; 1501 :     /*----------------------------------------------------*/
; 1502 :     for (i=0; i < 16; i += 2, txf_gprmask <<= 1)
; 1503 :     {
; 1504 :         if (txf_gprmask & 0x80)
; 1505 :         {
; 1506 :             regs->gr[ i+0 ] = regs->txf_savedgr[ i+0 ];
; 1507 :             regs->gr[ i+1 ] = regs->txf_savedgr[ i+1 ];
; 1508 :         }
; 1509 :     }
; 1510 : 
; 1511 :     /*----------------------------------------------------*/
; 1512 :     /*                 Release INTLOCK                    */
; 1513 :     /*----------------------------------------------------*/
; 1514 :     /*  Release the interrupt lock if we obtained it, or  */
; 1515 :     /*  if we won't be directly returning. That is if we  */
; 1516 :     /*  will be jumping to progjmp via program_interrupt  */
; 1517 :     /*  or via SIE_NO_INTERCEPT, then we need to release  */
; 1518 :     /*  the interrupt lock beforehand. Otherwise if we    */
; 1519 :     /*  already held it when we were called, then we need */
; 1520 :     /*  to return to the caller with it still held.       */
; 1521 :     /*----------------------------------------------------*/
; 1522 : 
; 1523 :     if (!had_INTLOCK || retry != ABORT_RETRY_RETURN)
; 1524 :     {
; 1525 :         PERFORM_SERIALIZATION( regs );
; 1526 :         RELEASE_INTLOCK( regs );
; 1527 :     }
; 1528 : 
; 1529 :     /*----------------------------------------------------*/
; 1530 :     /*       RETURN TO CALLER OR JUMP AS REQUESTED        */
; 1531 :     /*----------------------------------------------------*/
; 1532 : 
; 1533 :     if (retry == ABORT_RETRY_RETURN)
; 1534 :     {
; 1535 :         /* Caller requested that we return back to
; 1536 :            them so they can decide what to do next.
; 1537 :            This 'retry' code is typically used by
; 1538 :            the various interrupt handlers (external,
; 1539 :            machine check, restart, program and I/O).
; 1540 :         */
; 1541 :         PTT_TXF( "*TXF abrtret", 0, txf_contran, txf_tnd );
; 1542 :         return; // (caller decides what to do next)
; 1543 :     }
; 1544 : 
; 1545 :     if (retry == ABORT_RETRY_CC)
; 1546 :     {
; 1547 :         /* Transaction failures have their PSW set to the
; 1548 :            Transaction Abort PSW, which for unconstrained
; 1549 :            transactions points to the instruction immediately
; 1550 :            following the TBEGIN instruction (so that the
; 1551 :            condition code can then be used to decide whether
; 1552 :            to bother retrying the transaction or not), and
; 1553 :            for constrained transactions points to the TBEGINC
; 1554 :            instruction itself (so that the transaction can
; 1555 :            then be unconditionally retried).
; 1556 : 
; 1557 :            Either way, we simply jump directly back to the
; 1558 :            'run_cpu' loop to redispatch this CPU, thereby
; 1559 :            causing it to continue executing instructions at
; 1560 :            where the Transaction Abort PSW said it should.
; 1561 :         */
; 1562 :         PTT_TXF( "*TXF abrtjmp", 0, txf_contran, txf_tnd );
; 1563 :         longjmp( regs->progjmp, SIE_NO_INTERCEPT );
; 1564 :         UNREACHABLE_CODE( return );
; 1565 :     }
; 1566 : 
; 1567 :     /*   (a transaction constraint has been violated...)   */
; 1568 : 
; 1569 :     ASSERT( retry == ABORT_RETRY_PGMCHK );  // (sanity check)
; 1570 : 
; 1571 :     /* The caller has requested via retry == ABORT_RETRY_PGMCHK
; 1572 :        that a program interrupt should be thrown for this aborted
; 1573 :        transaction. This of course implies an unfilterable program
; 1574 :        interrupt since transaction constraints cannot be ignored
; 1575 :        nor filtered. A program interrupt WILL occur. If it was a
; 1576 :        CONSTRAINED transaction, it will be retried at the TBEGINC
; 1577 :        instruction. For unconstrained transactions it will restart
; 1578 :        at the instruction immediately following TBEGIN instruction
; 1579 :        with a condition code of 3.
; 1580 :     */
; 1581 :     PTT_TXF( "*TXF abrtpgm", 0, txf_contran, txf_tnd );
; 1582 :     ARCH_DEP( program_interrupt )( regs,
; 1583 :         PGM_TXF_EVENT | PGM_TRANSACTION_CONSTRAINT_EXCEPTION );
; 1584 :     UNREACHABLE_CODE( return );
; 1585 : 
; 1586 : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 1587 : 
; 1588 : } /* end ARCH_DEP( abort_transaction ) */

  00044	48 83 c4 18	 add	 rsp, 24
  00048	c3		 ret	 0
s370_abort_transaction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
cmtype$ = 64
cacheidx$ = 68
pmap$ = 72
altpage$ = 80
i$ = 88
pageoffs$ = 92
txf_acctype$ = 96
cacheidxe$ = 100
tv152 = 104
tv154 = 108
tv161 = 112
txf_tac$1 = 116
tv211 = 120
txf_tac$2 = 124
tv262 = 128
tv283 = 132
addrpage$ = 136
endingoff$3 = 144
altpagec$ = 152
addrwork$ = 160
endlen$4 = 168
tv192 = 176
minlen$5 = 184
pageaddr$ = 192
savepage$ = 200
pageaddrc$ = 208
savepagec$ = 216
vaddr$ = 256
len$ = 264
arn$ = 272
regs$ = 280
acctype$ = 288
maddr$ = 296
txf_maddr_l PROC

; 2009 : {

$LN63:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
$LN4@txf_maddr_:

; 2010 :     BYTE *pageaddr, *pageaddrc;
; 2011 :     BYTE *savepage, *savepagec;
; 2012 :     BYTE *altpage,  *altpagec;
; 2013 : 
; 2014 :     U64  addrwork;              /* maddr converted to U64            */
; 2015 :     U64  addrpage;              /* Corresponding page address        */
; 2016 : 
; 2017 :     int  pageoffs;              /* addrwork offset into addrpage     */
; 2018 :     int  cacheidx;              /* Corresponding cache line          */
; 2019 :     int  cacheidxe;             /* Corresponding ending cache line   */
; 2020 :     int  i;                     /* Work variable                     */
; 2021 :     int  txf_acctype;           /* ACC_READ or ACC_WRITE             */
; 2022 : 
; 2023 :     BYTE cmtype;                /* Cache Map access type             */
; 2024 : 
; 2025 :     TPAGEMAP*  pmap;            /* Pointer to Transaction Page Map   */
; 2026 : 
; 2027 :     ASSERT( regs && regs->txf_tnd );      /* (sanity check) */

  0001d	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR regs$[rsp], 0
  00026	74 13		 je	 SHORT $LN32@txf_maddr_
  00028	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00030	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00037	85 c0		 test	 eax, eax
  00039	75 5c		 jne	 SHORT $LN31@txf_maddr_
$LN32@txf_maddr_:
$LN7@txf_maddr_:
  0003b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194042
  00042	41 b8 eb 07 00
	00		 mov	 r8d, 2027		; 000007ebH
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194043
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194044
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00062	85 c0		 test	 eax, eax
  00064	74 20		 je	 SHORT $LN33@txf_maddr_
  00066	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194046
  0006d	41 b8 eb 07 00
	00		 mov	 r8d, 2027		; 000007ebH
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194047
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194048
  00081	e8 00 00 00 00	 call	 DebuggerTrace
$LN33@txf_maddr_:
  00086	33 c0		 xor	 eax, eax
  00088	85 c0		 test	 eax, eax
  0008a	75 af		 jne	 SHORT $LN7@txf_maddr_
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00092	85 c0		 test	 eax, eax
  00094	74 01		 je	 SHORT $LN34@txf_maddr_
  00096	cc		 int	 3
$LN34@txf_maddr_:
$LN31@txf_maddr_:
  00097	33 c0		 xor	 eax, eax
  00099	85 c0		 test	 eax, eax
  0009b	75 80		 jne	 SHORT $LN4@txf_maddr_

; 2028 : 
; 2029 :     /* Check if our transaction has already been aborted */
; 2030 :     if (regs->txf_tac)

  0009d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a5	83 b8 08 af 00
	00 00		 cmp	 DWORD PTR [rax+44808], 0
  000ac	0f 84 12 01 00
	00		 je	 $LN35@txf_maddr_
$LN10@txf_maddr_:

; 2031 :     {
; 2032 :         PTT_TXF( "*TXF mad TAC", regs->txf_tac, regs->txf_contran, regs->txf_tnd );

  000b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000bc	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  000c2	48 85 c0	 test	 rax, rax
  000c5	74 5f		 je	 SHORT $LN36@txf_maddr_
  000c7	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cf	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000d6	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000de	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  000e5	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ed	48 63 92 08 af
	00 00		 movsxd	 rdx, DWORD PTR [rdx+44808]
  000f4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000fd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00102	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194052
  00109	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010e	44 8b c9	 mov	 r9d, ecx
  00111	4c 8b c2	 mov	 r8, rdx
  00114	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194053
  0011b	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@txf_maddr_:
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	75 86		 jne	 SHORT $LN10@txf_maddr_

; 2033 :         if (!(regs->txf_why & TXF_WHY_DELAYED_ABORT))

  0012c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00134	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0013a	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  0013f	85 c0		 test	 eax, eax
  00141	75 59		 jne	 SHORT $LN37@txf_maddr_

; 2034 :         {
; 2035 :             regs->txf_why  |=  TXF_WHY_DELAYED_ABORT;

  00143	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014b	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00151	0f ba e8 11	 bts	 eax, 17
  00155	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015d	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 2036 :             regs->txf_who   =  regs->cpuad;

  00163	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00172	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017a	89 81 10 af 00
	00		 mov	 DWORD PTR [rcx+44816], eax

; 2037 :             regs->txf_loc   =  TRIMLOC( PTT_LOC );

  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194055
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trimloc
  0018d	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00195	48 89 81 18 af
	00 00		 mov	 QWORD PTR [rcx+44824], rax
$LN37@txf_maddr_:

; 2038 :         }
; 2039 :         ABORT_TRANS( regs, ABORT_RETRY_CC, regs->txf_tac );

  0019c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194056
  001a3	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ab	44 8b 80 08 af
	00 00		 mov	 r8d, DWORD PTR [rax+44808]
  001b2	ba 01 00 00 00	 mov	 edx, 1
  001b7	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bf	e8 00 00 00 00	 call	 z900_abort_transaction
$LN35@txf_maddr_:

; 2040 :         UNREACHABLE_CODE( return maddr );
; 2041 :     }
; 2042 : 
; 2043 :     /* Normalize access type for TXF usage */
; 2044 :     txf_acctype = TXF_ACCTYPE( acctype );

  001c4	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  001cb	83 e0 04	 and	 eax, 4
  001ce	85 c0		 test	 eax, eax
  001d0	74 0a		 je	 SHORT $LN53@txf_maddr_
  001d2	c7 44 24 6c 04
	00 00 00	 mov	 DWORD PTR tv154[rsp], 4
  001da	eb 28		 jmp	 SHORT $LN54@txf_maddr_
$LN53@txf_maddr_:
  001dc	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  001e3	83 e0 03	 and	 eax, 3
  001e6	85 c0		 test	 eax, eax
  001e8	74 0a		 je	 SHORT $LN51@txf_maddr_
  001ea	c7 44 24 68 02
	00 00 00	 mov	 DWORD PTR tv152[rsp], 2
  001f2	eb 08		 jmp	 SHORT $LN52@txf_maddr_
$LN51@txf_maddr_:
  001f4	c7 44 24 68 04
	00 00 00	 mov	 DWORD PTR tv152[rsp], 4
$LN52@txf_maddr_:
  001fc	8b 44 24 68	 mov	 eax, DWORD PTR tv152[rsp]
  00200	89 44 24 6c	 mov	 DWORD PTR tv154[rsp], eax
$LN54@txf_maddr_:
  00204	8b 44 24 6c	 mov	 eax, DWORD PTR tv154[rsp]
  00208	89 44 24 60	 mov	 DWORD PTR txf_acctype$[rsp], eax

; 2045 : 
; 2046 :     /*  Constrained transactions constraint #4: "The transaction's
; 2047 :         storage operands access no more than four octowords. Note:
; 2048 :         LOAD ON CONDITION and STORE ON CONDITION are considered to
; 2049 :         reference storage regardless of the condition code."
; 2050 :         (SA22-7832-12, page 5-109)
; 2051 :     */
; 2052 :     if (regs->txf_contran && len > (4 * ZOCTOWORD_SIZE))

  0020c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00214	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0021b	85 c0		 test	 eax, eax
  0021d	0f 84 e4 00 00
	00		 je	 $LN38@txf_maddr_
  00223	48 81 bc 24 08
	01 00 00 80 00
	00 00		 cmp	 QWORD PTR len$[rsp], 128 ; 00000080H
  0022f	0f 86 d2 00 00
	00		 jbe	 $LN38@txf_maddr_

; 2053 :     {
; 2054 :         int txf_tac = TXF_IS_FETCH_ACCTYPE() ? TAC_FETCH_OVF

  00235	8b 44 24 60	 mov	 eax, DWORD PTR txf_acctype$[rsp]
  00239	83 e0 04	 and	 eax, 4
  0023c	85 c0		 test	 eax, eax
  0023e	74 0a		 je	 SHORT $LN55@txf_maddr_
  00240	c7 44 24 70 07
	00 00 00	 mov	 DWORD PTR tv161[rsp], 7
  00248	eb 08		 jmp	 SHORT $LN56@txf_maddr_
$LN55@txf_maddr_:
  0024a	c7 44 24 70 08
	00 00 00	 mov	 DWORD PTR tv161[rsp], 8
$LN56@txf_maddr_:
  00252	8b 44 24 70	 mov	 eax, DWORD PTR tv161[rsp]
  00256	89 44 24 74	 mov	 DWORD PTR txf_tac$1[rsp], eax

; 2055 :                                              : TAC_STORE_OVF;
; 2056 :         regs->txf_why |= TXF_WHY_CONSTRAINT_4;

  0025a	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00262	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00268	83 c8 02	 or	 eax, 2
  0026b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00273	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
$LN13@txf_maddr_:

; 2057 :         PTT_TXF( "*TXF mad len", txf_tac, regs->txf_contran, regs->txf_tnd );

  00279	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00280	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00283	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00289	48 85 c0	 test	 rax, rax
  0028c	74 55		 je	 SHORT $LN39@txf_maddr_
  0028e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00296	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0029d	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a5	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  002ac	48 63 54 24 74	 movsxd	 rdx, DWORD PTR txf_tac$1[rsp]
  002b1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002ba	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194059
  002c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002cb	44 8b c9	 mov	 r9d, ecx
  002ce	4c 8b c2	 mov	 r8, rdx
  002d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194060
  002d8	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  002dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@txf_maddr_:
  002e3	33 c0		 xor	 eax, eax
  002e5	85 c0		 test	 eax, eax
  002e7	75 90		 jne	 SHORT $LN13@txf_maddr_

; 2058 :         ABORT_TRANS( regs, ABORT_RETRY_CC, txf_tac );

  002e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194061
  002f0	44 8b 44 24 74	 mov	 r8d, DWORD PTR txf_tac$1[rsp]
  002f5	ba 01 00 00 00	 mov	 edx, 1
  002fa	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00302	e8 00 00 00 00	 call	 z900_abort_transaction
$LN38@txf_maddr_:

; 2059 :         UNREACHABLE_CODE( return maddr );
; 2060 :     }
; 2061 : 
; 2062 :     /* Save last translation arn */
; 2063 :     regs->txf_lastarn = arn;

  00307	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030f	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR arn$[rsp]
  00316	89 88 88 af 00
	00		 mov	 DWORD PTR [rax+44936], ecx

; 2064 : 
; 2065 :     /* Calculate range of cache lines for this storage access */
; 2066 : 
; 2067 :     addrwork = (U64) maddr;                     /* convert to U64    */

  0031c	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR maddr$[rsp]
  00324	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR addrwork$[rsp], rax

; 2068 :     addrpage = addrwork & ZPAGEFRAME_PAGEMASK;  /* address of page   */

  0032c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR addrwork$[rsp]
  00334	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0033a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR addrpage$[rsp], rax

; 2069 :     pageoffs = addrwork & ZPAGEFRAME_BYTEMASK;  /* offset into page  */

  00342	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR addrwork$[rsp]
  0034a	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00350	89 44 24 5c	 mov	 DWORD PTR pageoffs$[rsp], eax

; 2070 : 
; 2071 :     /* Calculate starting cache line */
; 2072 :     cacheidx = pageoffs >> ZCACHE_LINE_SHIFT;   /* data cache line   */

  00354	8b 44 24 5c	 mov	 eax, DWORD PTR pageoffs$[rsp]
  00358	c1 f8 08	 sar	 eax, 8
  0035b	89 44 24 44	 mov	 DWORD PTR cacheidx$[rsp], eax

; 2073 : 
; 2074 :     /* Calculate ending cache line */
; 2075 :     {
; 2076 :         /* Length from data to end of page */
; 2077 :         size_t  endlen  = ZPAGEFRAME_PAGESIZE - (vaddr & ZPAGEFRAME_BYTEMASK);

  0035f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR vaddr$[rsp]
  00367	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0036d	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00372	48 2b c8	 sub	 rcx, rax
  00375	48 8b c1	 mov	 rax, rcx
  00378	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR endlen$4[rsp], rax

; 2078 : 
; 2079 :         /* Lesser of that length and actual data length */
; 2080 :         size_t  minlen  = MIN( len, endlen );

  00380	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR endlen$4[rsp]
  00388	48 39 84 24 08
	01 00 00	 cmp	 QWORD PTR len$[rsp], rax
  00390	73 12		 jae	 SHORT $LN57@txf_maddr_
  00392	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR len$[rsp]
  0039a	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv192[rsp], rax
  003a2	eb 10		 jmp	 SHORT $LN58@txf_maddr_
$LN57@txf_maddr_:
  003a4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR endlen$4[rsp]
  003ac	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv192[rsp], rax
$LN58@txf_maddr_:
  003b4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv192[rsp]
  003bc	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR minlen$5[rsp], rax

; 2081 : 
; 2082 :         /* Page offset to end of data */
; 2083 :         int  endingoff  = pageoffs + minlen;

  003c4	48 63 44 24 5c	 movsxd	 rax, DWORD PTR pageoffs$[rsp]
  003c9	48 03 84 24 b8
	00 00 00	 add	 rax, QWORD PTR minlen$5[rsp]
  003d1	89 84 24 90 00
	00 00		 mov	 DWORD PTR endingoff$3[rsp], eax

; 2084 : 
; 2085 :         /* Data ends on this cache line */
; 2086 :         cacheidxe = endingoff >> ZCACHE_LINE_SHIFT;

  003d8	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR endingoff$3[rsp]
  003df	c1 f8 08	 sar	 eax, 8
  003e2	89 44 24 64	 mov	 DWORD PTR cacheidxe$[rsp], eax

; 2087 : 
; 2088 :         if (cacheidxe > (ZCACHE_LINE_PAGE - 1))

  003e6	83 7c 24 64 0f	 cmp	 DWORD PTR cacheidxe$[rsp], 15
  003eb	7e 08		 jle	 SHORT $LN40@txf_maddr_

; 2089 :             cacheidxe = (ZCACHE_LINE_PAGE - 1);

  003ed	c7 44 24 64 0f
	00 00 00	 mov	 DWORD PTR cacheidxe$[rsp], 15
$LN40@txf_maddr_:

; 2090 :     }
; 2091 : 
; 2092 :     /* Check if we have already captured this page and if not,
; 2093 :        capture it and save a copy.  The copy is used at commit
; 2094 :        time to determine if any unexpected changes were made.
; 2095 :     */
; 2096 :     altpage = NULL;

  003f5	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR altpage$[rsp], 0

; 2097 :     pmap = regs->txf_pagesmap;

  003fe	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00406	48 05 80 0e 00
	00		 add	 rax, 3712		; 00000e80H
  0040c	48 89 44 24 48	 mov	 QWORD PTR pmap$[rsp], rax

; 2098 : 
; 2099 :     /* Check if page already mapped. If so, use it */
; 2100 :     for (i=0; i < regs->txf_pgcnt; i++, pmap++)

  00411	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00419	eb 18		 jmp	 SHORT $LN16@txf_maddr_
$LN14@txf_maddr_:
  0041b	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  0041f	ff c0		 inc	 eax
  00421	89 44 24 58	 mov	 DWORD PTR i$[rsp], eax
  00425	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  0042a	48 83 c0 28	 add	 rax, 40			; 00000028H
  0042e	48 89 44 24 48	 mov	 QWORD PTR pmap$[rsp], rax
$LN16@txf_maddr_:
  00433	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0043b	8b 80 80 ae 00
	00		 mov	 eax, DWORD PTR [rax+44672]
  00441	39 44 24 58	 cmp	 DWORD PTR i$[rsp], eax
  00445	7d 25		 jge	 SHORT $LN15@txf_maddr_

; 2101 :     {
; 2102 :         if (addrpage == (U64) pmap->mainpageaddr)

  00447	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  0044c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00450	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR addrpage$[rsp], rax
  00458	75 10		 jne	 SHORT $LN41@txf_maddr_

; 2103 :         {
; 2104 :             altpage = pmap->altpageaddr;

  0045a	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  0045f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00463	48 89 44 24 50	 mov	 QWORD PTR altpage$[rsp], rax

; 2105 :             break;

  00468	eb 02		 jmp	 SHORT $LN15@txf_maddr_
$LN41@txf_maddr_:

; 2106 :         }
; 2107 :     }

  0046a	eb af		 jmp	 SHORT $LN14@txf_maddr_
$LN15@txf_maddr_:

; 2108 : 
; 2109 :     /* If not mapped yet, capture real page and save a copy */
; 2110 :     if (!altpage)

  0046c	48 83 7c 24 50
	00		 cmp	 QWORD PTR altpage$[rsp], 0
  00472	0f 85 b1 01 00
	00		 jne	 $LN42@txf_maddr_

; 2111 :     {
; 2112 :         /* Abort transaction if too many pages were touched */
; 2113 :         if (regs->txf_pgcnt >= MAX_TXF_PAGES)

  00478	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00480	81 b8 80 ae 00
	00 00 04 00 00	 cmp	 DWORD PTR [rax+44672], 1024 ; 00000400H
  0048a	0f 8c d3 00 00
	00		 jl	 $LN43@txf_maddr_

; 2114 :         {
; 2115 :             int txf_tac = TXF_IS_FETCH_ACCTYPE() ?

  00490	8b 44 24 60	 mov	 eax, DWORD PTR txf_acctype$[rsp]
  00494	83 e0 04	 and	 eax, 4
  00497	85 c0		 test	 eax, eax
  00499	74 0a		 je	 SHORT $LN59@txf_maddr_
  0049b	c7 44 24 78 07
	00 00 00	 mov	 DWORD PTR tv211[rsp], 7
  004a3	eb 08		 jmp	 SHORT $LN60@txf_maddr_
$LN59@txf_maddr_:
  004a5	c7 44 24 78 08
	00 00 00	 mov	 DWORD PTR tv211[rsp], 8
$LN60@txf_maddr_:
  004ad	8b 44 24 78	 mov	 eax, DWORD PTR tv211[rsp]
  004b1	89 44 24 7c	 mov	 DWORD PTR txf_tac$2[rsp], eax

; 2116 :                 TAC_FETCH_OVF : TAC_STORE_OVF;
; 2117 :             regs->txf_why |= TXF_WHY_MAX_PAGES;

  004b5	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004bd	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  004c3	0f ba e8 18	 bts	 eax, 24
  004c7	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004cf	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
$LN19@txf_maddr_:

; 2118 : 
; 2119 :             PTT_TXF( "*TXF mad max", txf_tac, regs->txf_contran, regs->txf_tnd );

  004d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004df	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  004e5	48 85 c0	 test	 rax, rax
  004e8	74 55		 je	 SHORT $LN44@txf_maddr_
  004ea	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f2	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  004f9	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00501	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00508	48 63 54 24 7c	 movsxd	 rdx, DWORD PTR txf_tac$2[rsp]
  0050d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00516	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0051b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194067
  00522	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00527	44 8b c9	 mov	 r9d, ecx
  0052a	4c 8b c2	 mov	 r8, rdx
  0052d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194068
  00534	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00539	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN44@txf_maddr_:
  0053f	33 c0		 xor	 eax, eax
  00541	85 c0		 test	 eax, eax
  00543	75 90		 jne	 SHORT $LN19@txf_maddr_

; 2120 :             ABORT_TRANS( regs, ABORT_RETRY_CC, txf_tac );

  00545	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194069
  0054c	44 8b 44 24 7c	 mov	 r8d, DWORD PTR txf_tac$2[rsp]
  00551	ba 01 00 00 00	 mov	 edx, 1
  00556	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0055e	e8 00 00 00 00	 call	 z900_abort_transaction
$LN43@txf_maddr_:

; 2121 :             UNREACHABLE_CODE( return maddr );
; 2122 :         }
; 2123 : 
; 2124 :         pageaddr = (BYTE*) addrpage;

  00563	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR addrpage$[rsp]
  0056b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pageaddr$[rsp], rax

; 2125 :         pmap     = &regs->txf_pagesmap[ regs->txf_pgcnt ];

  00573	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057b	48 63 80 80 ae
	00 00		 movsxd	 rax, DWORD PTR [rax+44672]
  00582	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00586	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0058e	48 8d 84 01 80
	0e 00 00	 lea	 rax, QWORD PTR [rcx+rax+3712]
  00596	48 89 44 24 48	 mov	 QWORD PTR pmap$[rsp], rax

; 2126 :         altpage  = pmap->altpageaddr;

  0059b	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  005a0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  005a4	48 89 44 24 50	 mov	 QWORD PTR altpage$[rsp], rax

; 2127 :         savepage = altpage + ZPAGEFRAME_PAGESIZE;

  005a9	48 8b 44 24 50	 mov	 rax, QWORD PTR altpage$[rsp]
  005ae	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  005b4	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR savepage$[rsp], rax

; 2128 : 
; 2129 :         /* Capture a copy of this page */
; 2130 :         memcpy( altpage,  pageaddr, ZPAGEFRAME_PAGESIZE );

  005bc	48 8b 7c 24 50	 mov	 rdi, QWORD PTR altpage$[rsp]
  005c1	48 8b b4 24 c0
	00 00 00	 mov	 rsi, QWORD PTR pageaddr$[rsp]
  005c9	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  005ce	f3 a4		 rep movsb

; 2131 :         memcpy( savepage, altpage,  ZPAGEFRAME_PAGESIZE );

  005d0	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR savepage$[rsp]
  005d8	48 8b 74 24 50	 mov	 rsi, QWORD PTR altpage$[rsp]
  005dd	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  005e2	f3 a4		 rep movsb

; 2132 : 
; 2133 :         /* Finish mapping this page */
; 2134 :         pmap->mainpageaddr = (BYTE*) addrpage;

  005e4	48 8b 44 24 48	 mov	 rax, QWORD PTR pmap$[rsp]
  005e9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR addrpage$[rsp]
  005f1	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2135 :         pmap->virtpageaddr = vaddr & ZPAGEFRAME_PAGEMASK;

  005f5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR vaddr$[rsp]
  005fd	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00603	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pmap$[rsp]
  00608	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2136 :         regs->txf_pgcnt++;

  0060b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00613	8b 80 80 ae 00
	00		 mov	 eax, DWORD PTR [rax+44672]
  00619	ff c0		 inc	 eax
  0061b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00623	89 81 80 ae 00
	00		 mov	 DWORD PTR [rcx+44672], eax
$LN42@txf_maddr_:

; 2137 :     }
; 2138 : 
; 2139 :     /* Calculate alternate address and cache map access type */
; 2140 :     maddr = altpage + pageoffs;

  00629	48 63 44 24 5c	 movsxd	 rax, DWORD PTR pageoffs$[rsp]
  0062e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR altpage$[rsp]
  00633	48 03 c8	 add	 rcx, rax
  00636	48 8b c1	 mov	 rax, rcx
  00639	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR maddr$[rsp], rax

; 2141 :     cmtype = TXF_IS_FETCH_ACCTYPE() ? CM_FETCHED : CM_STORED;

  00641	8b 44 24 60	 mov	 eax, DWORD PTR txf_acctype$[rsp]
  00645	83 e0 04	 and	 eax, 4
  00648	85 c0		 test	 eax, eax
  0064a	74 0d		 je	 SHORT $LN61@txf_maddr_
  0064c	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv262[rsp], 1
  00657	eb 0b		 jmp	 SHORT $LN62@txf_maddr_
$LN61@txf_maddr_:
  00659	c7 84 24 80 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv262[rsp], 2
$LN62@txf_maddr_:
  00664	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR tv262[rsp]
  0066c	88 44 24 40	 mov	 BYTE PTR cmtype$[rsp], al
$LN22@txf_maddr_:

; 2142 : 
; 2143 :     PTT_TXF( "TXF maddr_l:", addrpage, altpage, regs->txf_tnd );

  00670	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00677	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0067a	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00680	48 85 c0	 test	 rax, rax
  00683	74 48		 je	 SHORT $LN45@txf_maddr_
  00685	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0068d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00694	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0069d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194071
  006a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006ae	4c 8b 4c 24 50	 mov	 r9, QWORD PTR altpage$[rsp]
  006b3	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR addrpage$[rsp]
  006bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194072
  006c2	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  006c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN45@txf_maddr_:
  006cd	33 c0		 xor	 eax, eax
  006cf	85 c0		 test	 eax, eax
  006d1	75 9d		 jne	 SHORT $LN22@txf_maddr_

; 2144 : 
; 2145 :     /* Update page map's cache line indicators for this reference */
; 2146 :     for (; cacheidx <= cacheidxe; cacheidx++)

  006d3	eb 0a		 jmp	 SHORT $LN25@txf_maddr_
$LN23@txf_maddr_:
  006d5	8b 44 24 44	 mov	 eax, DWORD PTR cacheidx$[rsp]
  006d9	ff c0		 inc	 eax
  006db	89 44 24 44	 mov	 DWORD PTR cacheidx$[rsp], eax
$LN25@txf_maddr_:
  006df	8b 44 24 64	 mov	 eax, DWORD PTR cacheidxe$[rsp]
  006e3	39 44 24 44	 cmp	 DWORD PTR cacheidx$[rsp], eax
  006e7	0f 8f d8 00 00
	00		 jg	 $LN24@txf_maddr_

; 2147 :     {
; 2148 :         switch (pmap->cachemap[ cacheidx ])

  006ed	48 63 44 24 44	 movsxd	 rax, DWORD PTR cacheidx$[rsp]
  006f2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pmap$[rsp]
  006f7	0f b6 44 01 18	 movzx	 eax, BYTE PTR [rcx+rax+24]
  006fc	88 84 24 84 00
	00 00		 mov	 BYTE PTR tv283[rsp], al
  00703	80 bc 24 84 00
	00 00 00	 cmp	 BYTE PTR tv283[rsp], 0
  0070b	74 13		 je	 SHORT $LN46@txf_maddr_
  0070d	80 bc 24 84 00
	00 00 01	 cmp	 BYTE PTR tv283[rsp], 1
  00715	0f 84 92 00 00
	00		 je	 $LN47@txf_maddr_
  0071b	e9 a0 00 00 00	 jmp	 $LN26@txf_maddr_
$LN46@txf_maddr_:

; 2149 :         {
; 2150 :         case CM_CLEAN:
; 2151 : 
; 2152 :             /* Cache line WAS marked as being clean so we should now
; 2153 :                refresh it in order to pick up any potential changes.
; 2154 :             */
; 2155 :             pageaddrc = pmap->mainpageaddr + (cacheidx << ZCACHE_LINE_SHIFT);

  00720	8b 44 24 44	 mov	 eax, DWORD PTR cacheidx$[rsp]
  00724	c1 e0 08	 shl	 eax, 8
  00727	48 98		 cdqe
  00729	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pmap$[rsp]
  0072e	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00732	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR pageaddrc$[rsp], rax

; 2156 :             altpagec  = pmap->altpageaddr  + (cacheidx << ZCACHE_LINE_SHIFT);

  0073a	8b 44 24 44	 mov	 eax, DWORD PTR cacheidx$[rsp]
  0073e	c1 e0 08	 shl	 eax, 8
  00741	48 98		 cdqe
  00743	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pmap$[rsp]
  00748	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0074c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR altpagec$[rsp], rax

; 2157 :             savepagec = altpagec + ZPAGEFRAME_PAGESIZE;

  00754	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR altpagec$[rsp]
  0075c	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00762	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR savepagec$[rsp], rax

; 2158 : 
; 2159 :             memcpy( altpagec,  pageaddrc, ZCACHE_LINE_SIZE );

  0076a	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR altpagec$[rsp]
  00772	48 8b b4 24 d0
	00 00 00	 mov	 rsi, QWORD PTR pageaddrc$[rsp]
  0077a	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0077f	f3 a4		 rep movsb

; 2160 :             memcpy( savepagec, altpagec,  ZCACHE_LINE_SIZE );

  00781	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR savepagec$[rsp]
  00789	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR altpagec$[rsp]
  00791	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00796	f3 a4		 rep movsb

; 2161 : 
; 2162 :             /* Remember how we accessed this cache line */
; 2163 :             pmap->cachemap[ cacheidx ] = cmtype;

  00798	48 63 44 24 44	 movsxd	 rax, DWORD PTR cacheidx$[rsp]
  0079d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pmap$[rsp]
  007a2	0f b6 54 24 40	 movzx	 edx, BYTE PTR cmtype$[rsp]
  007a7	88 54 01 18	 mov	 BYTE PTR [rcx+rax+24], dl

; 2164 :             break;

  007ab	eb 13		 jmp	 SHORT $LN26@txf_maddr_
$LN47@txf_maddr_:

; 2165 : 
; 2166 :         case CM_FETCHED:
; 2167 : 
; 2168 :             /* Remember how we accessed this cache line */
; 2169 :             pmap->cachemap[ cacheidx ] = cmtype;

  007ad	48 63 44 24 44	 movsxd	 rax, DWORD PTR cacheidx$[rsp]
  007b2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pmap$[rsp]
  007b7	0f b6 54 24 40	 movzx	 edx, BYTE PTR cmtype$[rsp]
  007bc	88 54 01 18	 mov	 BYTE PTR [rcx+rax+24], dl
$LN26@txf_maddr_:

; 2170 :             break;
; 2171 : 
; 2172 :         case CM_STORED:
; 2173 : 
; 2174 :             /* Cache lines marked CM_STORED must stay that way */
; 2175 :             break;
; 2176 : 
; 2177 :         } /* switch (pmap->cachemap[cacheidx]) */
; 2178 : 
; 2179 :     } /* for (; cacheidx <= cacheidxe; cacheidx++) */

  007c0	e9 10 ff ff ff	 jmp	 $LN23@txf_maddr_
$LN24@txf_maddr_:
$LN30@txf_maddr_:

; 2180 : 
; 2181 :     /* Done. Return alternate address */
; 2182 :     PTT_TXF( "TXF maddr_l", maddr, len, regs->txf_tnd );

  007c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  007cc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007cf	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  007d5	48 85 c0	 test	 rax, rax
  007d8	74 4b		 je	 SHORT $LN49@txf_maddr_
  007da	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007e2	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  007e9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  007f2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194077
  007fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00803	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR len$[rsp]
  0080b	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR maddr$[rsp]
  00813	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194078
  0081a	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0081f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN49@txf_maddr_:
  00825	33 c0		 xor	 eax, eax
  00827	85 c0		 test	 eax, eax
  00829	75 9a		 jne	 SHORT $LN30@txf_maddr_

; 2183 :     return maddr;

  0082b	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR maddr$[rsp]
$LN50@txf_maddr_:

; 2184 : 
; 2185 : } /* end function txf_maddr_l */

  00833	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0083a	5f		 pop	 rdi
  0083b	5e		 pop	 rsi
  0083c	c3		 ret	 0
txf_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
rc$1 = 80
tv136 = 88
txf_enabled_or_enabling_txf$ = 112
txf_set_timerint PROC

; 2570 : {

$LN11:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2571 :     if (0
; 2572 :         || !sysblk.config_processed
; 2573 :         || sysblk.arch_mode != ARCH_900_IDX

  00008	33 c0		 xor	 eax, eax
  0000a	85 c0		 test	 eax, eax
  0000c	75 20		 jne	 SHORT $LN3@txf_set_ti
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00015	83 b8 98 12 00
	00 00		 cmp	 DWORD PTR [rax+4760], 0
  0001c	74 10		 je	 SHORT $LN3@txf_set_ti
  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00025	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  0002c	74 05		 je	 SHORT $LN2@txf_set_ti
$LN3@txf_set_ti:

; 2574 :     )
; 2575 :         return;

  0002e	e9 27 02 00 00	 jmp	 $LN1@txf_set_ti
$LN2@txf_set_ti:

; 2576 : 
; 2577 :     if (txf_enabled_or_enabling_txf)

  00033	0f b6 44 24 70	 movzx	 eax, BYTE PTR txf_enabled_or_enabling_txf$[rsp]
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 b5 01 00
	00		 je	 $LN4@txf_set_ti

; 2578 :     {
; 2579 :         if (sysblk.timerint >= MIN_TXF_TIMERINT)

  00040	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00047	81 b8 60 11 00
	00 c8 00 00 00	 cmp	 DWORD PTR [rax+4448], 200 ; 000000c8H
  00051	7c 1f		 jl	 SHORT $LN6@txf_set_ti

; 2580 :         {
; 2581 :             /* Use the user's defined timerint value for TXF */
; 2582 :             sysblk.txf_timerint = sysblk.timerint;

  00053	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0005a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00061	8b 89 60 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4448]
  00067	89 88 74 05 00
	00		 mov	 DWORD PTR [rax+1396], ecx

; 2583 :         }

  0006d	e9 82 00 00 00	 jmp	 $LN7@txf_set_ti
$LN6@txf_set_ti:

; 2584 :         else
; 2585 :         {
; 2586 :             // "TXF: TIMERINT %d is too small; using default of %d instead"
; 2587 :             WRMSG( HHC17736, "W", sysblk.timerint, DEF_TXF_TIMERINT );

  00072	b9 01 00 00 00	 mov	 ecx, 1
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007d	c7 44 24 40 90
	01 00 00	 mov	 DWORD PTR [rsp+64], 400	; 00000190H
  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0008c	8b 89 60 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4448]
  00092	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194555
  0009d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194556
  000a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194557
  000c0	ba 1b 0a 00 00	 mov	 edx, 2587		; 00000a1bH
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194558
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2588 : 
; 2589 :             sysblk.txf_timerint = sysblk.timerint = DEF_TXF_TIMERINT;

  000d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d9	c7 80 60 11 00
	00 90 01 00 00	 mov	 DWORD PTR [rax+4448], 400 ; 00000190H
  000e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ea	c7 80 74 05 00
	00 90 01 00 00	 mov	 DWORD PTR [rax+1396], 400 ; 00000190H
$LN7@txf_set_ti:

; 2590 :         }
; 2591 : 
; 2592 :         /* Start the rubato_thread if it hasn't been started yet */
; 2593 :         obtain_lock( &sysblk.rublock );

  000f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000fb	48 05 68 05 00
	00		 add	 rax, 1384		; 00000568H
  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194559
  00108	48 8b c8	 mov	 rcx, rax
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2594 :         {
; 2595 :             if (!sysblk.rubtid)

  00111	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00118	83 b8 64 05 00
	00 00		 cmp	 DWORD PTR [rax+1380], 0
  0011f	0f 85 b1 00 00
	00		 jne	 $LN8@txf_set_ti

; 2596 :             {
; 2597 :                 int rc = create_thread( &sysblk.rubtid, DETACHED,

  00125	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0012c	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  00132	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00139	48 81 c1 64 05
	00 00		 add	 rcx, 1380		; 00000564H
  00140	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194561
  00147	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194562
  00153	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00158	45 33 c9	 xor	 r9d, r9d
  0015b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:rubato_thread
  00162	48 8b d0	 mov	 rdx, rax
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  0016b	89 44 24 50	 mov	 DWORD PTR rc$1[rsp], eax

; 2598 :                      rubato_thread, NULL, RUBATO_THREAD_NAME );
; 2599 :                 if (rc)

  0016f	83 7c 24 50 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00174	74 60		 je	 SHORT $LN9@txf_set_ti

; 2600 :                     // "Error in function create_thread(): %s"
; 2601 :                     WRMSG( HHC00102, "E", strerror( rc ));

  00176	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$1[rsp]
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00180	48 89 44 24 58	 mov	 QWORD PTR tv136[rsp], rax
  00185	b9 01 00 00 00	 mov	 ecx, 1
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00190	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv136[rsp]
  00195	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0019a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194564
  001a1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194565
  001ad	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b7	41 b9 03 00 00
	00		 mov	 r9d, 3
  001bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194566
  001c4	ba 29 0a 00 00	 mov	 edx, 2601		; 00000a29H
  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194567
  001d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@txf_set_ti:
$LN8@txf_set_ti:

; 2602 :             }
; 2603 :         }
; 2604 :         release_lock( &sysblk.rublock );

  001d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001dd	48 05 68 05 00
	00		 add	 rax, 1384		; 00000568H
  001e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194568
  001ea	48 8b c8	 mov	 rcx, rax
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2605 :     }

  001f3	eb 65		 jmp	 SHORT $LN5@txf_set_ti
$LN4@txf_set_ti:

; 2606 :     else
; 2607 :     {
; 2608 :         /* Stop the rubato_thread if it's still running */
; 2609 :         obtain_lock( &sysblk.rublock );

  001f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001fc	48 05 68 05 00
	00		 add	 rax, 1384		; 00000568H
  00202	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194569
  00209	48 8b c8	 mov	 rcx, rax
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2610 :         {
; 2611 :             /* Tell rubato_thread to please exit */
; 2612 :             sysblk.rubtid = 0;

  00212	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00219	c7 80 64 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1380], 0

; 2613 :         }
; 2614 :         release_lock( &sysblk.rublock );

  00223	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0022a	48 05 68 05 00
	00		 add	 rax, 1384		; 00000568H
  00230	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194570
  00237	48 8b c8	 mov	 rcx, rax
  0023a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2615 : 
; 2616 :         /* Reset the timerint value back to its original value */
; 2617 :         sysblk.timerint = sysblk.cfg_timerint;

  00240	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00247	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0024e	8b 89 64 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4452]
  00254	89 88 60 11 00
	00		 mov	 DWORD PTR [rax+4448], ecx
$LN5@txf_set_ti:
$LN1@txf_set_ti:

; 2618 :     }
; 2619 : }

  0025a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0025e	c3		 ret	 0
txf_set_timerint ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
tv80 = 64
txf_enabled_or_enabling_txf$ = 96
txf_model_warning PROC

; 2552 : {

$LN4:
  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2553 :     if (1
; 2554 :         && sysblk.arch_mode == ARCH_900_IDX
; 2555 :         && txf_enabled_or_enabling_txf
; 2556 :         && sysblk.config_processed
; 2557 :         && !is_TXF_model( sysblk.cpumodel )
; 2558 :         && MLVL( VERBOSE )

  00008	33 c0		 xor	 eax, eax
  0000a	83 f8 01	 cmp	 eax, 1
  0000d	0f 84 c6 00 00
	00		 je	 $LN2@txf_model_
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001a	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  00021	0f 85 b2 00 00
	00		 jne	 $LN2@txf_model_
  00027	0f b6 44 24 60	 movzx	 eax, BYTE PTR txf_enabled_or_enabling_txf$[rsp]
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 a5 00 00
	00		 je	 $LN2@txf_model_
  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003b	83 b8 98 12 00
	00 00		 cmp	 DWORD PTR [rax+4760], 0
  00042	0f 84 91 00 00
	00		 je	 $LN2@txf_model_
  00048	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004f	0f b7 88 d4 00
	00 00		 movzx	 ecx, WORD PTR [rax+212]
  00056	e8 00 00 00 00	 call	 is_TXF_model
  0005b	0f b6 c0	 movzx	 eax, al
  0005e	85 c0		 test	 eax, eax
  00060	75 77		 jne	 SHORT $LN2@txf_model_
  00062	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00069	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  0006f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00074	85 c0		 test	 eax, eax
  00076	74 61		 je	 SHORT $LN2@txf_model_

; 2559 :     )
; 2560 :     {
; 2561 :         // "CPUMODEL %04X does not technically support TXF"
; 2562 :         WRMSG( HHC02385, "W", sysblk.cpumodel );

  00078	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007f	0f b7 80 d4 00
	00 00		 movzx	 eax, WORD PTR [rax+212]
  00086	89 44 24 40	 mov	 DWORD PTR tv80[rsp], eax
  0008a	b9 01 00 00 00	 mov	 ecx, 1
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00095	8b 4c 24 40	 mov	 ecx, DWORD PTR tv80[rsp]
  00099	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194540
  000a4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194541
  000b0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ba	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194542
  000c7	ba 02 0a 00 00	 mov	 edx, 2562		; 00000a02H
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194543
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@txf_model_:

; 2563 :     }
; 2564 : }

  000d9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000dd	c3		 ret	 0
txf_model_warning ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
i$ = 32
tv70 = 40
defsym_TXF_models PROC

; 2541 : {

$LN6:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2542 :     size_t i;
; 2543 :     for (i=0; i < _countof( txf_models ); i++)

  00004	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0000d	eb 0d		 jmp	 SHORT $LN4@defsym_TXF
$LN2@defsym_TXF:
  0000f	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00014	48 ff c0	 inc	 rax
  00017	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@defsym_TXF:
  0001c	48 83 7c 24 20
	0a		 cmp	 QWORD PTR i$[rsp], 10
  00022	73 36		 jae	 SHORT $LN3@defsym_TXF

; 2544 :         // e.g. "CPUMODEL $(z13s)"  ==>  "CPUMODEL 2965"
; 2545 :         set_symbol( txf_models[i].pszSymbol, txf_models[i].pszModel );

  00024	48 6b 44 24 20
	18		 imul	 rax, QWORD PTR i$[rsp], 24
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:txf_models
  00031	48 6b 54 24 20
	18		 imul	 rdx, QWORD PTR i$[rsp], 24
  00037	48 89 54 24 28	 mov	 QWORD PTR tv70[rsp], rdx
  0003c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:txf_models
  00043	48 8b 54 01 08	 mov	 rdx, QWORD PTR [rcx+rax+8]
  00048	48 8b 44 24 28	 mov	 rax, QWORD PTR tv70[rsp]
  0004d	49 8b 4c 00 10	 mov	 rcx, QWORD PTR [r8+rax+16]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol
  00058	eb b5		 jmp	 SHORT $LN2@defsym_TXF
$LN3@defsym_TXF:

; 2546 : }

  0005a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005e	c3		 ret	 0
defsym_TXF_models ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
i$ = 0
cpumodel$ = 32
is_TXF_model PROC

; 2529 : {

$LN7:
  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 18	 sub	 rsp, 24

; 2530 :     size_t i;
; 2531 :     for (i=0; i < _countof( txf_models ); i++)

  00009	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00011	eb 0b		 jmp	 SHORT $LN4@is_TXF_mod
$LN2@is_TXF_mod:
  00013	48 8b 04 24	 mov	 rax, QWORD PTR i$[rsp]
  00017	48 ff c0	 inc	 rax
  0001a	48 89 04 24	 mov	 QWORD PTR i$[rsp], rax
$LN4@is_TXF_mod:
  0001e	48 83 3c 24 0a	 cmp	 QWORD PTR i$[rsp], 10
  00023	73 1f		 jae	 SHORT $LN3@is_TXF_mod

; 2532 :         if (cpumodel == txf_models[i].cpumodel)

  00025	0f b7 44 24 20	 movzx	 eax, WORD PTR cpumodel$[rsp]
  0002a	48 6b 0c 24 18	 imul	 rcx, QWORD PTR i$[rsp], 24
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:txf_models
  00036	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  0003a	3b c1		 cmp	 eax, ecx
  0003c	75 04		 jne	 SHORT $LN5@is_TXF_mod

; 2533 :             return true;

  0003e	b0 01		 mov	 al, 1
  00040	eb 04		 jmp	 SHORT $LN1@is_TXF_mod
$LN5@is_TXF_mod:
  00042	eb cf		 jmp	 SHORT $LN2@is_TXF_mod
$LN3@is_TXF_mod:

; 2534 :     return false;

  00044	32 c0		 xor	 al, al
$LN1@is_TXF_mod:

; 2535 : }

  00046	48 83 c4 18	 add	 rsp, 24
  0004a	c3		 ret	 0
is_TXF_model ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
tv68 = 288
tv72 = 296
tv76 = 304
tv80 = 312
tv84 = 320
tv88 = 328
tv92 = 336
tv128 = 344
tv132 = 352
tv136 = 360
tv140 = 368
tv144 = 376
tv148 = 384
tv152 = 392
tv156 = 400
tv192 = 408
tv196 = 416
tv200 = 424
tv204 = 432
tv208 = 440
tv212 = 448
tv216 = 456
tv220 = 464
tv224 = 472
tv228 = 480
tv232 = 488
tv236 = 496
tv240 = 504
tv244 = 512
tv248 = 520
tv252 = 528
buffer$ = 560
buffsize$ = 568
why$ = 576
txf_why_str PROC

; 2245 : {

$LN65:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 28 02
	00 00		 sub	 rsp, 552		; 00000228H

; 2246 :     #define TXF_WHY_FORMAT( _why ) ((why & _why) ? " " #_why : "")
; 2247 : 
; 2248 :     //                           1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
; 2249 :     snprintf( buffer, buffsize, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s"

  00015	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  0001c	83 e0 02	 and	 eax, 2
  0001f	85 c0		 test	 eax, eax
  00021	74 11		 je	 SHORT $LN3@txf_why_st
  00023	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194148
  0002a	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv68[rsp], rax
  00032	eb 0f		 jmp	 SHORT $LN4@txf_why_st
$LN3@txf_why_st:
  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194149
  0003b	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv68[rsp], rax
$LN4@txf_why_st:
  00043	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  0004a	83 e0 04	 and	 eax, 4
  0004d	85 c0		 test	 eax, eax
  0004f	74 11		 je	 SHORT $LN5@txf_why_st
  00051	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194150
  00058	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv72[rsp], rax
  00060	eb 0f		 jmp	 SHORT $LN6@txf_why_st
$LN5@txf_why_st:
  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194151
  00069	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv72[rsp], rax
$LN6@txf_why_st:
  00071	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00078	83 e0 08	 and	 eax, 8
  0007b	85 c0		 test	 eax, eax
  0007d	74 11		 je	 SHORT $LN7@txf_why_st
  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194152
  00086	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv76[rsp], rax
  0008e	eb 0f		 jmp	 SHORT $LN8@txf_why_st
$LN7@txf_why_st:
  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194153
  00097	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv76[rsp], rax
$LN8@txf_why_st:
  0009f	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  000a6	83 e0 10	 and	 eax, 16
  000a9	85 c0		 test	 eax, eax
  000ab	74 11		 je	 SHORT $LN9@txf_why_st
  000ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194154
  000b4	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv80[rsp], rax
  000bc	eb 0f		 jmp	 SHORT $LN10@txf_why_st
$LN9@txf_why_st:
  000be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194155
  000c5	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv80[rsp], rax
$LN10@txf_why_st:
  000cd	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  000d4	83 e0 20	 and	 eax, 32			; 00000020H
  000d7	85 c0		 test	 eax, eax
  000d9	74 11		 je	 SHORT $LN11@txf_why_st
  000db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194156
  000e2	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv84[rsp], rax
  000ea	eb 0f		 jmp	 SHORT $LN12@txf_why_st
$LN11@txf_why_st:
  000ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194157
  000f3	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv84[rsp], rax
$LN12@txf_why_st:
  000fb	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00102	83 e0 40	 and	 eax, 64			; 00000040H
  00105	85 c0		 test	 eax, eax
  00107	74 11		 je	 SHORT $LN13@txf_why_st
  00109	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194158
  00110	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv88[rsp], rax
  00118	eb 0f		 jmp	 SHORT $LN14@txf_why_st
$LN13@txf_why_st:
  0011a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194159
  00121	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv88[rsp], rax
$LN14@txf_why_st:
  00129	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00130	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00135	85 c0		 test	 eax, eax
  00137	74 11		 je	 SHORT $LN15@txf_why_st
  00139	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194160
  00140	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv92[rsp], rax
  00148	eb 0f		 jmp	 SHORT $LN16@txf_why_st
$LN15@txf_why_st:
  0014a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194161
  00151	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv92[rsp], rax
$LN16@txf_why_st:
  00159	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00160	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00165	85 c0		 test	 eax, eax
  00167	74 11		 je	 SHORT $LN17@txf_why_st
  00169	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194162
  00170	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv128[rsp], rax
  00178	eb 0f		 jmp	 SHORT $LN18@txf_why_st
$LN17@txf_why_st:
  0017a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194163
  00181	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv128[rsp], rax
$LN18@txf_why_st:
  00189	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00190	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00195	85 c0		 test	 eax, eax
  00197	74 11		 je	 SHORT $LN19@txf_why_st
  00199	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194164
  001a0	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv132[rsp], rax
  001a8	eb 0f		 jmp	 SHORT $LN20@txf_why_st
$LN19@txf_why_st:
  001aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194165
  001b1	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv132[rsp], rax
$LN20@txf_why_st:
  001b9	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  001c0	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  001c5	85 c0		 test	 eax, eax
  001c7	74 11		 je	 SHORT $LN21@txf_why_st
  001c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194166
  001d0	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv136[rsp], rax
  001d8	eb 0f		 jmp	 SHORT $LN22@txf_why_st
$LN21@txf_why_st:
  001da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194167
  001e1	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv136[rsp], rax
$LN22@txf_why_st:
  001e9	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  001f0	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  001f5	85 c0		 test	 eax, eax
  001f7	74 11		 je	 SHORT $LN23@txf_why_st
  001f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194168
  00200	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv140[rsp], rax
  00208	eb 0f		 jmp	 SHORT $LN24@txf_why_st
$LN23@txf_why_st:
  0020a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194169
  00211	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv140[rsp], rax
$LN24@txf_why_st:
  00219	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00220	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  00225	85 c0		 test	 eax, eax
  00227	74 11		 je	 SHORT $LN25@txf_why_st
  00229	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194170
  00230	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv144[rsp], rax
  00238	eb 0f		 jmp	 SHORT $LN26@txf_why_st
$LN25@txf_why_st:
  0023a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194171
  00241	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv144[rsp], rax
$LN26@txf_why_st:
  00249	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00250	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00255	85 c0		 test	 eax, eax
  00257	74 11		 je	 SHORT $LN27@txf_why_st
  00259	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194172
  00260	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv148[rsp], rax
  00268	eb 0f		 jmp	 SHORT $LN28@txf_why_st
$LN27@txf_why_st:
  0026a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194173
  00271	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv148[rsp], rax
$LN28@txf_why_st:
  00279	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00280	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00285	85 c0		 test	 eax, eax
  00287	74 11		 je	 SHORT $LN29@txf_why_st
  00289	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194174
  00290	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv152[rsp], rax
  00298	eb 0f		 jmp	 SHORT $LN30@txf_why_st
$LN29@txf_why_st:
  0029a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194175
  002a1	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv152[rsp], rax
$LN30@txf_why_st:
  002a9	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  002b0	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  002b5	85 c0		 test	 eax, eax
  002b7	74 11		 je	 SHORT $LN31@txf_why_st
  002b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194176
  002c0	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv156[rsp], rax
  002c8	eb 0f		 jmp	 SHORT $LN32@txf_why_st
$LN31@txf_why_st:
  002ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194177
  002d1	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv156[rsp], rax
$LN32@txf_why_st:
  002d9	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  002e0	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  002e5	85 c0		 test	 eax, eax
  002e7	74 11		 je	 SHORT $LN33@txf_why_st
  002e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194178
  002f0	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv192[rsp], rax
  002f8	eb 0f		 jmp	 SHORT $LN34@txf_why_st
$LN33@txf_why_st:
  002fa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194179
  00301	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv192[rsp], rax
$LN34@txf_why_st:
  00309	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00310	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00315	85 c0		 test	 eax, eax
  00317	74 11		 je	 SHORT $LN35@txf_why_st
  00319	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194180
  00320	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv196[rsp], rax
  00328	eb 0f		 jmp	 SHORT $LN36@txf_why_st
$LN35@txf_why_st:
  0032a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194181
  00331	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv196[rsp], rax
$LN36@txf_why_st:
  00339	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00340	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00345	85 c0		 test	 eax, eax
  00347	74 11		 je	 SHORT $LN37@txf_why_st
  00349	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194182
  00350	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv200[rsp], rax
  00358	eb 0f		 jmp	 SHORT $LN38@txf_why_st
$LN37@txf_why_st:
  0035a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194183
  00361	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv200[rsp], rax
$LN38@txf_why_st:
  00369	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00370	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00375	85 c0		 test	 eax, eax
  00377	74 11		 je	 SHORT $LN39@txf_why_st
  00379	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194184
  00380	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv204[rsp], rax
  00388	eb 0f		 jmp	 SHORT $LN40@txf_why_st
$LN39@txf_why_st:
  0038a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194185
  00391	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv204[rsp], rax
$LN40@txf_why_st:
  00399	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  003a0	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  003a5	85 c0		 test	 eax, eax
  003a7	74 11		 je	 SHORT $LN41@txf_why_st
  003a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194186
  003b0	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv208[rsp], rax
  003b8	eb 0f		 jmp	 SHORT $LN42@txf_why_st
$LN41@txf_why_st:
  003ba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194187
  003c1	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv208[rsp], rax
$LN42@txf_why_st:
  003c9	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  003d0	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  003d5	85 c0		 test	 eax, eax
  003d7	74 11		 je	 SHORT $LN43@txf_why_st
  003d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194188
  003e0	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv212[rsp], rax
  003e8	eb 0f		 jmp	 SHORT $LN44@txf_why_st
$LN43@txf_why_st:
  003ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194189
  003f1	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv212[rsp], rax
$LN44@txf_why_st:
  003f9	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00400	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00405	85 c0		 test	 eax, eax
  00407	74 11		 je	 SHORT $LN45@txf_why_st
  00409	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194190
  00410	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv216[rsp], rax
  00418	eb 0f		 jmp	 SHORT $LN46@txf_why_st
$LN45@txf_why_st:
  0041a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194191
  00421	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv216[rsp], rax
$LN46@txf_why_st:
  00429	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00430	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00435	85 c0		 test	 eax, eax
  00437	74 11		 je	 SHORT $LN47@txf_why_st
  00439	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194192
  00440	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv220[rsp], rax
  00448	eb 0f		 jmp	 SHORT $LN48@txf_why_st
$LN47@txf_why_st:
  0044a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194193
  00451	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv220[rsp], rax
$LN48@txf_why_st:
  00459	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00460	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00465	85 c0		 test	 eax, eax
  00467	74 11		 je	 SHORT $LN49@txf_why_st
  00469	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194194
  00470	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR tv224[rsp], rax
  00478	eb 0f		 jmp	 SHORT $LN50@txf_why_st
$LN49@txf_why_st:
  0047a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194195
  00481	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR tv224[rsp], rax
$LN50@txf_why_st:
  00489	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00490	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00495	85 c0		 test	 eax, eax
  00497	74 11		 je	 SHORT $LN51@txf_why_st
  00499	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194196
  004a0	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR tv228[rsp], rax
  004a8	eb 0f		 jmp	 SHORT $LN52@txf_why_st
$LN51@txf_why_st:
  004aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194197
  004b1	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR tv228[rsp], rax
$LN52@txf_why_st:
  004b9	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  004c0	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  004c5	85 c0		 test	 eax, eax
  004c7	74 11		 je	 SHORT $LN53@txf_why_st
  004c9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194198
  004d0	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR tv232[rsp], rax
  004d8	eb 0f		 jmp	 SHORT $LN54@txf_why_st
$LN53@txf_why_st:
  004da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194199
  004e1	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR tv232[rsp], rax
$LN54@txf_why_st:
  004e9	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  004f0	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  004f5	85 c0		 test	 eax, eax
  004f7	74 11		 je	 SHORT $LN55@txf_why_st
  004f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194200
  00500	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR tv236[rsp], rax
  00508	eb 0f		 jmp	 SHORT $LN56@txf_why_st
$LN55@txf_why_st:
  0050a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194201
  00511	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR tv236[rsp], rax
$LN56@txf_why_st:
  00519	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00520	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00525	85 c0		 test	 eax, eax
  00527	74 11		 je	 SHORT $LN57@txf_why_st
  00529	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194202
  00530	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR tv240[rsp], rax
  00538	eb 0f		 jmp	 SHORT $LN58@txf_why_st
$LN57@txf_why_st:
  0053a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194203
  00541	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR tv240[rsp], rax
$LN58@txf_why_st:
  00549	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00550	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00555	85 c0		 test	 eax, eax
  00557	74 11		 je	 SHORT $LN59@txf_why_st
  00559	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194204
  00560	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR tv244[rsp], rax
  00568	eb 0f		 jmp	 SHORT $LN60@txf_why_st
$LN59@txf_why_st:
  0056a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194205
  00571	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR tv244[rsp], rax
$LN60@txf_why_st:
  00579	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  00580	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00585	85 c0		 test	 eax, eax
  00587	74 11		 je	 SHORT $LN61@txf_why_st
  00589	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194206
  00590	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR tv248[rsp], rax
  00598	eb 0f		 jmp	 SHORT $LN62@txf_why_st
$LN61@txf_why_st:
  0059a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194207
  005a1	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR tv248[rsp], rax
$LN62@txf_why_st:
  005a9	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR why$[rsp]
  005b0	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  005b5	85 c0		 test	 eax, eax
  005b7	74 11		 je	 SHORT $LN63@txf_why_st
  005b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194208
  005c0	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR tv252[rsp], rax
  005c8	eb 0f		 jmp	 SHORT $LN64@txf_why_st
$LN63@txf_why_st:
  005ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194209
  005d1	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR tv252[rsp], rax
$LN64@txf_why_st:
  005d9	48 63 84 24 38
	02 00 00	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  005e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194147
  005e8	48 89 8c 24 10
	01 00 00	 mov	 QWORD PTR [rsp+272], rcx
  005f0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv68[rsp]
  005f8	48 89 8c 24 08
	01 00 00	 mov	 QWORD PTR [rsp+264], rcx
  00600	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv72[rsp]
  00608	48 89 8c 24 00
	01 00 00	 mov	 QWORD PTR [rsp+256], rcx
  00610	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv76[rsp]
  00618	48 89 8c 24 f8
	00 00 00	 mov	 QWORD PTR [rsp+248], rcx
  00620	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv80[rsp]
  00628	48 89 8c 24 f0
	00 00 00	 mov	 QWORD PTR [rsp+240], rcx
  00630	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv84[rsp]
  00638	48 89 8c 24 e8
	00 00 00	 mov	 QWORD PTR [rsp+232], rcx
  00640	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv88[rsp]
  00648	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR [rsp+224], rcx
  00650	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv92[rsp]
  00658	48 89 8c 24 d8
	00 00 00	 mov	 QWORD PTR [rsp+216], rcx
  00660	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv128[rsp]
  00668	48 89 8c 24 d0
	00 00 00	 mov	 QWORD PTR [rsp+208], rcx
  00670	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  00678	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR [rsp+200], rcx
  00680	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv136[rsp]
  00688	48 89 8c 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rcx
  00690	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv140[rsp]
  00698	48 89 8c 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], rcx
  006a0	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv144[rsp]
  006a8	48 89 8c 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rcx
  006b0	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR tv148[rsp]
  006b8	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rcx
  006c0	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR tv152[rsp]
  006c8	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rcx
  006d0	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR tv156[rsp]
  006d8	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rcx
  006e0	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR tv192[rsp]
  006e8	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rcx
  006f0	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR tv196[rsp]
  006f8	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rcx
  00700	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR tv200[rsp]
  00708	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rcx
  00710	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR tv204[rsp]
  00718	48 89 4c 24 78	 mov	 QWORD PTR [rsp+120], rcx
  0071d	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR tv208[rsp]
  00725	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  0072a	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR tv212[rsp]
  00732	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00737	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR tv216[rsp]
  0073f	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00744	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR tv220[rsp]
  0074c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00751	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR tv224[rsp]
  00759	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0075e	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR tv228[rsp]
  00766	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0076b	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR tv232[rsp]
  00773	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00778	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR tv236[rsp]
  00780	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00785	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR tv240[rsp]
  0078d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00792	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR tv244[rsp]
  0079a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0079f	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR tv248[rsp]
  007a7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  007ac	4c 8b 8c 24 10
	02 00 00	 mov	 r9, QWORD PTR tv252[rsp]
  007b4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194210
  007bb	48 8b d0	 mov	 rdx, rax
  007be	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  007c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2250 : 
; 2251 :         , TXF_WHY_FORMAT( TXF_WHY_INSTRADDR                ) // 1
; 2252 :         , TXF_WHY_FORMAT( TXF_WHY_INSTRCOUNT               ) // 2
; 2253 :         , TXF_WHY_FORMAT( TXF_WHY_RAND_ABORT               ) // 3
; 2254 :         , TXF_WHY_FORMAT( TXF_WHY_CSP_INSTR                ) // 4
; 2255 :         , TXF_WHY_FORMAT( TXF_WHY_CSPG_INSTR               ) // 5
; 2256 :         , TXF_WHY_FORMAT( TXF_WHY_SIE_EXIT                 ) // 6
; 2257 :         , TXF_WHY_FORMAT( TXF_WHY_CONFLICT                 ) // 7
; 2258 :         , TXF_WHY_FORMAT( TXF_WHY_MAX_PAGES                ) // 8
; 2259 :         , TXF_WHY_FORMAT( TXF_WHY_EXT_INT                  ) // 9
; 2260 :         , TXF_WHY_FORMAT( TXF_WHY_UNFILT_INT               ) // 10
; 2261 :         , TXF_WHY_FORMAT( TXF_WHY_FILT_INT                 ) // 11
; 2262 :         , TXF_WHY_FORMAT( TXF_WHY_RESTART_INT              ) // 12
; 2263 :         , TXF_WHY_FORMAT( TXF_WHY_IO_INT                   ) // 13
; 2264 :         , TXF_WHY_FORMAT( TXF_WHY_MCK_INT                  ) // 14
; 2265 :         , TXF_WHY_FORMAT( TXF_WHY_DELAYED_ABORT            ) // 15
; 2266 :         , TXF_WHY_FORMAT( TXF_WHY_TABORT_INSTR             ) // 16
; 2267 :         , TXF_WHY_FORMAT( TXF_WHY_CONTRAN_INSTR            ) // 17
; 2268 :         , TXF_WHY_FORMAT( TXF_WHY_CONTRAN_BRANCH           ) // 18
; 2269 :         , TXF_WHY_FORMAT( TXF_WHY_CONTRAN_RELATIVE_BRANCH  ) // 19
; 2270 :         , TXF_WHY_FORMAT( TXF_WHY_TRAN_INSTR               ) // 20
; 2271 :         , TXF_WHY_FORMAT( TXF_WHY_TRAN_FLOAT_INSTR         ) // 21
; 2272 :         , TXF_WHY_FORMAT( TXF_WHY_TRAN_ACCESS_INSTR        ) // 22
; 2273 :         , TXF_WHY_FORMAT( TXF_WHY_TRAN_NONRELATIVE_BRANCH  ) // 23
; 2274 :         , TXF_WHY_FORMAT( TXF_WHY_TRAN_BRANCH_SET_MODE     ) // 24
; 2275 :         , TXF_WHY_FORMAT( TXF_WHY_TRAN_SET_ADDRESSING_MODE ) // 25
; 2276 :         , TXF_WHY_FORMAT( TXF_WHY_TRAN_MISC_INSTR          ) // 26
; 2277 :         , TXF_WHY_FORMAT( TXF_WHY_NESTING                  ) // 27
; 2278 :         , TXF_WHY_FORMAT( TXF_WHY_STORKEY                  ) // 28
; 2279 :         , TXF_WHY_FORMAT( TXF_WHY_IPTE_INSTR               ) // 29
; 2280 :         , TXF_WHY_FORMAT( TXF_WHY_IDTE_INSTR               ) // 30
; 2281 :         , TXF_WHY_FORMAT( TXF_WHY_CONSTRAINT_4             ) // 31
; 2282 :         , ""                                                 // 32
; 2283 :     );
; 2284 :     return buffer;

  007cc	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR buffer$[rsp]

; 2285 : }

  007d4	48 81 c4 28 02
	00 00		 add	 rsp, 552		; 00000228H
  007db	c3		 ret	 0
txf_why_str ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
n$1 = 96
showregs$2 = 100
code$3 = 104
tregs$4 = 112
ilc$5 = 120
tnd$6 = 124
piid$7 = 128
tv602 = 132
tv603 = 136
atia$8 = 144
dmp$9 = 152
real_atia$10 = 160
tv82 = 168
tv141 = 172
tv188 = 176
tv229 = 180
tv339 = 184
tv381 = 188
tv423 = 192
xcode$11 = 196
tv717 = 200
tv792 = 204
tv848 = 208
tv905 = 212
tv962 = 216
tv1019 = 220
tv1108 = 224
tv1165 = 228
tv1222 = 232
tv1279 = 236
tv565 = 240
tac$12 = 248
tv526 = 256
tv683 = 260
tv549 = 264
tv1219 = 272
tv1276 = 280
tv79 = 288
tv138 = 296
tv185 = 304
tv226 = 312
tv301 = 320
tv307 = 328
tv336 = 336
tv378 = 344
tv420 = 352
tv508 = 360
tv523 = 368
tv562 = 376
tv658 = 384
tv659 = 392
tv680 = 400
tv714 = 408
tv789 = 416
tv845 = 424
tv902 = 432
tv959 = 440
tv1016 = 448
tv1105 = 456
tv1162 = 464
stid$13 = 472
tv84 = 480
dat$14 = 488
tv176 = 496
tv190 = 504
tv231 = 512
tv341 = 520
tv364 = 528
tv383 = 536
tkn$15 = 544
tv425 = 552
tv528 = 560
tv567 = 568
ip$16 = 576
tv685 = 584
tv719 = 592
bea$17 = 600
teid$18 = 608
tv794 = 616
tv850 = 624
tv907 = 632
tv964 = 640
tv1021 = 648
tv1110 = 656
tv1167 = 664
tv1224 = 672
tv1281 = 680
gr$19 = 688
inst$20 = 816
buf$21 = 832
flgs$22 = 960
dump_pfx$23 = 992
__$ArrayPad$ = 1056
regs$ = 1104
tdb$ = 1112
dump_tdb PROC

; 2322 : {

$LN98:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 38 04
	00 00		 sub	 rsp, 1080		; 00000438H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 20
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2323 :     /* NOT verbose tracing -or- invalid TDB : do storage dump of TDB */
; 2324 :     if (!MLVL( VERBOSE ) || tdb->tdb_format != 1)

  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002c	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00032	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00037	85 c0		 test	 eax, eax
  00039	74 14		 je	 SHORT $LN30@dump_tdb
  0003b	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  00043	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00046	83 f8 01	 cmp	 eax, 1
  00049	0f 84 c1 03 00
	00		 je	 $LN29@dump_tdb
$LN30@dump_tdb:

; 2325 :     {
; 2326 :         char*  /* (work) */  dmp  = NULL;

  0004f	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR dmp$9[rsp], 0

; 2327 :         const char*          dat  = (const char*) tdb;

  0005b	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  00063	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR dat$14[rsp], rax

; 2328 :         static const size_t  skp  = 0;
; 2329 :         static const size_t  amt  = sizeof( TDB );
; 2330 :         static const U64     adr  = 0; // (cosmetic)
; 2331 :         static const size_t  bpg  = 8; // bytes per formatted group
; 2332 :         static const size_t  gpl  = 2; // formatted groups per line
; 2333 :         char dump_pfx[64]         = {0};

  0006b	48 8d 84 24 e0
	03 00 00	 lea	 rax, QWORD PTR dump_pfx$23[rsp]
  00073	48 8b f8	 mov	 rdi, rax
  00076	33 c0		 xor	 eax, eax
  00078	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0007d	f3 aa		 rep stosb

; 2334 : 
; 2335 :         // "TXF: %s%02X: %s%s dump of TDB:"
; 2336 :         WRMSG( HHC17709, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ), "Storage" );

  0007f	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00087	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0008d	d1 e8		 shr	 eax, 1
  0008f	83 e0 01	 and	 eax, 1
  00092	85 c0		 test	 eax, eax
  00094	74 11		 je	 SHORT $LN44@dump_tdb
  00096	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194330
  0009d	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv79[rsp], rax
  000a5	eb 0f		 jmp	 SHORT $LN45@dump_tdb
$LN44@dump_tdb:
  000a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194331
  000ae	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv79[rsp], rax
$LN45@dump_tdb:
  000b6	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000be	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000c5	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv82[rsp], eax
  000cc	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d4	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  000db	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000e2	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  000f0	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR tv84[rsp], rax
  000f8	b9 01 00 00 00	 mov	 ecx, 1
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194329
  0010a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0010f	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv79[rsp]
  00117	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0011c	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv82[rsp]
  00123	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00127	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR tv84[rsp]
  0012f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194332
  0013b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194333
  00147	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00151	41 b9 03 00 00
	00		 mov	 r9d, 3
  00157	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194334
  0015e	ba 20 09 00 00	 mov	 edx, 2336		; 00000920H
  00163	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194335
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2337 : 
; 2338 :         MSGBUF(     dump_pfx, MSG( HHC17710, "D", TXF_CPUAD( regs ), TXF_QSIE( regs )));

  00170	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00178	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0017e	d1 e8		 shr	 eax, 1
  00180	83 e0 01	 and	 eax, 1
  00183	85 c0		 test	 eax, eax
  00185	74 11		 je	 SHORT $LN46@dump_tdb
  00187	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194336
  0018e	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv138[rsp], rax
  00196	eb 0f		 jmp	 SHORT $LN47@dump_tdb
$LN46@dump_tdb:
  00198	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194337
  0019f	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv138[rsp], rax
$LN47@dump_tdb:
  001a7	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001af	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  001b6	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv141[rsp], eax
  001bd	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c5	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  001cc	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001d3	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  001e1	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv138[rsp]
  001e9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ee	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv141[rsp]
  001f5	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  001f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fe	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194338
  00205	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194339
  0020c	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00211	48 8d 8c 24 e0
	03 00 00	 lea	 rcx, QWORD PTR dump_pfx$23[rsp]
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2339 :         RTRIM(      dump_pfx );

  0021f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194340
  00226	48 8d 8c 24 e0
	03 00 00	 lea	 rcx, QWORD PTR dump_pfx$23[rsp]
  0022e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim

; 2340 :         hexdumpe16( dump_pfx, &dmp, dat, skp, amt, adr, bpg, gpl );

  00234	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?gpl@?2??dump_tdb@@9@9
  0023b	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00240	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?bpg@?2??dump_tdb@@9@9
  00247	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0024c	c7 44 24 30 10
	00 00 00	 mov	 DWORD PTR [rsp+48], 16
  00254	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?adr@?2??dump_tdb@@9@9
  0025b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00260	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?amt@?2??dump_tdb@@9@9
  00267	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026c	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?skp@?2??dump_tdb@@9@9
  00273	4c 8b 84 24 e8
	01 00 00	 mov	 r8, QWORD PTR dat$14[rsp]
  0027b	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR dmp$9[rsp]
  00283	48 8d 8c 24 e0
	03 00 00	 lea	 rcx, QWORD PTR dump_pfx$23[rsp]
  0028b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hexdumpew

; 2341 : 
; 2342 :         if (dmp)

  00291	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR dmp$9[rsp], 0
  0029a	74 5b		 je	 SHORT $LN31@dump_tdb

; 2343 :         {
; 2344 :             LOGMSG( "%s", dmp );

  0029c	b9 01 00 00 00	 mov	 ecx, 1
  002a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dmp$9[rsp]
  002af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194343
  002bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  002cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194344
  002d2	ba 28 09 00 00	 mov	 edx, 2344		; 00000928H
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194345
  002de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2345 :             free( dmp );

  002e4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dmp$9[rsp]
  002ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2346 :         }

  002f2	e9 14 01 00 00	 jmp	 $LN32@dump_tdb
$LN31@dump_tdb:

; 2347 :         else
; 2348 :         {
; 2349 :             // "TXF: %s%02X: %serror in function %s: %s"
; 2350 :             WRMSG( HHC17708, "E", TXF_CPUAD( regs ), TXF_QSIE( regs ),

  002f7	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ff	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00305	d1 e8		 shr	 eax, 1
  00307	83 e0 01	 and	 eax, 1
  0030a	85 c0		 test	 eax, eax
  0030c	74 11		 je	 SHORT $LN48@dump_tdb
  0030e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194347
  00315	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv185[rsp], rax
  0031d	eb 0f		 jmp	 SHORT $LN49@dump_tdb
$LN48@dump_tdb:
  0031f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194348
  00326	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv185[rsp], rax
$LN49@dump_tdb:
  0032e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00334	8b 08		 mov	 ecx, DWORD PTR [rax]
  00336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0033c	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR tv176[rsp], rax
  00344	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034c	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00353	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv188[rsp], ecx
  0035a	48 8b 94 24 50
	04 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00362	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  00369	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00370	0f b6 8c 17 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdi+rdx+2888]
  00378	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0037e	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR tv190[rsp], rax
  00386	b9 01 00 00 00	 mov	 ecx, 1
  0038b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00391	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR tv176[rsp]
  00399	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0039e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194346
  003a5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  003aa	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv185[rsp]
  003b2	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003b7	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv188[rsp]
  003be	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003c2	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR tv190[rsp]
  003ca	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194349
  003d6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194350
  003e2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ec	41 b9 03 00 00
	00		 mov	 r9d, 3
  003f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194351
  003f9	ba 2f 09 00 00	 mov	 edx, 2351		; 0000092fH
  003fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194352
  00405	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN32@dump_tdb:

; 2351 :                 "dump_tdb()", strerror( errno ));
; 2352 :         }
; 2353 :         return;

  0040b	e9 df 1e 00 00	 jmp	 $LN1@dump_tdb
$LN29@dump_tdb:

; 2354 :     }
; 2355 : 
; 2356 :     /* Otherwise if verbose messages wanted and TDB is valid,
; 2357 :        then do a formatted print of each individual TDB field.
; 2358 :     */
; 2359 :     if (tdb->tdb_format == 1 && MLVL( VERBOSE ))

  00410	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  00418	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0041b	83 f8 01	 cmp	 eax, 1
  0041e	0f 85 cb 1e 00
	00		 jne	 $LN33@dump_tdb
  00424	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0042b	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00431	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00436	85 c0		 test	 eax, eax
  00438	0f 84 b1 1e 00
	00		 je	 $LN33@dump_tdb

; 2360 :     {
; 2361 :         char buf[128] = {0};

  0043e	48 8d 84 24 40
	03 00 00	 lea	 rax, QWORD PTR buf$21[rsp]
  00446	48 8b f8	 mov	 rdi, rax
  00449	33 c0		 xor	 eax, eax
  0044b	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00450	f3 aa		 rep stosb

; 2362 :         char flgs[32] = {0};

  00452	48 8d 84 24 c0
	03 00 00	 lea	 rax, QWORD PTR flgs$22[rsp]
  0045a	48 8b f8	 mov	 rdi, rax
  0045d	33 c0		 xor	 eax, eax
  0045f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00464	f3 aa		 rep stosb

; 2363 : 
; 2364 :         U16  tnd;
; 2365 :         U32  piid;
; 2366 :         U64  tac, tkn, atia, teid, bea;
; 2367 : 
; 2368 :         U64  gr[16];
; 2369 : 
; 2370 :         // "TXF: %s%02X: %s%s dump of TDB:"
; 2371 :         WRMSG( HHC17709, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ), "Formatted" );

  00466	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0046e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00474	d1 e8		 shr	 eax, 1
  00476	83 e0 01	 and	 eax, 1
  00479	85 c0		 test	 eax, eax
  0047b	74 11		 je	 SHORT $LN50@dump_tdb
  0047d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194355
  00484	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv226[rsp], rax
  0048c	eb 0f		 jmp	 SHORT $LN51@dump_tdb
$LN50@dump_tdb:
  0048e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194356
  00495	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv226[rsp], rax
$LN51@dump_tdb:
  0049d	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004a5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  004ac	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv229[rsp], eax
  004b3	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004bb	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  004c2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004c9	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  004d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  004d7	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR tv231[rsp], rax
  004df	b9 01 00 00 00	 mov	 ecx, 1
  004e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194354
  004f1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  004f6	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv226[rsp]
  004fe	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00503	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv229[rsp]
  0050a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0050e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR tv231[rsp]
  00516	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0051b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194357
  00522	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00527	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194358
  0052e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00533	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00538	41 b9 03 00 00
	00		 mov	 r9d, 3
  0053e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194359
  00545	ba 43 09 00 00	 mov	 edx, 2371		; 00000943H
  0054a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194360
  00551	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2372 : 
; 2373 :         // Fmt: 1, TND: 1, EAID: 00, DXC/VXC: 00, PIID: 00000000, Flags: (none)
; 2374 : 
; 2375 :         FETCH_HW( tnd,  tdb->tdb_tnd  );

  00557	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  0055f	48 83 c0 06	 add	 rax, 6
  00563	48 8b c8	 mov	 rcx, rax
  00566	e8 00 00 00 00	 call	 fetch_hw_noswap
  0056b	0f b7 c8	 movzx	 ecx, ax
  0056e	e8 00 00 00 00	 call	 _byteswap_ushort
  00573	66 89 44 24 7c	 mov	 WORD PTR tnd$6[rsp], ax

; 2376 :         FETCH_FW( piid, tdb->tdb_piid );

  00578	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  00580	48 83 c0 24	 add	 rax, 36			; 00000024H
  00584	48 8b c8	 mov	 rcx, rax
  00587	e8 00 00 00 00	 call	 fetch_fw_noswap
  0058c	8b c8		 mov	 ecx, eax
  0058e	e8 00 00 00 00	 call	 _byteswap_ulong
  00593	89 84 24 80 00
	00 00		 mov	 DWORD PTR piid$7[rsp], eax

; 2377 : 
; 2378 :         if (!tdb->tdb_flags) STRLCPY( flgs, "none" );

  0059a	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  005a2	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  005a6	85 c0		 test	 eax, eax
  005a8	75 20		 jne	 SHORT $LN34@dump_tdb
  005aa	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  005b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194363
  005b7	48 8d 8c 24 c0
	03 00 00	 lea	 rcx, QWORD PTR flgs$22[rsp]
  005bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  005c5	e9 97 00 00 00	 jmp	 $LN35@dump_tdb
$LN34@dump_tdb:

; 2379 :         else MSGBUF( flgs, "%s%s"

  005ca	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  005d2	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  005d6	83 e0 40	 and	 eax, 64			; 00000040H
  005d9	85 c0		 test	 eax, eax
  005db	74 11		 je	 SHORT $LN52@dump_tdb
  005dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194364
  005e4	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv301[rsp], rax
  005ec	eb 0f		 jmp	 SHORT $LN53@dump_tdb
$LN52@dump_tdb:
  005ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194365
  005f5	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv301[rsp], rax
$LN53@dump_tdb:
  005fd	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  00605	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00609	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0060e	85 c0		 test	 eax, eax
  00610	74 11		 je	 SHORT $LN54@dump_tdb
  00612	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194366
  00619	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv307[rsp], rax
  00621	eb 0f		 jmp	 SHORT $LN55@dump_tdb
$LN54@dump_tdb:
  00623	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194367
  0062a	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv307[rsp], rax
$LN55@dump_tdb:
  00632	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR tv301[rsp]
  0063a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0063f	4c 8b 8c 24 48
	01 00 00	 mov	 r9, QWORD PTR tv307[rsp]
  00647	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194368
  0064e	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00653	48 8d 8c 24 c0
	03 00 00	 lea	 rcx, QWORD PTR flgs$22[rsp]
  0065b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN35@dump_tdb:

; 2380 :             , tdb->tdb_flags & TDB_CTV ? "TDB_CTV, " : ""
; 2381 :             , tdb->tdb_flags & TDB_CTI ? "TDB_CTI, " : ""
; 2382 :         );
; 2383 :         RTRIM(  flgs ); rtrim ( flgs, "," );

  00661	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194369
  00668	48 8d 8c 24 c0
	03 00 00	 lea	 rcx, QWORD PTR flgs$22[rsp]
  00670	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  00676	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194370
  0067d	48 8d 8c 24 c0
	03 00 00	 lea	 rcx, QWORD PTR flgs$22[rsp]
  00685	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim

; 2384 : 
; 2385 :         MSGBUF( buf, "Fmt: %u, TND: %"PRIu16", EAID: %02X, DXC/VXC: %02X, PIID: %08"PRIX32", Flags: (%s)",

  0068b	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  00693	0f b6 40 21	 movzx	 eax, BYTE PTR [rax+33]
  00697	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  0069f	0f b6 49 20	 movzx	 ecx, BYTE PTR [rcx+32]
  006a3	0f b7 54 24 7c	 movzx	 edx, WORD PTR tnd$6[rsp]
  006a8	48 8b bc 24 58
	04 00 00	 mov	 rdi, QWORD PTR tdb$[rsp]
  006b0	0f b6 3f	 movzx	 edi, BYTE PTR [rdi]
  006b3	4c 8d 84 24 c0
	03 00 00	 lea	 r8, QWORD PTR flgs$22[rsp]
  006bb	4c 89 44 24 40	 mov	 QWORD PTR [rsp+64], r8
  006c0	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR piid$7[rsp]
  006c8	44 89 44 24 38	 mov	 DWORD PTR [rsp+56], r8d
  006cd	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  006d1	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  006d5	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  006d9	44 8b cf	 mov	 r9d, edi
  006dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194371
  006e3	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  006e8	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  006f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2386 :             tdb->tdb_format, tnd, tdb->tdb_eaid, tdb->tdb_dxc, piid, flgs );
; 2387 :         WRMSG( HHC17721, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ), buf );

  006f6	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006fe	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00704	d1 e8		 shr	 eax, 1
  00706	83 e0 01	 and	 eax, 1
  00709	85 c0		 test	 eax, eax
  0070b	74 11		 je	 SHORT $LN56@dump_tdb
  0070d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194372
  00714	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv336[rsp], rax
  0071c	eb 0f		 jmp	 SHORT $LN57@dump_tdb
$LN56@dump_tdb:
  0071e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194373
  00725	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv336[rsp], rax
$LN57@dump_tdb:
  0072d	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00735	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0073c	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv339[rsp], eax
  00743	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0074b	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00752	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00759	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00761	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00767	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR tv341[rsp], rax
  0076f	b9 01 00 00 00	 mov	 ecx, 1
  00774	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0077a	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  00782	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00787	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv336[rsp]
  0078f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00794	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv339[rsp]
  0079b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0079f	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR tv341[rsp]
  007a7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  007ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194374
  007b3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194375
  007bf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007c9	41 b9 03 00 00
	00		 mov	 r9d, 3
  007cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194376
  007d6	ba 53 09 00 00	 mov	 edx, 2387		; 00000953H
  007db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194377
  007e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2388 : 
; 2389 :         // TAC:   0x0000000000000008: TAC_STORE_OVF = Store overflow
; 2390 : 
; 2391 :         FETCH_DW( tac, tdb->tdb_tac );

  007e8	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  007f0	48 83 c0 08	 add	 rax, 8
  007f4	48 8b c8	 mov	 rcx, rax
  007f7	e8 00 00 00 00	 call	 fetch_dw_noswap
  007fc	48 8b c8	 mov	 rcx, rax
  007ff	e8 00 00 00 00	 call	 _byteswap_uint64
  00804	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tac$12[rsp], rax

; 2392 : 
; 2393 :         MSGBUF( buf, "TAC:   0x%16.16"PRIX64": %s = %s",

  0080c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tac$12[rsp]
  00814	e8 00 00 00 00	 call	 tac2long
  00819	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR tv364[rsp], rax
  00821	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tac$12[rsp]
  00829	e8 00 00 00 00	 call	 tac2short
  0082e	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR tv364[rsp]
  00836	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0083b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00840	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR tac$12[rsp]
  00848	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194378
  0084f	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00854	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  0085c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2394 :             tac, tac2short( tac ), tac2long( tac ) );
; 2395 :         WRMSG( HHC17721, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ), buf );

  00862	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0086a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00870	d1 e8		 shr	 eax, 1
  00872	83 e0 01	 and	 eax, 1
  00875	85 c0		 test	 eax, eax
  00877	74 11		 je	 SHORT $LN58@dump_tdb
  00879	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194379
  00880	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv378[rsp], rax
  00888	eb 0f		 jmp	 SHORT $LN59@dump_tdb
$LN58@dump_tdb:
  0088a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194380
  00891	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv378[rsp], rax
$LN59@dump_tdb:
  00899	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a1	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  008a8	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv381[rsp], eax
  008af	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008b7	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  008be	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  008c5	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  008cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  008d3	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR tv383[rsp], rax
  008db	b9 01 00 00 00	 mov	 ecx, 1
  008e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008e6	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  008ee	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  008f3	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv378[rsp]
  008fb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00900	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv381[rsp]
  00907	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0090b	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR tv383[rsp]
  00913	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00918	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194381
  0091f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00924	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194382
  0092b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00930	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00935	41 b9 03 00 00
	00		 mov	 r9d, 3
  0093b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194383
  00942	ba 5b 09 00 00	 mov	 edx, 2395		; 0000095bH
  00947	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194384
  0094e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2396 : 
; 2397 :         // Token: 0x0000000000000000, ATIA:  0x00000000000024EA
; 2398 : 
; 2399 :         FETCH_DW( tkn,  tdb->tdb_conflict );

  00954	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  0095c	48 83 c0 10	 add	 rax, 16
  00960	48 8b c8	 mov	 rcx, rax
  00963	e8 00 00 00 00	 call	 fetch_dw_noswap
  00968	48 8b c8	 mov	 rcx, rax
  0096b	e8 00 00 00 00	 call	 _byteswap_uint64
  00970	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR tkn$15[rsp], rax

; 2400 :         FETCH_DW( atia, tdb->tdb_atia     );

  00978	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  00980	48 83 c0 18	 add	 rax, 24
  00984	48 8b c8	 mov	 rcx, rax
  00987	e8 00 00 00 00	 call	 fetch_dw_noswap
  0098c	48 8b c8	 mov	 rcx, rax
  0098f	e8 00 00 00 00	 call	 _byteswap_uint64
  00994	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR atia$8[rsp], rax

; 2401 : 
; 2402 :         MSGBUF( buf, "Token: 0x%16.16"PRIX64", ATIA:  0x%16.16"PRIX64, tkn, atia );

  0099c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR atia$8[rsp]
  009a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009a9	4c 8b 8c 24 20
	02 00 00	 mov	 r9, QWORD PTR tkn$15[rsp]
  009b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194385
  009b8	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  009bd	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  009c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2403 :         WRMSG( HHC17721, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ), buf );

  009cb	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009d3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  009d9	d1 e8		 shr	 eax, 1
  009db	83 e0 01	 and	 eax, 1
  009de	85 c0		 test	 eax, eax
  009e0	74 11		 je	 SHORT $LN60@dump_tdb
  009e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194386
  009e9	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv420[rsp], rax
  009f1	eb 0f		 jmp	 SHORT $LN61@dump_tdb
$LN60@dump_tdb:
  009f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194387
  009fa	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv420[rsp], rax
$LN61@dump_tdb:
  00a02	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a0a	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00a11	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv423[rsp], eax
  00a18	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a20	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00a27	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00a2e	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00a36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00a3c	48 89 84 24 28
	02 00 00	 mov	 QWORD PTR tv425[rsp], rax
  00a44	b9 01 00 00 00	 mov	 ecx, 1
  00a49	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a4f	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  00a57	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00a5c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv420[rsp]
  00a64	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a69	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv423[rsp]
  00a70	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a74	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR tv425[rsp]
  00a7c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a81	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194388
  00a88	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a8d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194389
  00a94	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a99	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a9e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00aa4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194390
  00aab	ba 63 09 00 00	 mov	 edx, 2403		; 00000963H
  00ab0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194391
  00ab7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2404 : 
; 2405 :         /* Display the instruction that the transaction aborted on */
; 2406 :         {
; 2407 :             REGS*  tregs = copy_regs( regs );

  00abd	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ac5	e8 00 00 00 00	 call	 copy_regs
  00aca	48 89 44 24 70	 mov	 QWORD PTR tregs$4[rsp], rax
$LN4@dump_tdb:

; 2408 :             int    xcode, stid;
; 2409 :             RADR   real_atia;
; 2410 : 
; 2411 :             /* Point the PSW to the aborted instruction */
; 2412 :             SET_PSW_IA_AND_MAYBE_IP( tregs, atia );

  00acf	48 8b 44 24 70	 mov	 rax, QWORD PTR tregs$4[rsp]
  00ad4	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00adb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR atia$8[rsp]
  00ae3	48 23 c8	 and	 rcx, rax
  00ae6	48 8b c1	 mov	 rax, rcx
  00ae9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tregs$4[rsp]
  00aee	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00af5	48 8b 44 24 70	 mov	 rax, QWORD PTR tregs$4[rsp]
  00afa	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00b02	74 5f		 je	 SHORT $LN36@dump_tdb
  00b04	48 8b 44 24 70	 mov	 rax, QWORD PTR tregs$4[rsp]
  00b09	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00b10	48 25 01 f0 ff
	ff		 and	 rax, -4095		; fffffffffffff001H
  00b16	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tregs$4[rsp]
  00b1b	48 39 81 10 02
	00 00		 cmp	 QWORD PTR [rcx+528], rax
  00b22	75 2f		 jne	 SHORT $LN37@dump_tdb
  00b24	48 8b 44 24 70	 mov	 rax, QWORD PTR tregs$4[rsp]
  00b29	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00b30	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00b36	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tregs$4[rsp]
  00b3b	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00b42	48 0b c8	 or	 rcx, rax
  00b45	48 8b c1	 mov	 rax, rcx
  00b48	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tregs$4[rsp]
  00b4d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00b51	eb 10		 jmp	 SHORT $LN38@dump_tdb
$LN37@dump_tdb:
  00b53	48 8b 44 24 70	 mov	 rax, QWORD PTR tregs$4[rsp]
  00b58	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN38@dump_tdb:
$LN36@dump_tdb:
  00b63	33 c0		 xor	 eax, eax
  00b65	85 c0		 test	 eax, eax
  00b67	0f 85 62 ff ff
	ff		 jne	 $LN4@dump_tdb

; 2413 : 
; 2414 :             /* Get absolute mainstor addr of that instruction */
; 2415 :             if ((xcode = ARCH_DEP( virt_to_real )( &real_atia,
; 2416 :                 &stid, atia, 0, tregs, ACCTYPE_INSTFETCH )) == 0)

  00b6d	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  00b75	48 8b 44 24 70	 mov	 rax, QWORD PTR tregs$4[rsp]
  00b7a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b7f	45 33 c9	 xor	 r9d, r9d
  00b82	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR atia$8[rsp]
  00b8a	48 8d 94 24 d8
	01 00 00	 lea	 rdx, QWORD PTR stid$13[rsp]
  00b92	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR real_atia$10[rsp]
  00b9a	e8 00 00 00 00	 call	 z900_virt_to_real
  00b9f	89 84 24 c4 00
	00 00		 mov	 DWORD PTR xcode$11[rsp], eax
  00ba6	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR xcode$11[rsp], 0
  00bae	0f 85 aa 07 00
	00		 jne	 $LN39@dump_tdb

; 2417 :             {
; 2418 :                 BYTE*  ip        = (tregs->mainstor + APPLY_PREFIXING( real_atia, tregs->PX ));

  00bb4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR real_atia$10[rsp]
  00bbc	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00bc2	48 85 c0	 test	 rax, rax
  00bc5	74 2b		 je	 SHORT $LN62@dump_tdb
  00bc7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR real_atia$10[rsp]
  00bcf	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00bd5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tregs$4[rsp]
  00bda	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  00bde	74 12		 je	 SHORT $LN62@dump_tdb
  00be0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR real_atia$10[rsp]
  00be8	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv508[rsp], rax
  00bf0	eb 1f		 jmp	 SHORT $LN63@dump_tdb
$LN62@dump_tdb:
  00bf2	48 8b 44 24 70	 mov	 rax, QWORD PTR tregs$4[rsp]
  00bf7	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00bfb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR real_atia$10[rsp]
  00c03	48 33 c8	 xor	 rcx, rax
  00c06	48 8b c1	 mov	 rax, rcx
  00c09	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv508[rsp], rax
$LN63@dump_tdb:
  00c11	48 8b 44 24 70	 mov	 rax, QWORD PTR tregs$4[rsp]
  00c16	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00c1d	48 03 84 24 68
	01 00 00	 add	 rax, QWORD PTR tv508[rsp]
  00c25	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR ip$16[rsp], rax

; 2419 :                 bool   showregs  = sysblk.showregsnone;

  00c2d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c34	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00c3a	c1 e8 11	 shr	 eax, 17
  00c3d	83 e0 01	 and	 eax, 1
  00c40	88 44 24 64	 mov	 BYTE PTR showregs$2[rsp], al

; 2420 :                 U16    code      = CODE_FROM_PIID( piid );

  00c44	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR piid$7[rsp]
  00c4b	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00c50	66 89 44 24 68	 mov	 WORD PTR code$3[rsp], ax

; 2421 :                 int    ilc       = ILC_FROM_PIID(  piid );

  00c55	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR piid$7[rsp]
  00c5c	25 00 00 07 00	 and	 eax, 458752		; 00070000H
  00c61	c1 e8 10	 shr	 eax, 16
  00c64	89 44 24 78	 mov	 DWORD PTR ilc$5[rsp], eax

; 2422 : 
; 2423 :                 // (blank line)
; 2424 :                 WRMSG( HHC17721, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ), "" );

  00c68	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c70	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00c76	d1 e8		 shr	 eax, 1
  00c78	83 e0 01	 and	 eax, 1
  00c7b	85 c0		 test	 eax, eax
  00c7d	74 11		 je	 SHORT $LN64@dump_tdb
  00c7f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194397
  00c86	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv523[rsp], rax
  00c8e	eb 0f		 jmp	 SHORT $LN65@dump_tdb
$LN64@dump_tdb:
  00c90	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194398
  00c97	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv523[rsp], rax
$LN65@dump_tdb:
  00c9f	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ca7	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00cae	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv526[rsp], eax
  00cb5	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cbd	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00cc4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00ccb	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00cd3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00cd9	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR tv528[rsp], rax
  00ce1	b9 01 00 00 00	 mov	 ecx, 1
  00ce6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194396
  00cf3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00cf8	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv523[rsp]
  00d00	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00d05	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv526[rsp]
  00d0c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00d10	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR tv528[rsp]
  00d18	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00d1d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194399
  00d24	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d29	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194400
  00d30	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d35	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d3a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d40	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194401
  00d47	ba 78 09 00 00	 mov	 edx, 2424		; 00000978H
  00d4c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194402
  00d53	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2425 :                 {
; 2426 :                     if (code)

  00d59	0f b7 44 24 68	 movzx	 eax, WORD PTR code$3[rsp]
  00d5e	85 c0		 test	 eax, eax
  00d60	0f 84 39 01 00
	00		 je	 $LN40@dump_tdb

; 2427 :                     {
; 2428 :                         // e.g. "Operation exception code 0201 ilc 2"
; 2429 :                         MSGBUF( buf, "%s code %4.4X ilc %d", PIC2Name( code ), code, ilc );

  00d66	0f b7 44 24 68	 movzx	 eax, WORD PTR code$3[rsp]
  00d6b	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv549[rsp], eax
  00d72	0f b7 4c 24 68	 movzx	 ecx, WORD PTR code$3[rsp]
  00d77	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  00d7d	8b 4c 24 78	 mov	 ecx, DWORD PTR ilc$5[rsp]
  00d81	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00d85	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv549[rsp]
  00d8c	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00d90	4c 8b c8	 mov	 r9, rax
  00d93	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194404
  00d9a	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00d9f	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  00da7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2430 :                         WRMSG( HHC17721, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ), buf );

  00dad	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00db5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00dbb	d1 e8		 shr	 eax, 1
  00dbd	83 e0 01	 and	 eax, 1
  00dc0	85 c0		 test	 eax, eax
  00dc2	74 11		 je	 SHORT $LN66@dump_tdb
  00dc4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194405
  00dcb	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv562[rsp], rax
  00dd3	eb 0f		 jmp	 SHORT $LN67@dump_tdb
$LN66@dump_tdb:
  00dd5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194406
  00ddc	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv562[rsp], rax
$LN67@dump_tdb:
  00de4	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dec	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00df3	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv565[rsp], eax
  00dfa	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e02	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00e09	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00e10	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00e18	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00e1e	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR tv567[rsp], rax
  00e26	b9 01 00 00 00	 mov	 ecx, 1
  00e2b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e31	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  00e39	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00e3e	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv562[rsp]
  00e46	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e4b	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv565[rsp]
  00e52	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e56	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR tv567[rsp]
  00e5e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e63	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194407
  00e6a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e6f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194408
  00e76	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e7b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e80	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e86	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194409
  00e8d	ba 7e 09 00 00	 mov	 edx, 2430		; 0000097eH
  00e92	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194410
  00e99	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN40@dump_tdb:

; 2431 :                     }
; 2432 : 
; 2433 :                     sysblk.showregsnone = true;

  00e9f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ea6	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00eac	0f ba e8 11	 bts	 eax, 17
  00eb0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00eb7	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 2434 :                     {
; 2435 :                         int n = 0;

  00ebd	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0

; 2436 :                         BYTE inst[6];
; 2437 : 
; 2438 :                         memcpy( inst, ip, sizeof( inst ));

  00ec5	48 8d 84 24 30
	03 00 00	 lea	 rax, QWORD PTR inst$20[rsp]
  00ecd	48 8b f8	 mov	 rdi, rax
  00ed0	48 8b b4 24 40
	02 00 00	 mov	 rsi, QWORD PTR ip$16[rsp]
  00ed8	b9 06 00 00 00	 mov	 ecx, 6
  00edd	f3 a4		 rep movsb

; 2439 :                         ilc = ILC( inst[0] );

  00edf	b8 01 00 00 00	 mov	 eax, 1
  00ee4	48 6b c0 00	 imul	 rax, rax, 0
  00ee8	0f b6 84 04 30
	03 00 00	 movzx	 eax, BYTE PTR inst$20[rsp+rax]
  00ef0	83 f8 40	 cmp	 eax, 64			; 00000040H
  00ef3	7d 0d		 jge	 SHORT $LN70@dump_tdb
  00ef5	c7 84 24 88 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv603[rsp], 2
  00f00	eb 3e		 jmp	 SHORT $LN71@dump_tdb
$LN70@dump_tdb:
  00f02	b8 01 00 00 00	 mov	 eax, 1
  00f07	48 6b c0 00	 imul	 rax, rax, 0
  00f0b	0f b6 84 04 30
	03 00 00	 movzx	 eax, BYTE PTR inst$20[rsp+rax]
  00f13	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00f18	7d 0d		 jge	 SHORT $LN68@dump_tdb
  00f1a	c7 84 24 84 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv602[rsp], 4
  00f25	eb 0b		 jmp	 SHORT $LN69@dump_tdb
$LN68@dump_tdb:
  00f27	c7 84 24 84 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv602[rsp], 6
$LN69@dump_tdb:
  00f32	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv602[rsp]
  00f39	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv603[rsp], eax
$LN71@dump_tdb:
  00f40	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv603[rsp]
  00f47	89 44 24 78	 mov	 DWORD PTR ilc$5[rsp], eax

; 2440 : 
; 2441 :                                      n += idx_snprintf( n, buf, sizeof( buf ), "%16.16"PRIX64" ", atia );

  00f4b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR atia$8[rsp]
  00f53	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f58	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194411
  00f5f	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00f65	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR buf$21[rsp]
  00f6d	8b 4c 24 60	 mov	 ecx, DWORD PTR n$1[rsp]
  00f71	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00f77	8b 4c 24 60	 mov	 ecx, DWORD PTR n$1[rsp]
  00f7b	03 c8		 add	 ecx, eax
  00f7d	8b c1		 mov	 eax, ecx
  00f7f	89 44 24 60	 mov	 DWORD PTR n$1[rsp], eax

; 2442 :                                      n += idx_snprintf( n, buf, sizeof( buf ), "INST=%2.2X%2.2X", inst[0], inst[1] );

  00f83	b8 01 00 00 00	 mov	 eax, 1
  00f88	48 6b c0 01	 imul	 rax, rax, 1
  00f8c	0f b6 84 04 30
	03 00 00	 movzx	 eax, BYTE PTR inst$20[rsp+rax]
  00f94	b9 01 00 00 00	 mov	 ecx, 1
  00f99	48 6b c9 00	 imul	 rcx, rcx, 0
  00f9d	0f b6 8c 0c 30
	03 00 00	 movzx	 ecx, BYTE PTR inst$20[rsp+rcx]
  00fa5	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00fa9	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00fad	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194412
  00fb4	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00fba	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR buf$21[rsp]
  00fc2	8b 4c 24 60	 mov	 ecx, DWORD PTR n$1[rsp]
  00fc6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  00fcc	8b 4c 24 60	 mov	 ecx, DWORD PTR n$1[rsp]
  00fd0	03 c8		 add	 ecx, eax
  00fd2	8b c1		 mov	 eax, ecx
  00fd4	89 44 24 60	 mov	 DWORD PTR n$1[rsp], eax

; 2443 :                         if (ilc > 2){n += idx_snprintf( n, buf, sizeof( buf ), "%2.2X%2.2X",      inst[2], inst[3] );}

  00fd8	83 7c 24 78 02	 cmp	 DWORD PTR ilc$5[rsp], 2
  00fdd	7e 55		 jle	 SHORT $LN41@dump_tdb
  00fdf	b8 01 00 00 00	 mov	 eax, 1
  00fe4	48 6b c0 03	 imul	 rax, rax, 3
  00fe8	0f b6 84 04 30
	03 00 00	 movzx	 eax, BYTE PTR inst$20[rsp+rax]
  00ff0	b9 01 00 00 00	 mov	 ecx, 1
  00ff5	48 6b c9 02	 imul	 rcx, rcx, 2
  00ff9	0f b6 8c 0c 30
	03 00 00	 movzx	 ecx, BYTE PTR inst$20[rsp+rcx]
  01001	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  01005	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  01009	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194414
  01010	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  01016	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR buf$21[rsp]
  0101e	8b 4c 24 60	 mov	 ecx, DWORD PTR n$1[rsp]
  01022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  01028	8b 4c 24 60	 mov	 ecx, DWORD PTR n$1[rsp]
  0102c	03 c8		 add	 ecx, eax
  0102e	8b c1		 mov	 eax, ecx
  01030	89 44 24 60	 mov	 DWORD PTR n$1[rsp], eax
$LN41@dump_tdb:

; 2444 :                         if (ilc > 4){n += idx_snprintf( n, buf, sizeof( buf ), "%2.2X%2.2X",      inst[4], inst[5] );}

  01034	83 7c 24 78 04	 cmp	 DWORD PTR ilc$5[rsp], 4
  01039	7e 55		 jle	 SHORT $LN42@dump_tdb
  0103b	b8 01 00 00 00	 mov	 eax, 1
  01040	48 6b c0 05	 imul	 rax, rax, 5
  01044	0f b6 84 04 30
	03 00 00	 movzx	 eax, BYTE PTR inst$20[rsp+rax]
  0104c	b9 01 00 00 00	 mov	 ecx, 1
  01051	48 6b c9 04	 imul	 rcx, rcx, 4
  01055	0f b6 8c 0c 30
	03 00 00	 movzx	 ecx, BYTE PTR inst$20[rsp+rcx]
  0105d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  01061	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  01065	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194416
  0106c	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  01072	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR buf$21[rsp]
  0107a	8b 4c 24 60	 mov	 ecx, DWORD PTR n$1[rsp]
  0107e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  01084	8b 4c 24 60	 mov	 ecx, DWORD PTR n$1[rsp]
  01088	03 c8		 add	 ecx, eax
  0108a	8b c1		 mov	 eax, ecx
  0108c	89 44 24 60	 mov	 DWORD PTR n$1[rsp], eax
$LN42@dump_tdb:

; 2445 :                                      n += idx_snprintf( n, buf, sizeof( buf ), " %s", (ilc < 4) ? "        "

  01090	83 7c 24 78 04	 cmp	 DWORD PTR ilc$5[rsp], 4
  01095	7d 11		 jge	 SHORT $LN74@dump_tdb
  01097	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194417
  0109e	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv659[rsp], rax
  010a6	eb 37		 jmp	 SHORT $LN75@dump_tdb
$LN74@dump_tdb:
  010a8	83 7c 24 78 06	 cmp	 DWORD PTR ilc$5[rsp], 6
  010ad	7d 11		 jge	 SHORT $LN72@dump_tdb
  010af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194418
  010b6	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv658[rsp], rax
  010be	eb 0f		 jmp	 SHORT $LN73@dump_tdb
$LN72@dump_tdb:
  010c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194419
  010c7	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv658[rsp], rax
$LN73@dump_tdb:
  010cf	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR tv658[rsp]
  010d7	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv659[rsp], rax
$LN75@dump_tdb:
  010df	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR tv659[rsp]
  010e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010ec	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194420
  010f3	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  010f9	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR buf$21[rsp]
  01101	8b 4c 24 60	 mov	 ecx, DWORD PTR n$1[rsp]
  01105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0110b	8b 4c 24 60	 mov	 ecx, DWORD PTR n$1[rsp]
  0110f	03 c8		 add	 ecx, eax
  01111	8b c1		 mov	 eax, ecx
  01113	89 44 24 60	 mov	 DWORD PTR n$1[rsp], eax

; 2446 :                                                                                     : (ilc < 6) ? "    "
; 2447 :                                                                                     :             "" );
; 2448 :                         n += PRINT_INST( regs->arch_mode, inst, buf + n );

  01117	48 63 44 24 60	 movsxd	 rax, DWORD PTR n$1[rsp]
  0111c	48 8d 84 04 40
	03 00 00	 lea	 rax, QWORD PTR buf$21[rsp+rax]
  01124	4c 8b c8	 mov	 r9, rax
  01127	45 33 c0	 xor	 r8d, r8d
  0112a	48 8d 94 24 30
	03 00 00	 lea	 rdx, QWORD PTR inst$20[rsp]
  01132	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0113a	8b 48 64	 mov	 ecx, DWORD PTR [rax+100]
  0113d	e8 00 00 00 00	 call	 iprint_router_func
  01142	8b 4c 24 60	 mov	 ecx, DWORD PTR n$1[rsp]
  01146	03 c8		 add	 ecx, eax
  01148	8b c1		 mov	 eax, ecx
  0114a	89 44 24 60	 mov	 DWORD PTR n$1[rsp], eax

; 2449 : 
; 2450 :                         // "AAAAAAAAAAAAAAAA INST=112233445566 XXXXX op1,op2                name"
; 2451 :                         WRMSG( HHC17721, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ), buf );

  0114e	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01156	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0115c	d1 e8		 shr	 eax, 1
  0115e	83 e0 01	 and	 eax, 1
  01161	85 c0		 test	 eax, eax
  01163	74 11		 je	 SHORT $LN76@dump_tdb
  01165	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194421
  0116c	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv680[rsp], rax
  01174	eb 0f		 jmp	 SHORT $LN77@dump_tdb
$LN76@dump_tdb:
  01176	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194422
  0117d	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv680[rsp], rax
$LN77@dump_tdb:
  01185	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0118d	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01194	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv683[rsp], eax
  0119b	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011a3	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  011aa	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  011b1	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  011b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  011bf	48 89 84 24 48
	02 00 00	 mov	 QWORD PTR tv685[rsp], rax
  011c7	b9 01 00 00 00	 mov	 ecx, 1
  011cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011d2	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  011da	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  011df	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR tv680[rsp]
  011e7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  011ec	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv683[rsp]
  011f3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  011f7	48 8b 8c 24 48
	02 00 00	 mov	 rcx, QWORD PTR tv685[rsp]
  011ff	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01204	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194423
  0120b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01210	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194424
  01217	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0121c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01221	41 b9 03 00 00
	00		 mov	 r9d, 3
  01227	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194425
  0122e	ba 93 09 00 00	 mov	 edx, 2451		; 00000993H
  01233	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194426
  0123a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2452 :                     }
; 2453 :                     sysblk.showregsnone = showregs;

  01240	0f b6 44 24 64	 movzx	 eax, BYTE PTR showregs$2[rsp]
  01245	83 e0 01	 and	 eax, 1
  01248	c1 e0 11	 shl	 eax, 17
  0124b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01252	8b 89 94 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4756]
  01258	0f ba f1 11	 btr	 ecx, 17
  0125c	0b c8		 or	 ecx, eax
  0125e	8b c1		 mov	 eax, ecx
  01260	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01267	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 2454 :                 }
; 2455 :                 // (blank line)
; 2456 :                 WRMSG( HHC17721, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ), "" );

  0126d	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01275	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0127b	d1 e8		 shr	 eax, 1
  0127d	83 e0 01	 and	 eax, 1
  01280	85 c0		 test	 eax, eax
  01282	74 11		 je	 SHORT $LN78@dump_tdb
  01284	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194428
  0128b	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv714[rsp], rax
  01293	eb 0f		 jmp	 SHORT $LN79@dump_tdb
$LN78@dump_tdb:
  01295	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194429
  0129c	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv714[rsp], rax
$LN79@dump_tdb:
  012a4	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012ac	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  012b3	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv717[rsp], eax
  012ba	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  012c2	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  012c9	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  012d0	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  012d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  012de	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR tv719[rsp], rax
  012e6	b9 01 00 00 00	 mov	 ecx, 1
  012eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  012f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194427
  012f8	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  012fd	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR tv714[rsp]
  01305	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0130a	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv717[rsp]
  01311	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01315	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR tv719[rsp]
  0131d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01322	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194430
  01329	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0132e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194431
  01335	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0133a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0133f	41 b9 03 00 00
	00		 mov	 r9d, 3
  01345	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194432
  0134c	ba 98 09 00 00	 mov	 edx, 2456		; 00000998H
  01351	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194433
  01358	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN39@dump_tdb:

; 2457 :             }
; 2458 :             free_aligned( tregs );

  0135e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tregs$4[rsp]
  01363	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 2459 :         }
; 2460 : 
; 2461 :         // TEID:  0x0000000000000000, BEA:   0x000000000000255C
; 2462 : 
; 2463 :         FETCH_DW( teid, tdb->tdb_teid );

  01369	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  01371	48 83 c0 28	 add	 rax, 40			; 00000028H
  01375	48 8b c8	 mov	 rcx, rax
  01378	e8 00 00 00 00	 call	 fetch_dw_noswap
  0137d	48 8b c8	 mov	 rcx, rax
  01380	e8 00 00 00 00	 call	 _byteswap_uint64
  01385	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR teid$18[rsp], rax

; 2464 :         FETCH_DW( bea,  tdb->tdb_bea  );

  0138d	48 8b 84 24 58
	04 00 00	 mov	 rax, QWORD PTR tdb$[rsp]
  01395	48 83 c0 30	 add	 rax, 48			; 00000030H
  01399	48 8b c8	 mov	 rcx, rax
  0139c	e8 00 00 00 00	 call	 fetch_dw_noswap
  013a1	48 8b c8	 mov	 rcx, rax
  013a4	e8 00 00 00 00	 call	 _byteswap_uint64
  013a9	48 89 84 24 58
	02 00 00	 mov	 QWORD PTR bea$17[rsp], rax

; 2465 : 
; 2466 :         MSGBUF( buf, "TEID:  0x%16.16"PRIX64", BEA:   0x%16.16"PRIX64, teid, bea );

  013b1	48 8b 84 24 58
	02 00 00	 mov	 rax, QWORD PTR bea$17[rsp]
  013b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  013be	4c 8b 8c 24 60
	02 00 00	 mov	 r9, QWORD PTR teid$18[rsp]
  013c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194434
  013cd	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  013d2	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  013da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2467 :         WRMSG( HHC17721, "D", TXF_CPUAD( regs ), TXF_QSIE( regs ), buf );

  013e0	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013e8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  013ee	d1 e8		 shr	 eax, 1
  013f0	83 e0 01	 and	 eax, 1
  013f3	85 c0		 test	 eax, eax
  013f5	74 11		 je	 SHORT $LN80@dump_tdb
  013f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194435
  013fe	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv789[rsp], rax
  01406	eb 0f		 jmp	 SHORT $LN81@dump_tdb
$LN80@dump_tdb:
  01408	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194436
  0140f	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv789[rsp], rax
$LN81@dump_tdb:
  01417	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0141f	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01426	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv792[rsp], eax
  0142d	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01435	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0143c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01443	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0144b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01451	48 89 84 24 68
	02 00 00	 mov	 QWORD PTR tv794[rsp], rax
  01459	b9 01 00 00 00	 mov	 ecx, 1
  0145e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01464	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  0146c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01471	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR tv789[rsp]
  01479	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0147e	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv792[rsp]
  01485	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01489	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR tv794[rsp]
  01491	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01496	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194437
  0149d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  014a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194438
  014a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  014ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  014b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194439
  014c0	ba a3 09 00 00	 mov	 edx, 2467		; 000009a3H
  014c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194440
  014cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@dump_tdb:

; 2468 : 
; 2469 :         // GR (General Registers)
; 2470 : 
; 2471 : #define GRPAIR_FMT( r )                                 \
; 2472 :         do                                              \
; 2473 :         {                                               \
; 2474 :             FETCH_DW( gr[r+0], tdb->tdb_gpr[r+0] );     \
; 2475 :             FETCH_DW( gr[r+1], tdb->tdb_gpr[r+1] );     \
; 2476 :             MSGBUF( buf, "GR %02u: 0x%16.16"PRIX64      \
; 2477 :                        ", GR %02u: 0x%16.16"PRIX64,     \
; 2478 :                        r+0, gr[r+0], r+1, gr[r+1] );    \
; 2479 :             WRMSG( HHC17721, "D", TXF_CPUAD( regs ),    \
; 2480 :                 TXF_QSIE( regs ), buf );                \
; 2481 :         }                                               \
; 2482 :         while (0)
; 2483 : 
; 2484 :         GRPAIR_FMT(  0 );

  014d2	b8 08 00 00 00	 mov	 eax, 8
  014d7	48 6b c0 00	 imul	 rax, rax, 0
  014db	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  014e3	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  014eb	48 8b c8	 mov	 rcx, rax
  014ee	e8 00 00 00 00	 call	 fetch_dw_noswap
  014f3	48 8b c8	 mov	 rcx, rax
  014f6	e8 00 00 00 00	 call	 _byteswap_uint64
  014fb	b9 08 00 00 00	 mov	 ecx, 8
  01500	48 6b c9 00	 imul	 rcx, rcx, 0
  01504	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  0150c	b8 08 00 00 00	 mov	 eax, 8
  01511	48 6b c0 01	 imul	 rax, rax, 1
  01515	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  0151d	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  01525	48 8b c8	 mov	 rcx, rax
  01528	e8 00 00 00 00	 call	 fetch_dw_noswap
  0152d	48 8b c8	 mov	 rcx, rax
  01530	e8 00 00 00 00	 call	 _byteswap_uint64
  01535	b9 08 00 00 00	 mov	 ecx, 8
  0153a	48 6b c9 01	 imul	 rcx, rcx, 1
  0153e	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  01546	b8 08 00 00 00	 mov	 eax, 8
  0154b	48 6b c0 01	 imul	 rax, rax, 1
  0154f	b9 08 00 00 00	 mov	 ecx, 8
  01554	48 6b c9 00	 imul	 rcx, rcx, 0
  01558	48 8b 84 04 b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rax]
  01560	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01565	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR [rsp+40], 1
  0156d	48 8b 84 0c b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rcx]
  01575	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0157a	45 33 c9	 xor	 r9d, r9d
  0157d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194441
  01584	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  01589	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  01591	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  01597	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0159f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  015a5	d1 e8		 shr	 eax, 1
  015a7	83 e0 01	 and	 eax, 1
  015aa	85 c0		 test	 eax, eax
  015ac	74 11		 je	 SHORT $LN82@dump_tdb
  015ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194442
  015b5	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv845[rsp], rax
  015bd	eb 0f		 jmp	 SHORT $LN83@dump_tdb
$LN82@dump_tdb:
  015bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194443
  015c6	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv845[rsp], rax
$LN83@dump_tdb:
  015ce	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  015d6	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  015dd	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv848[rsp], eax
  015e4	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  015ec	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  015f3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  015fa	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  01602	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01608	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR tv850[rsp], rax
  01610	b9 01 00 00 00	 mov	 ecx, 1
  01615	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0161b	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  01623	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01628	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR tv845[rsp]
  01630	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01635	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv848[rsp]
  0163c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01640	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR tv850[rsp]
  01648	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0164d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194444
  01654	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01659	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194445
  01660	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01665	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0166a	41 b9 03 00 00
	00		 mov	 r9d, 3
  01670	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194446
  01677	ba b4 09 00 00	 mov	 edx, 2484		; 000009b4H
  0167c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194447
  01683	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  01689	33 c0		 xor	 eax, eax
  0168b	85 c0		 test	 eax, eax
  0168d	0f 85 3f fe ff
	ff		 jne	 $LN7@dump_tdb
$LN10@dump_tdb:

; 2485 :         GRPAIR_FMT(  2 );

  01693	b8 08 00 00 00	 mov	 eax, 8
  01698	48 6b c0 02	 imul	 rax, rax, 2
  0169c	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  016a4	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  016ac	48 8b c8	 mov	 rcx, rax
  016af	e8 00 00 00 00	 call	 fetch_dw_noswap
  016b4	48 8b c8	 mov	 rcx, rax
  016b7	e8 00 00 00 00	 call	 _byteswap_uint64
  016bc	b9 08 00 00 00	 mov	 ecx, 8
  016c1	48 6b c9 02	 imul	 rcx, rcx, 2
  016c5	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  016cd	b8 08 00 00 00	 mov	 eax, 8
  016d2	48 6b c0 03	 imul	 rax, rax, 3
  016d6	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  016de	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  016e6	48 8b c8	 mov	 rcx, rax
  016e9	e8 00 00 00 00	 call	 fetch_dw_noswap
  016ee	48 8b c8	 mov	 rcx, rax
  016f1	e8 00 00 00 00	 call	 _byteswap_uint64
  016f6	b9 08 00 00 00	 mov	 ecx, 8
  016fb	48 6b c9 03	 imul	 rcx, rcx, 3
  016ff	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  01707	b8 08 00 00 00	 mov	 eax, 8
  0170c	48 6b c0 03	 imul	 rax, rax, 3
  01710	b9 08 00 00 00	 mov	 ecx, 8
  01715	48 6b c9 02	 imul	 rcx, rcx, 2
  01719	48 8b 84 04 b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rax]
  01721	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01726	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR [rsp+40], 3
  0172e	48 8b 84 0c b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rcx]
  01736	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0173b	41 b9 02 00 00
	00		 mov	 r9d, 2
  01741	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194448
  01748	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0174d	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  01755	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0175b	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01763	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01769	d1 e8		 shr	 eax, 1
  0176b	83 e0 01	 and	 eax, 1
  0176e	85 c0		 test	 eax, eax
  01770	74 11		 je	 SHORT $LN84@dump_tdb
  01772	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194449
  01779	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv902[rsp], rax
  01781	eb 0f		 jmp	 SHORT $LN85@dump_tdb
$LN84@dump_tdb:
  01783	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194450
  0178a	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv902[rsp], rax
$LN85@dump_tdb:
  01792	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0179a	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  017a1	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv905[rsp], eax
  017a8	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  017b0	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  017b7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  017be	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  017c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  017cc	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR tv907[rsp], rax
  017d4	b9 01 00 00 00	 mov	 ecx, 1
  017d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  017df	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  017e7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  017ec	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR tv902[rsp]
  017f4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  017f9	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv905[rsp]
  01800	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01804	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR tv907[rsp]
  0180c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01811	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194451
  01818	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0181d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194452
  01824	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01829	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0182e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01834	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194453
  0183b	ba b5 09 00 00	 mov	 edx, 2485		; 000009b5H
  01840	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194454
  01847	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  0184d	33 c0		 xor	 eax, eax
  0184f	85 c0		 test	 eax, eax
  01851	0f 85 3c fe ff
	ff		 jne	 $LN10@dump_tdb
$LN13@dump_tdb:

; 2486 :         GRPAIR_FMT(  4 );

  01857	b8 08 00 00 00	 mov	 eax, 8
  0185c	48 6b c0 04	 imul	 rax, rax, 4
  01860	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  01868	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  01870	48 8b c8	 mov	 rcx, rax
  01873	e8 00 00 00 00	 call	 fetch_dw_noswap
  01878	48 8b c8	 mov	 rcx, rax
  0187b	e8 00 00 00 00	 call	 _byteswap_uint64
  01880	b9 08 00 00 00	 mov	 ecx, 8
  01885	48 6b c9 04	 imul	 rcx, rcx, 4
  01889	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  01891	b8 08 00 00 00	 mov	 eax, 8
  01896	48 6b c0 05	 imul	 rax, rax, 5
  0189a	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  018a2	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  018aa	48 8b c8	 mov	 rcx, rax
  018ad	e8 00 00 00 00	 call	 fetch_dw_noswap
  018b2	48 8b c8	 mov	 rcx, rax
  018b5	e8 00 00 00 00	 call	 _byteswap_uint64
  018ba	b9 08 00 00 00	 mov	 ecx, 8
  018bf	48 6b c9 05	 imul	 rcx, rcx, 5
  018c3	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  018cb	b8 08 00 00 00	 mov	 eax, 8
  018d0	48 6b c0 05	 imul	 rax, rax, 5
  018d4	b9 08 00 00 00	 mov	 ecx, 8
  018d9	48 6b c9 04	 imul	 rcx, rcx, 4
  018dd	48 8b 84 04 b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rax]
  018e5	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  018ea	c7 44 24 28 05
	00 00 00	 mov	 DWORD PTR [rsp+40], 5
  018f2	48 8b 84 0c b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rcx]
  018fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  018ff	41 b9 04 00 00
	00		 mov	 r9d, 4
  01905	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194455
  0190c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  01911	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  01919	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0191f	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01927	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0192d	d1 e8		 shr	 eax, 1
  0192f	83 e0 01	 and	 eax, 1
  01932	85 c0		 test	 eax, eax
  01934	74 11		 je	 SHORT $LN86@dump_tdb
  01936	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194456
  0193d	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv959[rsp], rax
  01945	eb 0f		 jmp	 SHORT $LN87@dump_tdb
$LN86@dump_tdb:
  01947	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194457
  0194e	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv959[rsp], rax
$LN87@dump_tdb:
  01956	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0195e	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01965	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv962[rsp], eax
  0196c	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01974	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0197b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01982	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0198a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01990	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR tv964[rsp], rax
  01998	b9 01 00 00 00	 mov	 ecx, 1
  0199d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  019a3	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  019ab	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  019b0	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR tv959[rsp]
  019b8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  019bd	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv962[rsp]
  019c4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  019c8	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR tv964[rsp]
  019d0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  019d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194458
  019dc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  019e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194459
  019e8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  019ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  019f2	41 b9 03 00 00
	00		 mov	 r9d, 3
  019f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194460
  019ff	ba b6 09 00 00	 mov	 edx, 2486		; 000009b6H
  01a04	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194461
  01a0b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  01a11	33 c0		 xor	 eax, eax
  01a13	85 c0		 test	 eax, eax
  01a15	0f 85 3c fe ff
	ff		 jne	 $LN13@dump_tdb
$LN16@dump_tdb:

; 2487 :         GRPAIR_FMT(  6 );

  01a1b	b8 08 00 00 00	 mov	 eax, 8
  01a20	48 6b c0 06	 imul	 rax, rax, 6
  01a24	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  01a2c	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  01a34	48 8b c8	 mov	 rcx, rax
  01a37	e8 00 00 00 00	 call	 fetch_dw_noswap
  01a3c	48 8b c8	 mov	 rcx, rax
  01a3f	e8 00 00 00 00	 call	 _byteswap_uint64
  01a44	b9 08 00 00 00	 mov	 ecx, 8
  01a49	48 6b c9 06	 imul	 rcx, rcx, 6
  01a4d	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  01a55	b8 08 00 00 00	 mov	 eax, 8
  01a5a	48 6b c0 07	 imul	 rax, rax, 7
  01a5e	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  01a66	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  01a6e	48 8b c8	 mov	 rcx, rax
  01a71	e8 00 00 00 00	 call	 fetch_dw_noswap
  01a76	48 8b c8	 mov	 rcx, rax
  01a79	e8 00 00 00 00	 call	 _byteswap_uint64
  01a7e	b9 08 00 00 00	 mov	 ecx, 8
  01a83	48 6b c9 07	 imul	 rcx, rcx, 7
  01a87	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  01a8f	b8 08 00 00 00	 mov	 eax, 8
  01a94	48 6b c0 07	 imul	 rax, rax, 7
  01a98	b9 08 00 00 00	 mov	 ecx, 8
  01a9d	48 6b c9 06	 imul	 rcx, rcx, 6
  01aa1	48 8b 84 04 b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rax]
  01aa9	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01aae	c7 44 24 28 07
	00 00 00	 mov	 DWORD PTR [rsp+40], 7
  01ab6	48 8b 84 0c b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rcx]
  01abe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01ac3	41 b9 06 00 00
	00		 mov	 r9d, 6
  01ac9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194462
  01ad0	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  01ad5	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  01add	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  01ae3	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01aeb	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01af1	d1 e8		 shr	 eax, 1
  01af3	83 e0 01	 and	 eax, 1
  01af6	85 c0		 test	 eax, eax
  01af8	74 11		 je	 SHORT $LN88@dump_tdb
  01afa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194463
  01b01	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv1016[rsp], rax
  01b09	eb 0f		 jmp	 SHORT $LN89@dump_tdb
$LN88@dump_tdb:
  01b0b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194464
  01b12	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv1016[rsp], rax
$LN89@dump_tdb:
  01b1a	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b22	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01b29	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv1019[rsp], eax
  01b30	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b38	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01b3f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01b46	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  01b4e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01b54	48 89 84 24 88
	02 00 00	 mov	 QWORD PTR tv1021[rsp], rax
  01b5c	b9 01 00 00 00	 mov	 ecx, 1
  01b61	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01b67	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  01b6f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01b74	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR tv1016[rsp]
  01b7c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01b81	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv1019[rsp]
  01b88	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01b8c	48 8b 8c 24 88
	02 00 00	 mov	 rcx, QWORD PTR tv1021[rsp]
  01b94	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01b99	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194465
  01ba0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01ba5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194466
  01bac	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01bb1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01bb6	41 b9 03 00 00
	00		 mov	 r9d, 3
  01bbc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194467
  01bc3	ba b7 09 00 00	 mov	 edx, 2487		; 000009b7H
  01bc8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194468
  01bcf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  01bd5	33 c0		 xor	 eax, eax
  01bd7	85 c0		 test	 eax, eax
  01bd9	0f 85 3c fe ff
	ff		 jne	 $LN16@dump_tdb
$LN19@dump_tdb:

; 2488 :         GRPAIR_FMT(  8 );

  01bdf	b8 08 00 00 00	 mov	 eax, 8
  01be4	48 6b c0 08	 imul	 rax, rax, 8
  01be8	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  01bf0	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  01bf8	48 8b c8	 mov	 rcx, rax
  01bfb	e8 00 00 00 00	 call	 fetch_dw_noswap
  01c00	48 8b c8	 mov	 rcx, rax
  01c03	e8 00 00 00 00	 call	 _byteswap_uint64
  01c08	b9 08 00 00 00	 mov	 ecx, 8
  01c0d	48 6b c9 08	 imul	 rcx, rcx, 8
  01c11	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  01c19	b8 08 00 00 00	 mov	 eax, 8
  01c1e	48 6b c0 09	 imul	 rax, rax, 9
  01c22	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  01c2a	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  01c32	48 8b c8	 mov	 rcx, rax
  01c35	e8 00 00 00 00	 call	 fetch_dw_noswap
  01c3a	48 8b c8	 mov	 rcx, rax
  01c3d	e8 00 00 00 00	 call	 _byteswap_uint64
  01c42	b9 08 00 00 00	 mov	 ecx, 8
  01c47	48 6b c9 09	 imul	 rcx, rcx, 9
  01c4b	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  01c53	b8 08 00 00 00	 mov	 eax, 8
  01c58	48 6b c0 09	 imul	 rax, rax, 9
  01c5c	b9 08 00 00 00	 mov	 ecx, 8
  01c61	48 6b c9 08	 imul	 rcx, rcx, 8
  01c65	48 8b 84 04 b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rax]
  01c6d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01c72	c7 44 24 28 09
	00 00 00	 mov	 DWORD PTR [rsp+40], 9
  01c7a	48 8b 84 0c b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rcx]
  01c82	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01c87	41 b9 08 00 00
	00		 mov	 r9d, 8
  01c8d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194469
  01c94	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  01c99	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  01ca1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  01ca7	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01caf	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01cb5	d1 e8		 shr	 eax, 1
  01cb7	83 e0 01	 and	 eax, 1
  01cba	85 c0		 test	 eax, eax
  01cbc	74 11		 je	 SHORT $LN90@dump_tdb
  01cbe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194470
  01cc5	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv1105[rsp], rax
  01ccd	eb 0f		 jmp	 SHORT $LN91@dump_tdb
$LN90@dump_tdb:
  01ccf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194471
  01cd6	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv1105[rsp], rax
$LN91@dump_tdb:
  01cde	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ce6	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01ced	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv1108[rsp], eax
  01cf4	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01cfc	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01d03	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01d0a	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  01d12	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01d18	48 89 84 24 90
	02 00 00	 mov	 QWORD PTR tv1110[rsp], rax
  01d20	b9 01 00 00 00	 mov	 ecx, 1
  01d25	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01d2b	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  01d33	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01d38	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR tv1105[rsp]
  01d40	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01d45	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv1108[rsp]
  01d4c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01d50	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR tv1110[rsp]
  01d58	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01d5d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194472
  01d64	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01d69	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194473
  01d70	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01d75	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01d7a	41 b9 03 00 00
	00		 mov	 r9d, 3
  01d80	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194474
  01d87	ba b8 09 00 00	 mov	 edx, 2488		; 000009b8H
  01d8c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194475
  01d93	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  01d99	33 c0		 xor	 eax, eax
  01d9b	85 c0		 test	 eax, eax
  01d9d	0f 85 3c fe ff
	ff		 jne	 $LN19@dump_tdb
$LN22@dump_tdb:

; 2489 :         GRPAIR_FMT( 10 );

  01da3	b8 08 00 00 00	 mov	 eax, 8
  01da8	48 6b c0 0a	 imul	 rax, rax, 10
  01dac	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  01db4	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  01dbc	48 8b c8	 mov	 rcx, rax
  01dbf	e8 00 00 00 00	 call	 fetch_dw_noswap
  01dc4	48 8b c8	 mov	 rcx, rax
  01dc7	e8 00 00 00 00	 call	 _byteswap_uint64
  01dcc	b9 08 00 00 00	 mov	 ecx, 8
  01dd1	48 6b c9 0a	 imul	 rcx, rcx, 10
  01dd5	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  01ddd	b8 08 00 00 00	 mov	 eax, 8
  01de2	48 6b c0 0b	 imul	 rax, rax, 11
  01de6	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  01dee	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  01df6	48 8b c8	 mov	 rcx, rax
  01df9	e8 00 00 00 00	 call	 fetch_dw_noswap
  01dfe	48 8b c8	 mov	 rcx, rax
  01e01	e8 00 00 00 00	 call	 _byteswap_uint64
  01e06	b9 08 00 00 00	 mov	 ecx, 8
  01e0b	48 6b c9 0b	 imul	 rcx, rcx, 11
  01e0f	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  01e17	b8 08 00 00 00	 mov	 eax, 8
  01e1c	48 6b c0 0b	 imul	 rax, rax, 11
  01e20	b9 08 00 00 00	 mov	 ecx, 8
  01e25	48 6b c9 0a	 imul	 rcx, rcx, 10
  01e29	48 8b 84 04 b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rax]
  01e31	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01e36	c7 44 24 28 0b
	00 00 00	 mov	 DWORD PTR [rsp+40], 11
  01e3e	48 8b 84 0c b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rcx]
  01e46	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e4b	41 b9 0a 00 00
	00		 mov	 r9d, 10
  01e51	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194476
  01e58	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  01e5d	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  01e65	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  01e6b	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e73	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01e79	d1 e8		 shr	 eax, 1
  01e7b	83 e0 01	 and	 eax, 1
  01e7e	85 c0		 test	 eax, eax
  01e80	74 11		 je	 SHORT $LN92@dump_tdb
  01e82	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194477
  01e89	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv1162[rsp], rax
  01e91	eb 0f		 jmp	 SHORT $LN93@dump_tdb
$LN92@dump_tdb:
  01e93	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194478
  01e9a	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv1162[rsp], rax
$LN93@dump_tdb:
  01ea2	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01eaa	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01eb1	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv1165[rsp], eax
  01eb8	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01ec0	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01ec7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01ece	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  01ed6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01edc	48 89 84 24 98
	02 00 00	 mov	 QWORD PTR tv1167[rsp], rax
  01ee4	b9 01 00 00 00	 mov	 ecx, 1
  01ee9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01eef	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  01ef7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01efc	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR tv1162[rsp]
  01f04	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01f09	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv1165[rsp]
  01f10	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01f14	48 8b 8c 24 98
	02 00 00	 mov	 rcx, QWORD PTR tv1167[rsp]
  01f1c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01f21	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194479
  01f28	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01f2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194480
  01f34	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01f39	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01f3e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01f44	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194481
  01f4b	ba b9 09 00 00	 mov	 edx, 2489		; 000009b9H
  01f50	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194482
  01f57	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  01f5d	33 c0		 xor	 eax, eax
  01f5f	85 c0		 test	 eax, eax
  01f61	0f 85 3c fe ff
	ff		 jne	 $LN22@dump_tdb
$LN25@dump_tdb:

; 2490 :         GRPAIR_FMT( 12 );

  01f67	b8 08 00 00 00	 mov	 eax, 8
  01f6c	48 6b c0 0c	 imul	 rax, rax, 12
  01f70	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  01f78	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  01f80	48 8b c8	 mov	 rcx, rax
  01f83	e8 00 00 00 00	 call	 fetch_dw_noswap
  01f88	48 8b c8	 mov	 rcx, rax
  01f8b	e8 00 00 00 00	 call	 _byteswap_uint64
  01f90	b9 08 00 00 00	 mov	 ecx, 8
  01f95	48 6b c9 0c	 imul	 rcx, rcx, 12
  01f99	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  01fa1	b8 08 00 00 00	 mov	 eax, 8
  01fa6	48 6b c0 0d	 imul	 rax, rax, 13
  01faa	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  01fb2	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  01fba	48 8b c8	 mov	 rcx, rax
  01fbd	e8 00 00 00 00	 call	 fetch_dw_noswap
  01fc2	48 8b c8	 mov	 rcx, rax
  01fc5	e8 00 00 00 00	 call	 _byteswap_uint64
  01fca	b9 08 00 00 00	 mov	 ecx, 8
  01fcf	48 6b c9 0d	 imul	 rcx, rcx, 13
  01fd3	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  01fdb	b8 08 00 00 00	 mov	 eax, 8
  01fe0	48 6b c0 0d	 imul	 rax, rax, 13
  01fe4	b9 08 00 00 00	 mov	 ecx, 8
  01fe9	48 6b c9 0c	 imul	 rcx, rcx, 12
  01fed	48 8b 84 04 b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rax]
  01ff5	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01ffa	c7 44 24 28 0d
	00 00 00	 mov	 DWORD PTR [rsp+40], 13
  02002	48 8b 84 0c b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rcx]
  0200a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0200f	41 b9 0c 00 00
	00		 mov	 r9d, 12
  02015	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194483
  0201c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  02021	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  02029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0202f	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02037	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0203d	d1 e8		 shr	 eax, 1
  0203f	83 e0 01	 and	 eax, 1
  02042	85 c0		 test	 eax, eax
  02044	74 11		 je	 SHORT $LN94@dump_tdb
  02046	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194484
  0204d	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv1219[rsp], rax
  02055	eb 0f		 jmp	 SHORT $LN95@dump_tdb
$LN94@dump_tdb:
  02057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194485
  0205e	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv1219[rsp], rax
$LN95@dump_tdb:
  02066	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0206e	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  02075	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv1222[rsp], eax
  0207c	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02084	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0208b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  02092	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0209a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  020a0	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR tv1224[rsp], rax
  020a8	b9 01 00 00 00	 mov	 ecx, 1
  020ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  020b3	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  020bb	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  020c0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv1219[rsp]
  020c8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  020cd	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv1222[rsp]
  020d4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  020d8	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR tv1224[rsp]
  020e0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  020e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194486
  020ec	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  020f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194487
  020f8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  020fd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02102	41 b9 03 00 00
	00		 mov	 r9d, 3
  02108	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194488
  0210f	ba ba 09 00 00	 mov	 edx, 2490		; 000009baH
  02114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194489
  0211b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  02121	33 c0		 xor	 eax, eax
  02123	85 c0		 test	 eax, eax
  02125	0f 85 3c fe ff
	ff		 jne	 $LN25@dump_tdb
$LN28@dump_tdb:

; 2491 :         GRPAIR_FMT( 14 );

  0212b	b8 08 00 00 00	 mov	 eax, 8
  02130	48 6b c0 0e	 imul	 rax, rax, 14
  02134	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  0213c	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  02144	48 8b c8	 mov	 rcx, rax
  02147	e8 00 00 00 00	 call	 fetch_dw_noswap
  0214c	48 8b c8	 mov	 rcx, rax
  0214f	e8 00 00 00 00	 call	 _byteswap_uint64
  02154	b9 08 00 00 00	 mov	 ecx, 8
  02159	48 6b c9 0e	 imul	 rcx, rcx, 14
  0215d	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  02165	b8 08 00 00 00	 mov	 eax, 8
  0216a	48 6b c0 0f	 imul	 rax, rax, 15
  0216e	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR tdb$[rsp]
  02176	48 8d 84 01 80
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+128]
  0217e	48 8b c8	 mov	 rcx, rax
  02181	e8 00 00 00 00	 call	 fetch_dw_noswap
  02186	48 8b c8	 mov	 rcx, rax
  02189	e8 00 00 00 00	 call	 _byteswap_uint64
  0218e	b9 08 00 00 00	 mov	 ecx, 8
  02193	48 6b c9 0f	 imul	 rcx, rcx, 15
  02197	48 89 84 0c b0
	02 00 00	 mov	 QWORD PTR gr$19[rsp+rcx], rax
  0219f	b8 08 00 00 00	 mov	 eax, 8
  021a4	48 6b c0 0f	 imul	 rax, rax, 15
  021a8	b9 08 00 00 00	 mov	 ecx, 8
  021ad	48 6b c9 0e	 imul	 rcx, rcx, 14
  021b1	48 8b 84 04 b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rax]
  021b9	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  021be	c7 44 24 28 0f
	00 00 00	 mov	 DWORD PTR [rsp+40], 15
  021c6	48 8b 84 0c b0
	02 00 00	 mov	 rax, QWORD PTR gr$19[rsp+rcx]
  021ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  021d3	41 b9 0e 00 00
	00		 mov	 r9d, 14
  021d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194490
  021e0	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  021e5	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  021ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  021f3	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  021fb	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  02201	d1 e8		 shr	 eax, 1
  02203	83 e0 01	 and	 eax, 1
  02206	85 c0		 test	 eax, eax
  02208	74 11		 je	 SHORT $LN96@dump_tdb
  0220a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194491
  02211	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv1276[rsp], rax
  02219	eb 0f		 jmp	 SHORT $LN97@dump_tdb
$LN96@dump_tdb:
  0221b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194492
  02222	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv1276[rsp], rax
$LN97@dump_tdb:
  0222a	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02232	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  02239	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv1279[rsp], eax
  02240	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02248	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0224f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  02256	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0225e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  02264	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR tv1281[rsp], rax
  0226c	b9 01 00 00 00	 mov	 ecx, 1
  02271	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02277	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$21[rsp]
  0227f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  02284	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv1276[rsp]
  0228c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  02291	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv1279[rsp]
  02298	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0229c	48 8b 8c 24 a8
	02 00 00	 mov	 rcx, QWORD PTR tv1281[rsp]
  022a4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  022a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194493
  022b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  022b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194494
  022bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  022c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  022c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  022cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194495
  022d3	ba bb 09 00 00	 mov	 edx, 2491		; 000009bbH
  022d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194496
  022df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  022e5	33 c0		 xor	 eax, eax
  022e7	85 c0		 test	 eax, eax
  022e9	0f 85 3c fe ff
	ff		 jne	 $LN28@dump_tdb
$LN33@dump_tdb:
$LN1@dump_tdb:

; 2492 :     }
; 2493 : }

  022ef	48 8b 8c 24 20
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  022f7	48 33 cc	 xor	 rcx, rsp
  022fa	e8 00 00 00 00	 call	 __security_check_cookie
  022ff	48 81 c4 38 04
	00 00		 add	 rsp, 1080		; 00000438H
  02306	5f		 pop	 rdi
  02307	5e		 pop	 rsi
  02308	c3		 ret	 0
dump_tdb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
dmp$ = 96
tv78 = 104
tv156 = 108
tv75 = 112
tv153 = 120
adr$ = 128
dat$ = 136
tv144 = 144
tv158 = 152
dump_pfx$ = 160
__$ArrayPad$ = 224
regs$ = 256
pfxfmt$ = 264
linenum$ = 272
line$ = 280
dump_cache PROC

; 2291 : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2292 :     char*  /* (work) */  dmp  = NULL;

  0002e	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR dmp$[rsp], 0

; 2293 :     const char*          dat  = (const char*) line;

  00037	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR line$[rsp]
  0003f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dat$[rsp], rax

; 2294 :     static const size_t  skp  = 0;
; 2295 :     static const size_t  amt  = ZCACHE_LINE_SIZE;
; 2296 :     U64 /* (cosmetic) */ adr  = linenum << ZCACHE_LINE_SHIFT;

  00047	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR linenum$[rsp]
  0004e	c1 e0 08	 shl	 eax, 8
  00051	48 98		 cdqe
  00053	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR adr$[rsp], rax

; 2297 :     static const size_t  bpg  = 4; // bytes per formatted group
; 2298 :     static const size_t  gpl  = 4; // formatted groups per line
; 2299 :     char dump_pfx[64]         = {0};

  0005b	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR dump_pfx$[rsp]
  00063	48 8b f8	 mov	 rdi, rax
  00066	33 c0		 xor	 eax, eax
  00068	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0006d	f3 aa		 rep stosb

; 2300 : 
; 2301 :     MSGBUF(     dump_pfx, pfxfmt, TXF_CPUAD( regs ), TXF_QSIE( regs ));

  0006f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00077	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0007d	d1 e8		 shr	 eax, 1
  0007f	83 e0 01	 and	 eax, 1
  00082	85 c0		 test	 eax, eax
  00084	74 0e		 je	 SHORT $LN5@dump_cache
  00086	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194235
  0008d	48 89 44 24 70	 mov	 QWORD PTR tv75[rsp], rax
  00092	eb 0c		 jmp	 SHORT $LN6@dump_cache
$LN5@dump_cache:
  00094	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194236
  0009b	48 89 44 24 70	 mov	 QWORD PTR tv75[rsp], rax
$LN6@dump_cache:
  000a0	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000af	89 44 24 68	 mov	 DWORD PTR tv78[rsp], eax
  000b3	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bb	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  000c2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000c9	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  000d7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv75[rsp]
  000dc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e1	8b 4c 24 68	 mov	 ecx, DWORD PTR tv78[rsp]
  000e5	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000e9	4c 8b c8	 mov	 r9, rax
  000ec	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR pfxfmt$[rsp]
  000f4	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  000f9	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dump_pfx$[rsp]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2302 :     RTRIM(      dump_pfx );

  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194237
  0010e	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dump_pfx$[rsp]
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim

; 2303 :     hexdumpe16( dump_pfx, &dmp, dat, skp, amt, adr, bpg, gpl );

  0011c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?gpl@?1??dump_cache@@9@9
  00123	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00128	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?bpg@?1??dump_cache@@9@9
  0012f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00134	c7 44 24 30 10
	00 00 00	 mov	 DWORD PTR [rsp+48], 16
  0013c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR adr$[rsp]
  00144	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00149	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?amt@?1??dump_cache@@9@9
  00150	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00155	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ?skp@?1??dump_cache@@9@9
  0015c	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR dat$[rsp]
  00164	48 8d 54 24 60	 lea	 rdx, QWORD PTR dmp$[rsp]
  00169	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR dump_pfx$[rsp]
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hexdumpew

; 2304 : 
; 2305 :     if (dmp)

  00177	48 83 7c 24 60
	00		 cmp	 QWORD PTR dmp$[rsp], 0
  0017d	74 55		 je	 SHORT $LN2@dump_cache

; 2306 :     {
; 2307 :         LOGMSG( "%s", dmp );

  0017f	b9 01 00 00 00	 mov	 ecx, 1
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0018a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dmp$[rsp]
  0018f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194240
  0019b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001a0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a5	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194241
  001b2	ba 03 09 00 00	 mov	 edx, 2307		; 00000903H
  001b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194242
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2308 :         free( dmp );

  001c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dmp$[rsp]
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2309 :     }

  001cf	e9 05 01 00 00	 jmp	 $LN3@dump_cache
$LN2@dump_cache:

; 2310 :     else
; 2311 :     {
; 2312 :         // "TXF: %s%02X: %serror in function %s: %s"
; 2313 :         WRMSG( HHC17708, "E", TXF_CPUAD( regs ), TXF_QSIE( regs ),

  001d4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001dc	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001e2	d1 e8		 shr	 eax, 1
  001e4	83 e0 01	 and	 eax, 1
  001e7	85 c0		 test	 eax, eax
  001e9	74 0e		 je	 SHORT $LN7@dump_cache
  001eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194244
  001f2	48 89 44 24 78	 mov	 QWORD PTR tv153[rsp], rax
  001f7	eb 0c		 jmp	 SHORT $LN8@dump_cache
$LN7@dump_cache:
  001f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194245
  00200	48 89 44 24 78	 mov	 QWORD PTR tv153[rsp], rax
$LN8@dump_cache:
  00205	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0020b	8b 08		 mov	 ecx, DWORD PTR [rax]
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00213	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv144[rsp], rax
  0021b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00223	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0022a	89 4c 24 6c	 mov	 DWORD PTR tv156[rsp], ecx
  0022e	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00236	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  0023d	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00244	0f b6 8c 17 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdi+rdx+2888]
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00252	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv158[rsp], rax
  0025a	b9 01 00 00 00	 mov	 ecx, 1
  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00265	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv144[rsp]
  0026d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00272	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194243
  00279	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0027e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv153[rsp]
  00283	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00288	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv156[rsp]
  0028c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00290	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv158[rsp]
  00298	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0029d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194246
  002a4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194247
  002b0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ba	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194248
  002c7	ba 0a 09 00 00	 mov	 edx, 2314		; 0000090aH
  002cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194249
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@dump_cache:

; 2314 :             "dump_cache()", strerror( errno ));
; 2315 :     }
; 2316 : }

  002d9	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002e1	48 33 cc	 xor	 rcx, rsp
  002e4	e8 00 00 00 00	 call	 __security_check_cookie
  002e9	48 81 c4 f0 00
	00 00		 add	 rsp, 240		; 000000f0H
  002f0	5f		 pop	 rdi
  002f1	c3		 ret	 0
dump_cache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
tac$ = 48
tac2long PROC

; 2238 : const char* tac2long ( U64 tac ) { return tac2name( tac, true  ); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 01		 mov	 dl, 1
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tac$[rsp]
  00010	e8 00 00 00 00	 call	 tac2name
  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
tac2long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\transact.c
_TEXT	SEGMENT
tac$ = 48
tac2short PROC

; 2239 : const char* tac2short( U64 tac ) { return tac2name( tac, false ); }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	33 d2		 xor	 edx, edx
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tac$[rsp]
  00010	e8 00 00 00 00	 call	 tac2name
  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
tac2short ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
