; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	episode_current
PUBLIC	hw_steering
PUBLIC	hw_offset
PUBLIC	hw_unique_clock_tick
PUBLIC	default_epoch
PUBLIC	default_yroffset
PUBLIC	default_tzoffset
_DATA	SEGMENT
COMM	hw_tod:BYTE:010H
COMM	tod_epoch:QWORD
COMM	tod_value:BYTE:010H
COMM	universal_tod:BYTE:010H
COMM	episode_old:BYTE:018H
COMM	episode_new:BYTE:018H
_DATA	ENDS
_BSS	SEGMENT
hw_steering DQ	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	hw_episode:QWORD
_DATA	ENDS
_BSS	SEGMENT
hw_offset DQ	01H DUP (?)
hw_unique_clock_tick DB 010H DUP (?)
default_yroffset DD 01H DUP (?)
default_tzoffset DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
episode_current DQ FLAT:episode_new
default_epoch DD 076cH
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+8
?uib@?1??z900_query_utc_information@@9@9	ORG $+256	; `z900_query_utc_information'::`2'::uib
?m1@?1??hw_calculate_unique_tick@@9@9 DQ 0000000000010000H ; `hw_calculate_unique_tick'::`2'::m1
	DQ	0000000000000000H
?adj@?3??hw_calculate_unique_tick@@9@9 DQ 0000000100000000H ; `hw_calculate_unique_tick'::`4'::adj
	DQ	0000000000000000H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	csr_reset
PUBLIC	set_tod_steering
PUBLIC	get_tod_steering
PUBLIC	update_tod_clock
PUBLIC	get_tod_epoch
PUBLIC	hw_clock
PUBLIC	set_tod_clock
PUBLIC	clock_hsuspend
PUBLIC	clock_hresume
PUBLIC	query_tzoffset
PUBLIC	s370_fetch_int_timer
PUBLIC	s370_store_int_timer
PUBLIC	s370_store_int_timer_locked
PUBLIC	etod_clock
PUBLIC	get_tod_clock
PUBLIC	get_cpu_timer
PUBLIC	set_cpu_timer
PUBLIC	set_int_timer
PUBLIC	chk_int_timer
PUBLIC	thread_cputime_us
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	configure_epoch
PUBLIC	configure_yroffset
PUBLIC	configure_tzoffset
PUBLIC	host_ETOD
PUBLIC	set_tod_epoch
PUBLIC	adjust_tod_epoch
PUBLIC	z900_maddr_l
PUBLIC	z900_vstore8_full
PUBLIC	z900_vfetch4_full
PUBLIC	z900_vfetch8_full
PUBLIC	z900_vstorec
PUBLIC	z900_vstore8
PUBLIC	z900_vfetch4
PUBLIC	z900_vfetch8
PUBLIC	z900_set_gross_s_rate
PUBLIC	z900_set_fine_s_rate
PUBLIC	z900_set_tod_offset
PUBLIC	z900_set_tod_offset_user
PUBLIC	z900_adjust_tod_offset
PUBLIC	z900_query_physical_clock
PUBLIC	z900_query_utc_information
PUBLIC	z900_query_steering_information
PUBLIC	z900_query_tod_offset
PUBLIC	z900_query_tod_offset_user
PUBLIC	z900_query_available_functions
PUBLIC	__real@4000000000000000
PUBLIC	__real@43e0000000000000
EXTRN	__imp__errno:PROC
EXTRN	strlen:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_ldexp:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_clock_gettime:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	update_cpu_timer:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$csr_reset DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$csr_reset
$pdata$set_tod_steering DD imagerel $LN3
	DD	imagerel $LN3+120
	DD	imagerel $unwind$set_tod_steering
$pdata$update_tod_clock DD imagerel $LN4
	DD	imagerel $LN4+161
	DD	imagerel $unwind$update_tod_clock
$pdata$hw_clock DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$hw_clock
$pdata$set_tod_clock DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$set_tod_clock
$pdata$clock_hsuspend DD imagerel $LN57
	DD	imagerel $LN57+799
	DD	imagerel $unwind$clock_hsuspend
$pdata$clock_hresume DD imagerel $LN87
	DD	imagerel $LN87+1352
	DD	imagerel $unwind$clock_hresume
$pdata$ETOD_add DD imagerel ETOD_add
	DD	imagerel ETOD_add+119
	DD	imagerel $unwind$ETOD_add
$pdata$ETOD_sub DD imagerel ETOD_sub
	DD	imagerel ETOD_sub+128
	DD	imagerel $unwind$ETOD_sub
$pdata$ETOD_shift DD imagerel ETOD_shift
	DD	imagerel ETOD_shift+501
	DD	imagerel $unwind$ETOD_shift
$pdata$host_tod DD imagerel host_tod
	DD	imagerel host_tod+169
	DD	imagerel $unwind$host_tod
$pdata$timespec2usecs DD imagerel timespec2usecs
	DD	imagerel timespec2usecs+66
	DD	imagerel $unwind$timespec2usecs
$pdata$s370_fetch_int_timer DD imagerel $LN8
	DD	imagerel $LN8+226
	DD	imagerel $unwind$s370_fetch_int_timer
$pdata$s370_store_int_timer DD imagerel $LN7
	DD	imagerel $LN7+130
	DD	imagerel $unwind$s370_store_int_timer
$pdata$s370_store_int_timer_locked DD imagerel $LN5
	DD	imagerel $LN5+165
	DD	imagerel $unwind$s370_store_int_timer_locked
$pdata$etod_clock DD imagerel $LN45
	DD	imagerel $LN45+900
	DD	imagerel $unwind$etod_clock
$pdata$get_tod_clock DD imagerel $LN3
	DD	imagerel $LN3+63
	DD	imagerel $unwind$get_tod_clock
$pdata$get_cpu_timer DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$get_cpu_timer
$pdata$set_cpu_timer DD imagerel $LN6
	DD	imagerel $LN6+226
	DD	imagerel $unwind$set_cpu_timer
$pdata$set_int_timer DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$set_int_timer
$pdata$chk_int_timer DD imagerel $LN16
	DD	imagerel $LN16+277
	DD	imagerel $unwind$chk_int_timer
$pdata$thread_cputime_us DD imagerel $LN10
	DD	imagerel $LN10+202
	DD	imagerel $unwind$thread_cputime_us
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$configure_epoch DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$configure_epoch
$pdata$configure_yroffset DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$configure_yroffset
$pdata$configure_tzoffset DD imagerel $LN5
	DD	imagerel $LN5+57
	DD	imagerel $unwind$configure_tzoffset
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
$pdata$sr_write_hdr DD imagerel sr_write_hdr
	DD	imagerel sr_write_hdr+199
	DD	imagerel $unwind$sr_write_hdr
$pdata$sr_write_value DD imagerel sr_write_value
	DD	imagerel sr_write_value+378
	DD	imagerel $unwind$sr_write_value
$pdata$sr_write_string DD imagerel sr_write_string
	DD	imagerel sr_write_string+190
	DD	imagerel $unwind$sr_write_string
$pdata$sr_read_hdr DD imagerel sr_read_hdr
	DD	imagerel sr_read_hdr+221
	DD	imagerel $unwind$sr_read_hdr
$pdata$sr_read_value DD imagerel sr_read_value
	DD	imagerel sr_read_value+588
	DD	imagerel $unwind$sr_read_value
$pdata$sr_read_string DD imagerel sr_read_string
	DD	imagerel sr_read_string+143
	DD	imagerel $unwind$sr_read_string
$pdata$sr_read_skip DD imagerel sr_read_skip
	DD	imagerel sr_read_skip+248
	DD	imagerel $unwind$sr_read_skip
$pdata$sr_write_error_ DD imagerel sr_write_error_
	DD	imagerel sr_write_error_+121
	DD	imagerel $unwind$sr_write_error_
$pdata$sr_read_error_ DD imagerel sr_read_error_
	DD	imagerel sr_read_error_+121
	DD	imagerel $unwind$sr_read_error_
$pdata$sr_value_error_ DD imagerel sr_value_error_
	DD	imagerel sr_value_error_+80
	DD	imagerel $unwind$sr_value_error_
$pdata$sr_string_error_ DD imagerel sr_string_error_
	DD	imagerel sr_string_error_+80
	DD	imagerel $unwind$sr_string_error_
$pdata$universal_clock DD imagerel universal_clock
	DD	imagerel universal_clock+28
	DD	imagerel $unwind$universal_clock
$pdata$hw_calculate_unique_tick DD imagerel hw_calculate_unique_tick
	DD	imagerel hw_calculate_unique_tick+494
	DD	imagerel $unwind$hw_calculate_unique_tick
$pdata$hw_adjust DD imagerel hw_adjust
	DD	imagerel hw_adjust+328
	DD	imagerel $unwind$hw_adjust
$pdata$hw_clock_locked DD imagerel hw_clock_locked
	DD	imagerel hw_clock_locked+22
	DD	imagerel $unwind$hw_clock_locked
$pdata$host_ETOD DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$host_ETOD
$pdata$set_gross_steering_rate DD imagerel set_gross_steering_rate
	DD	imagerel set_gross_steering_rate+86
	DD	imagerel $unwind$set_gross_steering_rate
$pdata$set_fine_steering_rate DD imagerel set_fine_steering_rate
	DD	imagerel set_fine_steering_rate+86
	DD	imagerel $unwind$set_fine_steering_rate
$pdata$prepare_new_episode DD imagerel prepare_new_episode
	DD	imagerel prepare_new_episode+63
	DD	imagerel $unwind$prepare_new_episode
$pdata$start_new_episode DD imagerel start_new_episode
	DD	imagerel start_new_episode+129
	DD	imagerel $unwind$start_new_episode
$pdata$set_tod_offset DD imagerel set_tod_offset
	DD	imagerel set_tod_offset+89
	DD	imagerel $unwind$set_tod_offset
$pdata$adjust_tod_offset DD imagerel adjust_tod_offset
	DD	imagerel adjust_tod_offset+102
	DD	imagerel $unwind$adjust_tod_offset
$pdata$set_tod_epoch DD imagerel $LN3
	DD	imagerel $LN3+101
	DD	imagerel $unwind$set_tod_epoch
$pdata$adjust_tod_epoch DD imagerel $LN3
	DD	imagerel $LN3+114
	DD	imagerel $unwind$adjust_tod_epoch
$pdata$set_tod_epoch_all DD imagerel set_tod_epoch_all
	DD	imagerel set_tod_epoch_all+194
	DD	imagerel $unwind$set_tod_epoch_all
$pdata$configure_time DD imagerel configure_time
	DD	imagerel configure_time+227
	DD	imagerel $unwind$configure_time
$pdata$is_leapyear DD imagerel is_leapyear
	DD	imagerel is_leapyear+115
	DD	imagerel $unwind$is_leapyear
$pdata$lyear_adjust DD imagerel lyear_adjust
	DD	imagerel lyear_adjust+420
	DD	imagerel $unwind$lyear_adjust
$pdata$get_ecps_vtimer DD imagerel get_ecps_vtimer
	DD	imagerel get_ecps_vtimer+51
	DD	imagerel $unwind$get_ecps_vtimer
$pdata$set_ecps_vtimer DD imagerel set_ecps_vtimer
	DD	imagerel set_ecps_vtimer+91
	DD	imagerel $unwind$set_ecps_vtimer
$pdata$get_int_timer DD imagerel get_int_timer
	DD	imagerel get_int_timer+51
	DD	imagerel $unwind$get_int_timer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8_full DD imagerel $LN3
	DD	imagerel $LN3+375
	DD	imagerel $unwind$z900_vstore8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch8_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8 DD imagerel $LN9
	DD	imagerel $LN9+174
	DD	imagerel $unwind$z900_vstore8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+195
	DD	imagerel $unwind$z900_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch8 DD imagerel $LN8
	DD	imagerel $LN8+157
	DD	imagerel $unwind$z900_vfetch8
pdata	ENDS
pdata	SEGMENT
$pdata$z900_set_gross_s_rate DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$z900_set_gross_s_rate
$pdata$z900_set_fine_s_rate DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$z900_set_fine_s_rate
$pdata$z900_set_tod_offset DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$z900_set_tod_offset
$pdata$z900_set_tod_offset_user DD imagerel $LN4
	DD	imagerel $LN4+242
	DD	imagerel $unwind$z900_set_tod_offset_user
$pdata$z900_adjust_tod_offset DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$z900_adjust_tod_offset
$pdata$z900_query_physical_clock DD imagerel $LN3
	DD	imagerel $LN3+92
	DD	imagerel $unwind$z900_query_physical_clock
$pdata$z900_query_utc_information DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$z900_query_utc_information
$pdata$z900_query_steering_information DD imagerel $LN3
	DD	imagerel $LN3+427
	DD	imagerel $unwind$z900_query_steering_information
$pdata$build_qto_locked DD imagerel build_qto_locked
	DD	imagerel build_qto_locked+187
	DD	imagerel $unwind$build_qto_locked
$pdata$z900_query_tod_offset DD imagerel $LN3
	DD	imagerel $LN3+183
	DD	imagerel $unwind$z900_query_tod_offset
$pdata$z900_query_tod_offset_user DD imagerel $LN3
	DD	imagerel $LN3+203
	DD	imagerel $unwind$z900_query_tod_offset_user
$pdata$z900_query_available_functions DD imagerel $LN3
	DD	imagerel $LN3+461
	DD	imagerel $unwind$z900_query_available_functions
pdata	ENDS
;	COMDAT __real@43e0000000000000
CONST	SEGMENT
__real@43e0000000000000 DQ 043e0000000000000r	; 9.22337e+18
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
_DATA	SEGMENT
$SG178879 DB	'E', 00H
	ORG $+2
$SG178685 DB	'SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+1
$SG178687 DB	'SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+1
$SG178702 DB	'SR: sr_write_string: key=0x%8.8x', 0aH, 00H
	ORG $+2
$SG178884 DB	'read()', 00H
	ORG $+1
$SG178885 DB	'E', 00H
	ORG $+2
$SG178704 DB	'SR: sr_write_string: key=0x%8.8x', 0aH, 00H
	ORG $+6
$SG178773 DB	'SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+3
$SG178790 DB	'SR: sr_read_skip:                  len=0x%8.8x', 0aH, 00H
$SG178878 DB	'write()', 00H
$SG178751 DB	'SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16'
	DB	'.16llx', 0aH, 00H
$SG178753 DB	'SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16'
	DB	'.16llx', 0aH, 00H
$SG178775 DB	'SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+3
$SG178792 DB	'SR: sr_read_skip:                  len=0x%8.8x', 0aH, 00H
$SG178805 DB	'SR: sr_read_string:                len=0x%8.8x', 0aH, 00H
$SG178807 DB	'SR: sr_read_string:                len=0x%8.8x', 0aH, 00H
$SG178860 DB	'SR: sr_read_value:              suslen=0x%8.8x, reslen=0'
	DB	'x%8.8x,', 0aH, 00H
	ORG $+7
$SG178870 DB	'                           val=0x%16.16llx', 0aH, 00H
$SG178896 DB	'E', 00H
	ORG $+2
$SG178881 DB	'sr_write_error_', 00H
$SG178882 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
	ORG $+4
$SG178862 DB	'SR: sr_read_value:              suslen=0x%8.8x, reslen=0'
	DB	'x%8.8x,', 0aH, 00H
	ORG $+3
$SG178901 DB	'E', 00H
	ORG $+2
$SG178872 DB	'                           val=0x%16.16llx', 0aH, 00H
$SG201954 DB	'D', 00H
	ORG $+2
$SG178880 DB	'HHC02001%s SR: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG202362 DB	'%f', 00H
	ORG $+1
$SG178886 DB	'HHC02001%s SR: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG202497 DB	'%f', 00H
	ORG $+1
$SG178887 DB	'sr_read_error_', 00H
	ORG $+1
$SG178888 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
	ORG $+4
$SG178897 DB	'HHC02020%s SR: value error, incorrect length', 0aH, 00H
	ORG $+2
$SG178898 DB	'sr_value_error_', 00H
$SG178899 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
	ORG $+4
$SG178902 DB	'HHC02021%s SR: string error, incorrect length', 0aH, 00H
	ORG $+1
$SG178903 DB	'sr_string_error_', 00H
	ORG $+7
$SG178904 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
	ORG $+4
$SG179005 DB	'clock.c:500', 00H
	ORG $+4
$SG179006 DB	'clock.c:504', 00H
	ORG $+4
$SG179013 DB	'clock.c:516', 00H
	ORG $+4
$SG179015 DB	'clock.c:528', 00H
	ORG $+4
$SG201953 DB	'PTFF-STOU 0x%16.16llX!', 00H
	ORG $+1
$SG201955 DB	'HHC90000%s DBG: %s', 0aH, 00H
	ORG $+4
$SG201956 DB	'z900_set_tod_offset_user', 00H
	ORG $+7
$SG201957 DB	'C:\papa\MyGit\hyperion-zvector\clock.c', 00H
	ORG $+1
$SG201978 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:340', 00H
	ORG $+5
$SG201979 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:354', 00H
	ORG $+5
$SG201991 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:388', 00H
	ORG $+5
$SG201992 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:392', 00H
	ORG $+5
$SG202001 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:413', 00H
	ORG $+5
$SG202002 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:418', 00H
	ORG $+5
$SG202038 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:697', 00H
	ORG $+5
$SG202039 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:702', 00H
	ORG $+5
$SG202043 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:716', 00H
	ORG $+5
$SG202044 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:724', 00H
	ORG $+5
$SG202057 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:773', 00H
	ORG $+5
$SG202059 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:778', 00H
	ORG $+5
$SG202064 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:795', 00H
	ORG $+5
$SG202065 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:800', 00H
	ORG $+5
$SG202069 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:809', 00H
	ORG $+5
$SG202070 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:814', 00H
	ORG $+5
$SG202078 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:838', 00H
	ORG $+5
$SG202079 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:843', 00H
	ORG $+5
$SG202083 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:851', 00H
	ORG $+5
$SG202084 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:856', 00H
	ORG $+5
$SG202088 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:864', 00H
	ORG $+5
$SG202089 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:869', 00H
	ORG $+5
$SG202093 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:877', 00H
	ORG $+5
$SG202094 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:882', 00H
	ORG $+5
$SG202141 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:967', 00H
	ORG $+5
$SG202153 DB	'etod_clock', 00H
	ORG $+5
$SG202154 DB	'C:\papa\MyGit\hyperion-zvector\clock.c', 00H
	ORG $+9
$SG202155 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG202157 DB	'etod_clock', 00H
	ORG $+5
$SG202158 DB	'C:\papa\MyGit\hyperion-zvector\clock.c', 00H
	ORG $+1
$SG202159 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG202167 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:1048', 00H
	ORG $+4
$SG202208 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:1240', 00H
	ORG $+4
$SG202210 DB	'C:\papa\MyGit\hyperion-zvector\clock.c:1254', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch8 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8 DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch8_full DD 032319H
	DD	07010c214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4_full DD 032319H
	DD	07010a214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	0163H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8_full DD 032919H
	DD	07016c21aH
	DD	06015H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_query_available_functions
	DD	014H
	DD	01baH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_query_tod_offset_user
	DD	013H
	DD	0b9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_query_tod_offset
	DD	013H
	DD	0a5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_query_steering_information
	DD	013H
	DD	0199H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_set_tod_offset_user
	DD	013H
	DD	0e0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:host_ETOD
	DD	013H
	DD	039H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:hw_calculate_unique_tick
	DD	014H
	DD	01d4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_skip
	DD	01aH
	DD	0e0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_value
	DD	021H
	DD	023aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_hdr
	DD	01dH
	DD	0cbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_write_value
	DD	021H
	DD	0168H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_write_hdr
	DD	01cH
	DD	0b5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:thread_cputime_us
	DD	013H
	DD	0b8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:get_tod_clock
	DD	013H
	DD	02dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:host_tod
	DD	0eH
	DD	097H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:clock_hresume
	DD	01dH
	DD	052fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:clock_hsuspend
	DD	01cH
	DD	0307H
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$csr_reset DD 020301H
	DD	060027003H
$unwind$set_tod_steering DD 010a01H
	DD	0420aH
$unwind$update_tod_clock DD 010401H
	DD	06204H
$unwind$hw_clock DD 010401H
	DD	06204H
$unwind$set_tod_clock DD 010901H
	DD	04209H
$unwind$clock_hsuspend DD 022419H
	DD	02090112H
	DD	imagerel __GSHandlerCheck
	DD	01030H
$unwind$clock_hresume DD 032519H
	DD	020c0113H
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	01050H
$unwind$ETOD_add DD 011301H
	DD	02213H
$unwind$ETOD_sub DD 011301H
	DD	02213H
$unwind$ETOD_shift DD 011301H
	DD	08213H
$unwind$host_tod DD 011319H
	DD	0a204H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$timespec2usecs DD 010901H
	DD	02209H
$unwind$s370_fetch_int_timer DD 010901H
	DD	08209H
$unwind$s370_store_int_timer DD 010901H
	DD	06209H
$unwind$s370_store_int_timer_locked DD 010901H
	DD	06209H
$unwind$etod_clock DD 011301H
	DD	0c213H
$unwind$get_tod_clock DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$get_cpu_timer DD 010901H
	DD	06209H
$unwind$set_cpu_timer DD 010e01H
	DD	0820eH
$unwind$set_int_timer DD 010d01H
	DD	0620dH
$unwind$chk_int_timer DD 010901H
	DD	06209H
$unwind$thread_cputime_us DD 011819H
	DD	0a209H
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$configure_epoch DD 010801H
	DD	04208H
$unwind$configure_yroffset DD 010801H
	DD	04208H
$unwind$configure_tzoffset DD 010801H
	DD	04208H
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$sr_write_hdr DD 012119H
	DD	06212H
	DD	imagerel __GSHandlerCheck
	DD	028H
$unwind$sr_write_value DD 012619H
	DD	08217H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$sr_write_string DD 011201H
	DD	06212H
$unwind$sr_read_hdr DD 012219H
	DD	06213H
	DD	imagerel __GSHandlerCheck
	DD	028H
$unwind$sr_read_value DD 012619H
	DD	0c217H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$sr_read_string DD 011301H
	DD	04213H
$unwind$sr_read_skip DD 022219H
	DD	02b0110H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$sr_write_error_ DD 010401H
	DD	0c204H
$unwind$sr_read_error_ DD 010401H
	DD	0c204H
$unwind$sr_value_error_ DD 010401H
	DD	08204H
$unwind$sr_string_error_ DD 010401H
	DD	08204H
$unwind$universal_clock DD 010401H
	DD	04204H
$unwind$hw_calculate_unique_tick DD 041c19H
	DD	019010aH
	DD	060027003H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$hw_adjust DD 030b01H
	DD	07007820bH
	DD	06006H
$unwind$hw_clock_locked DD 010401H
	DD	04204H
$unwind$host_ETOD DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$set_gross_steering_rate DD 010801H
	DD	04208H
$unwind$set_fine_steering_rate DD 010801H
	DD	04208H
$unwind$prepare_new_episode DD 020301H
	DD	060027003H
$unwind$start_new_episode DD 010401H
	DD	04204H
$unwind$set_tod_offset DD 010901H
	DD	04209H
$unwind$adjust_tod_offset DD 010901H
	DD	04209H
$unwind$set_tod_epoch DD 010901H
	DD	04209H
$unwind$adjust_tod_epoch DD 010901H
	DD	04209H
$unwind$set_tod_epoch_all DD 010901H
	DD	06209H
$unwind$configure_time DD 010401H
	DD	08204H
$unwind$is_leapyear DD 010801H
	DD	02208H
$unwind$lyear_adjust DD 010801H
	DD	0a208H
$unwind$get_ecps_vtimer DD 010901H
	DD	04209H
$unwind$set_ecps_vtimer DD 010d01H
	DD	0620dH
$unwind$get_int_timer DD 010901H
	DD	04209H
$unwind$z900_set_gross_s_rate DD 010901H
	DD	06209H
$unwind$z900_set_fine_s_rate DD 010901H
	DD	06209H
$unwind$z900_set_tod_offset DD 010901H
	DD	06209H
$unwind$z900_set_tod_offset_user DD 011819H
	DD	0e209H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$z900_adjust_tod_offset DD 010901H
	DD	06209H
$unwind$z900_query_physical_clock DD 010901H
	DD	06209H
$unwind$z900_query_utc_information DD 010901H
	DD	06209H
$unwind$z900_query_steering_information DD 011819H
	DD	0e209H
	DD	imagerel __GSHandlerCheck
	DD	068H
$unwind$build_qto_locked DD 010e01H
	DD	0420eH
$unwind$z900_query_tod_offset DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$z900_query_tod_offset_user DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$z900_query_available_functions DD 021919H
	DD	07006920aH
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
qaf$ = 48
__$ArrayPad$ = 64
regs$ = 96
z900_query_available_functions PROC

; 437  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00011	48 33 c4	 xor	 rax, rsp
  00014	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 438  :     BYTE qaf[16] = {0};

  00019	48 8d 44 24 30	 lea	 rax, QWORD PTR qaf$[rsp]
  0001e	48 8b f8	 mov	 rdi, rax
  00021	33 c0		 xor	 eax, eax
  00023	b9 10 00 00 00	 mov	 ecx, 16
  00028	f3 aa		 rep stosb

; 439  : 
; 440  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_QAF  );

  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	48 6b c0 00	 imul	 rax, rax, 0
  00033	0f b6 44 04 30	 movzx	 eax, BYTE PTR qaf$[rsp+rax]
  00038	0f ba e8 07	 bts	 eax, 7
  0003c	b9 01 00 00 00	 mov	 ecx, 1
  00041	48 6b c9 00	 imul	 rcx, rcx, 0
  00045	88 44 0c 30	 mov	 BYTE PTR qaf$[rsp+rcx], al

; 441  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_QTO  );

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	48 6b c0 00	 imul	 rax, rax, 0
  00052	0f b6 44 04 30	 movzx	 eax, BYTE PTR qaf$[rsp+rax]
  00057	83 c8 40	 or	 eax, 64			; 00000040H
  0005a	b9 01 00 00 00	 mov	 ecx, 1
  0005f	48 6b c9 00	 imul	 rcx, rcx, 0
  00063	88 44 0c 30	 mov	 BYTE PTR qaf$[rsp+rcx], al

; 442  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_QSI  );

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	48 6b c0 00	 imul	 rax, rax, 0
  00070	0f b6 44 04 30	 movzx	 eax, BYTE PTR qaf$[rsp+rax]
  00075	83 c8 20	 or	 eax, 32			; 00000020H
  00078	b9 01 00 00 00	 mov	 ecx, 1
  0007d	48 6b c9 00	 imul	 rcx, rcx, 0
  00081	88 44 0c 30	 mov	 BYTE PTR qaf$[rsp+rcx], al

; 443  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_QPT  );

  00085	b8 01 00 00 00	 mov	 eax, 1
  0008a	48 6b c0 00	 imul	 rax, rax, 0
  0008e	0f b6 44 04 30	 movzx	 eax, BYTE PTR qaf$[rsp+rax]
  00093	83 c8 10	 or	 eax, 16
  00096	b9 01 00 00 00	 mov	 ecx, 1
  0009b	48 6b c9 00	 imul	 rcx, rcx, 0
  0009f	88 44 0c 30	 mov	 BYTE PTR qaf$[rsp+rcx], al

; 444  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_QUI  );

  000a3	b8 01 00 00 00	 mov	 eax, 1
  000a8	48 6b c0 00	 imul	 rax, rax, 0
  000ac	0f b6 44 04 30	 movzx	 eax, BYTE PTR qaf$[rsp+rax]
  000b1	83 c8 08	 or	 eax, 8
  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	48 6b c9 00	 imul	 rcx, rcx, 0
  000bd	88 44 0c 30	 mov	 BYTE PTR qaf$[rsp+rcx], al

; 445  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_QTOU );

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	48 6b c0 00	 imul	 rax, rax, 0
  000ca	0f b6 44 04 30	 movzx	 eax, BYTE PTR qaf$[rsp+rax]
  000cf	83 c8 04	 or	 eax, 4
  000d2	b9 01 00 00 00	 mov	 ecx, 1
  000d7	48 6b c9 00	 imul	 rcx, rcx, 0
  000db	88 44 0c 30	 mov	 BYTE PTR qaf$[rsp+rcx], al

; 446  : #if defined( FEATURE_139_MULTIPLE_EPOCH_FACILITY )
; 447  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_QSIE  );
; 448  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_QTOUE );
; 449  : #endif
; 450  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_ATO  );

  000df	b8 01 00 00 00	 mov	 eax, 1
  000e4	48 6b c0 08	 imul	 rax, rax, 8
  000e8	0f b6 44 04 30	 movzx	 eax, BYTE PTR qaf$[rsp+rax]
  000ed	0f ba e8 07	 bts	 eax, 7
  000f1	b9 01 00 00 00	 mov	 ecx, 1
  000f6	48 6b c9 08	 imul	 rcx, rcx, 8
  000fa	88 44 0c 30	 mov	 BYTE PTR qaf$[rsp+rcx], al

; 451  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_STO  );

  000fe	b8 01 00 00 00	 mov	 eax, 1
  00103	48 6b c0 08	 imul	 rax, rax, 8
  00107	0f b6 44 04 30	 movzx	 eax, BYTE PTR qaf$[rsp+rax]
  0010c	83 c8 40	 or	 eax, 64			; 00000040H
  0010f	b9 01 00 00 00	 mov	 ecx, 1
  00114	48 6b c9 08	 imul	 rcx, rcx, 8
  00118	88 44 0c 30	 mov	 BYTE PTR qaf$[rsp+rcx], al

; 452  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_SFS  );

  0011c	b8 01 00 00 00	 mov	 eax, 1
  00121	48 6b c0 08	 imul	 rax, rax, 8
  00125	0f b6 44 04 30	 movzx	 eax, BYTE PTR qaf$[rsp+rax]
  0012a	83 c8 20	 or	 eax, 32			; 00000020H
  0012d	b9 01 00 00 00	 mov	 ecx, 1
  00132	48 6b c9 08	 imul	 rcx, rcx, 8
  00136	88 44 0c 30	 mov	 BYTE PTR qaf$[rsp+rcx], al

; 453  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_SGS  );

  0013a	b8 01 00 00 00	 mov	 eax, 1
  0013f	48 6b c0 08	 imul	 rax, rax, 8
  00143	0f b6 44 04 30	 movzx	 eax, BYTE PTR qaf$[rsp+rax]
  00148	83 c8 10	 or	 eax, 16
  0014b	b9 01 00 00 00	 mov	 ecx, 1
  00150	48 6b c9 08	 imul	 rcx, rcx, 8
  00154	88 44 0c 30	 mov	 BYTE PTR qaf$[rsp+rcx], al

; 454  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_STOU );

  00158	b8 01 00 00 00	 mov	 eax, 1
  0015d	48 6b c0 08	 imul	 rax, rax, 8
  00161	0f b6 44 04 30	 movzx	 eax, BYTE PTR qaf$[rsp+rax]
  00166	83 c8 04	 or	 eax, 4
  00169	b9 01 00 00 00	 mov	 ecx, 1
  0016e	48 6b c9 08	 imul	 rcx, rcx, 8
  00172	88 44 0c 30	 mov	 BYTE PTR qaf$[rsp+rcx], al

; 455  : #if defined( FEATURE_139_MULTIPLE_EPOCH_FACILITY )
; 456  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_STOE  );
; 457  :     BIT_ARRAY_SET( qaf, PTFF_GPR0_FC_STOUE );
; 458  : #endif
; 459  : 
; 460  :     ARCH_DEP(vstorec) (&qaf, sizeof(qaf)-1, regs->GR(1) & ADDRESS_MAXWRAP(regs), 1, regs);

  00176	b8 08 00 00 00	 mov	 eax, 8
  0017b	48 6b c0 01	 imul	 rax, rax, 1
  0017f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00189	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00190	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00198	48 23 c2	 and	 rax, rdx
  0019b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001a5	41 b9 01 00 00
	00		 mov	 r9d, 1
  001ab	4c 8b c0	 mov	 r8, rax
  001ae	b2 0f		 mov	 dl, 15
  001b0	48 8d 4c 24 30	 lea	 rcx, QWORD PTR qaf$[rsp]
  001b5	e8 00 00 00 00	 call	 z900_vstorec

; 461  : }

  001ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001bf	48 33 cc	 xor	 rcx, rsp
  001c2	e8 00 00 00 00	 call	 __security_check_cookie
  001c7	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001cb	5f		 pop	 rdi
  001cc	c3		 ret	 0
z900_query_available_functions ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
qtou$ = 48
__$ArrayPad$ = 88
regs$ = 112
z900_query_tod_offset_user PROC

; 400  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 401  :     /* "The 64-bit TOD user specified epoch difference value returned
; 402  :         is the user-specified portion of the *GUEST* epoch difference
; 403  :         for the current level of CPU execution. When executed at the
; 404  :         basic-machine or LPAR hypervisor level, this value is zero."
; 405  :     */
; 406  :     struct
; 407  :     {
; 408  :         PTFFQTO  qto;
; 409  :         DBLWRD   tod_user_specified_epoch_difference;
; 410  :     }
; 411  :     qtou;
; 412  : 
; 413  :     obtain_lock( &sysblk.todlock );

  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001f	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202001
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 414  :     {
; 415  :         build_qto_locked( &qtou.qto, regs );

  00035	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0003a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR qtou$[rsp]
  0003f	e8 00 00 00 00	 call	 build_qto_locked

; 416  :         STORE_DW( qtou.tod_user_specified_epoch_difference, 0 );

  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 _byteswap_uint64
  0004b	48 8b d0	 mov	 rdx, rax
  0004e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR qtou$[rsp+32]
  00053	e8 00 00 00 00	 call	 store_dw_noswap

; 417  :     }
; 418  :     release_lock( &sysblk.todlock );

  00058	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0005f	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202002
  0006c	48 8b c8	 mov	 rcx, rax
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 419  : 
; 420  :     ARCH_DEP( vstorec )( &qtou, sizeof( qtou )-1, regs->GR(1) & ADDRESS_MAXWRAP( regs ), 1, regs );

  00075	b8 08 00 00 00	 mov	 eax, 8
  0007a	48 6b c0 01	 imul	 rax, rax, 1
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00088	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  0008f	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00097	48 23 c2	 and	 rax, rdx
  0009a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000a4	41 b9 01 00 00
	00		 mov	 r9d, 1
  000aa	4c 8b c0	 mov	 r8, rax
  000ad	b2 27		 mov	 dl, 39			; 00000027H
  000af	48 8d 4c 24 30	 lea	 rcx, QWORD PTR qtou$[rsp]
  000b4	e8 00 00 00 00	 call	 z900_vstorec

; 421  : }

  000b9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000be	48 33 cc	 xor	 rcx, rsp
  000c1	e8 00 00 00 00	 call	 __security_check_cookie
  000c6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000ca	c3		 ret	 0
z900_query_tod_offset_user ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
qto$ = 48
__$ArrayPad$ = 80
regs$ = 112
z900_query_tod_offset PROC

; 385  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 386  : PTFFQTO qto;
; 387  : 
; 388  :     obtain_lock( &sysblk.todlock );

  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001f	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG201991
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 389  :     {
; 390  :         build_qto_locked( &qto, regs );

  00035	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0003a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR qto$[rsp]
  0003f	e8 00 00 00 00	 call	 build_qto_locked

; 391  :     }
; 392  :     release_lock( &sysblk.todlock );

  00044	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004b	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG201992
  00058	48 8b c8	 mov	 rcx, rax
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 393  : 
; 394  :     ARCH_DEP(vstorec) (&qto, sizeof(qto)-1, regs->GR(1) & ADDRESS_MAXWRAP(regs), 1, regs);

  00061	b8 08 00 00 00	 mov	 eax, 8
  00066	48 6b c0 01	 imul	 rax, rax, 1
  0006a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0006f	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00074	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  0007b	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00083	48 23 c2	 and	 rax, rdx
  00086	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00090	41 b9 01 00 00
	00		 mov	 r9d, 1
  00096	4c 8b c0	 mov	 r8, rax
  00099	b2 1f		 mov	 dl, 31
  0009b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR qto$[rsp]
  000a0	e8 00 00 00 00	 call	 z900_vstorec

; 395  : }

  000a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000aa	48 33 cc	 xor	 rcx, rsp
  000ad	e8 00 00 00 00	 call	 __security_check_cookie
  000b2	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000b6	c3		 ret	 0
z900_query_tod_offset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
qto$ = 48
regs$ = 56
build_qto_locked PROC

; 375  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 376  :     STORE_DW( qto->todoff,   (hw_clock_locked() - universal_tod.high) << 8);

  0000e	e8 00 00 00 00	 call	 hw_clock_locked
  00013	48 2b 05 08 00
	00 00		 sub	 rax, QWORD PTR universal_tod+8
  0001a	48 c1 e0 08	 shl	 rax, 8
  0001e	48 8b c8	 mov	 rcx, rax
  00021	e8 00 00 00 00	 call	 _byteswap_uint64
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR qto$[rsp]
  0002b	48 83 c1 08	 add	 rcx, 8
  0002f	48 8b d0	 mov	 rdx, rax
  00032	e8 00 00 00 00	 call	 store_dw_noswap

; 377  :     STORE_DW( qto->physclk,  (universal_tod.high << 8) | (universal_tod.low >> (64-8)));

  00037	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR universal_tod+8
  0003e	48 c1 e0 08	 shl	 rax, 8
  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR universal_tod
  00049	48 c1 e9 38	 shr	 rcx, 56			; 00000038H
  0004d	48 0b c1	 or	 rax, rcx
  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 _byteswap_uint64
  00058	48 8b 4c 24 30	 mov	 rcx, QWORD PTR qto$[rsp]
  0005d	48 8b d0	 mov	 rdx, rax
  00060	e8 00 00 00 00	 call	 store_dw_noswap

; 378  :     STORE_DW( qto->ltodoff,  episode_current->base_offset << 8);

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR episode_current
  0006c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00070	48 c1 e0 08	 shl	 rax, 8
  00074	48 8b c8	 mov	 rcx, rax
  00077	e8 00 00 00 00	 call	 _byteswap_uint64
  0007c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR qto$[rsp]
  00081	48 83 c1 10	 add	 rcx, 16
  00085	48 8b d0	 mov	 rdx, rax
  00088	e8 00 00 00 00	 call	 store_dw_noswap

; 379  :     STORE_DW( qto->todepoch, regs->tod_epoch << 8);

  0008d	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  00092	48 8b 80 40 07
	00 00		 mov	 rax, QWORD PTR [rax+1856]
  00099	48 c1 e0 08	 shl	 rax, 8
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	e8 00 00 00 00	 call	 _byteswap_uint64
  000a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR qto$[rsp]
  000aa	48 83 c1 18	 add	 rcx, 24
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	e8 00 00 00 00	 call	 store_dw_noswap

; 380  : }

  000b6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ba	c3		 ret	 0
build_qto_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
qsi$ = 48
__$ArrayPad$ = 104
regs$ = 128
z900_query_steering_information PROC

; 337  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 338  : PTFFQSI qsi;
; 339  : 
; 340  :     obtain_lock( &sysblk.todlock );

  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001f	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG201978
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 341  :     {
; 342  :         STORE_DW( qsi.physclk,   universal_clock() << 8);

  00035	e8 00 00 00 00	 call	 universal_clock
  0003a	48 c1 e0 08	 shl	 rax, 8
  0003e	48 8b c8	 mov	 rcx, rax
  00041	e8 00 00 00 00	 call	 _byteswap_uint64
  00046	48 8b d0	 mov	 rdx, rax
  00049	48 8d 4c 24 30	 lea	 rcx, QWORD PTR qsi$[rsp]
  0004e	e8 00 00 00 00	 call	 store_dw_noswap

; 343  : 
; 344  :         STORE_DW( qsi.oldestart, episode_old.start_time  << 8);

  00053	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR episode_old
  0005a	48 c1 e0 08	 shl	 rax, 8
  0005e	48 8b c8	 mov	 rcx, rax
  00061	e8 00 00 00 00	 call	 _byteswap_uint64
  00066	48 8b d0	 mov	 rdx, rax
  00069	48 8d 4c 24 38	 lea	 rcx, QWORD PTR qsi$[rsp+8]
  0006e	e8 00 00 00 00	 call	 store_dw_noswap

; 345  :         STORE_DW( qsi.oldebase,  episode_old.base_offset << 8);

  00073	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR episode_old+8
  0007a	48 c1 e0 08	 shl	 rax, 8
  0007e	48 8b c8	 mov	 rcx, rax
  00081	e8 00 00 00 00	 call	 _byteswap_uint64
  00086	48 8b d0	 mov	 rdx, rax
  00089	48 8d 4c 24 40	 lea	 rcx, QWORD PTR qsi$[rsp+16]
  0008e	e8 00 00 00 00	 call	 store_dw_noswap

; 346  :         STORE_FW( qsi.oldfsr,    episode_old.fine_s_rate );

  00093	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR episode_old+16
  00099	e8 00 00 00 00	 call	 _byteswap_ulong
  0009e	8b d0		 mov	 edx, eax
  000a0	48 8d 4c 24 48	 lea	 rcx, QWORD PTR qsi$[rsp+24]
  000a5	e8 00 00 00 00	 call	 store_fw_noswap

; 347  :         STORE_FW( qsi.oldgsr,    episode_old.gross_s_rate );

  000aa	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR episode_old+20
  000b0	e8 00 00 00 00	 call	 _byteswap_ulong
  000b5	8b d0		 mov	 edx, eax
  000b7	48 8d 4c 24 4c	 lea	 rcx, QWORD PTR qsi$[rsp+28]
  000bc	e8 00 00 00 00	 call	 store_fw_noswap

; 348  : 
; 349  :         STORE_DW( qsi.newestart, episode_new.start_time  << 8);

  000c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR episode_new
  000c8	48 c1 e0 08	 shl	 rax, 8
  000cc	48 8b c8	 mov	 rcx, rax
  000cf	e8 00 00 00 00	 call	 _byteswap_uint64
  000d4	48 8b d0	 mov	 rdx, rax
  000d7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR qsi$[rsp+32]
  000dc	e8 00 00 00 00	 call	 store_dw_noswap

; 350  :         STORE_DW( qsi.newebase,  episode_new.base_offset << 8);

  000e1	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR episode_new+8
  000e8	48 c1 e0 08	 shl	 rax, 8
  000ec	48 8b c8	 mov	 rcx, rax
  000ef	e8 00 00 00 00	 call	 _byteswap_uint64
  000f4	48 8b d0	 mov	 rdx, rax
  000f7	48 8d 4c 24 58	 lea	 rcx, QWORD PTR qsi$[rsp+40]
  000fc	e8 00 00 00 00	 call	 store_dw_noswap

; 351  :         STORE_FW( qsi.newfsr,    episode_new.fine_s_rate );

  00101	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR episode_new+16
  00107	e8 00 00 00 00	 call	 _byteswap_ulong
  0010c	8b d0		 mov	 edx, eax
  0010e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR qsi$[rsp+48]
  00113	e8 00 00 00 00	 call	 store_fw_noswap

; 352  :         STORE_FW( qsi.newgsr,    episode_new.gross_s_rate );

  00118	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR episode_new+20
  0011e	e8 00 00 00 00	 call	 _byteswap_ulong
  00123	8b d0		 mov	 edx, eax
  00125	48 8d 4c 24 64	 lea	 rcx, QWORD PTR qsi$[rsp+52]
  0012a	e8 00 00 00 00	 call	 store_fw_noswap

; 353  :     }
; 354  :     release_lock( &sysblk.todlock );

  0012f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00136	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG201979
  00143	48 8b c8	 mov	 rcx, rax
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 355  : 
; 356  :     ARCH_DEP(vstorec) (&qsi, sizeof(qsi)-1, regs->GR(1) & ADDRESS_MAXWRAP(regs), 1, regs);

  0014c	b8 08 00 00 00	 mov	 eax, 8
  00151	48 6b c0 01	 imul	 rax, rax, 1
  00155	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00165	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  0016c	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00174	48 23 c2	 and	 rax, rdx
  00177	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00184	41 b9 01 00 00
	00		 mov	 r9d, 1
  0018a	4c 8b c0	 mov	 r8, rax
  0018d	b2 37		 mov	 dl, 55			; 00000037H
  0018f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR qsi$[rsp]
  00194	e8 00 00 00 00	 call	 z900_vstorec

; 357  : }

  00199	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0019e	48 33 cc	 xor	 rcx, rsp
  001a1	e8 00 00 00 00	 call	 __security_check_cookie
  001a6	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001aa	c3		 ret	 0
z900_query_steering_information ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
regs$ = 64
z900_query_utc_information PROC

; 325  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 326  :     /* "The information in the UIB is provided by the server-time-
; 327  :         protocol (STP) facility that also controls TOD-clock steering.
; 328  :         When STP is not installed, all fields in the UIB are zero."
; 329  :     */
; 330  :     static const BYTE uib[256] = {0};
; 331  :     ARCH_DEP( vstorec )( &uib, sizeof( uib )-1, regs->GR(1) & ADDRESS_MAXWRAP( regs ), 1, regs );

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 01	 imul	 rax, rax, 1
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	48 8b 54 24 40	 mov	 rdx, QWORD PTR regs$[rsp]
  0001c	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00023	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0002b	48 23 c2	 and	 rax, rdx
  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	41 b9 01 00 00
	00		 mov	 r9d, 1
  0003e	4c 8b c0	 mov	 r8, rax
  00041	b2 ff		 mov	 dl, 255			; 000000ffH
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?uib@?1??z900_query_utc_information@@9@9
  0004a	e8 00 00 00 00	 call	 z900_vstorec

; 332  : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
z900_query_utc_information ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
tv71 = 32
regs$ = 64
z900_query_physical_clock PROC

; 318  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 319  :     ARCH_DEP(vstore8) (universal_clock() << 8, regs->GR(1) & ADDRESS_MAXWRAP(regs), 1, regs);

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 01	 imul	 rax, rax, 1
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	48 8b 54 24 40	 mov	 rdx, QWORD PTR regs$[rsp]
  0001c	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00023	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0002b	48 23 c2	 and	 rax, rdx
  0002e	48 89 44 24 20	 mov	 QWORD PTR tv71[rsp], rax
  00033	e8 00 00 00 00	 call	 universal_clock
  00038	48 c1 e0 08	 shl	 rax, 8
  0003c	4c 8b 4c 24 40	 mov	 r9, QWORD PTR regs$[rsp]
  00041	41 b8 01 00 00
	00		 mov	 r8d, 1
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv71[rsp]
  0004c	48 8b d1	 mov	 rdx, rcx
  0004f	48 8b c8	 mov	 rcx, rax
  00052	e8 00 00 00 00	 call	 z900_vstore8

; 320  : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
z900_query_physical_clock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
offset$ = 32
regs$ = 64
z900_adjust_tod_offset PROC

; 308  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 309  : S64 offset;
; 310  :     offset = ARCH_DEP(vfetch8) (regs->GR(1) & ADDRESS_MAXWRAP(regs), 1, regs);

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 01	 imul	 rax, rax, 1
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	48 8b 54 24 40	 mov	 rdx, QWORD PTR regs$[rsp]
  0001c	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00023	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0002b	48 23 c2	 and	 rax, rdx
  0002e	4c 8b 44 24 40	 mov	 r8, QWORD PTR regs$[rsp]
  00033	ba 01 00 00 00	 mov	 edx, 1
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 z900_vfetch8
  00040	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax

; 311  : 
; 312  :     adjust_tod_offset(offset >> 8);

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  0004a	48 c1 f8 08	 sar	 rax, 8
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 adjust_tod_offset

; 313  : }

  00056	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005a	c3		 ret	 0
z900_adjust_tod_offset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
offset$ = 64
buf$1 = 72
__$ArrayPad$ = 104
regs$ = 128
z900_set_tod_offset_user PROC

; 257  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 68	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 258  : S64 offset;
; 259  : 
; 260  :     /* "This function specifies a value that is to replace the
; 261  :         *USER*-specified portion of the TOD epoch difference;"
; 262  : 
; 263  :         Since, at the basic-machine or LPAR hypervisor level, the
; 264  :         user-specified epoch difference is always ZERO (see the
; 265  :         'query_tod_offset_user' function), we should ideally never
; 266  :         see this function ever being called since z/VM should be
; 267  :         handling it itself (i.e. simulating it for the SIE guest).
; 268  :         Therefore we ignore this call and do absolutely nothing.
; 269  :     */
; 270  : 
; 271  :     /* Fetch the value anyway to check for any addressing exception */
; 272  :     offset = ARCH_DEP( vfetch8 )( regs->GR(1) & ADDRESS_MAXWRAP( regs ), 1, regs );

  00018	b8 08 00 00 00	 mov	 eax, 8
  0001d	48 6b c0 01	 imul	 rax, rax, 1
  00021	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00029	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00031	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00038	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00040	48 23 c2	 and	 rax, rdx
  00043	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0004b	ba 01 00 00 00	 mov	 edx, 1
  00050	48 8b c8	 mov	 rcx, rax
  00053	e8 00 00 00 00	 call	 z900_vfetch8
  00058	48 89 44 24 40	 mov	 QWORD PTR offset$[rsp], rax

; 273  : 
; 274  :     /* Inform the user that an unexpected situation has occurred */
; 275  :     if (MLVL( VERBOSE ))

  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00064	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  0006a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0006f	85 c0		 test	 eax, eax
  00071	74 6d		 je	 SHORT $LN2@z900_set_t

; 276  :     {
; 277  :         char buf[32];
; 278  :         MSGBUF( buf, "PTFF-STOU 0x%16.16"PRIX64"!", offset );

  00073	4c 8b 4c 24 40	 mov	 r9, QWORD PTR offset$[rsp]
  00078	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG201953
  0007f	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00084	48 8d 4c 24 48	 lea	 rcx, QWORD PTR buf$1[rsp]
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 279  :         WRMSG( HHC90000, "D", buf );

  0008f	b9 01 00 00 00	 mov	 ecx, 1
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009a	48 8d 4c 24 48	 lea	 rcx, QWORD PTR buf$1[rsp]
  0009f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG201954
  000ab	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG201955
  000b7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c1	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG201956
  000ce	ba 17 01 00 00	 mov	 edx, 279		; 00000117H
  000d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG201957
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@z900_set_t:

; 280  :     }
; 281  : }

  000e0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e5	48 33 cc	 xor	 rcx, rsp
  000e8	e8 00 00 00 00	 call	 __security_check_cookie
  000ed	48 83 c4 78	 add	 rsp, 120		; 00000078H
  000f1	c3		 ret	 0
z900_set_tod_offset_user ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
offset$ = 32
regs$ = 64
z900_set_tod_offset PROC

; 247  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 248  : S64 offset;
; 249  :     offset = ARCH_DEP(vfetch8) (regs->GR(1) & ADDRESS_MAXWRAP(regs), 1, regs);

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 01	 imul	 rax, rax, 1
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	48 8b 54 24 40	 mov	 rdx, QWORD PTR regs$[rsp]
  0001c	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00023	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0002b	48 23 c2	 and	 rax, rdx
  0002e	4c 8b 44 24 40	 mov	 r8, QWORD PTR regs$[rsp]
  00033	ba 01 00 00 00	 mov	 edx, 1
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 z900_vfetch8
  00040	48 89 44 24 20	 mov	 QWORD PTR offset$[rsp], rax

; 250  : 
; 251  :     set_tod_offset(offset >> 8);

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR offset$[rsp]
  0004a	48 c1 f8 08	 sar	 rax, 8
  0004e	48 8b c8	 mov	 rcx, rax
  00051	e8 00 00 00 00	 call	 set_tod_offset

; 252  : }

  00056	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005a	c3		 ret	 0
z900_set_tod_offset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
fsr$ = 32
regs$ = 64
z900_set_fine_s_rate PROC

; 237  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 238  : S32 fsr;
; 239  :     fsr = ARCH_DEP(vfetch4) (regs->GR(1) & ADDRESS_MAXWRAP(regs), 1, regs);

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 01	 imul	 rax, rax, 1
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	48 8b 54 24 40	 mov	 rdx, QWORD PTR regs$[rsp]
  0001c	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00023	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0002b	48 23 c2	 and	 rax, rdx
  0002e	4c 8b 44 24 40	 mov	 r8, QWORD PTR regs$[rsp]
  00033	ba 01 00 00 00	 mov	 edx, 1
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 z900_vfetch4
  00040	89 44 24 20	 mov	 DWORD PTR fsr$[rsp], eax

; 240  : 
; 241  :     set_fine_steering_rate(fsr);

  00044	8b 4c 24 20	 mov	 ecx, DWORD PTR fsr$[rsp]
  00048	e8 00 00 00 00	 call	 set_fine_steering_rate

; 242  : }

  0004d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00051	c3		 ret	 0
z900_set_fine_s_rate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
gsr$ = 32
regs$ = 64
z900_set_gross_s_rate PROC

; 227  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 228  : S32 gsr;
; 229  :     gsr = ARCH_DEP(vfetch4) (regs->GR(1) & ADDRESS_MAXWRAP(regs), 1, regs);

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 01	 imul	 rax, rax, 1
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	48 8b 54 24 40	 mov	 rdx, QWORD PTR regs$[rsp]
  0001c	48 8b 92 90 00
	00 00		 mov	 rdx, QWORD PTR [rdx+144]
  00023	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0002b	48 23 c2	 and	 rax, rdx
  0002e	4c 8b 44 24 40	 mov	 r8, QWORD PTR regs$[rsp]
  00033	ba 01 00 00 00	 mov	 edx, 1
  00038	48 8b c8	 mov	 rcx, rax
  0003b	e8 00 00 00 00	 call	 z900_vfetch4
  00040	89 44 24 20	 mov	 DWORD PTR gsr$[rsp], eax

; 230  : 
; 231  :     set_gross_steering_rate(gsr);

  00044	8b 4c 24 20	 mov	 ecx, DWORD PTR gsr$[rsp]
  00048	e8 00 00 00 00	 call	 set_gross_steering_rate

; 232  : }

  0004d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00051	c3		 ret	 0
z900_set_gross_s_rate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch8 PROC					; COMDAT

; 711  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 712  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 713  :     if(likely(!((VADR_L)addr & 0x07)))
; 714  :     {
; 715  :         /* doubleword aligned fetch */
; 716  :         U64 *mn;
; 717  :         ITIMER_SYNC( addr, 8-1, regs );
; 718  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 719  :         if (regs->cpubit == regs->sysblk->started_mask)
; 720  :             return CSWAP64( *mn );
; 721  :         return fetch_dw( mn );
; 722  :     }
; 723  :     else
; 724  : #endif
; 725  :     {
; 726  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0001d	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00023	77 0a		 ja	 SHORT $LN6@z900_vfetc
  00025	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0002d	eb 08		 jmp	 SHORT $LN7@z900_vfetc
$LN6@z900_vfetc:
  0002f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN7@z900_vfetc:
  00037	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  0003c	74 47		 je	 SHORT $LN2@z900_vfetc

; 727  :         {
; 728  :             /* unaligned, non-crossing doubleword fetch */
; 729  :             BYTE *mn;
; 730  :             ITIMER_SYNC( addr, 8-1, regs );
; 731  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00043	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00047	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0004b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00053	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00058	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0005d	ba 08 00 00 00	 mov	 edx, 8
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00067	e8 00 00 00 00	 call	 z900_maddr_l
  0006c	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 732  :             return fetch_dw( mn );

  00071	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00076	e8 00 00 00 00	 call	 fetch_dw_noswap
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	e8 00 00 00 00	 call	 _byteswap_uint64
  00083	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 733  :         }
; 734  :     }
; 735  :     /* page crossing doubleword fetch */
; 736  :     return ARCH_DEP( vfetch8_full )( addr, arn, regs );

  00085	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  0008a	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  0008e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00093	e8 00 00 00 00	 call	 z900_vfetch8_full
$LN1@z900_vfetc:

; 737  : }

  00098	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009c	c3		 ret	 0
z900_vfetch8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 83 e0 03	 and	 rax, 3
  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0a		 jne	 SHORT $LN5@z900_vfetc
  00020	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN6@z900_vfetc
$LN5@z900_vfetc:
  0002a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@z900_vfetc:
  00032	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00037	74 0a		 je	 SHORT $LN9@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN10@z900_vfetc
$LN9@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00050	75 13		 jne	 SHORT $LN3@z900_vfetc
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00057	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0005d	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00063	77 46		 ja	 SHORT $LN2@z900_vfetc
$LN3@z900_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006e	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00072	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 04 00 00 00	 mov	 edx, 4
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  0009d	e8 00 00 00 00	 call	 fetch_fw_noswap
  000a2	8b c8		 mov	 ecx, eax
  000a4	e8 00 00 00 00	 call	 _byteswap_ulong
  000a9	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000ab	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000b0	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  000b9	e8 00 00 00 00	 call	 z900_vfetch4_full
$LN1@z900_vfetc:

; 705  : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore8 PROC					; COMDAT

; 577  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 578  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 579  :     /* Check alignement. If aligned then we are guaranteed
; 580  :        not to cross a page boundary */
; 581  :     if (likely(!((VADR_L)addr & 0x07)))
; 582  :     {
; 583  :         /* Most common case : Aligned */
; 584  :         U64 *mn;
; 585  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );
; 586  :         if (regs->cpubit == regs->sysblk->started_mask)
; 587  :             *mn = CSWAP64( value );
; 588  :         else
; 589  :             STORE_DW( mn, value );
; 590  :     }
; 591  :     else
; 592  : #endif
; 593  :     {
; 594  :         /* We're not aligned. So we have to check whether we are
; 595  :            crossing a page boundary. This cannot be the same
; 596  :            code as above because casting U64* to a non aligned
; 597  :            pointer may break on those architectures mandating
; 598  :            strict alignement */
; 599  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00023	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00029	77 0a		 ja	 SHORT $LN7@z900_vstor
  0002b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00033	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00035	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN8@z900_vstor:
  0003d	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00042	74 4c		 je	 SHORT $LN2@z900_vstor

; 600  :         {
; 601  :             /* Non aligned but not crossing page boundary */
; 602  :             BYTE *mn;
; 603  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00044	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00049	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0004d	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00051	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00059	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0005e	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00063	ba 08 00 00 00	 mov	 edx, 8
  00068	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  0006d	e8 00 00 00 00	 call	 z900_maddr_l
  00072	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 604  :             /* invoking STORE_DW ensures endianness correctness */
; 605  :             STORE_DW( mn, value );

  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  0007c	e8 00 00 00 00	 call	 _byteswap_uint64
  00081	48 8b d0	 mov	 rdx, rax
  00084	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00089	e8 00 00 00 00	 call	 store_dw_noswap

; 606  :         }

  0008e	eb 19		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 607  :         else
; 608  :             /* Crossing page boundary */
; 609  :             ARCH_DEP( vstore8_full )( value, addr, arn, regs );

  00090	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  0009a	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  000a4	e8 00 00 00 00	 call	 z900_vstore8_full
$LN3@z900_vstor:

; 610  :     }
; 611  :     ITIMER_UPDATE( addr, 8-1, regs );
; 612  : }

  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
z900_vstore8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch8_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 80
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetch8_full PROC					; COMDAT

; 457  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 458  : BYTE   *mn;                             /* Main storage addresses    */
; 459  : int     len;                            /* Length to end of page     */
; 460  : BYTE    temp[16];                       /* Copy destination          */
; 461  : 
; 462  :     /* Get absolute address of first byte of operand */
; 463  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  0002b	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00031	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00036	48 2b c8	 sub	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 464  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00040	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00045	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004d	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00051	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00055	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005d	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00065	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00078	e8 00 00 00 00	 call	 z900_maddr_l
  0007d	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 465  :     memcpy( temp, mn, len);

  00082	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00087	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0008c	48 8b f9	 mov	 rdi, rcx
  0008f	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00094	48 8b c8	 mov	 rcx, rax
  00097	f3 a4		 rep movsb

; 466  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8 - len, arn, regs,

  00099	b8 08 00 00 00	 mov	 eax, 8
  0009e	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000a2	48 98		 cdqe
  000a4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a9	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000b1	48 03 d1	 add	 rdx, rcx
  000b4	48 8b ca	 mov	 rcx, rdx
  000b7	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000bf	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000c6	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ce	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000d2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000d6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000de	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e6	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ee	48 8b d0	 mov	 rdx, rax
  000f1	e8 00 00 00 00	 call	 z900_maddr_l
  000f6	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 467  :                  ACCTYPE_READ, regs->psw.pkey );
; 468  :     memcpy( temp+len, mn, 8 );

  000fb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00100	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$[rsp]
  00105	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00108	48 89 4c 04 40	 mov	 QWORD PTR temp$[rsp+rax], rcx

; 469  :     return fetch_dw( temp );

  0010d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00112	e8 00 00 00 00	 call	 fetch_dw_noswap
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 _byteswap_uint64

; 470  : }

  0011f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
z900_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR addr$[rsp]
  00028	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0002e	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00033	48 2b c8	 sub	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003d	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00042	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00052	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00062	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00067	48 8b d0	 mov	 rdx, rax
  0006a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR addr$[rsp]
  0006f	e8 00 00 00 00	 call	 z900_maddr_l
  00074	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00079	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0007e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00083	48 8b f9	 mov	 rdi, rcx
  00086	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  00090	b8 04 00 00 00	 mov	 eax, 4
  00095	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00099	48 98		 cdqe
  0009b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a0	48 8b 54 24 70	 mov	 rdx, QWORD PTR addr$[rsp]
  000a5	48 03 d1	 add	 rdx, rcx
  000a8	48 8b ca	 mov	 rcx, rdx
  000ab	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b3	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000ba	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c6	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ca	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d2	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000da	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000df	48 8b d0	 mov	 rdx, rax
  000e2	e8 00 00 00 00	 call	 z900_maddr_l
  000e7	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000ec	b8 04 00 00 00	 mov	 eax, 4
  000f1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000f5	48 98		 cdqe
  000f7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000fc	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00101	48 8b f9	 mov	 rdi, rcx
  00104	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00109	48 8b c8	 mov	 rcx, rax
  0010c	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  0010e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00113	e8 00 00 00 00	 call	 fetch_fw_noswap
  00118	8b c8		 mov	 ecx, eax
  0011a	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0011f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8_full
_TEXT	SEGMENT
len$ = 48
sk$ = 56
main1$ = 64
main2$ = 72
temp$ = 80
__$ArrayPad$ = 88
value$ = 128
addr$ = 136
arn$ = 144
regs$ = 152
z900_vstore8_full PROC					; COMDAT

; 369  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 371  : BYTE   *sk;                             /* Storage key addresses     */
; 372  : int     len;                            /* Length to end of page     */
; 373  : BYTE    temp[8];                        /* Copied value              */
; 374  : 
; 375  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00029	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00031	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00037	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0003c	48 2b c8	 sub	 rcx, rax
  0003f	48 8b c1	 mov	 rax, rcx
  00042	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 376  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00046	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0004b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00057	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0005b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00063	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0006b	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00073	48 8b d0	 mov	 rdx, rax
  00076	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0007e	e8 00 00 00 00	 call	 z900_maddr_l
  00083	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 377  :     sk = regs->dat.storkey;

  00088	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00097	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 378  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8-len, arn, regs,

  0009c	b8 08 00 00 00	 mov	 eax, 8
  000a1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000a5	48 98		 cdqe
  000a7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000ac	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000b4	48 03 d1	 add	 rdx, rcx
  000b7	48 8b ca	 mov	 rcx, rdx
  000ba	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000c9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000d1	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000d5	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000d9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000e1	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e9	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f1	48 8b d0	 mov	 rdx, rax
  000f4	e8 00 00 00 00	 call	 z900_maddr_l
  000f9	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 379  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 380  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000fe	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00103	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00106	83 c8 06	 or	 eax, 6
  00109	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  0010e	88 01		 mov	 BYTE PTR [rcx], al

; 381  :     STORE_DW( temp, value );

  00110	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  00118	e8 00 00 00 00	 call	 _byteswap_uint64
  0011d	48 8b d0	 mov	 rdx, rax
  00120	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00125	e8 00 00 00 00	 call	 store_dw_noswap

; 382  :     memcpy( main1, temp,       len );

  0012a	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0012f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00134	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00139	48 8b f1	 mov	 rsi, rcx
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	f3 a4		 rep movsb

; 383  :     memcpy( main2, temp+len, 8-len );

  00141	b8 08 00 00 00	 mov	 eax, 8
  00146	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0014a	48 98		 cdqe
  0014c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00151	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00156	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0015b	48 8b f1	 mov	 rsi, rcx
  0015e	48 8b c8	 mov	 rcx, rax
  00161	f3 a4		 rep movsb

; 384  : }

  00163	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00168	48 33 cc	 xor	 rcx, rsp
  0016b	e8 00 00 00 00	 call	 __security_check_cookie
  00170	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00174	5f		 pop	 rdi
  00175	5e		 pop	 rsi
  00176	c3		 ret	 0
z900_vstore8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
regs$ = 48
get_int_timer PROC

; 1300 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1301 :     return (S32)TOD_TO_ITIMER((S64)(regs->int_timer - hw_clock()));

  00009	e8 00 00 00 00	 call	 hw_clock
  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00013	48 8b 89 60 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1888]
  0001a	48 2b c8	 sub	 rcx, rax
  0001d	48 8b c1	 mov	 rax, rcx
  00020	48 6b c0 03	 imul	 rax, rax, 3
  00024	48 99		 cdq
  00026	b9 71 02 00 00	 mov	 ecx, 625		; 00000271H
  0002b	48 f7 f9	 idiv	 rcx

; 1302 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
get_int_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
tv65 = 32
regs$ = 64
vtimer$ = 72
set_ecps_vtimer PROC

; 1289 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1290 :     regs->ecps_vtimer = (U64)(hw_clock() + ITIMER_TO_TOD(vtimer));

  0000d	e8 00 00 00 00	 call	 hw_clock
  00012	48 89 44 24 20	 mov	 QWORD PTR tv65[rsp], rax
  00017	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR vtimer$[rsp]
  0001c	48 69 c9 71 02
	00 00		 imul	 rcx, rcx, 625		; 00000271H
  00023	48 8b c1	 mov	 rax, rcx
  00026	48 99		 cdq
  00028	b9 03 00 00 00	 mov	 ecx, 3
  0002d	48 f7 f9	 idiv	 rcx
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv65[rsp]
  00035	48 03 c8	 add	 rcx, rax
  00038	48 8b c1	 mov	 rax, rcx
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00040	48 89 81 68 07
	00 00		 mov	 QWORD PTR [rcx+1896], rax

; 1291 :     regs->ecps_oldtmr = vtimer;

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004c	8b 4c 24 48	 mov	 ecx, DWORD PTR vtimer$[rsp]
  00050	89 88 74 07 00
	00		 mov	 DWORD PTR [rax+1908], ecx

; 1292 : }

  00056	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005a	c3		 ret	 0
set_ecps_vtimer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
regs$ = 48
get_ecps_vtimer PROC

; 1281 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1282 :     return (S32)TOD_TO_ITIMER((S64)(regs->ecps_vtimer - hw_clock()));

  00009	e8 00 00 00 00	 call	 hw_clock
  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00013	48 8b 89 68 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1896]
  0001a	48 2b c8	 sub	 rcx, rax
  0001d	48 8b c1	 mov	 rax, rcx
  00020	48 6b c0 03	 imul	 rax, rax, 3
  00024	48 99		 cdq
  00026	b9 71 02 00 00	 mov	 ecx, 625		; 00000271H
  0002b	48 f7 f9	 idiv	 rcx

; 1283 : }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
get_ecps_vtimer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
year$ = 32
leapyear$ = 36
tv82 = 40
tv94 = 44
tod$ = 48
tv86 = 56
tv131 = 64
epoch$ = 96
lyear_adjust PROC

; 1117 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1118 : int year, leapyear;
; 1119 : TOD tod = hw_clock();

  00008	e8 00 00 00 00	 call	 hw_clock
  0000d	48 89 44 24 30	 mov	 QWORD PTR tod$[rsp], rax

; 1120 : 
; 1121 :     if (tod >= TOD_YEAR)

  00012	48 b8 00 00 00
	3e c1 e8 ca 01	 mov	 rax, 129171456000000000	; 01cae8c13e000000H
  0001c	48 39 44 24 30	 cmp	 QWORD PTR tod$[rsp], rax
  00021	0f 82 91 00 00
	00		 jb	 $LN2@lyear_adju

; 1122 :     {
; 1123 :         tod -= TOD_YEAR;

  00027	48 b8 00 00 00
	3e c1 e8 ca 01	 mov	 rax, 129171456000000000	; 01cae8c13e000000H
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tod$[rsp]
  00036	48 2b c8	 sub	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	48 89 44 24 30	 mov	 QWORD PTR tod$[rsp], rax

; 1124 :         year = (tod / TOD_4YEARS * 4) + 1;

  00041	33 d2		 xor	 edx, edx
  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR tod$[rsp]
  00048	48 b9 00 00 00
	6e e2 e4 2c 07	 mov	 rcx, 517039718400000000	; 072ce4e26e000000H
  00052	48 f7 f1	 div	 rcx
  00055	48 8d 04 85 01
	00 00 00	 lea	 rax, QWORD PTR [rax*4+1]
  0005d	89 44 24 20	 mov	 DWORD PTR year$[rsp], eax

; 1125 :         tod %= TOD_4YEARS;

  00061	33 d2		 xor	 edx, edx
  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR tod$[rsp]
  00068	48 b9 00 00 00
	6e e2 e4 2c 07	 mov	 rcx, 517039718400000000	; 072ce4e26e000000H
  00072	48 f7 f1	 div	 rcx
  00075	48 8b c2	 mov	 rax, rdx
  00078	48 89 44 24 30	 mov	 QWORD PTR tod$[rsp], rax

; 1126 : 
; 1127 :         if ((leapyear = tod / TOD_YEAR) == 4)

  0007d	33 d2		 xor	 edx, edx
  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR tod$[rsp]
  00084	48 b9 00 00 00
	3e c1 e8 ca 01	 mov	 rcx, 129171456000000000	; 01cae8c13e000000H
  0008e	48 f7 f1	 div	 rcx
  00091	89 44 24 24	 mov	 DWORD PTR leapyear$[rsp], eax
  00095	83 7c 24 24 04	 cmp	 DWORD PTR leapyear$[rsp], 4
  0009a	75 0a		 jne	 SHORT $LN4@lyear_adju

; 1128 :             year--;

  0009c	8b 44 24 20	 mov	 eax, DWORD PTR year$[rsp]
  000a0	ff c8		 dec	 eax
  000a2	89 44 24 20	 mov	 DWORD PTR year$[rsp], eax
$LN4@lyear_adju:

; 1129 : 
; 1130 :         year += leapyear;

  000a6	8b 44 24 24	 mov	 eax, DWORD PTR leapyear$[rsp]
  000aa	8b 4c 24 20	 mov	 ecx, DWORD PTR year$[rsp]
  000ae	03 c8		 add	 ecx, eax
  000b0	8b c1		 mov	 eax, ecx
  000b2	89 44 24 20	 mov	 DWORD PTR year$[rsp], eax

; 1131 :     }

  000b6	eb 08		 jmp	 SHORT $LN3@lyear_adju
$LN2@lyear_adju:

; 1132 :     else
; 1133 :        year = 0;

  000b8	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR year$[rsp], 0
$LN3@lyear_adju:

; 1134 : 
; 1135 :     if (epoch > 0)

  000c0	83 7c 24 60 00	 cmp	 DWORD PTR epoch$[rsp], 0
  000c5	7e 61		 jle	 SHORT $LN5@lyear_adju

; 1136 :         return ( ((!is_leapyear(year)) && (((year % 4) - (epoch % 4)) <= 0)) ? -TOD_DAY : 0 );

  000c7	8b 4c 24 20	 mov	 ecx, DWORD PTR year$[rsp]
  000cb	e8 00 00 00 00	 call	 is_leapyear
  000d0	0f b6 c0	 movzx	 eax, al
  000d3	85 c0		 test	 eax, eax
  000d5	75 3f		 jne	 SHORT $LN8@lyear_adju
  000d7	8b 44 24 20	 mov	 eax, DWORD PTR year$[rsp]
  000db	99		 cdq
  000dc	83 e2 03	 and	 edx, 3
  000df	03 c2		 add	 eax, edx
  000e1	83 e0 03	 and	 eax, 3
  000e4	2b c2		 sub	 eax, edx
  000e6	89 44 24 28	 mov	 DWORD PTR tv82[rsp], eax
  000ea	8b 44 24 60	 mov	 eax, DWORD PTR epoch$[rsp]
  000ee	99		 cdq
  000ef	83 e2 03	 and	 edx, 3
  000f2	03 c2		 add	 eax, edx
  000f4	83 e0 03	 and	 eax, 3
  000f7	2b c2		 sub	 eax, edx
  000f9	8b 4c 24 28	 mov	 ecx, DWORD PTR tv82[rsp]
  000fd	2b c8		 sub	 ecx, eax
  000ff	8b c1		 mov	 eax, ecx
  00101	85 c0		 test	 eax, eax
  00103	7f 11		 jg	 SHORT $LN8@lyear_adju
  00105	48 b8 00 00 00
	8a 22 be fe ff	 mov	 rax, -353894400000000	; fffebe228a000000H
  0010f	48 89 44 24 38	 mov	 QWORD PTR tv86[rsp], rax
  00114	eb 09		 jmp	 SHORT $LN9@lyear_adju
$LN8@lyear_adju:
  00116	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tv86[rsp], 0
$LN9@lyear_adju:
  0011f	48 8b 44 24 38	 mov	 rax, QWORD PTR tv86[rsp]
  00124	eb 79		 jmp	 SHORT $LN1@lyear_adju
  00126	eb 77		 jmp	 SHORT $LN6@lyear_adju
$LN5@lyear_adju:

; 1137 :     else
; 1138 :         return ( ((is_leapyear(year) && (-epoch % 4) != 0) || ((year % 4) + (-epoch % 4) > 4)) ? TOD_DAY : 0 );

  00128	8b 4c 24 20	 mov	 ecx, DWORD PTR year$[rsp]
  0012c	e8 00 00 00 00	 call	 is_leapyear
  00131	0f b6 c0	 movzx	 eax, al
  00134	85 c0		 test	 eax, eax
  00136	74 15		 je	 SHORT $LN10@lyear_adju
  00138	8b 44 24 60	 mov	 eax, DWORD PTR epoch$[rsp]
  0013c	f7 d8		 neg	 eax
  0013e	99		 cdq
  0013f	83 e2 03	 and	 edx, 3
  00142	03 c2		 add	 eax, edx
  00144	83 e0 03	 and	 eax, 3
  00147	2b c2		 sub	 eax, edx
  00149	85 c0		 test	 eax, eax
  0014b	75 3e		 jne	 SHORT $LN11@lyear_adju
$LN10@lyear_adju:
  0014d	8b 44 24 20	 mov	 eax, DWORD PTR year$[rsp]
  00151	99		 cdq
  00152	83 e2 03	 and	 edx, 3
  00155	03 c2		 add	 eax, edx
  00157	83 e0 03	 and	 eax, 3
  0015a	2b c2		 sub	 eax, edx
  0015c	89 44 24 2c	 mov	 DWORD PTR tv94[rsp], eax
  00160	8b 4c 24 60	 mov	 ecx, DWORD PTR epoch$[rsp]
  00164	f7 d9		 neg	 ecx
  00166	8b c1		 mov	 eax, ecx
  00168	99		 cdq
  00169	83 e2 03	 and	 edx, 3
  0016c	03 c2		 add	 eax, edx
  0016e	83 e0 03	 and	 eax, 3
  00171	2b c2		 sub	 eax, edx
  00173	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv94[rsp]
  00177	03 c8		 add	 ecx, eax
  00179	8b c1		 mov	 eax, ecx
  0017b	83 f8 04	 cmp	 eax, 4
  0017e	7f 0b		 jg	 SHORT $LN11@lyear_adju
  00180	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv131[rsp], 0
  00189	eb 0f		 jmp	 SHORT $LN12@lyear_adju
$LN11@lyear_adju:
  0018b	48 b8 00 00 00
	76 dd 41 01 00	 mov	 rax, 353894400000000	; 000141dd76000000H
  00195	48 89 44 24 40	 mov	 QWORD PTR tv131[rsp], rax
$LN12@lyear_adju:
  0019a	48 8b 44 24 40	 mov	 rax, QWORD PTR tv131[rsp]
$LN6@lyear_adju:
$LN1@lyear_adju:

; 1139 : }

  0019f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001a3	c3		 ret	 0
lyear_adjust ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
tv70 = 0
tv72 = 4
year$ = 32
is_leapyear PROC

; 1109 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 1110 :     return (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));

  00008	33 d2		 xor	 edx, edx
  0000a	8b 44 24 20	 mov	 eax, DWORD PTR year$[rsp]
  0000e	b9 04 00 00 00	 mov	 ecx, 4
  00013	f7 f1		 div	 ecx
  00015	8b c2		 mov	 eax, edx
  00017	85 c0		 test	 eax, eax
  00019	75 2f		 jne	 SHORT $LN4@is_leapyea
  0001b	33 d2		 xor	 edx, edx
  0001d	8b 44 24 20	 mov	 eax, DWORD PTR year$[rsp]
  00021	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00026	f7 f1		 div	 ecx
  00028	8b c2		 mov	 eax, edx
  0002a	85 c0		 test	 eax, eax
  0002c	75 13		 jne	 SHORT $LN3@is_leapyea
  0002e	33 d2		 xor	 edx, edx
  00030	8b 44 24 20	 mov	 eax, DWORD PTR year$[rsp]
  00034	b9 90 01 00 00	 mov	 ecx, 400		; 00000190H
  00039	f7 f1		 div	 ecx
  0003b	8b c2		 mov	 eax, edx
  0003d	85 c0		 test	 eax, eax
  0003f	75 09		 jne	 SHORT $LN4@is_leapyea
$LN3@is_leapyea:
  00041	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv70[rsp], 1
  00048	eb 07		 jmp	 SHORT $LN5@is_leapyea
$LN4@is_leapyea:
  0004a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv70[rsp], 0
$LN5@is_leapyea:
  00051	83 3c 24 00	 cmp	 DWORD PTR tv70[rsp], 0
  00055	75 0a		 jne	 SHORT $LN6@is_leapyea
  00057	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
  0005f	eb 08		 jmp	 SHORT $LN7@is_leapyea
$LN6@is_leapyea:
  00061	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
$LN7@is_leapyea:
  00069	0f b6 44 24 04	 movzx	 eax, BYTE PTR tv72[rsp]

; 1111 : }

  0006e	48 83 c4 18	 add	 rsp, 24
  00072	c3		 ret	 0
is_leapyear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
epoch$ = 32
tv67 = 36
tv78 = 40
ly1960$ = 48
tv71 = 56
configure_time PROC

; 1145 : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1146 : int epoch;
; 1147 : S64 ly1960;
; 1148 : 
; 1149 :     /* Set up the system TOD clock offset: compute the number of
; 1150 :      * microseconds offset to 0000 GMT, 1 January 1900.
; 1151 :      */
; 1152 : 
; 1153 :     if( (epoch = default_epoch) == 1960 )

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR default_epoch
  0000a	89 44 24 20	 mov	 DWORD PTR epoch$[rsp], eax
  0000e	81 7c 24 20 a8
	07 00 00	 cmp	 DWORD PTR epoch$[rsp], 1960 ; 000007a8H
  00016	75 11		 jne	 SHORT $LN2@configure_

; 1154 :         ly1960 = ETOD_DAY;

  00018	48 b8 00 00 76
	dd 41 01 00 00	 mov	 rax, 1382400000000	; 00000141dd760000H
  00022	48 89 44 24 30	 mov	 QWORD PTR ly1960$[rsp], rax
  00027	eb 09		 jmp	 SHORT $LN3@configure_
$LN2@configure_:

; 1155 :     else
; 1156 :         ly1960 = 0;

  00029	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR ly1960$[rsp], 0
$LN3@configure_:

; 1157 : 
; 1158 :     epoch -= 1900 + default_yroffset;

  00032	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR default_yroffset
  00038	05 6c 07 00 00	 add	 eax, 1900		; 0000076cH
  0003d	8b 4c 24 20	 mov	 ecx, DWORD PTR epoch$[rsp]
  00041	2b c8		 sub	 ecx, eax
  00043	8b c1		 mov	 eax, ecx
  00045	89 44 24 20	 mov	 DWORD PTR epoch$[rsp], eax

; 1159 : 
; 1160 :     set_tod_epoch(((epoch*365+(epoch/4))*-ETOD_DAY)+lyear_adjust(epoch)+ly1960);

  00049	69 44 24 20 6d
	01 00 00	 imul	 eax, DWORD PTR epoch$[rsp], 365 ; 0000016dH
  00051	89 44 24 24	 mov	 DWORD PTR tv67[rsp], eax
  00055	8b 44 24 20	 mov	 eax, DWORD PTR epoch$[rsp]
  00059	99		 cdq
  0005a	83 e2 03	 and	 edx, 3
  0005d	03 c2		 add	 eax, edx
  0005f	c1 f8 02	 sar	 eax, 2
  00062	8b 4c 24 24	 mov	 ecx, DWORD PTR tv67[rsp]
  00066	03 c8		 add	 ecx, eax
  00068	8b c1		 mov	 eax, ecx
  0006a	48 98		 cdqe
  0006c	48 b9 00 00 8a
	22 be fe ff ff	 mov	 rcx, -1382400000000	; fffffebe228a0000H
  00076	48 0f af c1	 imul	 rax, rcx
  0007a	48 89 44 24 38	 mov	 QWORD PTR tv71[rsp], rax
  0007f	8b 4c 24 20	 mov	 ecx, DWORD PTR epoch$[rsp]
  00083	e8 00 00 00 00	 call	 lyear_adjust
  00088	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ly1960$[rsp]
  0008d	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv71[rsp]
  00092	48 03 ca	 add	 rcx, rdx
  00095	48 03 c1	 add	 rax, rcx
  00098	48 8b c8	 mov	 rcx, rax
  0009b	e8 00 00 00 00	 call	 set_tod_epoch

; 1161 : 
; 1162 :     /* Set the timezone offset */
; 1163 :     adjust_tod_epoch((((default_tzoffset / 100) * 60) + /* Hours -> Minutes       */

  000a0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR default_tzoffset
  000a6	99		 cdq
  000a7	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000ac	f7 f9		 idiv	 ecx
  000ae	6b c0 3c	 imul	 eax, eax, 60		; 0000003cH
  000b1	89 44 24 28	 mov	 DWORD PTR tv78[rsp], eax
  000b5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR default_tzoffset
  000bb	99		 cdq
  000bc	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000c1	f7 f9		 idiv	 ecx
  000c3	8b c2		 mov	 eax, edx
  000c5	8b 4c 24 28	 mov	 ecx, DWORD PTR tv78[rsp]
  000c9	03 c8		 add	 ecx, eax
  000cb	8b c1		 mov	 eax, ecx
  000cd	48 98		 cdqe
  000cf	48 69 c0 00 70
	38 39		 imul	 rax, rax, 960000000	; 39387000H
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	e8 00 00 00 00	 call	 adjust_tod_epoch

; 1164 :                       (default_tzoffset % 100)) *       /* Minutes                */
; 1165 :                      ETOD_MIN);                         /* Convert to ETOD format */
; 1166 : }

  000de	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e2	c3		 ret	 0
configure_time ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
cpu$ = 32
epoch$ = 64
set_tod_epoch_all PROC

; 764  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 765  : int cpu;
; 766  : 
; 767  :     /* Update the TOD clock of all CPU's in the configuration
; 768  :        as we simulate 1 shared TOD clock, and do not support
; 769  :        the TOD clock sync check.
; 770  :     */
; 771  :     for (cpu = 0; cpu < sysblk.maxcpu; cpu++)

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN4@set_tod_ep
$LN2@set_tod_ep:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN4@set_tod_ep:
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00024	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0002a	39 44 24 20	 cmp	 DWORD PTR cpu$[rsp], eax
  0002e	0f 8d 84 00 00
	00		 jge	 $LN3@set_tod_ep

; 772  :     {
; 773  :         obtain_lock( &sysblk.cpulock[ cpu ]);

  00034	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00040	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202057
  0004f	48 8b c8	 mov	 rcx, rax
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 774  :         {
; 775  :             if (IS_CPU_ONLINE(cpu))

  00058	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0005d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00064	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0006d	74 20		 je	 SHORT $LN5@set_tod_ep

; 776  :                 sysblk.regs[ cpu ]->tod_epoch = epoch;

  0006f	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00074	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0007b	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00083	48 8b 4c 24 40	 mov	 rcx, QWORD PTR epoch$[rsp]
  00088	48 89 88 40 07
	00 00		 mov	 QWORD PTR [rax+1856], rcx
$LN5@set_tod_ep:

; 777  :         }
; 778  :         release_lock( &sysblk.cpulock[ cpu ]);

  0008f	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00094	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0009b	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202059
  000aa	48 8b c8	 mov	 rcx, rax
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 779  :     }

  000b3	e9 5b ff ff ff	 jmp	 $LN2@set_tod_ep
$LN3@set_tod_ep:

; 780  : 
; 781  :     return epoch;

  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR epoch$[rsp]

; 782  : }

  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	c3		 ret	 0
set_tod_epoch_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
adjustment$ = 48
adjust_tod_epoch PROC

; 808  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 809  :     obtain_lock( &sysblk.todlock );

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202069
  0001d	48 8b c8	 mov	 rcx, rax
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 810  :     {
; 811  :         csr_reset();

  00026	e8 00 00 00 00	 call	 csr_reset

; 812  :         tod_epoch += adjustment;

  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR adjustment$[rsp]
  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR tod_epoch
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	48 89 05 00 00
	00 00		 mov	 QWORD PTR tod_epoch, rax

; 813  :     }
; 814  :     release_lock( &sysblk.todlock );

  00044	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004b	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202070
  00058	48 8b c8	 mov	 rcx, rax
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 815  : 
; 816  :     set_tod_epoch_all( tod_epoch );

  00061	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR tod_epoch
  00068	e8 00 00 00 00	 call	 set_tod_epoch_all

; 817  : }

  0006d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00071	c3		 ret	 0
adjust_tod_epoch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
epoch$ = 48
set_tod_epoch PROC

; 794  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 795  :     obtain_lock( &sysblk.todlock );

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202064
  0001d	48 8b c8	 mov	 rcx, rax
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 796  :     {
; 797  :         csr_reset();

  00026	e8 00 00 00 00	 call	 csr_reset

; 798  :         tod_epoch = epoch;

  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR epoch$[rsp]
  00030	48 89 05 00 00
	00 00		 mov	 QWORD PTR tod_epoch, rax

; 799  :     }
; 800  :     release_lock( &sysblk.todlock );

  00037	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003e	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202065
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 801  : 
; 802  :     set_tod_epoch_all( tod_epoch );

  00054	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR tod_epoch
  0005b	e8 00 00 00 00	 call	 set_tod_epoch_all

; 803  : }

  00060	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00064	c3		 ret	 0
set_tod_epoch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
offset$ = 48
adjust_tod_offset PROC

; 876  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 877  :     obtain_lock( &sysblk.todlock );

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202093
  0001d	48 8b c8	 mov	 rcx, rax
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 878  :     {
; 879  :         prepare_new_episode();

  00026	e8 00 00 00 00	 call	 prepare_new_episode

; 880  :         episode_new.base_offset = episode_old.base_offset + offset;

  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR offset$[rsp]
  00030	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR episode_old+8
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	48 89 05 08 00
	00 00		 mov	 QWORD PTR episode_new+8, rax

; 881  :     }
; 882  :     release_lock( &sysblk.todlock );

  00044	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004b	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202094
  00058	48 8b c8	 mov	 rcx, rax
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 883  : }

  00061	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00065	c3		 ret	 0
adjust_tod_offset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
offset$ = 48
set_tod_offset PROC

; 863  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 864  :     obtain_lock( &sysblk.todlock );

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202088
  0001d	48 8b c8	 mov	 rcx, rax
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 865  :     {
; 866  :         prepare_new_episode();

  00026	e8 00 00 00 00	 call	 prepare_new_episode

; 867  :         episode_new.base_offset = offset;

  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR offset$[rsp]
  00030	48 89 05 08 00
	00 00		 mov	 QWORD PTR episode_new+8, rax

; 868  :     }
; 869  :     release_lock( &sysblk.todlock );

  00037	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003e	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00044	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202089
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 870  : }

  00054	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00058	c3		 ret	 0
set_tod_offset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
start_new_episode PROC

; 734  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 735  :     hw_offset = hw_tod.high - universal_tod.high;

  00004	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR universal_tod+8
  0000b	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR hw_tod+8
  00012	48 2b c8	 sub	 rcx, rax
  00015	48 8b c1	 mov	 rax, rcx
  00018	48 89 05 00 00
	00 00		 mov	 QWORD PTR hw_offset, rax

; 736  :     hw_episode = hw_tod.high;

  0001f	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR hw_tod+8
  00026	48 89 05 00 00
	00 00		 mov	 QWORD PTR hw_episode, rax

; 737  :     episode_new.start_time = hw_episode;

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hw_episode
  00034	48 89 05 00 00
	00 00		 mov	 QWORD PTR episode_new, rax

; 738  :     /* TODO: Convert to binary arithmetic to avoid floating point conversions */
; 739  :     hw_steering = ldexp(2,-44) *

  0003b	ba d4 ff ff ff	 mov	 edx, -44		; ffffffffffffffd4H
  00040	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4000000000000000
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ldexp
  0004e	8b 05 14 00 00
	00		 mov	 eax, DWORD PTR episode_new+20
  00054	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR episode_new+16
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	f2 0f 2a c8	 cvtsi2sd xmm1, eax
  00062	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00066	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR hw_steering, xmm0

; 740  :                   (S32)(episode_new.fine_s_rate + episode_new.gross_s_rate);
; 741  :     episode_current = &episode_new;

  0006e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_new
  00075	48 89 05 00 00
	00 00		 mov	 QWORD PTR episode_current, rax

; 742  : }

  0007c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00080	c3		 ret	 0
start_new_episode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
prepare_new_episode PROC

; 750  : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi

; 751  :     if (episode_current == &episode_new)

  00003	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_new
  0000a	48 39 05 00 00
	00 00		 cmp	 QWORD PTR episode_current, rax
  00011	75 29		 jne	 SHORT $LN2@prepare_ne

; 752  :     {
; 753  :         episode_old = episode_new;

  00013	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_old
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:episode_new
  00021	48 8b f8	 mov	 rdi, rax
  00024	48 8b f1	 mov	 rsi, rcx
  00027	b9 18 00 00 00	 mov	 ecx, 24
  0002c	f3 a4		 rep movsb

; 754  :         episode_current = &episode_old;

  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_old
  00035	48 89 05 00 00
	00 00		 mov	 QWORD PTR episode_current, rax
$LN2@prepare_ne:

; 755  :     }
; 756  : }

  0003c	5f		 pop	 rdi
  0003d	5e		 pop	 rsi
  0003e	c3		 ret	 0
prepare_new_episode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
fsr$ = 48
set_fine_steering_rate PROC

; 850  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 851  :     obtain_lock( &sysblk.todlock );

  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000f	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202083
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 852  :     {
; 853  :         prepare_new_episode();

  00025	e8 00 00 00 00	 call	 prepare_new_episode

; 854  :         episode_new.fine_s_rate = fsr;

  0002a	8b 44 24 30	 mov	 eax, DWORD PTR fsr$[rsp]
  0002e	89 05 10 00 00
	00		 mov	 DWORD PTR episode_new+16, eax

; 855  :     }
; 856  :     release_lock( &sysblk.todlock );

  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003b	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202084
  00048	48 8b c8	 mov	 rcx, rax
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 857  : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
set_fine_steering_rate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
gsr$ = 48
set_gross_steering_rate PROC

; 837  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 838  :     obtain_lock( &sysblk.todlock );

  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000f	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202078
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 839  :     {
; 840  :         prepare_new_episode();

  00025	e8 00 00 00 00	 call	 prepare_new_episode

; 841  :         episode_new.gross_s_rate = gsr;

  0002a	8b 44 24 30	 mov	 eax, DWORD PTR gsr$[rsp]
  0002e	89 05 14 00 00
	00		 mov	 DWORD PTR episode_new+20, eax

; 842  :     }
; 843  :     release_lock( &sysblk.todlock );

  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003b	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202079
  00048	48 8b c8	 mov	 rcx, rax
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 844  : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
set_gross_steering_rate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
time$ = 32
__$ArrayPad$ = 48
ETOD$ = 80
host_ETOD PROC

; 570  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 571  :     struct timespec time;
; 572  : 
; 573  :     /* Should use CLOCK_MONOTONIC + adjustment, but host sleep/hibernate
; 574  :      * destroys consistent monotonic clock.
; 575  :      */
; 576  : 
; 577  :     clock_gettime( CLOCK_REALTIME, &time );

  00018	48 8d 54 24 20	 lea	 rdx, QWORD PTR time$[rsp]
  0001d	33 c9		 xor	 ecx, ecx
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock_gettime

; 578  :     timespec2ETOD( ETOD, &time );

  00025	48 8d 54 24 20	 lea	 rdx, QWORD PTR time$[rsp]
  0002a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ETOD$[rsp]
  0002f	e8 00 00 00 00	 call	 timespec2ETOD

; 579  :     return ( ETOD );                /* Return address of result      */

  00034	48 8b 44 24 50	 mov	 rax, QWORD PTR ETOD$[rsp]

; 580  : }

  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0003e	48 33 cc	 xor	 rcx, rsp
  00041	e8 00 00 00 00	 call	 __security_check_cookie
  00046	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004a	c3		 ret	 0
host_ETOD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
hw_clock_locked PROC

; 686  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 687  :     /* Get time of day (GMT); adjust speed and ensure uniqueness */
; 688  :     return hw_adjust( universal_clock() );

  00004	e8 00 00 00 00	 call	 universal_clock
  00009	48 8b c8	 mov	 rcx, rax
  0000c	e8 00 00 00 00	 call	 hw_adjust

; 689  : }

  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
hw_clock_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
base_tod$ = 96
hw_adjust PROC

; 658  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 659  :     /* Apply hardware offset, this is the offset achieved by all
; 660  :        previous steering episodes */
; 661  :     base_tod += hw_offset;

  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hw_offset
  00012	48 8b 4c 24 60	 mov	 rcx, QWORD PTR base_tod$[rsp]
  00017	48 03 c8	 add	 rcx, rax
  0001a	48 8b c1	 mov	 rax, rcx
  0001d	48 89 44 24 60	 mov	 QWORD PTR base_tod$[rsp], rax

; 662  : 
; 663  :     /* Apply the steering offset from the current steering episode */
; 664  :     /* TODO: Shift resolution to permit adjustment by less than 62.5
; 665  :      *       nanosecond increments (1/16 microsecond).
; 666  :      */
; 667  :     base_tod += (S64)(base_tod - hw_episode) * hw_steering;

  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hw_episode
  00029	48 8b 4c 24 60	 mov	 rcx, QWORD PTR base_tod$[rsp]
  0002e	48 2b c8	 sub	 rcx, rax
  00031	48 8b c1	 mov	 rax, rcx
  00034	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00039	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR hw_steering
  00041	48 8b 44 24 60	 mov	 rax, QWORD PTR base_tod$[rsp]
  00046	48 85 c0	 test	 rax, rax
  00049	7c 07		 jl	 SHORT $LN8@hw_adjust
  0004b	f2 48 0f 2a c8	 cvtsi2sd xmm1, rax
  00050	eb 19		 jmp	 SHORT $LN9@hw_adjust
$LN8@hw_adjust:
  00052	48 8b c8	 mov	 rcx, rax
  00055	48 d1 e9	 shr	 rcx, 1
  00058	48 83 e0 01	 and	 rax, 1
  0005c	48 0b c8	 or	 rcx, rax
  0005f	f2 48 0f 2a d1	 cvtsi2sd xmm2, rcx
  00064	f2 0f 58 d2	 addsd	 xmm2, xmm2
  00068	0f 28 ca	 movaps	 xmm1, xmm2
$LN9@hw_adjust:
  0006b	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0006f	0f 28 c1	 movaps	 xmm0, xmm1
  00072	33 c0		 xor	 eax, eax
  00074	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@43e0000000000000
  0007c	72 1f		 jb	 SHORT $LN7@hw_adjust
  0007e	f2 0f 5c 05 00
	00 00 00	 subsd	 xmm0, QWORD PTR __real@43e0000000000000
  00086	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@43e0000000000000
  0008e	73 0d		 jae	 SHORT $LN7@hw_adjust
  00090	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  0009a	48 03 c1	 add	 rax, rcx
$LN7@hw_adjust:
  0009d	f2 48 0f 2c c8	 cvttsd2si rcx, xmm0
  000a2	48 03 c8	 add	 rcx, rax
  000a5	48 8b c1	 mov	 rax, rcx
  000a8	48 89 44 24 60	 mov	 QWORD PTR base_tod$[rsp], rax

; 668  : 
; 669  :     /* Ensure that the clock returns a unique value */
; 670  :     if (hw_tod.high < base_tod)

  000ad	48 8b 44 24 60	 mov	 rax, QWORD PTR base_tod$[rsp]
  000b2	48 39 05 08 00
	00 00		 cmp	 QWORD PTR hw_tod+8, rax
  000b9	73 1c		 jae	 SHORT $LN2@hw_adjust

; 671  :         hw_tod.high = base_tod,

  000bb	48 8b 44 24 60	 mov	 rax, QWORD PTR base_tod$[rsp]
  000c0	48 89 05 08 00
	00 00		 mov	 QWORD PTR hw_tod+8, rax
  000c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR universal_tod
  000ce	48 89 05 00 00
	00 00		 mov	 QWORD PTR hw_tod, rax
  000d5	eb 63		 jmp	 SHORT $LN3@hw_adjust
$LN2@hw_adjust:

; 672  :         hw_tod.low  = universal_tod.low;
; 673  :     else if (hw_unique_clock_tick.low  == 0 &&

  000d7	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hw_unique_clock_tick, 0
  000df	75 11		 jne	 SHORT $LN4@hw_adjust
  000e1	48 83 3d 08 00
	00 00 00	 cmp	 QWORD PTR hw_unique_clock_tick+8, 0
  000e9	75 07		 jne	 SHORT $LN4@hw_adjust

; 674  :              hw_unique_clock_tick.high == 0)
; 675  :         hw_calculate_unique_tick();

  000eb	e8 00 00 00 00	 call	 hw_calculate_unique_tick
  000f0	eb 48		 jmp	 SHORT $LN5@hw_adjust
$LN4@hw_adjust:

; 676  :     else
; 677  :         ETOD_add( &hw_tod, hw_tod, hw_unique_clock_tick );

  000f2	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hw_unique_clock_tick
  000fe	48 8b f8	 mov	 rdi, rax
  00101	48 8b f1	 mov	 rsi, rcx
  00104	b9 10 00 00 00	 mov	 ecx, 16
  00109	f3 a4		 rep movsb
  0010b	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hw_tod
  00117	48 8b f8	 mov	 rdi, rax
  0011a	48 8b f1	 mov	 rsi, rcx
  0011d	b9 10 00 00 00	 mov	 ecx, 16
  00122	f3 a4		 rep movsb
  00124	4c 8d 44 24 20	 lea	 r8, QWORD PTR $T1[rsp]
  00129	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hw_tod
  00135	e8 00 00 00 00	 call	 ETOD_add
$LN5@hw_adjust:
$LN3@hw_adjust:

; 678  : 
; 679  :     return ( hw_tod.high );

  0013a	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR hw_tod+8

; 680  : }

  00141	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00145	5f		 pop	 rdi
  00146	5e		 pop	 rsi
  00147	c3		 ret	 0
hw_adjust ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
n$ = 32
result$ = 40
$T1 = 48
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
$T6 = 128
$T7 = 144
temp$ = 160
__$ArrayPad$ = 176
hw_calculate_unique_tick PROC

; 609  : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00011	48 33 c4	 xor	 rax, rsp
  00014	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 610  :     static const ETOD     m1  = ETOD_init(0,65536);
; 611  : 
; 612  :     ETOD          temp;
; 613  :     register TOD  result;
; 614  :     register int  n;
; 615  : 
; 616  :     temp.high = universal_tod.high;

  0001c	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR universal_tod+8
  00023	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR temp$[rsp+8], rax

; 617  :     temp.low  = universal_tod.low;

  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR universal_tod
  00032	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR temp$[rsp], rax

; 618  :     hw_unique_clock_tick.low = 1;

  0003a	48 c7 05 00 00
	00 00 01 00 00
	00		 mov	 QWORD PTR hw_unique_clock_tick, 1

; 619  :     for (n = 0; n < 65536; ++n)

  00045	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  0004d	eb 0a		 jmp	 SHORT $LN4@hw_calcula
$LN2@hw_calcula:
  0004f	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  00053	ff c0		 inc	 eax
  00055	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
$LN4@hw_calcula:
  00059	81 7c 24 20 00
	00 01 00	 cmp	 DWORD PTR n$[rsp], 65536 ; 00010000H
  00061	7d 14		 jge	 SHORT $LN3@hw_calcula

; 620  :         result = hw_adjust(universal_clock());

  00063	e8 00 00 00 00	 call	 universal_clock
  00068	48 8b c8	 mov	 rcx, rax
  0006b	e8 00 00 00 00	 call	 hw_adjust
  00070	48 89 44 24 28	 mov	 QWORD PTR result$[rsp], rax
  00075	eb d8		 jmp	 SHORT $LN2@hw_calcula
$LN3@hw_calcula:

; 621  :     ETOD_sub(&temp, universal_tod, temp);

  00077	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  0007c	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR temp$[rsp]
  00084	48 8b f8	 mov	 rdi, rax
  00087	48 8b f1	 mov	 rsi, rcx
  0008a	b9 10 00 00 00	 mov	 ecx, 16
  0008f	f3 a4		 rep movsb
  00091	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:universal_tod
  0009d	48 8b f8	 mov	 rdi, rax
  000a0	48 8b f1	 mov	 rsi, rcx
  000a3	b9 10 00 00 00	 mov	 ecx, 16
  000a8	f3 a4		 rep movsb
  000aa	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T1[rsp]
  000af	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T2[rsp]
  000b4	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR temp$[rsp]
  000bc	e8 00 00 00 00	 call	 ETOD_sub

; 622  :     ETOD_sub(&temp, temp, m1);

  000c1	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?m1@?1??hw_calculate_unique_tick@@9@9
  000cd	48 8b f8	 mov	 rdi, rax
  000d0	48 8b f1	 mov	 rsi, rcx
  000d3	b9 10 00 00 00	 mov	 ecx, 16
  000d8	f3 a4		 rep movsb
  000da	48 8d 44 24 60	 lea	 rax, QWORD PTR $T4[rsp]
  000df	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR temp$[rsp]
  000e7	48 8b f8	 mov	 rdi, rax
  000ea	48 8b f1	 mov	 rsi, rcx
  000ed	b9 10 00 00 00	 mov	 ecx, 16
  000f2	f3 a4		 rep movsb
  000f4	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T3[rsp]
  000f9	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T4[rsp]
  000fe	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR temp$[rsp]
  00106	e8 00 00 00 00	 call	 ETOD_sub

; 623  :     ETOD_shift(&hw_unique_clock_tick, temp, 16);

  0010b	48 8d 44 24 70	 lea	 rax, QWORD PTR $T5[rsp]
  00110	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR temp$[rsp]
  00118	48 8b f8	 mov	 rdi, rax
  0011b	48 8b f1	 mov	 rsi, rcx
  0011e	b9 10 00 00 00	 mov	 ecx, 16
  00123	f3 a4		 rep movsb
  00125	41 b8 10 00 00
	00		 mov	 r8d, 16
  0012b	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T5[rsp]
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hw_unique_clock_tick
  00137	e8 00 00 00 00	 call	 ETOD_shift

; 624  :     if (hw_unique_clock_tick.low  == 0 &&

  0013c	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hw_unique_clock_tick, 0
  00144	75 17		 jne	 SHORT $LN5@hw_calcula
  00146	48 83 3d 08 00
	00 00 00	 cmp	 QWORD PTR hw_unique_clock_tick+8, 0
  0014e	75 0d		 jne	 SHORT $LN5@hw_calcula

; 625  :         hw_unique_clock_tick.high == 0)
; 626  :         hw_unique_clock_tick.high = 1;

  00150	48 c7 05 08 00
	00 00 01 00 00
	00		 mov	 QWORD PTR hw_unique_clock_tick+8, 1
  0015b	eb 72		 jmp	 SHORT $LN6@hw_calcula
$LN5@hw_calcula:

; 627  : 
; 628  : #if defined(TOD_95BIT_PRECISION) || \
; 629  :         defined(TOD_64BIT_PRECISION) || \
; 630  :         defined(TOD_MIN_PRECISION)
; 631  : 
; 632  :     else
; 633  :     {
; 634  :       #if defined(TOD_95BIT_PRECISION)
; 635  :         static const ETOD adj = ETOD_init(0,0x0000000100000000ULL);
; 636  :       #else
; 637  :         static const ETOD adj = ETOD_init(0,0x8000000000000000ULL);
; 638  :       #endif
; 639  : 
; 640  :         ETOD_add(&hw_unique_clock_tick, hw_unique_clock_tick, adj);

  0015d	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T6[rsp]
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?adj@?3??hw_calculate_unique_tick@@9@9
  0016c	48 8b f8	 mov	 rdi, rax
  0016f	48 8b f1	 mov	 rsi, rcx
  00172	b9 10 00 00 00	 mov	 ecx, 16
  00177	f3 a4		 rep movsb
  00179	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T7[rsp]
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hw_unique_clock_tick
  00188	48 8b f8	 mov	 rdi, rax
  0018b	48 8b f1	 mov	 rsi, rcx
  0018e	b9 10 00 00 00	 mov	 ecx, 16
  00193	f3 a4		 rep movsb
  00195	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR $T6[rsp]
  0019d	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR $T7[rsp]
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hw_unique_clock_tick
  001ac	e8 00 00 00 00	 call	 ETOD_add

; 641  : 
; 642  :       #if defined(TOD_95BIT_PRECISION)
; 643  :         hw_unique_clock_tick.low &= 0xFFFFFFFE00000000ULL;

  001b1	48 b8 00 00 00
	00 fe ff ff ff	 mov	 rax, -8589934592	; fffffffe00000000H
  001bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hw_unique_clock_tick
  001c2	48 23 c8	 and	 rcx, rax
  001c5	48 8b c1	 mov	 rax, rcx
  001c8	48 89 05 00 00
	00 00		 mov	 QWORD PTR hw_unique_clock_tick, rax
$LN6@hw_calcula:

; 644  :       #else
; 645  :         hw_unique_clock_tick.low = 0;
; 646  :       #endif
; 647  :     }
; 648  : 
; 649  : #endif /* defined(TOD_95BIT_PRECISION) ... */
; 650  : 
; 651  :     return ( result );

  001cf	48 8b 44 24 28	 mov	 rax, QWORD PTR result$[rsp]

; 652  : }

  001d4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001dc	48 33 cc	 xor	 rcx, rsp
  001df	e8 00 00 00 00	 call	 __security_check_cookie
  001e4	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  001eb	5f		 pop	 rdi
  001ec	5e		 pop	 rsi
  001ed	c3		 ret	 0
hw_calculate_unique_tick ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
universal_clock PROC

; 600  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 601  :     host_ETOD( &universal_tod );

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:universal_tod
  0000b	e8 00 00 00 00	 call	 host_ETOD

; 602  :     return (universal_tod.high);

  00010	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR universal_tod+8

; 603  : }

  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	c3		 ret	 0
universal_clock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
sr_string_error_ PROC

; 842  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 843  :     // "SR: string error, incorrect length"
; 844  :     WRMSG(HHC02021, "E");

  00004	b9 01 00 00 00	 mov	 ecx, 1
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178901
  00016	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178902
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178903
  00039	ba 4c 03 00 00	 mov	 edx, 844		; 0000034cH
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178904
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 845  : }

  0004b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004f	c3		 ret	 0
sr_string_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
sr_value_error_ PROC

; 836  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 837  :     // "SR: value error, incorrect length"
; 838  :     WRMSG(HHC02020, "E");

  00004	b9 01 00 00 00	 mov	 ecx, 1
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178896
  00016	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178897
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178898
  00039	ba 46 03 00 00	 mov	 edx, 838		; 00000346H
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178899
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 839  : }

  0004b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004f	c3		 ret	 0
sr_value_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv64 = 80
sr_read_error_ PROC

; 824  : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 825  :     // "SR: error in function '%s': '%s'"
; 826  :     WRMSG(HHC02001, "E", "read()", strerror(errno));

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00012	48 89 44 24 50	 mov	 QWORD PTR tv64[rsp], rax
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv64[rsp]
  00027	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178884
  00033	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178885
  0003f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178886
  0004b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	41 b9 03 00 00
	00		 mov	 r9d, 3
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178887
  00062	ba 3a 03 00 00	 mov	 edx, 826		; 0000033aH
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178888
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 827  : }

  00074	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00078	c3		 ret	 0
sr_read_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv64 = 80
sr_write_error_ PROC

; 818  : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 819  :     // "SR: error in function '%s': '%s'"
; 820  :     WRMSG(HHC02001, "E", "write()", strerror(errno));

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00012	48 89 44 24 50	 mov	 QWORD PTR tv64[rsp], rax
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv64[rsp]
  00027	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178878
  00033	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178879
  0003f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178880
  0004b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	41 b9 03 00 00
	00		 mov	 r9d, 3
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178881
  00062	ba 34 03 00 00	 mov	 edx, 820		; 00000334H
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178882
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 821  : }

  00074	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00078	c3		 ret	 0
sr_write_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tot$ = 32
siz$ = 40
tv74 = 48
buf$ = 64
__$ArrayPad$ = 320
file$ = 352
len$ = 360
sr_read_skip PROC

; 677  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_read_sk:

; 678  : /* FIXME: Workaround for problem involving gzseek
; 679  :           and large files.  Just read the data. */
; 680  : 
; 681  : BYTE    buf[SR_SKIP_CHUNKSIZE];
; 682  : size_t  siz;
; 683  : size_t  tot;
; 684  : 
; 685  :     TRACE("SR: sr_read_skip:                  len=0x%8.8x\n", len);

  00022	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178790
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003c	85 c0		 test	 eax, eax
  0003e	74 13		 je	 SHORT $LN7@sr_read_sk
  00040	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178792
  0004e	e8 00 00 00 00	 call	 DebuggerTrace
$LN7@sr_read_sk:
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	75 c9		 jne	 SHORT $LN4@sr_read_sk

; 686  : 
; 687  :     tot = len;

  00059	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00060	48 89 44 24 20	 mov	 QWORD PTR tot$[rsp], rax
$LN5@sr_read_sk:

; 688  : 
; 689  :     while (tot)

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR tot$[rsp], 0
  0006b	74 71		 je	 SHORT $LN6@sr_read_sk

; 690  :     {
; 691  :         siz = tot < SR_SKIP_CHUNKSIZE ? tot : SR_SKIP_CHUNKSIZE;

  0006d	48 81 7c 24 20
	00 01 00 00	 cmp	 QWORD PTR tot$[rsp], 256 ; 00000100H
  00076	73 0c		 jae	 SHORT $LN10@sr_read_sk
  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR tot$[rsp]
  0007d	48 89 44 24 30	 mov	 QWORD PTR tv74[rsp], rax
  00082	eb 09		 jmp	 SHORT $LN11@sr_read_sk
$LN10@sr_read_sk:
  00084	48 c7 44 24 30
	00 01 00 00	 mov	 QWORD PTR tv74[rsp], 256 ; 00000100H
$LN11@sr_read_sk:
  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR tv74[rsp]
  00092	48 89 44 24 28	 mov	 QWORD PTR siz$[rsp], rax

; 692  : 
; 693  :         if ((size_t)SR_READ(buf, 1, siz, file) != siz)

  00097	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR file$[rsp]
  0009f	4c 8b 44 24 28	 mov	 r8, QWORD PTR siz$[rsp]
  000a4	ba 01 00 00 00	 mov	 edx, 1
  000a9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  000b4	48 3b 44 24 28	 cmp	 rax, QWORD PTR siz$[rsp]
  000b9	74 0c		 je	 SHORT $LN8@sr_read_sk

; 694  :         {
; 695  :             sr_read_error_();

  000bb	e8 00 00 00 00	 call	 sr_read_error_

; 696  :             return -1;

  000c0	b8 ff ff ff ff	 mov	 eax, -1
  000c5	eb 19		 jmp	 SHORT $LN1@sr_read_sk
$LN8@sr_read_sk:

; 697  :         }
; 698  :         tot -= siz;

  000c7	48 8b 44 24 28	 mov	 rax, QWORD PTR siz$[rsp]
  000cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tot$[rsp]
  000d1	48 2b c8	 sub	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 89 44 24 20	 mov	 QWORD PTR tot$[rsp], rax

; 699  :     }

  000dc	eb 87		 jmp	 SHORT $LN5@sr_read_sk
$LN6@sr_read_sk:

; 700  :     return 0;

  000de	33 c0		 xor	 eax, eax
$LN1@sr_read_sk:

; 701  : }

  000e0	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e8	48 33 cc	 xor	 rcx, rsp
  000eb	e8 00 00 00 00	 call	 __security_check_cookie
  000f0	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000f7	c3		 ret	 0
sr_read_skip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
file$ = 48
p$ = 56
len$ = 64
sr_read_string PROC

; 707  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@sr_read_st:

; 708  :     TRACE("SR: sr_read_string:                len=0x%8.8x\n", len);

  00013	8b 54 24 40	 mov	 edx, DWORD PTR len$[rsp]
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178805
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0002a	85 c0		 test	 eax, eax
  0002c	74 10		 je	 SHORT $LN5@sr_read_st
  0002e	8b 54 24 40	 mov	 edx, DWORD PTR len$[rsp]
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178807
  00039	e8 00 00 00 00	 call	 DebuggerTrace
$LN5@sr_read_st:
  0003e	33 c0		 xor	 eax, eax
  00040	85 c0		 test	 eax, eax
  00042	75 cf		 jne	 SHORT $LN4@sr_read_st

; 709  : 
; 710  :     if (len > SR_MAX_STRING_LENGTH)

  00044	81 7c 24 40 00
	10 00 00	 cmp	 DWORD PTR len$[rsp], 4096 ; 00001000H
  0004c	76 0c		 jbe	 SHORT $LN6@sr_read_st

; 711  :     {
; 712  :         sr_string_error_();

  0004e	e8 00 00 00 00	 call	 sr_string_error_

; 713  :         return -1;

  00053	b8 ff ff ff ff	 mov	 eax, -1
  00058	eb 30		 jmp	 SHORT $LN1@sr_read_st
$LN6@sr_read_st:

; 714  :     }
; 715  :     if ((U32)SR_READ(p, 1, len, file) != len)

  0005a	8b 44 24 40	 mov	 eax, DWORD PTR len$[rsp]
  0005e	4c 8b 4c 24 30	 mov	 r9, QWORD PTR file$[rsp]
  00063	44 8b c0	 mov	 r8d, eax
  00066	ba 01 00 00 00	 mov	 edx, 1
  0006b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$[rsp]
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  00076	3b 44 24 40	 cmp	 eax, DWORD PTR len$[rsp]
  0007a	74 0c		 je	 SHORT $LN7@sr_read_st

; 716  :     {
; 717  :         sr_read_error_();

  0007c	e8 00 00 00 00	 call	 sr_read_error_

; 718  :         return -1;

  00081	b8 ff ff ff ff	 mov	 eax, -1
  00086	eb 02		 jmp	 SHORT $LN1@sr_read_st
$LN7@sr_read_st:

; 719  :     }
; 720  :     return 0;

  00088	33 c0		 xor	 eax, eax
$LN1@sr_read_st:

; 721  : }

  0008a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008e	c3		 ret	 0
sr_read_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
value$ = 32
tv85 = 40
tv146 = 44
ptr$1 = 48
ptr$2 = 56
ptr$3 = 64
ptr$4 = 72
buf$ = 80
__$ArrayPad$ = 88
file$ = 112
suslen$ = 120
p$ = 128
reslen$ = 136
sr_read_value PROC

; 754  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_read_va:

; 755  : BYTE    buf[8];
; 756  : U64     value;
; 757  : 
; 758  :     TRACE("SR: sr_read_value:              suslen=0x%8.8x, reslen=0x%8.8x,\n", suslen, reslen);

  00026	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR reslen$[rsp]
  0002e	8b 54 24 78	 mov	 edx, DWORD PTR suslen$[rsp]
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178860
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00045	85 c0		 test	 eax, eax
  00047	74 18		 je	 SHORT $LN12@sr_read_va
  00049	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR reslen$[rsp]
  00051	8b 54 24 78	 mov	 edx, DWORD PTR suslen$[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178862
  0005c	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@sr_read_va:
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 bf		 jne	 SHORT $LN4@sr_read_va

; 759  : 
; 760  :     if (suslen != 1 && suslen != 2 && suslen != 4 && suslen != 8)

  00067	83 7c 24 78 01	 cmp	 DWORD PTR suslen$[rsp], 1
  0006c	74 24		 je	 SHORT $LN13@sr_read_va
  0006e	83 7c 24 78 02	 cmp	 DWORD PTR suslen$[rsp], 2
  00073	74 1d		 je	 SHORT $LN13@sr_read_va
  00075	83 7c 24 78 04	 cmp	 DWORD PTR suslen$[rsp], 4
  0007a	74 16		 je	 SHORT $LN13@sr_read_va
  0007c	83 7c 24 78 08	 cmp	 DWORD PTR suslen$[rsp], 8
  00081	74 0f		 je	 SHORT $LN13@sr_read_va

; 761  :     {
; 762  :         sr_value_error_();

  00083	e8 00 00 00 00	 call	 sr_value_error_

; 763  :         return -1;

  00088	b8 ff ff ff ff	 mov	 eax, -1
  0008d	e9 a8 01 00 00	 jmp	 $LN1@sr_read_va
$LN13@sr_read_va:

; 764  :     }
; 765  : 
; 766  :     if ((U32)SR_READ(buf, 1, suslen, file) != suslen)

  00092	8b 44 24 78	 mov	 eax, DWORD PTR suslen$[rsp]
  00096	4c 8b 4c 24 70	 mov	 r9, QWORD PTR file$[rsp]
  0009b	44 8b c0	 mov	 r8d, eax
  0009e	ba 01 00 00 00	 mov	 edx, 1
  000a3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  000ae	3b 44 24 78	 cmp	 eax, DWORD PTR suslen$[rsp]
  000b2	74 0f		 je	 SHORT $LN14@sr_read_va

; 767  :     {
; 768  :         sr_read_error_();

  000b4	e8 00 00 00 00	 call	 sr_read_error_

; 769  :         return -1;

  000b9	b8 ff ff ff ff	 mov	 eax, -1
  000be	e9 77 01 00 00	 jmp	 $LN1@sr_read_va
$LN14@sr_read_va:

; 770  :     }
; 771  : 
; 772  :     switch (suslen)

  000c3	8b 44 24 78	 mov	 eax, DWORD PTR suslen$[rsp]
  000c7	89 44 24 28	 mov	 DWORD PTR tv85[rsp], eax
  000cb	83 7c 24 28 01	 cmp	 DWORD PTR tv85[rsp], 1
  000d0	74 17		 je	 SHORT $LN15@sr_read_va
  000d2	83 7c 24 28 02	 cmp	 DWORD PTR tv85[rsp], 2
  000d7	74 25		 je	 SHORT $LN16@sr_read_va
  000d9	83 7c 24 28 04	 cmp	 DWORD PTR tv85[rsp], 4
  000de	74 3a		 je	 SHORT $LN17@sr_read_va
  000e0	83 7c 24 28 08	 cmp	 DWORD PTR tv85[rsp], 8
  000e5	74 4d		 je	 SHORT $LN18@sr_read_va
  000e7	eb 64		 jmp	 SHORT $LN19@sr_read_va
$LN15@sr_read_va:

; 773  :     {
; 774  :         case 1:  value = buf[0];         break;

  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	48 6b c0 00	 imul	 rax, rax, 0
  000f2	0f b6 44 04 50	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  000f7	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  000fc	eb 58		 jmp	 SHORT $LN5@sr_read_va
$LN16@sr_read_va:

; 775  :         case 2:  value = fetch_hw (buf); break;

  000fe	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00103	e8 00 00 00 00	 call	 fetch_hw_noswap
  00108	0f b7 c8	 movzx	 ecx, ax
  0010b	e8 00 00 00 00	 call	 _byteswap_ushort
  00110	0f b7 c0	 movzx	 eax, ax
  00113	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  00118	eb 3c		 jmp	 SHORT $LN5@sr_read_va
$LN17@sr_read_va:

; 776  :         case 4:  value = fetch_fw (buf); break;

  0011a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  0011f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00124	8b c8		 mov	 ecx, eax
  00126	e8 00 00 00 00	 call	 _byteswap_ulong
  0012b	8b c0		 mov	 eax, eax
  0012d	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  00132	eb 22		 jmp	 SHORT $LN5@sr_read_va
$LN18@sr_read_va:

; 777  :         case 8:  value = fetch_dw (buf); break;

  00134	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00139	e8 00 00 00 00	 call	 fetch_dw_noswap
  0013e	48 8b c8	 mov	 rcx, rax
  00141	e8 00 00 00 00	 call	 _byteswap_uint64
  00146	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  0014b	eb 09		 jmp	 SHORT $LN5@sr_read_va
$LN19@sr_read_va:

; 778  :         default: value = 0;              break; /* To ward off gcc -Wall */

  0014d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR value$[rsp], 0
$LN5@sr_read_va:
$LN9@sr_read_va:

; 779  :     }
; 780  : 
; 781  :     TRACE("                           val=0x%16.16"PRIx64"\n", value);

  00156	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178870
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0016e	85 c0		 test	 eax, eax
  00170	74 11		 je	 SHORT $LN20@sr_read_va
  00172	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178872
  0017e	e8 00 00 00 00	 call	 DebuggerTrace
$LN20@sr_read_va:
  00183	33 c0		 xor	 eax, eax
  00185	85 c0		 test	 eax, eax
  00187	75 cd		 jne	 SHORT $LN9@sr_read_va

; 782  : 
; 783  :     switch (reslen)

  00189	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR reslen$[rsp]
  00190	89 44 24 2c	 mov	 DWORD PTR tv146[rsp], eax
  00194	83 7c 24 2c 01	 cmp	 DWORD PTR tv146[rsp], 1
  00199	74 1a		 je	 SHORT $LN21@sr_read_va
  0019b	83 7c 24 2c 02	 cmp	 DWORD PTR tv146[rsp], 2
  001a0	74 34		 je	 SHORT $LN22@sr_read_va
  001a2	83 7c 24 2c 04	 cmp	 DWORD PTR tv146[rsp], 4
  001a7	74 4f		 je	 SHORT $LN23@sr_read_va
  001a9	83 7c 24 2c 08	 cmp	 DWORD PTR tv146[rsp], 8
  001ae	74 6e		 je	 SHORT $LN24@sr_read_va
  001b0	e9 83 00 00 00	 jmp	 $LN10@sr_read_va
$LN21@sr_read_va:

; 784  :     {
; 785  :         case 1:
; 786  :         {
; 787  :             BYTE* ptr = p;

  001b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001bd	48 89 44 24 30	 mov	 QWORD PTR ptr$1[rsp], rax

; 788  :             *ptr = (BYTE)(value & 0xFF);

  001c2	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  001c7	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  001cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$1[rsp]
  001d2	88 01		 mov	 BYTE PTR [rcx], al

; 789  :             break;

  001d4	eb 62		 jmp	 SHORT $LN10@sr_read_va
$LN22@sr_read_va:

; 790  :         }
; 791  :         case 2:
; 792  :         {
; 793  :             U16* ptr = p;

  001d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001de	48 89 44 24 38	 mov	 QWORD PTR ptr$2[rsp], rax

; 794  :             *ptr = (U16)(value & 0xFFFF);

  001e3	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  001e8	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  001ee	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$2[rsp]
  001f3	66 89 01	 mov	 WORD PTR [rcx], ax

; 795  :             break;

  001f6	eb 40		 jmp	 SHORT $LN10@sr_read_va
$LN23@sr_read_va:

; 796  :         }
; 797  :         case 4:
; 798  :         {
; 799  :             U32* ptr = p;

  001f8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00200	48 89 44 24 40	 mov	 QWORD PTR ptr$3[rsp], rax

; 800  :             *ptr = (U32)(value & 0xFFFFFFFF);

  00205	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0020a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  0020f	48 23 c8	 and	 rcx, rax
  00212	48 8b c1	 mov	 rax, rcx
  00215	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ptr$3[rsp]
  0021a	89 01		 mov	 DWORD PTR [rcx], eax

; 801  :             break;

  0021c	eb 1a		 jmp	 SHORT $LN10@sr_read_va
$LN24@sr_read_va:

; 802  :         }
; 803  :         case 8:
; 804  :         {
; 805  :             U64* ptr = p;

  0021e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00226	48 89 44 24 48	 mov	 QWORD PTR ptr$4[rsp], rax

; 806  :             *ptr = (U64)(value & 0xFFFFFFFFFFFFFFFFULL);

  0022b	48 8b 44 24 48	 mov	 rax, QWORD PTR ptr$4[rsp]
  00230	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  00235	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN10@sr_read_va:

; 807  :             break;
; 808  :         }
; 809  :     }
; 810  :     return 0;

  00238	33 c0		 xor	 eax, eax
$LN1@sr_read_va:

; 811  : }

  0023a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0023f	48 33 cc	 xor	 rcx, rsp
  00242	e8 00 00 00 00	 call	 __security_check_cookie
  00247	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0024b	c3		 ret	 0
sr_read_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 40
file$ = 64
key$ = 72
len$ = 80
sr_read_hdr PROC

; 656  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 657  : BYTE  buf[8];
; 658  : 
; 659  :     if (SR_READ(buf, 1, 8, file) != 8)

  00022	4c 8b 4c 24 40	 mov	 r9, QWORD PTR file$[rsp]
  00027	41 b8 08 00 00
	00		 mov	 r8d, 8
  0002d	ba 01 00 00 00	 mov	 edx, 1
  00032	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  0003d	48 83 f8 08	 cmp	 rax, 8
  00041	74 0c		 je	 SHORT $LN5@sr_read_hd

; 660  :     {
; 661  :         sr_read_error_();

  00043	e8 00 00 00 00	 call	 sr_read_error_

; 662  :         return -1;

  00048	b8 ff ff ff ff	 mov	 eax, -1
  0004d	eb 7c		 jmp	 SHORT $LN1@sr_read_hd
$LN5@sr_read_hd:

; 663  :     }
; 664  : 
; 665  :     *key = fetch_fw (buf);

  0004f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00054	e8 00 00 00 00	 call	 fetch_fw_noswap
  00059	8b c8		 mov	 ecx, eax
  0005b	e8 00 00 00 00	 call	 _byteswap_ulong
  00060	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00065	89 01		 mov	 DWORD PTR [rcx], eax

; 666  :     *len = fetch_fw (buf+4);

  00067	48 8d 44 24 24	 lea	 rax, QWORD PTR buf$[rsp+4]
  0006c	48 8b c8	 mov	 rcx, rax
  0006f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00074	8b c8		 mov	 ecx, eax
  00076	e8 00 00 00 00	 call	 _byteswap_ulong
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  00080	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@sr_read_hd:

; 667  : 
; 668  :     TRACE("SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x\n", *key, *len);

  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  00087	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  0008f	8b 10		 mov	 edx, DWORD PTR [rax]
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178773
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000a4	85 c0		 test	 eax, eax
  000a6	74 1b		 je	 SHORT $LN6@sr_read_hd
  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  000ad	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000b0	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  000b5	8b 10		 mov	 edx, DWORD PTR [rax]
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178775
  000be	e8 00 00 00 00	 call	 DebuggerTrace
$LN6@sr_read_hd:
  000c3	33 c0		 xor	 eax, eax
  000c5	85 c0		 test	 eax, eax
  000c7	75 b9		 jne	 SHORT $LN4@sr_read_hd

; 669  : 
; 670  :     return 0;

  000c9	33 c0		 xor	 eax, eax
$LN1@sr_read_hd:

; 671  : }

  000cb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000d0	48 33 cc	 xor	 rcx, rsp
  000d3	e8 00 00 00 00	 call	 __security_check_cookie
  000d8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dc	c3		 ret	 0
sr_read_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
len$ = 32
file$ = 64
key$ = 72
str$ = 80
sr_write_string PROC

; 566  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 567  : size_t len = strlen(str) + 1;

  00012	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  00017	e8 00 00 00 00	 call	 strlen
  0001c	48 ff c0	 inc	 rax
  0001f	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax
$LN4@sr_write_s:

; 568  : 
; 569  :     TRACE("SR: sr_write_string: key=0x%8.8x\n", key);

  00024	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178702
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003b	85 c0		 test	 eax, eax
  0003d	74 10		 je	 SHORT $LN5@sr_write_s
  0003f	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178704
  0004a	e8 00 00 00 00	 call	 DebuggerTrace
$LN5@sr_write_s:
  0004f	33 c0		 xor	 eax, eax
  00051	85 c0		 test	 eax, eax
  00053	75 cf		 jne	 SHORT $LN4@sr_write_s

; 570  : 
; 571  :     if (len > SR_MAX_STRING_LENGTH)

  00055	48 81 7c 24 20
	00 10 00 00	 cmp	 QWORD PTR len$[rsp], 4096 ; 00001000H
  0005e	76 0c		 jbe	 SHORT $LN6@sr_write_s

; 572  :     {
; 573  :         sr_string_error_();

  00060	e8 00 00 00 00	 call	 sr_string_error_

; 574  :         return -1;

  00065	b8 ff ff ff ff	 mov	 eax, -1
  0006a	eb 4d		 jmp	 SHORT $LN1@sr_write_s
$LN6@sr_write_s:

; 575  :     }
; 576  : 
; 577  :     if (sr_write_hdr(file, key, (U32)len) != 0)

  0006c	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  00071	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  0007a	e8 00 00 00 00	 call	 sr_write_hdr
  0007f	85 c0		 test	 eax, eax
  00081	74 07		 je	 SHORT $LN7@sr_write_s

; 578  :         return -1;

  00083	b8 ff ff ff ff	 mov	 eax, -1
  00088	eb 2f		 jmp	 SHORT $LN1@sr_write_s
$LN7@sr_write_s:

; 579  : 
; 580  :     if ((size_t)SR_WRITE(str, 1, len, file) != len)

  0008a	4c 8b 4c 24 40	 mov	 r9, QWORD PTR file$[rsp]
  0008f	4c 8b 44 24 20	 mov	 r8, QWORD PTR len$[rsp]
  00094	ba 01 00 00 00	 mov	 edx, 1
  00099	48 8b 4c 24 50	 mov	 rcx, QWORD PTR str$[rsp]
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  000a4	48 3b 44 24 20	 cmp	 rax, QWORD PTR len$[rsp]
  000a9	74 0c		 je	 SHORT $LN8@sr_write_s

; 581  :     {
; 582  :         sr_write_error_();

  000ab	e8 00 00 00 00	 call	 sr_write_error_

; 583  :         return -1;

  000b0	b8 ff ff ff ff	 mov	 eax, -1
  000b5	eb 02		 jmp	 SHORT $LN1@sr_write_s
$LN8@sr_write_s:

; 584  :     }
; 585  :     return 0;

  000b7	33 c0		 xor	 eax, eax
$LN1@sr_write_s:

; 586  : }

  000b9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bd	c3		 ret	 0
sr_write_string ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv84 = 32
buf$ = 40
__$ArrayPad$ = 48
file$ = 80
key$ = 88
val$ = 96
len$ = 104
sr_write_value PROC

; 622  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_write_v:

; 623  : BYTE    buf[8];
; 624  : 
; 625  :     TRACE("SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16.16"PRIx64"\n", key, len, val);

  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR val$[rsp]
  0002b	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  00030	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178751
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00047	85 c0		 test	 eax, eax
  00049	74 1a		 je	 SHORT $LN7@sr_write_v
  0004b	4c 8b 4c 24 60	 mov	 r9, QWORD PTR val$[rsp]
  00050	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  00055	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178753
  00060	e8 00 00 00 00	 call	 DebuggerTrace
$LN7@sr_write_v:
  00065	33 c0		 xor	 eax, eax
  00067	85 c0		 test	 eax, eax
  00069	75 bb		 jne	 SHORT $LN4@sr_write_v

; 626  : 
; 627  :     if (len != 1 && len != 2 && len != 4 && len != 8)

  0006b	83 7c 24 68 01	 cmp	 DWORD PTR len$[rsp], 1
  00070	74 24		 je	 SHORT $LN8@sr_write_v
  00072	83 7c 24 68 02	 cmp	 DWORD PTR len$[rsp], 2
  00077	74 1d		 je	 SHORT $LN8@sr_write_v
  00079	83 7c 24 68 04	 cmp	 DWORD PTR len$[rsp], 4
  0007e	74 16		 je	 SHORT $LN8@sr_write_v
  00080	83 7c 24 68 08	 cmp	 DWORD PTR len$[rsp], 8
  00085	74 0f		 je	 SHORT $LN8@sr_write_v

; 628  :     {
; 629  :         sr_value_error_();

  00087	e8 00 00 00 00	 call	 sr_value_error_

; 630  :         return -1;

  0008c	b8 ff ff ff ff	 mov	 eax, -1
  00091	e9 d2 00 00 00	 jmp	 $LN1@sr_write_v
$LN8@sr_write_v:

; 631  :     }
; 632  : 
; 633  :     if (sr_write_hdr(file, key, len) != 0)

  00096	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  0009b	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  000a4	e8 00 00 00 00	 call	 sr_write_hdr
  000a9	85 c0		 test	 eax, eax
  000ab	74 0a		 je	 SHORT $LN9@sr_write_v

; 634  :         return -1;

  000ad	b8 ff ff ff ff	 mov	 eax, -1
  000b2	e9 b1 00 00 00	 jmp	 $LN1@sr_write_v
$LN9@sr_write_v:

; 635  : 
; 636  :     switch (len)

  000b7	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  000bb	89 44 24 20	 mov	 DWORD PTR tv84[rsp], eax
  000bf	83 7c 24 20 01	 cmp	 DWORD PTR tv84[rsp], 1
  000c4	74 17		 je	 SHORT $LN10@sr_write_v
  000c6	83 7c 24 20 02	 cmp	 DWORD PTR tv84[rsp], 2
  000cb	74 24		 je	 SHORT $LN11@sr_write_v
  000cd	83 7c 24 20 04	 cmp	 DWORD PTR tv84[rsp], 4
  000d2	74 36		 je	 SHORT $LN12@sr_write_v
  000d4	83 7c 24 20 08	 cmp	 DWORD PTR tv84[rsp], 8
  000d9	74 46		 je	 SHORT $LN13@sr_write_v
  000db	eb 5b		 jmp	 SHORT $LN5@sr_write_v
$LN10@sr_write_v:

; 637  :     {
; 638  :         case 1: buf[0]     =  (BYTE)val;  break;

  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	48 6b c0 00	 imul	 rax, rax, 0
  000e6	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR val$[rsp]
  000eb	88 4c 04 28	 mov	 BYTE PTR buf$[rsp+rax], cl
  000ef	eb 47		 jmp	 SHORT $LN5@sr_write_v
$LN11@sr_write_v:

; 639  :         case 2: store_hw (buf, (U16)val); break;

  000f1	0f b7 4c 24 60	 movzx	 ecx, WORD PTR val$[rsp]
  000f6	e8 00 00 00 00	 call	 _byteswap_ushort
  000fb	0f b7 d0	 movzx	 edx, ax
  000fe	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00103	e8 00 00 00 00	 call	 store_hw_noswap
  00108	eb 2e		 jmp	 SHORT $LN5@sr_write_v
$LN12@sr_write_v:

; 640  :         case 4: store_fw (buf, (U32)val); break;

  0010a	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  0010e	e8 00 00 00 00	 call	 _byteswap_ulong
  00113	8b d0		 mov	 edx, eax
  00115	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  0011a	e8 00 00 00 00	 call	 store_fw_noswap
  0011f	eb 17		 jmp	 SHORT $LN5@sr_write_v
$LN13@sr_write_v:

; 641  :         case 8: store_dw (buf, (U64)val); break;

  00121	48 8b 4c 24 60	 mov	 rcx, QWORD PTR val$[rsp]
  00126	e8 00 00 00 00	 call	 _byteswap_uint64
  0012b	48 8b d0	 mov	 rdx, rax
  0012e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00133	e8 00 00 00 00	 call	 store_dw_noswap
$LN5@sr_write_v:

; 642  :     }
; 643  : 
; 644  :     if ((U32)SR_WRITE(buf, 1, len, file) != len)

  00138	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  0013c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR file$[rsp]
  00141	44 8b c0	 mov	 r8d, eax
  00144	ba 01 00 00 00	 mov	 edx, 1
  00149	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  0014e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  00154	3b 44 24 68	 cmp	 eax, DWORD PTR len$[rsp]
  00158	74 0c		 je	 SHORT $LN14@sr_write_v

; 645  :     {
; 646  :         sr_write_error_();

  0015a	e8 00 00 00 00	 call	 sr_write_error_

; 647  :         return -1;

  0015f	b8 ff ff ff ff	 mov	 eax, -1
  00164	eb 02		 jmp	 SHORT $LN1@sr_write_v
$LN14@sr_write_v:

; 648  :     }
; 649  :     return 0;

  00166	33 c0		 xor	 eax, eax
$LN1@sr_write_v:

; 650  : }

  00168	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0016d	48 33 cc	 xor	 rcx, rsp
  00170	e8 00 00 00 00	 call	 __security_check_cookie
  00175	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00179	c3		 ret	 0
sr_write_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 40
file$ = 64
key$ = 72
len$ = 80
sr_write_hdr PROC

; 546  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_write_h:

; 547  : BYTE  buf[8];
; 548  : 
; 549  :     TRACE("SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x\n", key, len);

  00021	44 8b 44 24 50	 mov	 r8d, DWORD PTR len$[rsp]
  00026	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178685
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003d	85 c0		 test	 eax, eax
  0003f	74 15		 je	 SHORT $LN5@sr_write_h
  00041	44 8b 44 24 50	 mov	 r8d, DWORD PTR len$[rsp]
  00046	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178687
  00051	e8 00 00 00 00	 call	 DebuggerTrace
$LN5@sr_write_h:
  00056	33 c0		 xor	 eax, eax
  00058	85 c0		 test	 eax, eax
  0005a	75 c5		 jne	 SHORT $LN4@sr_write_h

; 550  : 
; 551  :     store_fw (buf, key);

  0005c	8b 4c 24 48	 mov	 ecx, DWORD PTR key$[rsp]
  00060	e8 00 00 00 00	 call	 _byteswap_ulong
  00065	8b d0		 mov	 edx, eax
  00067	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0006c	e8 00 00 00 00	 call	 store_fw_noswap

; 552  :     store_fw (buf+4, len);

  00071	8b 4c 24 50	 mov	 ecx, DWORD PTR len$[rsp]
  00075	e8 00 00 00 00	 call	 _byteswap_ulong
  0007a	48 8d 4c 24 24	 lea	 rcx, QWORD PTR buf$[rsp+4]
  0007f	8b d0		 mov	 edx, eax
  00081	e8 00 00 00 00	 call	 store_fw_noswap

; 553  : 
; 554  :     if (SR_WRITE(buf, 1, 8, file) != 8)

  00086	4c 8b 4c 24 40	 mov	 r9, QWORD PTR file$[rsp]
  0008b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00091	ba 01 00 00 00	 mov	 edx, 1
  00096	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  000a1	48 83 f8 08	 cmp	 rax, 8
  000a5	74 0c		 je	 SHORT $LN6@sr_write_h

; 555  :     {
; 556  :         sr_write_error_();

  000a7	e8 00 00 00 00	 call	 sr_write_error_

; 557  :         return -1;

  000ac	b8 ff ff ff ff	 mov	 eax, -1
  000b1	eb 02		 jmp	 SHORT $LN1@sr_write_h
$LN6@sr_write_h:

; 558  :     }
; 559  :     return 0;

  000b3	33 c0		 xor	 eax, eax
$LN1@sr_write_h:

; 560  : }

  000b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ba	48 33 cc	 xor	 rcx, rsp
  000bd	e8 00 00 00 00	 call	 __security_check_cookie
  000c2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c6	c3		 ret	 0
sr_write_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
tzoffset$ = 48
configure_tzoffset PROC

; 1201 : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1202 :     if(tzoffset < -2359 || tzoffset > 2359)

  00008	81 7c 24 30 c9
	f6 ff ff	 cmp	 DWORD PTR tzoffset$[rsp], -2359 ; fffffffffffff6c9H
  00010	7c 0a		 jl	 SHORT $LN3@configure_
  00012	81 7c 24 30 37
	09 00 00	 cmp	 DWORD PTR tzoffset$[rsp], 2359 ; 00000937H
  0001a	7e 07		 jle	 SHORT $LN2@configure_
$LN3@configure_:

; 1203 :         return -1;

  0001c	b8 ff ff ff ff	 mov	 eax, -1
  00021	eb 11		 jmp	 SHORT $LN1@configure_
$LN2@configure_:

; 1204 : 
; 1205 :     default_tzoffset = tzoffset;

  00023	8b 44 24 30	 mov	 eax, DWORD PTR tzoffset$[rsp]
  00027	89 05 00 00 00
	00		 mov	 DWORD PTR default_tzoffset, eax

; 1206 :     configure_time();

  0002d	e8 00 00 00 00	 call	 configure_time

; 1207 : 
; 1208 :     return 0;

  00032	33 c0		 xor	 eax, eax
$LN1@configure_:

; 1209 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
configure_tzoffset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
yroffset$ = 48
configure_yroffset PROC

; 1186 : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1187 :     if (yroffset < -142 || yroffset > 142)

  00008	81 7c 24 30 72
	ff ff ff	 cmp	 DWORD PTR yroffset$[rsp], -142 ; ffffffffffffff72H
  00010	7c 0a		 jl	 SHORT $LN3@configure_
  00012	81 7c 24 30 8e
	00 00 00	 cmp	 DWORD PTR yroffset$[rsp], 142 ; 0000008eH
  0001a	7e 07		 jle	 SHORT $LN2@configure_
$LN3@configure_:

; 1188 :         return -1;

  0001c	b8 ff ff ff ff	 mov	 eax, -1
  00021	eb 11		 jmp	 SHORT $LN1@configure_
$LN2@configure_:

; 1189 : 
; 1190 :     default_yroffset = yroffset;

  00023	8b 44 24 30	 mov	 eax, DWORD PTR yroffset$[rsp]
  00027	89 05 00 00 00
	00		 mov	 DWORD PTR default_yroffset, eax

; 1191 : 
; 1192 :     configure_time();

  0002d	e8 00 00 00 00	 call	 configure_time

; 1193 : 
; 1194 :     return 0;

  00032	33 c0		 xor	 eax, eax
$LN1@configure_:

; 1195 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
configure_yroffset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
epoch$ = 48
configure_epoch PROC

; 1172 : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1173 :     if (epoch != 1900 && epoch != 1960)

  00008	81 7c 24 30 6c
	07 00 00	 cmp	 DWORD PTR epoch$[rsp], 1900 ; 0000076cH
  00010	74 11		 je	 SHORT $LN2@configure_
  00012	81 7c 24 30 a8
	07 00 00	 cmp	 DWORD PTR epoch$[rsp], 1960 ; 000007a8H
  0001a	74 07		 je	 SHORT $LN2@configure_

; 1174 :         return -1;

  0001c	b8 ff ff ff ff	 mov	 eax, -1
  00021	eb 11		 jmp	 SHORT $LN1@configure_
$LN2@configure_:

; 1175 : 
; 1176 :     default_epoch = epoch;

  00023	8b 44 24 30	 mov	 eax, DWORD PTR epoch$[rsp]
  00027	89 05 00 00 00
	00		 mov	 DWORD PTR default_epoch, eax

; 1177 :     configure_time();

  0002d	e8 00 00 00 00	 call	 configure_time

; 1178 : 
; 1179 :     return 0;

  00032	33 c0		 xor	 eax, eax
$LN1@configure_:

; 1180 : }

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
configure_epoch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
rc$ = 32
tv82 = 36
tv89 = 40
result$ = 48
cputime$ = 56
__$ArrayPad$ = 72
regs$ = 96
thread_cputime_us PROC

; 900  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 901  :     U64              result;
; 902  :     int              rc = -1;

  00018	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 903  :     struct timespec  cputime;
; 904  : 
; 905  :     if (sysblk.cpuclockid[ regs->cpuad ])

  00020	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00025	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0002c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00033	83 bc 81 48 0a
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+2632], 0
  0003b	74 29		 je	 SHORT $LN2@thread_cpu

; 906  :     {
; 907  :         rc = clock_gettime( sysblk.cpuclockid[ regs->cpuad ], &cputime );

  0003d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00042	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00049	48 8d 54 24 38	 lea	 rdx, QWORD PTR cputime$[rsp]
  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00055	8b 8c 81 48 0a
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+2632]
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock_gettime
  00062	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
$LN2@thread_cpu:

; 908  :     }
; 909  :     result = (likely(rc == 0)) ? timespec2usecs( &cputime )

  00066	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0006b	75 0a		 jne	 SHORT $LN6@thread_cpu
  0006d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00075	eb 08		 jmp	 SHORT $LN7@thread_cpu
$LN6@thread_cpu:
  00077	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN7@thread_cpu:
  0007f	83 7c 24 24 00	 cmp	 DWORD PTR tv82[rsp], 0
  00084	74 11		 je	 SHORT $LN8@thread_cpu
  00086	48 8d 4c 24 38	 lea	 rcx, QWORD PTR cputime$[rsp]
  0008b	e8 00 00 00 00	 call	 timespec2usecs
  00090	48 89 44 24 28	 mov	 QWORD PTR tv89[rsp], rax
  00095	eb 12		 jmp	 SHORT $LN9@thread_cpu
$LN8@thread_cpu:
  00097	e8 00 00 00 00	 call	 host_tod
  0009c	48 8b c8	 mov	 rcx, rax
  0009f	e8 00 00 00 00	 call	 ETOD_high64_to_usecs
  000a4	48 89 44 24 28	 mov	 QWORD PTR tv89[rsp], rax
$LN9@thread_cpu:
  000a9	48 8b 44 24 28	 mov	 rax, QWORD PTR tv89[rsp]
  000ae	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 910  :                                : ETOD_high64_to_usecs( host_tod() );
; 911  :     return (result);

  000b3	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]

; 912  : }

  000b8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000bd	48 33 cc	 xor	 rcx, rsp
  000c0	e8 00 00 00 00	 call	 __security_check_cookie
  000c5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000c9	c3		 ret	 0
thread_cputime_us ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
itimer$ = 32
pending$ = 36
regs$ = 64
chk_int_timer PROC

; 1315 : {

$LN16:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1316 : S32 itimer;
; 1317 : int pending = 0;

  00009	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR pending$[rsp], 0

; 1318 : 
; 1319 :     itimer = get_int_timer( regs );

  00011	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00016	e8 00 00 00 00	 call	 get_int_timer
  0001b	89 44 24 20	 mov	 DWORD PTR itimer$[rsp], eax

; 1320 :     if (itimer < 0 && regs->old_timer >= 0)

  0001f	83 7c 24 20 00	 cmp	 DWORD PTR itimer$[rsp], 0
  00024	7d 67		 jge	 SHORT $LN8@chk_int_ti
  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	83 b8 70 07 00
	00 00		 cmp	 DWORD PTR [rax+1904], 0
  00032	7c 59		 jl	 SHORT $LN8@chk_int_ti
$LN4@chk_int_ti:

; 1321 :     {
; 1322 :         ON_IC_ITIMER( regs );

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00039	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0003c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00041	85 c0		 test	 eax, eax
  00043	74 17		 je	 SHORT $LN9@chk_int_ti
  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004d	0d 80 00 00 80	 or	 eax, -2147483520	; 80000080H
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0005a	eb 14		 jmp	 SHORT $LN10@chk_int_ti
$LN9@chk_int_ti:
  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00061	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00064	0f ba e8 07	 bts	 eax, 7
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN10@chk_int_ti:
  00070	33 c0		 xor	 eax, eax
  00072	85 c0		 test	 eax, eax
  00074	75 be		 jne	 SHORT $LN4@chk_int_ti

; 1323 :         pending = 1;

  00076	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR pending$[rsp], 1

; 1324 :         regs->old_timer=itimer;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00083	8b 4c 24 20	 mov	 ecx, DWORD PTR itimer$[rsp]
  00087	89 88 70 07 00
	00		 mov	 DWORD PTR [rax+1904], ecx
$LN8@chk_int_ti:

; 1325 :     }
; 1326 : #if defined( _FEATURE_ECPSVM )
; 1327 : 
; 1328 :     if (regs->ecps_vtmrpt)

  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00092	48 83 b8 78 07
	00 00 00	 cmp	 QWORD PTR [rax+1912], 0
  0009a	74 70		 je	 SHORT $LN11@chk_int_ti

; 1329 :     {
; 1330 :         itimer = get_ecps_vtimer( regs );

  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a1	e8 00 00 00 00	 call	 get_ecps_vtimer
  000a6	89 44 24 20	 mov	 DWORD PTR itimer$[rsp], eax

; 1331 : 
; 1332 :         if (itimer < 0 && regs->ecps_oldtmr >= 0)

  000aa	83 7c 24 20 00	 cmp	 DWORD PTR itimer$[rsp], 0
  000af	7d 5b		 jge	 SHORT $LN12@chk_int_ti
  000b1	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	83 b8 74 07 00
	00 00		 cmp	 DWORD PTR [rax+1908], 0
  000bd	7c 4d		 jl	 SHORT $LN12@chk_int_ti
$LN7@chk_int_ti:

; 1333 :         {
; 1334 :             ON_IC_ECPSVTIMER( regs );

  000bf	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000c7	25 00 01 00 00	 and	 eax, 256		; 00000100H
  000cc	85 c0		 test	 eax, eax
  000ce	74 17		 je	 SHORT $LN13@chk_int_ti
  000d0	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000d8	0d 00 01 00 80	 or	 eax, -2147483392	; 80000100H
  000dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000e2	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  000e5	eb 14		 jmp	 SHORT $LN14@chk_int_ti
$LN13@chk_int_ti:
  000e7	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000ec	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000ef	0f ba e8 08	 bts	 eax, 8
  000f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN14@chk_int_ti:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 be		 jne	 SHORT $LN7@chk_int_ti

; 1335 :             pending += 2;

  00101	8b 44 24 24	 mov	 eax, DWORD PTR pending$[rsp]
  00105	83 c0 02	 add	 eax, 2
  00108	89 44 24 24	 mov	 DWORD PTR pending$[rsp], eax
$LN12@chk_int_ti:
$LN11@chk_int_ti:

; 1336 :         }
; 1337 :     }
; 1338 : #endif
; 1339 : 
; 1340 :     return pending;

  0010c	8b 44 24 24	 mov	 eax, DWORD PTR pending$[rsp]

; 1341 : }

  00110	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00114	c3		 ret	 0
chk_int_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
tv65 = 32
regs$ = 64
itimer$ = 72
set_int_timer PROC

; 1307 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1308 :     regs->int_timer = (U64)(hw_clock() + ITIMER_TO_TOD(itimer));

  0000d	e8 00 00 00 00	 call	 hw_clock
  00012	48 89 44 24 20	 mov	 QWORD PTR tv65[rsp], rax
  00017	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR itimer$[rsp]
  0001c	48 69 c9 71 02
	00 00		 imul	 rcx, rcx, 625		; 00000271H
  00023	48 8b c1	 mov	 rax, rcx
  00026	48 99		 cdq
  00028	b9 03 00 00 00	 mov	 ecx, 3
  0002d	48 f7 f9	 idiv	 rcx
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv65[rsp]
  00035	48 03 c8	 add	 rcx, rax
  00038	48 8b c1	 mov	 rax, rcx
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00040	48 89 81 60 07
	00 00		 mov	 QWORD PTR [rcx+1888], rax

; 1309 :     regs->old_timer = itimer;

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004c	8b 4c 24 48	 mov	 ecx, DWORD PTR itimer$[rsp]
  00050	89 88 70 07 00
	00		 mov	 DWORD PTR [rax+1904], ecx

; 1310 : }

  00056	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005a	c3		 ret	 0
set_int_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
new_epoch_us$ = 32
tv76 = 40
tv86 = 48
regs$ = 80
timer$ = 88
set_cpu_timer PROC

; 917  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 918  :     U64 new_epoch_us = (sysblk.lparmode && !WAITSTATE( &regs->psw )) ?

  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00015	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [rax+236]
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 21		 je	 SHORT $LN4@set_cpu_ti
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00027	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0002b	83 e0 02	 and	 eax, 2
  0002e	85 c0		 test	 eax, eax
  00030	75 11		 jne	 SHORT $LN4@set_cpu_ti
  00032	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	e8 00 00 00 00	 call	 thread_cputime_us
  0003c	48 89 44 24 28	 mov	 QWORD PTR tv76[rsp], rax
  00041	eb 12		 jmp	 SHORT $LN5@set_cpu_ti
$LN4@set_cpu_ti:
  00043	e8 00 00 00 00	 call	 host_tod
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 ETOD_high64_to_usecs
  00050	48 89 44 24 28	 mov	 QWORD PTR tv76[rsp], rax
$LN5@set_cpu_ti:
  00055	48 8b 44 24 28	 mov	 rax, QWORD PTR tv76[rsp]
  0005a	48 89 44 24 20	 mov	 QWORD PTR new_epoch_us$[rsp], rax

; 919  :         thread_cputime_us( regs ) : (U64) ETOD_high64_to_usecs( host_tod() );
; 920  : 
; 921  :     if (regs->bcputime <= new_epoch_us)

  0005f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00064	48 8b 4c 24 20	 mov	 rcx, QWORD PTR new_epoch_us$[rsp]
  00069	48 39 88 88 07
	00 00		 cmp	 QWORD PTR [rax+1928], rcx
  00070	77 40		 ja	 SHORT $LN2@set_cpu_ti

; 922  :     {
; 923  :         /* Update real CPU time used and base CPU time epoch */
; 924  :         regs->rcputime += new_epoch_us - regs->bcputime;

  00072	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00077	48 8b 80 88 07
	00 00		 mov	 rax, QWORD PTR [rax+1928]
  0007e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR new_epoch_us$[rsp]
  00083	48 2b c8	 sub	 rcx, rax
  00086	48 8b c1	 mov	 rax, rcx
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	48 03 81 80 07
	00 00		 add	 rax, QWORD PTR [rcx+1920]
  00095	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	48 89 81 80 07
	00 00		 mov	 QWORD PTR [rcx+1920], rax

; 925  :         regs->bcputime  = new_epoch_us;

  000a1	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR new_epoch_us$[rsp]
  000ab	48 89 88 88 07
	00 00		 mov	 QWORD PTR [rax+1928], rcx
$LN2@set_cpu_ti:

; 926  :     }
; 927  : 
; 928  :     regs->cpu_timer = TOD_high64_to_ETOD_high56( timer ) + hw_clock();

  000b2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR timer$[rsp]
  000b7	e8 00 00 00 00	 call	 TOD_high64_to_ETOD_high56
  000bc	48 89 44 24 30	 mov	 QWORD PTR tv86[rsp], rax
  000c1	e8 00 00 00 00	 call	 hw_clock
  000c6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv86[rsp]
  000cb	48 03 c8	 add	 rcx, rax
  000ce	48 8b c1	 mov	 rax, rcx
  000d1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000d6	48 89 81 50 07
	00 00		 mov	 QWORD PTR [rcx+1872], rax

; 929  : }

  000dd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e1	c3		 ret	 0
set_cpu_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
timer$ = 32
regs$ = 64
get_cpu_timer PROC

; 934  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 935  : S64 timer;
; 936  :     timer = (S64)ETOD_high64_to_TOD_high56( regs->cpu_timer - hw_clock() );

  00009	e8 00 00 00 00	 call	 hw_clock
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00013	48 8b 89 50 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1872]
  0001a	48 2b c8	 sub	 rcx, rax
  0001d	48 8b c1	 mov	 rax, rcx
  00020	48 8b c8	 mov	 rcx, rax
  00023	e8 00 00 00 00	 call	 ETOD_high64_to_TOD_high56
  00028	48 89 44 24 20	 mov	 QWORD PTR timer$[rsp], rax

; 937  :     return timer;

  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR timer$[rsp]

; 938  : }

  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
get_cpu_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
ETOD$ = 32
__$ArrayPad$ = 48
regs$ = 80
get_tod_clock PROC

; 1058 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1059 :     ETOD    ETOD;
; 1060 :     return etod_clock( regs, &ETOD, ETOD_fast );

  00018	41 b8 01 00 00
	00		 mov	 r8d, 1
  0001e	48 8d 54 24 20	 lea	 rdx, QWORD PTR ETOD$[rsp]
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00028	e8 00 00 00 00	 call	 etod_clock

; 1061 : }

  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00032	48 33 cc	 xor	 rcx, rsp
  00035	e8 00 00 00 00	 call	 __security_check_cookie
  0003a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0003e	c3		 ret	 0
get_tod_clock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
swapped$ = 32
low$ = 40
high$ = 48
tv80 = 56
tv155 = 60
tv169 = 64
lmask$1 = 72
amask$2 = 80
cpuad$3 = 88
regs$ = 112
ETOD$ = 120
format$ = 128
etod_clock PROC

; 944  : {

$LN45:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 945  :     /* STORE CLOCK and STORE CLOCK EXTENDED values must be in ascending
; 946  :      * order for comparison. Consequently, swap delays for a subsequent
; 947  :      * STORE CLOCK, STORE CLOCK EXTENDED, or TRACE instruction may be
; 948  :      * introduced when a STORE CLOCK value is advanced due to the use of
; 949  :      * the CPU address in bits 66-71.
; 950  :      *
; 951  :      * If the regs pointer is null, then the request is a raw request,
; 952  :      * and the format operand should specify ETOD_raw or ETOD_fast. For
; 953  :      * raw and fast requests, the CPU address is not inserted into the
; 954  :      * returned value.
; 955  :      *
; 956  :      * A spin loop is used for the introduction of the delay, moderated
; 957  :      * by obtaining and releasing of the TOD lock. This permits raw and
; 958  :      * fast clock requests to complete without additional delay.
; 959  :      */
; 960  : 
; 961  :     U64 high;
; 962  :     U64 low;
; 963  :     U8  swapped = 0;

  00013	c6 44 24 20 00	 mov	 BYTE PTR swapped$[rsp], 0
$LN4@etod_clock:

; 964  : 
; 965  :     do
; 966  :     {
; 967  :         obtain_lock(&sysblk.todlock);

  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001f	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202141
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 968  : 
; 969  :         high = hw_clock_locked();

  00035	e8 00 00 00 00	 call	 hw_clock_locked
  0003a	48 89 44 24 30	 mov	 QWORD PTR high$[rsp], rax

; 970  :         low  = hw_tod.low;

  0003f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hw_tod
  00046	48 89 44 24 28	 mov	 QWORD PTR low$[rsp], rax

; 971  : 
; 972  :         /* If we are in the old episode, and the new episode has arrived
; 973  :          * then we must take action to start the new episode.
; 974  :          */
; 975  :         if (episode_current == &episode_old)

  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_old
  00052	48 39 05 00 00
	00 00		 cmp	 QWORD PTR episode_current, rax
  00059	75 05		 jne	 SHORT $LN13@etod_clock

; 976  :             start_new_episode();

  0005b	e8 00 00 00 00	 call	 start_new_episode
$LN13@etod_clock:

; 977  : 
; 978  :         /* Set the clock to the new updated value with offset applied */
; 979  :         high += episode_current->base_offset;

  00060	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR episode_current
  00067	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR high$[rsp]
  00070	48 03 c8	 add	 rcx, rax
  00073	48 8b c1	 mov	 rax, rcx
  00076	48 89 44 24 30	 mov	 QWORD PTR high$[rsp], rax

; 980  : 
; 981  :         /* Place CPU stamp into clock value for Standard and Extended
; 982  :          * formats (raw or fast requests fall through)
; 983  :          */
; 984  :         if (regs && format >= ETOD_standard)

  0007b	48 83 7c 24 70
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00081	0f 84 a3 01 00
	00		 je	 $LN14@etod_clock
  00087	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR format$[rsp], 2
  0008f	0f 8c 95 01 00
	00		 jl	 $LN14@etod_clock

; 985  :         {
; 986  :             register U64    cpuad;
; 987  :             register U64    amask;
; 988  :             register U64    lmask;
; 989  : 
; 990  :             /* Set CPU address masks */
; 991  :             if (sysblk.maxcpu <= 64)

  00095	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009c	83 b8 00 01 00
	00 40		 cmp	 DWORD PTR [rax+256], 64	; 00000040H
  000a3	7f 14		 jg	 SHORT $LN15@etod_clock

; 992  :                 amask = 0x3F, lmask = 0xFFFFFFFFFFC00000ULL;

  000a5	48 c7 44 24 50
	3f 00 00 00	 mov	 QWORD PTR amask$2[rsp], 63 ; 0000003fH
  000ae	48 c7 44 24 48
	00 00 c0 ff	 mov	 QWORD PTR lmask$1[rsp], -4194304 ; ffffffffffc00000H
  000b7	eb 39		 jmp	 SHORT $LN16@etod_clock
$LN15@etod_clock:

; 993  :             else if (sysblk.maxcpu <= 128)

  000b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c0	81 b8 00 01 00
	00 80 00 00 00	 cmp	 DWORD PTR [rax+256], 128 ; 00000080H
  000ca	7f 14		 jg	 SHORT $LN17@etod_clock

; 994  :                 amask = 0x7F, lmask = 0xFFFFFFFFFF800000ULL;

  000cc	48 c7 44 24 50
	7f 00 00 00	 mov	 QWORD PTR amask$2[rsp], 127 ; 0000007fH
  000d5	48 c7 44 24 48
	00 00 80 ff	 mov	 QWORD PTR lmask$1[rsp], -8388608 ; ffffffffff800000H
  000de	eb 12		 jmp	 SHORT $LN18@etod_clock
$LN17@etod_clock:

; 995  :             else /* sysblk.maxcpu <= 256) */
; 996  :                 amask = 0xFF, lmask = 0xFFFFFFFFFF000000ULL;

  000e0	48 c7 44 24 50
	ff 00 00 00	 mov	 QWORD PTR amask$2[rsp], 255 ; 000000ffH
  000e9	48 c7 44 24 48
	00 00 00 ff	 mov	 QWORD PTR lmask$1[rsp], -16777216 ; ffffffffff000000H
$LN18@etod_clock:
$LN16@etod_clock:

; 997  : 
; 998  :             /* Clean CPU address */
; 999  :             cpuad = (U64)regs->cpuad & amask;

  000f2	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000fe	48 23 44 24 50	 and	 rax, QWORD PTR amask$2[rsp]
  00103	48 89 44 24 58	 mov	 QWORD PTR cpuad$3[rsp], rax

; 1000 : 
; 1001 :             switch (format)

  00108	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR format$[rsp]
  0010f	89 44 24 38	 mov	 DWORD PTR tv80[rsp], eax
  00113	83 7c 24 38 02	 cmp	 DWORD PTR tv80[rsp], 2
  00118	74 0c		 je	 SHORT $LN19@etod_clock
  0011a	83 7c 24 38 03	 cmp	 DWORD PTR tv80[rsp], 3
  0011f	74 3c		 je	 SHORT $LN20@etod_clock
  00121	e9 9b 00 00 00	 jmp	 $LN22@etod_clock
$LN19@etod_clock:

; 1002 :             {
; 1003 :                 /* Standard TOD format */
; 1004 :                 case ETOD_standard:
; 1005 :                     low &= lmask << 40;

  00126	48 8b 44 24 48	 mov	 rax, QWORD PTR lmask$1[rsp]
  0012b	48 c1 e0 28	 shl	 rax, 40			; 00000028H
  0012f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR low$[rsp]
  00134	48 23 c8	 and	 rcx, rax
  00137	48 8b c1	 mov	 rax, rcx
  0013a	48 89 44 24 28	 mov	 QWORD PTR low$[rsp], rax

; 1006 :                     low |= cpuad << 56;

  0013f	48 8b 44 24 58	 mov	 rax, QWORD PTR cpuad$3[rsp]
  00144	48 c1 e0 38	 shl	 rax, 56			; 00000038H
  00148	48 8b 4c 24 28	 mov	 rcx, QWORD PTR low$[rsp]
  0014d	48 0b c8	 or	 rcx, rax
  00150	48 8b c1	 mov	 rax, rcx
  00153	48 89 44 24 28	 mov	 QWORD PTR low$[rsp], rax

; 1007 :                     break;

  00158	e9 cd 00 00 00	 jmp	 $LN5@etod_clock
$LN20@etod_clock:

; 1008 : 
; 1009 :                 /* Extended TOD format */
; 1010 :                 case ETOD_extended:
; 1011 :                     low &= lmask;

  0015d	48 8b 44 24 48	 mov	 rax, QWORD PTR lmask$1[rsp]
  00162	48 8b 4c 24 28	 mov	 rcx, QWORD PTR low$[rsp]
  00167	48 23 c8	 and	 rcx, rax
  0016a	48 8b c1	 mov	 rax, rcx
  0016d	48 89 44 24 28	 mov	 QWORD PTR low$[rsp], rax

; 1012 :                     low |= cpuad << 16;

  00172	48 8b 44 24 58	 mov	 rax, QWORD PTR cpuad$3[rsp]
  00177	48 c1 e0 10	 shl	 rax, 16
  0017b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR low$[rsp]
  00180	48 0b c8	 or	 rcx, rax
  00183	48 8b c1	 mov	 rax, rcx
  00186	48 89 44 24 28	 mov	 QWORD PTR low$[rsp], rax

; 1013 :                     if (low == 0)

  0018b	48 83 7c 24 28
	00		 cmp	 QWORD PTR low$[rsp], 0
  00191	75 11		 jne	 SHORT $LN21@etod_clock

; 1014 :                         low = (amask + 1) << 16;

  00193	48 8b 44 24 50	 mov	 rax, QWORD PTR amask$2[rsp]
  00198	48 ff c0	 inc	 rax
  0019b	48 c1 e0 10	 shl	 rax, 16
  0019f	48 89 44 24 28	 mov	 QWORD PTR low$[rsp], rax
$LN21@etod_clock:

; 1015 :                     low |= regs->todpr;

  001a4	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  001a9	8b 80 58 07 00
	00		 mov	 eax, DWORD PTR [rax+1880]
  001af	48 8b 4c 24 28	 mov	 rcx, QWORD PTR low$[rsp]
  001b4	48 0b c8	 or	 rcx, rax
  001b7	48 8b c1	 mov	 rax, rcx
  001ba	48 89 44 24 28	 mov	 QWORD PTR low$[rsp], rax

; 1016 :                     break;

  001bf	eb 69		 jmp	 SHORT $LN5@etod_clock
$LN22@etod_clock:
$LN9@etod_clock:

; 1017 :                 default:
; 1018 :                     ASSERT(0); /* unexpected */

  001c1	33 c0		 xor	 eax, eax
  001c3	83 f8 01	 cmp	 eax, 1
  001c6	74 5c		 je	 SHORT $LN23@etod_clock
$LN12@etod_clock:
  001c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG202153
  001cf	41 b8 fa 03 00
	00		 mov	 r8d, 1018		; 000003faH
  001d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202154
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG202155
  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001ef	85 c0		 test	 eax, eax
  001f1	74 20		 je	 SHORT $LN24@etod_clock
  001f3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG202157
  001fa	41 b8 fa 03 00
	00		 mov	 r8d, 1018		; 000003faH
  00200	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202158
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG202159
  0020e	e8 00 00 00 00	 call	 DebuggerTrace
$LN24@etod_clock:
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	75 af		 jne	 SHORT $LN12@etod_clock
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0021f	85 c0		 test	 eax, eax
  00221	74 01		 je	 SHORT $LN25@etod_clock
  00223	cc		 int	 3
$LN25@etod_clock:
$LN23@etod_clock:
  00224	33 c0		 xor	 eax, eax
  00226	85 c0		 test	 eax, eax
  00228	75 97		 jne	 SHORT $LN9@etod_clock
$LN5@etod_clock:
$LN14@etod_clock:

; 1019 :                     break;
; 1020 :             }
; 1021 :         }
; 1022 : 
; 1023 :         if (/* New clock value > Old clock value   */
; 1024 :             high > tod_value.high       ||
; 1025 :             (high == tod_value.high &&
; 1026 :             low > tod_value.low)        ||

  0022a	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR tod_value+8
  00231	48 39 44 24 30	 cmp	 QWORD PTR high$[rsp], rax
  00236	0f 87 8e 00 00
	00		 ja	 $LN28@etod_clock
  0023c	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR tod_value+8
  00243	48 39 44 24 30	 cmp	 QWORD PTR high$[rsp], rax
  00248	75 0e		 jne	 SHORT $LN29@etod_clock
  0024a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR tod_value
  00251	48 39 44 24 28	 cmp	 QWORD PTR low$[rsp], rax
  00256	77 72		 ja	 SHORT $LN28@etod_clock
$LN29@etod_clock:
  00258	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00262	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR tod_value+8
  00269	48 23 c8	 and	 rcx, rax
  0026c	48 8b c1	 mov	 rax, rcx
  0026f	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  00279	48 3b c1	 cmp	 rax, rcx
  0027c	75 24		 jne	 SHORT $LN33@etod_clock
  0027e	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00288	48 8b 4c 24 30	 mov	 rcx, QWORD PTR high$[rsp]
  0028d	48 23 c8	 and	 rcx, rax
  00290	48 8b c1	 mov	 rax, rcx
  00293	48 85 c0	 test	 rax, rax
  00296	75 0a		 jne	 SHORT $LN33@etod_clock
  00298	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  002a0	eb 08		 jmp	 SHORT $LN36@etod_clock
$LN33@etod_clock:
  002a2	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN36@etod_clock:
  002aa	83 7c 24 3c 00	 cmp	 DWORD PTR tv155[rsp], 0
  002af	74 0a		 je	 SHORT $LN43@etod_clock
  002b1	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv169[rsp], 1
  002b9	eb 08		 jmp	 SHORT $LN44@etod_clock
$LN43@etod_clock:
  002bb	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
$LN44@etod_clock:
  002c3	83 7c 24 40 00	 cmp	 DWORD PTR tv169[rsp], 0
  002c8	74 1f		 je	 SHORT $LN26@etod_clock
$LN28@etod_clock:

; 1027 :             /* or Clock Wrap                       */
; 1028 :             unlikely(unlikely((tod_value.high & 0x8000000000000000ULL) == 0x8000000000000000ULL &&
; 1029 :                               (          high & 0x8000000000000000ULL) == 0)))
; 1030 :         {
; 1031 :             tod_value.high = high;

  002ca	48 8b 44 24 30	 mov	 rax, QWORD PTR high$[rsp]
  002cf	48 89 05 08 00
	00 00		 mov	 QWORD PTR tod_value+8, rax

; 1032 :             tod_value.low  = low;

  002d6	48 8b 44 24 28	 mov	 rax, QWORD PTR low$[rsp]
  002db	48 89 05 00 00
	00 00		 mov	 QWORD PTR tod_value, rax

; 1033 :             swapped = 1;

  002e2	c6 44 24 20 01	 mov	 BYTE PTR swapped$[rsp], 1

; 1034 :         }

  002e7	eb 27		 jmp	 SHORT $LN27@etod_clock
$LN26@etod_clock:

; 1035 :         else if (format <= ETOD_fast)

  002e9	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR format$[rsp], 1
  002f1	7f 1d		 jg	 SHORT $LN30@etod_clock

; 1036 :         {
; 1037 :             high = tod_value.high;

  002f3	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR tod_value+8
  002fa	48 89 44 24 30	 mov	 QWORD PTR high$[rsp], rax

; 1038 :             low  = tod_value.low;

  002ff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR tod_value
  00306	48 89 44 24 28	 mov	 QWORD PTR low$[rsp], rax

; 1039 :             swapped = 1;

  0030b	c6 44 24 20 01	 mov	 BYTE PTR swapped$[rsp], 1
$LN30@etod_clock:
$LN27@etod_clock:

; 1040 :         }
; 1041 : 
; 1042 :         if (swapped)

  00310	0f b6 44 24 20	 movzx	 eax, BYTE PTR swapped$[rsp]
  00315	85 c0		 test	 eax, eax
  00317	74 37		 je	 SHORT $LN31@etod_clock

; 1043 :         {
; 1044 :             ETOD->high = high += regs->tod_epoch;

  00319	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0031e	48 8b 80 40 07
	00 00		 mov	 rax, QWORD PTR [rax+1856]
  00325	48 8b 4c 24 30	 mov	 rcx, QWORD PTR high$[rsp]
  0032a	48 03 c8	 add	 rcx, rax
  0032d	48 8b c1	 mov	 rax, rcx
  00330	48 89 44 24 30	 mov	 QWORD PTR high$[rsp], rax
  00335	48 8b 44 24 78	 mov	 rax, QWORD PTR ETOD$[rsp]
  0033a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR high$[rsp]
  0033f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1045 :             ETOD->low  = low;

  00343	48 8b 44 24 78	 mov	 rax, QWORD PTR ETOD$[rsp]
  00348	48 8b 4c 24 28	 mov	 rcx, QWORD PTR low$[rsp]
  0034d	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN31@etod_clock:

; 1046 :         }
; 1047 : 
; 1048 :         release_lock(&sysblk.todlock);

  00350	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00357	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  0035d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202167
  00364	48 8b c8	 mov	 rcx, rax
  00367	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1049 : 
; 1050 :     } while (!swapped);

  0036d	0f b6 44 24 20	 movzx	 eax, BYTE PTR swapped$[rsp]
  00372	85 c0		 test	 eax, eax
  00374	0f 84 9e fc ff
	ff		 je	 $LN4@etod_clock

; 1051 : 
; 1052 :     return ( high );

  0037a	48 8b 44 24 30	 mov	 rax, QWORD PTR high$[rsp]

; 1053 : }

  0037f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00383	c3		 ret	 0
etod_clock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
vtimer$ = 32
itimer$ = 36
regs$ = 64
s370_store_int_timer_locked PROC

; 469  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 470  :     S32 itimer;
; 471  :     S32 vtimer=0;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR vtimer$[rsp], 0

; 472  : 
; 473  :     itimer = get_int_timer( regs );

  00011	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00016	e8 00 00 00 00	 call	 get_int_timer
  0001b	89 44 24 24	 mov	 DWORD PTR itimer$[rsp], eax

; 474  :     STORE_FW( regs->psa->inttimer, itimer );

  0001f	8b 4c 24 24	 mov	 ecx, DWORD PTR itimer$[rsp]
  00023	e8 00 00 00 00	 call	 _byteswap_ulong
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0002d	48 8b 89 60 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2144]
  00034	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00038	8b d0		 mov	 edx, eax
  0003a	e8 00 00 00 00	 call	 store_fw_noswap

; 475  : 
; 476  : #if defined( FEATURE_ECPSVM )
; 477  : 
; 478  :     if (regs->ecps_vtmrpt)

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00044	48 83 b8 78 07
	00 00 00	 cmp	 QWORD PTR [rax+1912], 0
  0004c	74 2a		 je	 SHORT $LN2@s370_store

; 479  :     {
; 480  :         vtimer = get_ecps_vtimer( regs );

  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	e8 00 00 00 00	 call	 get_ecps_vtimer
  00058	89 44 24 20	 mov	 DWORD PTR vtimer$[rsp], eax

; 481  :         STORE_FW( regs->ecps_vtmrpt, vtimer );

  0005c	8b 4c 24 20	 mov	 ecx, DWORD PTR vtimer$[rsp]
  00060	e8 00 00 00 00	 call	 _byteswap_ulong
  00065	8b d0		 mov	 edx, eax
  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	48 8b 88 78 07
	00 00		 mov	 rcx, QWORD PTR [rax+1912]
  00073	e8 00 00 00 00	 call	 store_fw_noswap
$LN2@s370_store:

; 482  :     }
; 483  : #endif
; 484  : 
; 485  :     chk_int_timer( regs );

  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0007d	e8 00 00 00 00	 call	 chk_int_timer

; 486  : 
; 487  : #if defined( FEATURE_ECPSVM )
; 488  : 
; 489  :     if (regs->ecps_vtmrpt)

  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00087	48 83 b8 78 07
	00 00 00	 cmp	 QWORD PTR [rax+1912], 0
  0008f	74 0f		 je	 SHORT $LN3@s370_store

; 490  :         regs->ecps_oldtmr = vtimer;

  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00096	8b 4c 24 20	 mov	 ecx, DWORD PTR vtimer$[rsp]
  0009a	89 88 74 07 00
	00		 mov	 DWORD PTR [rax+1908], ecx
$LN3@s370_store:

; 491  : 
; 492  : #endif
; 493  : }

  000a0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a4	c3		 ret	 0
s370_store_int_timer_locked ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
tv67 = 32
tv73 = 40
regs$ = 64
s370_store_int_timer PROC

; 499  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 500  :     OBTAIN_INTLOCK( HOSTREGS ? regs : NULL );

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 83 b8 68 08
	00 00 00	 cmp	 QWORD PTR [rax+2152], 0
  00016	74 0c		 je	 SHORT $LN3@s370_store
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR tv67[rsp], rax
  00022	eb 09		 jmp	 SHORT $LN4@s370_store
$LN3@s370_store:
  00024	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR tv67[rsp], 0
$LN4@s370_store:
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179005
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv67[rsp]
  00039	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 501  :     {
; 502  :         ARCH_DEP( store_int_timer_locked )( regs );

  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00043	e8 00 00 00 00	 call	 s370_store_int_timer_locked

; 503  :     }
; 504  :     RELEASE_INTLOCK( HOSTREGS ? regs : NULL );

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004d	48 83 b8 68 08
	00 00 00	 cmp	 QWORD PTR [rax+2152], 0
  00055	74 0c		 je	 SHORT $LN5@s370_store
  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	48 89 44 24 28	 mov	 QWORD PTR tv73[rsp], rax
  00061	eb 09		 jmp	 SHORT $LN6@s370_store
$LN5@s370_store:
  00063	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv73[rsp], 0
$LN6@s370_store:
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179006
  00073	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv73[rsp]
  00078	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 505  : }

  0007d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00081	c3		 ret	 0
s370_store_int_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
itimer$ = 32
tv73 = 40
tv89 = 48
regs$ = 80
s370_fetch_int_timer PROC

; 511  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 512  :     S32 itimer;
; 513  : 
; 514  :     FETCH_FW( itimer, regs->psa->inttimer );

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0000e	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  00015	48 83 c0 50	 add	 rax, 80			; 00000050H
  00019	48 8b c8	 mov	 rcx, rax
  0001c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00021	8b c8		 mov	 ecx, eax
  00023	e8 00 00 00 00	 call	 _byteswap_ulong
  00028	89 44 24 20	 mov	 DWORD PTR itimer$[rsp], eax

; 515  : 
; 516  :     OBTAIN_INTLOCK( HOSTREGS ? regs : NULL );

  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00031	48 83 b8 68 08
	00 00 00	 cmp	 QWORD PTR [rax+2152], 0
  00039	74 0c		 je	 SHORT $LN4@s370_fetch
  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00040	48 89 44 24 28	 mov	 QWORD PTR tv73[rsp], rax
  00045	eb 09		 jmp	 SHORT $LN5@s370_fetch
$LN4@s370_fetch:
  00047	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv73[rsp], 0
$LN5@s370_fetch:
  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179013
  00057	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv73[rsp]
  0005c	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 517  :     {
; 518  :         set_int_timer( regs, itimer );

  00061	8b 54 24 20	 mov	 edx, DWORD PTR itimer$[rsp]
  00065	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	e8 00 00 00 00	 call	 set_int_timer

; 519  : 
; 520  : #if defined( FEATURE_ECPSVM )
; 521  :         if (regs->ecps_vtmrpt)

  0006f	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 83 b8 78 07
	00 00 00	 cmp	 QWORD PTR [rax+1912], 0
  0007c	74 2a		 je	 SHORT $LN2@s370_fetch

; 522  :         {
; 523  :             FETCH_FW( itimer, regs->ecps_vtmrpt );

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00083	48 8b 88 78 07
	00 00		 mov	 rcx, QWORD PTR [rax+1912]
  0008a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0008f	8b c8		 mov	 ecx, eax
  00091	e8 00 00 00 00	 call	 _byteswap_ulong
  00096	89 44 24 20	 mov	 DWORD PTR itimer$[rsp], eax

; 524  :             set_ecps_vtimer( regs, itimer );

  0009a	8b 54 24 20	 mov	 edx, DWORD PTR itimer$[rsp]
  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	e8 00 00 00 00	 call	 set_ecps_vtimer
$LN2@s370_fetch:

; 525  :         }
; 526  : #endif
; 527  :     }
; 528  :     RELEASE_INTLOCK( HOSTREGS ? regs : NULL );

  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	48 83 b8 68 08
	00 00 00	 cmp	 QWORD PTR [rax+2152], 0
  000b5	74 0c		 je	 SHORT $LN6@s370_fetch
  000b7	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	48 89 44 24 30	 mov	 QWORD PTR tv89[rsp], rax
  000c1	eb 09		 jmp	 SHORT $LN7@s370_fetch
$LN6@s370_fetch:
  000c3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv89[rsp], 0
$LN7@s370_fetch:
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179015
  000d3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv89[rsp]
  000d8	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 529  : }

  000dd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e1	c3		 ret	 0
s370_fetch_int_timer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
ETOD$ = 8
ts$ = 16
timespec2ETOD PROC

; 482  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 483  :     /* This conversion, assuming a nanosecond host clock resolution,
; 484  :      * yields a TOD clock resolution of 120-bits, 95-bits, or 64-bits,
; 485  :      * with a period of over 36,533 years.
; 486  :      *
; 487  :      *
; 488  :      * Original 128-bit code:
; 489  :      *
; 490  :      * register U128 result;
; 491  :      * result  = ((((U128)time.tvsec * ETOD_SEC) + ETOD_1970) << 64) +
; 492  :      *           (((U128)time.tv_nsec << 68) / 1000);
; 493  :      *
; 494  :      *
; 495  :      * In the 64-bit translation of the routine, bits 121-127 are not
; 496  :      * calculated as a third division is required.
; 497  :      *
; 498  :      * It is not necessary to normalize the clock_gettime return value,
; 499  :      * ensuring that the tv_nsec field is less than 1 second, as tv_nsec
; 500  :      * is a 32-bit field and 64-bit registers are in use.
; 501  :      *
; 502  :      */
; 503  : 
; 504  :     ETOD->high  = ts->tv_sec;       /* Convert seconds to microseconds,       */

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ETOD$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR ts$[rsp]
  00014	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00017	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 505  :     ETOD->high *= ETOD_SEC;         /* adjusted to bit-59; truncate above     */

  0001b	48 8b 44 24 08	 mov	 rax, QWORD PTR ETOD$[rsp]
  00020	48 69 40 08 00
	24 f4 00	 imul	 rax, QWORD PTR [rax+8], 16000000 ; 00f42400H
  00028	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ETOD$[rsp]
  0002d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 506  :                                     /* extended TOD clock resolution          */
; 507  :     ETOD->high += ETOD_1970;        /* Adjust for open source epoch of 1970   */

  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR ETOD$[rsp]
  00036	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003a	48 b9 00 00 ca
	8b 04 91 7d 00	 mov	 rcx, 35343820800000000	; 007d91048bca0000H
  00044	48 03 c1	 add	 rax, rcx
  00047	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ETOD$[rsp]
  0004c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 508  :     ETOD->low   = ts->tv_nsec;      /* Copy nanoseconds                       */

  00050	48 8b 44 24 10	 mov	 rax, QWORD PTR ts$[rsp]
  00055	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00059	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ETOD$[rsp]
  0005e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 509  : 
; 510  : #if defined(TOD_FULL_PRECISION)       || \
; 511  :     defined(TOD_120BIT_PRECISION)     || \
; 512  :     defined(TOD_64BIT_PRECISION)      || \
; 513  :     defined(TOD_MIN_PRECISION)        || \
; 514  :    !defined(TOD_95BIT_PRECISION)
; 515  : 
; 516  :     {
; 517  :         register U64    temp;
; 518  :         temp        = ETOD->low;    /* Adjust nanoseconds to bit-59 for       */
; 519  :         temp      <<= 1;            /* division by 1000 (shift compressed),   */
; 520  :         temp       /= 125;          /* calculating microseconds and the top   */
; 521  :                                     /* nibble of the remainder                */
; 522  :                                     /* (us*16 = ns*16/1000 = ns*2/125)        */
; 523  :         ETOD->high += temp;         /* Add to upper 64-bits                   */
; 524  :         #if defined(TOD_MIN_PRECISION)      || \
; 525  :             defined(TOD_64BIT_PRECISION)
; 526  :             ETOD->low   = 0;        /* Set lower 64-bits to zero              */
; 527  :                                     /* (gettimeofday or other microsecond     */
; 528  :                                     /* clock used as clock source)            */
; 529  :         #else /* Calculate full precision fractional clock value              */
; 530  :             temp      >>= 1;        /* Calculate remainder                    */
; 531  :             temp       *= 125;      /* ...                                    */
; 532  :             ETOD->low  -= temp;     /* ...                                    */
; 533  :             ETOD->low <<= 57;       /* Divide remainder by 1000 and adjust    */
; 534  :             ETOD->low  /= 125;      /* to proper position, shifting out high- */
; 535  :             ETOD->low <<= 8;        /* order byte                             */
; 536  :         #endif
; 537  :     }
; 538  : 
; 539  : #else /* 95-bit resolution */
; 540  : 
; 541  :     {
; 542  :         ETOD->low <<= 32;           /* Place nanoseconds in high-order word   */

  00061	48 8b 44 24 08	 mov	 rax, QWORD PTR ETOD$[rsp]
  00066	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00069	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0006d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ETOD$[rsp]
  00072	48 89 01	 mov	 QWORD PTR [rcx], rax

; 543  :         ETOD->low  /= 125;          /* Divide by 1000 (125 * 2^3)             */

  00075	33 d2		 xor	 edx, edx
  00077	48 8b 44 24 08	 mov	 rax, QWORD PTR ETOD$[rsp]
  0007c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007f	b9 7d 00 00 00	 mov	 ecx, 125		; 0000007dH
  00084	48 f7 f1	 div	 rcx
  00087	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ETOD$[rsp]
  0008c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 544  :         ETOD->high += ETOD->low >> 31;  /* Adjust and add microseconds and    */

  0008f	48 8b 44 24 08	 mov	 rax, QWORD PTR ETOD$[rsp]
  00094	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00097	48 c1 e8 1f	 shr	 rax, 31
  0009b	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ETOD$[rsp]
  000a0	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  000a4	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ETOD$[rsp]
  000a9	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 545  :                                     /* first nibble of nanosecond remainder   */
; 546  :                                     /* to bits 0-63                           */
; 547  :         ETOD->low <<= 33;           /* Adjust remaining nanosecond fraction   */

  000ad	48 8b 44 24 08	 mov	 rax, QWORD PTR ETOD$[rsp]
  000b2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b5	48 c1 e0 21	 shl	 rax, 33			; 00000021H
  000b9	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ETOD$[rsp]
  000be	48 89 01	 mov	 QWORD PTR [rcx], rax

; 548  :                                     /* to bits 64-93                          */
; 549  :     }
; 550  : 
; 551  : #endif /* defined(TOD_FULL_PRECISION) || .... */
; 552  : 
; 553  :     return ( ETOD->high );          /* Return address of result               */

  000c1	48 8b 44 24 08	 mov	 rax, QWORD PTR ETOD$[rsp]
  000c6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 554  : }

  000ca	c3		 ret	 0
timespec2ETOD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
tv65 = 0
ts$ = 32
timespec2usecs PROC

; 246  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 247  :     return ((ts->tv_sec) * 1000000 + ((ts->tv_nsec + 500) / 1000));

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  0000e	48 69 00 40 42
	0f 00		 imul	 rax, QWORD PTR [rax], 1000000 ; 000f4240H
  00015	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  0001e	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00021	81 c1 f4 01 00
	00		 add	 ecx, 500		; 000001f4H
  00027	8b c1		 mov	 eax, ecx
  00029	99		 cdq
  0002a	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0002f	f7 f9		 idiv	 ecx
  00031	48 98		 cdqe
  00033	48 8b 0c 24	 mov	 rcx, QWORD PTR tv65[rsp]
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx

; 248  : }

  0003d	48 83 c4 18	 add	 rsp, 24
  00041	c3		 ret	 0
timespec2usecs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
etod$ = 8
ETOD_high64_to_usecs PROC

; 229  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 230  :     return (etod >> 4);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR etod$[rsp]
  0000a	48 c1 f8 04	 sar	 rax, 4

; 231  : }

  0000e	c3		 ret	 0
ETOD_high64_to_usecs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
tod$ = 8
TOD_high64_to_ETOD_high56 PROC

; 221  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 222  :     return (tod >> 8);                  /* Adjust bit 51 to bit 59   */

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR tod$[rsp]
  0000a	48 c1 e8 08	 shr	 rax, 8

; 223  : }

  0000e	c3		 ret	 0
TOD_high64_to_ETOD_high56 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
etod$ = 8
ETOD_high64_to_TOD_high56 PROC

; 213  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 214  :     return (etod << 8);                 /* Adjust bit 59 to bit 51   */

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR etod$[rsp]
  0000a	48 c1 e0 08	 shl	 rax, 8

; 215  : }

  0000e	c3		 ret	 0
ETOD_high64_to_TOD_high56 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
result$ = 32
temp$ = 40
time$1 = 48
__$ArrayPad$ = 64
host_tod PROC

; 565  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000b	48 33 c4	 xor	 rax, rsp
  0000e	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 566  :   register TOD  result;
; 567  :   register U64  temp;
; 568  : 
; 569  :   /* Use the same clock source as host_ETOD().
; 570  :      Refer to host_ETOD() in clock.c for additional comments.
; 571  :    */
; 572  : 
; 573  : #if !defined( _MSVC_ ) && !defined( CLOCK_REALTIME )
; 574  :   {
; 575  :     struct timeval time;
; 576  :     gettimeofday( &time, NULL );    /* Get current host time         */
; 577  :     result = time.tv_usec << 4;     /* Adjust microseconds to bit-59 */
; 578  :     temp   = time.tv_sec;           /* Load seconds                  */
; 579  :   }
; 580  : #else
; 581  :   {
; 582  :     struct timespec time;
; 583  :     clock_gettime( CLOCK_REALTIME, &time );

  00013	48 8d 54 24 30	 lea	 rdx, QWORD PTR time$1[rsp]
  00018	33 c9		 xor	 ecx, ecx
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock_gettime

; 584  :     result  = time.tv_nsec;         /* Adjust nanoseconds to bit-59  */

  00020	48 63 44 24 38	 movsxd	 rax, DWORD PTR time$1[rsp+8]
  00025	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 585  :     result <<= 1;                   /* and divide by 1000

  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0002f	48 d1 e0	 shl	 rax, 1
  00032	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 586  :                                        (bit-shift compressed)        */
; 587  :     result  /= 125;                 /* ...                           */

  00037	33 d2		 xor	 edx, edx
  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0003e	b9 7d 00 00 00	 mov	 ecx, 125		; 0000007dH
  00043	48 f7 f1	 div	 rcx
  00046	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 588  :     temp     = time.tv_sec;         /* Load seconds                  */

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR time$1[rsp]
  00050	48 89 44 24 28	 mov	 QWORD PTR temp$[rsp], rax

; 589  :    }
; 590  : #endif /* !defined( _MSVC_ ) && !defined( CLOCK_REALTIME ) */
; 591  : 
; 592  :   temp   *= ETOD_SEC;               /* Convert seconds to ETOD fmt   */

  00055	48 69 44 24 28
	00 24 f4 00	 imul	 rax, QWORD PTR temp$[rsp], 16000000 ; 00f42400H
  0005e	48 89 44 24 28	 mov	 QWORD PTR temp$[rsp], rax

; 593  :   result += temp;                   /* Add seconds                   */

  00063	48 8b 44 24 28	 mov	 rax, QWORD PTR temp$[rsp]
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 594  :   result += ETOD_1970;              /* Adjust to epoch 1970          */

  00078	48 b8 00 00 ca
	8b 04 91 7d 00	 mov	 rax, 35343820800000000	; 007d91048bca0000H
  00082	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00087	48 03 c8	 add	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 595  :   return ( result );

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 596  : }

  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009c	48 33 cc	 xor	 rcx, rsp
  0009f	e8 00 00 00 00	 call	 __security_check_cookie
  000a4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000a8	c3		 ret	 0
host_tod ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
low$ = 0
high$ = 8
tv157 = 16
tv160 = 24
tv169 = 32
tv175 = 40
tv178 = 48
tv183 = 56
result$ = 80
a$ = 88
shift$ = 96
ETOD_shift PROC

; 284  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 285  :     register U64 high;
; 286  :     register U64 low;
; 287  : 
; 288  :     if (shift == 0)                 /* Zero shift: copy in to out */

  00013	83 7c 24 60 00	 cmp	 DWORD PTR shift$[rsp], 0
  00018	75 1f		 jne	 SHORT $LN2@ETOD_shift

; 289  :     {
; 290  :         high = a.high;

  0001a	48 8b 44 24 58	 mov	 rax, QWORD PTR a$[rsp]
  0001f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00023	48 89 44 24 08	 mov	 QWORD PTR high$[rsp], rax

; 291  :         low  = a.low;

  00028	48 8b 44 24 58	 mov	 rax, QWORD PTR a$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 89 04 24	 mov	 QWORD PTR low$[rsp], rax

; 292  :     }

  00034	e9 9d 01 00 00	 jmp	 $LN3@ETOD_shift
$LN2@ETOD_shift:

; 293  :     else if (shift < 0)             /* Negtative: shift LEFT */

  00039	83 7c 24 60 00	 cmp	 DWORD PTR shift$[rsp], 0
  0003e	0f 8d d0 00 00
	00		 jge	 $LN4@ETOD_shift

; 294  :     {
; 295  :         shift = -shift;             /* (get positive shift amount) */

  00044	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  00048	f7 d8		 neg	 eax
  0004a	89 44 24 60	 mov	 DWORD PTR shift$[rsp], eax

; 296  : 
; 297  :         if (shift >= 64)            /* Negtative: shift LEFT >= 64 */

  0004e	83 7c 24 60 40	 cmp	 DWORD PTR shift$[rsp], 64 ; 00000040H
  00053	7c 5e		 jl	 SHORT $LN6@ETOD_shift

; 298  :         {
; 299  :             shift -= 64;            /* (get shift amount 0-64) */

  00055	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  00059	83 e8 40	 sub	 eax, 64			; 00000040H
  0005c	89 44 24 60	 mov	 DWORD PTR shift$[rsp], eax

; 300  : 
; 301  :             if (shift == 0)

  00060	83 7c 24 60 00	 cmp	 DWORD PTR shift$[rsp], 0
  00065	75 0f		 jne	 SHORT $LN8@ETOD_shift

; 302  :                 high = a.low;

  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR a$[rsp]
  0006c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006f	48 89 44 24 08	 mov	 QWORD PTR high$[rsp], rax
  00074	eb 33		 jmp	 SHORT $LN9@ETOD_shift
$LN8@ETOD_shift:

; 303  :             else if (shift > 64)

  00076	83 7c 24 60 40	 cmp	 DWORD PTR shift$[rsp], 64 ; 00000040H
  0007b	7e 0b		 jle	 SHORT $LN10@ETOD_shift

; 304  :                 high = 0;

  0007d	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR high$[rsp], 0
  00086	eb 21		 jmp	 SHORT $LN11@ETOD_shift
$LN10@ETOD_shift:

; 305  :             else
; 306  :                 high = a.low << shift;

  00088	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  0008c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp]
  00091	48 89 4c 24 10	 mov	 QWORD PTR tv157[rsp], rcx
  00096	0f b6 c8	 movzx	 ecx, al
  00099	48 8b 44 24 10	 mov	 rax, QWORD PTR tv157[rsp]
  0009e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a1	48 d3 e0	 shl	 rax, cl
  000a4	48 89 44 24 08	 mov	 QWORD PTR high$[rsp], rax
$LN11@ETOD_shift:
$LN9@ETOD_shift:

; 307  : 
; 308  :             low = 0;

  000a9	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR low$[rsp], 0

; 309  :         }

  000b1	eb 5c		 jmp	 SHORT $LN7@ETOD_shift
$LN6@ETOD_shift:

; 310  :         else                        /* Negtative: shift LEFT < 64 */
; 311  :         {
; 312  :             high = a.high << shift | a.low >> (64 - shift);

  000b3	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  000b7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp]
  000bc	48 89 4c 24 18	 mov	 QWORD PTR tv160[rsp], rcx
  000c1	0f b6 c8	 movzx	 ecx, al
  000c4	48 8b 44 24 18	 mov	 rax, QWORD PTR tv160[rsp]
  000c9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000cd	48 d3 e0	 shl	 rax, cl
  000d0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000d5	2b 4c 24 60	 sub	 ecx, DWORD PTR shift$[rsp]
  000d9	48 8b 54 24 58	 mov	 rdx, QWORD PTR a$[rsp]
  000de	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000e1	48 d3 ea	 shr	 rdx, cl
  000e4	48 8b ca	 mov	 rcx, rdx
  000e7	48 0b c1	 or	 rax, rcx
  000ea	48 89 44 24 08	 mov	 QWORD PTR high$[rsp], rax

; 313  :             low  = a.low << shift;

  000ef	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  000f3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp]
  000f8	48 89 4c 24 20	 mov	 QWORD PTR tv169[rsp], rcx
  000fd	0f b6 c8	 movzx	 ecx, al
  00100	48 8b 44 24 20	 mov	 rax, QWORD PTR tv169[rsp]
  00105	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00108	48 d3 e0	 shl	 rax, cl
  0010b	48 89 04 24	 mov	 QWORD PTR low$[rsp], rax
$LN7@ETOD_shift:

; 314  :         }
; 315  :     }

  0010f	e9 c2 00 00 00	 jmp	 $LN5@ETOD_shift
$LN4@ETOD_shift:

; 316  :     else if (shift >= 64)           /* Positive: shift RIGHT >= 64 */

  00114	83 7c 24 60 40	 cmp	 DWORD PTR shift$[rsp], 64 ; 00000040H
  00119	7c 5e		 jl	 SHORT $LN12@ETOD_shift

; 317  :     {
; 318  :         shift -= 64;                /* (get shift amount 0-64) */

  0011b	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  0011f	83 e8 40	 sub	 eax, 64			; 00000040H
  00122	89 44 24 60	 mov	 DWORD PTR shift$[rsp], eax

; 319  :         high   = 0;

  00126	48 c7 44 24 08
	00 00 00 00	 mov	 QWORD PTR high$[rsp], 0

; 320  : 
; 321  :         if (shift == 0)

  0012f	83 7c 24 60 00	 cmp	 DWORD PTR shift$[rsp], 0
  00134	75 0f		 jne	 SHORT $LN14@ETOD_shift

; 322  :             low = a.high;

  00136	48 8b 44 24 58	 mov	 rax, QWORD PTR a$[rsp]
  0013b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0013f	48 89 04 24	 mov	 QWORD PTR low$[rsp], rax
  00143	eb 32		 jmp	 SHORT $LN15@ETOD_shift
$LN14@ETOD_shift:

; 323  :         else if (shift < 64)

  00145	83 7c 24 60 40	 cmp	 DWORD PTR shift$[rsp], 64 ; 00000040H
  0014a	7d 23		 jge	 SHORT $LN16@ETOD_shift

; 324  :             low = a.high >> shift;

  0014c	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  00150	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp]
  00155	48 89 4c 24 28	 mov	 QWORD PTR tv175[rsp], rcx
  0015a	0f b6 c8	 movzx	 ecx, al
  0015d	48 8b 44 24 28	 mov	 rax, QWORD PTR tv175[rsp]
  00162	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00166	48 d3 e8	 shr	 rax, cl
  00169	48 89 04 24	 mov	 QWORD PTR low$[rsp], rax
  0016d	eb 08		 jmp	 SHORT $LN17@ETOD_shift
$LN16@ETOD_shift:

; 325  :         else
; 326  :             low = 0;

  0016f	48 c7 04 24 00
	00 00 00	 mov	 QWORD PTR low$[rsp], 0
$LN17@ETOD_shift:
$LN15@ETOD_shift:

; 327  :     }

  00177	eb 5d		 jmp	 SHORT $LN13@ETOD_shift
$LN12@ETOD_shift:

; 328  :     else                            /* Positive: shift RIGHT < 64 */
; 329  :     {
; 330  :         high = a.high >> shift;

  00179	8b 44 24 60	 mov	 eax, DWORD PTR shift$[rsp]
  0017d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp]
  00182	48 89 4c 24 30	 mov	 QWORD PTR tv178[rsp], rcx
  00187	0f b6 c8	 movzx	 ecx, al
  0018a	48 8b 44 24 30	 mov	 rax, QWORD PTR tv178[rsp]
  0018f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00193	48 d3 e8	 shr	 rax, cl
  00196	48 89 44 24 08	 mov	 QWORD PTR high$[rsp], rax

; 331  :         low  = a.high << (64 - shift) | a.low >> shift;

  0019b	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  001a0	2b 44 24 60	 sub	 eax, DWORD PTR shift$[rsp]
  001a4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR a$[rsp]
  001a9	48 89 4c 24 38	 mov	 QWORD PTR tv183[rsp], rcx
  001ae	0f b6 c8	 movzx	 ecx, al
  001b1	48 8b 44 24 38	 mov	 rax, QWORD PTR tv183[rsp]
  001b6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001ba	48 d3 e0	 shl	 rax, cl
  001bd	8b 4c 24 60	 mov	 ecx, DWORD PTR shift$[rsp]
  001c1	48 8b 54 24 58	 mov	 rdx, QWORD PTR a$[rsp]
  001c6	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  001c9	48 d3 ea	 shr	 rdx, cl
  001cc	48 8b ca	 mov	 rcx, rdx
  001cf	48 0b c1	 or	 rax, rcx
  001d2	48 89 04 24	 mov	 QWORD PTR low$[rsp], rax
$LN13@ETOD_shift:
$LN5@ETOD_shift:
$LN3@ETOD_shift:

; 332  :     }
; 333  : 
; 334  :     result->low  = low;

  001d6	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  001db	48 8b 0c 24	 mov	 rcx, QWORD PTR low$[rsp]
  001df	48 89 08	 mov	 QWORD PTR [rax], rcx

; 335  :     result->high = high;

  001e2	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
  001e7	48 8b 4c 24 08	 mov	 rcx, QWORD PTR high$[rsp]
  001ec	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 336  : }

  001f0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f4	c3		 ret	 0
ETOD_shift ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
high$ = 0
low$ = 8
result$ = 32
a$ = 40
b$ = 48
ETOD_sub PROC

; 269  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 270  :     register U64 high  = a.high - b.high;

  00013	48 8b 44 24 28	 mov	 rax, QWORD PTR a$[rsp]
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  0001d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00021	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00025	48 2b c1	 sub	 rax, rcx
  00028	48 89 04 24	 mov	 QWORD PTR high$[rsp], rax

; 271  :     register U64 low   = a.low  - b.low;

  0002c	48 8b 44 24 28	 mov	 rax, QWORD PTR a$[rsp]
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  00036	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 2b c1	 sub	 rax, rcx
  0003f	48 89 44 24 08	 mov	 QWORD PTR low$[rsp], rax

; 272  : 
; 273  :     if (a.low < b.low)

  00044	48 8b 44 24 28	 mov	 rax, QWORD PTR a$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  0004e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00051	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00054	73 0b		 jae	 SHORT $LN2@ETOD_sub

; 274  :         --high;

  00056	48 8b 04 24	 mov	 rax, QWORD PTR high$[rsp]
  0005a	48 ff c8	 dec	 rax
  0005d	48 89 04 24	 mov	 QWORD PTR high$[rsp], rax
$LN2@ETOD_sub:

; 275  : 
; 276  :     result->high = high;

  00061	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00066	48 8b 0c 24	 mov	 rcx, QWORD PTR high$[rsp]
  0006a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 277  :     result->low  = low;

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00073	48 8b 4c 24 08	 mov	 rcx, QWORD PTR low$[rsp]
  00078	48 89 08	 mov	 QWORD PTR [rax], rcx

; 278  : }

  0007b	48 83 c4 18	 add	 rsp, 24
  0007f	c3		 ret	 0
ETOD_sub ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
high$ = 0
low$ = 8
result$ = 32
a$ = 40
b$ = 48
ETOD_add PROC

; 254  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 255  :     register U64 high  = a.high + b.high;

  00013	48 8b 44 24 28	 mov	 rax, QWORD PTR a$[rsp]
  00018	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  00021	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  00025	48 89 04 24	 mov	 QWORD PTR high$[rsp], rax

; 256  :     register U64 low   = a.low  + b.low;

  00029	48 8b 44 24 28	 mov	 rax, QWORD PTR a$[rsp]
  0002e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00031	48 8b 4c 24 30	 mov	 rcx, QWORD PTR b$[rsp]
  00036	48 03 01	 add	 rax, QWORD PTR [rcx]
  00039	48 89 44 24 08	 mov	 QWORD PTR low$[rsp], rax

; 257  : 
; 258  :     if (low < a.low)

  0003e	48 8b 44 24 28	 mov	 rax, QWORD PTR a$[rsp]
  00043	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00046	48 39 44 24 08	 cmp	 QWORD PTR low$[rsp], rax
  0004b	73 0b		 jae	 SHORT $LN2@ETOD_add

; 259  :         ++high;

  0004d	48 8b 04 24	 mov	 rax, QWORD PTR high$[rsp]
  00051	48 ff c0	 inc	 rax
  00054	48 89 04 24	 mov	 QWORD PTR high$[rsp], rax
$LN2@ETOD_add:

; 260  : 
; 261  :     result->high = high;

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0005d	48 8b 0c 24	 mov	 rcx, QWORD PTR high$[rsp]
  00061	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 262  :     result->low  = low;

  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0006a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR low$[rsp]
  0006f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 263  : }

  00072	48 83 c4 18	 add	 rsp, 24
  00076	c3		 ret	 0
ETOD_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
query_tzoffset PROC

; 1216 :     return default_tzoffset;

  00000	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR default_tzoffset

; 1217 : }

  00006	c3		 ret	 0
query_tzoffset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
tv80 = 32
len$ = 40
k$1 = 48
l$2 = 52
i$ = 56
f$ = 60
tv89 = 64
key$ = 72
buf$ = 80
__$ArrayPad$ = 4176
file$ = 4208
clock_hresume PROC

; 1397 : {

$LN87:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	b8 60 10 00 00	 mov	 eax, 4192		; 00001060H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	48 2b e0	 sub	 rsp, rax
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 50
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1398 :     size_t key, len;
; 1399 :     int i;
; 1400 :     float f;
; 1401 :     char buf[SR_MAX_STRING_LENGTH];
; 1402 : 
; 1403 :     memset(&episode_old, 0, sizeof(CSR));

  00025	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_old
  0002c	48 8b f8	 mov	 rdi, rax
  0002f	33 c0		 xor	 eax, eax
  00031	b9 18 00 00 00	 mov	 ecx, 24
  00036	f3 aa		 rep stosb

; 1404 :     memset(&episode_new, 0, sizeof(CSR));

  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_new
  0003f	48 8b f8	 mov	 rdi, rax
  00042	33 c0		 xor	 eax, eax
  00044	b9 18 00 00 00	 mov	 ecx, 24
  00049	f3 aa		 rep stosb

; 1405 :     episode_current = &episode_new;

  0004b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_new
  00052	48 89 05 00 00
	00 00		 mov	 QWORD PTR episode_current, rax

; 1406 :     universal_tod.high = universal_tod.low = 0;

  00059	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR universal_tod, 0
  00064	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR universal_tod
  0006b	48 89 05 08 00
	00 00		 mov	 QWORD PTR universal_tod+8, rax

; 1407 :     hw_steering = 0.0;

  00072	0f 57 c0	 xorps	 xmm0, xmm0
  00075	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR hw_steering, xmm0

; 1408 :     hw_episode = 0;

  0007d	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR hw_episode, 0

; 1409 :     hw_offset = 0;

  00088	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR hw_offset, 0
$LN4@clock_hres:
$LN7@clock_hres:

; 1410 : 
; 1411 :     do {
; 1412 :         SR_READ_HDR(file, key, len);

  00093	4c 8d 44 24 34	 lea	 r8, QWORD PTR l$2[rsp]
  00098	48 8d 54 24 30	 lea	 rdx, QWORD PTR k$1[rsp]
  0009d	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  000a5	e8 00 00 00 00	 call	 sr_read_hdr
  000aa	85 c0		 test	 eax, eax
  000ac	74 0a		 je	 SHORT $LN52@clock_hres
  000ae	b8 ff ff ff ff	 mov	 eax, -1
  000b3	e9 77 04 00 00	 jmp	 $LN1@clock_hres
$LN52@clock_hres:
  000b8	8b 44 24 30	 mov	 eax, DWORD PTR k$1[rsp]
  000bc	48 89 44 24 48	 mov	 QWORD PTR key$[rsp], rax
  000c1	8b 44 24 34	 mov	 eax, DWORD PTR l$2[rsp]
  000c5	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax
  000ca	33 c0		 xor	 eax, eax
  000cc	85 c0		 test	 eax, eax
  000ce	75 c3		 jne	 SHORT $LN7@clock_hres

; 1413 :         switch (key) {

  000d0	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  000d5	48 89 44 24 20	 mov	 QWORD PTR tv80[rsp], rax
  000da	b8 02 21 e1 ac	 mov	 eax, -1394532094	; ace12102H
  000df	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  000e4	0f 87 86 00 00
	00		 ja	 $LN84@clock_hres
  000ea	b8 02 21 e1 ac	 mov	 eax, -1394532094	; ace12102H
  000ef	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  000f4	0f 84 7e 02 00
	00		 je	 $LN65@clock_hres
  000fa	b8 05 20 e1 ac	 mov	 eax, -1394532347	; ace12005H
  000ff	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  00104	77 45		 ja	 SHORT $LN85@clock_hres
  00106	b8 05 20 e1 ac	 mov	 eax, -1394532347	; ace12005H
  0010b	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  00110	0f 84 bd 01 00
	00		 je	 $LN59@clock_hres
  00116	b8 01 20 e1 ac	 mov	 eax, -1394532351	; ace12001H
  0011b	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  00120	0f 84 c0 00 00
	00		 je	 $LN53@clock_hres
  00126	b8 02 20 e1 ac	 mov	 eax, -1394532350	; ace12002H
  0012b	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  00130	0f 84 12 01 00
	00		 je	 $LN55@clock_hres
  00136	b8 04 20 e1 ac	 mov	 eax, -1394532348	; ace12004H
  0013b	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  00140	0f 84 39 01 00
	00		 je	 $LN57@clock_hres
  00146	e9 a2 03 00 00	 jmp	 $LN79@clock_hres
$LN85@clock_hres:
  0014b	b8 06 20 e1 ac	 mov	 eax, -1394532346	; ace12006H
  00150	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  00155	0f 84 af 01 00
	00		 je	 $LN61@clock_hres
  0015b	b8 01 21 e1 ac	 mov	 eax, -1394532095	; ace12101H
  00160	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  00165	0f 84 d6 01 00
	00		 je	 $LN63@clock_hres
  0016b	e9 7d 03 00 00	 jmp	 $LN79@clock_hres
$LN84@clock_hres:
  00170	b8 02 22 e1 ac	 mov	 eax, -1394531838	; ace12202H
  00175	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  0017a	77 45		 ja	 SHORT $LN86@clock_hres
  0017c	b8 02 22 e1 ac	 mov	 eax, -1394531838	; ace12202H
  00181	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  00186	0f 84 c8 02 00
	00		 je	 $LN73@clock_hres
  0018c	b8 03 21 e1 ac	 mov	 eax, -1394532093	; ace12103H
  00191	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  00196	0f 84 13 02 00
	00		 je	 $LN67@clock_hres
  0019c	b8 04 21 e1 ac	 mov	 eax, -1394532092	; ace12104H
  001a1	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  001a6	0f 84 3a 02 00
	00		 je	 $LN69@clock_hres
  001ac	b8 01 22 e1 ac	 mov	 eax, -1394531839	; ace12201H
  001b1	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  001b6	0f 84 61 02 00
	00		 je	 $LN71@clock_hres
  001bc	e9 2c 03 00 00	 jmp	 $LN79@clock_hres
$LN86@clock_hres:
  001c1	b8 03 22 e1 ac	 mov	 eax, -1394531837	; ace12203H
  001c6	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  001cb	0f 84 ba 02 00
	00		 je	 $LN75@clock_hres
  001d1	b8 04 22 e1 ac	 mov	 eax, -1394531836	; ace12204H
  001d6	48 39 44 24 20	 cmp	 QWORD PTR tv80[rsp], rax
  001db	0f 84 db 02 00
	00		 je	 $LN77@clock_hres
  001e1	e9 07 03 00 00	 jmp	 $LN79@clock_hres
$LN53@clock_hres:
$LN12@clock_hres:

; 1414 :         case SR_SYS_CLOCK_CURRENT_CSR:
; 1415 :             SR_READ_VALUE(file, len, &i, sizeof(i));

  001e6	41 b9 04 00 00
	00		 mov	 r9d, 4
  001ec	4c 8d 44 24 38	 lea	 r8, QWORD PTR i$[rsp]
  001f1	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  001f5	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  001fd	e8 00 00 00 00	 call	 sr_read_value
  00202	85 c0		 test	 eax, eax
  00204	74 0a		 je	 SHORT $LN54@clock_hres
  00206	b8 ff ff ff ff	 mov	 eax, -1
  0020b	e9 1f 03 00 00	 jmp	 $LN1@clock_hres
$LN54@clock_hres:
  00210	33 c0		 xor	 eax, eax
  00212	85 c0		 test	 eax, eax
  00214	75 d0		 jne	 SHORT $LN12@clock_hres

; 1416 :             episode_current = i ? &episode_new : &episode_old;

  00216	83 7c 24 38 00	 cmp	 DWORD PTR i$[rsp], 0
  0021b	74 0e		 je	 SHORT $LN82@clock_hres
  0021d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_new
  00224	48 89 44 24 40	 mov	 QWORD PTR tv89[rsp], rax
  00229	eb 0c		 jmp	 SHORT $LN83@clock_hres
$LN82@clock_hres:
  0022b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_old
  00232	48 89 44 24 40	 mov	 QWORD PTR tv89[rsp], rax
$LN83@clock_hres:
  00237	48 8b 44 24 40	 mov	 rax, QWORD PTR tv89[rsp]
  0023c	48 89 05 00 00
	00 00		 mov	 QWORD PTR episode_current, rax

; 1417 :             break;

  00243	e9 c7 02 00 00	 jmp	 $LN8@clock_hres
$LN55@clock_hres:
$LN15@clock_hres:

; 1418 :         case SR_SYS_CLOCK_UNIVERSAL_TOD:
; 1419 :             SR_READ_VALUE(file, len, &universal_tod.high, sizeof(universal_tod.high));

  00248	41 b9 08 00 00
	00		 mov	 r9d, 8
  0024e	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:universal_tod+8
  00255	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  00259	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00261	e8 00 00 00 00	 call	 sr_read_value
  00266	85 c0		 test	 eax, eax
  00268	74 0a		 je	 SHORT $LN56@clock_hres
  0026a	b8 ff ff ff ff	 mov	 eax, -1
  0026f	e9 bb 02 00 00	 jmp	 $LN1@clock_hres
$LN56@clock_hres:
  00274	33 c0		 xor	 eax, eax
  00276	85 c0		 test	 eax, eax
  00278	75 ce		 jne	 SHORT $LN15@clock_hres

; 1420 :             break;

  0027a	e9 90 02 00 00	 jmp	 $LN8@clock_hres
$LN57@clock_hres:
$LN18@clock_hres:

; 1421 :         case SR_SYS_CLOCK_HW_STEERING:
; 1422 :             SR_READ_STRING(file, buf, len);

  0027f	44 8b 44 24 28	 mov	 r8d, DWORD PTR len$[rsp]
  00284	48 8d 54 24 50	 lea	 rdx, QWORD PTR buf$[rsp]
  00289	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00291	e8 00 00 00 00	 call	 sr_read_string
  00296	85 c0		 test	 eax, eax
  00298	74 0a		 je	 SHORT $LN58@clock_hres
  0029a	b8 ff ff ff ff	 mov	 eax, -1
  0029f	e9 8b 02 00 00	 jmp	 $LN1@clock_hres
$LN58@clock_hres:
  002a4	33 c0		 xor	 eax, eax
  002a6	85 c0		 test	 eax, eax
  002a8	75 d5		 jne	 SHORT $LN18@clock_hres

; 1423 :             sscanf(buf, "%f",&f);

  002aa	4c 8d 44 24 3c	 lea	 r8, QWORD PTR f$[rsp]
  002af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202497
  002b6	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  002bb	e8 00 00 00 00	 call	 sscanf

; 1424 :             hw_steering = f;

  002c0	f3 0f 5a 44 24
	3c		 cvtss2sd xmm0, DWORD PTR f$[rsp]
  002c6	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR hw_steering, xmm0

; 1425 :             break;

  002ce	e9 3c 02 00 00	 jmp	 $LN8@clock_hres
$LN59@clock_hres:
$LN21@clock_hres:

; 1426 :         case SR_SYS_CLOCK_HW_EPISODE:
; 1427 :             SR_READ_VALUE(file, len, &hw_episode, sizeof(hw_episode));

  002d3	41 b9 08 00 00
	00		 mov	 r9d, 8
  002d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:hw_episode
  002e0	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  002e4	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  002ec	e8 00 00 00 00	 call	 sr_read_value
  002f1	85 c0		 test	 eax, eax
  002f3	74 0a		 je	 SHORT $LN60@clock_hres
  002f5	b8 ff ff ff ff	 mov	 eax, -1
  002fa	e9 30 02 00 00	 jmp	 $LN1@clock_hres
$LN60@clock_hres:
  002ff	33 c0		 xor	 eax, eax
  00301	85 c0		 test	 eax, eax
  00303	75 ce		 jne	 SHORT $LN21@clock_hres

; 1428 :             break;

  00305	e9 05 02 00 00	 jmp	 $LN8@clock_hres
$LN61@clock_hres:
$LN24@clock_hres:

; 1429 :         case SR_SYS_CLOCK_HW_OFFSET:
; 1430 :             SR_READ_VALUE(file, len, &hw_offset, sizeof(hw_offset));

  0030a	41 b9 08 00 00
	00		 mov	 r9d, 8
  00310	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:hw_offset
  00317	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  0031b	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00323	e8 00 00 00 00	 call	 sr_read_value
  00328	85 c0		 test	 eax, eax
  0032a	74 0a		 je	 SHORT $LN62@clock_hres
  0032c	b8 ff ff ff ff	 mov	 eax, -1
  00331	e9 f9 01 00 00	 jmp	 $LN1@clock_hres
$LN62@clock_hres:
  00336	33 c0		 xor	 eax, eax
  00338	85 c0		 test	 eax, eax
  0033a	75 ce		 jne	 SHORT $LN24@clock_hres

; 1431 :             break;

  0033c	e9 ce 01 00 00	 jmp	 $LN8@clock_hres
$LN63@clock_hres:
$LN27@clock_hres:

; 1432 :         case SR_SYS_CLOCK_OLD_CSR_START_TIME:
; 1433 :             SR_READ_VALUE(file, len, &episode_old.start_time, sizeof(episode_old.start_time));

  00341	41 b9 08 00 00
	00		 mov	 r9d, 8
  00347	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:episode_old
  0034e	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  00352	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  0035a	e8 00 00 00 00	 call	 sr_read_value
  0035f	85 c0		 test	 eax, eax
  00361	74 0a		 je	 SHORT $LN64@clock_hres
  00363	b8 ff ff ff ff	 mov	 eax, -1
  00368	e9 c2 01 00 00	 jmp	 $LN1@clock_hres
$LN64@clock_hres:
  0036d	33 c0		 xor	 eax, eax
  0036f	85 c0		 test	 eax, eax
  00371	75 ce		 jne	 SHORT $LN27@clock_hres

; 1434 :             break;

  00373	e9 97 01 00 00	 jmp	 $LN8@clock_hres
$LN65@clock_hres:
$LN30@clock_hres:

; 1435 :         case SR_SYS_CLOCK_OLD_CSR_BASE_OFFSET:
; 1436 :             SR_READ_VALUE(file, len, &episode_old.base_offset, sizeof(episode_old.base_offset));

  00378	41 b9 08 00 00
	00		 mov	 r9d, 8
  0037e	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:episode_old+8
  00385	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  00389	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00391	e8 00 00 00 00	 call	 sr_read_value
  00396	85 c0		 test	 eax, eax
  00398	74 0a		 je	 SHORT $LN66@clock_hres
  0039a	b8 ff ff ff ff	 mov	 eax, -1
  0039f	e9 8b 01 00 00	 jmp	 $LN1@clock_hres
$LN66@clock_hres:
  003a4	33 c0		 xor	 eax, eax
  003a6	85 c0		 test	 eax, eax
  003a8	75 ce		 jne	 SHORT $LN30@clock_hres

; 1437 :             break;

  003aa	e9 60 01 00 00	 jmp	 $LN8@clock_hres
$LN67@clock_hres:
$LN33@clock_hres:

; 1438 :         case SR_SYS_CLOCK_OLD_CSR_FINE_S_RATE:
; 1439 :             SR_READ_VALUE(file, len, &episode_old.fine_s_rate, sizeof(episode_old.fine_s_rate));

  003af	41 b9 04 00 00
	00		 mov	 r9d, 4
  003b5	4c 8d 05 10 00
	00 00		 lea	 r8, OFFSET FLAT:episode_old+16
  003bc	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  003c0	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  003c8	e8 00 00 00 00	 call	 sr_read_value
  003cd	85 c0		 test	 eax, eax
  003cf	74 0a		 je	 SHORT $LN68@clock_hres
  003d1	b8 ff ff ff ff	 mov	 eax, -1
  003d6	e9 54 01 00 00	 jmp	 $LN1@clock_hres
$LN68@clock_hres:
  003db	33 c0		 xor	 eax, eax
  003dd	85 c0		 test	 eax, eax
  003df	75 ce		 jne	 SHORT $LN33@clock_hres

; 1440 :             break;

  003e1	e9 29 01 00 00	 jmp	 $LN8@clock_hres
$LN69@clock_hres:
$LN36@clock_hres:

; 1441 :         case SR_SYS_CLOCK_OLD_CSR_GROSS_S_RATE:
; 1442 :             SR_READ_VALUE(file, len, &episode_old.gross_s_rate, sizeof(episode_old.gross_s_rate));

  003e6	41 b9 04 00 00
	00		 mov	 r9d, 4
  003ec	4c 8d 05 14 00
	00 00		 lea	 r8, OFFSET FLAT:episode_old+20
  003f3	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  003f7	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  003ff	e8 00 00 00 00	 call	 sr_read_value
  00404	85 c0		 test	 eax, eax
  00406	74 0a		 je	 SHORT $LN70@clock_hres
  00408	b8 ff ff ff ff	 mov	 eax, -1
  0040d	e9 1d 01 00 00	 jmp	 $LN1@clock_hres
$LN70@clock_hres:
  00412	33 c0		 xor	 eax, eax
  00414	85 c0		 test	 eax, eax
  00416	75 ce		 jne	 SHORT $LN36@clock_hres

; 1443 :             break;

  00418	e9 f2 00 00 00	 jmp	 $LN8@clock_hres
$LN71@clock_hres:
$LN39@clock_hres:

; 1444 :         case SR_SYS_CLOCK_NEW_CSR_START_TIME:
; 1445 :             SR_READ_VALUE(file, len, &episode_new.start_time, sizeof(episode_new.start_time));

  0041d	41 b9 08 00 00
	00		 mov	 r9d, 8
  00423	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:episode_new
  0042a	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  0042e	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00436	e8 00 00 00 00	 call	 sr_read_value
  0043b	85 c0		 test	 eax, eax
  0043d	74 0a		 je	 SHORT $LN72@clock_hres
  0043f	b8 ff ff ff ff	 mov	 eax, -1
  00444	e9 e6 00 00 00	 jmp	 $LN1@clock_hres
$LN72@clock_hres:
  00449	33 c0		 xor	 eax, eax
  0044b	85 c0		 test	 eax, eax
  0044d	75 ce		 jne	 SHORT $LN39@clock_hres

; 1446 :             break;

  0044f	e9 bb 00 00 00	 jmp	 $LN8@clock_hres
$LN73@clock_hres:
$LN42@clock_hres:

; 1447 :         case SR_SYS_CLOCK_NEW_CSR_BASE_OFFSET:
; 1448 :             SR_READ_VALUE(file, len, &episode_new.base_offset, sizeof(episode_new.base_offset));

  00454	41 b9 08 00 00
	00		 mov	 r9d, 8
  0045a	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:episode_new+8
  00461	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  00465	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  0046d	e8 00 00 00 00	 call	 sr_read_value
  00472	85 c0		 test	 eax, eax
  00474	74 0a		 je	 SHORT $LN74@clock_hres
  00476	b8 ff ff ff ff	 mov	 eax, -1
  0047b	e9 af 00 00 00	 jmp	 $LN1@clock_hres
$LN74@clock_hres:
  00480	33 c0		 xor	 eax, eax
  00482	85 c0		 test	 eax, eax
  00484	75 ce		 jne	 SHORT $LN42@clock_hres

; 1449 :             break;

  00486	e9 84 00 00 00	 jmp	 $LN8@clock_hres
$LN75@clock_hres:
$LN45@clock_hres:

; 1450 :         case SR_SYS_CLOCK_NEW_CSR_FINE_S_RATE:
; 1451 :             SR_READ_VALUE(file, len, &episode_new.fine_s_rate, sizeof(episode_new.fine_s_rate));

  0048b	41 b9 04 00 00
	00		 mov	 r9d, 4
  00491	4c 8d 05 10 00
	00 00		 lea	 r8, OFFSET FLAT:episode_new+16
  00498	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  0049c	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  004a4	e8 00 00 00 00	 call	 sr_read_value
  004a9	85 c0		 test	 eax, eax
  004ab	74 07		 je	 SHORT $LN76@clock_hres
  004ad	b8 ff ff ff ff	 mov	 eax, -1
  004b2	eb 7b		 jmp	 SHORT $LN1@clock_hres
$LN76@clock_hres:
  004b4	33 c0		 xor	 eax, eax
  004b6	85 c0		 test	 eax, eax
  004b8	75 d1		 jne	 SHORT $LN45@clock_hres

; 1452 :             break;

  004ba	eb 53		 jmp	 SHORT $LN8@clock_hres
$LN77@clock_hres:
$LN48@clock_hres:

; 1453 :         case SR_SYS_CLOCK_NEW_CSR_GROSS_S_RATE:
; 1454 :             SR_READ_VALUE(file, len, &episode_new.gross_s_rate, sizeof(episode_new.gross_s_rate));

  004bc	41 b9 04 00 00
	00		 mov	 r9d, 4
  004c2	4c 8d 05 14 00
	00 00		 lea	 r8, OFFSET FLAT:episode_new+20
  004c9	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  004cd	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  004d5	e8 00 00 00 00	 call	 sr_read_value
  004da	85 c0		 test	 eax, eax
  004dc	74 07		 je	 SHORT $LN78@clock_hres
  004de	b8 ff ff ff ff	 mov	 eax, -1
  004e3	eb 4a		 jmp	 SHORT $LN1@clock_hres
$LN78@clock_hres:
  004e5	33 c0		 xor	 eax, eax
  004e7	85 c0		 test	 eax, eax
  004e9	75 d1		 jne	 SHORT $LN48@clock_hres

; 1455 :             break;

  004eb	eb 22		 jmp	 SHORT $LN8@clock_hres
$LN79@clock_hres:
$LN51@clock_hres:

; 1456 :         default:
; 1457 :             SR_READ_SKIP(file, len);

  004ed	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  004f1	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  004f9	e8 00 00 00 00	 call	 sr_read_skip
  004fe	85 c0		 test	 eax, eax
  00500	74 07		 je	 SHORT $LN80@clock_hres
  00502	b8 ff ff ff ff	 mov	 eax, -1
  00507	eb 26		 jmp	 SHORT $LN1@clock_hres
$LN80@clock_hres:
  00509	33 c0		 xor	 eax, eax
  0050b	85 c0		 test	 eax, eax
  0050d	75 de		 jne	 SHORT $LN51@clock_hres
$LN8@clock_hres:

; 1458 :             break;
; 1459 :         }
; 1460 :     } while ((key & SR_SYS_MASK) == SR_SYS_CLOCK);

  0050f	b8 00 f0 ff ff	 mov	 eax, -4096		; fffff000H
  00514	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00519	48 23 c8	 and	 rcx, rax
  0051c	48 8b c1	 mov	 rax, rcx
  0051f	b9 00 20 e1 ac	 mov	 ecx, -1394532352	; ace12000H
  00524	48 3b c1	 cmp	 rax, rcx
  00527	0f 84 66 fb ff
	ff		 je	 $LN4@clock_hres

; 1461 :     return 0;

  0052d	33 c0		 xor	 eax, eax
$LN1@clock_hres:

; 1462 : }

  0052f	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00537	48 33 cc	 xor	 rcx, rsp
  0053a	e8 00 00 00 00	 call	 __security_check_cookie
  0053f	48 81 c4 60 10
	00 00		 add	 rsp, 4192		; 00001060H
  00546	5f		 pop	 rdi
  00547	c3		 ret	 0
clock_hresume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
tv65 = 32
i$ = 36
buf$ = 48
__$ArrayPad$ = 4144
file$ = 4176
clock_hsuspend PROC

; 1369 : {

$LN57:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 48 10 00 00	 mov	 eax, 4168		; 00001048H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 30
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1370 :     int i;
; 1371 :     char buf[SR_MAX_STRING_LENGTH];
; 1372 : 
; 1373 :     i = (episode_current == &episode_new);

  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_new
  0002b	48 39 05 00 00
	00 00		 cmp	 QWORD PTR episode_current, rax
  00032	75 0a		 jne	 SHORT $LN55@clock_hsus
  00034	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  0003c	eb 08		 jmp	 SHORT $LN56@clock_hsus
$LN55@clock_hsus:
  0003e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN56@clock_hsus:
  00046	8b 44 24 20	 mov	 eax, DWORD PTR tv65[rsp]
  0004a	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@clock_hsus:

; 1374 :     SR_WRITE_VALUE(file, SR_SYS_CLOCK_CURRENT_CSR, i, sizeof(i));

  0004e	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00053	41 b9 04 00 00
	00		 mov	 r9d, 4
  00059	4c 8b c0	 mov	 r8, rax
  0005c	ba 01 20 e1 ac	 mov	 edx, -1394532351	; ace12001H
  00061	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00069	e8 00 00 00 00	 call	 sr_write_value
  0006e	85 c0		 test	 eax, eax
  00070	74 0a		 je	 SHORT $LN41@clock_hsus
  00072	b8 ff ff ff ff	 mov	 eax, -1
  00077	e9 8b 02 00 00	 jmp	 $LN1@clock_hsus
$LN41@clock_hsus:
  0007c	33 c0		 xor	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	75 cc		 jne	 SHORT $LN4@clock_hsus
$LN7@clock_hsus:

; 1375 :     SR_WRITE_VALUE(file, SR_SYS_CLOCK_UNIVERSAL_TOD, universal_tod.high, sizeof(universal_tod.high));

  00082	41 b9 08 00 00
	00		 mov	 r9d, 8
  00088	4c 8b 05 08 00
	00 00		 mov	 r8, QWORD PTR universal_tod+8
  0008f	ba 02 20 e1 ac	 mov	 edx, -1394532350	; ace12002H
  00094	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  0009c	e8 00 00 00 00	 call	 sr_write_value
  000a1	85 c0		 test	 eax, eax
  000a3	74 0a		 je	 SHORT $LN42@clock_hsus
  000a5	b8 ff ff ff ff	 mov	 eax, -1
  000aa	e9 58 02 00 00	 jmp	 $LN1@clock_hsus
$LN42@clock_hsus:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 cd		 jne	 SHORT $LN7@clock_hsus

; 1376 :     MSGBUF(buf, "%f", hw_steering);

  000b5	f2 0f 10 1d 00
	00 00 00	 movsd	 xmm3, QWORD PTR hw_steering
  000bd	66 49 0f 7e d9	 movq	 r9, xmm3
  000c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG202362
  000c9	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  000ce	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN10@clock_hsus:

; 1377 :     SR_WRITE_STRING(file, SR_SYS_CLOCK_HW_STEERING, buf);

  000d9	4c 8d 44 24 30	 lea	 r8, QWORD PTR buf$[rsp]
  000de	ba 04 20 e1 ac	 mov	 edx, -1394532348	; ace12004H
  000e3	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  000eb	e8 00 00 00 00	 call	 sr_write_string
  000f0	85 c0		 test	 eax, eax
  000f2	74 0a		 je	 SHORT $LN43@clock_hsus
  000f4	b8 ff ff ff ff	 mov	 eax, -1
  000f9	e9 09 02 00 00	 jmp	 $LN1@clock_hsus
$LN43@clock_hsus:
  000fe	33 c0		 xor	 eax, eax
  00100	85 c0		 test	 eax, eax
  00102	75 d5		 jne	 SHORT $LN10@clock_hsus
$LN13@clock_hsus:

; 1378 :     SR_WRITE_VALUE(file, SR_SYS_CLOCK_HW_EPISODE, hw_episode, sizeof(hw_episode));

  00104	41 b9 08 00 00
	00		 mov	 r9d, 8
  0010a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR hw_episode
  00111	ba 05 20 e1 ac	 mov	 edx, -1394532347	; ace12005H
  00116	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  0011e	e8 00 00 00 00	 call	 sr_write_value
  00123	85 c0		 test	 eax, eax
  00125	74 0a		 je	 SHORT $LN44@clock_hsus
  00127	b8 ff ff ff ff	 mov	 eax, -1
  0012c	e9 d6 01 00 00	 jmp	 $LN1@clock_hsus
$LN44@clock_hsus:
  00131	33 c0		 xor	 eax, eax
  00133	85 c0		 test	 eax, eax
  00135	75 cd		 jne	 SHORT $LN13@clock_hsus
$LN16@clock_hsus:

; 1379 :     SR_WRITE_VALUE(file, SR_SYS_CLOCK_HW_OFFSET, hw_offset, sizeof(hw_offset));

  00137	41 b9 08 00 00
	00		 mov	 r9d, 8
  0013d	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR hw_offset
  00144	ba 06 20 e1 ac	 mov	 edx, -1394532346	; ace12006H
  00149	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00151	e8 00 00 00 00	 call	 sr_write_value
  00156	85 c0		 test	 eax, eax
  00158	74 0a		 je	 SHORT $LN45@clock_hsus
  0015a	b8 ff ff ff ff	 mov	 eax, -1
  0015f	e9 a3 01 00 00	 jmp	 $LN1@clock_hsus
$LN45@clock_hsus:
  00164	33 c0		 xor	 eax, eax
  00166	85 c0		 test	 eax, eax
  00168	75 cd		 jne	 SHORT $LN16@clock_hsus
$LN19@clock_hsus:

; 1380 : 
; 1381 :     SR_WRITE_VALUE(file, SR_SYS_CLOCK_OLD_CSR_START_TIME,   episode_old.start_time,   sizeof(episode_old.start_time));

  0016a	41 b9 08 00 00
	00		 mov	 r9d, 8
  00170	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR episode_old
  00177	ba 01 21 e1 ac	 mov	 edx, -1394532095	; ace12101H
  0017c	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00184	e8 00 00 00 00	 call	 sr_write_value
  00189	85 c0		 test	 eax, eax
  0018b	74 0a		 je	 SHORT $LN46@clock_hsus
  0018d	b8 ff ff ff ff	 mov	 eax, -1
  00192	e9 70 01 00 00	 jmp	 $LN1@clock_hsus
$LN46@clock_hsus:
  00197	33 c0		 xor	 eax, eax
  00199	85 c0		 test	 eax, eax
  0019b	75 cd		 jne	 SHORT $LN19@clock_hsus
$LN22@clock_hsus:

; 1382 :     SR_WRITE_VALUE(file, SR_SYS_CLOCK_OLD_CSR_BASE_OFFSET,  episode_old.base_offset,  sizeof(episode_old.base_offset));

  0019d	41 b9 08 00 00
	00		 mov	 r9d, 8
  001a3	4c 8b 05 08 00
	00 00		 mov	 r8, QWORD PTR episode_old+8
  001aa	ba 02 21 e1 ac	 mov	 edx, -1394532094	; ace12102H
  001af	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  001b7	e8 00 00 00 00	 call	 sr_write_value
  001bc	85 c0		 test	 eax, eax
  001be	74 0a		 je	 SHORT $LN47@clock_hsus
  001c0	b8 ff ff ff ff	 mov	 eax, -1
  001c5	e9 3d 01 00 00	 jmp	 $LN1@clock_hsus
$LN47@clock_hsus:
  001ca	33 c0		 xor	 eax, eax
  001cc	85 c0		 test	 eax, eax
  001ce	75 cd		 jne	 SHORT $LN22@clock_hsus
$LN25@clock_hsus:

; 1383 :     SR_WRITE_VALUE(file, SR_SYS_CLOCK_OLD_CSR_FINE_S_RATE,  episode_old.fine_s_rate,  sizeof(episode_old.fine_s_rate));

  001d0	48 63 05 10 00
	00 00		 movsxd	 rax, DWORD PTR episode_old+16
  001d7	41 b9 04 00 00
	00		 mov	 r9d, 4
  001dd	4c 8b c0	 mov	 r8, rax
  001e0	ba 03 21 e1 ac	 mov	 edx, -1394532093	; ace12103H
  001e5	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  001ed	e8 00 00 00 00	 call	 sr_write_value
  001f2	85 c0		 test	 eax, eax
  001f4	74 0a		 je	 SHORT $LN48@clock_hsus
  001f6	b8 ff ff ff ff	 mov	 eax, -1
  001fb	e9 07 01 00 00	 jmp	 $LN1@clock_hsus
$LN48@clock_hsus:
  00200	33 c0		 xor	 eax, eax
  00202	85 c0		 test	 eax, eax
  00204	75 ca		 jne	 SHORT $LN25@clock_hsus
$LN28@clock_hsus:

; 1384 :     SR_WRITE_VALUE(file, SR_SYS_CLOCK_OLD_CSR_GROSS_S_RATE, episode_old.gross_s_rate, sizeof(episode_old.gross_s_rate));

  00206	48 63 05 14 00
	00 00		 movsxd	 rax, DWORD PTR episode_old+20
  0020d	41 b9 04 00 00
	00		 mov	 r9d, 4
  00213	4c 8b c0	 mov	 r8, rax
  00216	ba 04 21 e1 ac	 mov	 edx, -1394532092	; ace12104H
  0021b	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00223	e8 00 00 00 00	 call	 sr_write_value
  00228	85 c0		 test	 eax, eax
  0022a	74 0a		 je	 SHORT $LN49@clock_hsus
  0022c	b8 ff ff ff ff	 mov	 eax, -1
  00231	e9 d1 00 00 00	 jmp	 $LN1@clock_hsus
$LN49@clock_hsus:
  00236	33 c0		 xor	 eax, eax
  00238	85 c0		 test	 eax, eax
  0023a	75 ca		 jne	 SHORT $LN28@clock_hsus
$LN31@clock_hsus:

; 1385 : 
; 1386 :     SR_WRITE_VALUE(file, SR_SYS_CLOCK_NEW_CSR_START_TIME,   episode_new.start_time,   sizeof(episode_new.start_time));

  0023c	41 b9 08 00 00
	00		 mov	 r9d, 8
  00242	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR episode_new
  00249	ba 01 22 e1 ac	 mov	 edx, -1394531839	; ace12201H
  0024e	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00256	e8 00 00 00 00	 call	 sr_write_value
  0025b	85 c0		 test	 eax, eax
  0025d	74 0a		 je	 SHORT $LN50@clock_hsus
  0025f	b8 ff ff ff ff	 mov	 eax, -1
  00264	e9 9e 00 00 00	 jmp	 $LN1@clock_hsus
$LN50@clock_hsus:
  00269	33 c0		 xor	 eax, eax
  0026b	85 c0		 test	 eax, eax
  0026d	75 cd		 jne	 SHORT $LN31@clock_hsus
$LN34@clock_hsus:

; 1387 :     SR_WRITE_VALUE(file, SR_SYS_CLOCK_NEW_CSR_BASE_OFFSET,  episode_new.base_offset,  sizeof(episode_new.base_offset));

  0026f	41 b9 08 00 00
	00		 mov	 r9d, 8
  00275	4c 8b 05 08 00
	00 00		 mov	 r8, QWORD PTR episode_new+8
  0027c	ba 02 22 e1 ac	 mov	 edx, -1394531838	; ace12202H
  00281	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00289	e8 00 00 00 00	 call	 sr_write_value
  0028e	85 c0		 test	 eax, eax
  00290	74 07		 je	 SHORT $LN51@clock_hsus
  00292	b8 ff ff ff ff	 mov	 eax, -1
  00297	eb 6e		 jmp	 SHORT $LN1@clock_hsus
$LN51@clock_hsus:
  00299	33 c0		 xor	 eax, eax
  0029b	85 c0		 test	 eax, eax
  0029d	75 d0		 jne	 SHORT $LN34@clock_hsus
$LN37@clock_hsus:

; 1388 :     SR_WRITE_VALUE(file, SR_SYS_CLOCK_NEW_CSR_FINE_S_RATE,  episode_new.fine_s_rate,  sizeof(episode_new.fine_s_rate));

  0029f	48 63 05 10 00
	00 00		 movsxd	 rax, DWORD PTR episode_new+16
  002a6	41 b9 04 00 00
	00		 mov	 r9d, 4
  002ac	4c 8b c0	 mov	 r8, rax
  002af	ba 03 22 e1 ac	 mov	 edx, -1394531837	; ace12203H
  002b4	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  002bc	e8 00 00 00 00	 call	 sr_write_value
  002c1	85 c0		 test	 eax, eax
  002c3	74 07		 je	 SHORT $LN52@clock_hsus
  002c5	b8 ff ff ff ff	 mov	 eax, -1
  002ca	eb 3b		 jmp	 SHORT $LN1@clock_hsus
$LN52@clock_hsus:
  002cc	33 c0		 xor	 eax, eax
  002ce	85 c0		 test	 eax, eax
  002d0	75 cd		 jne	 SHORT $LN37@clock_hsus
$LN40@clock_hsus:

; 1389 :     SR_WRITE_VALUE(file, SR_SYS_CLOCK_NEW_CSR_GROSS_S_RATE, episode_new.gross_s_rate, sizeof(episode_new.gross_s_rate));

  002d2	48 63 05 14 00
	00 00		 movsxd	 rax, DWORD PTR episode_new+20
  002d9	41 b9 04 00 00
	00		 mov	 r9d, 4
  002df	4c 8b c0	 mov	 r8, rax
  002e2	ba 04 22 e1 ac	 mov	 edx, -1394531836	; ace12204H
  002e7	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  002ef	e8 00 00 00 00	 call	 sr_write_value
  002f4	85 c0		 test	 eax, eax
  002f6	74 07		 je	 SHORT $LN53@clock_hsus
  002f8	b8 ff ff ff ff	 mov	 eax, -1
  002fd	eb 08		 jmp	 SHORT $LN1@clock_hsus
$LN53@clock_hsus:
  002ff	33 c0		 xor	 eax, eax
  00301	85 c0		 test	 eax, eax
  00303	75 cd		 jne	 SHORT $LN40@clock_hsus

; 1390 : 
; 1391 :     return 0;

  00305	33 c0		 xor	 eax, eax
$LN1@clock_hsus:

; 1392 : }

  00307	48 8b 8c 24 30
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0030f	48 33 cc	 xor	 rcx, rsp
  00312	e8 00 00 00 00	 call	 __security_check_cookie
  00317	48 81 c4 48 10
	00 00		 add	 rsp, 4168		; 00001048H
  0031e	c3		 ret	 0
clock_hsuspend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
tod$ = 48
set_tod_clock PROC

; 822  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 823  :     set_tod_epoch(tod - hw_clock());

  00009	e8 00 00 00 00	 call	 hw_clock
  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tod$[rsp]
  00013	48 2b c8	 sub	 rcx, rax
  00016	48 8b c1	 mov	 rax, rcx
  00019	48 8b c8	 mov	 rcx, rax
  0001c	e8 00 00 00 00	 call	 set_tod_epoch

; 824  : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
set_tod_clock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
temp_tod$ = 32
hw_clock PROC

; 694  : {

$LN3:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 695  :     register TOD  temp_tod;
; 696  : 
; 697  :     obtain_lock( &sysblk.todlock );

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202038
  00018	48 8b c8	 mov	 rcx, rax
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 698  :     {
; 699  :         /* Get time of day (GMT); adjust speed and ensure uniqueness */
; 700  :         temp_tod = hw_clock_locked();

  00021	e8 00 00 00 00	 call	 hw_clock_locked
  00026	48 89 44 24 20	 mov	 QWORD PTR temp_tod$[rsp], rax

; 701  :     }
; 702  :     release_lock( &sysblk.todlock );

  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00032	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202039
  0003f	48 8b c8	 mov	 rcx, rax
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 703  : 
; 704  :     return temp_tod;

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR temp_tod$[rsp]

; 705  : }

  0004d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00051	c3		 ret	 0
hw_clock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
get_tod_epoch PROC

; 830  :     return tod_epoch;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR tod_epoch

; 831  : }

  00007	c3		 ret	 0
get_tod_epoch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
new_clock$ = 32
update_tod_clock PROC

; 1237 : {

$LN4:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1238 :     TOD new_clock;
; 1239 : 
; 1240 :     obtain_lock( &sysblk.todlock );

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00011	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202208
  00018	48 8b c8	 mov	 rcx, rax
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1241 :     {
; 1242 :         new_clock = hw_clock_locked();

  00021	e8 00 00 00 00	 call	 hw_clock_locked
  00026	48 89 44 24 20	 mov	 QWORD PTR new_clock$[rsp], rax

; 1243 : 
; 1244 :         /* If we are in the old episode, and the new episode has arrived
; 1245 :            then we must take action to start the new episode */
; 1246 :         if (episode_current == &episode_old)

  0002b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_old
  00032	48 39 05 00 00
	00 00		 cmp	 QWORD PTR episode_current, rax
  00039	75 05		 jne	 SHORT $LN2@update_tod

; 1247 :             start_new_episode();

  0003b	e8 00 00 00 00	 call	 start_new_episode
$LN2@update_tod:

; 1248 : 
; 1249 :         /* Set the clock to the new updated value with offset applied */
; 1250 :         new_clock += episode_current->base_offset;

  00040	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR episode_current
  00047	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR new_clock$[rsp]
  00050	48 03 c8	 add	 rcx, rax
  00053	48 8b c1	 mov	 rax, rcx
  00056	48 89 44 24 20	 mov	 QWORD PTR new_clock$[rsp], rax

; 1251 :         tod_value.high = new_clock;

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR new_clock$[rsp]
  00060	48 89 05 08 00
	00 00		 mov	 QWORD PTR tod_value+8, rax

; 1252 :         tod_value.low  = hw_tod.low;

  00067	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR hw_tod
  0006e	48 89 05 00 00
	00 00		 mov	 QWORD PTR tod_value, rax

; 1253 :     }
; 1254 :     release_lock( &sysblk.todlock );

  00075	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007c	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202210
  00089	48 8b c8	 mov	 rcx, rax
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1255 : 
; 1256 :     /* Update the timers and check if either a clock related event has
; 1257 :        become pending */
; 1258 :     update_cpu_timer();

  00092	e8 00 00 00 00	 call	 update_cpu_timer

; 1259 : 
; 1260 :     return new_clock;

  00097	48 8b 44 24 20	 mov	 rax, QWORD PTR new_clock$[rsp]

; 1261 : }

  0009c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a0	c3		 ret	 0
update_tod_clock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
get_tod_steering PROC

; 788  :     return hw_steering;

  00000	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR hw_steering

; 789  : }

  00008	c3		 ret	 0
get_tod_steering ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
steering$ = 48
set_tod_steering PROC

; 715  : {

$LN3:
  00000	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 716  :     obtain_lock( &sysblk.todlock );

  0000a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00011	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202043
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 717  :     {
; 718  :         /* Get current offset between hw_adjust and universal TOD value  */
; 719  :         hw_offset = hw_clock_locked() - universal_tod.high;

  00027	e8 00 00 00 00	 call	 hw_clock_locked
  0002c	48 2b 05 08 00
	00 00		 sub	 rax, QWORD PTR universal_tod+8
  00033	48 89 05 00 00
	00 00		 mov	 QWORD PTR hw_offset, rax

; 720  : 
; 721  :         hw_episode = hw_tod.high;

  0003a	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR hw_tod+8
  00041	48 89 05 00 00
	00 00		 mov	 QWORD PTR hw_episode, rax

; 722  :         hw_steering = steering;

  00048	f2 0f 10 44 24
	30		 movsd	 xmm0, QWORD PTR steering$[rsp]
  0004e	f2 0f 11 05 00
	00 00 00	 movsd	 QWORD PTR hw_steering, xmm0

; 723  :     }
; 724  :     release_lock( &sysblk.todlock );

  00056	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0005d	48 05 88 0b 00
	00		 add	 rax, 2952		; 00000b88H
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG202044
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 725  : }

  00073	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00077	c3		 ret	 0
set_tod_steering ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.c
_TEXT	SEGMENT
csr_reset PROC

; 585  : {

$LN3:
  00000	40 56		 push	 rsi
  00002	57		 push	 rdi

; 586  :     episode_new.start_time   = 0;

  00003	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR episode_new, 0

; 587  :     episode_new.base_offset  = 0;

  0000e	48 c7 05 08 00
	00 00 00 00 00
	00		 mov	 QWORD PTR episode_new+8, 0

; 588  :     episode_new.fine_s_rate  = 0;

  00019	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR episode_new+16, 0

; 589  :     episode_new.gross_s_rate = 0;

  00023	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR episode_new+20, 0

; 590  : 
; 591  :     episode_current = &episode_new;

  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_new
  00034	48 89 05 00 00
	00 00		 mov	 QWORD PTR episode_current, rax

; 592  : 
; 593  :     episode_old = episode_new;

  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:episode_old
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:episode_new
  00049	48 8b f8	 mov	 rdi, rax
  0004c	48 8b f1	 mov	 rsi, rcx
  0004f	b9 18 00 00 00	 mov	 ecx, 24
  00054	f3 a4		 rep movsb

; 594  : }

  00056	5f		 pop	 rdi
  00057	5e		 pop	 rsi
  00058	c3		 ret	 0
csr_reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
