; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	cckd_dasd_close_device
PUBLIC	cckd_read_track
PUBLIC	cckd_update_track
PUBLIC	cfba_read_block
PUBLIC	cfba_write_block
PUBLIC	cckd_dasd_device_hndinfo
PUBLIC	cfba_dasd_device_hndinfo
PUBLIC	gctab
PUBLIC	compname
PUBLIC	empty_l2
PUBLIC	empty64_l2
PUBLIC	cckd_dasd_start
PUBLIC	cckd_dasd_end
PUBLIC	cckd_used
PUBLIC	cfba_used
EXTRN	ckd_dasd_init_handler:PROC
EXTRN	ckd_dasd_execute_ccw:PROC
EXTRN	ckd_dasd_query_device:PROC
EXTRN	ckd_dasd_hsuspend:PROC
EXTRN	ckd_dasd_hresume:PROC
EXTRN	fba_dasd_init_handler:PROC
EXTRN	fba_dasd_execute_ccw:PROC
EXTRN	fba_dasd_query_device:PROC
EXTRN	fba_dasd_hsuspend:PROC
_DATA	SEGMENT
COMM	cckdblk:BYTE:0320H
_DATA	ENDS
_BSS	SEGMENT
empty_l2 DQ	0300H DUP (?)
empty64_l2 DB	03000H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
cckd_dasd_device_hndinfo DQ FLAT:ckd_dasd_init_handler
	DQ	FLAT:ckd_dasd_execute_ccw
	DQ	FLAT:cckd_dasd_close_device
	DQ	FLAT:ckd_dasd_query_device
	DQ	0000000000000000H
	DQ	FLAT:cckd_dasd_start
	DQ	FLAT:cckd_dasd_end
	DQ	FLAT:cckd_dasd_start
	DQ	FLAT:cckd_dasd_end
	DQ	0000000000000000H
	DQ	FLAT:cckd_read_track
	DQ	FLAT:cckd_update_track
	DQ	FLAT:cckd_used
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:ckd_dasd_hsuspend
	DQ	FLAT:ckd_dasd_hresume
gctab	DD	01000H
	DD	0800H
	DD	0400H
	DD	0200H
	DD	0100H
	ORG $+4
cfba_dasd_device_hndinfo DQ FLAT:fba_dasd_init_handler
	DQ	FLAT:fba_dasd_execute_ccw
	DQ	FLAT:cckd_dasd_close_device
	DQ	FLAT:fba_dasd_query_device
	DQ	0000000000000000H
	DQ	FLAT:cckd_dasd_start
	DQ	FLAT:cckd_dasd_end
	DQ	FLAT:cckd_dasd_start
	DQ	FLAT:cckd_dasd_end
	DQ	0000000000000000H
	DQ	FLAT:cfba_read_block
	DQ	FLAT:cfba_write_block
	DQ	FLAT:cfba_used
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:fba_dasd_hsuspend
	DQ	FLAT:ckd_dasd_hresume
compname DQ	FLAT:$SG169496
	DQ	FLAT:$SG169497
	DQ	FLAT:$SG169498
$SG169496 DB	'none', 00H
	ORG $+3
$SG169497 DB	'zlib', 00H
	ORG $+3
$SG169498 DB	'bzip2', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	cckd_dasd_init_handler
PUBLIC	cckd_dasd_init
PUBLIC	cckd_dasd_term_if_appropriate
PUBLIC	cckd_open
PUBLIC	cckd_close
PUBLIC	cckd_read
PUBLIC	cckd_write
PUBLIC	cckd_ftruncate
PUBLIC	cckd_malloc
PUBLIC	cckd_calloc
PUBLIC	cckd_realloc
PUBLIC	cckd_free
PUBLIC	cckd_read_trk
PUBLIC	cckd_readahead
PUBLIC	cckd_readahead_scan
PUBLIC	cckd_ra
PUBLIC	cckd_flush_cache
PUBLIC	cckd_flush_cache_scan
PUBLIC	cckd_flush_cache_all
PUBLIC	cckd_purge_cache
PUBLIC	cckd_purge_cache_scan
PUBLIC	cckd_writer
PUBLIC	cckd_writer_scan
PUBLIC	cckd_writer_write
PUBLIC	cckd_get_space
PUBLIC	cckd_rel_space
PUBLIC	cckd_flush_space
PUBLIC	cckd_read_chdr
PUBLIC	cckd_write_chdr
PUBLIC	cckd_read_l1
PUBLIC	cckd_write_l1
PUBLIC	cckd_write_l1ent
PUBLIC	cckd_read_init
PUBLIC	cckd_read_fsp
PUBLIC	cckd_write_fsp
PUBLIC	cckd_read_l2
PUBLIC	cckd_purge_l2
PUBLIC	cckd_purge_l2_scan
PUBLIC	cckd_steal_l2
PUBLIC	cckd_steal_l2_scan
PUBLIC	cckd_write_l2
PUBLIC	cckd_read_l2ent
PUBLIC	cckd_write_l2ent
PUBLIC	cckd_read_trkimg
PUBLIC	cckd_write_trkimg
PUBLIC	cckd_harden
PUBLIC	cckd_trklen
PUBLIC	cckd_null_trk
PUBLIC	cckd_check_null_trk
PUBLIC	cckd_cchh
PUBLIC	cckd_validate
PUBLIC	cckd_sf_parse_sfn
PUBLIC	cckd_sf_name
PUBLIC	cckd_sf_init
PUBLIC	cckd_sf_new
PUBLIC	cckd_lock_devchain
PUBLIC	cckd_unlock_devchain
PUBLIC	cckd_gcstart
PUBLIC	cckd_gcol
PUBLIC	cckd_gcol_dev
PUBLIC	cckd_gc_state
PUBLIC	cckd_gc_rpt_state
PUBLIC	cckd_gc_percolate
PUBLIC	cckd_gc_l2
PUBLIC	cckd_find_device_by_devnum
PUBLIC	cckd_uncompress
PUBLIC	cckd_uncompress_zlib
PUBLIC	cckd_uncompress_bzip2
PUBLIC	cckd_compress
PUBLIC	cckd_compress_none
PUBLIC	cckd_compress_zlib
PUBLIC	cckd_compress_bzip2
PUBLIC	cckd_command
PUBLIC	cckd_command_help
PUBLIC	cckd_command_opts
PUBLIC	cckd_command_stats
PUBLIC	cckd_trace
PUBLIC	cckd_print_itrace
PUBLIC	cckd_dtax
PUBLIC	cckd_sf_add
PUBLIC	cckd_sf_remove
PUBLIC	cckd_sf_comp
PUBLIC	cckd_sf_chk
PUBLIC	cckd_sf_stats
PUBLIC	cckd_gc_rpt_states
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	strrchr:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	abs:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp__chsize_s:PROC
EXTRN	__imp__commit:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp_unlink:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp__ctime64:PROC
EXTRN	__imp__fstat64:PROC
EXTRN	__imp__stat64:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_destroy_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_destroy_condition:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_broadcast_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_timed_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_set_thread_prio:PROC
EXTRN	__imp_hthread_get_thread_prio:PROC
EXTRN	__imp_hthread_set_lock_name:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_timed_wait_condition_relative_usecs_impl:PROC
EXTRN	__imp_trimloc:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_gettimeofday:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_get_file_accmode_flags:PROC
EXTRN	__imp_w32_vsnprintf:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	cache_busy:PROC
EXTRN	cache_waiters:PROC
EXTRN	cache_busy_percent:PROC
EXTRN	cache_lookup:PROC
EXTRN	cache_scan:PROC
EXTRN	cache_lock:PROC
EXTRN	cache_unlock:PROC
EXTRN	cache_wait:PROC
EXTRN	cache_getkey:PROC
EXTRN	cache_setkey:PROC
EXTRN	cache_getflag:PROC
EXTRN	cache_setflag:PROC
EXTRN	cache_getage:PROC
EXTRN	cache_setage:PROC
EXTRN	cache_getbuf:PROC
EXTRN	cache_setbuf:PROC
EXTRN	cache_getlen:PROC
EXTRN	cache_getval:PROC
EXTRN	cache_setval:PROC
EXTRN	cache_release:PROC
EXTRN	shared_update_notify:PROC
EXTRN	ckd_build_sense:PROC
EXTRN	cckd64_dasd_close_device:PROC
EXTRN	cckd_swapend:PROC
EXTRN	cckd_swapend_chdr:PROC
EXTRN	cckd_swapend_l1:PROC
EXTRN	cckd_swapend_l2:PROC
EXTRN	cckd_def_opt_bigend:PROC
EXTRN	cckd_comp:PROC
EXTRN	cckd_chkdsk:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	ckd_tracklen:PROC
EXTRN	dh_devid_typ:PROC
EXTRN	is_dh_devid_typ:PROC
EXTRN	cckd64_dasd_start:PROC
EXTRN	cckd64_dasd_end:PROC
EXTRN	cckd64_used:PROC
EXTRN	cfba64_used:PROC
EXTRN	cckd64_read_trk:PROC
EXTRN	cckd64_flush_cache:PROC
EXTRN	cckd64_purge_cache:PROC
EXTRN	cckd64_writer_write:PROC
EXTRN	cckd64_get_space:PROC
EXTRN	cckd64_rel_space:PROC
EXTRN	cckd64_flush_space:PROC
EXTRN	cckd64_read_chdr:PROC
EXTRN	cckd64_write_chdr:PROC
EXTRN	cckd64_read_l1:PROC
EXTRN	cckd64_write_l1:PROC
EXTRN	cckd64_write_l1ent:PROC
EXTRN	cckd64_read_init:PROC
EXTRN	cckd64_read_fsp:PROC
EXTRN	cckd64_write_fsp:PROC
EXTRN	cckd64_read_l2:PROC
EXTRN	cckd64_purge_l2:PROC
EXTRN	cckd64_steal_l2:PROC
EXTRN	cckd64_write_l2:PROC
EXTRN	cckd64_read_l2ent:PROC
EXTRN	cckd64_write_l2ent:PROC
EXTRN	cckd64_write_trkimg:PROC
EXTRN	cckd64_harden:PROC
EXTRN	cckd64_null_trk:PROC
EXTRN	cckd64_check_null_trk:PROC
EXTRN	cckd64_sf_init:PROC
EXTRN	cckd64_sf_new:PROC
EXTRN	cckd64_gcstart:PROC
EXTRN	cckd64_gcol_dev:PROC
EXTRN	cckd64_gc_state:PROC
EXTRN	cckd64_gc_rpt_state:PROC
EXTRN	cckd64_gc_percolate:PROC
EXTRN	cckd64_sf_remove:PROC
EXTRN	cckd64_sf_comp:PROC
EXTRN	cckd64_sf_chk:PROC
EXTRN	cckd64_sf_stats:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	ckd_dasd_device_hndinfo:BYTE
EXTRN	fba_dasd_device_hndinfo:BYTE
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG169694 DB	01H DUP (?)
	ALIGN	4

$SG171123 DB	01H DUP (?)
	ALIGN	4

$SG171591 DB	01H DUP (?)
	ALIGN	4

$SG171596 DB	01H DUP (?)
	ALIGN	4

$SG171607 DB	01H DUP (?)
	ALIGN	4

$SG171907 DB	01H DUP (?)
	ALIGN	4

$SG171930 DB	01H DUP (?)
	ALIGN	4

$SG171943 DB	01H DUP (?)
	ALIGN	4

$SG171950 DB	01H DUP (?)
	ALIGN	4

$SG171996 DB	01H DUP (?)
	ALIGN	4

$SG172373 DB	01H DUP (?)
	ALIGN	4

$SG172379 DB	01H DUP (?)
	ALIGN	4

$SG172385 DB	01H DUP (?)
	ALIGN	4

$SG172572 DB	01H DUP (?)
	ALIGN	4

$SG172618 DB	01H DUP (?)
	ALIGN	4

$SG172647 DB	01H DUP (?)
	ALIGN	4

$SG172845 DB	01H DUP (?)
	ALIGN	4

$SG172853 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$ctime DD	imagerel ctime
	DD	imagerel ctime+25
	DD	imagerel $unwind$ctime
$pdata$strcaseabbrev DD imagerel strcaseabbrev
	DD	imagerel strcaseabbrev+320
	DD	imagerel $unwind$strcaseabbrev
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$cckd_dasd_init_handler DD imagerel $LN40
	DD	imagerel $LN40+1435
	DD	imagerel $unwind$cckd_dasd_init_handler
$pdata$cckd_dasd_close_device DD imagerel $LN32
	DD	imagerel $LN32+1695
	DD	imagerel $unwind$cckd_dasd_close_device
$pdata$cckd_read_track DD imagerel $LN12
	DD	imagerel $LN12+1180
	DD	imagerel $unwind$cckd_read_track
$pdata$cckd_update_track DD imagerel $LN10
	DD	imagerel $LN10+640
	DD	imagerel $unwind$cckd_update_track
$pdata$cfba_read_block DD imagerel $LN11
	DD	imagerel $LN11+1025
	DD	imagerel $unwind$cfba_read_block
$pdata$cfba_write_block DD imagerel $LN10
	DD	imagerel $LN10+385
	DD	imagerel $unwind$cfba_write_block
$pdata$cckd_dasd_init DD imagerel $LN19
	DD	imagerel $LN19+974
	DD	imagerel $unwind$cckd_dasd_init
$pdata$cckd_dasd_term_if_appropriate DD imagerel $LN10
	DD	imagerel $LN10+408
	DD	imagerel $unwind$cckd_dasd_term_if_appropriate
$pdata$cckd_dasd_start DD imagerel $LN17
	DD	imagerel $LN17+848
	DD	imagerel $unwind$cckd_dasd_start
$pdata$cckd_dasd_end DD imagerel $LN10
	DD	imagerel $LN10+468
	DD	imagerel $unwind$cckd_dasd_end
$pdata$cckd_open DD imagerel $LN18
	DD	imagerel $LN18+1028
	DD	imagerel $unwind$cckd_open
$pdata$cckd_close DD imagerel $LN10
	DD	imagerel $LN10+546
	DD	imagerel $unwind$cckd_close
$pdata$cckd_read DD imagerel $LN19
	DD	imagerel $LN19+1219
	DD	imagerel $unwind$cckd_read
$pdata$cckd_write DD imagerel $LN19
	DD	imagerel $LN19+1227
	DD	imagerel $unwind$cckd_write
$pdata$cckd_ftruncate DD imagerel $LN8
	DD	imagerel $LN8+460
	DD	imagerel $unwind$cckd_ftruncate
$pdata$cckd_malloc DD imagerel $LN9
	DD	imagerel $LN9+430
	DD	imagerel $unwind$cckd_malloc
$pdata$cckd_calloc DD imagerel $LN9
	DD	imagerel $LN9+482
	DD	imagerel $unwind$cckd_calloc
$pdata$cckd_realloc DD imagerel $LN9
	DD	imagerel $LN9+457
	DD	imagerel $unwind$cckd_realloc
$pdata$cckd_free DD imagerel $LN4
	DD	imagerel $LN4+94
	DD	imagerel $unwind$cckd_free
$pdata$cckd_used DD imagerel $LN15
	DD	imagerel $LN15+370
	DD	imagerel $unwind$cckd_used
$pdata$cfba_used DD imagerel $LN15
	DD	imagerel $LN15+359
	DD	imagerel $unwind$cfba_used
$pdata$cckd_read_trk DD imagerel $LN35
	DD	imagerel $LN35+3065
	DD	imagerel $unwind$cckd_read_trk
$pdata$cckd_readahead DD imagerel $LN24
	DD	imagerel $LN24+1209
	DD	imagerel $unwind$cckd_readahead
$pdata$cckd_readahead_scan DD imagerel $LN14
	DD	imagerel $LN14+208
	DD	imagerel $unwind$cckd_readahead_scan
$pdata$cckd_ra DD imagerel $LN35
	DD	imagerel $LN35+1997
	DD	imagerel $unwind$cckd_ra
$pdata$cckd_flush_cache DD imagerel $LN11
	DD	imagerel $LN11+620
	DD	imagerel $unwind$cckd_flush_cache
$pdata$cckd_flush_cache_scan DD imagerel $LN10
	DD	imagerel $LN10+310
	DD	imagerel $unwind$cckd_flush_cache_scan
$pdata$cckd_flush_cache_all DD imagerel $LN7
	DD	imagerel $LN7+183
	DD	imagerel $unwind$cckd_flush_cache_all
$pdata$cckd_purge_cache DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$cckd_purge_cache
$pdata$cckd_purge_cache_scan DD imagerel $LN10
	DD	imagerel $LN10+189
	DD	imagerel $unwind$cckd_purge_cache_scan
$pdata$cckd_writer DD imagerel $LN32
	DD	imagerel $LN32+1823
	DD	imagerel $unwind$cckd_writer
$pdata$cckd_writer_scan DD imagerel $LN8
	DD	imagerel $LN8+156
	DD	imagerel $unwind$cckd_writer_scan
$pdata$cckd_writer_write DD imagerel $LN28
	DD	imagerel $LN28+2215
	DD	imagerel $unwind$cckd_writer_write
$pdata$cckd_get_space DD imagerel $LN34
	DD	imagerel $LN34+2256
	DD	imagerel $unwind$cckd_get_space
$pdata$cckd_rel_space DD imagerel $LN27
	DD	imagerel $LN27+1656
	DD	imagerel $unwind$cckd_rel_space
$pdata$cckd_flush_space DD imagerel $LN25
	DD	imagerel $LN25+2131
	DD	imagerel $unwind$cckd_flush_space
$pdata$cckd_read_chdr DD imagerel $LN12
	DD	imagerel $LN12+629
	DD	imagerel $unwind$cckd_read_chdr
$pdata$cckd_write_chdr DD imagerel $LN5
	DD	imagerel $LN5+299
	DD	imagerel $unwind$cckd_write_chdr
$pdata$cckd_read_l1 DD imagerel $LN18
	DD	imagerel $LN18+881
	DD	imagerel $unwind$cckd_read_l1
$pdata$cckd_write_l1 DD imagerel $LN5
	DD	imagerel $LN5+225
	DD	imagerel $unwind$cckd_write_l1
$pdata$cckd_write_l1ent DD imagerel $LN5
	DD	imagerel $LN5+230
	DD	imagerel $unwind$cckd_write_l1ent
$pdata$cckd_read_init DD imagerel $LN18
	DD	imagerel $LN18+674
	DD	imagerel $unwind$cckd_read_init
$pdata$cckd_read_fsp DD imagerel $LN29
	DD	imagerel $LN29+1711
	DD	imagerel $unwind$cckd_read_fsp
$pdata$cckd_write_fsp DD imagerel $LN30
	DD	imagerel $LN30+1355
	DD	imagerel $unwind$cckd_write_fsp
$pdata$cckd_read_l2 DD imagerel $LN19
	DD	imagerel $LN19+1621
	DD	imagerel $unwind$cckd_read_l2
$pdata$cckd_purge_l2 DD imagerel $LN4
	DD	imagerel $LN4+199
	DD	imagerel $unwind$cckd_purge_l2
$pdata$cckd_purge_l2_scan DD imagerel $LN11
	DD	imagerel $LN11+259
	DD	imagerel $unwind$cckd_purge_l2_scan
$pdata$cckd_steal_l2 DD imagerel $LN7
	DD	imagerel $LN7+253
	DD	imagerel $unwind$cckd_steal_l2
$pdata$cckd_steal_l2_scan DD imagerel $LN9
	DD	imagerel $LN9+114
	DD	imagerel $unwind$cckd_steal_l2_scan
$pdata$cckd_write_l2 DD imagerel $LN13
	DD	imagerel $LN13+592
	DD	imagerel $unwind$cckd_write_l2
$pdata$cckd_read_l2ent DD imagerel $LN18
	DD	imagerel $LN18+740
	DD	imagerel $unwind$cckd_read_l2ent
$pdata$cckd_write_l2ent DD imagerel $LN9
	DD	imagerel $LN9+524
	DD	imagerel $unwind$cckd_write_l2ent
$pdata$cckd_read_trkimg DD imagerel $LN10
	DD	imagerel $LN10+461
	DD	imagerel $unwind$cckd_read_trkimg
$pdata$cckd_write_trkimg DD imagerel $LN12
	DD	imagerel $LN12+1184
	DD	imagerel $unwind$cckd_write_trkimg
$pdata$cckd_harden DD imagerel $LN12
	DD	imagerel $LN12+371
	DD	imagerel $unwind$cckd_harden
$pdata$cckd_trklen DD imagerel $LN10
	DD	imagerel $LN10+544
	DD	imagerel $unwind$cckd_trklen
$pdata$cckd_null_trk DD imagerel $LN18
	DD	imagerel $LN18+1171
	DD	imagerel $unwind$cckd_null_trk
$pdata$cckd_check_null_trk DD imagerel $LN11
	DD	imagerel $LN11+367
	DD	imagerel $unwind$cckd_check_null_trk
$pdata$cckd_cchh DD imagerel $LN44
	DD	imagerel $LN44+2775
	DD	imagerel $unwind$cckd_cchh
$pdata$cckd_validate DD imagerel $LN23
	DD	imagerel $LN23+1661
	DD	imagerel $unwind$cckd_validate
$pdata$cckd_sf_parse_sfn DD imagerel $LN8
	DD	imagerel $LN8+381
	DD	imagerel $unwind$cckd_sf_parse_sfn
$pdata$cckd_sf_init DD imagerel $LN46
	DD	imagerel $LN46+1948
	DD	imagerel $unwind$cckd_sf_init
$pdata$cckd_sf_new DD imagerel $LN21
	DD	imagerel $LN21+1665
	DD	imagerel $unwind$cckd_sf_new
$pdata$cckd_lock_devchain DD imagerel $LN9
	DD	imagerel $LN9+179
	DD	imagerel $unwind$cckd_lock_devchain
$pdata$cckd_unlock_devchain DD imagerel $LN6
	DD	imagerel $LN6+126
	DD	imagerel $unwind$cckd_unlock_devchain
$pdata$cckd_gcstart DD imagerel $LN13
	DD	imagerel $LN13+790
	DD	imagerel $unwind$cckd_gcstart
$pdata$cckd_gcol DD imagerel $LN26
	DD	imagerel $LN26+1476
	DD	imagerel $unwind$cckd_gcol
$pdata$cckd_gcol_dev DD imagerel $LN20
	DD	imagerel $LN20+1090
	DD	imagerel $unwind$cckd_gcol_dev
$pdata$cckd_gc_state DD imagerel $LN15
	DD	imagerel $LN15+452
	DD	imagerel $unwind$cckd_gc_state
$pdata$cckd_gc_rpt_state DD imagerel $LN24
	DD	imagerel $LN24+879
	DD	imagerel $unwind$cckd_gc_rpt_state
$pdata$cckd_gc_percolate DD imagerel $LN95
	DD	imagerel $LN95+5213
	DD	imagerel $unwind$cckd_gc_percolate
$pdata$cckd_find_device_by_devnum DD imagerel $LN7
	DD	imagerel $LN7+105
	DD	imagerel $unwind$cckd_find_device_by_devnum
$pdata$cckd_uncompress DD imagerel $LN27
	DD	imagerel $LN27+2017
	DD	imagerel $unwind$cckd_uncompress
$pdata$cckd_compress DD imagerel $LN9
	DD	imagerel $LN9+218
	DD	imagerel $unwind$cckd_compress
$pdata$cckd_compress_zlib DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$cckd_compress_zlib
$pdata$cckd_compress_bzip2 DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$cckd_compress_bzip2
$pdata$cckd_command DD imagerel $LN129
	DD	imagerel $LN129+4673
	DD	imagerel $unwind$cckd_command
$pdata$cckd_command_help DD imagerel $LN6
	DD	imagerel $LN6+534
	DD	imagerel $unwind$cckd_command_help
$pdata$cckd_command_opts DD imagerel $LN5
	DD	imagerel $LN5+465
	DD	imagerel $unwind$cckd_command_opts
$pdata$cckd_command_stats DD imagerel $LN3
	DD	imagerel $LN3+1140
	DD	imagerel $unwind$cckd_command_stats
$pdata$cckd_trace DD imagerel $LN21
	DD	imagerel $LN21+876
	DD	imagerel $unwind$cckd_trace
$pdata$cckd_print_itrace DD imagerel $LN10
	DD	imagerel $LN10+425
	DD	imagerel $unwind$cckd_print_itrace
$pdata$cckd_dtax DD imagerel $LN7
	DD	imagerel $LN7+70
	DD	imagerel $unwind$cckd_dtax
$pdata$cckd_sf_add DD imagerel $LN38
	DD	imagerel $LN38+1866
	DD	imagerel $unwind$cckd_sf_add
$pdata$cckd_sf_remove DD imagerel $LN111
	DD	imagerel $LN111+6532
	DD	imagerel $unwind$cckd_sf_remove
$pdata$cckd_sf_comp DD imagerel $LN27
	DD	imagerel $LN27+1341
	DD	imagerel $unwind$cckd_sf_comp
$pdata$cckd_sf_chk DD imagerel $LN27
	DD	imagerel $LN27+1436
	DD	imagerel $unwind$cckd_sf_chk
$pdata$cckd_sf_stats DD imagerel $LN80
	DD	imagerel $LN80+4347
	DD	imagerel $unwind$cckd_sf_stats
$pdata$cckd_gc_rpt_states DD imagerel $LN7
	DD	imagerel $LN7+122
	DD	imagerel $unwind$cckd_gc_rpt_states
$pdata$cckd_gc_perc_error DD imagerel cckd_gc_perc_error
	DD	imagerel cckd_gc_perc_error+92
	DD	imagerel $unwind$cckd_gc_perc_error
$pdata$cckd_gc_perc_space_error DD imagerel cckd_gc_perc_space_error
	DD	imagerel cckd_gc_perc_space_error+714
	DD	imagerel $unwind$cckd_gc_perc_space_error
pdata	ENDS
_DATA	SEGMENT
	ORG $+2
$SG169523 DB	'CCKDBLK ', 00H
	ORG $+3
$SG169595 DB	'ext', 00H
$SG169524 DB	'CCKDBLK ', 00H
	ORG $+3
$SG169609 DB	'E', 00H
	ORG $+2
$SG169525 DB	'cckddasd.c:70', 00H
	ORG $+2
$SG169526 DB	'&cckdblk.gclock', 00H
$SG169527 DB	'cckddasd.c:71', 00H
	ORG $+2
$SG169528 DB	'&cckdblk.ralock', 00H
$SG169529 DB	'cckddasd.c:72', 00H
	ORG $+2
$SG169530 DB	'&cckdblk.wrlock', 00H
$SG169531 DB	'cckddasd.c:73', 00H
	ORG $+2
$SG169532 DB	'&cckdblk.devlock', 00H
	ORG $+3
$SG169656 DB	'W', 00H
	ORG $+2
$SG169533 DB	'cckddasd.c:74', 00H
	ORG $+2
$SG169534 DB	'&cckdblk.trclock', 00H
	ORG $+3
$SG169662 DB	'newbuf', 00H
	ORG $+1
$SG169667 DB	'l1', 00H
	ORG $+1
$SG169535 DB	'cckddasd.c:76', 00H
	ORG $+2
$SG169536 DB	'cckddasd.c:77', 00H
	ORG $+2
$SG169537 DB	'cckddasd.c:78', 00H
	ORG $+2
$SG169538 DB	'cckddasd.c:79', 00H
	ORG $+2
$SG169539 DB	'cckddasd.c:80', 00H
	ORG $+2
$SG169547 DB	'cckddasd.c:150', 00H
	ORG $+1
$SG169549 DB	'cckddasd.c:155', 00H
	ORG $+1
$SG169550 DB	'cckddasd.c:160', 00H
	ORG $+1
$SG169551 DB	'cckddasd.c:163', 00H
	ORG $+1
$SG169552 DB	'cckddasd.c:168', 00H
	ORG $+1
$SG169553 DB	'cckddasd.c:169', 00H
	ORG $+1
$SG169554 DB	'cckddasd.c:172', 00H
	ORG $+1
$SG169555 DB	'cckddasd.c:175', 00H
	ORG $+1
$SG169556 DB	'cckddasd.c:180', 00H
	ORG $+1
$SG169557 DB	'cckddasd.c:181', 00H
	ORG $+1
$SG169558 DB	'cckddasd.c:184', 00H
	ORG $+1
$SG169559 DB	'cckddasd.c:187', 00H
	ORG $+1
$SG169560 DB	'cckddasd.c:192', 00H
	ORG $+1
$SG169561 DB	'cckddasd.c:193', 00H
	ORG $+1
$SG169562 DB	'cckddasd.c:196', 00H
	ORG $+1
$SG169594 DB	'CCKDBLK ', 00H
	ORG $+3
$SG169674 DB	'ext', 00H
$SG169597 DB	'cckddasd.c:225', 00H
	ORG $+1
$SG169598 DB	'&cckd->cckdiolock', 00H
	ORG $+2
$SG169738 DB	'open()', 00H
	ORG $+1
$SG169739 DB	'E', 00H
	ORG $+2
$SG169599 DB	'&cckd->cckdiolock %1d:%04X', 00H
	ORG $+1
$SG169759 DB	'E', 00H
	ORG $+2
$SG169600 DB	'cckddasd.c:229', 00H
	ORG $+1
$SG169601 DB	'&cckd->filelock', 00H
$SG169602 DB	'&cckd->filelock %1d:%04X', 00H
	ORG $+3
$SG169783 DB	'E', 00H
	ORG $+2
$SG169603 DB	'cckddasd.c:233', 00H
	ORG $+1
$SG169604 DB	'cckddasd.c:236', 00H
	ORG $+1
$SG169610 DB	'HHC00300%s %1d:%04X CCKD file: error initializing shadow'
	DB	' files', 0aH, 00H
$SG169611 DB	'cckd_dasd_init_handler', 00H
	ORG $+1
$SG169612 DB	'cckddasd.c', 00H
	ORG $+1
$SG169791 DB	'E', 00H
	ORG $+2
$SG169615 DB	'cckddasd.c:272', 00H
	ORG $+1
$SG169644 DB	'cckddasd.c:308', 00H
	ORG $+1
$SG169645 DB	'cckddasd.c:312', 00H
	ORG $+1
$SG169646 DB	'cckddasd.c:314', 00H
	ORG $+1
$SG169647 DB	'cckddasd.c:316', 00H
	ORG $+1
$SG169648 DB	'cckddasd.c:319', 00H
	ORG $+1
$SG169650 DB	'cckddasd.c:327', 00H
	ORG $+1
$SG169654 DB	'closing device while wrpending=%d cckdioact=%d', 00H
	ORG $+1
$SG169655 DB	'cckd_dasd_close_device', 00H
	ORG $+1
$SG169657 DB	'HHC00381%s %1d:%04X CCKD file %s: closing device while w'
	DB	'rpending=%d cckdioact=%d', 0aH, 00H
	ORG $+2
$SG169790 DB	'read()', 00H
	ORG $+1
$SG169797 DB	'E', 00H
	ORG $+2
$SG169658 DB	'cckd_dasd_close_device', 00H
	ORG $+1
$SG169659 DB	'cckddasd.c', 00H
	ORG $+1
$SG169820 DB	'E', 00H
	ORG $+2
$SG169660 DB	'cckddasd.c:347', 00H
	ORG $+1
$SG169663 DB	'cckddasd.c:355', 00H
	ORG $+1
$SG169666 DB	'cckddasd.c:373', 00H
	ORG $+1
$SG169671 DB	'cckddasd.c:398', 00H
	ORG $+1
$SG169672 DB	'cckddasd.c:401', 00H
	ORG $+1
$SG169673 DB	'cckddasd.c:402', 00H
	ORG $+1
$SG169690 DB	'start i/o file[%d] bufcur %d cache[%d]', 00H
	ORG $+1
$SG169691 DB	'cckd_dasd_start', 00H
$SG169692 DB	'cckddasd.c:448', 00H
	ORG $+1
$SG169695 DB	'start i/o waiting for merge%s', 00H
	ORG $+2
$SG169696 DB	'cckd_dasd_start', 00H
$SG169697 DB	'cckddasd.c:455', 00H
	ORG $+1
$SG169703 DB	'cckddasd.c:480', 00H
	ORG $+1
$SG169704 DB	'cckddasd.c:488', 00H
	ORG $+1
$SG169711 DB	'end i/o bufcur %d cache[%d] waiters %d', 00H
	ORG $+1
$SG169712 DB	'cckd_dasd_end', 00H
	ORG $+2
$SG169713 DB	'cckddasd.c:521', 00H
	ORG $+1
$SG169719 DB	'cckddasd.c:537', 00H
	ORG $+1
$SG169720 DB	'cckddasd.c:539', 00H
	ORG $+1
$SG169743 DB	'file[%d] fd[%d] open %s error flags %8.8x mode %8.8x', 00H
	ORG $+3
$SG169740 DB	'HHC00301%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s: %s', 0aH, 00H
$SG169741 DB	'cckd_open', 00H
	ORG $+2
$SG169796 DB	'read()', 00H
	ORG $+1
$SG169828 DB	'E', 00H
	ORG $+2
$SG169742 DB	'cckddasd.c', 00H
	ORG $+1
$SG169834 DB	'E', 00H
	ORG $+2
$SG169744 DB	'cckd_open', 00H
	ORG $+2
$SG169850 DB	'E', 00H
	ORG $+2
$SG169745 DB	'file[%d] fd[%d] open %s, flags %8.8x mode %8.8x', 00H
$SG169746 DB	'cckd_open', 00H
	ORG $+2
$SG169871 DB	'E', 00H
	ORG $+2
$SG169754 DB	'file[%d] fd[%d] close %s', 00H
	ORG $+3
$SG169895 DB	'E', 00H
	ORG $+2
$SG169755 DB	'cckd_close', 00H
	ORG $+1
$SG169918 DB	'E', 00H
	ORG $+2
$SG169758 DB	'close()', 00H
$SG169760 DB	'HHC00301%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s: %s', 0aH, 00H
$SG169761 DB	'cckd_close', 00H
	ORG $+1
$SG170224 DB	'I', 00H
	ORG $+2
$SG169762 DB	'cckddasd.c', 00H
	ORG $+1
$SG170234 DB	'E', 00H
	ORG $+2
$SG169779 DB	'file[%d] fd[%d] read, off 0x%16.16llx len %d', 00H
	ORG $+3
$SG169780 DB	'cckd_read', 00H
	ORG $+2
$SG170300 DB	'I', 00H
	ORG $+2
$SG169782 DB	'lseek()', 00H
$SG169795 DB	'read incomplete: read %d, expected %d', 00H
	ORG $+2
$SG169784 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169785 DB	'cckd_read', 00H
	ORG $+2
$SG170307 DB	'W', 00H
	ORG $+2
$SG169786 DB	'cckddasd.c', 00H
	ORG $+5
$SG169816 DB	'file[%d] fd[%d] write, off 0x%16.16llx len %d', 00H
	ORG $+2
$SG169819 DB	'lseek()', 00H
$SG169792 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169793 DB	'cckd_read', 00H
	ORG $+2
$SG170316 DB	'I', 00H
	ORG $+2
$SG169794 DB	'cckddasd.c', 00H
	ORG $+5
$SG169827 DB	'write()', 00H
$SG169798 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169799 DB	'cckd_read', 00H
	ORG $+2
$SG170333 DB	'I', 00H
	ORG $+2
$SG169800 DB	'cckddasd.c', 00H
	ORG $+1
$SG170343 DB	'E', 00H
	ORG $+2
$SG169817 DB	'cckd_write', 00H
	ORG $+5
$SG169832 DB	'write incomplete: write %d, expected %d', 00H
$SG169821 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169822 DB	'cckd_write', 00H
	ORG $+1
$SG170354 DB	'I', 00H
	ORG $+2
$SG169823 DB	'cckddasd.c', 00H
	ORG $+5
$SG169833 DB	'write()', 00H
$SG169829 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169830 DB	'cckd_write', 00H
	ORG $+1
$SG170377 DB	'I', 00H
	ORG $+2
$SG169831 DB	'cckddasd.c', 00H
	ORG $+5
$SG169847 DB	'cckd_ftruncate', 00H
	ORG $+1
$SG169867 DB	'%s malloc %p len %ld', 00H
	ORG $+3
$SG169835 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169836 DB	'cckd_write', 00H
	ORG $+1
$SG170387 DB	'E', 00H
	ORG $+2
$SG169837 DB	'cckddasd.c', 00H
	ORG $+1
$SG170485 DB	'I', 00H
	ORG $+2
$SG169846 DB	'file[%d] fd[%d] ftruncate, off 0x%16.16llx', 00H
	ORG $+1
$SG170492 DB	'W', 00H
	ORG $+2
$SG169849 DB	'ftruncate()', 00H
$SG170149 DB	'read', 00H
	ORG $+7
$SG169851 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169852 DB	'cckd_ftruncate', 00H
	ORG $+1
$SG169853 DB	'cckddasd.c', 00H
	ORG $+1
$SG170501 DB	'I', 00H
	ORG $+2
$SG169868 DB	'cckd_malloc', 00H
$SG170517 DB	'I', 00H
	ORG $+2
$SG169870 DB	'malloc( %d )', 00H
	ORG $+3
$SG169872 DB	'HHC00303%s %1d:%04X CCKD file: error in function %s: %s', 0aH
	DB	00H
	ORG $+3
$SG170150 DB	'write', 00H
	ORG $+2
$SG170527 DB	'E', 00H
	ORG $+2
$SG169873 DB	'cckd_malloc', 00H
$SG170536 DB	'I', 00H
	ORG $+2
$SG169874 DB	'cckddasd.c', 00H
	ORG $+1
$SG170602 DB	'I', 00H
	ORG $+2
$SG169891 DB	'%s calloc %p len %ld', 00H
	ORG $+3
$SG169892 DB	'cckd_calloc', 00H
$SG170612 DB	'E', 00H
	ORG $+2
$SG169894 DB	'calloc( %d, %d )', 00H
	ORG $+3
$SG170674 DB	'E', 00H
	ORG $+2
$SG169896 DB	'HHC00303%s %1d:%04X CCKD file: error in function %s: %s', 0aH
	DB	00H
	ORG $+3
$SG170742 DB	'ifb', 00H
$SG169897 DB	'cckd_calloc', 00H
$SG170864 DB	'l1', 00H
	ORG $+1
$SG169898 DB	'cckddasd.c', 00H
	ORG $+1
$SG170866 DB	'l1', 00H
	ORG $+1
$SG169914 DB	'%s realloc %p len %ld', 00H
	ORG $+2
$SG169915 DB	'cckd_realloc', 00H
	ORG $+3
$SG169917 DB	'realloc( %p, %d )', 00H
	ORG $+2
$SG170936 DB	'E', 00H
	ORG $+2
$SG169919 DB	'HHC00303%s %1d:%04X CCKD file: error in function %s: %s', 0aH
	DB	00H
	ORG $+3
$SG170981 DB	'ifb', 00H
$SG169920 DB	'cckd_realloc', 00H
	ORG $+3
$SG169921 DB	'cckddasd.c', 00H
	ORG $+1
$SG170983 DB	'ifb', 00H
$SG169931 DB	'%s free %p', 00H
	ORG $+1
$SG170990 DB	'fsp', 00H
$SG169932 DB	'cckd_free', 00H
	ORG $+2
$SG170994 DB	'fsp', 00H
$SG169955 DB	'read  trk   %d uncompressed len %d', 00H
	ORG $+1
$SG171046 DB	'fsp', 00H
$SG169956 DB	'cckd_read_track', 00H
$SG169958 DB	'asynchronous', 00H
	ORG $+3
$SG169959 DB	'read  trk   %d (%s)', 00H
$SG171050 DB	'fsp', 00H
$SG169960 DB	'cckd_read_track', 00H
$SG169986 DB	'updt  trk   %d offset %d length %d', 00H
	ORG $+1
$SG171053 DB	'ifb', 00H
$SG169987 DB	'cckd_update_track', 00H
	ORG $+2
$SG171388 DB	'E', 00H
	ORG $+2
$SG170009 DB	'cckddasd.c:985', 00H
	ORG $+1
$SG170013 DB	'cckddasd.c:1002', 00H
$SG170043 DB	'read bkgrp  %d uncompressed len %d', 00H
	ORG $+1
$SG171448 DB	'trk', 00H
$SG170044 DB	'cfba_read_block', 00H
$SG170045 DB	'asynchronous', 00H
	ORG $+3
$SG170046 DB	'read blkgrp  %d (%s)', 00H
	ORG $+3
$SG170047 DB	'cfba_read_block', 00H
$SG170095 DB	'cckddasd.c:1156', 00H
$SG170099 DB	'cckddasd.c:1173', 00H
$SG170136 DB	'%d rdtrk     %d', 00H
$SG170137 DB	'cckd_read_trk', 00H
	ORG $+2
$SG170139 DB	'cckddasd.c:1208', 00H
$SG170146 DB	'cckddasd.c:1244', 00H
$SG170147 DB	'%d rdtrk[%d] %d cache hit buf %p:%2.2x%2.2x%2.2x%2.2x%2.'
	DB	'2x', 00H
	ORG $+1
$SG171510 DB	'E', 00H
	ORG $+2
$SG170148 DB	'cckd_read_trk', 00H
	ORG $+2
$SG170151 DB	'%d rdtrk[%d] %d waiting for %s', 00H
	ORG $+1
$SG170152 DB	'cckd_read_trk', 00H
	ORG $+2
$SG170153 DB	'cckddasd.c:1265', 00H
$SG170154 DB	'%d rdtrk[%d] %d io wait complete', 00H
	ORG $+3
$SG171449 DB	'blkgrp', 00H
	ORG $+1
$SG171520 DB	'E', 00H
	ORG $+2
$SG170155 DB	'cckd_read_trk', 00H
	ORG $+2
$SG170156 DB	'cckddasd.c:1272', 00H
$SG170158 DB	'%d rdtrk[%d] %d cache miss', 00H
	ORG $+1
$SG171528 DB	'trk', 00H
$SG170159 DB	'cckd_read_trk', 00H
	ORG $+2
$SG170161 DB	'%d rdtrk[%d] %d no available cache entry', 00H
	ORG $+3
$SG171529 DB	'blk', 00H
$SG170162 DB	'cckd_read_trk', 00H
	ORG $+2
$SG170164 DB	'cckddasd.c:1293', 00H
$SG170166 DB	'cckddasd.c:1301', 00H
$SG170168 DB	'%d rdtrk[%d] %d dropping %4.4X:%d from cache', 00H
	ORG $+3
$SG170169 DB	'cckd_read_trk', 00H
	ORG $+2
$SG170172 DB	'%d rdtrk[%d] %d buf %p len %d', 00H
	ORG $+2
$SG170173 DB	'cckd_read_trk', 00H
	ORG $+2
$SG170175 DB	'cckddasd.c:1338', 00H
$SG170178 DB	'cckddasd.c:1348', 00H
$SG170179 DB	'cckddasd.c:1352', 00H
$SG170180 DB	'cckddasd.c:1356', 00H
$SG170182 DB	'%d rdtrk[%d] %d signalling read complete', 00H
	ORG $+3
$SG171530 DB	'trk', 00H
$SG170183 DB	'cckd_read_trk', 00H
	ORG $+2
$SG170184 DB	'cckddasd.c:1367', 00H
$SG170185 DB	'cckddasd.c:1370', 00H
$SG170187 DB	'%d rdtrk[%d] %d complete buf %p:%2.2x%2.2x%2.2x%2.2x%2.2'
	DB	'x', 00H
	ORG $+2
$SG171531 DB	'blk', 00H
$SG170188 DB	'cckd_read_trk', 00H
	ORG $+2
$SG170209 DB	'cckddasd.c:1401', 00H
$SG170219 DB	'cckddasd.c:1446', 00H
$SG170223 DB	'cckd_ra()', 00H
	ORG $+2
$SG171532 DB	'E', 00H
	ORG $+2
$SG170225 DB	'HHC00107%s Starting thread %s, active=%d, started=%d, ma'
	DB	'x=%d', 0aH, 00H
	ORG $+2
$SG170226 DB	'cckd_readahead', 00H
	ORG $+1
$SG170227 DB	'cckddasd.c', 00H
	ORG $+1
$SG171536 DB	'trk', 00H
$SG170228 DB	'cckddasd.c:1458', 00H
$SG170229 DB	'cckddasd.c:1460', 00H
$SG170230 DB	'cckd_ra', 00H
$SG170231 DB	'cckddasd.c:1462', 00H
$SG170233 DB	'cckd_ra()', 00H
	ORG $+6
$SG170236 DB	'cckd_readahead', 00H
	ORG $+1
$SG170238 DB	'cckddasd.c:1475', 00H
$SG170293 DB	'cckd_ra thread %d', 00H
	ORG $+6
$SG170235 DB	'HHC00106%s Error in function create_thread() for %s %d o'
	DB	'f %d: %s', 0aH, 00H
	ORG $+2
$SG171537 DB	'blk', 00H
$SG170237 DB	'cckddasd.c', 00H
	ORG $+1
$SG171538 DB	'trk', 00H
$SG170292 DB	'cckddasd.c:1517', 00H
$SG170299 DB	'cckddasd.c:1532', 00H
$SG170301 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG170302 DB	'cckd_ra', 00H
$SG170303 DB	'cckddasd.c', 00H
	ORG $+1
$SG171539 DB	'blk', 00H
$SG170306 DB	'cckddasd.c:1538', 00H
$SG170309 DB	'cckd_ra', 00H
$SG170308 DB	'HHC00108%s Ending thread %8.8x %s, pri=%d, started=%d, m'
	DB	'ax=%d exceeded', 0aH, 00H
$SG170310 DB	'cckddasd.c', 00H
	ORG $+1
$SG171540 DB	'E', 00H
	ORG $+2
$SG170311 DB	'cckddasd.c:1540', 00H
$SG170312 DB	'cckddasd.c:1541', 00H
$SG170315 DB	'cckddasd.c:1547', 00H
$SG170317 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG170318 DB	'cckd_ra', 00H
$SG170319 DB	'cckddasd.c', 00H
	ORG $+1
$SG171584 DB	'trk', 00H
$SG170321 DB	'cckddasd.c:1554', 00H
$SG170328 DB	'cckddasd.c:1580', 00H
$SG170332 DB	'cckd_ra() from cckd_ra()', 00H
	ORG $+3
$SG171585 DB	'blkgrp', 00H
	ORG $+1
$SG171673 DB	'E', 00H
	ORG $+2
$SG170334 DB	'HHC00107%s Starting thread %s, active=%d, started=%d, ma'
	DB	'x=%d', 0aH, 00H
	ORG $+2
$SG170335 DB	'cckd_ra', 00H
$SG170336 DB	'cckddasd.c', 00H
	ORG $+1
$SG171682 DB	'E', 00H
	ORG $+2
$SG170337 DB	'cckddasd.c:1592', 00H
$SG170338 DB	'cckddasd.c:1594', 00H
$SG170339 DB	'cckd_ra', 00H
$SG170340 DB	'cckddasd.c:1596', 00H
$SG170342 DB	'cckd_ra() from cckd_ra()', 00H
	ORG $+7
$SG170344 DB	'HHC00106%s Error in function create_thread() for %s %d o'
	DB	'f %d: %s', 0aH, 00H
	ORG $+2
$SG171693 DB	'E', 00H
	ORG $+2
$SG170345 DB	'cckd_ra', 00H
$SG170346 DB	'cckddasd.c', 00H
	ORG $+1
$SG171724 DB	'E', 00H
	ORG $+2
$SG170349 DB	'cckddasd.c:1612', 00H
$SG170350 DB	'cckddasd.c:1617', 00H
$SG170353 DB	'cckddasd.c:1624', 00H
$SG170355 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG170356 DB	'cckd_ra', 00H
$SG170357 DB	'cckddasd.c', 00H
	ORG $+1
$SG171729 DB	'E', 00H
	ORG $+2
$SG170358 DB	'cckddasd.c:1631', 00H
$SG170360 DB	'cckddasd.c:1634', 00H
$SG170368 DB	'cckddasd.c:1657', 00H
$SG170372 DB	'cckddasd.c:1666', 00H
$SG170376 DB	'cckd_writer()', 00H
	ORG $+2
$SG170378 DB	'HHC00107%s Starting thread %s, active=%d, started=%d, ma'
	DB	'x=%d', 0aH, 00H
	ORG $+2
$SG170379 DB	'cckd_flush_cache', 00H
	ORG $+3
$SG171720 DB	'(none)', 00H
	ORG $+1
$SG171737 DB	'l1', 00H
	ORG $+1
$SG170380 DB	'cckddasd.c', 00H
	ORG $+1
$SG171739 DB	'l1', 00H
	ORG $+1
$SG170381 DB	'cckddasd.c:1678', 00H
$SG170382 DB	'cckddasd.c:1680', 00H
$SG170383 DB	'cckd_writer', 00H
$SG171759 DB	'I', 00H
	ORG $+2
$SG170384 DB	'cckddasd.c:1682', 00H
$SG170386 DB	'cckd_writer()', 00H
	ORG $+2
$SG170388 DB	'HHC00106%s Error in function create_thread() for %s %d o'
	DB	'f %d: %s', 0aH, 00H
	ORG $+2
$SG171763 DB	'I', 00H
	ORG $+2
$SG170389 DB	'cckd_flush_cache', 00H
	ORG $+3
$SG171768 DB	'E', 00H
	ORG $+2
$SG170390 DB	'cckddasd.c', 00H
	ORG $+1
$SG171775 DB	'W', 00H
	ORG $+2
$SG170391 DB	'cckddasd.c:1695', 00H
$SG170414 DB	'flush file[%d] cache[%d] %4.4X trk %d', 00H
	ORG $+2
$SG170415 DB	'cckd_flush_cache_scan', 00H
	ORG $+2
$SG170423 DB	'cckddasd.c:1729', 00H
$SG170425 DB	'cckddasd.c:1732', 00H
$SG170451 DB	'purge cache[%d] %4.4X trk %d purged', 00H
$SG171785 DB	'E', 00H
	ORG $+2
$SG170452 DB	'cckd_purge_cache_scan', 00H
	ORG $+2
$SG170476 DB	'cckddasd.c:1793', 00H
$SG170477 DB	'cckddasd.c:1796', 00H
$SG170478 DB	'cckd_writer thread %d', 00H
	ORG $+2
$SG170484 DB	'cckddasd.c:1811', 00H
$SG170486 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG170487 DB	'cckd_writer', 00H
$SG171790 DB	'I', 00H
	ORG $+2
$SG170488 DB	'cckddasd.c', 00H
	ORG $+1
$SG171892 DB	'I', 00H
	ORG $+2
$SG170491 DB	'cckddasd.c:1817', 00H
$SG170493 DB	'HHC00108%s Ending thread %8.8x %s, pri=%d, started=%d, m'
	DB	'ax=%d exceeded', 0aH, 00H
$SG170494 DB	'cckd_writer', 00H
$SG171896 DB	'I', 00H
	ORG $+2
$SG170495 DB	'cckddasd.c', 00H
	ORG $+1
$SG171902 DB	'W', 00H
	ORG $+2
$SG170496 DB	'cckddasd.c:1819', 00H
$SG170497 DB	'cckddasd.c:1820', 00H
$SG170500 DB	'cckddasd.c:1826', 00H
$SG170502 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG170503 DB	'cckd_writer', 00H
$SG171915 DB	'W', 00H
	ORG $+2
$SG170504 DB	'cckddasd.c', 00H
	ORG $+1
$SG171925 DB	'E', 00H
	ORG $+2
$SG170507 DB	'cckddasd.c:1835', 00H
$SG170512 DB	'cckddasd.c:1867', 00H
$SG170516 DB	'cckd_writer() from cckd_writer()', 00H
	ORG $+3
$SG171784 DB	'(null)', 00H
	ORG $+1
$SG171932 DB	'E', 00H
	ORG $+2
$SG170518 DB	'HHC00107%s Starting thread %s, active=%d, started=%d, ma'
	DB	'x=%d', 0aH, 00H
	ORG $+2
$SG170519 DB	'cckd_writer', 00H
$SG171945 DB	'E', 00H
	ORG $+2
$SG170520 DB	'cckddasd.c', 00H
	ORG $+1
$SG171952 DB	'E', 00H
	ORG $+2
$SG170521 DB	'cckddasd.c:1881', 00H
$SG170522 DB	'cckddasd.c:1883', 00H
$SG170523 DB	'cckd_writer', 00H
$SG171983 DB	'l1', 00H
	ORG $+1
$SG170524 DB	'cckddasd.c:1885', 00H
$SG170526 DB	'cckd_writer() from cckd_writer()', 00H
	ORG $+7
$SG170529 DB	'cckd_writer', 00H
$SG171906 DB	'force', 00H
	ORG $+6
$SG170528 DB	'HHC00106%s Error in function create_thread() for %s %d o'
	DB	'f %d: %s', 0aH, 00H
	ORG $+2
$SG171985 DB	'merged', 00H
	ORG $+1
$SG171988 DB	'I', 00H
	ORG $+2
$SG170530 DB	'cckddasd.c', 00H
	ORG $+1
$SG172002 DB	'E', 00H
	ORG $+2
$SG170531 DB	'cckddasd.c:1899', 00H
$SG170532 DB	'cckddasd.c:1903', 00H
$SG170535 DB	'cckddasd.c:1909', 00H
$SG170537 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG170538 DB	'cckd_writer', 00H
$SG172006 DB	'E', 00H
	ORG $+2
$SG170539 DB	'cckddasd.c', 00H
	ORG $+1
$SG172029 DB	'I', 00H
	ORG $+2
$SG170540 DB	'cckddasd.c:1916', 00H
$SG170542 DB	'cckddasd.c:1919', 00H
$SG170584 DB	'%d wrtrk[%d] %d len %d buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x', 00H
$SG170585 DB	'cckd_writer_write', 00H
	ORG $+2
$SG172033 DB	'I', 00H
	ORG $+2
$SG170590 DB	'%d wrtrk[%d] %d comp %s parm %d', 00H
$SG170591 DB	'cckd_writer_write', 00H
	ORG $+2
$SG172039 DB	'W', 00H
	ORG $+2
$SG170592 DB	'%d wrtrk[%d] %d compressed length %d', 00H
	ORG $+3
$SG170593 DB	'cckd_writer_write', 00H
	ORG $+2
$SG172046 DB	'W', 00H
	ORG $+2
$SG170594 DB	'cckddasd.c:2021', 00H
$SG170596 DB	'cckddasd.c:2033', 00H
$SG170597 DB	'cckddasd.c:2036', 00H
$SG170601 DB	'cckd_gcol()', 00H
$SG172078 DB	'I', 00H
	ORG $+2
$SG170603 DB	'HHC00107%s Starting thread %s, active=%d, started=%d, ma'
	DB	'x=%d', 0aH, 00H
	ORG $+2
$SG170604 DB	'cckd_writer_write', 00H
	ORG $+2
$SG172082 DB	'I', 00H
	ORG $+2
$SG170605 DB	'cckddasd.c', 00H
	ORG $+1
$SG172088 DB	'W', 00H
	ORG $+2
$SG170606 DB	'cckddasd.c:2050', 00H
$SG170607 DB	'cckddasd.c:2052', 00H
$SG170608 DB	'cckd_gcol', 00H
	ORG $+2
$SG172095 DB	'W', 00H
	ORG $+2
$SG170609 DB	'cckddasd.c:2054', 00H
$SG170611 DB	'cckd_gcol()', 00H
$SG171908 DB	'merge', 00H
	ORG $+6
$SG170613 DB	'HHC00106%s Error in function create_thread() for %s %d o'
	DB	'f %d: %s', 0aH, 00H
	ORG $+2
$SG172140 DB	'  ', 00H
	ORG $+1
$SG170614 DB	'cckd_writer_write', 00H
	ORG $+2
$SG172142 DB	'ro', 00H
	ORG $+1
$SG170615 DB	'cckddasd.c', 00H
	ORG $+1
$SG172144 DB	'rd', 00H
	ORG $+1
$SG170616 DB	'cckddasd.c:2066', 00H
$SG170617 DB	'cckddasd.c:2068', 00H
$SG170620 DB	'writer[%d] cache[%2.2d] %d signalling write complete', 00H
	ORG $+3
$SG170621 DB	'cckd_writer_write', 00H
	ORG $+2
$SG172146 DB	'rw', 00H
	ORG $+1
$SG170622 DB	'cckddasd.c:2089', 00H
$SG170623 DB	'cckddasd.c:2092', 00H
$SG170624 DB	'%d wrtrk[%2.2d] %d complete flags:%8.8x', 00H
$SG170625 DB	'cckd_writer_write', 00H
	ORG $+2
$SG172149 DB	'I', 00H
	ORG $+2
$SG170668 DB	'get_space len %d largest %d flags 0x%2.2x', 00H
	ORG $+2
$SG172153 DB	'I', 00H
	ORG $+2
$SG170669 DB	'cckd_get_space', 00H
	ORG $+1
$SG170675 DB	'HHC00304%s %1d:%04X CCKD file[%d] %s: get space error, s'
	DB	'ize exceeds %lldM', 0aH, 00H
	ORG $+1
$SG172159 DB	'W', 00H
	ORG $+2
$SG170676 DB	'cckd_get_space', 00H
	ORG $+1
$SG170677 DB	'cckddasd.c', 00H
	ORG $+1
$SG172165 DB	'E', 00H
	ORG $+2
$SG170678 DB	'get_space atend 0x%16.16llx len %d', 00H
	ORG $+1
$SG172171 DB	'I', 00H
	ORG $+2
$SG170679 DB	'cckd_get_space', 00H
	ORG $+1
$SG170695 DB	'get_space found 0x%16.16llx len %d size %d', 00H
	ORG $+1
$SG172177 DB	'I', 00H
	ORG $+2
$SG170696 DB	'cckd_get_space', 00H
	ORG $+1
$SG170734 DB	'rel_space offset 0x%16.16llx len %d size %d', 00H
$SG172181 DB	'I', 00H
	ORG $+2
$SG170735 DB	'cckd_rel_space', 00H
	ORG $+1
$SG170768 DB	'flush_space nbr %d', 00H
	ORG $+1
$SG172185 DB	'64', 00H
	ORG $+1
$SG170769 DB	'cckd_flush_space', 00H
	ORG $+3
$SG172186 DB	'32', 00H
	ORG $+1
$SG170778 DB	'rel_flush_space nbr %d (after merge)', 00H
	ORG $+3
$SG170779 DB	'cckd_flush_space', 00H
	ORG $+3
$SG172187 DB	'I', 00H
	ORG $+2
$SG170781 DB	'file[%d] rel_flush_space atend 0x%16.16llx len %d', 00H
	ORG $+2
$SG172193 DB	'I', 00H
	ORG $+2
$SG170782 DB	'cckd_flush_space', 00H
	ORG $+3
$SG172197 DB	'I', 00H
	ORG $+2
$SG170799 DB	'file[%d] read_chdr', 00H
	ORG $+1
$SG172201 DB	'64', 00H
	ORG $+1
$SG170800 DB	'cckd_read_chdr', 00H
	ORG $+1
$SG170819 DB	'file[%d] write_chdr', 00H
$SG172202 DB	'32', 00H
	ORG $+1
$SG170820 DB	'cckd_write_chdr', 00H
$SG170862 DB	'file[%d] read_l1 offset 0x%llx', 00H
	ORG $+1
$SG170863 DB	'cckd_read_l1', 00H
	ORG $+3
$SG170892 DB	'file[%d] write_l1 0x%llx len %d', 00H
$SG170893 DB	'cckd_write_l1', 00H
	ORG $+2
$SG170913 DB	'file[%d] write_l1ent[%d] , 0x%16.16llx', 00H
	ORG $+1
$SG170914 DB	'cckd_write_l1ent', 00H
	ORG $+3
$SG172203 DB	'I', 00H
	ORG $+2
$SG170926 DB	'file[%d] read_init', 00H
	ORG $+1
$SG172208 DB	'I', 00H
	ORG $+2
$SG170927 DB	'cckd_read_init', 00H
	ORG $+1
$SG170937 DB	'HHC00305%s %1d:%04X CCKD file[%d] %s: device header id e'
	DB	'rror', 0aH, 00H
	ORG $+2
$SG170938 DB	'cckd_read_init', 00H
	ORG $+1
$SG170939 DB	'cckddasd.c', 00H
	ORG $+1
$SG172212 DB	'64', 00H
	ORG $+1
$SG170979 DB	'file[%d] read_fsp number %d', 00H
$SG172213 DB	'32', 00H
	ORG $+1
$SG170980 DB	'cckd_read_fsp', 00H
	ORG $+2
$SG170988 DB	'FREE_BLK', 00H
	ORG $+3
$SG172214 DB	'I', 00H
	ORG $+2
$SG171037 DB	'file[%d] write_fsp number %d', 00H
	ORG $+3
$SG171038 DB	'cckd_write_fsp', 00H
	ORG $+1
$SG171049 DB	'FREE_BLK', 00H
	ORG $+3
$SG172257 DB	'I', 00H
	ORG $+2
$SG171093 DB	'file[%d] read_l2 %d active %d %d %d', 00H
$SG172267 DB	'E', 00H
	ORG $+2
$SG171094 DB	'cckd_read_l2', 00H
	ORG $+3
$SG171098 DB	'l2[%d,%d] cache[%d] hit', 00H
$SG171099 DB	'cckd_read_l2', 00H
	ORG $+3
$SG171100 DB	'l2[%d,%d] cache[%d] miss', 00H
	ORG $+3
$SG172306 DB	'I', 00H
	ORG $+2
$SG171101 DB	'cckd_read_l2', 00H
	ORG $+3
$SG171107 DB	'l2[%d,%d] cache[%d] null fmt[%d]', 00H
	ORG $+3
$SG172314 DB	'W', 00H
	ORG $+2
$SG171108 DB	'cckd_read_l2', 00H
	ORG $+3
$SG171111 DB	'l2[%d,%d] cache[%d] null 0xff', 00H
	ORG $+2
$SG171112 DB	'cckd_read_l2', 00H
	ORG $+3
$SG171115 DB	'file[%d] cache[%d] l2[%d] read offset 0x%8.8x', 00H
	ORG $+2
$SG171116 DB	'cckd_read_l2', 00H
	ORG $+3
$SG171124 DB	'purge_l2%s', 00H
	ORG $+1
$SG172324 DB	'I', 00H
	ORG $+2
$SG171125 DB	'cckd_purge_l2', 00H
	ORG $+2
$SG171151 DB	'purge l2cache[%d] %4.4X sfx %d ix %d purged', 00H
$SG172329 DB	'I', 00H
	ORG $+2
$SG171152 DB	'cckd_purge_l2_scan', 00H
	ORG $+1
$SG172334 DB	'I', 00H
	ORG $+2
$SG171214 DB	'file[%d] write_l2 %d', 00H
	ORG $+3
$SG171215 DB	'cckd_write_l2', 00H
	ORG $+2
$SG171248 DB	'file[%d] l2[%d,%d] trk[%d] read_l2ent 0x%x', 00H
	ORG $+1
$SG172346 DB	'I', 00H
	ORG $+2
$SG171249 DB	'cckd_read_l2ent', 00H
$SG171253 DB	'file[%d] l2[%d,%d] trk[%d] read_l2ent 0x%x %d %d', 00H
	ORG $+3
$SG172374 DB	'W', 00H
	ORG $+2
$SG171254 DB	'cckd_read_l2ent', 00H
$SG171282 DB	'file[%d] l2[%d,%d] trk[%d] write_l2ent 0x%x %d %d', 00H
	ORG $+2
$SG172380 DB	'W', 00H
	ORG $+2
$SG171283 DB	'cckd_write_l2ent', 00H
	ORG $+3
$SG172386 DB	'I', 00H
	ORG $+2
$SG171303 DB	'trk[%d] read_trkimg', 00H
$SG172483 DB	'E', 00H
	ORG $+2
$SG171304 DB	'cckd_read_trkimg', 00H
	ORG $+7
$SG171344 DB	'file[%d] trk[%d] write_trkimg len %d buf %p:%2.2x%2.2x%2'
	DB	'.2x%2.2x%2.2x', 00H
	ORG $+2
$SG171345 DB	'cckd_write_trkimg', 00H
	ORG $+2
$SG172431 DB	'newbuf', 00H
	ORG $+1
$SG172573 DB	'I', 00H
	ORG $+2
$SG171348 DB	'file[%d] trk[%d] write_trkimg oldl2 0x%x %d %d', 00H
	ORG $+1
$SG171349 DB	'cckd_write_trkimg', 00H
	ORG $+2
$SG172619 DB	'I', 00H
	ORG $+2
$SG171365 DB	'file[%d] harden', 00H
$SG171366 DB	'cckd_harden', 00H
	ORG $+4
$SG171389 DB	'HHC00306%s %1d:%04X CCKD file[%d] %s: trklen error for B'
	DB	'CCHH = %2.2x%4.4x%4.4x', 0aH, 00H
$SG171390 DB	'cckd_trklen', 00H
$SG172648 DB	'I', 00H
	ORG $+2
$SG171391 DB	'cckddasd.c', 00H
	ORG $+1
$SG172714 DB	'E', 00H
	ORG $+2
$SG171450 DB	'null_trk %s %d format %d size %d', 00H
	ORG $+3
$SG172700 DB	'newbuf', 00H
	ORG $+1
$SG172719 DB	'E', 00H
	ORG $+2
$SG171451 DB	'cckd_null_trk', 00H
	ORG $+2
$SG171511 DB	'HHC00307%s %1d:%04X CCKD file[%d] %s: invalid byte 0 trk'
	DB	' %d, buf %2.2x%2.2x%2.2x%2.2x%2.2x', 0aH, 00H
$SG172890 DB	'I', 00H
	ORG $+2
$SG171512 DB	'cckd_cchh', 00H
	ORG $+2
$SG172897 DB	'I', 00H
	ORG $+2
$SG171513 DB	'cckddasd.c', 00H
	ORG $+5
$SG171521 DB	'HHC00308%s %1d:%04X CCKD file[%d] %s: invalid byte 0 blk'
	DB	'grp %d, buf %2.2x%2.2x%2.2x%2.2x%2.2x', 0aH, 00H
	ORG $+1
$SG171522 DB	'cckd_cchh', 00H
	ORG $+2
$SG172902 DB	'I', 00H
	ORG $+2
$SG171523 DB	'cckddasd.c', 00H
	ORG $+5
$SG171533 DB	'HHC00309%s %1d:%04X CCKD file[%d] %s: invalid %s hdr %s '
	DB	'%d: %s compression unsupported', 0aH, 00H
$SG171534 DB	'cckd_cchh', 00H
	ORG $+2
$SG172909 DB	'I', 00H
	ORG $+2
$SG171535 DB	'cckddasd.c', 00H
	ORG $+5
$SG171587 DB	'cckd_validate', 00H
	ORG $+2
$SG171592 DB	'validation failed: bad length%s', 00H
$SG171721 DB	'file[%d] sf_new %s', 00H
	ORG $+5
$SG171541 DB	'HHC00310%s %1d:%04X CCKD file[%d] %s: invalid %s hdr %s '
	DB	'%d buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x', 0aH, 00H
	ORG $+3
$SG171542 DB	'cckd_cchh', 00H
	ORG $+2
$SG172914 DB	'I', 00H
	ORG $+2
$SG171543 DB	'cckddasd.c', 00H
	ORG $+5
$SG171586 DB	'validating %s %d len %d %2.2x%2.2x%2.2x%2.2x%2.2x %2.2x%'
	DB	'2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x', 00H
	ORG $+1
$SG172919 DB	'I', 00H
	ORG $+2
$SG171593 DB	'cckd_validate', 00H
	ORG $+2
$SG171597 DB	'validation failed: bad r0%s', 00H
$SG172924 DB	'I', 00H
	ORG $+2
$SG171598 DB	'cckd_validate', 00H
	ORG $+2
$SG171602 DB	'validation failed: bad r%d %2.2x%2.2x%2.2x%2.2x%2.2x%2.2'
	DB	'x%2.2x%2.2x', 00H
$SG172929 DB	'I', 00H
	ORG $+2
$SG171603 DB	'cckd_validate', 00H
	ORG $+2
$SG171608 DB	'validation failed: no eot%s', 00H
$SG172934 DB	'I', 00H
	ORG $+2
$SG171609 DB	'cckd_validate', 00H
	ORG $+2
$SG171725 DB	'HHC00313%s %1d:%04X CCKD file[%d]: no shadow file name', 0aH
	DB	00H
$SG171674 DB	'HHC00311%s %1d:%04X CCKD file[%d] %s: shadow file name c'
	DB	'ollides with %1d:%04X file[%d] %s', 0aH, 00H
	ORG $+1
$SG172939 DB	'I', 00H
	ORG $+2
$SG171675 DB	'cckd_sf_init', 00H
	ORG $+3
$SG171676 DB	'cckddasd.c', 00H
	ORG $+5
$SG171683 DB	'HHC00351%s %1d:%04X CCKD file[%d] %s: cckd/64 format dif'
	DB	'fers from base', 0aH, 00H
$SG171684 DB	'cckd_sf_init', 00H
	ORG $+3
$SG171685 DB	'cckddasd.c', 00H
	ORG $+5
$SG171695 DB	'cckd_sf_init', 00H
	ORG $+3
$SG171760 DB	'HHC00315%s %1d:%04X CCKD file: adding shadow files...', 0aH
	DB	00H
	ORG $+1
$SG171694 DB	'HHC00312%s %1d:%04X CCKD file[%d] %s: error re-opening r'
	DB	'eadonly: %s', 0aH, 00H
	ORG $+3
$SG171696 DB	'cckddasd.c', 00H
	ORG $+1
$SG172944 DB	'I', 00H
	ORG $+2
$SG171722 DB	'cckd_sf_new', 00H
$SG172949 DB	'I', 00H
	ORG $+2
$SG171726 DB	'cckd_sf_new', 00H
$SG173004 DB	'E', 00H
	ORG $+2
$SG171727 DB	'cckddasd.c', 00H
	ORG $+5
$SG171731 DB	'cckd_sf_new', 00H
$SG172989 DB	'%d%c', 00H
	ORG $+7
$SG171730 DB	'HHC00314%s %1d:%04X CCKD file[%d] %s:  max shadow files '
	DB	'exceeded', 0aH, 00H
	ORG $+2
$SG173011 DB	'E', 00H
	ORG $+2
$SG171732 DB	'cckddasd.c', 00H
	ORG $+1
$SG173021 DB	'E', 00H
	ORG $+2
$SG171761 DB	'cckd_sf_add', 00H
$SG173030 DB	'E', 00H
	ORG $+2
$SG171762 DB	'cckddasd.c', 00H
	ORG $+1
$SG173040 DB	'E', 00H
	ORG $+2
$SG171764 DB	'HHC00316%s CCKD file number of devices processed: %d', 0aH
	DB	00H
	ORG $+2
$SG171765 DB	'cckd_sf_add', 00H
$SG173050 DB	'E', 00H
	ORG $+2
$SG171766 DB	'cckddasd.c', 00H
	ORG $+1
$SG173060 DB	'E', 00H
	ORG $+2
$SG171769 DB	'HHC00317%s %1d:%04X CCKD file: device is not a cckd devi'
	DB	'ce', 0aH, 00H
$SG173070 DB	'E', 00H
	ORG $+2
$SG171770 DB	'cckd_sf_add', 00H
$SG173080 DB	'E', 00H
	ORG $+2
$SG171771 DB	'cckddasd.c', 00H
	ORG $+1
$SG173090 DB	'E', 00H
	ORG $+2
$SG171772 DB	'cckddasd.c:4151', 00H
$SG171774 DB	'cckddasd.c:4154', 00H
$SG171776 DB	'HHC00318%s %1d:%04X CCKD file[%d] %s: error adding shado'
	DB	'w file, sf command busy on device', 0aH, 00H
	ORG $+1
$SG173100 DB	'E', 00H
	ORG $+2
$SG171777 DB	'cckd_sf_add', 00H
$SG173110 DB	'E', 00H
	ORG $+2
$SG171778 DB	'cckddasd.c', 00H
	ORG $+1
$SG173120 DB	'E', 00H
	ORG $+2
$SG171780 DB	'cckddasd.c:4163', 00H
$SG171781 DB	'cckddasd.c:4169', 00H
$SG171782 DB	'cckddasd.c:4172', 00H
$SG171786 DB	'HHC00319%s %1d:%04X CCKD file[%d] %s: error adding shado'
	DB	'w file', 0aH, 00H
$SG171787 DB	'cckd_sf_add', 00H
$SG173131 DB	'E', 00H
	ORG $+2
$SG171788 DB	'cckddasd.c', 00H
	ORG $+5
$SG171791 DB	'HHC00320%s %1d:%04X CCKD file[%d] %s: shadow file succes'
	DB	'fully added', 0aH, 00H
	ORG $+3
$SG171792 DB	'cckd_sf_add', 00H
$SG173141 DB	'E', 00H
	ORG $+2
$SG171793 DB	'cckddasd.c', 00H
	ORG $+1
$SG173151 DB	'E', 00H
	ORG $+2
$SG171794 DB	'cckddasd.c:4195', 00H
$SG171795 DB	'cckddasd.c:4197', 00H
$SG171797 DB	'cckddasd.c:4200', 00H
$SG171798 DB	'cckddasd.c:4201', 00H
$SG171893 DB	'HHC00321%s %1d:%04X CCKD file: merging shadow files...', 0aH
	DB	00H
$SG171894 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG171895 DB	'cckddasd.c', 00H
	ORG $+1
$SG173157 DB	'RA', 00H
	ORG $+1
$SG171897 DB	'HHC00316%s CCKD file number of devices processed: %d', 0aH
	DB	00H
	ORG $+2
$SG171898 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG171899 DB	'cckddasd.c', 00H
	ORG $+1
$SG173161 DB	'E', 00H
	ORG $+2
$SG171903 DB	'HHC00317%s %1d:%04X CCKD file: device is not a cckd devi'
	DB	'ce', 0aH, 00H
$SG173167 DB	'RAQ', 00H
$SG171904 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG171905 DB	'cckddasd.c', 00H
	ORG $+1
$SG173171 DB	'E', 00H
	ORG $+2
$SG171909 DB	'nomerge', 00H
$SG171910 DB	'merge starting: %s %s', 00H
	ORG $+2
$SG171911 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG171912 DB	'cckddasd.c:4273', 00H
$SG171914 DB	'cckddasd.c:4277', 00H
$SG171957 DB	'merging to file[%d]', 00H
	ORG $+4
$SG171916 DB	'HHC00322%s %1d:%04X CCKD file[%d] %s: error merging shad'
	DB	'ow file, sf command busy on device', 0aH, 00H
$SG173177 DB	'RAT', 00H
$SG171917 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG171918 DB	'cckddasd.c', 00H
	ORG $+1
$SG173181 DB	'E', 00H
	ORG $+2
$SG171920 DB	'cckddasd.c:4287', 00H
$SG171921 DB	'cckddasd.c:4295', 00H
$SG171922 DB	'cckddasd.c:4297', 00H
$SG171924 DB	'cckddasd.c:4301', 00H
$SG171926 DB	'HHC00323%s %1d:%04X CCKD file[%d] %s: cannot remove base'
	DB	' file', 0aH, 00H
	ORG $+1
$SG171927 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG171928 DB	'cckddasd.c', 00H
	ORG $+1
$SG173191 DB	'E', 00H
	ORG $+2
$SG171931 DB	'not hardened', 00H
	ORG $+3
$SG171933 DB	'HHC00324%s %1d:%04X CCKD file[%d] %s: shadow file not me'
	DB	'rged: file[%d] %s%s', 0aH, 00H
	ORG $+3
$SG171934 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG171935 DB	'cckddasd.c', 00H
	ORG $+1
$SG173200 DB	'E', 00H
	ORG $+2
$SG171942 DB	', try ''force''', 00H
	ORG $+2
$SG171944 DB	'cannot be opened read-write', 00H
	ORG $+4
$SG171946 DB	'HHC00324%s %1d:%04X CCKD file[%d] %s: shadow file not me'
	DB	'rged: file[%d] %s%s', 0aH, 00H
	ORG $+3
$SG171947 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG171948 DB	'cckddasd.c', 00H
	ORG $+1
$SG173207 DB	'WR', 00H
	ORG $+1
$SG171951 DB	'check failed', 00H
	ORG $+3
$SG171953 DB	'HHC00324%s %1d:%04X CCKD file[%d] %s: shadow file not me'
	DB	'rged: file[%d] %s%s', 0aH, 00H
	ORG $+3
$SG171954 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG171955 DB	'cckddasd.c', 00H
	ORG $+1
$SG173211 DB	'E', 00H
	ORG $+2
$SG171958 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG171986 DB	're-added', 00H
	ORG $+3
$SG172998 DB	'STATS', 00H
	ORG $+2
$SG173096 DB	'GCMSGS', 00H
	ORG $+1
$SG173215 DB	'E', 00H
	ORG $+2
$SG171987 DB	'removed', 00H
$SG171997 DB	'merge complete%s', 00H
	ORG $+7
$SG171989 DB	'HHC00325%s %1d:%04X CCKD file[%d] %s: shadow file succes'
	DB	'sfully %s', 0aH, 00H
	ORG $+1
$SG173231 DB	'I', 00H
	ORG $+2
$SG171990 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG171991 DB	'cckddasd.c', 00H
	ORG $+1
$SG173239 DB	'I', 00H
	ORG $+2
$SG171992 DB	'cckddasd.c:4513', 00H
$SG171993 DB	'cckddasd.c:4515', 00H
$SG171995 DB	'cckddasd.c:4522', 00H
$SG171998 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG171999 DB	'cckddasd.c:4525', 00H
$SG172034 DB	'HHC00316%s CCKD file number of devices processed: %d', 0aH
	DB	00H
	ORG $+2
$SG172003 DB	'HHC00326%s %1d:%04X CCKD file[%d] %s: shadow file not me'
	DB	'rged, error during merge', 0aH, 00H
	ORG $+2
$SG173106 DB	'GCPARM', 00H
	ORG $+1
$SG173283 DB	'I', 00H
	ORG $+2
$SG172004 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG172005 DB	'cckddasd.c', 00H
	ORG $+5
$SG172007 DB	'HHC00327%s %1d:%04X CCKD file[%d] %s: shadow file not me'
	DB	'rged, error processing trk(%d)', 0aH, 00H
$SG172008 DB	'cckd_sf_remove', 00H
	ORG $+1
$SG172009 DB	'cckddasd.c', 00H
	ORG $+5
$SG172030 DB	'HHC00328%s %1d:%04X CCKD file: compressing shadow files.'
	DB	'..', 0aH, 00H
	ORG $+4
$SG172031 DB	'cckd_sf_comp', 00H
	ORG $+3
$SG172032 DB	'cckddasd.c', 00H
	ORG $+5
$SG172035 DB	'cckd_sf_comp', 00H
	ORG $+3
$SG172036 DB	'cckddasd.c', 00H
	ORG $+5
$SG172040 DB	'HHC00317%s %1d:%04X CCKD file: device is not a cckd devi'
	DB	'ce', 0aH, 00H
	ORG $+4
$SG172041 DB	'cckd_sf_comp', 00H
	ORG $+3
$SG172042 DB	'cckddasd.c', 00H
	ORG $+5
$SG172043 DB	'cckddasd.c:4593', 00H
$SG172045 DB	'cckddasd.c:4597', 00H
$SG172079 DB	'HHC00330%s %1d:%04X CCKD file: checking level %d...', 0aH
	DB	00H
	ORG $+3
$SG172047 DB	'HHC00329%s %1d:%04X CCKD file[%d] %s: error compressing '
	DB	'shadow file, sf command busy on device', 0aH, 00H
$SG172048 DB	'cckd_sf_comp', 00H
	ORG $+3
$SG172049 DB	'cckddasd.c', 00H
	ORG $+5
$SG172051 DB	'cckddasd.c:4607', 00H
$SG172052 DB	'cckddasd.c:4615', 00H
$SG172053 DB	'cckddasd.c:4618', 00H
$SG172054 DB	'cckddasd.c:4629', 00H
$SG172055 DB	'cckddasd.c:4631', 00H
$SG172057 DB	'cckddasd.c:4635', 00H
$SG172058 DB	'cckddasd.c:4637', 00H
$SG172080 DB	'cckd_sf_chk', 00H
	ORG $+4
$SG172081 DB	'cckddasd.c', 00H
	ORG $+5
$SG172083 DB	'HHC00316%s CCKD file number of devices processed: %d', 0aH
	DB	00H
	ORG $+2
$SG172084 DB	'cckd_sf_chk', 00H
	ORG $+4
$SG172085 DB	'cckddasd.c', 00H
	ORG $+5
$SG172089 DB	'HHC00317%s %1d:%04X CCKD file: device is not a cckd devi'
	DB	'ce', 0aH, 00H
	ORG $+4
$SG172090 DB	'cckd_sf_chk', 00H
	ORG $+4
$SG172091 DB	'cckddasd.c', 00H
	ORG $+5
$SG172092 DB	'cckddasd.c:4691', 00H
$SG172094 DB	'cckddasd.c:4695', 00H
$SG172150 DB	'HHC00332%s %1d:%04X CCKD file: display cckd statistics', 0aH
	DB	00H
$SG172096 DB	'HHC00331%s %1d:%04X CCKD file[%d] %s: shadow file check '
	DB	'failed, sf command busy on device', 0aH, 00H
	ORG $+5
$SG172097 DB	'cckd_sf_chk', 00H
	ORG $+4
$SG172098 DB	'cckddasd.c', 00H
	ORG $+5
$SG172100 DB	'cckddasd.c:4708', 00H
$SG172101 DB	'cckddasd.c:4718', 00H
$SG172102 DB	'cckddasd.c:4721', 00H
$SG172103 DB	'cckddasd.c:4732', 00H
$SG172104 DB	'cckddasd.c:4734', 00H
$SG172106 DB	'cckddasd.c:4738', 00H
$SG172107 DB	'cckddasd.c:4740', 00H
$SG172151 DB	'cckd_sf_stats', 00H
	ORG $+2
$SG172152 DB	'cckddasd.c', 00H
	ORG $+5
$SG172154 DB	'HHC00316%s CCKD file number of devices processed: %d', 0aH
	DB	00H
	ORG $+2
$SG172155 DB	'cckd_sf_stats', 00H
	ORG $+2
$SG172156 DB	'cckddasd.c', 00H
	ORG $+5
$SG172160 DB	'HHC00317%s %1d:%04X CCKD file: device is not a cckd devi'
	DB	'ce', 0aH, 00H
	ORG $+4
$SG172161 DB	'cckd_sf_stats', 00H
	ORG $+2
$SG172162 DB	'cckddasd.c', 00H
	ORG $+5
$SG172164 DB	'fstat()', 00H
$SG172166 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG172167 DB	'cckd_sf_stats', 00H
	ORG $+2
$SG172168 DB	'cckddasd.c', 00H
	ORG $+5
$SG172173 DB	'cckd_sf_stats', 00H
	ORG $+2
$SG172198 DB	'HHC00338%s %1d:%04X %s', 0aH, 00H
$SG172172 DB	'HHC00333%s %1d:%04X   32/64       size free  nbr st   re'
	DB	'ads  writes l2reads    hits switches', 0aH, 00H
	ORG $+2
$SG172174 DB	'cckddasd.c', 00H
	ORG $+5
$SG172178 DB	'HHC00334%s %1d:%04X                                     '
	DB	'                 readaheads   misses', 0aH, 00H
	ORG $+2
$SG172179 DB	'cckd_sf_stats', 00H
	ORG $+2
$SG172180 DB	'cckddasd.c', 00H
	ORG $+5
$SG172182 DB	'HHC00335%s %1d:%04X ------------------------------------'
	DB	'------------------------------------', 0aH, 00H
	ORG $+2
$SG172183 DB	'cckd_sf_stats', 00H
	ORG $+2
$SG172184 DB	'cckddasd.c', 00H
	ORG $+5
$SG172188 DB	'HHC00336%s %1d:%04X [*] %s %11.11lld %3.3lld%% %4.4lld  '
	DB	'  %7.7d %7.7d %7.7d %7.7d  %7.7d', 0aH, 00H
	ORG $+6
$SG172189 DB	'cckd_sf_stats', 00H
	ORG $+2
$SG172190 DB	'cckddasd.c', 00H
	ORG $+5
$SG172194 DB	'HHC00337%s %1d:%04X                                     '
	DB	'                    %7.7d  %7.7d', 0aH, 00H
	ORG $+6
$SG172195 DB	'cckd_sf_stats', 00H
	ORG $+2
$SG172196 DB	'cckddasd.c', 00H
	ORG $+5
$SG172199 DB	'cckd_sf_stats', 00H
	ORG $+2
$SG172200 DB	'cckddasd.c', 00H
	ORG $+5
$SG172204 DB	'HHC00339%s %1d:%04X [0] %s %11.11lld %3.3lld%% %4.4lld %'
	DB	's %7.7d %7.7d %7.7d', 0aH, 00H
	ORG $+3
$SG172205 DB	'cckd_sf_stats', 00H
	ORG $+2
$SG172206 DB	'cckddasd.c', 00H
	ORG $+5
$SG172209 DB	'HHC00340%s %1d:%04X %s', 0aH, 00H
$SG172210 DB	'cckd_sf_stats', 00H
	ORG $+2
$SG172211 DB	'cckddasd.c', 00H
	ORG $+5
$SG172216 DB	'cckd_sf_stats', 00H
	ORG $+2
$SG172223 DB	'cckddasd.c:4881', 00H
$SG172307 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG172215 DB	'HHC00341%s %1d:%04X [%d] %s %11.11lld %3.3lld%% %4.4lld '
	DB	'%s %7.7d %7.7d %7.7d', 0aH, 00H
	ORG $+2
$SG172217 DB	'cckddasd.c', 00H
	ORG $+5
$SG172226 DB	'cckddasd.c:4901', 00H
$SG172229 DB	'cckddasd.c:4910', 00H
$SG172231 DB	'cckddasd.c:4918', 00H
$SG172235 DB	'cckddasd.c:4924', 00H
$SG172236 DB	'cckddasd.c:4926', 00H
$SG172248 DB	'cckddasd.c:4949', 00H
$SG172250 DB	'cckddasd.c:4958', 00H
$SG172252 DB	'cckddasd.c:4967', 00H
$SG172256 DB	'cckd_gcol() by command line', 00H
	ORG $+4
$SG172258 DB	'HHC00107%s Starting thread %s, active=%d, started=%d, ma'
	DB	'x=%d', 0aH, 00H
	ORG $+2
$SG172259 DB	'cckd_gcstart', 00H
	ORG $+3
$SG172260 DB	'cckddasd.c', 00H
	ORG $+5
$SG172261 DB	'cckddasd.c:4980', 00H
$SG172262 DB	'cckddasd.c:4982', 00H
$SG172263 DB	'cckd_gcol', 00H
	ORG $+6
$SG172264 DB	'cckddasd.c:4984', 00H
$SG172266 DB	'cckd_gcol() by command line', 00H
	ORG $+4
$SG172268 DB	'HHC00106%s Error in function create_thread() for %s %d o'
	DB	'f %d: %s', 0aH, 00H
	ORG $+6
$SG172269 DB	'cckd_gcstart', 00H
	ORG $+3
$SG172270 DB	'cckddasd.c', 00H
	ORG $+5
$SG172271 DB	'cckddasd.c:4996', 00H
$SG172298 DB	'cckddasd.c:5025', 00H
$SG172304 DB	'cckd_gcol', 00H
	ORG $+6
$SG172305 DB	'cckddasd.c:5039', 00H
$SG172308 DB	'cckd_gcol', 00H
	ORG $+6
$SG172309 DB	'cckddasd.c', 00H
	ORG $+5
$SG172312 DB	'cckddasd.c:5045', 00H
$SG172313 DB	'cckd_gcol', 00H
	ORG $+6
$SG172317 DB	'cckddasd.c', 00H
	ORG $+5
$SG172318 DB	'cckddasd.c:5047', 00H
$SG172325 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG172315 DB	'HHC00108%s Ending thread %8.8x %s, pri=%d, started=%d, m'
	DB	'ax=%d exceeded', 0aH, 00H
$SG172316 DB	'cckd_gcol', 00H
	ORG $+6
$SG172319 DB	'cckddasd.c:5048', 00H
$SG172322 DB	'cckd_gcol', 00H
	ORG $+6
$SG172323 DB	'cckddasd.c:5054', 00H
$SG172326 DB	'cckd_gcol', 00H
	ORG $+6
$SG172327 DB	'cckddasd.c', 00H
	ORG $+5
$SG172330 DB	'HHC00382%s Begin CCKD garbage collection', 0aH, 00H
	ORG $+6
$SG172331 DB	'cckd_gcol', 00H
	ORG $+6
$SG172332 DB	'cckddasd.c', 00H
	ORG $+5
$SG172335 DB	'HHC00383%s End CCKD garbage collection', 0aH, 00H
$SG172336 DB	'cckd_gcol', 00H
	ORG $+6
$SG172337 DB	'cckddasd.c', 00H
	ORG $+5
$SG172339 DB	'cckd_gcol wait %d seconds at %s', 00H
$SG172340 DB	'cckd_gcol', 00H
	ORG $+6
$SG172341 DB	'cckddasd.c:5091', 00H
$SG172344 DB	'cckd_gcol', 00H
	ORG $+6
$SG172345 DB	'cckddasd.c:5096', 00H
$SG172347 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG172348 DB	'cckd_gcol', 00H
	ORG $+6
$SG172349 DB	'cckddasd.c', 00H
	ORG $+5
$SG172350 DB	'cckddasd.c:5103', 00H
$SG172352 DB	'cckddasd.c:5106', 00H
$SG172360 DB	'cckddasd.c:5121', 00H
$SG172361 DB	'cckddasd.c:5129', 00H
$SG172375 DB	'HHC00387%s %1d:%04X CCKD%s image %s is SEVERELY fragment'
	DB	'ed!', 0aH, 00H
	ORG $+3
$SG172376 DB	'cckd_gc_rpt_state', 00H
	ORG $+6
$SG172377 DB	'cckddasd.c', 00H
	ORG $+5
$SG172381 DB	'HHC00388%s %1d:%04X CCKD%s image %s is moderately fragme'
	DB	'nted', 0aH, 00H
	ORG $+2
$SG172382 DB	'cckd_gc_rpt_state', 00H
	ORG $+6
$SG172383 DB	'cckddasd.c', 00H
	ORG $+5
$SG172387 DB	'HHC00389%s %1d:%04X CCKD%s image %s is slightly fragment'
	DB	'ed', 0aH, 00H
	ORG $+4
$SG172388 DB	'cckd_gc_rpt_state', 00H
	ORG $+6
$SG172389 DB	'cckddasd.c', 00H
	ORG $+5
$SG172424 DB	'cckddasd.c:5240', 00H
$SG172427 DB	'cckddasd.c:5245', 00H
$SG172429 DB	'cckddasd.c:5252', 00H
$SG172434 DB	'cckddasd.c:5266', 00H
$SG172441 DB	'cckddasd.c:5283', 00H
$SG172442 DB	'cckddasd.c:5289', 00H
$SG172443 DB	'cckddasd.c:5297', 00H
$SG172444 DB	'cckddasd.c:5302', 00H
$SG172446 DB	'cckddasd.c:5307', 00H
$SG172447 DB	'cckddasd.c:5312', 00H
$SG172449 DB	'cckddasd.c:5318', 00H
$SG172450 DB	'cckddasd.c:5322', 00H
$SG172463 DB	'gcperc exiting due to error, moved %u', 00H
	ORG $+2
$SG172464 DB	'cckddasd.c:5333', 00H
$SG172575 DB	'cckd_gc_percolate', 00H
	ORG $+6
$SG172484 DB	'HHC00342%s %1d:%04X CCKD file[%d] %s: %s(%d): offset 0x%'
	DB	'16.16llx unknown space %2.2x%2.2x%2.2x%2.2x%2.2x', 0aH, 00H
	ORG $+6
$SG172485 DB	'cckd_gc_perc_space_error', 00H
	ORG $+7
$SG172486 DB	'cckddasd.c', 00H
	ORG $+5
$SG172574 DB	'HHC00385%s Skipping garbage collection for CCKD%s file[%'
	DB	'd] %1d:%04X %s due to space errors', 0aH, 00H
	ORG $+4
$SG172576 DB	'cckddasd.c', 00H
	ORG $+5
$SG172577 DB	'cckddasd.c:5388', 00H
$SG172580 DB	'cckddasd.c:5391', 00H
$SG172581 DB	'gcperc size %d 1st 0x%x nbr %d largest %u', 00H
	ORG $+6
$SG172582 DB	'cckd_gc_percolate', 00H
	ORG $+6
$SG172583 DB	'gcperc free[%4d]:%8.8x end %8.8x len %10d%cpend %d', 00H
	ORG $+5
$SG172584 DB	'cckd_gc_percolate', 00H
	ORG $+6
$SG172585 DB	'cckddasd.c:5411', 00H
$SG172587 DB	'cckddasd.c:5419', 00H
$SG172589 DB	'cckddasd.c:5425', 00H
$SG172606 DB	'gcperc no applicable space, moved %u', 00H
	ORG $+3
$SG172607 DB	'cckd_gc_percolate', 00H
	ORG $+6
$SG172608 DB	'cckddasd.c:5508', 00H
$SG172611 DB	'gcperc selected space 0x%16.16llx len %d', 00H
	ORG $+7
$SG172612 DB	'cckd_gc_percolate', 00H
	ORG $+6
$SG172614 DB	'cckddasd.c', 00H
	ORG $+5
$SG172620 DB	'HHC00384%s Collecting garbage for CCKD%s file[%d] %1d:%0'
	DB	'4X %s...', 0aH, 00H
	ORG $+6
$SG172621 DB	'cckd_gc_percolate', 00H
	ORG $+6
$SG172622 DB	'cckddasd.c', 00H
	ORG $+5
$SG172626 DB	'gcperc move l2tab[%d] at pos 0x%16.16llx len %d', 00H
$SG172627 DB	'cckd_gc_percolate', 00H
	ORG $+6
$SG172629 DB	'cckddasd.c', 00H
	ORG $+5
$SG172631 DB	'cckddasd.c', 00H
	ORG $+5
$SG172633 DB	'cckddasd.c', 00H
	ORG $+5
$SG172635 DB	'cckddasd.c', 00H
	ORG $+5
$SG172637 DB	'cckddasd.c', 00H
	ORG $+5
$SG172639 DB	'gcperc move trk %d at pos 0x%16.16llx len %hu', 00H
	ORG $+2
$SG172640 DB	'cckd_gc_percolate', 00H
	ORG $+6
$SG172642 DB	'cckddasd.c', 00H
	ORG $+5
$SG172643 DB	'cckddasd.c:5587', 00H
$SG172644 DB	'gcperc moved %d 1st 0x%x nbr %u', 00H
$SG172645 DB	'cckd_gc_percolate', 00H
	ORG $+6
$SG172650 DB	'cckd_gc_percolate', 00H
	ORG $+6
$SG172649 DB	'HHC00386%s Collected %u bytes of garbage for CCKD%s file'
	DB	'[%d] %1d:%04X %s...', 0aH, 00H
	ORG $+3
$SG172651 DB	'cckddasd.c', 00H
	ORG $+5
$SG172697 DB	'uncompress comp %d len %d maxlen %d trk %d', 00H
	ORG $+5
$SG172698 DB	'cckd_uncompress', 00H
$SG172709 DB	'newbuf2', 00H
$SG172847 DB	'  help          Display help message', 00H
	ORG $+3
$SG172715 DB	'HHC00343%s %1d:%04X CCKD file[%d] %s: uncompress error t'
	DB	'rk %d: %2.2x%2.2x%2.2x%2.2x%2.2x', 0aH, 00H
	ORG $+6
$SG172716 DB	'cckd_uncompress', 00H
$SG172717 DB	'cckddasd.c', 00H
	ORG $+5
$SG172720 DB	'HHC00344%s %1d:%04X CCKD file[%d] %s: compression %s not'
	DB	' supported', 0aH, 00H
	ORG $+4
$SG172721 DB	'cckd_uncompress', 00H
$SG172722 DB	'cckddasd.c', 00H
	ORG $+5
$SG172843 DB	'Command parameters for cckd:', 00H
	ORG $+3
$SG172849 DB	'  stats         Display cckd statistics', 00H
$SG172851 DB	'  opts          Display cckd options', 00H
	ORG $+3
$SG172891 DB	'HHC00345%s %s', 0aH, 00H
	ORG $+1
$SG172892 DB	'cckd_command_help', 00H
	ORG $+6
$SG172855 DB	'  comp=<n>      Override compression                 (-1'
	DB	',0,1,2)', 00H
$SG172857 DB	'  compparm=<n>  Override compression parm            (-1'
	DB	' ... 9)', 00H
$SG172859 DB	'  debug=<n>     Enable CCW tracing debug messages      ('
	DB	'0 or 1)', 00H
$SG172861 DB	'  dtax=<n>      Dump cckd trace table at exit          ('
	DB	'0 or 1)', 00H
$SG172863 DB	'  freepend=<n>  Set free pending cycles              (-1'
	DB	' ... 4)', 00H
$SG172865 DB	'  fsync=<n>     Enable fsync                           ('
	DB	'0 or 1)', 00H
$SG172867 DB	'  gcint=<n>     Set garbage collector interval (sec) ( 0'
	DB	' .. 60)', 00H
$SG172869 DB	'  gcmsgs=<n>    Display garbage collector messages     ('
	DB	'0 or 1)', 00H
$SG172871 DB	'  gcparm=<n>    Set garbage collector parameter      (-8'
	DB	' ... 8)', 00H
$SG172873 DB	'  gcstart=<n>   Start garbage collector                ('
	DB	'0 or 1)', 00H
$SG172875 DB	'  linuxnull=<n> Check for null linux tracks            ('
	DB	'0 or 1)', 00H
$SG172877 DB	'  nosfd=<n>     Disable stats report at close          ('
	DB	'0 or 1)', 00H
$SG172879 DB	'  nostress=<n>  Disable stress writes                  ('
	DB	'0 or 1)', 00H
$SG172881 DB	'  ra=<n>        Set number readahead threads         ( 1'
	DB	' ... 9)', 00H
$SG172883 DB	'  raq=<n>       Set readahead queue size             ( 0'
	DB	' .. 16)', 00H
$SG172885 DB	'  rat=<n>       Set number tracks to read ahead      ( 0'
	DB	' .. 16)', 00H
$SG172887 DB	'  trace=<n>     Set trace table size             (0 ... '
	DB	'200000)', 00H
$SG172889 DB	'  wr=<n>        Set number writer threads            ( 1'
	DB	' ... 9)', 00H
$SG172893 DB	'cckddasd.c', 00H
	ORG $+5
$SG172896 DB	'cckd opts: comp=%d,compparm=%d,debug=%d,dtax=%d,freepend'
	DB	'=%d,fsync=%d,gcint=%d,gcmsgs=%d', 00H
$SG172898 DB	'HHC00346%s %s', 0aH, 00H
	ORG $+1
$SG172899 DB	'cckd_command_opts', 00H
	ORG $+6
$SG172900 DB	'cckddasd.c', 00H
	ORG $+5
$SG172901 DB	'           gcparm=%d,linuxnull=%d,nosfd=%d,nostress=%d,r'
	DB	'a=%d,raq=%d,rat=%d,trace=%d,wr=%d', 00H
	ORG $+6
$SG172903 DB	'HHC00346%s %s', 0aH, 00H
	ORG $+1
$SG172904 DB	'cckd_command_opts', 00H
	ORG $+6
$SG172905 DB	'cckddasd.c', 00H
	ORG $+5
$SG172908 DB	'cckd stats:', 00H
	ORG $+4
$SG172910 DB	'HHC00347%s %s', 0aH, 00H
	ORG $+1
$SG172911 DB	'cckd_command_stats', 00H
	ORG $+5
$SG172912 DB	'cckddasd.c', 00H
	ORG $+5
$SG172913 DB	'  reads....%10lld Kbytes...%10lld', 00H
	ORG $+6
$SG172915 DB	'HHC00347%s %s', 0aH, 00H
	ORG $+1
$SG172916 DB	'cckd_command_stats', 00H
	ORG $+5
$SG172917 DB	'cckddasd.c', 00H
	ORG $+5
$SG172918 DB	'  writes...%10lld Kbytes...%10lld', 00H
	ORG $+6
$SG172920 DB	'HHC00347%s %s', 0aH, 00H
	ORG $+1
$SG172921 DB	'cckd_command_stats', 00H
	ORG $+5
$SG172922 DB	'cckddasd.c', 00H
	ORG $+5
$SG172923 DB	'  readaheads%9lld misses...%10lld', 00H
	ORG $+6
$SG172925 DB	'HHC00347%s %s', 0aH, 00H
	ORG $+1
$SG172926 DB	'cckd_command_stats', 00H
	ORG $+5
$SG172927 DB	'cckddasd.c', 00H
	ORG $+5
$SG172928 DB	'  switches.%10lld l2 reads.%10lld strs wrt.%10lld', 00H
	ORG $+6
$SG172930 DB	'HHC00347%s %s', 0aH, 00H
	ORG $+1
$SG172931 DB	'cckd_command_stats', 00H
	ORG $+5
$SG172932 DB	'cckddasd.c', 00H
	ORG $+5
$SG172933 DB	'  cachehits%10lld misses...%10lld', 00H
	ORG $+6
$SG172935 DB	'HHC00347%s %s', 0aH, 00H
	ORG $+1
$SG172936 DB	'cckd_command_stats', 00H
	ORG $+5
$SG172937 DB	'cckddasd.c', 00H
	ORG $+5
$SG172938 DB	'  l2 hits..%10lld misses...%10lld', 00H
	ORG $+6
$SG172940 DB	'HHC00347%s %s', 0aH, 00H
	ORG $+1
$SG172941 DB	'cckd_command_stats', 00H
	ORG $+5
$SG172942 DB	'cckddasd.c', 00H
	ORG $+5
$SG172943 DB	'  waits............   i/o......%10lld cache....%10lld', 00H
	ORG $+2
$SG172945 DB	'HHC00347%s %s', 0aH, 00H
	ORG $+1
$SG172946 DB	'cckd_command_stats', 00H
	ORG $+5
$SG172947 DB	'cckddasd.c', 00H
	ORG $+5
$SG172948 DB	'  garbage collector   moves....%10lld Kbytes...%10lld', 00H
	ORG $+2
$SG172950 DB	'HHC00347%s %s', 0aH, 00H
	ORG $+1
$SG172951 DB	'cckd_command_stats', 00H
	ORG $+5
$SG172952 DB	'cckddasd.c', 00H
	ORG $+5
$SG172984 DB	'CCKDBLK ', 00H
	ORG $+7
$SG172986 DB	'CCKDBLK ', 00H
	ORG $+3
$SG172994 DB	'HELP', 00H
	ORG $+3
$SG173002 DB	'OPTS', 00H
	ORG $+7
$SG173005 DB	'HHC00349%s CCKD file: invalid cckd keyword: %s', 0aH, 00H
$SG173006 DB	'cckd_command', 00H
	ORG $+3
$SG173007 DB	'cckddasd.c', 00H
	ORG $+5
$SG173012 DB	'HHC00350%s CCKD file: invalid numeric value %s', 0aH, 00H
$SG173013 DB	'cckd_command', 00H
	ORG $+3
$SG173014 DB	'cckddasd.c', 00H
	ORG $+1
$SG173017 DB	'COMP', 00H
	ORG $+7
$SG173022 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173023 DB	'cckd_command', 00H
	ORG $+3
$SG173024 DB	'cckddasd.c', 00H
	ORG $+5
$SG173031 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173032 DB	'cckd_command', 00H
	ORG $+3
$SG173033 DB	'cckddasd.c', 00H
	ORG $+5
$SG173036 DB	'COMPPARM', 00H
	ORG $+7
$SG173041 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173042 DB	'cckd_command', 00H
	ORG $+3
$SG173043 DB	'cckddasd.c', 00H
	ORG $+1
$SG173046 DB	'DEBUG', 00H
	ORG $+6
$SG173051 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173052 DB	'cckd_command', 00H
	ORG $+3
$SG173053 DB	'cckddasd.c', 00H
	ORG $+1
$SG173056 DB	'DTAX', 00H
	ORG $+7
$SG173061 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173062 DB	'cckd_command', 00H
	ORG $+3
$SG173063 DB	'cckddasd.c', 00H
	ORG $+5
$SG173066 DB	'FREEPEND', 00H
	ORG $+7
$SG173071 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173072 DB	'cckd_command', 00H
	ORG $+3
$SG173073 DB	'cckddasd.c', 00H
	ORG $+1
$SG173076 DB	'FSYNC', 00H
	ORG $+6
$SG173081 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173082 DB	'cckd_command', 00H
	ORG $+3
$SG173083 DB	'cckddasd.c', 00H
	ORG $+1
$SG173086 DB	'GCINT', 00H
	ORG $+6
$SG173091 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173092 DB	'cckd_command', 00H
	ORG $+3
$SG173093 DB	'cckddasd.c', 00H
	ORG $+5
$SG173101 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173102 DB	'cckd_command', 00H
	ORG $+3
$SG173103 DB	'cckddasd.c', 00H
	ORG $+5
$SG173111 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173112 DB	'cckd_command', 00H
	ORG $+3
$SG173113 DB	'cckddasd.c', 00H
	ORG $+5
$SG173116 DB	'GCSTART', 00H
$SG173121 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173122 DB	'cckd_command', 00H
	ORG $+3
$SG173123 DB	'cckddasd.c', 00H
	ORG $+5
$SG173127 DB	'LINUXNULL', 00H
	ORG $+6
$SG173132 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173133 DB	'cckd_command', 00H
	ORG $+3
$SG173134 DB	'cckddasd.c', 00H
	ORG $+1
$SG173137 DB	'NOSFD', 00H
	ORG $+6
$SG173142 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173143 DB	'cckd_command', 00H
	ORG $+3
$SG173144 DB	'cckddasd.c', 00H
	ORG $+5
$SG173147 DB	'NOSTRESS', 00H
	ORG $+7
$SG173152 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173153 DB	'cckd_command', 00H
	ORG $+3
$SG173154 DB	'cckddasd.c', 00H
	ORG $+5
$SG173162 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173163 DB	'cckd_command', 00H
	ORG $+3
$SG173164 DB	'cckddasd.c', 00H
	ORG $+5
$SG173172 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173173 DB	'cckd_command', 00H
	ORG $+3
$SG173174 DB	'cckddasd.c', 00H
	ORG $+5
$SG173182 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173183 DB	'cckd_command', 00H
	ORG $+3
$SG173184 DB	'cckddasd.c', 00H
	ORG $+1
$SG173187 DB	'TRACE', 00H
	ORG $+6
$SG173192 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173193 DB	'cckd_command', 00H
	ORG $+3
$SG173194 DB	'cckddasd.c', 00H
	ORG $+5
$SG173195 DB	'cckddasd.c:6561', 00H
$SG173199 DB	'calloc( %d, %d )', 00H
	ORG $+7
$SG173201 DB	'HHC00303%s %1d:%04X CCKD file: error in function %s: %s', 0aH
	DB	00H
	ORG $+7
$SG173202 DB	'cckd_command', 00H
	ORG $+3
$SG173203 DB	'cckddasd.c', 00H
	ORG $+5
$SG173204 DB	'cckddasd.c:6599', 00H
$SG173212 DB	'HHC00348%s CCKD file: invalid value %d for %s', 0aH, 00H
	ORG $+1
$SG173213 DB	'cckd_command', 00H
	ORG $+3
$SG173214 DB	'cckddasd.c', 00H
	ORG $+5
$SG173216 DB	'HHC00349%s CCKD file: invalid cckd keyword: %s', 0aH, 00H
$SG173217 DB	'cckd_command', 00H
	ORG $+3
$SG173218 DB	'cckddasd.c', 00H
	ORG $+5
$SG173232 DB	'HHC00399%s CCKD file: internal cckd trace', 0aH, 00H
	ORG $+5
$SG173233 DB	'cckd_print_itrace', 00H
	ORG $+6
$SG173234 DB	'cckddasd.c', 00H
	ORG $+5
$SG173235 DB	'cckddasd.c:6644', 00H
$SG173240 DB	'HHC00398%s %s', 0aH, 00H
	ORG $+1
$SG173241 DB	'cckd_print_itrace', 00H
	ORG $+6
$SG173242 DB	'cckddasd.c', 00H
	ORG $+5
$SG173244 DB	'cckddasd.c:6673', 00H
$SG173274 DB	'cckddasd.c:6696', 00H
$SG173276 DB	'%s.%6.6ld %1d:%04X ', 00H
	ORG $+4
$SG173279 DB	'%s%s(%d): %s', 00H
	ORG $+3
$SG173280 DB	'cckddasd.c:6737', 00H
$SG173284 DB	'HHC00396%s %1d:%04X %s', 0aH, 00H
$SG173285 DB	'cckd_trace', 00H
	ORG $+5
$SG173286 DB	'cckddasd.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_sf_stats
	DD	017H
	DD	010e2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_sf_remove
	DD	01dH
	DD	0196bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_trace
	DD	024H
	DD	0354H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_command_stats
	DD	011H
	DD	045cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_command_opts
	DD	011H
	DD	01b9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_command_help
	DD	011H
	DD	01feH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_command
	DD	01aH
	DD	01229H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_gc_percolate
	DD	021H
	DD	01445H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_gcol
	DD	016H
	DD	05acH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_sf_new
	DD	018H
	DD	0667H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_sf_init
	DD	016H
	DD	0784H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_sf_parse_sfn
	DD	01bH
	DD	0165H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_validate
	DD	02fH
	DD	065bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_check_null_trk
	DD	02bH
	DD	0157H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_read_init
	DD	016H
	DD	028aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_writer_write
	DD	01fH
	DD	088fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_writer
	DD	016H
	DD	0707H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_ra
	DD	016H
	DD	07b5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_realloc
	DD	025H
	DD	01b1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_calloc
	DD	025H
	DD	01caH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_malloc
	DD	020H
	DD	0196H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_write
	DD	024H
	DD	04b3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_read
	DD	024H
	DD	04abH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_open
	DD	024H
	DD	03ecH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd_dasd_init_handler
	DD	01fH
	DD	0583H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$ctime DD 010901H
	DD	04209H
$unwind$strcaseabbrev DD 011301H
	DD	08213H
$unwind$cckd_dasd_init_handler DD 022719H
	DD	0170115H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$cckd_dasd_close_device DD 020c01H
	DD	015010cH
$unwind$cckd_read_track DD 011201H
	DD	0a212H
$unwind$cckd_update_track DD 031901H
	DD	07015a219H
	DD	06014H
$unwind$cfba_read_block DD 011201H
	DD	0c212H
$unwind$cfba_write_block DD 031901H
	DD	070158219H
	DD	06014H
$unwind$cckd_dasd_init DD 020e01H
	DD	0700a520eH
$unwind$cckd_dasd_term_if_appropriate DD 010401H
	DD	04204H
$unwind$cckd_dasd_start DD 010901H
	DD	0c209H
$unwind$cckd_dasd_end DD 010901H
	DD	0a209H
$unwind$cckd_open DD 022c19H
	DD	039011aH
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$unwind$cckd_close DD 021001H
	DD	0150110H
$unwind$cckd_read DD 022c19H
	DD	02b011aH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$cckd_write DD 022c19H
	DD	02b011aH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$cckd_ftruncate DD 021501H
	DD	0130115H
$unwind$cckd_malloc DD 022819H
	DD	01b0116H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$cckd_calloc DD 022d19H
	DD	01b011bH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$cckd_realloc DD 022d19H
	DD	01b011bH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$cckd_free DD 011301H
	DD	06213H
$unwind$cckd_used DD 010901H
	DD	08209H
$unwind$cfba_used DD 010901H
	DD	08209H
$unwind$cckd_read_trk DD 031b01H
	DD	01a011bH
	DD	07014H
$unwind$cckd_readahead DD 031101H
	DD	0120111H
	DD	0700aH
$unwind$cckd_readahead_scan DD 011701H
	DD	08217H
$unwind$cckd_ra DD 021e19H
	DD	01f010cH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$cckd_flush_cache DD 020c01H
	DD	011010cH
$unwind$cckd_flush_cache_scan DD 011701H
	DD	0c217H
$unwind$cckd_flush_cache_all DD 010401H
	DD	06204H
$unwind$cckd_purge_cache DD 010901H
	DD	04209H
$unwind$cckd_purge_cache_scan DD 011701H
	DD	0a217H
$unwind$cckd_writer DD 021e19H
	DD	01b010cH
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$cckd_writer_scan DD 011701H
	DD	06217H
$unwind$cckd_writer_write DD 022719H
	DD	0201f0115H
	DD	imagerel __GSHandlerCheck
	DD	0100e0H
$unwind$cckd_get_space DD 021601H
	DD	0170116H
$unwind$cckd_rel_space DD 021b01H
	DD	013011bH
$unwind$cckd_flush_space DD 010901H
	DD	0c209H
$unwind$cckd_read_chdr DD 020a01H
	DD	07006720aH
$unwind$cckd_write_chdr DD 010901H
	DD	08209H
$unwind$cckd_read_l1 DD 020a01H
	DD	07006b20aH
$unwind$cckd_write_l1 DD 010901H
	DD	0a209H
$unwind$cckd_write_l1ent DD 010d01H
	DD	0c20dH
$unwind$cckd_read_init DD 021e19H
	DD	053010cH
	DD	imagerel __GSHandlerCheck
	DD	0280H
$unwind$cckd_read_fsp DD 020c01H
	DD	011010cH
$unwind$cckd_write_fsp DD 010901H
	DD	0e209H
$unwind$cckd_read_l2 DD 021601H
	DD	0700ff216H
$unwind$cckd_purge_l2 DD 010901H
	DD	08209H
$unwind$cckd_purge_l2_scan DD 011701H
	DD	0c217H
$unwind$cckd_steal_l2 DD 010401H
	DD	08204H
$unwind$cckd_steal_l2_scan DD 011701H
	DD	06217H
$unwind$cckd_write_l2 DD 010901H
	DD	0c209H
$unwind$cckd_read_l2ent DD 021601H
	DD	0110116H
$unwind$cckd_write_l2ent DD 021601H
	DD	0110116H
$unwind$cckd_read_trkimg DD 011801H
	DD	0a218H
$unwind$cckd_write_trkimg DD 021b01H
	DD	017011bH
$unwind$cckd_harden DD 010901H
	DD	08209H
$unwind$cckd_trklen DD 021101H
	DD	0150111H
$unwind$cckd_null_trk DD 031c01H
	DD	012011cH
	DD	07015H
$unwind$cckd_check_null_trk DD 023319H
	DD	020090121H
	DD	imagerel __GSHandlerCheck
	DD	010030H
$unwind$cckd_cchh DD 021601H
	DD	02f0116H
$unwind$cckd_validate DD 093719H
	DD	01c0125H
	DD	0e01cf01eH
	DD	07018c01aH
	DD	050166017H
	DD	03015H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$cckd_sf_parse_sfn DD 022319H
	DD	02b0111H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$cckd_sf_init DD 021e19H
	DD	08b010cH
	DD	imagerel __GSHandlerCheck
	DD	0440H
$unwind$cckd_sf_new DD 042019H
	DD	059010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	02b0H
$unwind$cckd_lock_devchain DD 010801H
	DD	04208H
$unwind$cckd_unlock_devchain DD 010401H
	DD	04204H
$unwind$cckd_gcstart DD 020701H
	DD	0130107H
$unwind$cckd_gcol DD 021e19H
	DD	01b010cH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$cckd_gcol_dev DD 010e01H
	DD	0a20eH
$unwind$cckd_gc_state DD 010901H
	DD	08209H
$unwind$cckd_gc_rpt_state DD 020c01H
	DD	017010cH
$unwind$cckd_gc_percolate DD 022919H
	DD	080290117H
	DD	imagerel __GSHandlerCheck
	DD	040130H
$unwind$cckd_find_device_by_devnum DD 010901H
	DD	06209H
$unwind$cckd_uncompress DD 021b01H
	DD	01f011bH
$unwind$cckd_compress DD 011801H
	DD	08218H
$unwind$cckd_compress_zlib DD 011801H
	DD	06218H
$unwind$cckd_compress_bzip2 DD 011801H
	DD	06218H
$unwind$cckd_command DD 022219H
	DD	03f0110H
	DD	imagerel __GSHandlerCheck
	DD	01e0H
$unwind$cckd_command_help DD 021919H
	DD	0270107H
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$cckd_command_opts DD 021919H
	DD	0310107H
	DD	imagerel __GSHandlerCheck
	DD	0170H
$unwind$cckd_command_stats DD 021919H
	DD	01b0107H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$cckd_trace DD 022c19H
	DD	03d011aH
	DD	imagerel __GSHandlerCheck
	DD	01d0H
$unwind$cckd_print_itrace DD 020601H
	DD	07002b206H
$unwind$cckd_dtax DD 010401H
	DD	02204H
$unwind$cckd_sf_add DD 020c01H
	DD	019010cH
$unwind$cckd_sf_remove DD 032519H
	DD	022340113H
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	011190H
$unwind$cckd_sf_comp DD 020c01H
	DD	015010cH
$unwind$cckd_sf_chk DD 020c01H
	DD	015010cH
$unwind$cckd_sf_stats DD 031f19H
	DD	042010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0208H
$unwind$cckd_gc_rpt_states DD 010401H
	DD	06204H
$unwind$cckd_gc_perc_error DD 011801H
	DD	06218H
$unwind$cckd_gc_perc_space_error DD 021b01H
	DD	01d011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
tv142 = 160
tv148 = 164
tv68 = 168
tv74 = 172
tv80 = 176
tv86 = 180
tv91 = 184
tv94 = 192
tv129 = 200
tv132 = 208
dev$ = 240
cckd$ = 248
upos$ = 256
i$ = 264
buf$ = 272
moved$ = 280
file$ = 288
line$ = 296
cckd_gc_perc_space_error PROC

; 5340 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 5341 :     // "%1d:%04X CCKD file[%d] %s: %s(%d): offset 0x%16.16"PRIx64" unknown space %2.2x%2.2x%2.2x%2.2x%2.2x"
; 5342 : 
; 5343 :     WRMSG( HHC00342, "E", LCSS_DEVNUM,

  0001b	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00024	74 15		 je	 SHORT $LN3@cckd_gc_pe
  00026	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00032	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv142[rsp], eax
  00039	eb 0b		 jmp	 SHORT $LN4@cckd_gc_pe
$LN3@cckd_gc_pe:
  0003b	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv142[rsp], 0
$LN4@cckd_gc_pe:
  00046	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0004f	74 17		 je	 SHORT $LN5@cckd_gc_pe
  00051	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00059	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0005d	d1 f8		 sar	 eax, 1
  0005f	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv148[rsp], eax
  00066	eb 0b		 jmp	 SHORT $LN6@cckd_gc_pe
$LN5@cckd_gc_pe:
  00068	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv148[rsp], 0
$LN6@cckd_gc_pe:
  00073	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0007a	83 c0 04	 add	 eax, 4
  0007d	48 98		 cdqe
  0007f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00087	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008b	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv68[rsp], eax
  00092	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00099	83 c1 03	 add	 ecx, 3
  0009c	48 63 c9	 movsxd	 rcx, ecx
  0009f	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000a7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000ab	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR tv74[rsp], ecx
  000b2	8b 94 24 08 01
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  000b9	83 c2 02	 add	 edx, 2
  000bc	48 63 d2	 movsxd	 rdx, edx
  000bf	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  000c7	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  000cc	89 94 24 b0 00
	00 00		 mov	 DWORD PTR tv80[rsp], edx
  000d3	44 8b 84 24 08
	01 00 00	 mov	 r8d, DWORD PTR i$[rsp]
  000db	41 ff c0	 inc	 r8d
  000de	4d 63 c0	 movsxd	 r8, r8d
  000e1	4c 8b 8c 24 10
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  000e9	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  000ee	44 89 84 24 b4
	00 00 00	 mov	 DWORD PTR tv86[rsp], r8d
  000f6	4c 63 8c 24 08
	01 00 00	 movsxd	 r9, DWORD PTR i$[rsp]
  000fe	4c 8b 94 24 10
	01 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  00106	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  0010b	44 89 8c 24 b8
	00 00 00	 mov	 DWORD PTR tv91[rsp], r9d
  00113	4c 63 94 24 08
	01 00 00	 movsxd	 r10, DWORD PTR i$[rsp]
  0011b	4c 8b 9c 24 00
	01 00 00	 mov	 r11, QWORD PTR upos$[rsp]
  00123	4d 03 da	 add	 r11, r10
  00126	4d 8b d3	 mov	 r10, r11
  00129	4c 89 94 24 c0
	00 00 00	 mov	 QWORD PTR tv94[rsp], r10
  00131	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trimloc
  0013f	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv129[rsp], rax
  00147	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0014f	8b 51 3c	 mov	 edx, DWORD PTR [rcx+60]
  00152	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0015a	e8 00 00 00 00	 call	 cckd_sf_name
  0015f	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
  00167	b9 01 00 00 00	 mov	 ecx, 1
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00172	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv68[rsp]
  00179	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  00180	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv74[rsp]
  00187	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  0018e	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv80[rsp]
  00195	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  0019c	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv86[rsp]
  001a3	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  001a7	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv91[rsp]
  001ae	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  001b2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv94[rsp]
  001ba	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  001bf	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR line$[rsp]
  001c6	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  001ca	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv129[rsp]
  001d2	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001d7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  001df	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001e4	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ec	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  001ef	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001f3	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv142[rsp]
  001fa	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001fe	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv148[rsp]
  00205	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00209	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172483
  00210	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00215	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172484
  0021c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00221	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00226	41 b9 03 00 00
	00		 mov	 r9d, 3
  0022c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172485
  00233	ba e1 14 00 00	 mov	 edx, 5345		; 000014e1H
  00238	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172486
  0023f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5344 :             cckd->sfn, cckd_sf_name( dev, cckd->sfn ), TRIMLOC( file ), line,
; 5345 :             upos + i, buf[i], buf[i+1],buf[i+2], buf[i+3], buf[i+4]);
; 5346 : 
; 5347 :     cckd->cdevhdr[ cckd->sfn ].cdh_opts |= CCKD_OPT_SPERRS;

  00245	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0024d	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00251	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00258	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00260	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  00268	83 c8 20	 or	 eax, 32			; 00000020H
  0026b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00273	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  00277	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  0027e	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR cckd$[rsp]
  00286	88 84 0a e3 01
	00 00		 mov	 BYTE PTR [rdx+rcx+483], al

; 5348 :     cckd_print_itrace();

  0028d	e8 00 00 00 00	 call	 cckd_print_itrace

; 5349 :     return cckd_gc_perc_error( dev, cckd, moved, file, line );

  00292	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR line$[rsp]
  00299	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0029d	4c 8b 8c 24 20
	01 00 00	 mov	 r9, QWORD PTR file$[rsp]
  002a5	44 8b 84 24 18
	01 00 00	 mov	 r8d, DWORD PTR moved$[rsp]
  002ad	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR cckd$[rsp]
  002b5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002bd	e8 00 00 00 00	 call	 cckd_gc_perc_error

; 5350 : }

  002c2	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  002c9	c3		 ret	 0
cckd_gc_perc_space_error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 64
cckd$ = 72
moved$ = 80
file$ = 88
line$ = 96
cckd_gc_perc_error PROC

; 5331 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5332 :     cckd_trace( file, line, dev, "gcperc exiting due to error, moved %u", moved );

  00018	8b 44 24 50	 mov	 eax, DWORD PTR moved$[rsp]
  0001c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00020	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172463
  00027	4c 8b 44 24 40	 mov	 r8, QWORD PTR dev$[rsp]
  0002c	8b 54 24 60	 mov	 edx, DWORD PTR line$[rsp]
  00030	48 8b 4c 24 58	 mov	 rcx, QWORD PTR file$[rsp]
  00035	e8 00 00 00 00	 call	 cckd_trace

; 5333 :     release_lock( &cckd->filelock );

  0003a	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  0003f	48 83 c0 10	 add	 rax, 16
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172464
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5334 :     return moved;

  00053	8b 44 24 50	 mov	 eax, DWORD PTR moved$[rsp]

; 5335 : }

  00057	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005b	c3		 ret	 0
cckd_gc_perc_error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$1 = 32
cckd$2 = 40
cckd_gc_rpt_states PROC

; 5115 : {

$LN7:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5116 :     if (cckdblk.gcmsgs)     // (only if they're interested)

  00004	83 3d 4c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+588, 0
  0000b	74 68		 je	 SHORT $LN5@cckd_gc_rp

; 5117 :     {
; 5118 :         CCKD_EXT*  cckd;                /* -> cckd extension         */
; 5119 :         DEVBLK*    dev;                 /* -> device                 */
; 5120 : 
; 5121 :         obtain_lock( &cckdblk.devlock );

  0000d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172360
  00014	48 8d 0d 30 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+560
  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5122 :         {
; 5123 :             for (dev = cckdblk.dev1st; dev; dev = cckd->devnext)

  00021	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  00028	48 89 44 24 20	 mov	 QWORD PTR dev$1[rsp], rax
  0002d	eb 0d		 jmp	 SHORT $LN4@cckd_gc_rp
$LN2@cckd_gc_rp:
  0002f	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$2[rsp]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	48 89 44 24 20	 mov	 QWORD PTR dev$1[rsp], rax
$LN4@cckd_gc_rp:
  0003c	48 83 7c 24 20
	00		 cmp	 QWORD PTR dev$1[rsp], 0
  00042	74 1d		 je	 SHORT $LN3@cckd_gc_rp

; 5124 :             {
; 5125 :                 cckd = dev->cckd_ext;

  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$1[rsp]
  00049	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00050	48 89 44 24 28	 mov	 QWORD PTR cckd$2[rsp], rax

; 5126 :                 cckd_gc_rpt_state( dev );

  00055	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$1[rsp]
  0005a	e8 00 00 00 00	 call	 cckd_gc_rpt_state

; 5127 :             }

  0005f	eb ce		 jmp	 SHORT $LN2@cckd_gc_rp
$LN3@cckd_gc_rp:

; 5128 :         }
; 5129 :         release_lock( &cckdblk.devlock );

  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172361
  00068	48 8d 0d 30 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+560
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN5@cckd_gc_rp:

; 5130 :     }
; 5131 : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	c3		 ret	 0
cckd_gc_rpt_states ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 144
i$ = 152
cckd$ = 160
n$1 = 168
free_count$ = 172
usize$ = 176
tv149 = 184
tv155 = 188
tv218 = 192
tv224 = 196
tv242 = 200
tv248 = 204
tv262 = 208
tv268 = 212
tv338 = 216
tv344 = 220
tv366 = 224
tv372 = 228
tv388 = 232
tv394 = 236
tv456 = 240
tv477 = 244
tv483 = 248
tv566 = 252
tv572 = 256
tv450 = 260
tv77 = 264
tv83 = 268
ufree$ = 272
tv326 = 280
tv333 = 288
tv438 = 296
tv445 = 304
tv547 = 312
tv560 = 320
tv173 = 328
tv321 = 336
tv383 = 344
tv406 = 352
tv410 = 360
tv414 = 368
tv428 = 376
tv470 = 384
tv498 = 392
tv503 = 400
tv508 = 408
tv525 = 416
tv554 = 424
st$ = 432
ost$ = 488
__$ArrayPad$ = 520
data$ = 544
cckd_sf_stats PROC

; 4752 : {

$LN80:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 10 02
	00 00		 sub	 rsp, 528		; 00000210H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4753 : DEVBLK         *dev = data;             /* -> DEVBLK                 */

  0001f	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00027	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax

; 4754 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 4755 : struct stat     st = {0};               /* File information          */

  0002f	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR st$[rsp]
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00041	f3 aa		 rep stosb

; 4756 : int             i;                      /* Index                     */
; 4757 : char           *ost[] = {"  ", "ro", "rd", "rw"};

  00043	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172140
  0004a	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR ost$[rsp], rax
  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172142
  00059	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR ost$[rsp+8], rax
  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172144
  00068	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR ost$[rsp+16], rax
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172146
  00077	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR ost$[rsp+24], rax

; 4758 : U64             usize=0,ufree=0;        /* Total size, free space    */

  0007f	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR usize$[rsp], 0
  0008b	48 c7 84 24 10
	01 00 00 00 00
	00 00		 mov	 QWORD PTR ufree$[rsp], 0

; 4759 : int             free_count=0;           /* Total number free spaces  */

  00097	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR free_count$[rsp], 0

; 4760 : 
; 4761 :     /* NULL DEVBLK == all devices? */
; 4762 :     if (!dev)

  000a2	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000ab	0f 85 8c 01 00
	00		 jne	 $LN11@cckd_sf_st

; 4763 :     {
; 4764 :     int n = 0;

  000b1	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR n$1[rsp], 0

; 4765 :         for (dev=sysblk.firstdev; dev; dev=dev->nextdev)

  000bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c3	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  000ca	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax
  000d2	eb 14		 jmp	 SHORT $LN4@cckd_sf_st
$LN2@cckd_sf_st:
  000d4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000dc	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000e0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd_sf_st:
  000e8	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000f1	0f 84 ed 00 00
	00		 je	 $LN3@cckd_sf_st

; 4766 :         {
; 4767 :             if (dev->cckd_ext)  /* Is this a compressed device? */

  000f7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ff	48 83 b8 08 13
	00 00 00	 cmp	 QWORD PTR [rax+4872], 0
  00107	0f 84 d2 00 00
	00		 je	 $LN12@cckd_sf_st

; 4768 :             {
; 4769 :                 // "%1d:%04X CCKD file: display cckd statistics"
; 4770 :                 WRMSG( HHC00332, "I", LCSS_DEVNUM );

  0010d	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00116	74 15		 je	 SHORT $LN24@cckd_sf_st
  00118	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00120	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00124	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv77[rsp], eax
  0012b	eb 0b		 jmp	 SHORT $LN25@cckd_sf_st
$LN24@cckd_sf_st:
  0012d	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv77[rsp], 0
$LN25@cckd_sf_st:
  00138	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00141	74 17		 je	 SHORT $LN26@cckd_sf_st
  00143	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0014f	d1 f8		 sar	 eax, 1
  00151	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv83[rsp], eax
  00158	eb 0b		 jmp	 SHORT $LN27@cckd_sf_st
$LN26@cckd_sf_st:
  0015a	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv83[rsp], 0
$LN27@cckd_sf_st:
  00165	b9 01 00 00 00	 mov	 ecx, 1
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00170	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv77[rsp]
  00177	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0017b	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv83[rsp]
  00182	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172149
  0018d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172150
  00199	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0019e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a3	41 b9 03 00 00
	00		 mov	 r9d, 3
  001a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172151
  001b0	ba a2 12 00 00	 mov	 edx, 4770		; 000012a2H
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172152
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4771 :                 cckd_sf_stats( dev );

  001c2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ca	e8 00 00 00 00	 call	 cckd_sf_stats

; 4772 :                 n++;

  001cf	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR n$1[rsp]
  001d6	ff c0		 inc	 eax
  001d8	89 84 24 a8 00
	00 00		 mov	 DWORD PTR n$1[rsp], eax
$LN12@cckd_sf_st:

; 4773 :             }
; 4774 :         }

  001df	e9 f0 fe ff ff	 jmp	 $LN2@cckd_sf_st
$LN3@cckd_sf_st:

; 4775 :         // "CCKD file number of devices processed: %d"
; 4776 :         WRMSG( HHC00316, "I", n );

  001e4	b9 01 00 00 00	 mov	 ecx, 1
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ef	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR n$1[rsp]
  001f6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172153
  00201	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172154
  0020d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00212	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00217	41 b9 03 00 00
	00		 mov	 r9d, 3
  0021d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172155
  00224	ba a8 12 00 00	 mov	 edx, 4776		; 000012a8H
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172156
  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4777 :         return NULL;

  00236	33 c0		 xor	 eax, eax
  00238	e9 a5 0e 00 00	 jmp	 $LN1@cckd_sf_st
$LN11@cckd_sf_st:

; 4778 :     }
; 4779 : 
; 4780 :     if (dev->cckd64)

  0023d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00245	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0024c	24 01		 and	 al, 1
  0024e	0f b6 c0	 movzx	 eax, al
  00251	85 c0		 test	 eax, eax
  00253	74 12		 je	 SHORT $LN13@cckd_sf_st

; 4781 :         return cckd64_sf_stats( data );

  00255	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0025d	e8 00 00 00 00	 call	 cckd64_sf_stats
  00262	e9 7b 0e 00 00	 jmp	 $LN1@cckd_sf_st
$LN13@cckd_sf_st:

; 4782 : 
; 4783 :     if (!(cckd = dev->cckd_ext))

  00267	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0026f	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00276	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax
  0027e	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR cckd$[rsp], 0
  00287	0f 85 bc 00 00
	00		 jne	 $LN14@cckd_sf_st

; 4784 :     {
; 4785 :         // "%1d:%04X CCKD file: device is not a cckd device"
; 4786 :         WRMSG( HHC00317, "W", LCSS_DEVNUM );

  0028d	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00296	74 15		 je	 SHORT $LN28@cckd_sf_st
  00298	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002a4	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv149[rsp], eax
  002ab	eb 0b		 jmp	 SHORT $LN29@cckd_sf_st
$LN28@cckd_sf_st:
  002ad	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv149[rsp], 0
$LN29@cckd_sf_st:
  002b8	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002c1	74 17		 je	 SHORT $LN30@cckd_sf_st
  002c3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002cb	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002cf	d1 f8		 sar	 eax, 1
  002d1	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv155[rsp], eax
  002d8	eb 0b		 jmp	 SHORT $LN31@cckd_sf_st
$LN30@cckd_sf_st:
  002da	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv155[rsp], 0
$LN31@cckd_sf_st:
  002e5	b9 01 00 00 00	 mov	 ecx, 1
  002ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f0	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv149[rsp]
  002f7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002fb	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv155[rsp]
  00302	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00306	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172159
  0030d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00312	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172160
  00319	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0031e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00323	41 b9 03 00 00
	00		 mov	 r9d, 3
  00329	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172161
  00330	ba b2 12 00 00	 mov	 edx, 4786		; 000012b2H
  00335	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172162
  0033c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4787 :         return NULL;

  00342	33 c0		 xor	 eax, eax
  00344	e9 99 0d 00 00	 jmp	 $LN1@cckd_sf_st
$LN14@cckd_sf_st:

; 4788 :     }
; 4789 : 
; 4790 :     /* Calculate totals */
; 4791 :     if (fstat( cckd->fd[0], &st ) != 0)

  00349	b8 04 00 00 00	 mov	 eax, 4
  0034e	48 6b c0 00	 imul	 rax, rax, 0
  00352	48 8d 94 24 b0
	01 00 00	 lea	 rdx, QWORD PTR st$[rsp]
  0035a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00362	8b 8c 01 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+240]
  00369	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fstat64
  0036f	85 c0		 test	 eax, eax
  00371	0f 84 8a 00 00
	00		 je	 $LN15@cckd_sf_st

; 4792 :     {
; 4793 :         // "Error in function %s: %s"
; 4794 :         WRMSG( HHC00075, "E", "fstat()", strerror( errno ));

  00377	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0037d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0037f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00385	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv173[rsp], rax
  0038d	b9 01 00 00 00	 mov	 ecx, 1
  00392	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00398	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv173[rsp]
  003a0	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172164
  003ac	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172165
  003b8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172166
  003c4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ce	41 b9 03 00 00
	00		 mov	 r9d, 3
  003d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172167
  003db	ba ba 12 00 00	 mov	 edx, 4794		; 000012baH
  003e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172168
  003e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4795 :         memset( &st, 0, sizeof( st ));

  003ed	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR st$[rsp]
  003f5	48 8b f8	 mov	 rdi, rax
  003f8	33 c0		 xor	 eax, eax
  003fa	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  003ff	f3 aa		 rep stosb
$LN15@cckd_sf_st:

; 4796 :     }
; 4797 :     for (i=0; i <= cckd->sfn; i++)

  00401	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  0040c	eb 10		 jmp	 SHORT $LN7@cckd_sf_st
$LN5@cckd_sf_st:
  0040e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00415	ff c0		 inc	 eax
  00417	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN7@cckd_sf_st:
  0041e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00426	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00429	39 84 24 98 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00430	0f 8f b9 00 00
	00		 jg	 $LN6@cckd_sf_st

; 4798 :     {
; 4799 :         if (!i) usize = st.st_size;

  00436	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR i$[rsp], 0
  0043e	75 12		 jne	 SHORT $LN16@cckd_sf_st
  00440	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR st$[rsp+24]
  00448	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR usize$[rsp], rax
  00450	eb 34		 jmp	 SHORT $LN17@cckd_sf_st
$LN16@cckd_sf_st:

; 4800 :         else usize += cckd->cdevhdr[i].cdh_size;

  00452	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0045a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00461	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00469	8b 84 01 ec 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+492]
  00470	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR usize$[rsp]
  00478	48 03 c8	 add	 rcx, rax
  0047b	48 8b c1	 mov	 rax, rcx
  0047e	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR usize$[rsp], rax
$LN17@cckd_sf_st:

; 4801 :         ufree += cckd->cdevhdr[i].free_total;

  00486	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0048e	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00495	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0049d	8b 84 01 f8 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+504]
  004a4	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ufree$[rsp]
  004ac	48 03 c8	 add	 rcx, rax
  004af	48 8b c1	 mov	 rax, rcx
  004b2	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR ufree$[rsp], rax

; 4802 :         free_count += cckd->cdevhdr[i].free_num;

  004ba	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  004c2	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004c9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  004d1	8b 84 01 00 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+512]
  004d8	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR free_count$[rsp]
  004df	03 c8		 add	 ecx, eax
  004e1	8b c1		 mov	 eax, ecx
  004e3	89 84 24 ac 00
	00 00		 mov	 DWORD PTR free_count$[rsp], eax

; 4803 :     }

  004ea	e9 1f ff ff ff	 jmp	 $LN5@cckd_sf_st
$LN6@cckd_sf_st:

; 4804 : 
; 4805 :     /* header */
; 4806 : 
; 4807 :     // "%1d:%04X   32/64       size free  nbr st   reads  writes l2reads    hits switches"
; 4808 :     WRMSG (HHC00333, "I", LCSS_DEVNUM);

  004ef	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  004f8	74 15		 je	 SHORT $LN32@cckd_sf_st
  004fa	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00502	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00506	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv218[rsp], eax
  0050d	eb 0b		 jmp	 SHORT $LN33@cckd_sf_st
$LN32@cckd_sf_st:
  0050f	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv218[rsp], 0
$LN33@cckd_sf_st:
  0051a	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00523	74 17		 je	 SHORT $LN34@cckd_sf_st
  00525	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0052d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00531	d1 f8		 sar	 eax, 1
  00533	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv224[rsp], eax
  0053a	eb 0b		 jmp	 SHORT $LN35@cckd_sf_st
$LN34@cckd_sf_st:
  0053c	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv224[rsp], 0
$LN35@cckd_sf_st:
  00547	b9 01 00 00 00	 mov	 ecx, 1
  0054c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00552	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv218[rsp]
  00559	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0055d	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv224[rsp]
  00564	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00568	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172171
  0056f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00574	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172172
  0057b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00580	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00585	41 b9 03 00 00
	00		 mov	 r9d, 3
  0058b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172173
  00592	ba c8 12 00 00	 mov	 edx, 4808		; 000012c8H
  00597	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172174
  0059e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4809 : 
; 4810 :     if (cckd->readaheads || cckd->misses)

  005a4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  005ac	83 b8 e4 00 00
	00 00		 cmp	 DWORD PTR [rax+228], 0
  005b3	75 15		 jne	 SHORT $LN19@cckd_sf_st
  005b5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  005bd	83 b8 ec 00 00
	00 00		 cmp	 DWORD PTR [rax+236], 0
  005c4	0f 84 b5 00 00
	00		 je	 $LN18@cckd_sf_st
$LN19@cckd_sf_st:

; 4811 :     // "%1d:%04X                                                      readaheads   misses"
; 4812 :     WRMSG (HHC00334, "I", LCSS_DEVNUM);

  005ca	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005d3	74 15		 je	 SHORT $LN36@cckd_sf_st
  005d5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005dd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005e1	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv242[rsp], eax
  005e8	eb 0b		 jmp	 SHORT $LN37@cckd_sf_st
$LN36@cckd_sf_st:
  005ea	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv242[rsp], 0
$LN37@cckd_sf_st:
  005f5	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005fe	74 17		 je	 SHORT $LN38@cckd_sf_st
  00600	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00608	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0060c	d1 f8		 sar	 eax, 1
  0060e	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv248[rsp], eax
  00615	eb 0b		 jmp	 SHORT $LN39@cckd_sf_st
$LN38@cckd_sf_st:
  00617	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv248[rsp], 0
$LN39@cckd_sf_st:
  00622	b9 01 00 00 00	 mov	 ecx, 1
  00627	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0062d	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv242[rsp]
  00634	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00638	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv248[rsp]
  0063f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00643	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172177
  0064a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0064f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172178
  00656	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0065b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00660	41 b9 03 00 00
	00		 mov	 r9d, 3
  00666	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172179
  0066d	ba cc 12 00 00	 mov	 edx, 4812		; 000012ccH
  00672	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172180
  00679	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@cckd_sf_st:

; 4813 : 
; 4814 :     // "%1d:%04X ------------------------------------------------------------------------"
; 4815 :     WRMSG (HHC00335, "I", LCSS_DEVNUM);

  0067f	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00688	74 15		 je	 SHORT $LN40@cckd_sf_st
  0068a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00692	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00696	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv262[rsp], eax
  0069d	eb 0b		 jmp	 SHORT $LN41@cckd_sf_st
$LN40@cckd_sf_st:
  0069f	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv262[rsp], 0
$LN41@cckd_sf_st:
  006aa	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006b3	74 17		 je	 SHORT $LN42@cckd_sf_st
  006b5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006bd	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  006c1	d1 f8		 sar	 eax, 1
  006c3	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv268[rsp], eax
  006ca	eb 0b		 jmp	 SHORT $LN43@cckd_sf_st
$LN42@cckd_sf_st:
  006cc	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv268[rsp], 0
$LN43@cckd_sf_st:
  006d7	b9 01 00 00 00	 mov	 ecx, 1
  006dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006e2	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv262[rsp]
  006e9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006ed	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv268[rsp]
  006f4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172181
  006ff	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00704	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172182
  0070b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00710	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00715	41 b9 03 00 00
	00		 mov	 r9d, 3
  0071b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172183
  00722	ba cf 12 00 00	 mov	 edx, 4815		; 000012cfH
  00727	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172184
  0072e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4816 : 
; 4817 :     /* total statistics */
; 4818 : 
; 4819 :     // "%1d:%04X [*] %s %11.11"PRId64" %3.3"PRId64"%% %4.4"PRId64"    %7.7d %7.7d %7.7d %7.7d  %7.7d"
; 4820 :     WRMSG( HHC00336, "I", LCSS_DEVNUM, dev->cckd64 ? "64" : "32", usize

  00734	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR usize$[rsp], 0
  0073d	74 1d		 je	 SHORT $LN44@cckd_sf_st
  0073f	48 6b 84 24 10
	01 00 00 64	 imul	 rax, QWORD PTR ufree$[rsp], 100 ; 00000064H
  00748	33 d2		 xor	 edx, edx
  0074a	48 f7 b4 24 b0
	00 00 00	 div	 QWORD PTR usize$[rsp]
  00752	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv326[rsp], rax
  0075a	eb 0c		 jmp	 SHORT $LN45@cckd_sf_st
$LN44@cckd_sf_st:
  0075c	48 c7 84 24 18
	01 00 00 e7 03
	00 00		 mov	 QWORD PTR tv326[rsp], 999 ; 000003e7H
$LN45@cckd_sf_st:
  00768	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00770	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00777	24 01		 and	 al, 1
  00779	0f b6 c0	 movzx	 eax, al
  0077c	85 c0		 test	 eax, eax
  0077e	74 11		 je	 SHORT $LN46@cckd_sf_st
  00780	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172185
  00787	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv333[rsp], rax
  0078f	eb 0f		 jmp	 SHORT $LN47@cckd_sf_st
$LN46@cckd_sf_st:
  00791	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172186
  00798	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv333[rsp], rax
$LN47@cckd_sf_st:
  007a0	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  007a9	74 15		 je	 SHORT $LN48@cckd_sf_st
  007ab	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007b3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  007b7	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv338[rsp], eax
  007be	eb 0b		 jmp	 SHORT $LN49@cckd_sf_st
$LN48@cckd_sf_st:
  007c0	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv338[rsp], 0
$LN49@cckd_sf_st:
  007cb	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  007d4	74 17		 je	 SHORT $LN50@cckd_sf_st
  007d6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007de	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  007e2	d1 f8		 sar	 eax, 1
  007e4	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv344[rsp], eax
  007eb	eb 0b		 jmp	 SHORT $LN51@cckd_sf_st
$LN50@cckd_sf_st:
  007ed	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv344[rsp], 0
$LN51@cckd_sf_st:
  007f8	48 63 84 24 ac
	00 00 00	 movsxd	 rax, DWORD PTR free_count$[rsp]
  00800	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv321[rsp], rax
  00808	b9 01 00 00 00	 mov	 ecx, 1
  0080d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00813	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0081b	8b 89 e8 00 00
	00		 mov	 ecx, DWORD PTR [rcx+232]
  00821	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  00828	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00830	8b 89 e0 00 00
	00		 mov	 ecx, DWORD PTR [rcx+224]
  00836	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  0083d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00845	8b 89 dc 00 00
	00		 mov	 ecx, DWORD PTR [rcx+220]
  0084b	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  0084f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00857	8b 89 d8 00 00
	00		 mov	 ecx, DWORD PTR [rcx+216]
  0085d	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00861	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00869	8b 89 d4 00 00
	00		 mov	 ecx, DWORD PTR [rcx+212]
  0086f	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00873	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv321[rsp]
  0087b	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00880	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv326[rsp]
  00888	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0088d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR usize$[rsp]
  00895	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0089a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv333[rsp]
  008a2	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008a7	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv338[rsp]
  008ae	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  008b2	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv344[rsp]
  008b9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172187
  008c4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172188
  008d0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008da	41 b9 03 00 00
	00		 mov	 r9d, 3
  008e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172189
  008e7	ba dd 12 00 00	 mov	 edx, 4829		; 000012ddH
  008ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172190
  008f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4821 : 
; 4822 :         , usize ? (ufree * 100) / usize : 999
; 4823 :         , (S64)free_count
; 4824 :         , cckd->totreads
; 4825 :         , cckd->totwrites
; 4826 :         , cckd->totl2reads
; 4827 :         , cckd->cachehits
; 4828 :         , cckd->switches
; 4829 :     );
; 4830 : 
; 4831 :     if (cckd->readaheads || cckd->misses)

  008f9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00901	83 b8 e4 00 00
	00 00		 cmp	 DWORD PTR [rax+228], 0
  00908	75 15		 jne	 SHORT $LN21@cckd_sf_st
  0090a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00912	83 b8 ec 00 00
	00 00		 cmp	 DWORD PTR [rax+236], 0
  00919	0f 84 d9 00 00
	00		 je	 $LN20@cckd_sf_st
$LN21@cckd_sf_st:

; 4832 :     // "%1d:%04X                                                         %7.7d  %7.7d"
; 4833 :     WRMSG (HHC00337, "I", LCSS_DEVNUM,

  0091f	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00928	74 15		 je	 SHORT $LN52@cckd_sf_st
  0092a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00932	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00936	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv366[rsp], eax
  0093d	eb 0b		 jmp	 SHORT $LN53@cckd_sf_st
$LN52@cckd_sf_st:
  0093f	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv366[rsp], 0
$LN53@cckd_sf_st:
  0094a	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00953	74 17		 je	 SHORT $LN54@cckd_sf_st
  00955	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0095d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00961	d1 f8		 sar	 eax, 1
  00963	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv372[rsp], eax
  0096a	eb 0b		 jmp	 SHORT $LN55@cckd_sf_st
$LN54@cckd_sf_st:
  0096c	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv372[rsp], 0
$LN55@cckd_sf_st:
  00977	b9 01 00 00 00	 mov	 ecx, 1
  0097c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00982	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0098a	8b 89 ec 00 00
	00		 mov	 ecx, DWORD PTR [rcx+236]
  00990	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00994	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0099c	8b 89 e4 00 00
	00		 mov	 ecx, DWORD PTR [rcx+228]
  009a2	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  009a6	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv366[rsp]
  009ad	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  009b1	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv372[rsp]
  009b8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  009bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172193
  009c3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172194
  009cf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009d9	41 b9 03 00 00
	00		 mov	 r9d, 3
  009df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172195
  009e6	ba e2 12 00 00	 mov	 edx, 4834		; 000012e2H
  009eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172196
  009f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN20@cckd_sf_st:

; 4834 :             cckd->readaheads, cckd->misses);
; 4835 : 
; 4836 :     /* base file statistics */
; 4837 : 
; 4838 :     // "%1d:%04X %s"
; 4839 :     WRMSG (HHC00338, "I", LCSS_DEVNUM, dev->filename);

  009f8	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00a01	74 15		 je	 SHORT $LN56@cckd_sf_st
  00a03	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a0b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00a0f	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv388[rsp], eax
  00a16	eb 0b		 jmp	 SHORT $LN57@cckd_sf_st
$LN56@cckd_sf_st:
  00a18	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv388[rsp], 0
$LN57@cckd_sf_st:
  00a23	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00a2c	74 17		 je	 SHORT $LN58@cckd_sf_st
  00a2e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a36	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00a3a	d1 f8		 sar	 eax, 1
  00a3c	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv394[rsp], eax
  00a43	eb 0b		 jmp	 SHORT $LN59@cckd_sf_st
$LN58@cckd_sf_st:
  00a45	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv394[rsp], 0
$LN59@cckd_sf_st:
  00a50	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a58	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00a5e	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv383[rsp], rax
  00a66	b9 01 00 00 00	 mov	 ecx, 1
  00a6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a71	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv383[rsp]
  00a79	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a7e	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv388[rsp]
  00a85	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a89	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv394[rsp]
  00a90	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a94	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172197
  00a9b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00aa0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172198
  00aa7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00aac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ab1	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ab7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172199
  00abe	ba e7 12 00 00	 mov	 edx, 4839		; 000012e7H
  00ac3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172200
  00aca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4840 : 
; 4841 :     // "%1d:%04X [0] %s %11.11"PRId64" %3.3"PRId64"%% %4.4"PRId64" %s %7.7d %7.7d %7.7d"
; 4842 :     WRMSG( HHC00339, "I", LCSS_DEVNUM, dev->cckd64 ? "64" : "32", st.st_size

  00ad0	48 83 bc 24 c8
	01 00 00 00	 cmp	 QWORD PTR st$[rsp+24], 0
  00ad9	74 2f		 je	 SHORT $LN60@cckd_sf_st
  00adb	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00ae0	48 6b c0 00	 imul	 rax, rax, 0
  00ae4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00aec	6b 84 01 f8 01
	00 00 64	 imul	 eax, DWORD PTR [rcx+rax+504], 100 ; 00000064H
  00af4	8b c0		 mov	 eax, eax
  00af6	48 99		 cdq
  00af8	48 f7 bc 24 c8
	01 00 00	 idiv	 QWORD PTR st$[rsp+24]
  00b00	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv438[rsp], rax
  00b08	eb 0c		 jmp	 SHORT $LN61@cckd_sf_st
$LN60@cckd_sf_st:
  00b0a	48 c7 84 24 28
	01 00 00 e7 03
	00 00		 mov	 QWORD PTR tv438[rsp], 999 ; 000003e7H
$LN61@cckd_sf_st:
  00b16	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b1e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00b25	24 01		 and	 al, 1
  00b27	0f b6 c0	 movzx	 eax, al
  00b2a	85 c0		 test	 eax, eax
  00b2c	74 11		 je	 SHORT $LN62@cckd_sf_st
  00b2e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172201
  00b35	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv445[rsp], rax
  00b3d	eb 0f		 jmp	 SHORT $LN63@cckd_sf_st
$LN62@cckd_sf_st:
  00b3f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172202
  00b46	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv445[rsp], rax
$LN63@cckd_sf_st:
  00b4e	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00b57	74 15		 je	 SHORT $LN64@cckd_sf_st
  00b59	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b61	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b65	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv450[rsp], eax
  00b6c	eb 0b		 jmp	 SHORT $LN65@cckd_sf_st
$LN64@cckd_sf_st:
  00b6e	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv450[rsp], 0
$LN65@cckd_sf_st:
  00b79	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00b82	74 17		 je	 SHORT $LN66@cckd_sf_st
  00b84	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b8c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00b90	d1 f8		 sar	 eax, 1
  00b92	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv456[rsp], eax
  00b99	eb 0b		 jmp	 SHORT $LN67@cckd_sf_st
$LN66@cckd_sf_st:
  00b9b	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv456[rsp], 0
$LN67@cckd_sf_st:
  00ba6	b8 04 00 00 00	 mov	 eax, 4
  00bab	48 6b c0 00	 imul	 rax, rax, 0
  00baf	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv406[rsp], rax
  00bb7	b9 04 00 00 00	 mov	 ecx, 4
  00bbc	48 6b c9 00	 imul	 rcx, rcx, 0
  00bc0	48 89 8c 24 68
	01 00 00	 mov	 QWORD PTR tv410[rsp], rcx
  00bc8	ba 04 00 00 00	 mov	 edx, 4
  00bcd	48 6b d2 00	 imul	 rdx, rdx, 0
  00bd1	48 89 94 24 70
	01 00 00	 mov	 QWORD PTR tv414[rsp], rdx
  00bd9	bf 01 00 00 00	 mov	 edi, 1
  00bde	48 6b ff 00	 imul	 rdi, rdi, 0
  00be2	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR cckd$[rsp]
  00bea	41 0f b6 bc 38
	1d 01 00 00	 movzx	 edi, BYTE PTR [r8+rdi+285]
  00bf3	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00bf9	4d 6b c0 00	 imul	 r8, r8, 0
  00bfd	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR cckd$[rsp]
  00c05	4f 63 84 01 00
	02 00 00	 movsxd	 r8, DWORD PTR [r9+r8+512]
  00c0d	4c 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv428[rsp], r8
  00c15	b9 01 00 00 00	 mov	 ecx, 1
  00c1a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c20	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00c28	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR tv406[rsp]
  00c30	8b 8c 11 4c 01
	00 00		 mov	 ecx, DWORD PTR [rcx+rdx+332]
  00c37	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  00c3e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00c46	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR tv410[rsp]
  00c4e	8b 8c 11 70 01
	00 00		 mov	 ecx, DWORD PTR [rcx+rdx+368]
  00c55	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00c59	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00c61	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR tv414[rsp]
  00c69	8b 8c 11 28 01
	00 00		 mov	 ecx, DWORD PTR [rcx+rdx+296]
  00c70	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00c74	48 8b 8c fc e8
	01 00 00	 mov	 rcx, QWORD PTR ost$[rsp+rdi*8]
  00c7c	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00c81	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv428[rsp]
  00c89	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00c8e	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv438[rsp]
  00c96	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00c9b	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR st$[rsp+24]
  00ca3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00ca8	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv445[rsp]
  00cb0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00cb5	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv450[rsp]
  00cbc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00cc0	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv456[rsp]
  00cc7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ccb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172203
  00cd2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00cd7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172204
  00cde	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ce3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ce8	41 b9 03 00 00
	00		 mov	 r9d, 3
  00cee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172205
  00cf5	ba f3 12 00 00	 mov	 edx, 4851		; 000012f3H
  00cfa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172206
  00d01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4843 : 
; 4844 :         , st.st_size ?
; 4845 :           ((S64)(cckd->cdevhdr[0].free_total * 100) / st.st_size) : 999
; 4846 :         ,  (S64) cckd->cdevhdr[0].free_num
; 4847 :         , ost[cckd->open[0]]
; 4848 :         , cckd->reads[0]
; 4849 :         , cckd->writes[0]
; 4850 :         , cckd->L2_reads[0]
; 4851 :     );
; 4852 : 
; 4853 :     if (dev->dasdsfn != NULL && CCKD_MAX_SF > 0)

  00d07	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d0f	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  00d17	0f 84 e7 00 00
	00		 je	 $LN22@cckd_sf_st
  00d1d	33 c0		 xor	 eax, eax
  00d1f	83 f8 01	 cmp	 eax, 1
  00d22	0f 84 dc 00 00
	00		 je	 $LN22@cckd_sf_st

; 4854 :         // "%1d:%04X %s"
; 4855 :         WRMSG (HHC00340, "I", LCSS_DEVNUM, cckd_sf_name(dev, -1));

  00d28	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d31	74 15		 je	 SHORT $LN68@cckd_sf_st
  00d33	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d3b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00d3f	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv477[rsp], eax
  00d46	eb 0b		 jmp	 SHORT $LN69@cckd_sf_st
$LN68@cckd_sf_st:
  00d48	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv477[rsp], 0
$LN69@cckd_sf_st:
  00d53	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d5c	74 17		 je	 SHORT $LN70@cckd_sf_st
  00d5e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d66	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00d6a	d1 f8		 sar	 eax, 1
  00d6c	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv483[rsp], eax
  00d73	eb 0b		 jmp	 SHORT $LN71@cckd_sf_st
$LN70@cckd_sf_st:
  00d75	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv483[rsp], 0
$LN71@cckd_sf_st:
  00d80	ba ff ff ff ff	 mov	 edx, -1
  00d85	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d8d	e8 00 00 00 00	 call	 cckd_sf_name
  00d92	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv470[rsp], rax
  00d9a	b9 01 00 00 00	 mov	 ecx, 1
  00d9f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00da5	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR tv470[rsp]
  00dad	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00db2	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv477[rsp]
  00db9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00dbd	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv483[rsp]
  00dc4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00dc8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172208
  00dcf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00dd4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172209
  00ddb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00de0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00de5	41 b9 03 00 00
	00		 mov	 r9d, 3
  00deb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172210
  00df2	ba f7 12 00 00	 mov	 edx, 4855		; 000012f7H
  00df7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172211
  00dfe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN22@cckd_sf_st:

; 4856 : 
; 4857 :     /* shadow file statistics */
; 4858 :     for (i = 1; i <= cckd->sfn; i++)

  00e04	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR i$[rsp], 1
  00e0f	eb 10		 jmp	 SHORT $LN10@cckd_sf_st
$LN8@cckd_sf_st:
  00e11	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00e18	ff c0		 inc	 eax
  00e1a	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN10@cckd_sf_st:
  00e21	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00e29	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00e2c	39 84 24 98 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00e33	0f 8f a7 02 00
	00		 jg	 $LN9@cckd_sf_st

; 4859 :     {
; 4860 :         // "%1d:%04X [%d] %s %11.11"PRId64" %3.3"PRId64"%% %4.4"PRId64" %s %7.7d %7.7d %7.7d"
; 4861 :         WRMSG( HHC00341, "I", LCSS_DEVNUM, i, dev->cckd64 ? "64" : "32", (S64)cckd->cdevhdr[i].cdh_size

  00e39	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00e41	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00e48	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00e50	83 bc 01 ec 01
	00 00 00	 cmp	 DWORD PTR [rcx+rax+492], 0
  00e58	74 4e		 je	 SHORT $LN72@cckd_sf_st
  00e5a	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00e62	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00e69	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00e71	6b 84 01 f8 01
	00 00 64	 imul	 eax, DWORD PTR [rcx+rax+504], 100 ; 00000064H
  00e79	8b c0		 mov	 eax, eax
  00e7b	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00e83	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00e8a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR cckd$[rsp]
  00e92	8b 8c 0a ec 01
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+492]
  00e99	48 99		 cdq
  00e9b	48 f7 f9	 idiv	 rcx
  00e9e	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv547[rsp], rax
  00ea6	eb 0c		 jmp	 SHORT $LN73@cckd_sf_st
$LN72@cckd_sf_st:
  00ea8	48 c7 84 24 38
	01 00 00 e7 03
	00 00		 mov	 QWORD PTR tv547[rsp], 999 ; 000003e7H
$LN73@cckd_sf_st:
  00eb4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ebc	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00ec3	24 01		 and	 al, 1
  00ec5	0f b6 c0	 movzx	 eax, al
  00ec8	85 c0		 test	 eax, eax
  00eca	74 11		 je	 SHORT $LN74@cckd_sf_st
  00ecc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172212
  00ed3	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv560[rsp], rax
  00edb	eb 0f		 jmp	 SHORT $LN75@cckd_sf_st
$LN74@cckd_sf_st:
  00edd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172213
  00ee4	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv560[rsp], rax
$LN75@cckd_sf_st:
  00eec	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00ef5	74 15		 je	 SHORT $LN76@cckd_sf_st
  00ef7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00eff	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00f03	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv566[rsp], eax
  00f0a	eb 0b		 jmp	 SHORT $LN77@cckd_sf_st
$LN76@cckd_sf_st:
  00f0c	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv566[rsp], 0
$LN77@cckd_sf_st:
  00f17	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00f20	74 17		 je	 SHORT $LN78@cckd_sf_st
  00f22	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f2a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00f2e	d1 f8		 sar	 eax, 1
  00f30	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv572[rsp], eax
  00f37	eb 0b		 jmp	 SHORT $LN79@cckd_sf_st
$LN78@cckd_sf_st:
  00f39	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv572[rsp], 0
$LN79@cckd_sf_st:
  00f44	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00f4c	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv498[rsp], rax
  00f54	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00f5c	48 89 8c 24 90
	01 00 00	 mov	 QWORD PTR tv503[rsp], rcx
  00f64	48 63 94 24 98
	00 00 00	 movsxd	 rdx, DWORD PTR i$[rsp]
  00f6c	48 89 94 24 98
	01 00 00	 mov	 QWORD PTR tv508[rsp], rdx
  00f74	48 63 bc 24 98
	00 00 00	 movsxd	 rdi, DWORD PTR i$[rsp]
  00f7c	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR cckd$[rsp]
  00f84	41 0f b6 bc 38
	1d 01 00 00	 movzx	 edi, BYTE PTR [r8+rdi+285]
  00f8d	4c 63 84 24 98
	00 00 00	 movsxd	 r8, DWORD PTR i$[rsp]
  00f95	4d 69 c0 00 02
	00 00		 imul	 r8, r8, 512		; 00000200H
  00f9c	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR cckd$[rsp]
  00fa4	4f 63 84 01 00
	02 00 00	 movsxd	 r8, DWORD PTR [r9+r8+512]
  00fac	4c 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv525[rsp], r8
  00fb4	4c 63 8c 24 98
	00 00 00	 movsxd	 r9, DWORD PTR i$[rsp]
  00fbc	4d 69 c9 00 02
	00 00		 imul	 r9, r9, 512		; 00000200H
  00fc3	4c 8b 94 24 a0
	00 00 00	 mov	 r10, QWORD PTR cckd$[rsp]
  00fcb	47 8b 8c 0a ec
	01 00 00	 mov	 r9d, DWORD PTR [r10+r9+492]
  00fd3	4c 89 8c 24 a8
	01 00 00	 mov	 QWORD PTR tv554[rsp], r9
  00fdb	b9 01 00 00 00	 mov	 ecx, 1
  00fe0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00fe6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00fee	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR tv498[rsp]
  00ff6	8b 8c 91 4c 01
	00 00		 mov	 ecx, DWORD PTR [rcx+rdx*4+332]
  00ffd	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  01004	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0100c	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR tv503[rsp]
  01014	8b 8c 91 70 01
	00 00		 mov	 ecx, DWORD PTR [rcx+rdx*4+368]
  0101b	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  01022	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0102a	48 8b 94 24 98
	01 00 00	 mov	 rdx, QWORD PTR tv508[rsp]
  01032	8b 8c 91 28 01
	00 00		 mov	 ecx, DWORD PTR [rcx+rdx*4+296]
  01039	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  0103d	48 8b 8c fc e8
	01 00 00	 mov	 rcx, QWORD PTR ost$[rsp+rdi*8]
  01045	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  0104a	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR tv525[rsp]
  01052	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  01057	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv547[rsp]
  0105f	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  01064	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR tv554[rsp]
  0106c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01071	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv560[rsp]
  01079	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0107e	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  01085	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01089	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv566[rsp]
  01090	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01094	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv572[rsp]
  0109b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0109f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172214
  010a6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172215
  010b2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010bc	41 b9 03 00 00
	00		 mov	 r9d, 3
  010c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172216
  010c9	ba 06 13 00 00	 mov	 edx, 4870		; 00001306H
  010ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172217
  010d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4862 : 
; 4863 :             , cckd->cdevhdr[i].cdh_size ?
; 4864 :               ((S64)(cckd->cdevhdr[i].free_total * 100) / cckd->cdevhdr[i].cdh_size) : 999
; 4865 :             ,  (S64) cckd->cdevhdr[i].free_num
; 4866 :             , ost[cckd->open[i]]
; 4867 :             , cckd->reads[i]
; 4868 :             , cckd->writes[i]
; 4869 :             , cckd->L2_reads[i]
; 4870 :         );
; 4871 :     }

  010db	e9 31 fd ff ff	 jmp	 $LN8@cckd_sf_st
$LN9@cckd_sf_st:

; 4872 : 
; 4873 :     return NULL;

  010e0	33 c0		 xor	 eax, eax
$LN1@cckd_sf_st:

; 4874 : } /* end function cckd_sf_stats */

  010e2	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  010ea	48 33 cc	 xor	 rcx, rsp
  010ed	e8 00 00 00 00	 call	 __security_check_cookie
  010f2	48 81 c4 10 02
	00 00		 add	 rsp, 528		; 00000210H
  010f9	5f		 pop	 rdi
  010fa	c3		 ret	 0
cckd_sf_stats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 96
cckd$ = 104
level$ = 112
n$1 = 116
tv74 = 120
tv80 = 124
tv147 = 128
tv153 = 132
tv186 = 136
tv192 = 140
rc$ = 144
tv173 = 152
data$ = 176
cckd_sf_chk PROC

; 4649 : {

$LN27:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 4650 : DEVBLK         *dev = data;             /* -> DEVBLK                 */

  0000c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00014	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax

; 4651 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 4652 : int             rc;                     /* Return code               */
; 4653 : int             level = 2;              /* Check level               */

  00019	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR level$[rsp], 2

; 4654 : 
; 4655 :     /* NULL DEVBLK == all devices? */
; 4656 :     if (!dev)

  00021	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00027	0f 85 82 01 00
	00		 jne	 $LN7@cckd_sf_ch

; 4657 :     {
; 4658 :     int n = 0;

  0002d	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0

; 4659 :         level = cckdblk.sflevel;

  00035	8b 05 14 00 00
	00		 mov	 eax, DWORD PTR cckdblk+20
  0003b	89 44 24 70	 mov	 DWORD PTR level$[rsp], eax

; 4660 :         cckdblk.sflevel = 0;

  0003f	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+20, 0

; 4661 :         for (dev=sysblk.firstdev; dev; dev=dev->nextdev)

  00049	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00050	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00057	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
  0005c	eb 0e		 jmp	 SHORT $LN4@cckd_sf_ch
$LN2@cckd_sf_ch:
  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00063	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00067	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd_sf_ch:
  0006c	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00072	0f 84 e1 00 00
	00		 je	 $LN3@cckd_sf_ch

; 4662 :         {
; 4663 :             if ((cckd = dev->cckd_ext)) /* Compressed device? */

  00078	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0007d	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00084	48 89 44 24 68	 mov	 QWORD PTR cckd$[rsp], rax
  00089	48 83 7c 24 68
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  0008f	0f 84 bf 00 00
	00		 je	 $LN8@cckd_sf_ch

; 4664 :             {
; 4665 :                 // "%1d:%04X CCKD file: checking level %d..."
; 4666 :                 WRMSG( HHC00330, "I", LCSS_DEVNUM, level );

  00095	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0009b	74 0f		 je	 SHORT $LN15@cckd_sf_ch
  0009d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000a2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000a6	89 44 24 78	 mov	 DWORD PTR tv74[rsp], eax
  000aa	eb 08		 jmp	 SHORT $LN16@cckd_sf_ch
$LN15@cckd_sf_ch:
  000ac	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN16@cckd_sf_ch:
  000b4	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000ba	74 11		 je	 SHORT $LN17@cckd_sf_ch
  000bc	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000c1	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000c5	d1 f8		 sar	 eax, 1
  000c7	89 44 24 7c	 mov	 DWORD PTR tv80[rsp], eax
  000cb	eb 08		 jmp	 SHORT $LN18@cckd_sf_ch
$LN17@cckd_sf_ch:
  000cd	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@cckd_sf_ch:
  000d5	b9 01 00 00 00	 mov	 ecx, 1
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e0	8b 4c 24 70	 mov	 ecx, DWORD PTR level$[rsp]
  000e4	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000e8	8b 4c 24 78	 mov	 ecx, DWORD PTR tv74[rsp]
  000ec	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f0	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv80[rsp]
  000f4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172078
  000ff	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172079
  0010b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00110	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00115	41 b9 03 00 00
	00		 mov	 r9d, 3
  0011b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172080
  00122	ba 3a 12 00 00	 mov	 edx, 4666		; 0000123aH
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172081
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4667 :                 cckd->sflevel = level;

  00134	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00139	8b 4c 24 70	 mov	 ecx, DWORD PTR level$[rsp]
  0013d	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 4668 :                 cckd_sf_chk( dev );

  00140	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00145	e8 00 00 00 00	 call	 cckd_sf_chk

; 4669 :                 n++;

  0014a	8b 44 24 74	 mov	 eax, DWORD PTR n$1[rsp]
  0014e	ff c0		 inc	 eax
  00150	89 44 24 74	 mov	 DWORD PTR n$1[rsp], eax
$LN8@cckd_sf_ch:

; 4670 :             }
; 4671 :         }

  00154	e9 05 ff ff ff	 jmp	 $LN2@cckd_sf_ch
$LN3@cckd_sf_ch:

; 4672 :         // "CCKD file number of devices processed: %d"
; 4673 :         WRMSG( HHC00316, "I", n );

  00159	b9 01 00 00 00	 mov	 ecx, 1
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00164	8b 4c 24 74	 mov	 ecx, DWORD PTR n$1[rsp]
  00168	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172082
  00173	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00178	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172083
  0017f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00184	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00189	41 b9 03 00 00
	00		 mov	 r9d, 3
  0018f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172084
  00196	ba 41 12 00 00	 mov	 edx, 4673		; 00001241H
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172085
  001a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4674 :         return NULL;

  001a8	33 c0		 xor	 eax, eax
  001aa	e9 e5 03 00 00	 jmp	 $LN1@cckd_sf_ch
$LN7@cckd_sf_ch:

; 4675 :     }
; 4676 : 
; 4677 :     if (dev->cckd64)

  001af	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001b4	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  001bb	24 01		 and	 al, 1
  001bd	0f b6 c0	 movzx	 eax, al
  001c0	85 c0		 test	 eax, eax
  001c2	74 12		 je	 SHORT $LN9@cckd_sf_ch

; 4678 :         return cckd64_sf_chk( data );

  001c4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  001cc	e8 00 00 00 00	 call	 cckd64_sf_chk
  001d1	e9 be 03 00 00	 jmp	 $LN1@cckd_sf_ch
$LN9@cckd_sf_ch:

; 4679 : 
; 4680 :     if (!(cckd = dev->cckd_ext))

  001d6	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001db	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  001e2	48 89 44 24 68	 mov	 QWORD PTR cckd$[rsp], rax
  001e7	48 83 7c 24 68
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  001ed	0f 85 b0 00 00
	00		 jne	 $LN10@cckd_sf_ch

; 4681 :     {
; 4682 :         // "%1d:%04X CCKD file: device is not a cckd device"
; 4683 :         WRMSG( HHC00317, "W",  LCSS_DEVNUM );

  001f3	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001f9	74 12		 je	 SHORT $LN19@cckd_sf_ch
  001fb	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00200	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00204	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv147[rsp], eax
  0020b	eb 0b		 jmp	 SHORT $LN20@cckd_sf_ch
$LN19@cckd_sf_ch:
  0020d	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv147[rsp], 0
$LN20@cckd_sf_ch:
  00218	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0021e	74 14		 je	 SHORT $LN21@cckd_sf_ch
  00220	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00225	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00229	d1 f8		 sar	 eax, 1
  0022b	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv153[rsp], eax
  00232	eb 0b		 jmp	 SHORT $LN22@cckd_sf_ch
$LN21@cckd_sf_ch:
  00234	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv153[rsp], 0
$LN22@cckd_sf_ch:
  0023f	b9 01 00 00 00	 mov	 ecx, 1
  00244	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0024a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv147[rsp]
  00251	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00255	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv153[rsp]
  0025c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00260	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172088
  00267	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0026c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172089
  00273	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00278	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00283	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172090
  0028a	ba 4b 12 00 00	 mov	 edx, 4683		; 0000124bH
  0028f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172091
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4684 :         return NULL;

  0029c	33 c0		 xor	 eax, eax
  0029e	e9 f1 02 00 00	 jmp	 $LN1@cckd_sf_ch
$LN10@cckd_sf_ch:

; 4685 :     }
; 4686 : 
; 4687 :     level = cckd->sflevel;

  002a3	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002a8	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  002ab	89 44 24 70	 mov	 DWORD PTR level$[rsp], eax

; 4688 :     cckd->sflevel = 0;

  002af	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002b4	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 4689 : 
; 4690 :     /* schedule updated track entries to be written */
; 4691 :     obtain_lock( &cckd->cckdiolock );

  002bb	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002c0	48 83 c0 18	 add	 rax, 24
  002c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172092
  002cb	48 8b c8	 mov	 rcx, rax
  002ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4692 :     {
; 4693 :         if (cckd->merging)

  002d4	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002d9	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002dc	c1 e8 05	 shr	 eax, 5
  002df	83 e0 01	 and	 eax, 1
  002e2	85 c0		 test	 eax, eax
  002e4	0f 84 fc 00 00
	00		 je	 $LN11@cckd_sf_ch

; 4694 :         {
; 4695 :             release_lock( &cckd->cckdiolock );

  002ea	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002ef	48 83 c0 18	 add	 rax, 24
  002f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172094
  002fa	48 8b c8	 mov	 rcx, rax
  002fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4696 :             // "%1d:%04X CCKD file[%d] %s: shadow file check failed, sf command busy on device"
; 4697 :             WRMSG( HHC00331, "W", LCSS_DEVNUM, cckd->sfn, cckd_sf_name( dev, cckd->sfn ));

  00303	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00309	74 12		 je	 SHORT $LN23@cckd_sf_ch
  0030b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00310	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00314	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv186[rsp], eax
  0031b	eb 0b		 jmp	 SHORT $LN24@cckd_sf_ch
$LN23@cckd_sf_ch:
  0031d	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv186[rsp], 0
$LN24@cckd_sf_ch:
  00328	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0032e	74 14		 je	 SHORT $LN25@cckd_sf_ch
  00330	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00335	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00339	d1 f8		 sar	 eax, 1
  0033b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv192[rsp], eax
  00342	eb 0b		 jmp	 SHORT $LN26@cckd_sf_ch
$LN25@cckd_sf_ch:
  00344	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv192[rsp], 0
$LN26@cckd_sf_ch:
  0034f	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00354	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00357	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0035c	e8 00 00 00 00	 call	 cckd_sf_name
  00361	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv173[rsp], rax
  00369	b9 01 00 00 00	 mov	 ecx, 1
  0036e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00374	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv173[rsp]
  0037c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00381	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00386	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00389	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0038d	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv186[rsp]
  00394	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00398	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv192[rsp]
  0039f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172095
  003aa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172096
  003b6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003c0	41 b9 03 00 00
	00		 mov	 r9d, 3
  003c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172097
  003cd	ba 59 12 00 00	 mov	 edx, 4697		; 00001259H
  003d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172098
  003d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4698 :             return NULL;

  003df	33 c0		 xor	 eax, eax
  003e1	e9 ae 01 00 00	 jmp	 $LN1@cckd_sf_ch
$LN11@cckd_sf_ch:

; 4699 :         }
; 4700 : 
; 4701 :         cckd->merging = 1;

  003e6	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003eb	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003ee	83 c8 20	 or	 eax, 32			; 00000020H
  003f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  003f6	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4702 :         cckd_flush_cache( dev );

  003f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003fe	e8 00 00 00 00	 call	 cckd_flush_cache
$LN5@cckd_sf_ch:

; 4703 : 
; 4704 :         while (cckd->wrpending || cckd->cckdioact)

  00403	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00408	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  0040c	75 12		 jne	 SHORT $LN12@cckd_sf_ch
  0040e	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00413	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00416	c1 e8 02	 shr	 eax, 2
  00419	83 e0 01	 and	 eax, 1
  0041c	85 c0		 test	 eax, eax
  0041e	74 52		 je	 SHORT $LN6@cckd_sf_ch
$LN12@cckd_sf_ch:

; 4705 :         {
; 4706 :             cckd->cckdwaiters++;

  00420	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00425	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00428	ff c0		 inc	 eax
  0042a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  0042f	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 4707 :             {
; 4708 :                 wait_condition( &cckd->cckdiocond, &cckd->cckdiolock );

  00432	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00437	48 83 c0 18	 add	 rax, 24
  0043b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00440	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00444	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172100
  0044b	48 8b d0	 mov	 rdx, rax
  0044e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 4709 :             }
; 4710 :             cckd->cckdwaiters--;

  00454	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00459	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0045c	ff c8		 dec	 eax
  0045e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00463	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 4711 :             cckd_flush_cache( dev );

  00466	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0046b	e8 00 00 00 00	 call	 cckd_flush_cache

; 4712 :         }

  00470	eb 91		 jmp	 SHORT $LN5@cckd_sf_ch
$LN6@cckd_sf_ch:

; 4713 :         cckd_purge_cache( dev );

  00472	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00477	e8 00 00 00 00	 call	 cckd_purge_cache

; 4714 :         cckd_purge_l2( dev );

  0047c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00481	e8 00 00 00 00	 call	 cckd_purge_l2

; 4715 :         dev->bufcur = -1;

  00486	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0048b	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 4716 :         dev->cache  = -1;

  00495	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0049a	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1

; 4717 :     }
; 4718 :     release_lock( &cckd->cckdiolock );

  004a4	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004a9	48 83 c0 18	 add	 rax, 24
  004ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172101
  004b4	48 8b c8	 mov	 rcx, rax
  004b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4719 : 
; 4720 :     /* obtain control of the file */
; 4721 :     obtain_lock( &cckd->filelock );

  004bd	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004c2	48 83 c0 10	 add	 rax, 16
  004c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172102
  004cd	48 8b c8	 mov	 rcx, rax
  004d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4722 :     {
; 4723 :         /* harden the current file */
; 4724 :         cckd_harden( dev );

  004d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  004db	e8 00 00 00 00	 call	 cckd_harden

; 4725 : 
; 4726 :         /* Call the chkdsk function */
; 4727 :         rc = cckd_chkdsk( dev, level );

  004e0	8b 54 24 70	 mov	 edx, DWORD PTR level$[rsp]
  004e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  004e9	e8 00 00 00 00	 call	 cckd_chkdsk
  004ee	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4728 : 
; 4729 :         /* Perform initial read */
; 4730 :         rc = cckd_read_init( dev );

  004f5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  004fa	e8 00 00 00 00	 call	 cckd_read_init
  004ff	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4731 :     }
; 4732 :     release_lock( &cckd->filelock );

  00506	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0050b	48 83 c0 10	 add	 rax, 16
  0050f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172103
  00516	48 8b c8	 mov	 rcx, rax
  00519	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4733 : 
; 4734 :     obtain_lock( &cckd->cckdiolock );

  0051f	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00524	48 83 c0 18	 add	 rax, 24
  00528	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172104
  0052f	48 8b c8	 mov	 rcx, rax
  00532	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4735 :     {
; 4736 :         cckd->merging = 0;

  00538	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0053d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00540	83 e0 df	 and	 eax, -33		; ffffffdfH
  00543	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00548	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4737 :         if (cckd->cckdwaiters)

  0054b	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00550	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00554	74 19		 je	 SHORT $LN13@cckd_sf_ch

; 4738 :             broadcast_condition( &cckd->cckdiocond );

  00556	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0055b	48 83 c0 20	 add	 rax, 32			; 00000020H
  0055f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172106
  00566	48 8b c8	 mov	 rcx, rax
  00569	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN13@cckd_sf_ch:

; 4739 :     }
; 4740 :     release_lock( &cckd->cckdiolock );

  0056f	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00574	48 83 c0 18	 add	 rax, 24
  00578	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172107
  0057f	48 8b c8	 mov	 rcx, rax
  00582	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4741 : 
; 4742 :     /* Display the shadow file statistics */
; 4743 :     cckd_sf_stats( dev );

  00588	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0058d	e8 00 00 00 00	 call	 cckd_sf_stats

; 4744 : 
; 4745 :     return NULL;

  00592	33 c0		 xor	 eax, eax
$LN1@cckd_sf_ch:

; 4746 : } /* end function cckd_sf_chk */

  00594	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0059b	c3		 ret	 0
cckd_sf_chk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 96
cckd$ = 104
n$1 = 112
tv73 = 116
tv79 = 120
tv145 = 124
tv151 = 128
tv182 = 132
tv188 = 136
rc$ = 140
tv169 = 144
data$ = 176
cckd_sf_comp PROC

; 4558 : {

$LN27:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 4559 : DEVBLK         *dev = data;             /* -> DEVBLK                 */

  0000c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00014	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax

; 4560 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 4561 : int             rc;                     /* Return code               */
; 4562 : 
; 4563 :     /* NULL DEVBLK == all devices? */
; 4564 :     if (!dev)

  00019	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0001f	0f 85 50 01 00
	00		 jne	 $LN7@cckd_sf_co

; 4565 :     {
; 4566 :     int n = 0;

  00025	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0

; 4567 :         for (dev=sysblk.firstdev; dev; dev=dev->nextdev)

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00034	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  0003b	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
  00040	eb 0e		 jmp	 SHORT $LN4@cckd_sf_co
$LN2@cckd_sf_co:
  00042	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00047	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0004b	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd_sf_co:
  00050	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00056	0f 84 c3 00 00
	00		 je	 $LN3@cckd_sf_co

; 4568 :         {
; 4569 :             if (dev->cckd_ext)  /* Is this a compressed device? */

  0005c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00061	48 83 b8 08 13
	00 00 00	 cmp	 QWORD PTR [rax+4872], 0
  00069	0f 84 ab 00 00
	00		 je	 $LN8@cckd_sf_co

; 4570 :             {
; 4571 :                 // "%1d:%04X CCKD file: compressing shadow files..."
; 4572 :                 WRMSG( HHC00328, "I", LCSS_DEVNUM );

  0006f	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00075	74 0f		 je	 SHORT $LN15@cckd_sf_co
  00077	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0007c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00080	89 44 24 74	 mov	 DWORD PTR tv73[rsp], eax
  00084	eb 08		 jmp	 SHORT $LN16@cckd_sf_co
$LN15@cckd_sf_co:
  00086	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN16@cckd_sf_co:
  0008e	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00094	74 11		 je	 SHORT $LN17@cckd_sf_co
  00096	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0009b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0009f	d1 f8		 sar	 eax, 1
  000a1	89 44 24 78	 mov	 DWORD PTR tv79[rsp], eax
  000a5	eb 08		 jmp	 SHORT $LN18@cckd_sf_co
$LN17@cckd_sf_co:
  000a7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN18@cckd_sf_co:
  000af	b9 01 00 00 00	 mov	 ecx, 1
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ba	8b 4c 24 74	 mov	 ecx, DWORD PTR tv73[rsp]
  000be	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c2	8b 4c 24 78	 mov	 ecx, DWORD PTR tv79[rsp]
  000c6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172029
  000d1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172030
  000dd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172031
  000f4	ba dc 11 00 00	 mov	 edx, 4572		; 000011dcH
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172032
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4573 :                 cckd_sf_comp( dev );

  00106	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0010b	e8 00 00 00 00	 call	 cckd_sf_comp

; 4574 :                 n++;

  00110	8b 44 24 70	 mov	 eax, DWORD PTR n$1[rsp]
  00114	ff c0		 inc	 eax
  00116	89 44 24 70	 mov	 DWORD PTR n$1[rsp], eax
$LN8@cckd_sf_co:

; 4575 :             }
; 4576 :         }

  0011a	e9 23 ff ff ff	 jmp	 $LN2@cckd_sf_co
$LN3@cckd_sf_co:

; 4577 :         // "CCKD file number of devices processed: %d"
; 4578 :         WRMSG ( HHC00316, "I", n );

  0011f	b9 01 00 00 00	 mov	 ecx, 1
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012a	8b 4c 24 70	 mov	 ecx, DWORD PTR n$1[rsp]
  0012e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172033
  00139	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172034
  00145	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00155	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172035
  0015c	ba e2 11 00 00	 mov	 edx, 4578		; 000011e2H
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172036
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4579 :         return NULL;

  0016e	33 c0		 xor	 eax, eax
  00170	e9 c0 03 00 00	 jmp	 $LN1@cckd_sf_co
$LN7@cckd_sf_co:

; 4580 :     }
; 4581 : 
; 4582 :     if (dev->cckd64)

  00175	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0017a	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00181	24 01		 and	 al, 1
  00183	0f b6 c0	 movzx	 eax, al
  00186	85 c0		 test	 eax, eax
  00188	74 12		 je	 SHORT $LN9@cckd_sf_co

; 4583 :         return cckd64_sf_comp( data );

  0018a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00192	e8 00 00 00 00	 call	 cckd64_sf_comp
  00197	e9 99 03 00 00	 jmp	 $LN1@cckd_sf_co
$LN9@cckd_sf_co:

; 4584 : 
; 4585 :     if (!(cckd = dev->cckd_ext))

  0019c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001a1	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  001a8	48 89 44 24 68	 mov	 QWORD PTR cckd$[rsp], rax
  001ad	48 83 7c 24 68
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  001b3	0f 85 a7 00 00
	00		 jne	 $LN10@cckd_sf_co

; 4586 :     {
; 4587 :         // "%1d:%04X CCKD file: device is not a cckd device"
; 4588 :         WRMSG( HHC00317, "W",  LCSS_DEVNUM );

  001b9	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001bf	74 0f		 je	 SHORT $LN19@cckd_sf_co
  001c1	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001c6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001ca	89 44 24 7c	 mov	 DWORD PTR tv145[rsp], eax
  001ce	eb 08		 jmp	 SHORT $LN20@cckd_sf_co
$LN19@cckd_sf_co:
  001d0	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN20@cckd_sf_co:
  001d8	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001de	74 14		 je	 SHORT $LN21@cckd_sf_co
  001e0	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001e5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001e9	d1 f8		 sar	 eax, 1
  001eb	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv151[rsp], eax
  001f2	eb 0b		 jmp	 SHORT $LN22@cckd_sf_co
$LN21@cckd_sf_co:
  001f4	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv151[rsp], 0
$LN22@cckd_sf_co:
  001ff	b9 01 00 00 00	 mov	 ecx, 1
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0020a	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv145[rsp]
  0020e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00212	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv151[rsp]
  00219	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0021d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172039
  00224	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172040
  00230	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00235	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00240	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172041
  00247	ba ec 11 00 00	 mov	 edx, 4588		; 000011ecH
  0024c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172042
  00253	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4589 :         return NULL;

  00259	33 c0		 xor	 eax, eax
  0025b	e9 d5 02 00 00	 jmp	 $LN1@cckd_sf_co
$LN10@cckd_sf_co:

; 4590 :     }
; 4591 : 
; 4592 :     /* schedule updated track entries to be written */
; 4593 :     obtain_lock( &cckd->cckdiolock );

  00260	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00265	48 83 c0 18	 add	 rax, 24
  00269	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172043
  00270	48 8b c8	 mov	 rcx, rax
  00273	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4594 :     {
; 4595 :         if (cckd->merging)

  00279	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0027e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00281	c1 e8 05	 shr	 eax, 5
  00284	83 e0 01	 and	 eax, 1
  00287	85 c0		 test	 eax, eax
  00289	0f 84 fc 00 00
	00		 je	 $LN11@cckd_sf_co

; 4596 :         {
; 4597 :             release_lock( &cckd->cckdiolock );

  0028f	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00294	48 83 c0 18	 add	 rax, 24
  00298	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172045
  0029f	48 8b c8	 mov	 rcx, rax
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4598 :             // "%1d:%04X CCKD file[%d] %s: error compressing shadow file, sf command busy on device"
; 4599 :             WRMSG( HHC00329, "W",  LCSS_DEVNUM, cckd->sfn, cckd_sf_name(dev, cckd->sfn) );

  002a8	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002ae	74 12		 je	 SHORT $LN23@cckd_sf_co
  002b0	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002b5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002b9	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv182[rsp], eax
  002c0	eb 0b		 jmp	 SHORT $LN24@cckd_sf_co
$LN23@cckd_sf_co:
  002c2	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv182[rsp], 0
$LN24@cckd_sf_co:
  002cd	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002d3	74 14		 je	 SHORT $LN25@cckd_sf_co
  002d5	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002da	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002de	d1 f8		 sar	 eax, 1
  002e0	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv188[rsp], eax
  002e7	eb 0b		 jmp	 SHORT $LN26@cckd_sf_co
$LN25@cckd_sf_co:
  002e9	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv188[rsp], 0
$LN26@cckd_sf_co:
  002f4	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002f9	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  002fc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00301	e8 00 00 00 00	 call	 cckd_sf_name
  00306	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv169[rsp], rax
  0030e	b9 01 00 00 00	 mov	 ecx, 1
  00313	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00319	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv169[rsp]
  00321	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00326	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  0032b	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  0032e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00332	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv182[rsp]
  00339	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0033d	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv188[rsp]
  00344	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00348	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172046
  0034f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00354	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172047
  0035b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00360	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00365	41 b9 03 00 00
	00		 mov	 r9d, 3
  0036b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172048
  00372	ba f7 11 00 00	 mov	 edx, 4599		; 000011f7H
  00377	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172049
  0037e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4600 :             return NULL;

  00384	33 c0		 xor	 eax, eax
  00386	e9 aa 01 00 00	 jmp	 $LN1@cckd_sf_co
$LN11@cckd_sf_co:

; 4601 :         }
; 4602 :         cckd->merging = 1;

  0038b	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00390	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00393	83 c8 20	 or	 eax, 32			; 00000020H
  00396	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  0039b	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4603 :         cckd_flush_cache( dev );

  0039e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003a3	e8 00 00 00 00	 call	 cckd_flush_cache
$LN5@cckd_sf_co:

; 4604 :         while (cckd->wrpending || cckd->cckdioact)

  003a8	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003ad	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  003b1	75 12		 jne	 SHORT $LN12@cckd_sf_co
  003b3	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003b8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003bb	c1 e8 02	 shr	 eax, 2
  003be	83 e0 01	 and	 eax, 1
  003c1	85 c0		 test	 eax, eax
  003c3	74 52		 je	 SHORT $LN6@cckd_sf_co
$LN12@cckd_sf_co:

; 4605 :         {
; 4606 :             cckd->cckdwaiters++;

  003c5	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003ca	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  003cd	ff c0		 inc	 eax
  003cf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  003d4	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 4607 :             wait_condition( &cckd->cckdiocond, &cckd->cckdiolock );

  003d7	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003dc	48 83 c0 18	 add	 rax, 24
  003e0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  003e5	48 83 c1 20	 add	 rcx, 32			; 00000020H
  003e9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172051
  003f0	48 8b d0	 mov	 rdx, rax
  003f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 4608 :             cckd->cckdwaiters--;

  003f9	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003fe	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00401	ff c8		 dec	 eax
  00403	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00408	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 4609 :             cckd_flush_cache( dev );

  0040b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00410	e8 00 00 00 00	 call	 cckd_flush_cache

; 4610 :         }

  00415	eb 91		 jmp	 SHORT $LN5@cckd_sf_co
$LN6@cckd_sf_co:

; 4611 :         cckd_purge_cache( dev );

  00417	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0041c	e8 00 00 00 00	 call	 cckd_purge_cache

; 4612 :         cckd_purge_l2( dev );

  00421	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00426	e8 00 00 00 00	 call	 cckd_purge_l2

; 4613 :         dev->bufcur = dev->cache = -1;

  0042b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00430	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0043a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0043f	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 4614 :     }
; 4615 :     release_lock( &cckd->cckdiolock );

  00449	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0044e	48 83 c0 18	 add	 rax, 24
  00452	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172052
  00459	48 8b c8	 mov	 rcx, rax
  0045c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4616 : 
; 4617 :     /* obtain control of the file */
; 4618 :     obtain_lock( &cckd->filelock );

  00462	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00467	48 83 c0 10	 add	 rax, 16
  0046b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172053
  00472	48 8b c8	 mov	 rcx, rax
  00475	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4619 :     {
; 4620 :         /* harden the current file */
; 4621 :         cckd_harden( dev );

  0047b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00480	e8 00 00 00 00	 call	 cckd_harden

; 4622 : 
; 4623 :         /* Call the compress function */
; 4624 :         rc = cckd_comp( dev );

  00485	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0048a	e8 00 00 00 00	 call	 cckd_comp
  0048f	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4625 : 
; 4626 :         /* Perform initial read */
; 4627 :         rc = cckd_read_init( dev );

  00496	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0049b	e8 00 00 00 00	 call	 cckd_read_init
  004a0	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4628 :     }
; 4629 :     release_lock( &cckd->filelock );

  004a7	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004ac	48 83 c0 10	 add	 rax, 16
  004b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172054
  004b7	48 8b c8	 mov	 rcx, rax
  004ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4630 : 
; 4631 :     obtain_lock( &cckd->cckdiolock );

  004c0	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004c5	48 83 c0 18	 add	 rax, 24
  004c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172055
  004d0	48 8b c8	 mov	 rcx, rax
  004d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4632 :     {
; 4633 :         cckd->merging = 0;

  004d9	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004de	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  004e1	83 e0 df	 and	 eax, -33		; ffffffdfH
  004e4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  004e9	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4634 :         if (cckd->cckdwaiters)

  004ec	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004f1	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  004f5	74 19		 je	 SHORT $LN13@cckd_sf_co

; 4635 :             broadcast_condition( &cckd->cckdiocond );

  004f7	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004fc	48 83 c0 20	 add	 rax, 32			; 00000020H
  00500	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172057
  00507	48 8b c8	 mov	 rcx, rax
  0050a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN13@cckd_sf_co:

; 4636 :     }
; 4637 :     release_lock( &cckd->cckdiolock );

  00510	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00515	48 83 c0 18	 add	 rax, 24
  00519	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172058
  00520	48 8b c8	 mov	 rcx, rax
  00523	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4638 : 
; 4639 :     /* Display the shadow file statistics */
; 4640 :     cckd_sf_stats( dev );

  00529	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0052e	e8 00 00 00 00	 call	 cckd_sf_stats

; 4641 : 
; 4642 :     return NULL;

  00533	33 c0		 xor	 eax, eax
$LN1@cckd_sf_co:

; 4643 : } /* end function cckd_sf_comp */

  00535	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0053c	c3		 ret	 0
cckd_sf_comp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 112
cckd$ = 120
to_sfx$ = 128
from_sfx$ = 132
i$ = 136
j$ = 140
pos$ = 144
len$ = 152
merge$ = 156
l2updated$ = 160
force$ = 164
size$ = 168
trk$ = 172
new_l2$ = 176
n$1 = 184
add$ = 188
tv188 = 192
tv228 = 196
tv234 = 200
tv326 = 204
tv332 = 208
tv370 = 212
tv376 = 216
tv427 = 220
tv433 = 224
tv461 = 228
tv467 = 232
tv820 = 236
tv826 = 240
tv906 = 244
tv912 = 248
tv932 = 252
tv938 = 256
tv79 = 260
tv85 = 264
tv163 = 268
tv169 = 272
fix$ = 276
rc$ = 280
tv199 = 288
tv202 = 296
tv415 = 304
tv808 = 312
tv810 = 320
tv215 = 328
tv281 = 336
tv361 = 344
tv419 = 352
tv453 = 360
tv812 = 368
tv898 = 376
tv924 = 384
to_l2$ = 400
from_l2$ = 2448
buf$ = 4496
__$ArrayPad$ = 70032
data$ = 70064
cckd_sf_remove PROC

; 4211 : {

$LN111:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	b8 a0 11 01 00	 mov	 eax, 70048		; 000111a0H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	48 2b e0	 sub	 rsp, rax
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 90
	11 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4212 : DEVBLK         *dev = data;             /* -> DEVBLK                 */

  00025	48 8b 84 24 b0
	11 01 00	 mov	 rax, QWORD PTR data$[rsp]
  0002d	48 89 44 24 70	 mov	 QWORD PTR dev$[rsp], rax

; 4213 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 4214 : int             rc;                     /* Return code               */
; 4215 : int             from_sfx, to_sfx;       /* From/to file index        */
; 4216 : int             fix;                    /* nullfmt index             */
; 4217 : int             add = 0;                /* 1=Add shadow file back    */

  00032	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR add$[rsp], 0

; 4218 : int             l2updated = 0;          /* 1=L2 table was updated    */

  0003d	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR l2updated$[rsp], 0

; 4219 : int             i,j;                    /* Loop indexes              */
; 4220 : int             merge, force;           /* Flags                     */
; 4221 : off_t           pos;                    /* File offset               */
; 4222 : unsigned int    len;                    /* Length to read/write      */
; 4223 : int             size;                   /* Image size                */
; 4224 : int             trk = -1;               /* Track being read/written  */

  00048	c7 84 24 ac 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR trk$[rsp], -1

; 4225 : CCKD_L2ENT      from_l2[256],           /* Level 2 tables            */
; 4226 :                 to_l2[256];
; 4227 : CCKD_L2ENT      new_l2;                 /* New level 2 table entry   */
; 4228 : BYTE            buf[64*1024];           /* Buffer                    */
; 4229 : 
; 4230 :     /* NULL DEVBLK == all devices? */
; 4231 :     if (!dev)

  00053	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00059	0f 85 06 02 00
	00		 jne	 $LN13@cckd_sf_re

; 4232 :     {
; 4233 :     int n = 0;

  0005f	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR n$1[rsp], 0

; 4234 :         merge = cckdblk.sfmerge;

  0006a	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00070	c1 e8 03	 shr	 eax, 3
  00073	83 e0 01	 and	 eax, 1
  00076	89 84 24 9c 00
	00 00		 mov	 DWORD PTR merge$[rsp], eax

; 4235 :         force = cckdblk.sfforce;

  0007d	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00083	c1 e8 04	 shr	 eax, 4
  00086	83 e0 01	 and	 eax, 1
  00089	89 84 24 a4 00
	00 00		 mov	 DWORD PTR force$[rsp], eax

; 4236 :         cckdblk.sfmerge = cckdblk.sfforce = 0;

  00090	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00096	83 e0 ef	 and	 eax, -17		; ffffffefH
  00099	89 05 10 00 00
	00		 mov	 DWORD PTR cckdblk+16, eax
  0009f	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  000a5	83 e0 f7	 and	 eax, -9			; fffffff7H
  000a8	89 05 10 00 00
	00		 mov	 DWORD PTR cckdblk+16, eax

; 4237 :         for (dev=sysblk.firstdev; dev; dev=dev->nextdev)

  000ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b5	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  000bc	48 89 44 24 70	 mov	 QWORD PTR dev$[rsp], rax
  000c1	eb 0e		 jmp	 SHORT $LN4@cckd_sf_re
$LN2@cckd_sf_re:
  000c3	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000c8	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000cc	48 89 44 24 70	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd_sf_re:
  000d1	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000d7	0f 84 2f 01 00
	00		 je	 $LN3@cckd_sf_re

; 4238 :         {
; 4239 :             if ((cckd = dev->cckd_ext))

  000dd	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000e2	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  000e9	48 89 44 24 78	 mov	 QWORD PTR cckd$[rsp], rax
  000ee	48 83 7c 24 78
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  000f4	0f 84 0d 01 00
	00		 je	 $LN14@cckd_sf_re

; 4240 :             {
; 4241 :                 // "%1d:%04X CCKD file: merging shadow files..."
; 4242 :                 WRMSG( HHC00321, "I", LCSS_DEVNUM );

  000fa	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00100	74 12		 je	 SHORT $LN59@cckd_sf_re
  00102	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00107	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0010b	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv79[rsp], eax
  00112	eb 0b		 jmp	 SHORT $LN60@cckd_sf_re
$LN59@cckd_sf_re:
  00114	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv79[rsp], 0
$LN60@cckd_sf_re:
  0011f	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00125	74 14		 je	 SHORT $LN61@cckd_sf_re
  00127	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0012c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00130	d1 f8		 sar	 eax, 1
  00132	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv85[rsp], eax
  00139	eb 0b		 jmp	 SHORT $LN62@cckd_sf_re
$LN61@cckd_sf_re:
  0013b	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv85[rsp], 0
$LN62@cckd_sf_re:
  00146	b9 01 00 00 00	 mov	 ecx, 1
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00151	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv79[rsp]
  00158	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0015c	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv85[rsp]
  00163	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171892
  0016e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171893
  0017a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0017f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00184	41 b9 03 00 00
	00		 mov	 r9d, 3
  0018a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171894
  00191	ba 92 10 00 00	 mov	 edx, 4242		; 00001092H
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171895
  0019d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4243 :                 cckd->sfmerge = merge;

  001a3	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR merge$[rsp]
  001aa	83 e0 01	 and	 eax, 1
  001ad	c1 e0 09	 shl	 eax, 9
  001b0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001b5	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  001b8	0f ba f1 09	 btr	 ecx, 9
  001bc	0b c8		 or	 ecx, eax
  001be	8b c1		 mov	 eax, ecx
  001c0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001c5	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4244 :                 cckd->sfforce = force;

  001c8	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR force$[rsp]
  001cf	83 e0 01	 and	 eax, 1
  001d2	c1 e0 0a	 shl	 eax, 10
  001d5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001da	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  001dd	0f ba f1 0a	 btr	 ecx, 10
  001e1	0b c8		 or	 ecx, eax
  001e3	8b c1		 mov	 eax, ecx
  001e5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ea	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4245 :                 cckd_sf_remove( dev );

  001ed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001f2	e8 00 00 00 00	 call	 cckd_sf_remove

; 4246 :                 n++;

  001f7	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR n$1[rsp]
  001fe	ff c0		 inc	 eax
  00200	89 84 24 b8 00
	00 00		 mov	 DWORD PTR n$1[rsp], eax
$LN14@cckd_sf_re:

; 4247 :             }
; 4248 :         }

  00207	e9 b7 fe ff ff	 jmp	 $LN2@cckd_sf_re
$LN3@cckd_sf_re:

; 4249 :         // "CCKD file number of devices processed: %d"
; 4250 :         WRMSG( HHC00316, "I", n );

  0020c	b9 01 00 00 00	 mov	 ecx, 1
  00211	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00217	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR n$1[rsp]
  0021e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00222	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171896
  00229	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0022e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171897
  00235	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0023a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00245	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171898
  0024c	ba 9a 10 00 00	 mov	 edx, 4250		; 0000109aH
  00251	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171899
  00258	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4251 :         return NULL;

  0025e	33 c0		 xor	 eax, eax
  00260	e9 06 17 00 00	 jmp	 $LN1@cckd_sf_re
$LN13@cckd_sf_re:

; 4252 :     }
; 4253 : 
; 4254 :     if (dev->cckd64)

  00265	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0026a	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00271	24 01		 and	 al, 1
  00273	0f b6 c0	 movzx	 eax, al
  00276	85 c0		 test	 eax, eax
  00278	74 12		 je	 SHORT $LN15@cckd_sf_re

; 4255 :         return cckd64_sf_remove( data );

  0027a	48 8b 8c 24 b0
	11 01 00	 mov	 rcx, QWORD PTR data$[rsp]
  00282	e8 00 00 00 00	 call	 cckd64_sf_remove
  00287	e9 df 16 00 00	 jmp	 $LN1@cckd_sf_re
$LN15@cckd_sf_re:

; 4256 : 
; 4257 :     if (!(cckd = dev->cckd_ext))

  0028c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00291	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00298	48 89 44 24 78	 mov	 QWORD PTR cckd$[rsp], rax
  0029d	48 83 7c 24 78
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  002a3	0f 85 b0 00 00
	00		 jne	 $LN16@cckd_sf_re

; 4258 :     {
; 4259 :         // "%1d:%04X CCKD file: device is not a cckd device"
; 4260 :         WRMSG( HHC00317, "W", LCSS_DEVNUM );

  002a9	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002af	74 12		 je	 SHORT $LN63@cckd_sf_re
  002b1	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002b6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002ba	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv163[rsp], eax
  002c1	eb 0b		 jmp	 SHORT $LN64@cckd_sf_re
$LN63@cckd_sf_re:
  002c3	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv163[rsp], 0
$LN64@cckd_sf_re:
  002ce	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002d4	74 14		 je	 SHORT $LN65@cckd_sf_re
  002d6	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002db	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002df	d1 f8		 sar	 eax, 1
  002e1	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv169[rsp], eax
  002e8	eb 0b		 jmp	 SHORT $LN66@cckd_sf_re
$LN65@cckd_sf_re:
  002ea	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv169[rsp], 0
$LN66@cckd_sf_re:
  002f5	b9 01 00 00 00	 mov	 ecx, 1
  002fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00300	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv163[rsp]
  00307	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0030b	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv169[rsp]
  00312	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00316	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171902
  0031d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00322	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171903
  00329	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0032e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00333	41 b9 03 00 00
	00		 mov	 r9d, 3
  00339	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171904
  00340	ba a4 10 00 00	 mov	 edx, 4260		; 000010a4H
  00345	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171905
  0034c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4261 :         return NULL;

  00352	33 c0		 xor	 eax, eax
  00354	e9 12 16 00 00	 jmp	 $LN1@cckd_sf_re
$LN16@cckd_sf_re:

; 4262 :     }
; 4263 : 
; 4264 :     /* Set flags */
; 4265 :     merge = cckd->sfmerge || cckd->sfforce;

  00359	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0035e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00361	c1 e8 09	 shr	 eax, 9
  00364	83 e0 01	 and	 eax, 1
  00367	85 c0		 test	 eax, eax
  00369	75 1f		 jne	 SHORT $LN67@cckd_sf_re
  0036b	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00370	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00373	c1 e8 0a	 shr	 eax, 10
  00376	83 e0 01	 and	 eax, 1
  00379	85 c0		 test	 eax, eax
  0037b	75 0d		 jne	 SHORT $LN67@cckd_sf_re
  0037d	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv188[rsp], 0
  00388	eb 0b		 jmp	 SHORT $LN68@cckd_sf_re
$LN67@cckd_sf_re:
  0038a	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv188[rsp], 1
$LN68@cckd_sf_re:
  00395	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv188[rsp]
  0039c	89 84 24 9c 00
	00 00		 mov	 DWORD PTR merge$[rsp], eax

; 4266 :     force = cckd->sfforce;

  003a3	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  003a8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003ab	c1 e8 0a	 shr	 eax, 10
  003ae	83 e0 01	 and	 eax, 1
  003b1	89 84 24 a4 00
	00 00		 mov	 DWORD PTR force$[rsp], eax

; 4267 :     cckd->sfmerge = cckd->sfforce = 0;

  003b8	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  003bd	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003c0	0f ba f0 0a	 btr	 eax, 10
  003c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  003c9	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  003cc	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  003d1	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003d4	0f ba f0 09	 btr	 eax, 9
  003d8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  003dd	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4268 : 
; 4269 :     CCKD_TRACE( "merge starting: %s %s",

  003e0	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR force$[rsp], 0
  003e8	74 11		 je	 SHORT $LN69@cckd_sf_re
  003ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171906
  003f1	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv199[rsp], rax
  003f9	eb 0f		 jmp	 SHORT $LN70@cckd_sf_re
$LN69@cckd_sf_re:
  003fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171907
  00402	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv199[rsp], rax
$LN70@cckd_sf_re:
  0040a	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR merge$[rsp], 0
  00412	74 11		 je	 SHORT $LN71@cckd_sf_re
  00414	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171908
  0041b	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv202[rsp], rax
  00423	eb 0f		 jmp	 SHORT $LN72@cckd_sf_re
$LN71@cckd_sf_re:
  00425	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171909
  0042c	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv202[rsp], rax
$LN72@cckd_sf_re:
  00434	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR tv199[rsp]
  0043c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00441	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR tv202[rsp]
  00449	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0044e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171910
  00455	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  0045a	ba ae 10 00 00	 mov	 edx, 4270		; 000010aeH
  0045f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171911
  00466	e8 00 00 00 00	 call	 cckd_trace

; 4270 :                 merge ? "merge" : "nomerge", force ? "force" : "");
; 4271 : 
; 4272 :     /* Schedule updated track entries to be written */
; 4273 :     obtain_lock( &cckd->cckdiolock );

  0046b	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00470	48 83 c0 18	 add	 rax, 24
  00474	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171912
  0047b	48 8b c8	 mov	 rcx, rax
  0047e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4274 :     {
; 4275 :         if (cckd->merging)

  00484	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00489	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0048c	c1 e8 05	 shr	 eax, 5
  0048f	83 e0 01	 and	 eax, 1
  00492	85 c0		 test	 eax, eax
  00494	0f 84 fc 00 00
	00		 je	 $LN17@cckd_sf_re

; 4276 :         {
; 4277 :             release_lock( &cckd->cckdiolock );

  0049a	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0049f	48 83 c0 18	 add	 rax, 24
  004a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171914
  004aa	48 8b c8	 mov	 rcx, rax
  004ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4278 :             // "%1d:%04X CCKD file[%d] %s: error merging shadow file, sf command busy on device"
; 4279 :             WRMSG( HHC00322, "W", LCSS_DEVNUM, cckd->sfn, cckd_sf_name(dev, cckd->sfn) );

  004b3	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  004b9	74 12		 je	 SHORT $LN73@cckd_sf_re
  004bb	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  004c0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004c4	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv228[rsp], eax
  004cb	eb 0b		 jmp	 SHORT $LN74@cckd_sf_re
$LN73@cckd_sf_re:
  004cd	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv228[rsp], 0
$LN74@cckd_sf_re:
  004d8	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  004de	74 14		 je	 SHORT $LN75@cckd_sf_re
  004e0	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  004e5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  004e9	d1 f8		 sar	 eax, 1
  004eb	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv234[rsp], eax
  004f2	eb 0b		 jmp	 SHORT $LN76@cckd_sf_re
$LN75@cckd_sf_re:
  004f4	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv234[rsp], 0
$LN76@cckd_sf_re:
  004ff	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00504	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00507	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0050c	e8 00 00 00 00	 call	 cckd_sf_name
  00511	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv215[rsp], rax
  00519	b9 01 00 00 00	 mov	 ecx, 1
  0051e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00524	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv215[rsp]
  0052c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00531	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00536	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00539	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0053d	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv228[rsp]
  00544	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00548	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv234[rsp]
  0054f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00553	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171915
  0055a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0055f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171916
  00566	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0056b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00570	41 b9 03 00 00
	00		 mov	 r9d, 3
  00576	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171917
  0057d	ba b7 10 00 00	 mov	 edx, 4279		; 000010b7H
  00582	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171918
  00589	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4280 :             return NULL;

  0058f	33 c0		 xor	 eax, eax
  00591	e9 d5 13 00 00	 jmp	 $LN1@cckd_sf_re
$LN17@cckd_sf_re:

; 4281 :         }
; 4282 :         cckd->merging = 1;

  00596	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0059b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0059e	83 c8 20	 or	 eax, 32			; 00000020H
  005a1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  005a6	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4283 :         cckd_flush_cache (dev);

  005a9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  005ae	e8 00 00 00 00	 call	 cckd_flush_cache
$LN5@cckd_sf_re:

; 4284 :         while (cckd->wrpending || cckd->cckdioact)

  005b3	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  005b8	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  005bc	75 12		 jne	 SHORT $LN18@cckd_sf_re
  005be	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  005c3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  005c6	c1 e8 02	 shr	 eax, 2
  005c9	83 e0 01	 and	 eax, 1
  005cc	85 c0		 test	 eax, eax
  005ce	74 52		 je	 SHORT $LN6@cckd_sf_re
$LN18@cckd_sf_re:

; 4285 :         {
; 4286 :             cckd->cckdwaiters++;

  005d0	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  005d5	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  005d8	ff c0		 inc	 eax
  005da	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  005df	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 4287 :             wait_condition( &cckd->cckdiocond, &cckd->cckdiolock );

  005e2	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  005e7	48 83 c0 18	 add	 rax, 24
  005eb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  005f0	48 83 c1 20	 add	 rcx, 32			; 00000020H
  005f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171920
  005fb	48 8b d0	 mov	 rdx, rax
  005fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 4288 :             cckd->cckdwaiters--;

  00604	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00609	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0060c	ff c8		 dec	 eax
  0060e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00613	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 4289 :             cckd_flush_cache( dev );

  00616	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0061b	e8 00 00 00 00	 call	 cckd_flush_cache

; 4290 :         }

  00620	eb 91		 jmp	 SHORT $LN5@cckd_sf_re
$LN6@cckd_sf_re:

; 4291 :         cckd_purge_cache( dev );

  00622	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00627	e8 00 00 00 00	 call	 cckd_purge_cache

; 4292 :         cckd_purge_l2( dev );

  0062c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00631	e8 00 00 00 00	 call	 cckd_purge_l2

; 4293 :         dev->bufcur = dev->cache = -1;

  00636	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0063b	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00645	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0064a	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 4294 :     }
; 4295 :     release_lock( &cckd->cckdiolock );

  00654	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00659	48 83 c0 18	 add	 rax, 24
  0065d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171921
  00664	48 8b c8	 mov	 rcx, rax
  00667	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4296 : 
; 4297 :     obtain_lock( &cckd->filelock );

  0066d	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00672	48 83 c0 10	 add	 rax, 16
  00676	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171922
  0067d	48 8b c8	 mov	 rcx, rax
  00680	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4298 : 
; 4299 :     if (!cckd->sfn)

  00686	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0068b	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  0068f	0f 85 0f 01 00
	00		 jne	 $LN19@cckd_sf_re

; 4300 :     {
; 4301 :         release_lock( &cckd->filelock );

  00695	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0069a	48 83 c0 10	 add	 rax, 16
  0069e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171924
  006a5	48 8b c8	 mov	 rcx, rax
  006a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4302 :         // "%1d:%04X CCKD file[%d] %s: cannot remove base file"
; 4303 :         WRMSG( HHC00323, "E", LCSS_DEVNUM, cckd->sfn, cckd_sf_name(dev, cckd->sfn) );

  006ae	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  006b4	74 12		 je	 SHORT $LN77@cckd_sf_re
  006b6	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  006bb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006bf	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv326[rsp], eax
  006c6	eb 0b		 jmp	 SHORT $LN78@cckd_sf_re
$LN77@cckd_sf_re:
  006c8	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv326[rsp], 0
$LN78@cckd_sf_re:
  006d3	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  006d9	74 14		 je	 SHORT $LN79@cckd_sf_re
  006db	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  006e0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  006e4	d1 f8		 sar	 eax, 1
  006e6	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv332[rsp], eax
  006ed	eb 0b		 jmp	 SHORT $LN80@cckd_sf_re
$LN79@cckd_sf_re:
  006ef	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv332[rsp], 0
$LN80@cckd_sf_re:
  006fa	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  006ff	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00702	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00707	e8 00 00 00 00	 call	 cckd_sf_name
  0070c	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv281[rsp], rax
  00714	b9 01 00 00 00	 mov	 ecx, 1
  00719	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0071f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv281[rsp]
  00727	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0072c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00731	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00734	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00738	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv326[rsp]
  0073f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00743	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv332[rsp]
  0074a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0074e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171925
  00755	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0075a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171926
  00761	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00766	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0076b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00771	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171927
  00778	ba cf 10 00 00	 mov	 edx, 4303		; 000010cfH
  0077d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171928
  00784	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4304 :         cckd->merging = 0;

  0078a	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0078f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00792	83 e0 df	 and	 eax, -33		; ffffffdfH
  00795	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0079a	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4305 :         return NULL;

  0079d	33 c0		 xor	 eax, eax
  0079f	e9 c7 11 00 00	 jmp	 $LN1@cckd_sf_re
$LN19@cckd_sf_re:

; 4306 :     }
; 4307 : 
; 4308 :     from_sfx = cckd->sfn;

  007a4	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  007a9	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  007ac	89 84 24 84 00
	00 00		 mov	 DWORD PTR from_sfx$[rsp], eax

; 4309 :     to_sfx   = cckd->sfn - 1;

  007b3	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  007b8	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  007bb	ff c8		 dec	 eax
  007bd	89 84 24 80 00
	00 00		 mov	 DWORD PTR to_sfx$[rsp], eax

; 4310 :     fix = cckd->cdevhdr[ to_sfx ].cdh_nullfmt;

  007c4	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  007cc	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  007d3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  007d8	0f b6 84 01 0c
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+524]
  007e0	89 84 24 14 01
	00 00		 mov	 DWORD PTR fix$[rsp], eax

; 4311 : 
; 4312 :     /* Harden the `from' file */
; 4313 :     if (cckd_harden( dev ) < 0)

  007e7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  007ec	e8 00 00 00 00	 call	 cckd_harden
  007f1	85 c0		 test	 eax, eax
  007f3	0f 8d 03 01 00
	00		 jge	 $LN20@cckd_sf_re

; 4314 :     {
; 4315 :         // "%1d:%04X CCKD file[%d] %s: shadow file not merged: file[%d] %s%s"
; 4316 :         WRMSG( HHC00324, "E", LCSS_DEVNUM, from_sfx, cckd_sf_name( dev, cckd->sfx ),

  007f9	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  007ff	74 12		 je	 SHORT $LN81@cckd_sf_re
  00801	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00806	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0080a	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv370[rsp], eax
  00811	eb 0b		 jmp	 SHORT $LN82@cckd_sf_re
$LN81@cckd_sf_re:
  00813	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv370[rsp], 0
$LN82@cckd_sf_re:
  0081e	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00824	74 14		 je	 SHORT $LN83@cckd_sf_re
  00826	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0082b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0082f	d1 f8		 sar	 eax, 1
  00831	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv376[rsp], eax
  00838	eb 0b		 jmp	 SHORT $LN84@cckd_sf_re
$LN83@cckd_sf_re:
  0083a	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv376[rsp], 0
$LN84@cckd_sf_re:
  00845	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0084a	8b 50 40	 mov	 edx, DWORD PTR [rax+64]
  0084d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00852	e8 00 00 00 00	 call	 cckd_sf_name
  00857	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv361[rsp], rax
  0085f	b9 01 00 00 00	 mov	 ecx, 1
  00864	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0086a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171930
  00871	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00876	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171931
  0087d	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00882	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  00889	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0088d	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv361[rsp]
  00895	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0089a	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  008a1	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  008a5	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv370[rsp]
  008ac	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  008b0	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv376[rsp]
  008b7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171932
  008c2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171933
  008ce	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008d8	41 b9 03 00 00
	00		 mov	 r9d, 3
  008de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171934
  008e5	ba dd 10 00 00	 mov	 edx, 4317		; 000010ddH
  008ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171935
  008f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4317 :                from_sfx, "not hardened", "" );
; 4318 :         goto sf_remove_exit;

  008f7	e9 af 0c 00 00	 jmp	 $sf_remove_exit$112
$LN20@cckd_sf_re:

; 4319 :     }
; 4320 : 
; 4321 :     /* Attempt to re-open the `to' file read-write */
; 4322 :     cckd_close( dev, to_sfx );

  008fc	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  00903	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00908	e8 00 00 00 00	 call	 cckd_close

; 4323 : 
; 4324 :     if (to_sfx > 0 || !dev->ckdrdonly || force)

  0090d	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR to_sfx$[rsp], 0
  00915	7f 1f		 jg	 SHORT $LN22@cckd_sf_re
  00917	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0091c	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00922	c1 e8 12	 shr	 eax, 18
  00925	83 e0 01	 and	 eax, 1
  00928	85 c0		 test	 eax, eax
  0092a	74 0a		 je	 SHORT $LN22@cckd_sf_re
  0092c	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR force$[rsp], 0
  00934	74 1d		 je	 SHORT $LN21@cckd_sf_re
$LN22@cckd_sf_re:

; 4325 :         cckd_open( dev, to_sfx, O_RDWR | O_BINARY, 1 );

  00936	41 b9 01 00 00
	00		 mov	 r9d, 1
  0093c	41 b8 02 80 00
	00		 mov	 r8d, 32770		; 00008002H
  00942	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  00949	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0094e	e8 00 00 00 00	 call	 cckd_open
$LN21@cckd_sf_re:

; 4326 : 
; 4327 :     if (cckd->fd[to_sfx] < 0)

  00953	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  0095b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00960	83 bc 81 f0 00
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+240], 0
  00968	0f 8d 86 01 00
	00		 jge	 $LN23@cckd_sf_re

; 4328 :     {
; 4329 :         /* `from' file can't be opened read-write */
; 4330 :         cckd_open( dev, to_sfx, O_RDONLY | O_BINARY, 0 );

  0096e	45 33 c9	 xor	 r9d, r9d
  00971	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00977	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  0097e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00983	e8 00 00 00 00	 call	 cckd_open

; 4331 : 
; 4332 :         if (merge)

  00988	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR merge$[rsp], 0
  00990	0f 84 4e 01 00
	00		 je	 $LN25@cckd_sf_re

; 4333 :         {
; 4334 :             // "%1d:%04X CCKD file[%d] %s: shadow file not merged: file[%d] %s%s"
; 4335 :             WRMSG( HHC00324, "E", LCSS_DEVNUM, from_sfx, cckd_sf_name( dev, from_sfx ),

  00996	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR to_sfx$[rsp], 0
  0099e	75 30		 jne	 SHORT $LN85@cckd_sf_re
  009a0	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  009a5	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  009ab	c1 e8 12	 shr	 eax, 18
  009ae	83 e0 01	 and	 eax, 1
  009b1	85 c0		 test	 eax, eax
  009b3	74 1b		 je	 SHORT $LN85@cckd_sf_re
  009b5	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR force$[rsp], 0
  009bd	75 11		 jne	 SHORT $LN85@cckd_sf_re
  009bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171942
  009c6	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv415[rsp], rax
  009ce	eb 0f		 jmp	 SHORT $LN86@cckd_sf_re
$LN85@cckd_sf_re:
  009d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171943
  009d7	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv415[rsp], rax
$LN86@cckd_sf_re:
  009df	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  009e5	74 12		 je	 SHORT $LN87@cckd_sf_re
  009e7	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  009ec	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  009f0	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv427[rsp], eax
  009f7	eb 0b		 jmp	 SHORT $LN88@cckd_sf_re
$LN87@cckd_sf_re:
  009f9	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv427[rsp], 0
$LN88@cckd_sf_re:
  00a04	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00a0a	74 14		 je	 SHORT $LN89@cckd_sf_re
  00a0c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00a11	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00a15	d1 f8		 sar	 eax, 1
  00a17	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv433[rsp], eax
  00a1e	eb 0b		 jmp	 SHORT $LN90@cckd_sf_re
$LN89@cckd_sf_re:
  00a20	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv433[rsp], 0
$LN90@cckd_sf_re:
  00a2b	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  00a32	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00a37	e8 00 00 00 00	 call	 cckd_sf_name
  00a3c	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv419[rsp], rax
  00a44	b9 01 00 00 00	 mov	 ecx, 1
  00a49	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a4f	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv415[rsp]
  00a57	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00a5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171944
  00a63	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00a68	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR to_sfx$[rsp]
  00a6f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00a73	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv419[rsp]
  00a7b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00a80	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  00a87	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00a8b	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv427[rsp]
  00a92	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a96	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv433[rsp]
  00a9d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00aa1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171945
  00aa8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00aad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171946
  00ab4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ab9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00abe	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ac4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171947
  00acb	ba f1 10 00 00	 mov	 edx, 4337		; 000010f1H
  00ad0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171948
  00ad7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4336 :                                  to_sfx, "cannot be opened read-write",
; 4337 :                                  to_sfx == 0 && dev->ckdrdonly && !force ? ", try 'force'" : "" );
; 4338 :             goto sf_remove_exit;

  00add	e9 c9 0a 00 00	 jmp	 $sf_remove_exit$112

; 4339 :         }

  00ae2	eb 0b		 jmp	 SHORT $LN26@cckd_sf_re
$LN25@cckd_sf_re:

; 4340 :         else
; 4341 :            add = 1;

  00ae4	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR add$[rsp], 1
$LN26@cckd_sf_re:

; 4342 :     }

  00aef	e9 34 01 00 00	 jmp	 $LN24@cckd_sf_re
$LN23@cckd_sf_re:

; 4343 :     else
; 4344 :     {
; 4345 :         /* `from' file opened read-write */
; 4346 :         cckd->sfn = to_sfx;

  00af4	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00af9	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR to_sfx$[rsp]
  00b00	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 4347 : 
; 4348 :         if (cckd_chkdsk( dev, 0 ) < 0)

  00b03	33 d2		 xor	 edx, edx
  00b05	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00b0a	e8 00 00 00 00	 call	 cckd_chkdsk
  00b0f	85 c0		 test	 eax, eax
  00b11	0f 8d 11 01 00
	00		 jge	 $LN27@cckd_sf_re

; 4349 :         {
; 4350 :             cckd->sfn = from_sfx;

  00b17	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00b1c	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  00b23	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 4351 :             // "%1d:%04X CCKD file[%d] %s: shadow file not merged: file[%d] %s%s"
; 4352 :             WRMSG( HHC00324, "E", LCSS_DEVNUM, to_sfx, cckd_sf_name( dev, to_sfx ),

  00b26	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00b2c	74 12		 je	 SHORT $LN91@cckd_sf_re
  00b2e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00b33	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b37	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv461[rsp], eax
  00b3e	eb 0b		 jmp	 SHORT $LN92@cckd_sf_re
$LN91@cckd_sf_re:
  00b40	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv461[rsp], 0
$LN92@cckd_sf_re:
  00b4b	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00b51	74 14		 je	 SHORT $LN93@cckd_sf_re
  00b53	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00b58	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00b5c	d1 f8		 sar	 eax, 1
  00b5e	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv467[rsp], eax
  00b65	eb 0b		 jmp	 SHORT $LN94@cckd_sf_re
$LN93@cckd_sf_re:
  00b67	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv467[rsp], 0
$LN94@cckd_sf_re:
  00b72	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  00b79	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00b7e	e8 00 00 00 00	 call	 cckd_sf_name
  00b83	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv453[rsp], rax
  00b8b	b9 01 00 00 00	 mov	 ecx, 1
  00b90	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b96	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171950
  00b9d	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00ba2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171951
  00ba9	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00bae	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR to_sfx$[rsp]
  00bb5	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00bb9	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv453[rsp]
  00bc1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00bc6	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR to_sfx$[rsp]
  00bcd	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00bd1	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv461[rsp]
  00bd8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00bdc	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv467[rsp]
  00be3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00be7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171952
  00bee	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bf3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171953
  00bfa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00bff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c04	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c0a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171954
  00c11	ba 01 11 00 00	 mov	 edx, 4353		; 00001101H
  00c16	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171955
  00c1d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4353 :                                  to_sfx, "check failed", "" );
; 4354 :             goto sf_remove_exit;

  00c23	e9 83 09 00 00	 jmp	 $sf_remove_exit$112
$LN27@cckd_sf_re:
$LN24@cckd_sf_re:

; 4355 :         }
; 4356 :     }
; 4357 : 
; 4358 :     cckd->sfn = to_sfx;

  00c28	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00c2d	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR to_sfx$[rsp]
  00c34	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 4359 : 
; 4360 :     /* Perform backwards merge */
; 4361 :     if (merge)

  00c37	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR merge$[rsp], 0
  00c3f	0f 84 7e 06 00
	00		 je	 $LN28@cckd_sf_re

; 4362 :     {
; 4363 :         CCKD_TRACE( "merging to file[%d]", to_sfx );

  00c45	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR to_sfx$[rsp]
  00c4c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00c50	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171957
  00c57	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00c5c	ba 0b 11 00 00	 mov	 edx, 4363		; 0000110bH
  00c61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171958
  00c68	e8 00 00 00 00	 call	 cckd_trace

; 4364 : 
; 4365 :         /* Make the target file the active file */
; 4366 :         cckd->sfn = to_sfx;

  00c6d	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00c72	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR to_sfx$[rsp]
  00c79	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 4367 :         cckd->cdevhdr[to_sfx].cdh_opts |= (CCKD_OPT_OPENED | CCKD_OPT_OPENRW);

  00c7c	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  00c84	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00c8b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00c90	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  00c98	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  00c9d	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR to_sfx$[rsp]
  00ca5	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00cac	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00cb1	88 84 0a e3 01
	00 00		 mov	 BYTE PTR [rdx+rcx+483], al

; 4368 : 
; 4369 :         /* Loop for each level 1 table entry */
; 4370 :         for (i = 0; i < cckd->cdevhdr[from_sfx].num_L1tab; i++)

  00cb8	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00cc3	eb 10		 jmp	 SHORT $LN9@cckd_sf_re
$LN7@cckd_sf_re:
  00cc5	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00ccc	ff c0		 inc	 eax
  00cce	89 84 24 88 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN9@cckd_sf_re:
  00cd5	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  00cdd	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00ce4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00ce9	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  00cf0	39 84 24 88 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00cf7	0f 8d a6 05 00
	00		 jge	 $LN8@cckd_sf_re

; 4371 :         {
; 4372 :             l2updated = 0;

  00cfd	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR l2updated$[rsp], 0

; 4373 :             /* Continue if from L2 doesn't exist */
; 4374 :             if (cckd->L1tab[from_sfx][i] == CCKD_MAXSIZE
; 4375 :              || (cckd->L1tab[from_sfx][i] == 0 && cckd->L1tab[to_sfx][i] == 0))

  00d08	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  00d10	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00d18	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00d1d	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00d25	83 3c 88 ff	 cmp	 DWORD PTR [rax+rcx*4], -1 ; ffffffffH
  00d29	74 46		 je	 SHORT $LN30@cckd_sf_re
  00d2b	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  00d33	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00d3b	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00d40	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00d48	83 3c 88 00	 cmp	 DWORD PTR [rax+rcx*4], 0
  00d4c	75 28		 jne	 SHORT $LN29@cckd_sf_re
  00d4e	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  00d56	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00d5e	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00d63	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00d6b	83 3c 88 00	 cmp	 DWORD PTR [rax+rcx*4], 0
  00d6f	75 05		 jne	 SHORT $LN29@cckd_sf_re
$LN30@cckd_sf_re:

; 4376 :                 continue;

  00d71	e9 4f ff ff ff	 jmp	 $LN7@cckd_sf_re
$LN29@cckd_sf_re:

; 4377 : 
; 4378 :             trk = i*256;

  00d76	69 84 24 88 00
	00 00 00 01 00
	00		 imul	 eax, DWORD PTR i$[rsp], 256 ; 00000100H
  00d81	89 84 24 ac 00
	00 00		 mov	 DWORD PTR trk$[rsp], eax

; 4379 : 
; 4380 :             /* Read `from' l2 table */
; 4381 :             if (cckd->L1tab[from_sfx][i] == 0)

  00d88	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  00d90	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00d98	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00d9d	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00da5	83 3c 88 00	 cmp	 DWORD PTR [rax+rcx*4], 0
  00da9	75 16		 jne	 SHORT $LN31@cckd_sf_re

; 4382 :                 memset( &from_l2, 0, CCKD_L2TAB_SIZE );

  00dab	48 8d 84 24 90
	09 00 00	 lea	 rax, QWORD PTR from_l2$[rsp]
  00db3	48 8b f8	 mov	 rdi, rax
  00db6	33 c0		 xor	 eax, eax
  00db8	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00dbd	f3 aa		 rep stosb
  00dbf	eb 5a		 jmp	 SHORT $LN32@cckd_sf_re
$LN31@cckd_sf_re:

; 4383 :             else
; 4384 :             {
; 4385 :                 pos = (off_t)cckd->L1tab[from_sfx][i];

  00dc1	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  00dc9	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00dd1	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00dd6	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00dde	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00de1	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax

; 4386 :                 if (cckd_read( dev, from_sfx, pos, &from_l2, CCKD_L2TAB_SIZE ) < 0)

  00de9	c7 44 24 20 00
	08 00 00	 mov	 DWORD PTR [rsp+32], 2048 ; 00000800H
  00df1	4c 8d 8c 24 90
	09 00 00	 lea	 r9, QWORD PTR from_l2$[rsp]
  00df9	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pos$[rsp]
  00e01	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  00e08	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00e0d	e8 00 00 00 00	 call	 cckd_read
  00e12	85 c0		 test	 eax, eax
  00e14	7d 05		 jge	 SHORT $LN33@cckd_sf_re

; 4387 :                     goto sf_merge_error;

  00e16	e9 88 08 00 00	 jmp	 $sf_merge_error$113
$LN33@cckd_sf_re:
$LN32@cckd_sf_re:

; 4388 :             }
; 4389 : 
; 4390 :             /* Read `to' l2 table */
; 4391 :             if (cckd->L1tab[to_sfx][i] == 0)

  00e1b	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  00e23	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00e2b	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00e30	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00e38	83 3c 88 00	 cmp	 DWORD PTR [rax+rcx*4], 0
  00e3c	75 19		 jne	 SHORT $LN34@cckd_sf_re

; 4392 :                 memset( &to_l2, 0, CCKD_L2TAB_SIZE );

  00e3e	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR to_l2$[rsp]
  00e46	48 8b f8	 mov	 rdi, rax
  00e49	33 c0		 xor	 eax, eax
  00e4b	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00e50	f3 aa		 rep stosb
  00e52	e9 96 00 00 00	 jmp	 $LN35@cckd_sf_re
$LN34@cckd_sf_re:

; 4393 :             else if (cckd->L1tab[to_sfx][i] == CCKD_MAXSIZE)

  00e57	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  00e5f	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00e67	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00e6c	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00e74	83 3c 88 ff	 cmp	 DWORD PTR [rax+rcx*4], -1 ; ffffffffH
  00e78	75 19		 jne	 SHORT $LN36@cckd_sf_re

; 4394 :                 memset (&to_l2, 0xff, CCKD_L2TAB_SIZE);

  00e7a	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR to_l2$[rsp]
  00e82	48 8b f8	 mov	 rdi, rax
  00e85	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00e8a	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00e8f	f3 aa		 rep stosb
  00e91	eb 5a		 jmp	 SHORT $LN37@cckd_sf_re
$LN36@cckd_sf_re:

; 4395 :             else
; 4396 :             {
; 4397 :                 pos = (off_t)cckd->L1tab[to_sfx][i];

  00e93	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  00e9b	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00ea3	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00ea8	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00eb0	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00eb3	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax

; 4398 :                 if (cckd_read( dev, to_sfx, pos, &to_l2, CCKD_L2TAB_SIZE ) < 0)

  00ebb	c7 44 24 20 00
	08 00 00	 mov	 DWORD PTR [rsp+32], 2048 ; 00000800H
  00ec3	4c 8d 8c 24 90
	01 00 00	 lea	 r9, QWORD PTR to_l2$[rsp]
  00ecb	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pos$[rsp]
  00ed3	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  00eda	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00edf	e8 00 00 00 00	 call	 cckd_read
  00ee4	85 c0		 test	 eax, eax
  00ee6	7d 05		 jge	 SHORT $LN38@cckd_sf_re

; 4399 :                     goto sf_merge_error;

  00ee8	e9 b6 07 00 00	 jmp	 $sf_merge_error$113
$LN38@cckd_sf_re:
$LN37@cckd_sf_re:
$LN35@cckd_sf_re:

; 4400 :             }
; 4401 : 
; 4402 :             /* Loop for each level 2 table entry */
; 4403 :             for (j = 0; j < 256; j++)

  00eed	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  00ef8	eb 10		 jmp	 SHORT $LN12@cckd_sf_re
$LN10@cckd_sf_re:
  00efa	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00f01	ff c0		 inc	 eax
  00f03	89 84 24 8c 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN12@cckd_sf_re:
  00f0a	81 bc 24 8c 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR j$[rsp], 256	; 00000100H
  00f15	0f 8d 25 02 00
	00		 jge	 $LN11@cckd_sf_re

; 4404 :             {
; 4405 :                 trk = i*256 + j;

  00f1b	69 84 24 88 00
	00 00 00 01 00
	00		 imul	 eax, DWORD PTR i$[rsp], 256 ; 00000100H
  00f26	03 84 24 8c 00
	00 00		 add	 eax, DWORD PTR j$[rsp]
  00f2d	89 84 24 ac 00
	00 00		 mov	 DWORD PTR trk$[rsp], eax

; 4406 :                 /* Continue if from L2 entry doesn't exist */
; 4407 :                 if (from_l2[j].L2_trkoff == CCKD_MAXSIZE
; 4408 :                  || (from_l2[j].L2_trkoff == 0 && to_l2[j].L2_trkoff == 0))

  00f34	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00f3c	83 bc c4 90 09
	00 00 ff	 cmp	 DWORD PTR from_l2$[rsp+rax*8], -1 ; ffffffffH
  00f44	74 24		 je	 SHORT $LN40@cckd_sf_re
  00f46	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00f4e	83 bc c4 90 09
	00 00 00	 cmp	 DWORD PTR from_l2$[rsp+rax*8], 0
  00f56	75 14		 jne	 SHORT $LN39@cckd_sf_re
  00f58	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00f60	83 bc c4 90 01
	00 00 00	 cmp	 DWORD PTR to_l2$[rsp+rax*8], 0
  00f68	75 02		 jne	 SHORT $LN39@cckd_sf_re
$LN40@cckd_sf_re:

; 4409 :                     continue;

  00f6a	eb 8e		 jmp	 SHORT $LN10@cckd_sf_re
$LN39@cckd_sf_re:

; 4410 : 
; 4411 :                 /* Read the `from' track/blkgrp image */
; 4412 :                 len = (int)from_l2[j].L2_len;

  00f6c	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00f74	0f b7 84 c4 94
	09 00 00	 movzx	 eax, WORD PTR from_l2$[rsp+rax*8+4]
  00f7c	89 84 24 98 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 4413 :                 if (len > CKD_NULLTRK_FMTMAX)

  00f83	83 bc 24 98 00
	00 00 02	 cmp	 DWORD PTR len$[rsp], 2
  00f8b	0f 86 ef 00 00
	00		 jbe	 $LN41@cckd_sf_re

; 4414 :                 {
; 4415 :                     pos = (off_t)from_l2[j].L2_trkoff;

  00f91	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00f99	8b 84 c4 90 09
	00 00		 mov	 eax, DWORD PTR from_l2$[rsp+rax*8]
  00fa0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax

; 4416 :                     if (cckd_read( dev, from_sfx, pos, buf, len ) < 0)

  00fa8	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00faf	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00fb3	4c 8d 8c 24 90
	11 00 00	 lea	 r9, QWORD PTR buf$[rsp]
  00fbb	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pos$[rsp]
  00fc3	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  00fca	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00fcf	e8 00 00 00 00	 call	 cckd_read
  00fd4	85 c0		 test	 eax, eax
  00fd6	7d 05		 jge	 SHORT $LN43@cckd_sf_re

; 4417 :                         goto sf_merge_error;

  00fd8	e9 c6 06 00 00	 jmp	 $sf_merge_error$113
$LN43@cckd_sf_re:

; 4418 : 
; 4419 :                     /* Get space for the `to' track/blkgrp image */
; 4420 :                     size = len;

  00fdd	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00fe4	89 84 24 a8 00
	00 00		 mov	 DWORD PTR size$[rsp], eax

; 4421 :                     if ((pos = cckd_get_space (dev, &size, CCKD_SIZE_EXACT)) < 0)

  00feb	41 b8 01 00 00
	00		 mov	 r8d, 1
  00ff1	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR size$[rsp]
  00ff9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00ffe	e8 00 00 00 00	 call	 cckd_get_space
  01003	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax
  0100b	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR pos$[rsp], 0
  01014	7d 05		 jge	 SHORT $LN44@cckd_sf_re

; 4422 :                         goto sf_merge_error;

  01016	e9 88 06 00 00	 jmp	 $sf_merge_error$113
$LN44@cckd_sf_re:

; 4423 : 
; 4424 :                     new_l2.L2_trkoff = (U32)pos;

  0101b	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR pos$[rsp]
  01022	89 84 24 b0 00
	00 00		 mov	 DWORD PTR new_l2$[rsp], eax

; 4425 :                     new_l2.L2_len    = (U16)len;

  01029	0f b7 84 24 98
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  01031	66 89 84 24 b4
	00 00 00	 mov	 WORD PTR new_l2$[rsp+4], ax

; 4426 :                     new_l2.L2_size   = (U16)size;

  01039	0f b7 84 24 a8
	00 00 00	 movzx	 eax, WORD PTR size$[rsp]
  01041	66 89 84 24 b6
	00 00 00	 mov	 WORD PTR new_l2$[rsp+6], ax

; 4427 : 
; 4428 :                     /* Write the `to' track/blkgrp image */
; 4429 :                     if (cckd_write( dev, to_sfx, pos, buf, len ) < 0)

  01049	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  01050	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01054	4c 8d 8c 24 90
	11 00 00	 lea	 r9, QWORD PTR buf$[rsp]
  0105c	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pos$[rsp]
  01064	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  0106b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01070	e8 00 00 00 00	 call	 cckd_write
  01075	85 c0		 test	 eax, eax
  01077	7d 05		 jge	 SHORT $LN45@cckd_sf_re

; 4430 :                         goto sf_merge_error;

  01079	e9 25 06 00 00	 jmp	 $sf_merge_error$113
$LN45@cckd_sf_re:

; 4431 :                 }

  0107e	eb 2b		 jmp	 SHORT $LN42@cckd_sf_re
$LN41@cckd_sf_re:

; 4432 :                 else
; 4433 :                 {
; 4434 :                     new_l2.L2_trkoff = 0;

  01080	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR new_l2$[rsp], 0

; 4435 :                     new_l2.L2_len = new_l2.L2_size = (U16)len;

  0108b	0f b7 84 24 98
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  01093	66 89 84 24 b6
	00 00 00	 mov	 WORD PTR new_l2$[rsp+6], ax
  0109b	0f b7 84 24 b6
	00 00 00	 movzx	 eax, WORD PTR new_l2$[rsp+6]
  010a3	66 89 84 24 b4
	00 00 00	 mov	 WORD PTR new_l2$[rsp+4], ax
$LN42@cckd_sf_re:

; 4436 :                 }
; 4437 : 
; 4438 :                 /* Release space occupied by old `to' entry */
; 4439 :                 cckd_rel_space( dev, (off_t)to_l2[j].L2_trkoff, (int)to_l2[j].L2_len,

  010ab	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  010b3	0f b7 84 c4 96
	01 00 00	 movzx	 eax, WORD PTR to_l2$[rsp+rax*8+6]
  010bb	48 63 8c 24 8c
	00 00 00	 movsxd	 rcx, DWORD PTR j$[rsp]
  010c3	0f b7 8c cc 94
	01 00 00	 movzx	 ecx, WORD PTR to_l2$[rsp+rcx*8+4]
  010cb	48 63 94 24 8c
	00 00 00	 movsxd	 rdx, DWORD PTR j$[rsp]
  010d3	8b 94 d4 90 01
	00 00		 mov	 edx, DWORD PTR to_l2$[rsp+rdx*8]
  010da	44 8b c8	 mov	 r9d, eax
  010dd	44 8b c1	 mov	 r8d, ecx
  010e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  010e5	e8 00 00 00 00	 call	 cckd_rel_space

; 4440 :                                                                 (int)to_l2[j].L2_size );
; 4441 : 
; 4442 :                 /* Update `to' l2 table entry */
; 4443 :                 l2updated = 1;

  010ea	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR l2updated$[rsp], 1

; 4444 :                 to_l2[j].L2_trkoff  = new_l2.L2_trkoff;

  010f5	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  010fd	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR new_l2$[rsp]
  01104	89 8c c4 90 01
	00 00		 mov	 DWORD PTR to_l2$[rsp+rax*8], ecx

; 4445 :                 to_l2[j].L2_len  = new_l2.L2_len;

  0110b	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  01113	0f b7 8c 24 b4
	00 00 00	 movzx	 ecx, WORD PTR new_l2$[rsp+4]
  0111b	66 89 8c c4 94
	01 00 00	 mov	 WORD PTR to_l2$[rsp+rax*8+4], cx

; 4446 :                 to_l2[j].L2_size = new_l2.L2_size;

  01123	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  0112b	0f b7 8c 24 b6
	00 00 00	 movzx	 ecx, WORD PTR new_l2$[rsp+6]
  01133	66 89 8c c4 96
	01 00 00	 mov	 WORD PTR to_l2$[rsp+rax*8+6], cx

; 4447 :             } /* for each level 2 table entry */

  0113b	e9 ba fd ff ff	 jmp	 $LN10@cckd_sf_re
$LN11@cckd_sf_re:

; 4448 : 
; 4449 :             /* Update the `to' level 2 table */
; 4450 :             if (l2updated)

  01140	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR l2updated$[rsp], 0
  01148	0f 84 50 01 00
	00		 je	 $LN46@cckd_sf_re

; 4451 :             {
; 4452 :                 l2updated = 0;

  0114e	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR l2updated$[rsp], 0

; 4453 :                 pos = (off_t)cckd->L1tab[to_sfx][i];

  01159	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  01161	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  01169	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  0116e	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  01176	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  01179	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax

; 4454 :                 if (memcmp( &to_l2, &empty_l2[fix], CCKD_L2TAB_SIZE ) == 0)

  01181	48 63 84 24 14
	01 00 00	 movsxd	 rax, DWORD PTR fix$[rsp]
  01189	48 69 c0 00 08
	00 00		 imul	 rax, rax, 2048		; 00000800H
  01190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:empty_l2
  01197	48 03 c8	 add	 rcx, rax
  0119a	48 8b c1	 mov	 rax, rcx
  0119d	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  011a3	48 8b d0	 mov	 rdx, rax
  011a6	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR to_l2$[rsp]
  011ae	e8 00 00 00 00	 call	 memcmp
  011b3	85 c0		 test	 eax, eax
  011b5	75 2f		 jne	 SHORT $LN47@cckd_sf_re

; 4455 :                 {
; 4456 :                     cckd_rel_space( dev, pos, CCKD_L2TAB_SIZE, CCKD_L2TAB_SIZE );

  011b7	41 b9 00 08 00
	00		 mov	 r9d, 2048		; 00000800H
  011bd	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  011c3	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pos$[rsp]
  011cb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  011d0	e8 00 00 00 00	 call	 cckd_rel_space

; 4457 :                     pos = 0;

  011d5	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pos$[rsp], 0

; 4458 :                 }

  011e1	e9 87 00 00 00	 jmp	 $LN48@cckd_sf_re
$LN47@cckd_sf_re:

; 4459 :                 else
; 4460 :                 {
; 4461 :                     size = CCKD_L2TAB_SIZE;

  011e6	c7 84 24 a8 00
	00 00 00 08 00
	00		 mov	 DWORD PTR size$[rsp], 2048 ; 00000800H

; 4462 :                     if (pos == CCKD_NOSIZE || pos == CCKD_MAXSIZE)

  011f1	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR pos$[rsp], 0
  011fa	74 0f		 je	 SHORT $LN50@cckd_sf_re
  011fc	b8 ff ff ff ff	 mov	 eax, -1
  01201	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR pos$[rsp], rax
  01209	75 30		 jne	 SHORT $LN49@cckd_sf_re
$LN50@cckd_sf_re:

; 4463 :                         if ((pos = cckd_get_space( dev, &size, CCKD_L2SPACE )) < 0)

  0120b	41 b8 04 00 00
	00		 mov	 r8d, 4
  01211	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR size$[rsp]
  01219	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0121e	e8 00 00 00 00	 call	 cckd_get_space
  01223	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax
  0122b	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR pos$[rsp], 0
  01234	7d 05		 jge	 SHORT $LN51@cckd_sf_re

; 4464 :                             goto sf_merge_error;

  01236	e9 68 04 00 00	 jmp	 $sf_merge_error$113
$LN51@cckd_sf_re:
$LN49@cckd_sf_re:

; 4465 :                     if (cckd_write( dev, to_sfx, pos, &to_l2, CCKD_L2TAB_SIZE ) < 0)

  0123b	c7 44 24 20 00
	08 00 00	 mov	 DWORD PTR [rsp+32], 2048 ; 00000800H
  01243	4c 8d 8c 24 90
	01 00 00	 lea	 r9, QWORD PTR to_l2$[rsp]
  0124b	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pos$[rsp]
  01253	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  0125a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0125f	e8 00 00 00 00	 call	 cckd_write
  01264	85 c0		 test	 eax, eax
  01266	7d 05		 jge	 SHORT $LN52@cckd_sf_re

; 4466 :                         goto sf_merge_error;

  01268	e9 36 04 00 00	 jmp	 $sf_merge_error$113
$LN52@cckd_sf_re:
$LN48@cckd_sf_re:

; 4467 :                 } /* `to' level 2 table not null */
; 4468 : 
; 4469 :                 /* Update the level 1 table index */
; 4470 :                 cckd->L1tab[to_sfx][i] = (U32)pos;

  0126d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  01275	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  0127d	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  01282	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  0128a	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR pos$[rsp]
  01291	89 14 88	 mov	 DWORD PTR [rax+rcx*4], edx

; 4471 : 
; 4472 :                 /* Flush free space */
; 4473 :                 cckd_flush_space( dev );

  01294	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01299	e8 00 00 00 00	 call	 cckd_flush_space
$LN46@cckd_sf_re:

; 4474 : 
; 4475 :             } /* Update level 2 table */
; 4476 : 
; 4477 :         } /* For each level 1 table entry */

  0129e	e9 22 fa ff ff	 jmp	 $LN7@cckd_sf_re
$LN8@cckd_sf_re:

; 4478 : 
; 4479 :         /* Validate the merge */
; 4480 :         cckd_harden( dev );

  012a3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  012a8	e8 00 00 00 00	 call	 cckd_harden

; 4481 :         cckd_chkdsk( dev, 0 );

  012ad	33 d2		 xor	 edx, edx
  012af	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  012b4	e8 00 00 00 00	 call	 cckd_chkdsk

; 4482 :         cckd_read_init( dev );

  012b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  012be	e8 00 00 00 00	 call	 cckd_read_init
$LN28@cckd_sf_re:

; 4483 : 
; 4484 :     } /* if merge */
; 4485 : 
; 4486 :     /* Remove the old file */
; 4487 :     cckd_close( dev, from_sfx );

  012c3	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  012ca	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  012cf	e8 00 00 00 00	 call	 cckd_close

; 4488 :     cckd->L1tab[from_sfx] = cckd_free( dev, "l1", cckd->L1tab[ from_sfx ]);

  012d4	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  012dc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  012e1	4c 8b 84 c1 98
	01 00 00	 mov	 r8, QWORD PTR [rcx+rax*8+408]
  012e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171983
  012f0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  012f5	e8 00 00 00 00	 call	 cckd_free
  012fa	48 63 8c 24 84
	00 00 00	 movsxd	 rcx, DWORD PTR from_sfx$[rsp]
  01302	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  01307	48 89 84 ca 98
	01 00 00	 mov	 QWORD PTR [rdx+rcx*8+408], rax

; 4489 :     memset( &cckd->cdevhdr[from_sfx], 0, CCKD_DEVHDR_SIZE );

  0130f	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  01317	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0131e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  01323	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  0132b	48 8b f8	 mov	 rdi, rax
  0132e	33 c0		 xor	 eax, eax
  01330	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  01335	f3 aa		 rep stosb

; 4490 :     rc = unlink (cckd_sf_name (dev, from_sfx));

  01337	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  0133e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01343	e8 00 00 00 00	 call	 cckd_sf_name
  01348	48 8b c8	 mov	 rcx, rax
  0134b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_unlink
  01351	89 84 24 18 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4491 : 
; 4492 :     /* adjust the stats */
; 4493 :     cckd->reads   [to_sfx] += cckd->reads   [from_sfx];

  01358	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  01360	48 63 8c 24 84
	00 00 00	 movsxd	 rcx, DWORD PTR from_sfx$[rsp]
  01368	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  0136d	8b 84 82 28 01
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+296]
  01374	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  01379	03 84 8a 28 01
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+296]
  01380	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR to_sfx$[rsp]
  01388	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  0138d	89 84 8a 28 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+296], eax

; 4494 :     cckd->writes  [to_sfx] += cckd->writes  [from_sfx];

  01394	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  0139c	48 63 8c 24 84
	00 00 00	 movsxd	 rcx, DWORD PTR from_sfx$[rsp]
  013a4	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  013a9	8b 84 82 70 01
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+368]
  013b0	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  013b5	03 84 8a 70 01
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+368]
  013bc	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR to_sfx$[rsp]
  013c4	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  013c9	89 84 8a 70 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+368], eax

; 4495 :     cckd->L2_reads[to_sfx] += cckd->L2_reads[from_sfx];

  013d0	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  013d8	48 63 8c 24 84
	00 00 00	 movsxd	 rcx, DWORD PTR from_sfx$[rsp]
  013e0	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  013e5	8b 84 82 4c 01
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+332]
  013ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  013f1	03 84 8a 4c 01
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+332]
  013f8	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR to_sfx$[rsp]
  01400	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  01405	89 84 8a 4c 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+332], eax

; 4496 : 
; 4497 :     cckd->reads   [from_sfx] = 0;

  0140c	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  01414	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  01419	c7 84 81 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+296], 0

; 4498 :     cckd->writes  [from_sfx] = 0;

  01424	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  0142c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  01431	c7 84 81 70 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+368], 0

; 4499 :     cckd->L2_reads[from_sfx] = 0;

  0143c	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  01444	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  01449	c7 84 81 4c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+332], 0

; 4500 : 
; 4501 :     /* Add the file back if necessary */
; 4502 :     if (add) rc = cckd_sf_new( dev ) ;

  01454	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR add$[rsp], 0
  0145c	74 11		 je	 SHORT $LN53@cckd_sf_re
  0145e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01463	e8 00 00 00 00	 call	 cckd_sf_new
  01468	89 84 24 18 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
$LN53@cckd_sf_re:

; 4503 : 
; 4504 :     // "%1d:%04X CCKD file[%d] %s: shadow file successfully %s"
; 4505 :     WRMSG( HHC00325, "I", LCSS_DEVNUM, from_sfx, cckd_sf_name( dev, from_sfx ),

  0146f	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR merge$[rsp], 0
  01477	74 11		 je	 SHORT $LN97@cckd_sf_re
  01479	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171985
  01480	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv810[rsp], rax
  01488	eb 3a		 jmp	 SHORT $LN98@cckd_sf_re
$LN97@cckd_sf_re:
  0148a	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR add$[rsp], 0
  01492	74 11		 je	 SHORT $LN95@cckd_sf_re
  01494	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171986
  0149b	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv808[rsp], rax
  014a3	eb 0f		 jmp	 SHORT $LN96@cckd_sf_re
$LN95@cckd_sf_re:
  014a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171987
  014ac	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv808[rsp], rax
$LN96@cckd_sf_re:
  014b4	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR tv808[rsp]
  014bc	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv810[rsp], rax
$LN98@cckd_sf_re:
  014c4	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  014ca	74 12		 je	 SHORT $LN99@cckd_sf_re
  014cc	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  014d1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  014d5	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv820[rsp], eax
  014dc	eb 0b		 jmp	 SHORT $LN100@cckd_sf_re
$LN99@cckd_sf_re:
  014de	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv820[rsp], 0
$LN100@cckd_sf_re:
  014e9	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  014ef	74 14		 je	 SHORT $LN101@cckd_sf_re
  014f1	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  014f6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  014fa	d1 f8		 sar	 eax, 1
  014fc	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv826[rsp], eax
  01503	eb 0b		 jmp	 SHORT $LN102@cckd_sf_re
$LN101@cckd_sf_re:
  01505	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv826[rsp], 0
$LN102@cckd_sf_re:
  01510	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  01517	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0151c	e8 00 00 00 00	 call	 cckd_sf_name
  01521	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv812[rsp], rax
  01529	b9 01 00 00 00	 mov	 ecx, 1
  0152e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01534	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv810[rsp]
  0153c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01541	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv812[rsp]
  01549	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0154e	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  01555	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01559	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv820[rsp]
  01560	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01564	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv826[rsp]
  0156b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0156f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171988
  01576	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0157b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171989
  01582	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01587	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0158c	41 b9 03 00 00
	00		 mov	 r9d, 3
  01592	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171990
  01599	ba 9a 11 00 00	 mov	 edx, 4506		; 0000119aH
  0159e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171991
  015a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$sf_remove_exit$112:

; 4506 :                    merge ? "merged" : add ? "re-added" : "removed" );
; 4507 : 
; 4508 : sf_remove_exit:
; 4509 : 
; 4510 :     /* Re-read the l1 to set L2_bounds, L2ok */
; 4511 :     cckd_read_l1( dev );

  015ab	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  015b0	e8 00 00 00 00	 call	 cckd_read_l1

; 4512 : 
; 4513 :     release_lock( &cckd->filelock );

  015b5	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  015ba	48 83 c0 10	 add	 rax, 16
  015be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171992
  015c5	48 8b c8	 mov	 rcx, rax
  015c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4514 : 
; 4515 :     obtain_lock( &cckd->cckdiolock );

  015ce	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  015d3	48 83 c0 18	 add	 rax, 24
  015d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171993
  015de	48 8b c8	 mov	 rcx, rax
  015e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4516 :     {
; 4517 :         cckd_purge_cache( dev );

  015e7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  015ec	e8 00 00 00 00	 call	 cckd_purge_cache

; 4518 :         cckd_purge_l2( dev );

  015f1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  015f6	e8 00 00 00 00	 call	 cckd_purge_l2

; 4519 :         dev->bufcur = dev->cache = -1;

  015fb	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  01600	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0160a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0160f	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 4520 :         cckd->merging = 0;

  01619	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0161e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  01621	83 e0 df	 and	 eax, -33		; ffffffdfH
  01624	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  01629	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4521 :         if (cckd->cckdwaiters)

  0162c	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  01631	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  01635	74 19		 je	 SHORT $LN54@cckd_sf_re

; 4522 :             broadcast_condition( &cckd->cckdiocond );

  01637	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0163c	48 83 c0 20	 add	 rax, 32			; 00000020H
  01640	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171995
  01647	48 8b c8	 mov	 rcx, rax
  0164a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN54@cckd_sf_re:

; 4523 :         CCKD_TRACE( "merge complete%s", "" );

  01650	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171996
  01657	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0165c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171997
  01663	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  01668	ba ab 11 00 00	 mov	 edx, 4523		; 000011abH
  0166d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171998
  01674	e8 00 00 00 00	 call	 cckd_trace

; 4524 :     }
; 4525 :     release_lock( &cckd->cckdiolock );

  01679	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0167e	48 83 c0 18	 add	 rax, 24
  01682	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171999
  01689	48 8b c8	 mov	 rcx, rax
  0168c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4526 : 
; 4527 :     cckd_sf_stats( dev );

  01692	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01697	e8 00 00 00 00	 call	 cckd_sf_stats

; 4528 :     return NULL;

  0169c	33 c0		 xor	 eax, eax
  0169e	e9 c8 02 00 00	 jmp	 $LN1@cckd_sf_re
$sf_merge_error$113:

; 4529 : 
; 4530 : sf_merge_error:
; 4531 : 
; 4532 :     if (trk < 0)

  016a3	83 bc 24 ac 00
	00 00 00	 cmp	 DWORD PTR trk$[rsp], 0
  016ab	0f 8d df 00 00
	00		 jge	 $LN55@cckd_sf_re

; 4533 :         // "%1d:%04X CCKD file[%d] %s: shadow file not merged, error during merge"
; 4534 :         WRMSG( HHC00326, "E", LCSS_DEVNUM, from_sfx, cckd_sf_name( dev, from_sfx ));

  016b1	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  016b7	74 12		 je	 SHORT $LN103@cckd_sf_re
  016b9	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  016be	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  016c2	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv906[rsp], eax
  016c9	eb 0b		 jmp	 SHORT $LN104@cckd_sf_re
$LN103@cckd_sf_re:
  016cb	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv906[rsp], 0
$LN104@cckd_sf_re:
  016d6	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  016dc	74 14		 je	 SHORT $LN105@cckd_sf_re
  016de	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  016e3	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  016e7	d1 f8		 sar	 eax, 1
  016e9	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv912[rsp], eax
  016f0	eb 0b		 jmp	 SHORT $LN106@cckd_sf_re
$LN105@cckd_sf_re:
  016f2	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv912[rsp], 0
$LN106@cckd_sf_re:
  016fd	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  01704	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01709	e8 00 00 00 00	 call	 cckd_sf_name
  0170e	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv898[rsp], rax
  01716	b9 01 00 00 00	 mov	 ecx, 1
  0171b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01721	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv898[rsp]
  01729	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0172e	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  01735	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01739	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv906[rsp]
  01740	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01744	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv912[rsp]
  0174b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0174f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172002
  01756	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0175b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172003
  01762	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01767	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0176c	41 b9 03 00 00
	00		 mov	 r9d, 3
  01772	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172004
  01779	ba b6 11 00 00	 mov	 edx, 4534		; 000011b6H
  0177e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172005
  01785	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  0178b	e9 e5 00 00 00	 jmp	 $LN56@cckd_sf_re
$LN55@cckd_sf_re:

; 4535 :     else
; 4536 :         // "%1d:%04X CCKD file[%d] %s: shadow file not merged, error processing trk(%d)"
; 4537 :         WRMSG( HHC00327, "E", LCSS_DEVNUM, from_sfx, cckd_sf_name( dev, from_sfx ), trk );

  01790	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  01796	74 12		 je	 SHORT $LN107@cckd_sf_re
  01798	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0179d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  017a1	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv932[rsp], eax
  017a8	eb 0b		 jmp	 SHORT $LN108@cckd_sf_re
$LN107@cckd_sf_re:
  017aa	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv932[rsp], 0
$LN108@cckd_sf_re:
  017b5	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  017bb	74 14		 je	 SHORT $LN109@cckd_sf_re
  017bd	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  017c2	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  017c6	d1 f8		 sar	 eax, 1
  017c8	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv938[rsp], eax
  017cf	eb 0b		 jmp	 SHORT $LN110@cckd_sf_re
$LN109@cckd_sf_re:
  017d1	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv938[rsp], 0
$LN110@cckd_sf_re:
  017dc	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  017e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  017e8	e8 00 00 00 00	 call	 cckd_sf_name
  017ed	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv924[rsp], rax
  017f5	b9 01 00 00 00	 mov	 ecx, 1
  017fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01800	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  01807	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0180b	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR tv924[rsp]
  01813	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01818	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  0181f	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01823	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv932[rsp]
  0182a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0182e	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv938[rsp]
  01835	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01839	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172006
  01840	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01845	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172007
  0184c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01851	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01856	41 b9 03 00 00
	00		 mov	 r9d, 3
  0185c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172008
  01863	ba b9 11 00 00	 mov	 edx, 4537		; 000011b9H
  01868	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172009
  0186f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN56@cckd_sf_re:

; 4538 : 
; 4539 :     if (l2updated && cckd->L1tab[ to_sfx ][i] && cckd->L1tab[ to_sfx ][i] != CCKD_SHADOW_NO_OFFSET)

  01875	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR l2updated$[rsp], 0
  0187d	0f 84 a2 00 00
	00		 je	 $LN57@cckd_sf_re
  01883	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  0188b	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  01893	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  01898	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  018a0	83 3c 88 00	 cmp	 DWORD PTR [rax+rcx*4], 0
  018a4	74 7f		 je	 SHORT $LN57@cckd_sf_re
  018a6	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  018ae	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  018b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  018bb	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  018c3	83 3c 88 ff	 cmp	 DWORD PTR [rax+rcx*4], -1 ; ffffffffH
  018c7	74 5c		 je	 SHORT $LN57@cckd_sf_re

; 4540 :     {
; 4541 :         l2updated = 0;

  018c9	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR l2updated$[rsp], 0

; 4542 :         pos = (off_t)cckd->L1tab[to_sfx][i];

  018d4	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  018dc	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  018e4	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  018e9	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  018f1	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  018f4	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax

; 4543 :         cckd_write( dev, to_sfx, pos, &to_l2, CCKD_L2TAB_SIZE );

  018fc	c7 44 24 20 00
	08 00 00	 mov	 DWORD PTR [rsp+32], 2048 ; 00000800H
  01904	4c 8d 8c 24 90
	01 00 00	 lea	 r9, QWORD PTR to_l2$[rsp]
  0190c	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pos$[rsp]
  01914	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  0191b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01920	e8 00 00 00 00	 call	 cckd_write
$LN57@cckd_sf_re:

; 4544 :     }
; 4545 :     cckd_harden( dev );

  01925	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0192a	e8 00 00 00 00	 call	 cckd_harden

; 4546 :     cckd_chkdsk( dev, 2 );

  0192f	ba 02 00 00 00	 mov	 edx, 2
  01934	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01939	e8 00 00 00 00	 call	 cckd_chkdsk

; 4547 :     cckd->sfn = from_sfx;

  0193e	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  01943	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  0194a	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 4548 :     cckd_harden( dev );

  0194d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01952	e8 00 00 00 00	 call	 cckd_harden

; 4549 :     cckd_chkdsk( dev, 2 );

  01957	ba 02 00 00 00	 mov	 edx, 2
  0195c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01961	e8 00 00 00 00	 call	 cckd_chkdsk

; 4550 :     goto sf_remove_exit;

  01966	e9 40 fc ff ff	 jmp	 $sf_remove_exit$112
$LN1@cckd_sf_re:

; 4551 : 
; 4552 : } /* end function cckd_sf_remove */

  0196b	48 8b 8c 24 90
	11 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01973	48 33 cc	 xor	 rcx, rsp
  01976	e8 00 00 00 00	 call	 __security_check_cookie
  0197b	48 81 c4 a0 11
	01 00		 add	 rsp, 70048		; 000111a0H
  01982	5f		 pop	 rdi
  01983	c3		 ret	 0
cckd_sf_remove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 96
cckd$ = 104
n$1 = 112
tv73 = 116
tv79 = 120
tv139 = 124
tv145 = 128
tv176 = 132
tv182 = 136
tv250 = 140
tv256 = 144
tv291 = 148
tv297 = 152
tv245 = 156
tv242 = 160
tv163 = 168
tv275 = 176
data$ = 208
cckd_sf_add PROC

; 4125 : {

$LN38:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 4126 : DEVBLK         *dev = data;             /* -> DEVBLK                 */

  0000c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00014	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax

; 4127 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 4128 : 
; 4129 :     if (dev == NULL)

  00019	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0001f	0f 85 50 01 00
	00		 jne	 $LN7@cckd_sf_ad

; 4130 :     {
; 4131 :     int n = 0;

  00025	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0

; 4132 :         for (dev=sysblk.firstdev; dev; dev=dev->nextdev)

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00034	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  0003b	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
  00040	eb 0e		 jmp	 SHORT $LN4@cckd_sf_ad
$LN2@cckd_sf_ad:
  00042	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00047	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0004b	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd_sf_ad:
  00050	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00056	0f 84 c3 00 00
	00		 je	 $LN3@cckd_sf_ad

; 4133 :             if (dev->cckd_ext)

  0005c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00061	48 83 b8 08 13
	00 00 00	 cmp	 QWORD PTR [rax+4872], 0
  00069	0f 84 ab 00 00
	00		 je	 $LN8@cckd_sf_ad

; 4134 :             {
; 4135 :                 WRMSG (HHC00315, "I", LCSS_DEVNUM );

  0006f	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00075	74 0f		 je	 SHORT $LN16@cckd_sf_ad
  00077	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0007c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00080	89 44 24 74	 mov	 DWORD PTR tv73[rsp], eax
  00084	eb 08		 jmp	 SHORT $LN17@cckd_sf_ad
$LN16@cckd_sf_ad:
  00086	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN17@cckd_sf_ad:
  0008e	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00094	74 11		 je	 SHORT $LN18@cckd_sf_ad
  00096	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0009b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0009f	d1 f8		 sar	 eax, 1
  000a1	89 44 24 78	 mov	 DWORD PTR tv79[rsp], eax
  000a5	eb 08		 jmp	 SHORT $LN19@cckd_sf_ad
$LN18@cckd_sf_ad:
  000a7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN19@cckd_sf_ad:
  000af	b9 01 00 00 00	 mov	 ecx, 1
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ba	8b 4c 24 74	 mov	 ecx, DWORD PTR tv73[rsp]
  000be	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c2	8b 4c 24 78	 mov	 ecx, DWORD PTR tv79[rsp]
  000c6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171759
  000d1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171760
  000dd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171761
  000f4	ba 27 10 00 00	 mov	 edx, 4135		; 00001027H
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171762
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4136 :                 cckd_sf_add (dev);

  00106	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0010b	e8 00 00 00 00	 call	 cckd_sf_add

; 4137 :                 n++;

  00110	8b 44 24 70	 mov	 eax, DWORD PTR n$1[rsp]
  00114	ff c0		 inc	 eax
  00116	89 44 24 70	 mov	 DWORD PTR n$1[rsp], eax
$LN8@cckd_sf_ad:

; 4138 :             }

  0011a	e9 23 ff ff ff	 jmp	 $LN2@cckd_sf_ad
$LN3@cckd_sf_ad:

; 4139 :         WRMSG(HHC00316, "I", n );

  0011f	b9 01 00 00 00	 mov	 ecx, 1
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012a	8b 4c 24 70	 mov	 ecx, DWORD PTR n$1[rsp]
  0012e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171763
  00139	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171764
  00145	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00155	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171765
  0015c	ba 2b 10 00 00	 mov	 edx, 4139		; 0000102bH
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171766
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4140 :         return NULL;

  0016e	33 c0		 xor	 eax, eax
  00170	e9 cd 05 00 00	 jmp	 $LN1@cckd_sf_ad
$LN7@cckd_sf_ad:

; 4141 :     }
; 4142 : 
; 4143 :     cckd = dev->cckd_ext;

  00175	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0017a	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00181	48 89 44 24 68	 mov	 QWORD PTR cckd$[rsp], rax

; 4144 :     if (!cckd)

  00186	48 83 7c 24 68
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  0018c	0f 85 a7 00 00
	00		 jne	 $LN9@cckd_sf_ad

; 4145 :     {
; 4146 :         WRMSG (HHC00317, "E", LCSS_DEVNUM);

  00192	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00198	74 0f		 je	 SHORT $LN20@cckd_sf_ad
  0019a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0019f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001a3	89 44 24 7c	 mov	 DWORD PTR tv139[rsp], eax
  001a7	eb 08		 jmp	 SHORT $LN21@cckd_sf_ad
$LN20@cckd_sf_ad:
  001a9	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
$LN21@cckd_sf_ad:
  001b1	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001b7	74 14		 je	 SHORT $LN22@cckd_sf_ad
  001b9	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001be	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001c2	d1 f8		 sar	 eax, 1
  001c4	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv145[rsp], eax
  001cb	eb 0b		 jmp	 SHORT $LN23@cckd_sf_ad
$LN22@cckd_sf_ad:
  001cd	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv145[rsp], 0
$LN23@cckd_sf_ad:
  001d8	b9 01 00 00 00	 mov	 ecx, 1
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e3	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv139[rsp]
  001e7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001eb	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv145[rsp]
  001f2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171768
  001fd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171769
  00209	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0020e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00213	41 b9 03 00 00
	00		 mov	 r9d, 3
  00219	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171770
  00220	ba 32 10 00 00	 mov	 edx, 4146		; 00001032H
  00225	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171771
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4147 :         return NULL;

  00232	33 c0		 xor	 eax, eax
  00234	e9 09 05 00 00	 jmp	 $LN1@cckd_sf_ad
$LN9@cckd_sf_ad:

; 4148 :     }
; 4149 : 
; 4150 :     /* Schedule updated track entries to be written */
; 4151 :     obtain_lock (&cckd->cckdiolock);

  00239	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0023e	48 83 c0 18	 add	 rax, 24
  00242	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171772
  00249	48 8b c8	 mov	 rcx, rax
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4152 :     if (cckd->merging)

  00252	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00257	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0025a	c1 e8 05	 shr	 eax, 5
  0025d	83 e0 01	 and	 eax, 1
  00260	85 c0		 test	 eax, eax
  00262	0f 84 fc 00 00
	00		 je	 $LN10@cckd_sf_ad

; 4153 :     {
; 4154 :         release_lock (&cckd->cckdiolock);

  00268	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0026d	48 83 c0 18	 add	 rax, 24
  00271	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171774
  00278	48 8b c8	 mov	 rcx, rax
  0027b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4155 :         WRMSG (HHC00318, "W", LCSS_DEVNUM, cckd->sfn, cckd_sf_name (dev, cckd->sfn));

  00281	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00287	74 12		 je	 SHORT $LN24@cckd_sf_ad
  00289	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0028e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00292	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv176[rsp], eax
  00299	eb 0b		 jmp	 SHORT $LN25@cckd_sf_ad
$LN24@cckd_sf_ad:
  0029b	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv176[rsp], 0
$LN25@cckd_sf_ad:
  002a6	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002ac	74 14		 je	 SHORT $LN26@cckd_sf_ad
  002ae	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002b3	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002b7	d1 f8		 sar	 eax, 1
  002b9	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv182[rsp], eax
  002c0	eb 0b		 jmp	 SHORT $LN27@cckd_sf_ad
$LN26@cckd_sf_ad:
  002c2	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv182[rsp], 0
$LN27@cckd_sf_ad:
  002cd	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002d2	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  002d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002da	e8 00 00 00 00	 call	 cckd_sf_name
  002df	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv163[rsp], rax
  002e7	b9 01 00 00 00	 mov	 ecx, 1
  002ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv163[rsp]
  002fa	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002ff	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00304	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00307	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0030b	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv176[rsp]
  00312	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00316	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv182[rsp]
  0031d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00321	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171775
  00328	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0032d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171776
  00334	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00339	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0033e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00344	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171777
  0034b	ba 3b 10 00 00	 mov	 edx, 4155		; 0000103bH
  00350	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171778
  00357	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4156 :         return NULL;

  0035d	33 c0		 xor	 eax, eax
  0035f	e9 de 03 00 00	 jmp	 $LN1@cckd_sf_ad
$LN10@cckd_sf_ad:

; 4157 :     }
; 4158 :     cckd->merging = 1;

  00364	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00369	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0036c	83 c8 20	 or	 eax, 32			; 00000020H
  0036f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00374	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4159 :     cckd_flush_cache (dev);

  00377	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0037c	e8 00 00 00 00	 call	 cckd_flush_cache
$LN5@cckd_sf_ad:

; 4160 :     while (cckd->wrpending || cckd->cckdioact)

  00381	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00386	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  0038a	75 12		 jne	 SHORT $LN11@cckd_sf_ad
  0038c	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00391	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00394	c1 e8 02	 shr	 eax, 2
  00397	83 e0 01	 and	 eax, 1
  0039a	85 c0		 test	 eax, eax
  0039c	74 52		 je	 SHORT $LN6@cckd_sf_ad
$LN11@cckd_sf_ad:

; 4161 :     {
; 4162 :         cckd->cckdwaiters++;

  0039e	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003a3	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  003a6	ff c0		 inc	 eax
  003a8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  003ad	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 4163 :         wait_condition (&cckd->cckdiocond, &cckd->cckdiolock);

  003b0	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003b5	48 83 c0 18	 add	 rax, 24
  003b9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  003be	48 83 c1 20	 add	 rcx, 32			; 00000020H
  003c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171780
  003c9	48 8b d0	 mov	 rdx, rax
  003cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 4164 :         cckd->cckdwaiters--;

  003d2	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003d7	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  003da	ff c8		 dec	 eax
  003dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  003e1	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 4165 :         cckd_flush_cache (dev);

  003e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003e9	e8 00 00 00 00	 call	 cckd_flush_cache

; 4166 :     }

  003ee	eb 91		 jmp	 SHORT $LN5@cckd_sf_ad
$LN6@cckd_sf_ad:

; 4167 :     cckd_purge_cache (dev); cckd_purge_l2 (dev);

  003f0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003f5	e8 00 00 00 00	 call	 cckd_purge_cache
  003fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003ff	e8 00 00 00 00	 call	 cckd_purge_l2

; 4168 :     dev->bufcur = dev->cache = -1;

  00404	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00409	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00413	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00418	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 4169 :     release_lock (&cckd->cckdiolock);

  00422	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00427	48 83 c0 18	 add	 rax, 24
  0042b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171781
  00432	48 8b c8	 mov	 rcx, rax
  00435	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4170 : 
; 4171 :     /* Obtain control of the file */
; 4172 :     obtain_lock( &cckd->filelock );

  0043b	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00440	48 83 c0 10	 add	 rax, 16
  00444	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171782
  0044b	48 8b c8	 mov	 rcx, rax
  0044e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4173 :     {
; 4174 :         /* Harden the current file */
; 4175 :         cckd_harden (dev);

  00454	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00459	e8 00 00 00 00	 call	 cckd_harden

; 4176 : 
; 4177 :         /* Create a new shadow file */
; 4178 :         if (cckd_sf_new (dev) < 0) {

  0045e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00463	e8 00 00 00 00	 call	 cckd_sf_new
  00468	85 c0		 test	 eax, eax
  0046a	0f 8d 21 01 00
	00		 jge	 $LN12@cckd_sf_ad

; 4179 :             WRMSG (HHC00319, "E", LCSS_DEVNUM, cckd->sfn+1,

  00470	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00475	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00478	ff c0		 inc	 eax
  0047a	8b d0		 mov	 edx, eax
  0047c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00481	e8 00 00 00 00	 call	 cckd_sf_name
  00486	48 85 c0	 test	 rax, rax
  00489	74 20		 je	 SHORT $LN28@cckd_sf_ad
  0048b	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00490	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00493	ff c0		 inc	 eax
  00495	8b d0		 mov	 edx, eax
  00497	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0049c	e8 00 00 00 00	 call	 cckd_sf_name
  004a1	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv242[rsp], rax
  004a9	eb 0f		 jmp	 SHORT $LN29@cckd_sf_ad
$LN28@cckd_sf_ad:
  004ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171784
  004b2	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv242[rsp], rax
$LN29@cckd_sf_ad:
  004ba	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  004c0	74 12		 je	 SHORT $LN30@cckd_sf_ad
  004c2	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  004c7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004cb	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv250[rsp], eax
  004d2	eb 0b		 jmp	 SHORT $LN31@cckd_sf_ad
$LN30@cckd_sf_ad:
  004d4	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv250[rsp], 0
$LN31@cckd_sf_ad:
  004df	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  004e5	74 14		 je	 SHORT $LN32@cckd_sf_ad
  004e7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  004ec	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  004f0	d1 f8		 sar	 eax, 1
  004f2	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv256[rsp], eax
  004f9	eb 0b		 jmp	 SHORT $LN33@cckd_sf_ad
$LN32@cckd_sf_ad:
  004fb	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv256[rsp], 0
$LN33@cckd_sf_ad:
  00506	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0050b	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0050e	ff c0		 inc	 eax
  00510	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv245[rsp], eax
  00517	b9 01 00 00 00	 mov	 ecx, 1
  0051c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00522	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv242[rsp]
  0052a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0052f	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv245[rsp]
  00536	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0053a	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv250[rsp]
  00541	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00545	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv256[rsp]
  0054c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00550	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171785
  00557	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0055c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171786
  00563	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00568	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0056d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00573	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171787
  0057a	ba 54 10 00 00	 mov	 edx, 4180		; 00001054H
  0057f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171788
  00586	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4180 :                      cckd_sf_name(dev, cckd->sfn+1)?cckd_sf_name(dev, cckd->sfn+1):"(null)");
; 4181 :             goto cckd_sf_add_exit;

  0058c	e9 19 01 00 00	 jmp	 $cckd_sf_add_exit$39
$LN12@cckd_sf_ad:

; 4182 :         }
; 4183 : 
; 4184 :         /* Re-open the previous file if opened read-write */
; 4185 :         if (cckd->open[cckd->sfn-1] == CCKD_OPEN_RW)

  00591	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00596	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00599	ff c8		 dec	 eax
  0059b	48 98		 cdqe
  0059d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  005a2	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  005aa	83 f8 03	 cmp	 eax, 3
  005ad	75 1f		 jne	 SHORT $LN13@cckd_sf_ad

; 4186 :             cckd_open (dev, cckd->sfn-1, O_RDONLY|O_BINARY, 0);

  005af	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  005b4	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  005b7	ff c8		 dec	 eax
  005b9	45 33 c9	 xor	 r9d, r9d
  005bc	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  005c2	8b d0		 mov	 edx, eax
  005c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  005c9	e8 00 00 00 00	 call	 cckd_open
$LN13@cckd_sf_ad:

; 4187 : 
; 4188 :         WRMSG (HHC00320, "I", LCSS_DEVNUM, cckd->sfn, cckd_sf_name (dev, cckd->sfn));

  005ce	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  005d4	74 12		 je	 SHORT $LN34@cckd_sf_ad
  005d6	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  005db	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005df	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv291[rsp], eax
  005e6	eb 0b		 jmp	 SHORT $LN35@cckd_sf_ad
$LN34@cckd_sf_ad:
  005e8	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv291[rsp], 0
$LN35@cckd_sf_ad:
  005f3	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  005f9	74 14		 je	 SHORT $LN36@cckd_sf_ad
  005fb	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00600	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00604	d1 f8		 sar	 eax, 1
  00606	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv297[rsp], eax
  0060d	eb 0b		 jmp	 SHORT $LN37@cckd_sf_ad
$LN36@cckd_sf_ad:
  0060f	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv297[rsp], 0
$LN37@cckd_sf_ad:
  0061a	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0061f	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00622	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00627	e8 00 00 00 00	 call	 cckd_sf_name
  0062c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv275[rsp], rax
  00634	b9 01 00 00 00	 mov	 ecx, 1
  00639	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0063f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv275[rsp]
  00647	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0064c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00651	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00654	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00658	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv291[rsp]
  0065f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00663	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv297[rsp]
  0066a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0066e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171790
  00675	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0067a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171791
  00681	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00686	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0068b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00691	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171792
  00698	ba 5c 10 00 00	 mov	 edx, 4188		; 0000105cH
  0069d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171793
  006a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$cckd_sf_add_exit$39:

; 4189 : 
; 4190 : cckd_sf_add_exit:
; 4191 : 
; 4192 :         /* Re-read the l1 to set L2_bounds, L2ok */
; 4193 :         cckd_read_l1 (dev);

  006aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  006af	e8 00 00 00 00	 call	 cckd_read_l1

; 4194 :     }
; 4195 :     release_lock( &cckd->filelock );

  006b4	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  006b9	48 83 c0 10	 add	 rax, 16
  006bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171794
  006c4	48 8b c8	 mov	 rcx, rax
  006c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4196 : 
; 4197 :     obtain_lock (&cckd->cckdiolock);

  006cd	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  006d2	48 83 c0 18	 add	 rax, 24
  006d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171795
  006dd	48 8b c8	 mov	 rcx, rax
  006e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4198 :     cckd->merging = 0;

  006e6	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  006eb	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  006ee	83 e0 df	 and	 eax, -33		; ffffffdfH
  006f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  006f6	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4199 :     if (cckd->cckdwaiters)

  006f9	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  006fe	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00702	74 19		 je	 SHORT $LN14@cckd_sf_ad

; 4200 :         broadcast_condition (&cckd->cckdiocond);

  00704	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00709	48 83 c0 20	 add	 rax, 32			; 00000020H
  0070d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171797
  00714	48 8b c8	 mov	 rcx, rax
  00717	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN14@cckd_sf_ad:

; 4201 :     release_lock (&cckd->cckdiolock);

  0071d	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00722	48 83 c0 18	 add	 rax, 24
  00726	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171798
  0072d	48 8b c8	 mov	 rcx, rax
  00730	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4202 : 
; 4203 :     cckd_sf_stats (dev);

  00736	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0073b	e8 00 00 00 00	 call	 cckd_sf_stats

; 4204 :     return NULL;

  00740	33 c0		 xor	 eax, eax
$LN1@cckd_sf_ad:

; 4205 : } /* end function cckd_sf_add */

  00742	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00749	c3		 ret	 0
cckd_sf_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
tv67 = 0
tv69 = 4
cckd_dtax PROC

; 6214 : {

$LN7:
  00000	48 83 ec 18	 sub	 rsp, 24

; 6215 :     return cckdblk.dtax ? true : false;

  00004	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  0000a	c1 e8 02	 shr	 eax, 2
  0000d	83 e0 01	 and	 eax, 1
  00010	85 c0		 test	 eax, eax
  00012	74 09		 je	 SHORT $LN3@cckd_dtax
  00014	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
  0001b	eb 07		 jmp	 SHORT $LN4@cckd_dtax
$LN3@cckd_dtax:
  0001d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
$LN4@cckd_dtax:
  00024	83 3c 24 00	 cmp	 DWORD PTR tv67[rsp], 0
  00028	75 0a		 jne	 SHORT $LN5@cckd_dtax
  0002a	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
  00032	eb 08		 jmp	 SHORT $LN6@cckd_dtax
$LN5@cckd_dtax:
  00034	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
$LN6@cckd_dtax:
  0003c	0f b6 44 24 04	 movzx	 eax, BYTE PTR tv69[rsp]

; 6216 : }

  00041	48 83 c4 18	 add	 rsp, 24
  00045	c3		 ret	 0
cckd_dtax ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
i$1 = 64
pcur$2 = 72
pbeg$3 = 80
tv128 = 88
cckd_print_itrace PROC

; 6639 : {

$LN10:
  00000	40 57		 push	 rdi
  00002	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 6640 : 
; 6641 :     // "CCKD file: internal cckd trace"
; 6642 :     WRMSG( HHC00399, "I" );

  00006	b9 01 00 00 00	 mov	 ecx, 1
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00011	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173231
  00018	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173232
  00024	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00029	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00034	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173233
  0003b	ba f2 19 00 00	 mov	 edx, 6642		; 000019f2H
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173234
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6643 : 
; 6644 :     OBTAIN_TRACE_LOCK();

  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173235
  00054	48 8d 0d f0 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+752
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6645 :     if (cckdblk.itracen)                    // have trace table?

  00061	83 3d 10 03 00
	00 00		 cmp	 DWORD PTR cckdblk+784, 0
  00068	0f 84 21 01 00
	00		 je	 $LN5@cckd_print

; 6646 :     {
; 6647 :         CCKD_ITRACE*  pbeg;                 // start of trace table
; 6648 :         CCKD_ITRACE*  pcur;                 // current working entry
; 6649 :         int i;                              // loop counter
; 6650 : 
; 6651 :         pbeg = cckdblk.itrace;              // save beginning of table

  0006e	48 8b 05 f8 02
	00 00		 mov	 rax, QWORD PTR cckdblk+760
  00075	48 89 44 24 50	 mov	 QWORD PTR pbeg$3[rsp], rax

; 6652 :         pcur = cckdblk.itracep;             // "current" (oldest) entry

  0007a	48 8b 05 00 03
	00 00		 mov	 rax, QWORD PTR cckdblk+768
  00081	48 89 44 24 48	 mov	 QWORD PTR pcur$2[rsp], rax

; 6653 : 
; 6654 :         if (pcur >= cckdblk.itracex)        // past end of table?

  00086	48 8b 05 08 03
	00 00		 mov	 rax, QWORD PTR cckdblk+776
  0008d	48 39 44 24 48	 cmp	 QWORD PTR pcur$2[rsp], rax
  00092	72 0a		 jb	 SHORT $LN6@cckd_print

; 6655 :             pcur = pbeg;                    // then wrap to begin

  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR pbeg$3[rsp]
  00099	48 89 44 24 48	 mov	 QWORD PTR pcur$2[rsp], rax
$LN6@cckd_print:

; 6656 : 
; 6657 :         for (i=0; i < cckdblk.itracec; ++i) // print all used entries

  0009e	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  000a6	eb 0a		 jmp	 SHORT $LN4@cckd_print
$LN2@cckd_print:
  000a8	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  000ac	ff c0		 inc	 eax
  000ae	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN4@cckd_print:
  000b2	8b 05 14 03 00
	00		 mov	 eax, DWORD PTR cckdblk+788
  000b8	39 44 24 40	 cmp	 DWORD PTR i$1[rsp], eax
  000bc	0f 8d 8a 00 00
	00		 jge	 $LN3@cckd_print

; 6658 :         {
; 6659 :             if (*(const char*)pcur)         // print entry if not empty

  000c2	48 8b 44 24 48	 mov	 rax, QWORD PTR pcur$2[rsp]
  000c7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ca	85 c0		 test	 eax, eax
  000cc	74 51		 je	 SHORT $LN7@cckd_print

; 6660 :                 // "%s"
; 6661 :                 WRMSG( HHC00398, "I", (const char*) pcur );

  000ce	b9 01 00 00 00	 mov	 ecx, 1
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pcur$2[rsp]
  000de	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173239
  000ea	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173240
  000f6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00100	41 b9 03 00 00
	00		 mov	 r9d, 3
  00106	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173241
  0010d	ba 05 1a 00 00	 mov	 edx, 6661		; 00001a05H
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173242
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@cckd_print:

; 6662 : 
; 6663 :             if (++pcur >= cckdblk.itracex)  // next entry; if past end

  0011f	48 8b 44 24 48	 mov	 rax, QWORD PTR pcur$2[rsp]
  00124	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  0012a	48 89 44 24 48	 mov	 QWORD PTR pcur$2[rsp], rax
  0012f	48 8b 05 08 03
	00 00		 mov	 rax, QWORD PTR cckdblk+776
  00136	48 39 44 24 48	 cmp	 QWORD PTR pcur$2[rsp], rax
  0013b	72 0a		 jb	 SHORT $LN8@cckd_print

; 6664 :                 pcur = pbeg;                // then wrap to begin

  0013d	48 8b 44 24 50	 mov	 rax, QWORD PTR pbeg$3[rsp]
  00142	48 89 44 24 48	 mov	 QWORD PTR pcur$2[rsp], rax
$LN8@cckd_print:

; 6665 :         }

  00147	e9 5c ff ff ff	 jmp	 $LN2@cckd_print
$LN3@cckd_print:

; 6666 : 
; 6667 :         // Clear all table entries and reset pointers
; 6668 :         memset( pbeg, 0, cckdblk.itracen * sizeof( CCKD_ITRACE ));

  0014c	48 63 05 10 03
	00 00		 movsxd	 rax, DWORD PTR cckdblk+784
  00153	48 69 c0 00 01
	00 00		 imul	 rax, rax, 256		; 00000100H
  0015a	48 89 44 24 58	 mov	 QWORD PTR tv128[rsp], rax
  0015f	48 8b 7c 24 50	 mov	 rdi, QWORD PTR pbeg$3[rsp]
  00164	33 c0		 xor	 eax, eax
  00166	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv128[rsp]
  0016b	f3 aa		 rep stosb

; 6669 :         cckdblk.itracep = pbeg;

  0016d	48 8b 44 24 50	 mov	 rax, QWORD PTR pbeg$3[rsp]
  00172	48 89 05 00 03
	00 00		 mov	 QWORD PTR cckdblk+768, rax

; 6670 :         cckdblk.itrace  = pbeg;

  00179	48 8b 44 24 50	 mov	 rax, QWORD PTR pbeg$3[rsp]
  0017e	48 89 05 f8 02
	00 00		 mov	 QWORD PTR cckdblk+760, rax

; 6671 :         cckdblk.itracec = 0;

  00185	c7 05 14 03 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+788, 0
$LN5@cckd_print:

; 6672 :     }
; 6673 :     RELEASE_TRACE_LOCK();

  0018f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173244
  00196	48 8d 0d f0 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+752
  0019d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6674 : 
; 6675 : } /* end function cckd_print_itrace */

  001a3	48 83 c4 60	 add	 rsp, 96			; 00000060H
  001a7	5f		 pop	 rdi
  001a8	c3		 ret	 0
cckd_print_itrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
tv128 = 80
tv134 = 84
tv167 = 88
tv173 = 92
itracep$1 = 96
vl$ = 104
$T2 = 112
timeval$3 = 120
todsecs$4 = 128
todwrk$5 = 136
trcpfx$6 = 168
trcmsg$ = 208
__$ArrayPad$ = 464
func$ = 496
line$ = 504
dev$ = 512
fmt$ = 520
cckd_trace PROC

; 6681 : {

$LN21:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6682 :     va_list vl;
; 6683 :     char trcmsg[ CCKD_TRACE_SIZE ];
; 6684 : 
; 6685 :     /* Quick exit if trace messages not enabled or no trace table */
; 6686 :     if (!(dev && (cckdblk.debug || cckdblk.itrace)))

  0002c	48 83 bc 24 00
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00035	74 19		 je	 SHORT $LN3@cckd_trace
  00037	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  0003d	d1 e8		 shr	 eax, 1
  0003f	83 e0 01	 and	 eax, 1
  00042	85 c0		 test	 eax, eax
  00044	75 0f		 jne	 SHORT $LN2@cckd_trace
  00046	48 83 3d f8 02
	00 00 00	 cmp	 QWORD PTR cckdblk+760, 0
  0004e	75 05		 jne	 SHORT $LN2@cckd_trace
$LN3@cckd_trace:

; 6687 :         return;

  00050	e9 ff 02 00 00	 jmp	 $LN1@cckd_trace
$LN2@cckd_trace:

; 6688 : 
; 6689 :     /* Build the cckd trace message */
; 6690 :     va_start( vl, fmt );

  00055	48 8d 84 24 10
	02 00 00	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0005d	48 89 44 24 68	 mov	 QWORD PTR vl$[rsp], rax

; 6691 :     if (vsnprintf( trcmsg, sizeof( trcmsg ), fmt, vl ) < 0)

  00062	4c 8b 4c 24 68	 mov	 r9, QWORD PTR vl$[rsp]
  00067	4c 8b 84 24 08
	02 00 00	 mov	 r8, QWORD PTR fmt$[rsp]
  0006f	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00074	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR trcmsg$[rsp]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_vsnprintf
  00082	85 c0		 test	 eax, eax
  00084	7d 05		 jge	 SHORT $LN4@cckd_trace

; 6692 :         return;

  00086	e9 c9 02 00 00	 jmp	 $LN1@cckd_trace
$LN4@cckd_trace:

; 6693 :     va_end( vl );

  0008b	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR vl$[rsp], 0

; 6694 : 
; 6695 :     /* Add the message to our internal trace table (if we have one) */
; 6696 :     OBTAIN_TRACE_LOCK();

  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173274
  0009b	48 8d 0d f0 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+752
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6697 :     if (cckdblk.itracen)

  000a8	83 3d 10 03 00
	00 00		 cmp	 DWORD PTR cckdblk+784, 0
  000af	0f 84 9d 01 00
	00		 je	 $LN5@cckd_trace

; 6698 :     {
; 6699 :         CCKD_ITRACE*    itracep;            // (trace table entry ptr)
; 6700 :         struct timeval  timeval;            // (microsecond accuracy)
; 6701 :         time_t          todsecs;            // (#of secs since epoch)
; 6702 :         char            todwrk[32];         // (work)
; 6703 :         char            trcpfx[32];         // "hh:mm:ss.uuuuuu n:CCUU> "
; 6704 : 
; 6705 :         /* Build TOD+CUU "hh:mm:ss.uuuuuu n:CCUU> " prefix string */
; 6706 : 
; 6707 :         gettimeofday( &timeval, NULL );     // (microsecond accuracy)

  000b5	33 d2		 xor	 edx, edx
  000b7	48 8d 4c 24 78	 lea	 rcx, QWORD PTR timeval$3[rsp]
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 6708 : 
; 6709 :         todsecs = timeval.tv_sec;

  000c2	48 63 44 24 78	 movsxd	 rax, DWORD PTR timeval$3[rsp]
  000c7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR todsecs$4[rsp], rax

; 6710 :         STRLCPY( todwrk, ctime( &todsecs ));// "Day Mon dd hh:mm:ss yyyy\n"

  000cf	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR todsecs$4[rsp]
  000d7	e8 00 00 00 00	 call	 ctime
  000dc	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000e2	48 8b d0	 mov	 rdx, rax
  000e5	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR todwrk$5[rsp]
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 6711 :         todwrk[19] = 0;                     // "Day Mon dd hh:mm:ss"

  000f3	b8 01 00 00 00	 mov	 eax, 1
  000f8	48 6b c0 13	 imul	 rax, rax, 19
  000fc	48 89 44 24 70	 mov	 QWORD PTR $T2[rsp], rax
  00101	48 83 7c 24 70
	20		 cmp	 QWORD PTR $T2[rsp], 32	; 00000020H
  00107	73 02		 jae	 SHORT $LN11@cckd_trace
  00109	eb 05		 jmp	 SHORT $LN12@cckd_trace
$LN11@cckd_trace:
  0010b	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN12@cckd_trace:
  00110	48 8b 44 24 70	 mov	 rax, QWORD PTR $T2[rsp]
  00115	c6 84 04 88 00
	00 00 00	 mov	 BYTE PTR todwrk$5[rsp+rax], 0

; 6712 : 
; 6713 :         MSGBUF( trcpfx,

  0011d	48 83 bc 24 00
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00126	74 12		 je	 SHORT $LN13@cckd_trace
  00128	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00130	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00134	89 44 24 50	 mov	 DWORD PTR tv128[rsp], eax
  00138	eb 08		 jmp	 SHORT $LN14@cckd_trace
$LN13@cckd_trace:
  0013a	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN14@cckd_trace:
  00142	48 83 bc 24 00
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0014b	74 14		 je	 SHORT $LN15@cckd_trace
  0014d	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00155	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00159	d1 f8		 sar	 eax, 1
  0015b	89 44 24 54	 mov	 DWORD PTR tv134[rsp], eax
  0015f	eb 08		 jmp	 SHORT $LN16@cckd_trace
$LN15@cckd_trace:
  00161	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN16@cckd_trace:
  00169	48 8d 84 24 93
	00 00 00	 lea	 rax, QWORD PTR todwrk$5[rsp+11]
  00171	8b 4c 24 50	 mov	 ecx, DWORD PTR tv128[rsp]
  00175	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00179	8b 4c 24 54	 mov	 ecx, DWORD PTR tv134[rsp]
  0017d	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00181	8b 4c 24 7c	 mov	 ecx, DWORD PTR timeval$3[rsp+4]
  00185	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00189	4c 8b c8	 mov	 r9, rax
  0018c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173276
  00193	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00198	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR trcpfx$6[rsp]
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6714 : 
; 6715 :             "%s.%6.6ld %1d:%04X ",          // "hh:mm:ss.uuuuuu n:CCUU "
; 6716 :             todwrk + 11,                    // "hh:mm:ss" (%s)
; 6717 :             timeval.tv_usec,                // "uuuuuu"   (%6.6ld
; 6718 :             LCSS_DEVNUM                     // "n:CCUU"   (%1d:%04X)
; 6719 :         );
; 6720 : 
; 6721 :         /* Print trace message directly into trace table entry */
; 6722 : 
; 6723 :         itracep = cckdblk.itracep++;        // (grab table entry)

  001a6	48 8b 05 00 03
	00 00		 mov	 rax, QWORD PTR cckdblk+768
  001ad	48 89 44 24 60	 mov	 QWORD PTR itracep$1[rsp], rax
  001b2	48 8b 05 00 03
	00 00		 mov	 rax, QWORD PTR cckdblk+768
  001b9	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  001bf	48 89 05 00 03
	00 00		 mov	 QWORD PTR cckdblk+768, rax

; 6724 : 
; 6725 :         if (itracep >= cckdblk.itracex)     // (past end of table?)

  001c6	48 8b 05 08 03
	00 00		 mov	 rax, QWORD PTR cckdblk+776
  001cd	48 39 44 24 60	 cmp	 QWORD PTR itracep$1[rsp], rax
  001d2	72 1e		 jb	 SHORT $LN6@cckd_trace

; 6726 :         {
; 6727 :             itracep = cckdblk.itrace;       // (wrap to beginning)

  001d4	48 8b 05 f8 02
	00 00		 mov	 rax, QWORD PTR cckdblk+760
  001db	48 89 44 24 60	 mov	 QWORD PTR itracep$1[rsp], rax

; 6728 :             cckdblk.itracep = itracep + 1;  // (curr = next entry)

  001e0	48 8b 44 24 60	 mov	 rax, QWORD PTR itracep$1[rsp]
  001e5	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  001eb	48 89 05 00 03
	00 00		 mov	 QWORD PTR cckdblk+768, rax
$LN6@cckd_trace:

; 6729 :         }
; 6730 : 
; 6731 :         if (cckdblk.itracec < cckdblk.itracen) // (less than all used?)

  001f2	8b 05 10 03 00
	00		 mov	 eax, DWORD PTR cckdblk+784
  001f8	39 05 14 03 00
	00		 cmp	 DWORD PTR cckdblk+788, eax
  001fe	7d 0e		 jge	 SHORT $LN7@cckd_trace

; 6732 :             cckdblk.itracec++;                 // (count entries used)

  00200	8b 05 14 03 00
	00		 mov	 eax, DWORD PTR cckdblk+788
  00206	ff c0		 inc	 eax
  00208	89 05 14 03 00
	00		 mov	 DWORD PTR cckdblk+788, eax
$LN7@cckd_trace:

; 6733 : 
; 6734 :         snprintf( (char*) itracep, CCKD_TRACE_SIZE, "%s%s(%d): %s",

  0020e	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR trcmsg$[rsp]
  00216	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0021b	8b 84 24 f8 01
	00 00		 mov	 eax, DWORD PTR line$[rsp]
  00222	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00226	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR func$[rsp]
  0022e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00233	4c 8d 8c 24 a8
	00 00 00	 lea	 r9, QWORD PTR trcpfx$6[rsp]
  0023b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173279
  00242	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00247	48 8b 4c 24 60	 mov	 rcx, QWORD PTR itracep$1[rsp]
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN5@cckd_trace:

; 6735 :             trcpfx, func, line, trcmsg );
; 6736 :     }
; 6737 :     RELEASE_TRACE_LOCK();

  00252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173280
  00259	48 8d 0d f0 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+752
  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6738 : 
; 6739 :     /* Log the trace entry if requested */
; 6740 :     if (cckdblk.debug)

  00266	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  0026c	d1 e8		 shr	 eax, 1
  0026e	83 e0 01	 and	 eax, 1
  00271	85 c0		 test	 eax, eax
  00273	0f 84 db 00 00
	00		 je	 $LN8@cckd_trace

; 6741 :     {
; 6742 :         if (dev && dev->ccwtrace)

  00279	48 83 bc 24 00
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00282	0f 84 cc 00 00
	00		 je	 $LN9@cckd_trace
  00288	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00290	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00296	c1 e8 0f	 shr	 eax, 15
  00299	83 e0 01	 and	 eax, 1
  0029c	85 c0		 test	 eax, eax
  0029e	0f 84 b0 00 00
	00		 je	 $LN9@cckd_trace

; 6743 :             // "%1d:%04X %s"
; 6744 :             WRMSG( HHC00396, "I", LCSS_DEVNUM, trcmsg );

  002a4	48 83 bc 24 00
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002ad	74 12		 je	 SHORT $LN17@cckd_trace
  002af	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002b7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002bb	89 44 24 58	 mov	 DWORD PTR tv167[rsp], eax
  002bf	eb 08		 jmp	 SHORT $LN18@cckd_trace
$LN17@cckd_trace:
  002c1	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN18@cckd_trace:
  002c9	48 83 bc 24 00
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002d2	74 14		 je	 SHORT $LN19@cckd_trace
  002d4	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002dc	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002e0	d1 f8		 sar	 eax, 1
  002e2	89 44 24 5c	 mov	 DWORD PTR tv173[rsp], eax
  002e6	eb 08		 jmp	 SHORT $LN20@cckd_trace
$LN19@cckd_trace:
  002e8	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv173[rsp], 0
$LN20@cckd_trace:
  002f0	b9 01 00 00 00	 mov	 ecx, 1
  002f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002fb	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR trcmsg$[rsp]
  00303	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00308	8b 4c 24 58	 mov	 ecx, DWORD PTR tv167[rsp]
  0030c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00310	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv173[rsp]
  00314	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00318	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173283
  0031f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00324	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173284
  0032b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00330	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00335	41 b9 03 00 00
	00		 mov	 r9d, 3
  0033b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173285
  00342	ba 58 1a 00 00	 mov	 edx, 6744		; 00001a58H
  00347	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173286
  0034e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@cckd_trace:
$LN8@cckd_trace:
$LN1@cckd_trace:
$LN10@cckd_trace:

; 6745 :     }
; 6746 : 
; 6747 : } /* end function cckd_trace */

  00354	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0035c	48 33 cc	 xor	 rcx, rsp
  0035f	e8 00 00 00 00	 call	 __security_check_cookie
  00364	48 81 c4 e8 01
	00 00		 add	 rsp, 488		; 000001e8H
  0036b	c3		 ret	 0
cckd_trace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
msgbuf$ = 64
__$ArrayPad$ = 192
cckd_command_stats PROC

; 6170 : {

$LN3:
  00000	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6171 :     char msgbuf[128];
; 6172 : 
; 6173 :     WRMSG( HHC00347, "I", "cckd stats:" );

  00019	b9 01 00 00 00	 mov	 ecx, 1
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172908
  0002b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172909
  00037	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172910
  00043	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00048	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00053	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172911
  0005a	ba 1d 18 00 00	 mov	 edx, 6173		; 0000181dH
  0005f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172912
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6174 : 
; 6175 :     MSGBUF( msgbuf, "  reads....%10"PRId64" Kbytes...%10"PRId64,

  0006c	48 8b 05 c8 02
	00 00		 mov	 rax, QWORD PTR cckdblk+712
  00073	48 c1 e8 0a	 shr	 rax, 10
  00077	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007c	4c 8b 0d c0 02
	00 00		 mov	 r9, QWORD PTR cckdblk+704
  00083	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172913
  0008a	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0008f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6176 :                     cckdblk.stats_reads, cckdblk.stats_readbytes >> SHIFT_1K );
; 6177 :     WRMSG( HHC00347, "I", msgbuf );

  0009a	b9 01 00 00 00	 mov	 ecx, 1
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  000aa	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172914
  000b6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172915
  000c2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cc	41 b9 03 00 00
	00		 mov	 r9d, 3
  000d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172916
  000d9	ba 21 18 00 00	 mov	 edx, 6177		; 00001821H
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172917
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6178 : 
; 6179 :     MSGBUF( msgbuf, "  writes...%10"PRId64" Kbytes...%10"PRId64,

  000eb	48 8b 05 d8 02
	00 00		 mov	 rax, QWORD PTR cckdblk+728
  000f2	48 c1 e8 0a	 shr	 rax, 10
  000f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fb	4c 8b 0d d0 02
	00 00		 mov	 r9, QWORD PTR cckdblk+720
  00102	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172918
  00109	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0010e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6180 :                     cckdblk.stats_writes, cckdblk.stats_writebytes >> SHIFT_1K );
; 6181 :     WRMSG( HHC00347, "I", msgbuf );

  00119	b9 01 00 00 00	 mov	 ecx, 1
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00124	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00129	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172919
  00135	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0013a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172920
  00141	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00146	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00151	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172921
  00158	ba 25 18 00 00	 mov	 edx, 6181		; 00001825H
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172922
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6182 : 
; 6183 :     MSGBUF( msgbuf, "  readaheads%9"PRId64" misses...%10"PRId64,

  0016a	48 8b 05 88 02
	00 00		 mov	 rax, QWORD PTR cckdblk+648
  00171	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00176	4c 8b 0d 80 02
	00 00		 mov	 r9, QWORD PTR cckdblk+640
  0017d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172923
  00184	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00189	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6184 :                     cckdblk.stats_readaheads, cckdblk.stats_readaheadmisses );
; 6185 :     WRMSG( HHC00347, "I", msgbuf );

  00194	b9 01 00 00 00	 mov	 ecx, 1
  00199	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0019f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  001a4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172924
  001b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172925
  001bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172926
  001d3	ba 29 18 00 00	 mov	 edx, 6185		; 00001829H
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172927
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6186 : 
; 6187 :     MSGBUF( msgbuf, "  switches.%10"PRId64" l2 reads.%10"PRId64" strs wrt.%10"PRId64,

  001e5	48 8b 05 a0 02
	00 00		 mov	 rax, QWORD PTR cckdblk+672
  001ec	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001f1	48 8b 05 b8 02
	00 00		 mov	 rax, QWORD PTR cckdblk+696
  001f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fd	4c 8b 0d 68 02
	00 00		 mov	 r9, QWORD PTR cckdblk+616
  00204	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172928
  0020b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00210	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6188 :                     cckdblk.stats_switches, cckdblk.stats_l2reads, cckdblk.stats_stresswrites );
; 6189 :     WRMSG( HHC00347, "I", msgbuf );

  0021b	b9 01 00 00 00	 mov	 ecx, 1
  00220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00226	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  0022b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172929
  00237	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0023c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172930
  00243	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00248	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0024d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00253	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172931
  0025a	ba 2d 18 00 00	 mov	 edx, 6189		; 0000182dH
  0025f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172932
  00266	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6190 : 
; 6191 :     MSGBUF( msgbuf, "  cachehits%10"PRId64" misses...%10"PRId64,

  0026c	48 8b 05 78 02
	00 00		 mov	 rax, QWORD PTR cckdblk+632
  00273	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00278	4c 8b 0d 70 02
	00 00		 mov	 r9, QWORD PTR cckdblk+624
  0027f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172933
  00286	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0028b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00290	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6192 :                     cckdblk.stats_cachehits, cckdblk.stats_cachemisses );
; 6193 :     WRMSG( HHC00347, "I", msgbuf );

  00296	b9 01 00 00 00	 mov	 ecx, 1
  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  002a6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172934
  002b2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172935
  002be	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c8	41 b9 03 00 00
	00		 mov	 r9d, 3
  002ce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172936
  002d5	ba 31 18 00 00	 mov	 edx, 6193		; 00001831H
  002da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172937
  002e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6194 : 
; 6195 :     MSGBUF( msgbuf, "  l2 hits..%10"PRId64" misses...%10"PRId64,

  002e7	48 8b 05 b0 02
	00 00		 mov	 rax, QWORD PTR cckdblk+688
  002ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f3	4c 8b 0d a8 02
	00 00		 mov	 r9, QWORD PTR cckdblk+680
  002fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172938
  00301	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00306	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  0030b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6196 :                     cckdblk.stats_l2cachehits, cckdblk.stats_l2cachemisses );
; 6197 :     WRMSG( HHC00347, "I", msgbuf );

  00311	b9 01 00 00 00	 mov	 ecx, 1
  00316	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0031c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00321	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172939
  0032d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00332	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172940
  00339	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0033e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00343	41 b9 03 00 00
	00		 mov	 r9d, 3
  00349	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172941
  00350	ba 35 18 00 00	 mov	 edx, 6197		; 00001835H
  00355	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172942
  0035c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6198 : 
; 6199 :     MSGBUF( msgbuf, "  waits............   i/o......%10"PRId64" cache....%10"PRId64,

  00362	48 8b 05 98 02
	00 00		 mov	 rax, QWORD PTR cckdblk+664
  00369	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0036e	4c 8b 0d 90 02
	00 00		 mov	 r9, QWORD PTR cckdblk+656
  00375	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172943
  0037c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00381	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00386	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6200 :                     cckdblk.stats_iowaits, cckdblk.stats_cachewaits );
; 6201 :     WRMSG( HHC00347, "I", msgbuf );

  0038c	b9 01 00 00 00	 mov	 ecx, 1
  00391	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00397	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  0039c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172944
  003a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172945
  003b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003be	41 b9 03 00 00
	00		 mov	 r9d, 3
  003c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172946
  003cb	ba 39 18 00 00	 mov	 edx, 6201		; 00001839H
  003d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172947
  003d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6202 : 
; 6203 :     MSGBUF( msgbuf, "  garbage collector   moves....%10"PRId64" Kbytes...%10"PRId64,

  003dd	48 8b 05 e8 02
	00 00		 mov	 rax, QWORD PTR cckdblk+744
  003e4	48 c1 e8 0a	 shr	 rax, 10
  003e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ed	4c 8b 0d e0 02
	00 00		 mov	 r9, QWORD PTR cckdblk+736
  003f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172948
  003fb	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00400	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00405	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6204 :                     cckdblk.stats_gcolmoves, cckdblk.stats_gcolbytes >> SHIFT_1K );
; 6205 :     WRMSG( HHC00347, "I", msgbuf );

  0040b	b9 01 00 00 00	 mov	 ecx, 1
  00410	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00416	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  0041b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00420	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172949
  00427	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0042c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172950
  00433	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00438	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0043d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00443	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172951
  0044a	ba 3d 18 00 00	 mov	 edx, 6205		; 0000183dH
  0044f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172952
  00456	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6206 : 
; 6207 :     return;
; 6208 : } /* end function cckd_command_stats */

  0045c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00464	48 33 cc	 xor	 rcx, rsp
  00467	e8 00 00 00 00	 call	 __security_check_cookie
  0046c	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00473	c3		 ret	 0
cckd_command_stats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
tv79 = 96
msgbuf$ = 112
__$ArrayPad$ = 368
cckd_command_opts PROC

; 6110 : {

$LN5:
  00000	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6111 :     char msgbuf[256];
; 6112 : 
; 6113 :     MSGBUF( msgbuf, "cckd opts:"

  00019	0f b6 05 1d 00
	00 00		 movzx	 eax, BYTE PTR cckdblk+29
  00020	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00025	75 0a		 jne	 SHORT $LN3@cckd_comma
  00027	c7 44 24 60 ff
	ff ff ff	 mov	 DWORD PTR tv79[rsp], -1
  0002f	eb 0b		 jmp	 SHORT $LN4@cckd_comma
$LN3@cckd_comma:
  00031	0f b6 05 1d 00
	00 00		 movzx	 eax, BYTE PTR cckdblk+29
  00038	89 44 24 60	 mov	 DWORD PTR tv79[rsp], eax
$LN4@cckd_comma:
  0003c	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00042	c1 e8 02	 shr	 eax, 2
  00045	83 e0 01	 and	 eax, 1
  00048	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+16
  0004e	d1 e9		 shr	 ecx, 1
  00050	83 e1 01	 and	 ecx, 1
  00053	8b 15 4c 02 00
	00		 mov	 edx, DWORD PTR cckdblk+588
  00059	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  0005d	8b 15 44 00 00
	00		 mov	 edx, DWORD PTR cckdblk+68
  00063	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  00067	8b 15 5c 02 00
	00		 mov	 edx, DWORD PTR cckdblk+604
  0006d	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  00071	8b 15 48 02 00
	00		 mov	 edx, DWORD PTR cckdblk+584
  00077	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  0007b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0007f	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00083	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR cckdblk+32
  00089	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0008d	44 8b 4c 24 60	 mov	 r9d, DWORD PTR tv79[rsp]
  00092	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172896
  00099	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0009e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6114 : 
; 6115 :         // ***  Please keep these in alphabetical order!  ***
; 6116 : 
; 6117 :         " "   "comp=%d"
; 6118 :         ","   "compparm=%d"
; 6119 :         ","   "debug=%d"
; 6120 :         ","   "dtax=%d"
; 6121 :         ","   "freepend=%d"
; 6122 :         ","   "fsync=%d"
; 6123 :         ","   "gcint=%d"
; 6124 :         ","   "gcmsgs=%d"
; 6125 : 
; 6126 :         , cckdblk.comp == 0xff ? -1 : cckdblk.comp
; 6127 :         , cckdblk.compparm
; 6128 :         , cckdblk.debug
; 6129 :         , cckdblk.dtax
; 6130 :         , cckdblk.freepend
; 6131 :         , cckdblk.fsync
; 6132 :         , cckdblk.gcint
; 6133 :         , cckdblk.gcmsgs
; 6134 :     );
; 6135 :     WRMSG( HHC00346, "I", msgbuf );

  000a9	b9 01 00 00 00	 mov	 ecx, 1
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b4	48 8d 4c 24 70	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  000b9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172897
  000c5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172898
  000d1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000db	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172899
  000e8	ba f7 17 00 00	 mov	 edx, 6135		; 000017f7H
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172900
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6136 : 
; 6137 :     MSGBUF( msgbuf, "          "

  000fa	8b 05 70 00 00
	00		 mov	 eax, DWORD PTR cckdblk+112
  00100	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  00104	8b 05 10 03 00
	00		 mov	 eax, DWORD PTR cckdblk+784
  0010a	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  0010e	8b 05 9c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+156
  00114	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00118	8b 05 98 00 00
	00		 mov	 eax, DWORD PTR cckdblk+152
  0011e	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00122	8b 05 90 00 00
	00		 mov	 eax, DWORD PTR cckdblk+144
  00128	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0012c	8b 05 54 02 00
	00		 mov	 eax, DWORD PTR cckdblk+596
  00132	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00136	8b 05 50 02 00
	00		 mov	 eax, DWORD PTR cckdblk+592
  0013c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00140	8b 05 58 02 00
	00		 mov	 eax, DWORD PTR cckdblk+600
  00146	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0014a	44 8b 0d 48 00
	00 00		 mov	 r9d, DWORD PTR cckdblk+72
  00151	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172901
  00158	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0015d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6138 : 
; 6139 :         // ***  Please keep these in alphabetical order!  ***
; 6140 : 
; 6141 :         " "   "gcparm=%d"
; 6142 :         ","   "linuxnull=%d"
; 6143 :         ","   "nosfd=%d"
; 6144 :         ","   "nostress=%d"
; 6145 :         ","   "ra=%d"
; 6146 :         ","   "raq=%d"
; 6147 :         ","   "rat=%d"
; 6148 :         ","   "trace=%d"
; 6149 :         ","   "wr=%d"
; 6150 : 
; 6151 :         , cckdblk.gcparm
; 6152 :         , cckdblk.linuxnull
; 6153 :         , cckdblk.nosfd
; 6154 :         , cckdblk.nostress
; 6155 :         , cckdblk.ramax
; 6156 :         , cckdblk.ranbr
; 6157 :         , cckdblk.readaheads
; 6158 :         , cckdblk.itracen
; 6159 :         , cckdblk.wrmax
; 6160 :     );
; 6161 :     WRMSG( HHC00346, "I", msgbuf );

  00168	b9 01 00 00 00	 mov	 ecx, 1
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00173	48 8d 4c 24 70	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00178	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0017d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172902
  00184	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172903
  00190	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00195	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019a	41 b9 03 00 00
	00		 mov	 r9d, 3
  001a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172904
  001a7	ba 11 18 00 00	 mov	 edx, 6161		; 00001811H
  001ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172905
  001b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6162 : 
; 6163 :     return;
; 6164 : } /* end function cckd_command_opts */

  001b9	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c1	48 33 cc	 xor	 rcx, rsp
  001c4	e8 00 00 00 00	 call	 __security_check_cookie
  001c9	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  001d0	c3		 ret	 0
cckd_command_opts ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
i$ = 64
tv69 = 72
help$ = 80
__$ArrayPad$ = 288
cckd_command_help PROC

; 6066 : {

$LN6:
  00000	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6067 :     int i;
; 6068 :     char *help[] =

  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172843
  00020	48 89 44 24 50	 mov	 QWORD PTR help$[rsp], rax
  00025	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172845
  0002c	48 89 44 24 58	 mov	 QWORD PTR help$[rsp+8], rax
  00031	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172847
  00038	48 89 44 24 60	 mov	 QWORD PTR help$[rsp+16], rax
  0003d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172849
  00044	48 89 44 24 68	 mov	 QWORD PTR help$[rsp+24], rax
  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172851
  00050	48 89 44 24 70	 mov	 QWORD PTR help$[rsp+32], rax
  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172853
  0005c	48 89 44 24 78	 mov	 QWORD PTR help$[rsp+40], rax
  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172855
  00068	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR help$[rsp+48], rax
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172857
  00077	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR help$[rsp+56], rax
  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172859
  00086	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR help$[rsp+64], rax
  0008e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172861
  00095	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR help$[rsp+72], rax
  0009d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172863
  000a4	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR help$[rsp+80], rax
  000ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172865
  000b3	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR help$[rsp+88], rax
  000bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172867
  000c2	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR help$[rsp+96], rax
  000ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172869
  000d1	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR help$[rsp+104], rax
  000d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172871
  000e0	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR help$[rsp+112], rax
  000e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172873
  000ef	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR help$[rsp+120], rax
  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172875
  000fe	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR help$[rsp+128], rax
  00106	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172877
  0010d	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR help$[rsp+136], rax
  00115	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172879
  0011c	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR help$[rsp+144], rax
  00124	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172881
  0012b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR help$[rsp+152], rax
  00133	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172883
  0013a	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR help$[rsp+160], rax
  00142	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172885
  00149	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR help$[rsp+168], rax
  00151	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172887
  00158	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR help$[rsp+176], rax
  00160	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172889
  00167	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR help$[rsp+184], rax
  0016f	48 c7 84 24 10
	01 00 00 00 00
	00 00		 mov	 QWORD PTR help$[rsp+192], 0

; 6069 :     {
; 6070 :         "Command parameters for cckd:"
; 6071 :         , ""
; 6072 :         , "  help          Display help message"
; 6073 :         , "  stats         Display cckd statistics"
; 6074 :         , "  opts          Display cckd options"
; 6075 :         , ""
; 6076 : 
; 6077 :         //    ***  Please keep these in alphabetical order!  ***
; 6078 : 
; 6079 :         , "  comp=<n>      Override compression                 (-1,0,1,2)"
; 6080 :         , "  compparm=<n>  Override compression parm            (-1 ... 9)"
; 6081 :         , "  debug=<n>     Enable CCW tracing debug messages      (0 or 1)"
; 6082 :         , "  dtax=<n>      Dump cckd trace table at exit          (0 or 1)"
; 6083 :         , "  freepend=<n>  Set free pending cycles              (-1 ... 4)"
; 6084 :         , "  fsync=<n>     Enable fsync                           (0 or 1)"
; 6085 :         , "  gcint=<n>     Set garbage collector interval (sec) ( 0 .. 60)"
; 6086 :         , "  gcmsgs=<n>    Display garbage collector messages     (0 or 1)"
; 6087 :         , "  gcparm=<n>    Set garbage collector parameter      (-8 ... 8)"
; 6088 :         , "  gcstart=<n>   Start garbage collector                (0 or 1)"
; 6089 :         , "  linuxnull=<n> Check for null linux tracks            (0 or 1)"
; 6090 :         , "  nosfd=<n>     Disable stats report at close          (0 or 1)"
; 6091 :         , "  nostress=<n>  Disable stress writes                  (0 or 1)"
; 6092 :         , "  ra=<n>        Set number readahead threads         ( 1 ... 9)"
; 6093 :         , "  raq=<n>       Set readahead queue size             ( 0 .. 16)"
; 6094 :         , "  rat=<n>       Set number tracks to read ahead      ( 0 .. 16)"
; 6095 :         , "  trace=<n>     Set trace table size             (0 ... 200000)"
; 6096 :         , "  wr=<n>        Set number writer threads            ( 1 ... 9)"
; 6097 : 
; 6098 :         , NULL
; 6099 :     };
; 6100 : 
; 6101 :     for (i=0; help[i] != NULL; i++ )

  0017b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00183	eb 0a		 jmp	 SHORT $LN4@cckd_comma
$LN2@cckd_comma:
  00185	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00189	ff c0		 inc	 eax
  0018b	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd_comma:
  0018f	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00194	48 83 7c c4 50
	00		 cmp	 QWORD PTR help$[rsp+rax*8], 0
  0019a	74 62		 je	 SHORT $LN3@cckd_comma

; 6102 :         WRMSG(HHC00345, "I", help[i] );

  0019c	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001a1	48 89 44 24 48	 mov	 QWORD PTR tv69[rsp], rax
  001a6	b9 01 00 00 00	 mov	 ecx, 1
  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001b1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv69[rsp]
  001b6	48 8b 4c cc 50	 mov	 rcx, QWORD PTR help$[rsp+rcx*8]
  001bb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172890
  001c7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172891
  001d3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001dd	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172892
  001ea	ba d6 17 00 00	 mov	 edx, 6102		; 000017d6H
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172893
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  001fc	eb 87		 jmp	 SHORT $LN2@cckd_comma
$LN3@cckd_comma:

; 6103 : 
; 6104 : } /* end function cckd_command_help */

  001fe	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00206	48 33 cc	 xor	 rcx, rsp
  00209	e8 00 00 00 00	 call	 __security_check_cookie
  0020e	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00215	c3		 ret	 0
cckd_command_help ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
val$ = 96
kw$ = 104
opts$ = 112
c$ = 116
tv197 = 120
p$ = 128
itrace$1 = 136
tv199 = 144
rc$ = 148
tv653 = 152
buf$2 = 160
buf$ = 224
__$ArrayPad$ = 480
op$ = 512
cmd$ = 520
cckd_command PROC

; 6222 : {

$LN129:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6223 : char  *kw, *p, c, buf[256];
; 6224 : int   val, opts = 0;

  00022	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR opts$[rsp], 0

; 6225 : int   rc;
; 6226 : 
; 6227 :     /* Display help for null operand */
; 6228 :     if (!op)

  0002a	48 83 bc 24 00
	02 00 00 00	 cmp	 QWORD PTR op$[rsp], 0
  00033	75 33		 jne	 SHORT $LN6@cckd_comma

; 6229 :     {
; 6230 :         if (cmd && memcmp( &cckdblk.id, CCKDBLK_ID, sizeof( cckdblk.id )) == 0)

  00035	83 bc 24 08 02
	00 00 00	 cmp	 DWORD PTR cmd$[rsp], 0
  0003d	74 22		 je	 SHORT $LN7@cckd_comma
  0003f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172984
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk
  00053	e8 00 00 00 00	 call	 memcmp
  00058	85 c0		 test	 eax, eax
  0005a	75 05		 jne	 SHORT $LN7@cckd_comma

; 6231 :             cckd_command_help();

  0005c	e8 00 00 00 00	 call	 cckd_command_help
$LN7@cckd_comma:

; 6232 :         return 0;

  00061	33 c0		 xor	 eax, eax
  00063	e9 c1 11 00 00	 jmp	 $LN1@cckd_comma
$LN6@cckd_comma:

; 6233 :     }
; 6234 : 
; 6235 :     STRLCPY( buf, op );

  00068	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0006e	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR op$[rsp]
  00076	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 6236 :     op = buf;

  00084	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  0008c	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR op$[rsp], rax

; 6237 : 
; 6238 :     /* Initialize the global cckd block if necessary */
; 6239 :     if (memcmp( &cckdblk.id, CCKDBLK_ID, sizeof( cckdblk.id )))

  00094	41 b8 08 00 00
	00		 mov	 r8d, 8
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172986
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk
  000a8	e8 00 00 00 00	 call	 memcmp
  000ad	85 c0		 test	 eax, eax
  000af	74 09		 je	 SHORT $LN8@cckd_comma

; 6240 :         cckd_dasd_init( 0, NULL );

  000b1	33 d2		 xor	 edx, edx
  000b3	33 c9		 xor	 ecx, ecx
  000b5	e8 00 00 00 00	 call	 cckd_dasd_init
$LN8@cckd_comma:
$LN2@cckd_comma:

; 6241 : 
; 6242 :     while (op)

  000ba	48 83 bc 24 00
	02 00 00 00	 cmp	 QWORD PTR op$[rsp], 0
  000c3	0f 84 48 11 00
	00		 je	 $LN3@cckd_comma

; 6243 :     {
; 6244 :         /* Operands are delimited by commas */
; 6245 :         kw = op;

  000c9	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR op$[rsp]
  000d1	48 89 44 24 68	 mov	 QWORD PTR kw$[rsp], rax

; 6246 :         op = strchr( op, ',' );

  000d6	ba 2c 00 00 00	 mov	 edx, 44			; 0000002cH
  000db	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR op$[rsp]
  000e3	e8 00 00 00 00	 call	 strchr
  000e8	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR op$[rsp], rax

; 6247 :         if (op) *op++ = 0;

  000f0	48 83 bc 24 00
	02 00 00 00	 cmp	 QWORD PTR op$[rsp], 0
  000f9	74 1e		 je	 SHORT $LN9@cckd_comma
  000fb	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR op$[rsp]
  00103	c6 00 00	 mov	 BYTE PTR [rax], 0
  00106	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR op$[rsp]
  0010e	48 ff c0	 inc	 rax
  00111	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR op$[rsp], rax
$LN9@cckd_comma:

; 6248 : 
; 6249 :         /* Check for "keyword=value" */
; 6250 :         if ((p = strchr( kw, '=' )))

  00119	ba 3d 00 00 00	 mov	 edx, 61			; 0000003dH
  0011e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  00123	e8 00 00 00 00	 call	 strchr
  00128	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$[rsp], rax
  00130	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR p$[rsp], 0
  00139	74 48		 je	 SHORT $LN10@cckd_comma

; 6251 :         {
; 6252 :             *p++ = 0;

  0013b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00143	c6 00 00	 mov	 BYTE PTR [rax], 0
  00146	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  0014e	48 ff c0	 inc	 rax
  00151	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$[rsp], rax

; 6253 :             c = 0;

  00159	c6 44 24 74 00	 mov	 BYTE PTR c$[rsp], 0

; 6254 :             rc = sscanf( p, "%d%c", &val, &c );

  0015e	4c 8d 4c 24 74	 lea	 r9, QWORD PTR c$[rsp]
  00163	4c 8d 44 24 60	 lea	 r8, QWORD PTR val$[rsp]
  00168	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172989
  0016f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00177	e8 00 00 00 00	 call	 sscanf
  0017c	89 84 24 94 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
$LN10@cckd_comma:

; 6255 :         }
; 6256 : 
; 6257 :         /* If p == NULL, then just keyword syntax (no "=value") */
; 6258 :         if (!p)

  00183	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR p$[rsp], 0
  0018c	0f 85 04 01 00
	00		 jne	 $LN11@cckd_comma

; 6259 :         {
; 6260 :             /* Parse the keyword... */
; 6261 : 
; 6262 :             // Display cckd help
; 6263 :             if (CMD( kw, HELP, 4 ))

  00192	41 b8 04 00 00
	00		 mov	 r8d, 4
  00198	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  0019d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172994
  001a4	e8 00 00 00 00	 call	 strcaseabbrev
  001a9	85 c0		 test	 eax, eax
  001ab	74 1b		 je	 SHORT $LN13@cckd_comma

; 6264 :             {
; 6265 :                 if (!cmd) return 0;

  001ad	83 bc 24 08 02
	00 00 00	 cmp	 DWORD PTR cmd$[rsp], 0
  001b5	75 07		 jne	 SHORT $LN15@cckd_comma
  001b7	33 c0		 xor	 eax, eax
  001b9	e9 6b 10 00 00	 jmp	 $LN1@cckd_comma
$LN15@cckd_comma:

; 6266 :                 cckd_command_help();

  001be	e8 00 00 00 00	 call	 cckd_command_help

; 6267 :             }

  001c3	e9 c9 00 00 00	 jmp	 $LN14@cckd_comma
$LN13@cckd_comma:

; 6268 :             // Display current cckd statistics
; 6269 :             else if (CMD( kw, STATS, 4 ))

  001c8	41 b8 04 00 00
	00		 mov	 r8d, 4
  001ce	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  001d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172998
  001da	e8 00 00 00 00	 call	 strcaseabbrev
  001df	85 c0		 test	 eax, eax
  001e1	74 1b		 je	 SHORT $LN16@cckd_comma

; 6270 :             {
; 6271 :                 if (!cmd) return 0;

  001e3	83 bc 24 08 02
	00 00 00	 cmp	 DWORD PTR cmd$[rsp], 0
  001eb	75 07		 jne	 SHORT $LN18@cckd_comma
  001ed	33 c0		 xor	 eax, eax
  001ef	e9 35 10 00 00	 jmp	 $LN1@cckd_comma
$LN18@cckd_comma:

; 6272 :                 cckd_command_stats();

  001f4	e8 00 00 00 00	 call	 cckd_command_stats

; 6273 :             }

  001f9	e9 93 00 00 00	 jmp	 $LN17@cckd_comma
$LN16@cckd_comma:

; 6274 :             // Display current cckd options
; 6275 :             else if (CMD( kw, OPTS, 4 ))

  001fe	41 b8 04 00 00
	00		 mov	 r8d, 4
  00204	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  00209	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173002
  00210	e8 00 00 00 00	 call	 strcaseabbrev
  00215	85 c0		 test	 eax, eax
  00217	74 18		 je	 SHORT $LN19@cckd_comma

; 6276 :             {
; 6277 :                 if (!cmd) return 0;

  00219	83 bc 24 08 02
	00 00 00	 cmp	 DWORD PTR cmd$[rsp], 0
  00221	75 07		 jne	 SHORT $LN21@cckd_comma
  00223	33 c0		 xor	 eax, eax
  00225	e9 ff 0f 00 00	 jmp	 $LN1@cckd_comma
$LN21@cckd_comma:

; 6278 :                 cckd_command_opts();

  0022a	e8 00 00 00 00	 call	 cckd_command_opts

; 6279 :             }

  0022f	eb 60		 jmp	 SHORT $LN20@cckd_comma
$LN19@cckd_comma:

; 6280 :             else
; 6281 :             {
; 6282 :                 // "CCKD file: invalid cckd keyword: %s"
; 6283 :                 WRMSG( HHC00349, "E", kw );

  00231	b9 01 00 00 00	 mov	 ecx, 1
  00236	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0023c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  00241	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00246	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173004
  0024d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00252	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173005
  00259	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0025e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00263	41 b9 03 00 00
	00		 mov	 r9d, 3
  00269	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173006
  00270	ba 8b 18 00 00	 mov	 edx, 6283		; 0000188bH
  00275	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173007
  0027c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6284 :                 cckd_command_help();

  00282	e8 00 00 00 00	 call	 cckd_command_help

; 6285 :                 return -1;

  00287	b8 ff ff ff ff	 mov	 eax, -1
  0028c	e9 98 0f 00 00	 jmp	 $LN1@cckd_comma
$LN20@cckd_comma:
$LN17@cckd_comma:
$LN14@cckd_comma:

; 6286 :             }
; 6287 :         }

  00291	e9 76 0f 00 00	 jmp	 $LN12@cckd_comma
$LN11@cckd_comma:

; 6288 :         /* If rc != 1 || c != 0 then either a non-numeric "=value"
; 6289 :            was skipped (sscanf %d failed) and/or something follows
; 6290 :            the numeric "=value" (sscanf %c succeeded)
; 6291 :         */
; 6292 :         else if (rc != 1 || c != 0)

  00296	83 bc 24 94 00
	00 00 01	 cmp	 DWORD PTR rc$[rsp], 1
  0029e	75 09		 jne	 SHORT $LN24@cckd_comma
  002a0	0f be 44 24 74	 movsx	 eax, BYTE PTR c$[rsp]
  002a5	85 c0		 test	 eax, eax
  002a7	74 63		 je	 SHORT $LN22@cckd_comma
$LN24@cckd_comma:

; 6293 :         {
; 6294 :             // "CCKD file: invalid numeric value %s"
; 6295 :             WRMSG( HHC00350, "E", p );

  002a9	b9 01 00 00 00	 mov	 ecx, 1
  002ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  002bc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173011
  002c8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173012
  002d4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002de	41 b9 03 00 00
	00		 mov	 r9d, 3
  002e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173013
  002eb	ba 97 18 00 00	 mov	 edx, 6295		; 00001897H
  002f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173014
  002f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6296 :             return -1;

  002fd	b8 ff ff ff ff	 mov	 eax, -1
  00302	e9 22 0f 00 00	 jmp	 $LN1@cckd_comma

; 6297 :         }

  00307	e9 00 0f 00 00	 jmp	 $LN23@cckd_comma
$LN22@cckd_comma:

; 6298 :         /* If rc == 1 && c == 0, then "keyword=value" syntax */
; 6299 :         /* Please keep the below tests in alphabetical order! */
; 6300 : 
; 6301 :         // Compression to be used
; 6302 :         else if (CMD( kw, COMP, 4 ))

  0030c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00312	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  00317	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173017
  0031e	e8 00 00 00 00	 call	 strcaseabbrev
  00323	85 c0		 test	 eax, eax
  00325	0f 84 50 01 00
	00		 je	 $LN25@cckd_comma

; 6303 :         {
; 6304 :             if (val < -1 || (val > 0 && (val & ~cckdblk.comps)))

  0032b	83 7c 24 60 ff	 cmp	 DWORD PTR val$[rsp], -1
  00330	7c 1c		 jl	 SHORT $LN29@cckd_comma
  00332	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00337	7e 7d		 jle	 SHORT $LN27@cckd_comma
  00339	0f b6 05 1c 00
	00 00		 movzx	 eax, BYTE PTR cckdblk+28
  00340	f7 d0		 not	 eax
  00342	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00346	23 c8		 and	 ecx, eax
  00348	8b c1		 mov	 eax, ecx
  0034a	85 c0		 test	 eax, eax
  0034c	74 68		 je	 SHORT $LN27@cckd_comma
$LN29@cckd_comma:

; 6305 :             {
; 6306 :                 // "CCKD file: value %d invalid for %s"
; 6307 :                 WRMSG( HHC00348, "E", val, kw );

  0034e	b9 01 00 00 00	 mov	 ecx, 1
  00353	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00359	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  0035e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00363	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00367	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0036b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173021
  00372	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00377	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173022
  0037e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00383	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00388	41 b9 03 00 00
	00		 mov	 r9d, 3
  0038e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173023
  00395	ba a3 18 00 00	 mov	 edx, 6307		; 000018a3H
  0039a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173024
  003a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6308 :                 return -1;

  003a7	b8 ff ff ff ff	 mov	 eax, -1
  003ac	e9 78 0e 00 00	 jmp	 $LN1@cckd_comma

; 6309 :             }

  003b1	e9 c0 00 00 00	 jmp	 $LN28@cckd_comma
$LN27@cckd_comma:

; 6310 :             else switch (val)

  003b6	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  003ba	89 44 24 78	 mov	 DWORD PTR tv197[rsp], eax
  003be	83 7c 24 78 ff	 cmp	 DWORD PTR tv197[rsp], -1
  003c3	74 17		 je	 SHORT $LN30@cckd_comma
  003c5	83 7c 24 78 00	 cmp	 DWORD PTR tv197[rsp], 0
  003ca	74 10		 je	 SHORT $LN31@cckd_comma
  003cc	83 7c 24 78 01	 cmp	 DWORD PTR tv197[rsp], 1
  003d1	74 09		 je	 SHORT $LN32@cckd_comma
  003d3	83 7c 24 78 02	 cmp	 DWORD PTR tv197[rsp], 2
  003d8	74 02		 je	 SHORT $LN33@cckd_comma
  003da	eb 37		 jmp	 SHORT $LN34@cckd_comma
$LN30@cckd_comma:
$LN31@cckd_comma:
$LN32@cckd_comma:
$LN33@cckd_comma:

; 6311 :             {
; 6312 :             case -1:
; 6313 :             case CCKD_COMPRESS_NONE:
; 6314 :             case CCKD_COMPRESS_ZLIB:
; 6315 :             case CCKD_COMPRESS_BZIP2:
; 6316 :                 cckdblk.comp = val < 0 ? 0xff : val;

  003dc	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  003e1	7d 0d		 jge	 SHORT $LN127@cckd_comma
  003e3	c7 84 24 90 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv199[rsp], 255 ; 000000ffH
  003ee	eb 0b		 jmp	 SHORT $LN128@cckd_comma
$LN127@cckd_comma:
  003f0	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  003f4	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv199[rsp], eax
$LN128@cckd_comma:
  003fb	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR tv199[rsp]
  00403	88 05 1d 00 00
	00		 mov	 BYTE PTR cckdblk+29, al

; 6317 :                 opts = 1;

  00409	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1

; 6318 :                 break;

  00411	eb 63		 jmp	 SHORT $LN4@cckd_comma
$LN34@cckd_comma:

; 6319 :             default: /* unsupported algorithm */
; 6320 :                 // "CCKD file: value %d invalid for %s"
; 6321 :                 WRMSG( HHC00348, "E", val, kw );

  00413	b9 01 00 00 00	 mov	 ecx, 1
  00418	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0041e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  00423	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00428	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  0042c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00430	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173030
  00437	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0043c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173031
  00443	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00448	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0044d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00453	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173032
  0045a	ba b1 18 00 00	 mov	 edx, 6321		; 000018b1H
  0045f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173033
  00466	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6322 :                 return -1;

  0046c	b8 ff ff ff ff	 mov	 eax, -1
  00471	e9 b3 0d 00 00	 jmp	 $LN1@cckd_comma
$LN4@cckd_comma:
$LN28@cckd_comma:

; 6323 :             }
; 6324 :         }

  00476	e9 91 0d 00 00	 jmp	 $LN26@cckd_comma
$LN25@cckd_comma:

; 6325 :         // Compression parameter to be used
; 6326 :         else if (CMD( kw, COMPPARM, 8 ))

  0047b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00481	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  00486	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173036
  0048d	e8 00 00 00 00	 call	 strcaseabbrev
  00492	85 c0		 test	 eax, eax
  00494	0f 84 8a 00 00
	00		 je	 $LN35@cckd_comma

; 6327 :         {
; 6328 :             if (val < -1 || val > 9)

  0049a	83 7c 24 60 ff	 cmp	 DWORD PTR val$[rsp], -1
  0049f	7c 07		 jl	 SHORT $LN39@cckd_comma
  004a1	83 7c 24 60 09	 cmp	 DWORD PTR val$[rsp], 9
  004a6	7e 65		 jle	 SHORT $LN37@cckd_comma
$LN39@cckd_comma:

; 6329 :             {
; 6330 :                 // "CCKD file: value %d invalid for %s"
; 6331 :                 WRMSG( HHC00348, "E", val, kw );

  004a8	b9 01 00 00 00	 mov	 ecx, 1
  004ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004b3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  004b8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004bd	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  004c1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173040
  004cc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173041
  004d8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004dd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004e2	41 b9 03 00 00
	00		 mov	 r9d, 3
  004e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173042
  004ef	ba bb 18 00 00	 mov	 edx, 6331		; 000018bbH
  004f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173043
  004fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6332 :                 return -1;

  00501	b8 ff ff ff ff	 mov	 eax, -1
  00506	e9 1e 0d 00 00	 jmp	 $LN1@cckd_comma

; 6333 :             }

  0050b	eb 12		 jmp	 SHORT $LN38@cckd_comma
$LN37@cckd_comma:

; 6334 :             else
; 6335 :             {
; 6336 :                 cckdblk.compparm = val;

  0050d	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  00511	89 05 20 00 00
	00		 mov	 DWORD PTR cckdblk+32, eax

; 6337 :                 opts = 1;

  00517	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN38@cckd_comma:

; 6338 :             }
; 6339 :         }

  0051f	e9 e8 0c 00 00	 jmp	 $LN36@cckd_comma
$LN35@cckd_comma:

; 6340 :         // Turn CCW tracing debug messages on or off
; 6341 :         else if (CMD( kw, DEBUG, 5 ))

  00524	41 b8 05 00 00
	00		 mov	 r8d, 5
  0052a	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  0052f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173046
  00536	e8 00 00 00 00	 call	 strcaseabbrev
  0053b	85 c0		 test	 eax, eax
  0053d	0f 84 9c 00 00
	00		 je	 $LN40@cckd_comma

; 6342 :         {
; 6343 :             if (val < 0 || val > 1)

  00543	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00548	7c 07		 jl	 SHORT $LN44@cckd_comma
  0054a	83 7c 24 60 01	 cmp	 DWORD PTR val$[rsp], 1
  0054f	7e 65		 jle	 SHORT $LN42@cckd_comma
$LN44@cckd_comma:

; 6344 :             {
; 6345 :                 // "CCKD file: value %d invalid for %s"
; 6346 :                 WRMSG( HHC00348, "E", val, kw );

  00551	b9 01 00 00 00	 mov	 ecx, 1
  00556	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0055c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  00561	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00566	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  0056a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0056e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173050
  00575	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0057a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173051
  00581	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00586	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0058b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00591	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173052
  00598	ba ca 18 00 00	 mov	 edx, 6346		; 000018caH
  0059d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173053
  005a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6347 :                 return -1;

  005aa	b8 ff ff ff ff	 mov	 eax, -1
  005af	e9 75 0c 00 00	 jmp	 $LN1@cckd_comma

; 6348 :             }

  005b4	eb 24		 jmp	 SHORT $LN43@cckd_comma
$LN42@cckd_comma:

; 6349 :             else
; 6350 :             {
; 6351 :                 cckdblk.debug = val;

  005b6	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  005ba	83 e0 01	 and	 eax, 1
  005bd	d1 e0		 shl	 eax, 1
  005bf	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+16
  005c5	83 e1 fd	 and	 ecx, -3			; fffffffdH
  005c8	0b c8		 or	 ecx, eax
  005ca	8b c1		 mov	 eax, ecx
  005cc	89 05 10 00 00
	00		 mov	 DWORD PTR cckdblk+16, eax

; 6352 :                 opts = 1;

  005d2	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN43@cckd_comma:

; 6353 :             }
; 6354 :         }

  005da	e9 2d 0c 00 00	 jmp	 $LN41@cckd_comma
$LN40@cckd_comma:

; 6355 :         // Dump Table At Exit
; 6356 :         else if (CMD( kw, DTAX, 4 ))

  005df	41 b8 04 00 00
	00		 mov	 r8d, 4
  005e5	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  005ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173056
  005f1	e8 00 00 00 00	 call	 strcaseabbrev
  005f6	85 c0		 test	 eax, eax
  005f8	0f 84 9d 00 00
	00		 je	 $LN45@cckd_comma

; 6357 :         {
; 6358 :             if (val < 0 || val > 1)

  005fe	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00603	7c 07		 jl	 SHORT $LN49@cckd_comma
  00605	83 7c 24 60 01	 cmp	 DWORD PTR val$[rsp], 1
  0060a	7e 65		 jle	 SHORT $LN47@cckd_comma
$LN49@cckd_comma:

; 6359 :             {
; 6360 :                 // "CCKD file: value %d invalid for %s"
; 6361 :                 WRMSG( HHC00348, "E", val, kw );

  0060c	b9 01 00 00 00	 mov	 ecx, 1
  00611	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00617	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  0061c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00621	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00625	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00629	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173060
  00630	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00635	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173061
  0063c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00641	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00646	41 b9 03 00 00
	00		 mov	 r9d, 3
  0064c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173062
  00653	ba d9 18 00 00	 mov	 edx, 6361		; 000018d9H
  00658	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173063
  0065f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6362 :                 return -1;

  00665	b8 ff ff ff ff	 mov	 eax, -1
  0066a	e9 ba 0b 00 00	 jmp	 $LN1@cckd_comma

; 6363 :             }

  0066f	eb 25		 jmp	 SHORT $LN48@cckd_comma
$LN47@cckd_comma:

; 6364 :             else
; 6365 :             {
; 6366 :                 cckdblk.dtax = val;

  00671	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  00675	83 e0 01	 and	 eax, 1
  00678	c1 e0 02	 shl	 eax, 2
  0067b	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+16
  00681	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00684	0b c8		 or	 ecx, eax
  00686	8b c1		 mov	 eax, ecx
  00688	89 05 10 00 00
	00		 mov	 DWORD PTR cckdblk+16, eax

; 6367 :                 opts = 1;

  0068e	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN48@cckd_comma:

; 6368 :             }
; 6369 :         }

  00696	e9 71 0b 00 00	 jmp	 $LN46@cckd_comma
$LN45@cckd_comma:

; 6370 :         // Set the free pending value
; 6371 :         else if (CMD( kw, FREEPEND, 8 ))

  0069b	41 b8 08 00 00
	00		 mov	 r8d, 8
  006a1	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  006a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173066
  006ad	e8 00 00 00 00	 call	 strcaseabbrev
  006b2	85 c0		 test	 eax, eax
  006b4	0f 84 8a 00 00
	00		 je	 $LN50@cckd_comma

; 6372 :         {
; 6373 :             if (val < -1 || val > CCKD_MAX_FREEPEND)

  006ba	83 7c 24 60 ff	 cmp	 DWORD PTR val$[rsp], -1
  006bf	7c 07		 jl	 SHORT $LN54@cckd_comma
  006c1	83 7c 24 60 04	 cmp	 DWORD PTR val$[rsp], 4
  006c6	7e 65		 jle	 SHORT $LN52@cckd_comma
$LN54@cckd_comma:

; 6374 :             {
; 6375 :                 // "CCKD file: value %d invalid for %s"
; 6376 :                 WRMSG( HHC00348, "E", val, kw );

  006c8	b9 01 00 00 00	 mov	 ecx, 1
  006cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006d3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  006d8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  006dd	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  006e1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173070
  006ec	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173071
  006f8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006fd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00702	41 b9 03 00 00
	00		 mov	 r9d, 3
  00708	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173072
  0070f	ba e8 18 00 00	 mov	 edx, 6376		; 000018e8H
  00714	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173073
  0071b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6377 :                 return -1;

  00721	b8 ff ff ff ff	 mov	 eax, -1
  00726	e9 fe 0a 00 00	 jmp	 $LN1@cckd_comma

; 6378 :             }

  0072b	eb 12		 jmp	 SHORT $LN53@cckd_comma
$LN52@cckd_comma:

; 6379 :             else
; 6380 :             {
; 6381 :                 cckdblk.freepend = val;

  0072d	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  00731	89 05 48 02 00
	00		 mov	 DWORD PTR cckdblk+584, eax

; 6382 :                 opts = 1;

  00737	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN53@cckd_comma:

; 6383 :             }
; 6384 :         }

  0073f	e9 c8 0a 00 00	 jmp	 $LN51@cckd_comma
$LN50@cckd_comma:

; 6385 :         // Turn fsync on or off
; 6386 :         else if (CMD( kw, FSYNC, 5 ))

  00744	41 b8 05 00 00
	00		 mov	 r8d, 5
  0074a	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  0074f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173076
  00756	e8 00 00 00 00	 call	 strcaseabbrev
  0075b	85 c0		 test	 eax, eax
  0075d	0f 84 8a 00 00
	00		 je	 $LN55@cckd_comma

; 6387 :         {
; 6388 :             if (val < 0 || val > 1)

  00763	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00768	7c 07		 jl	 SHORT $LN59@cckd_comma
  0076a	83 7c 24 60 01	 cmp	 DWORD PTR val$[rsp], 1
  0076f	7e 65		 jle	 SHORT $LN57@cckd_comma
$LN59@cckd_comma:

; 6389 :             {
; 6390 :                 // "CCKD file: value %d invalid for %s"
; 6391 :                 WRMSG( HHC00348, "E", val, kw );

  00771	b9 01 00 00 00	 mov	 ecx, 1
  00776	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0077c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  00781	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00786	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  0078a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0078e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173080
  00795	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0079a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173081
  007a1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007ab	41 b9 03 00 00
	00		 mov	 r9d, 3
  007b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173082
  007b8	ba f7 18 00 00	 mov	 edx, 6391		; 000018f7H
  007bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173083
  007c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6392 :                 return -1;

  007ca	b8 ff ff ff ff	 mov	 eax, -1
  007cf	e9 55 0a 00 00	 jmp	 $LN1@cckd_comma

; 6393 :             }

  007d4	eb 12		 jmp	 SHORT $LN58@cckd_comma
$LN57@cckd_comma:

; 6394 :             else
; 6395 :             {
; 6396 :                 cckdblk.fsync = val;

  007d6	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  007da	89 05 5c 02 00
	00		 mov	 DWORD PTR cckdblk+604, eax

; 6397 :                 opts = 1;

  007e0	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN58@cckd_comma:

; 6398 :             }
; 6399 :         }

  007e8	e9 1f 0a 00 00	 jmp	 $LN56@cckd_comma
$LN55@cckd_comma:

; 6400 :         // Garbage collection interval
; 6401 :         else if (CMD( kw, GCINT, 5 ))

  007ed	41 b8 05 00 00
	00		 mov	 r8d, 5
  007f3	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  007f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173086
  007ff	e8 00 00 00 00	 call	 strcaseabbrev
  00804	85 c0		 test	 eax, eax
  00806	0f 84 8a 00 00
	00		 je	 $LN60@cckd_comma

; 6402 :         {
; 6403 :             if (val < CCKD_MIN_GCINT || val > CCKD_MAX_GCINT)

  0080c	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00811	7c 07		 jl	 SHORT $LN64@cckd_comma
  00813	83 7c 24 60 3c	 cmp	 DWORD PTR val$[rsp], 60	; 0000003cH
  00818	7e 65		 jle	 SHORT $LN62@cckd_comma
$LN64@cckd_comma:

; 6404 :             {
; 6405 :                 // "CCKD file: value %d invalid for %s"
; 6406 :                 WRMSG( HHC00348, "E", val, kw );

  0081a	b9 01 00 00 00	 mov	 ecx, 1
  0081f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00825	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  0082a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0082f	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00833	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00837	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173090
  0083e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00843	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173091
  0084a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0084f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00854	41 b9 03 00 00
	00		 mov	 r9d, 3
  0085a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173092
  00861	ba 06 19 00 00	 mov	 edx, 6406		; 00001906H
  00866	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173093
  0086d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6407 :                 return -1;

  00873	b8 ff ff ff ff	 mov	 eax, -1
  00878	e9 ac 09 00 00	 jmp	 $LN1@cckd_comma

; 6408 :             }

  0087d	eb 12		 jmp	 SHORT $LN63@cckd_comma
$LN62@cckd_comma:

; 6409 :             else
; 6410 :             {
; 6411 :                 cckdblk.gcint = val;

  0087f	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  00883	89 05 44 00 00
	00		 mov	 DWORD PTR cckdblk+68, eax

; 6412 :                 opts = 1;

  00889	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN63@cckd_comma:

; 6413 :             }
; 6414 :         }

  00891	e9 76 09 00 00	 jmp	 $LN61@cckd_comma
$LN60@cckd_comma:

; 6415 :         // Garbage collector messages
; 6416 :         else if (CMD( kw, GCMSGS, 6 ))

  00896	41 b8 06 00 00
	00		 mov	 r8d, 6
  0089c	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  008a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173096
  008a8	e8 00 00 00 00	 call	 strcaseabbrev
  008ad	85 c0		 test	 eax, eax
  008af	0f 84 8a 00 00
	00		 je	 $LN65@cckd_comma

; 6417 :         {
; 6418 :             if (val < 0 || val > 1)

  008b5	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  008ba	7c 07		 jl	 SHORT $LN69@cckd_comma
  008bc	83 7c 24 60 01	 cmp	 DWORD PTR val$[rsp], 1
  008c1	7e 65		 jle	 SHORT $LN67@cckd_comma
$LN69@cckd_comma:

; 6419 :             {
; 6420 :                 // "CCKD file: value %d invalid for %s"
; 6421 :                 WRMSG( HHC00348, "E", val, kw );

  008c3	b9 01 00 00 00	 mov	 ecx, 1
  008c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008ce	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  008d3	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  008d8	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  008dc	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173100
  008e7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173101
  008f3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008fd	41 b9 03 00 00
	00		 mov	 r9d, 3
  00903	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173102
  0090a	ba 15 19 00 00	 mov	 edx, 6421		; 00001915H
  0090f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173103
  00916	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6422 :                 return -1;

  0091c	b8 ff ff ff ff	 mov	 eax, -1
  00921	e9 03 09 00 00	 jmp	 $LN1@cckd_comma

; 6423 :             }

  00926	eb 12		 jmp	 SHORT $LN68@cckd_comma
$LN67@cckd_comma:

; 6424 :             else
; 6425 :             {
; 6426 :                 cckdblk.gcmsgs = val;

  00928	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  0092c	89 05 4c 02 00
	00		 mov	 DWORD PTR cckdblk+588, eax

; 6427 :                 opts = 1;

  00932	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN68@cckd_comma:

; 6428 :             }
; 6429 :         }

  0093a	e9 cd 08 00 00	 jmp	 $LN66@cckd_comma
$LN65@cckd_comma:

; 6430 :         // Garbage collection parameter
; 6431 :         else if (CMD( kw, GCPARM, 6 ))

  0093f	41 b8 06 00 00
	00		 mov	 r8d, 6
  00945	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  0094a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173106
  00951	e8 00 00 00 00	 call	 strcaseabbrev
  00956	85 c0		 test	 eax, eax
  00958	0f 84 8a 00 00
	00		 je	 $LN70@cckd_comma

; 6432 :         {
; 6433 :             if (val < CCKD_MIN_GCPARM || val > CCKD_MAX_GCPARM)

  0095e	83 7c 24 60 f8	 cmp	 DWORD PTR val$[rsp], -8
  00963	7c 07		 jl	 SHORT $LN74@cckd_comma
  00965	83 7c 24 60 08	 cmp	 DWORD PTR val$[rsp], 8
  0096a	7e 65		 jle	 SHORT $LN72@cckd_comma
$LN74@cckd_comma:

; 6434 :             {
; 6435 :                 // "CCKD file: value %d invalid for %s"
; 6436 :                 WRMSG( HHC00348, "E", val, kw );

  0096c	b9 01 00 00 00	 mov	 ecx, 1
  00971	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00977	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  0097c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00981	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00985	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00989	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173110
  00990	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00995	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173111
  0099c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009a1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009a6	41 b9 03 00 00
	00		 mov	 r9d, 3
  009ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173112
  009b3	ba 24 19 00 00	 mov	 edx, 6436		; 00001924H
  009b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173113
  009bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6437 :                 return -1;

  009c5	b8 ff ff ff ff	 mov	 eax, -1
  009ca	e9 5a 08 00 00	 jmp	 $LN1@cckd_comma

; 6438 :             }

  009cf	eb 12		 jmp	 SHORT $LN73@cckd_comma
$LN72@cckd_comma:

; 6439 :             else
; 6440 :             {
; 6441 :                 cckdblk.gcparm = val;

  009d1	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  009d5	89 05 48 00 00
	00		 mov	 DWORD PTR cckdblk+72, eax

; 6442 :                 opts = 1;

  009db	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN73@cckd_comma:

; 6443 :             }
; 6444 :         }

  009e3	e9 24 08 00 00	 jmp	 $LN71@cckd_comma
$LN70@cckd_comma:

; 6445 :         // Start garbage collector
; 6446 :         else if (CMD( kw, GCSTART, 7 ))

  009e8	41 b8 07 00 00
	00		 mov	 r8d, 7
  009ee	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  009f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173116
  009fa	e8 00 00 00 00	 call	 strcaseabbrev
  009ff	85 c0		 test	 eax, eax
  00a01	0f 84 89 00 00
	00		 je	 $LN75@cckd_comma

; 6447 :         {
; 6448 :             if (val < 0 || val > 1)

  00a07	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00a0c	7c 07		 jl	 SHORT $LN79@cckd_comma
  00a0e	83 7c 24 60 01	 cmp	 DWORD PTR val$[rsp], 1
  00a13	7e 65		 jle	 SHORT $LN77@cckd_comma
$LN79@cckd_comma:

; 6449 :             {
; 6450 :                 // "CCKD file: value %d invalid for %s"
; 6451 :                 WRMSG( HHC00348, "E", val, kw );

  00a15	b9 01 00 00 00	 mov	 ecx, 1
  00a1a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a20	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  00a25	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00a2a	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00a2e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a32	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173120
  00a39	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173121
  00a45	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a4a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a4f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a55	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173122
  00a5c	ba 33 19 00 00	 mov	 edx, 6451		; 00001933H
  00a61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173123
  00a68	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6452 :                 return -1;

  00a6e	b8 ff ff ff ff	 mov	 eax, -1
  00a73	e9 b1 07 00 00	 jmp	 $LN1@cckd_comma

; 6453 :             }

  00a78	eb 11		 jmp	 SHORT $LN78@cckd_comma
$LN77@cckd_comma:

; 6454 :             else if (val == 1)

  00a7a	83 7c 24 60 01	 cmp	 DWORD PTR val$[rsp], 1
  00a7f	75 0a		 jne	 SHORT $LN80@cckd_comma

; 6455 :             {
; 6456 :                 cckd_gcstart();

  00a81	e8 00 00 00 00	 call	 cckd_gcstart

; 6457 :                 cckd64_gcstart();

  00a86	e8 00 00 00 00	 call	 cckd64_gcstart
$LN80@cckd_comma:
$LN78@cckd_comma:

; 6458 :             }
; 6459 :         }

  00a8b	e9 7c 07 00 00	 jmp	 $LN76@cckd_comma
$LN75@cckd_comma:

; 6460 :         // Check for null linux tracks
; 6461 :         else if (CMD( kw, LINUXNULL, 5 ))

  00a90	41 b8 05 00 00
	00		 mov	 r8d, 5
  00a96	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  00a9b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173127
  00aa2	e8 00 00 00 00	 call	 strcaseabbrev
  00aa7	85 c0		 test	 eax, eax
  00aa9	0f 84 8a 00 00
	00		 je	 $LN81@cckd_comma

; 6462 :         {
; 6463 :             if (val < 0 || val > 1)

  00aaf	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00ab4	7c 07		 jl	 SHORT $LN85@cckd_comma
  00ab6	83 7c 24 60 01	 cmp	 DWORD PTR val$[rsp], 1
  00abb	7e 65		 jle	 SHORT $LN83@cckd_comma
$LN85@cckd_comma:

; 6464 :             {
; 6465 :                 // "CCKD file: value %d invalid for %s"
; 6466 :                 WRMSG( HHC00348, "E", val, kw );

  00abd	b9 01 00 00 00	 mov	 ecx, 1
  00ac2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00ac8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  00acd	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00ad2	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00ad6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ada	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173131
  00ae1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ae6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173132
  00aed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00af2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00af7	41 b9 03 00 00
	00		 mov	 r9d, 3
  00afd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173133
  00b04	ba 42 19 00 00	 mov	 edx, 6466		; 00001942H
  00b09	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173134
  00b10	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6467 :                 return -1;

  00b16	b8 ff ff ff ff	 mov	 eax, -1
  00b1b	e9 09 07 00 00	 jmp	 $LN1@cckd_comma

; 6468 :             }

  00b20	eb 12		 jmp	 SHORT $LN84@cckd_comma
$LN83@cckd_comma:

; 6469 :             else
; 6470 :             {
; 6471 :                 cckdblk.linuxnull = val;

  00b22	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  00b26	89 05 58 02 00
	00		 mov	 DWORD PTR cckdblk+600, eax

; 6472 :                 opts = 1;

  00b2c	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN84@cckd_comma:

; 6473 :             }
; 6474 :         }

  00b34	e9 d3 06 00 00	 jmp	 $LN82@cckd_comma
$LN81@cckd_comma:

; 6475 :         // Turn off stats report at close
; 6476 :         else if (CMD( kw, NOSFD, 5 ))

  00b39	41 b8 05 00 00
	00		 mov	 r8d, 5
  00b3f	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  00b44	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173137
  00b4b	e8 00 00 00 00	 call	 strcaseabbrev
  00b50	85 c0		 test	 eax, eax
  00b52	0f 84 8a 00 00
	00		 je	 $LN86@cckd_comma

; 6477 :         {
; 6478 :             if (val < 0 || val > 1)

  00b58	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00b5d	7c 07		 jl	 SHORT $LN90@cckd_comma
  00b5f	83 7c 24 60 01	 cmp	 DWORD PTR val$[rsp], 1
  00b64	7e 65		 jle	 SHORT $LN88@cckd_comma
$LN90@cckd_comma:

; 6479 :             {
; 6480 :                 // "CCKD file: value %d invalid for %s"
; 6481 :                 WRMSG( HHC00348, "E", val, kw );

  00b66	b9 01 00 00 00	 mov	 ecx, 1
  00b6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b71	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  00b76	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00b7b	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00b7f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00b83	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173141
  00b8a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b8f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173142
  00b96	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b9b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ba0	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ba6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173143
  00bad	ba 51 19 00 00	 mov	 edx, 6481		; 00001951H
  00bb2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173144
  00bb9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6482 :                 return -1;

  00bbf	b8 ff ff ff ff	 mov	 eax, -1
  00bc4	e9 60 06 00 00	 jmp	 $LN1@cckd_comma

; 6483 :             }

  00bc9	eb 12		 jmp	 SHORT $LN89@cckd_comma
$LN88@cckd_comma:

; 6484 :             else
; 6485 :             {
; 6486 :                 cckdblk.nosfd = val;

  00bcb	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  00bcf	89 05 50 02 00
	00		 mov	 DWORD PTR cckdblk+592, eax

; 6487 :                 opts = 1;

  00bd5	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN89@cckd_comma:

; 6488 :             }
; 6489 :         }

  00bdd	e9 2a 06 00 00	 jmp	 $LN87@cckd_comma
$LN86@cckd_comma:

; 6490 :         // Turn stress writes on or off
; 6491 :         else if (CMD( kw, NOSTRESS, 8 ))

  00be2	41 b8 08 00 00
	00		 mov	 r8d, 8
  00be8	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  00bed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173147
  00bf4	e8 00 00 00 00	 call	 strcaseabbrev
  00bf9	85 c0		 test	 eax, eax
  00bfb	0f 84 8a 00 00
	00		 je	 $LN91@cckd_comma

; 6492 :         {
; 6493 :             if (val < 0 || val > 1)

  00c01	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00c06	7c 07		 jl	 SHORT $LN95@cckd_comma
  00c08	83 7c 24 60 01	 cmp	 DWORD PTR val$[rsp], 1
  00c0d	7e 65		 jle	 SHORT $LN93@cckd_comma
$LN95@cckd_comma:

; 6494 :             {
; 6495 :                 // "CCKD file: value %d invalid for %s"
; 6496 :                 WRMSG( HHC00348, "E", val, kw );

  00c0f	b9 01 00 00 00	 mov	 ecx, 1
  00c14	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c1a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  00c1f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00c24	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00c28	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c2c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173151
  00c33	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c38	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173152
  00c3f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c44	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c49	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c4f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173153
  00c56	ba 60 19 00 00	 mov	 edx, 6496		; 00001960H
  00c5b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173154
  00c62	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6497 :                 return -1;

  00c68	b8 ff ff ff ff	 mov	 eax, -1
  00c6d	e9 b7 05 00 00	 jmp	 $LN1@cckd_comma

; 6498 :             }

  00c72	eb 12		 jmp	 SHORT $LN94@cckd_comma
$LN93@cckd_comma:

; 6499 :             else
; 6500 :             {
; 6501 :                 cckdblk.nostress = val;

  00c74	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  00c78	89 05 54 02 00
	00		 mov	 DWORD PTR cckdblk+596, eax

; 6502 :                 opts = 1;

  00c7e	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN94@cckd_comma:

; 6503 :             }
; 6504 :         }

  00c86	e9 81 05 00 00	 jmp	 $LN92@cckd_comma
$LN91@cckd_comma:

; 6505 :         // Number readahead threads
; 6506 :         else if (CMD( kw, RA, 2 ))

  00c8b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00c91	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  00c96	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173157
  00c9d	e8 00 00 00 00	 call	 strcaseabbrev
  00ca2	85 c0		 test	 eax, eax
  00ca4	0f 84 8a 00 00
	00		 je	 $LN96@cckd_comma

; 6507 :         {
; 6508 :             if (val < CCKD_MIN_RA || val > CCKD_MAX_RA)

  00caa	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00caf	7c 07		 jl	 SHORT $LN100@cckd_comma
  00cb1	83 7c 24 60 09	 cmp	 DWORD PTR val$[rsp], 9
  00cb6	7e 65		 jle	 SHORT $LN98@cckd_comma
$LN100@cckd_comma:

; 6509 :             {
; 6510 :                 // "CCKD file: value %d invalid for %s"
; 6511 :                 WRMSG( HHC00348, "E", val, kw );

  00cb8	b9 01 00 00 00	 mov	 ecx, 1
  00cbd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cc3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  00cc8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00ccd	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00cd1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00cd5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173161
  00cdc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ce1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173162
  00ce8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ced	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cf2	41 b9 03 00 00
	00		 mov	 r9d, 3
  00cf8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173163
  00cff	ba 6f 19 00 00	 mov	 edx, 6511		; 0000196fH
  00d04	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173164
  00d0b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6512 :                 return -1;

  00d11	b8 ff ff ff ff	 mov	 eax, -1
  00d16	e9 0e 05 00 00	 jmp	 $LN1@cckd_comma

; 6513 :             }

  00d1b	eb 12		 jmp	 SHORT $LN99@cckd_comma
$LN98@cckd_comma:

; 6514 :             else
; 6515 :             {
; 6516 :                 cckdblk.ramax = val;

  00d1d	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  00d21	89 05 90 00 00
	00		 mov	 DWORD PTR cckdblk+144, eax

; 6517 :                 opts = 1;

  00d27	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN99@cckd_comma:

; 6518 :             }
; 6519 :         }

  00d2f	e9 d8 04 00 00	 jmp	 $LN97@cckd_comma
$LN96@cckd_comma:

; 6520 :         // Readahead queue size
; 6521 :         else if (CMD( kw, RAQ, 3 ))

  00d34	41 b8 03 00 00
	00		 mov	 r8d, 3
  00d3a	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  00d3f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173167
  00d46	e8 00 00 00 00	 call	 strcaseabbrev
  00d4b	85 c0		 test	 eax, eax
  00d4d	0f 84 8a 00 00
	00		 je	 $LN101@cckd_comma

; 6522 :         {
; 6523 :             if (val < 0 || val > CCKD_MAX_RA_SIZE)

  00d53	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00d58	7c 07		 jl	 SHORT $LN105@cckd_comma
  00d5a	83 7c 24 60 10	 cmp	 DWORD PTR val$[rsp], 16
  00d5f	7e 65		 jle	 SHORT $LN103@cckd_comma
$LN105@cckd_comma:

; 6524 :             {
; 6525 :                 // "CCKD file: value %d invalid for %s"
; 6526 :                 WRMSG( HHC00348, "E", val, kw );

  00d61	b9 01 00 00 00	 mov	 ecx, 1
  00d66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d6c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  00d71	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00d76	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00d7a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00d7e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173171
  00d85	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d8a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173172
  00d91	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d96	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d9b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00da1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173173
  00da8	ba 7e 19 00 00	 mov	 edx, 6526		; 0000197eH
  00dad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173174
  00db4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6527 :                 return -1;

  00dba	b8 ff ff ff ff	 mov	 eax, -1
  00dbf	e9 65 04 00 00	 jmp	 $LN1@cckd_comma

; 6528 :             }

  00dc4	eb 12		 jmp	 SHORT $LN104@cckd_comma
$LN103@cckd_comma:

; 6529 :             else
; 6530 :             {
; 6531 :                 cckdblk.ranbr = val;

  00dc6	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  00dca	89 05 98 00 00
	00		 mov	 DWORD PTR cckdblk+152, eax

; 6532 :                 opts = 1;

  00dd0	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN104@cckd_comma:

; 6533 :             }
; 6534 :         }

  00dd8	e9 2f 04 00 00	 jmp	 $LN102@cckd_comma
$LN101@cckd_comma:

; 6535 :         // Number of tracks to readahead
; 6536 :         else if (CMD( kw, RAT, 3 ))

  00ddd	41 b8 03 00 00
	00		 mov	 r8d, 3
  00de3	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  00de8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173177
  00def	e8 00 00 00 00	 call	 strcaseabbrev
  00df4	85 c0		 test	 eax, eax
  00df6	0f 84 8a 00 00
	00		 je	 $LN106@cckd_comma

; 6537 :         {
; 6538 :             if (val < 0 || val > CCKD_MAX_RA_SIZE)

  00dfc	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00e01	7c 07		 jl	 SHORT $LN110@cckd_comma
  00e03	83 7c 24 60 10	 cmp	 DWORD PTR val$[rsp], 16
  00e08	7e 65		 jle	 SHORT $LN108@cckd_comma
$LN110@cckd_comma:

; 6539 :             {
; 6540 :                 // "CCKD file: value %d invalid for %s"
; 6541 :                 WRMSG( HHC00348, "E", val, kw );

  00e0a	b9 01 00 00 00	 mov	 ecx, 1
  00e0f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e15	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  00e1a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00e1f	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00e23	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e27	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173181
  00e2e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e33	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173182
  00e3a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e3f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e44	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e4a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173183
  00e51	ba 8d 19 00 00	 mov	 edx, 6541		; 0000198dH
  00e56	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173184
  00e5d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6542 :                 return -1;

  00e63	b8 ff ff ff ff	 mov	 eax, -1
  00e68	e9 bc 03 00 00	 jmp	 $LN1@cckd_comma

; 6543 :             }

  00e6d	eb 12		 jmp	 SHORT $LN109@cckd_comma
$LN108@cckd_comma:

; 6544 :             else
; 6545 :             {
; 6546 :                 cckdblk.readaheads = val;

  00e6f	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  00e73	89 05 9c 00 00
	00		 mov	 DWORD PTR cckdblk+156, eax

; 6547 :                 opts = 1;

  00e79	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN109@cckd_comma:

; 6548 :             }
; 6549 :         }

  00e81	e9 86 03 00 00	 jmp	 $LN107@cckd_comma
$LN106@cckd_comma:

; 6550 :         // Number of trace table entries
; 6551 :         else if (CMD( kw, TRACE, 5 ))

  00e86	41 b8 05 00 00
	00		 mov	 r8d, 5
  00e8c	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  00e91	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173187
  00e98	e8 00 00 00 00	 call	 strcaseabbrev
  00e9d	85 c0		 test	 eax, eax
  00e9f	0f 84 4e 02 00
	00		 je	 $LN111@cckd_comma

; 6552 :         {
; 6553 :             if (val < 0 || val > CCKD_MAX_NUM_TRACE)

  00ea5	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00eaa	7c 0a		 jl	 SHORT $LN115@cckd_comma
  00eac	81 7c 24 60 00
	00 04 00	 cmp	 DWORD PTR val$[rsp], 262144 ; 00040000H
  00eb4	7e 68		 jle	 SHORT $LN113@cckd_comma
$LN115@cckd_comma:

; 6554 :             {
; 6555 :                 // "CCKD file: value %d invalid for %s"
; 6556 :                 WRMSG( HHC00348, "E", val, kw );

  00eb6	b9 01 00 00 00	 mov	 ecx, 1
  00ebb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00ec1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  00ec6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00ecb	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  00ecf	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ed3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173191
  00eda	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00edf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173192
  00ee6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00eeb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ef0	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ef6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173193
  00efd	ba 9c 19 00 00	 mov	 edx, 6556		; 0000199cH
  00f02	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173194
  00f09	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6557 :                 return -1;

  00f0f	b8 ff ff ff ff	 mov	 eax, -1
  00f14	e9 10 03 00 00	 jmp	 $LN1@cckd_comma

; 6558 :             }

  00f19	e9 d0 01 00 00	 jmp	 $LN114@cckd_comma
$LN113@cckd_comma:

; 6559 :             else
; 6560 :             {
; 6561 :                 OBTAIN_TRACE_LOCK();

  00f1e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173195
  00f25	48 8d 0d f0 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+752
  00f2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6562 :                 {
; 6563 :                     CCKD_ITRACE* itrace = cckdblk.itrace;

  00f32	48 8b 05 f8 02
	00 00		 mov	 rax, QWORD PTR cckdblk+760
  00f39	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR itrace$1[rsp], rax

; 6564 : 
; 6565 :                     /* Tell others there is no table anymore */
; 6566 :                     cckdblk.itracen = 0;

  00f41	c7 05 10 03 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+784, 0

; 6567 :                     cckdblk.itracec = 0;

  00f4b	c7 05 14 03 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+788, 0

; 6568 :                     cckdblk.itrace  = NULL;

  00f55	48 c7 05 f8 02
	00 00 00 00 00
	00		 mov	 QWORD PTR cckdblk+760, 0

; 6569 :                     cckdblk.itracep = NULL;

  00f60	48 c7 05 00 03
	00 00 00 00 00
	00		 mov	 QWORD PTR cckdblk+768, 0

; 6570 :                     cckdblk.itracex = NULL;

  00f6b	48 c7 05 08 03
	00 00 00 00 00
	00		 mov	 QWORD PTR cckdblk+776, 0

; 6571 : 
; 6572 :                     /* Discard existing trace table */
; 6573 :                     free( itrace );

  00f76	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR itrace$1[rsp]
  00f7e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6574 : 
; 6575 :                     /* Allocate new table (if requested) */
; 6576 :                     if (val > 0)

  00f84	83 7c 24 60 00	 cmp	 DWORD PTR val$[rsp], 0
  00f89	0f 8e e4 00 00
	00		 jle	 $LN116@cckd_comma

; 6577 :                     {
; 6578 :                         if (!(itrace = calloc( val, sizeof( CCKD_ITRACE ))))

  00f8f	48 63 44 24 60	 movsxd	 rax, DWORD PTR val$[rsp]
  00f94	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00f99	48 8b c8	 mov	 rcx, rax
  00f9c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00fa2	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR itrace$1[rsp], rax
  00faa	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR itrace$1[rsp], 0
  00fb3	0f 85 b8 00 00
	00		 jne	 $LN118@cckd_comma

; 6579 :                         {
; 6580 :                             char buf[64];
; 6581 :                             MSGBUF( buf, "calloc( %d, %d )",

  00fb9	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR [rsp+32], 256	; 00000100H
  00fc1	44 8b 4c 24 60	 mov	 r9d, DWORD PTR val$[rsp]
  00fc6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173199
  00fcd	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00fd2	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00fda	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6582 :                                 val, (int) sizeof( CCKD_ITRACE ));
; 6583 :                             // "%1d:%04X CCKD file: error in function %s: %s"
; 6584 :                             WRMSG( HHC00303, "E", 0,0, buf, strerror( errno ));

  00fe0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00fe6	8b 08		 mov	 ecx, DWORD PTR [rax]
  00fe8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00fee	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv653[rsp], rax
  00ff6	b9 01 00 00 00	 mov	 ecx, 1
  00ffb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01001	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv653[rsp]
  01009	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0100e	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  01016	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0101b	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  01024	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0102d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173200
  01034	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173201
  01040	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01045	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0104a	41 b9 03 00 00
	00		 mov	 r9d, 3
  01050	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173202
  01057	ba b8 19 00 00	 mov	 edx, 6584		; 000019b8H
  0105c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173203
  01063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6585 :                             val = 0;

  01069	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR val$[rsp], 0
$LN118@cckd_comma:

; 6586 :                         }
; 6587 :                     }

  01071	eb 0c		 jmp	 SHORT $LN117@cckd_comma
$LN116@cckd_comma:

; 6588 :                     else
; 6589 :                         itrace = NULL;

  01073	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR itrace$1[rsp], 0
$LN117@cckd_comma:

; 6590 : 
; 6591 :                     /* Update global variables */
; 6592 :                     cckdblk.itrace  = itrace;

  0107f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR itrace$1[rsp]
  01087	48 89 05 f8 02
	00 00		 mov	 QWORD PTR cckdblk+760, rax

; 6593 :                     cckdblk.itracep = itrace;

  0108e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR itrace$1[rsp]
  01096	48 89 05 00 03
	00 00		 mov	 QWORD PTR cckdblk+768, rax

; 6594 :                     cckdblk.itracex = itrace + val;

  0109d	48 63 44 24 60	 movsxd	 rax, DWORD PTR val$[rsp]
  010a2	48 69 c0 00 01
	00 00		 imul	 rax, rax, 256		; 00000100H
  010a9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR itrace$1[rsp]
  010b1	48 03 c8	 add	 rcx, rax
  010b4	48 8b c1	 mov	 rax, rcx
  010b7	48 89 05 08 03
	00 00		 mov	 QWORD PTR cckdblk+776, rax

; 6595 :                     cckdblk.itracen = val;

  010be	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  010c2	89 05 10 03 00
	00		 mov	 DWORD PTR cckdblk+784, eax

; 6596 :                     cckdblk.itracec = 0;

  010c8	c7 05 14 03 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+788, 0

; 6597 :                     opts = 1;

  010d2	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1

; 6598 :                 }
; 6599 :                 RELEASE_TRACE_LOCK();

  010da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173204
  010e1	48 8d 0d f0 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+752
  010e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN114@cckd_comma:

; 6600 :             }
; 6601 :         }

  010ee	e9 19 01 00 00	 jmp	 $LN112@cckd_comma
$LN111@cckd_comma:

; 6602 :         // Number writer threads
; 6603 :         else if (CMD( kw, WR, 2 ))

  010f3	41 b8 02 00 00
	00		 mov	 r8d, 2
  010f9	48 8b 54 24 68	 mov	 rdx, QWORD PTR kw$[rsp]
  010fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173207
  01105	e8 00 00 00 00	 call	 strcaseabbrev
  0110a	85 c0		 test	 eax, eax
  0110c	0f 84 87 00 00
	00		 je	 $LN119@cckd_comma

; 6604 :         {
; 6605 :             if (val < CCKD_MIN_WRITER || val > CCKD_MAX_WRITER)

  01112	83 7c 24 60 01	 cmp	 DWORD PTR val$[rsp], 1
  01117	7c 07		 jl	 SHORT $LN123@cckd_comma
  01119	83 7c 24 60 09	 cmp	 DWORD PTR val$[rsp], 9
  0111e	7e 65		 jle	 SHORT $LN121@cckd_comma
$LN123@cckd_comma:

; 6606 :             {
; 6607 :                 // "CCKD file: value %d invalid for %s"
; 6608 :                 WRMSG( HHC00348, "E", val, kw );

  01120	b9 01 00 00 00	 mov	 ecx, 1
  01125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0112b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  01130	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01135	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  01139	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0113d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173211
  01144	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173212
  01150	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01155	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0115a	41 b9 03 00 00
	00		 mov	 r9d, 3
  01160	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173213
  01167	ba d0 19 00 00	 mov	 edx, 6608		; 000019d0H
  0116c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173214
  01173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6609 :                 return -1;

  01179	b8 ff ff ff ff	 mov	 eax, -1
  0117e	e9 a6 00 00 00	 jmp	 $LN1@cckd_comma

; 6610 :             }

  01183	eb 12		 jmp	 SHORT $LN122@cckd_comma
$LN121@cckd_comma:

; 6611 :             else
; 6612 :             {
; 6613 :                 cckdblk.wrmax = val;

  01185	8b 44 24 60	 mov	 eax, DWORD PTR val$[rsp]
  01189	89 05 70 00 00
	00		 mov	 DWORD PTR cckdblk+112, eax

; 6614 :                 opts = 1;

  0118f	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR opts$[rsp], 1
$LN122@cckd_comma:

; 6615 :             }
; 6616 :         }

  01197	eb 73		 jmp	 SHORT $LN120@cckd_comma
$LN119@cckd_comma:

; 6617 :         // Unknown option
; 6618 :         else
; 6619 :         {
; 6620 :             // "CCKD file: invalid cckd keyword: %s"
; 6621 :             WRMSG( HHC00349, "E", kw );

  01199	b9 01 00 00 00	 mov	 ecx, 1
  0119e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR kw$[rsp]
  011a9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  011ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173215
  011b5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  011ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173216
  011c1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  011c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011cb	41 b9 03 00 00
	00		 mov	 r9d, 3
  011d1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173217
  011d8	ba dd 19 00 00	 mov	 edx, 6621		; 000019ddH
  011dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173218
  011e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6622 :             if (!cmd) return -1;

  011ea	83 bc 24 08 02
	00 00 00	 cmp	 DWORD PTR cmd$[rsp], 0
  011f2	75 07		 jne	 SHORT $LN124@cckd_comma
  011f4	b8 ff ff ff ff	 mov	 eax, -1
  011f9	eb 2e		 jmp	 SHORT $LN1@cckd_comma
$LN124@cckd_comma:

; 6623 :             cckd_command_help();

  011fb	e8 00 00 00 00	 call	 cckd_command_help

; 6624 :             op = NULL;

  01200	48 c7 84 24 00
	02 00 00 00 00
	00 00		 mov	 QWORD PTR op$[rsp], 0
$LN120@cckd_comma:
$LN112@cckd_comma:
$LN107@cckd_comma:
$LN102@cckd_comma:
$LN97@cckd_comma:
$LN92@cckd_comma:
$LN87@cckd_comma:
$LN82@cckd_comma:
$LN76@cckd_comma:
$LN71@cckd_comma:
$LN66@cckd_comma:
$LN61@cckd_comma:
$LN56@cckd_comma:
$LN51@cckd_comma:
$LN46@cckd_comma:
$LN41@cckd_comma:
$LN36@cckd_comma:
$LN26@cckd_comma:
$LN23@cckd_comma:
$LN12@cckd_comma:

; 6625 :         }
; 6626 :     }

  0120c	e9 a9 ee ff ff	 jmp	 $LN2@cckd_comma
$LN3@cckd_comma:

; 6627 :     /* end while (op) */
; 6628 : 
; 6629 :     if (cmd && opts)

  01211	83 bc 24 08 02
	00 00 00	 cmp	 DWORD PTR cmd$[rsp], 0
  01219	74 0c		 je	 SHORT $LN125@cckd_comma
  0121b	83 7c 24 70 00	 cmp	 DWORD PTR opts$[rsp], 0
  01220	74 05		 je	 SHORT $LN125@cckd_comma

; 6630 :         cckd_command_opts();

  01222	e8 00 00 00 00	 call	 cckd_command_opts
$LN125@cckd_comma:

; 6631 : 
; 6632 :     return 0;

  01227	33 c0		 xor	 eax, eax
$LN1@cckd_comma:

; 6633 : } /* end function cckd_command */

  01229	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01231	48 33 cc	 xor	 rcx, rsp
  01234	e8 00 00 00 00	 call	 __security_check_cookie
  01239	48 81 c4 f8 01
	00 00		 add	 rsp, 504		; 000001f8H
  01240	c3		 ret	 0
cckd_command ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 64
to$ = 72
from$ = 80
len$ = 88
parm$ = 96
cckd_compress_bzip2 PROC

; 6034 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6035 : #if defined( CCKD_BZIP2 )
; 6036 : unsigned int newlen;
; 6037 : int rc;
; 6038 : BYTE *buf;
; 6039 : 
; 6040 :     UNREFERENCED(dev);
; 6041 :     buf = *to;
; 6042 :     from[0] = CCKD_COMPRESS_NONE;
; 6043 :     memcpy (buf, from, CKD_TRKHDR_SIZE);
; 6044 :     buf[0] = CCKD_COMPRESS_BZIP2;
; 6045 :     newlen = 65535 - CKD_TRKHDR_SIZE;
; 6046 :     rc = BZ2_bzBuffToBuffCompress (
; 6047 :                     (void *)&buf[CKD_TRKHDR_SIZE], &newlen,
; 6048 :                     (void *)&from[CKD_TRKHDR_SIZE], len - CKD_TRKHDR_SIZE,
; 6049 :                     parm >= 1 && parm <= 9 ? parm : 5, 0, 0);
; 6050 :     newlen += CKD_TRKHDR_SIZE;
; 6051 :     if (rc != BZ_OK || newlen >= (unsigned int)len)
; 6052 :     {
; 6053 :         *to = from;
; 6054 :         newlen = len;
; 6055 :     }
; 6056 :     return newlen;
; 6057 : #else
; 6058 :     return cckd_compress_zlib (dev, to, from, len, parm);

  00018	8b 44 24 60	 mov	 eax, DWORD PTR parm$[rsp]
  0001c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00020	44 8b 4c 24 58	 mov	 r9d, DWORD PTR len$[rsp]
  00025	4c 8b 44 24 50	 mov	 r8, QWORD PTR from$[rsp]
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR to$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00034	e8 00 00 00 00	 call	 cckd_compress_zlib

; 6059 : #endif
; 6060 : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
cckd_compress_bzip2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 64
to$ = 72
from$ = 80
len$ = 88
parm$ = 96
cckd_compress_zlib PROC

; 6001 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6002 : #if defined( HAVE_ZLIB )
; 6003 : unsigned long newlen;
; 6004 : int rc;
; 6005 : BYTE *buf;
; 6006 : 
; 6007 :     UNREFERENCED(dev);
; 6008 :     buf = *to;
; 6009 :     from[0] = CCKD_COMPRESS_NONE;
; 6010 :     memcpy (buf, from, CKD_TRKHDR_SIZE);
; 6011 :     buf[0] = CCKD_COMPRESS_ZLIB;
; 6012 :     newlen = 65535 - CKD_TRKHDR_SIZE;
; 6013 :     rc = compress2 (&buf[CKD_TRKHDR_SIZE], &newlen,
; 6014 :                     &from[CKD_TRKHDR_SIZE], len - CKD_TRKHDR_SIZE,
; 6015 :                     parm);
; 6016 :     newlen += CKD_TRKHDR_SIZE;
; 6017 :     if (rc != Z_OK || (int)newlen >= len)
; 6018 :     {
; 6019 :         *to = from;
; 6020 :         newlen = len;
; 6021 :     }
; 6022 :     return (int)newlen;
; 6023 : #else
; 6024 : 
; 6025 : #if defined( CCKD_BZIP2 )
; 6026 :     return cckd_compress_bzip2 (dev, to, from, len, parm);
; 6027 : #else
; 6028 :     return cckd_compress_none (dev, to, from, len, parm);

  00018	8b 44 24 60	 mov	 eax, DWORD PTR parm$[rsp]
  0001c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00020	44 8b 4c 24 58	 mov	 r9d, DWORD PTR len$[rsp]
  00025	4c 8b 44 24 50	 mov	 r8, QWORD PTR from$[rsp]
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR to$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00034	e8 00 00 00 00	 call	 cckd_compress_none

; 6029 : #endif
; 6030 : 
; 6031 : #endif
; 6032 : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
cckd_compress_zlib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 8
to$ = 16
from$ = 24
len$ = 32
parm$ = 40
cckd_compress_none PROC

; 5989 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@cckd_compr:

; 5990 :     UNREFERENCED(dev);

  00014	33 c0		 xor	 eax, eax
  00016	85 c0		 test	 eax, eax
  00018	75 fa		 jne	 SHORT $LN4@cckd_compr
$LN7@cckd_compr:

; 5991 :     UNREFERENCED(parm);

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN7@cckd_compr

; 5992 :     *to = from;

  00020	48 8b 44 24 10	 mov	 rax, QWORD PTR to$[rsp]
  00025	48 8b 4c 24 18	 mov	 rcx, QWORD PTR from$[rsp]
  0002a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 5993 :     from[0] = CCKD_COMPRESS_NONE;

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 00	 imul	 rax, rax, 0
  00036	48 8b 4c 24 18	 mov	 rcx, QWORD PTR from$[rsp]
  0003b	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 5994 :     return len;

  0003f	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]

; 5995 : }

  00043	c3		 ret	 0
cckd_compress_none ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
newlen$ = 48
tv64 = 52
dev$ = 80
to$ = 88
from$ = 96
len$ = 104
comp$ = 112
parm$ = 120
cckd_compress PROC

; 5965 : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5966 : int newlen;
; 5967 : 
; 5968 :     switch (comp) {

  00018	8b 44 24 70	 mov	 eax, DWORD PTR comp$[rsp]
  0001c	89 44 24 34	 mov	 DWORD PTR tv64[rsp], eax
  00020	83 7c 24 34 00	 cmp	 DWORD PTR tv64[rsp], 0
  00025	74 10		 je	 SHORT $LN4@cckd_compr
  00027	83 7c 24 34 01	 cmp	 DWORD PTR tv64[rsp], 1
  0002c	74 30		 je	 SHORT $LN5@cckd_compr
  0002e	83 7c 24 34 02	 cmp	 DWORD PTR tv64[rsp], 2
  00033	74 50		 je	 SHORT $LN6@cckd_compr
  00035	eb 75		 jmp	 SHORT $LN7@cckd_compr
$LN4@cckd_compr:

; 5969 :     case CCKD_COMPRESS_NONE:
; 5970 :         newlen = cckd_compress_none (dev, to, from, len, parm);

  00037	8b 44 24 78	 mov	 eax, DWORD PTR parm$[rsp]
  0003b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0003f	44 8b 4c 24 68	 mov	 r9d, DWORD PTR len$[rsp]
  00044	4c 8b 44 24 60	 mov	 r8, QWORD PTR from$[rsp]
  00049	48 8b 54 24 58	 mov	 rdx, QWORD PTR to$[rsp]
  0004e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00053	e8 00 00 00 00	 call	 cckd_compress_none
  00058	89 44 24 30	 mov	 DWORD PTR newlen$[rsp], eax

; 5971 :         break;

  0005c	eb 73		 jmp	 SHORT $LN2@cckd_compr
$LN5@cckd_compr:

; 5972 :     case CCKD_COMPRESS_ZLIB:
; 5973 :         newlen = cckd_compress_zlib (dev, to, from, len, parm);

  0005e	8b 44 24 78	 mov	 eax, DWORD PTR parm$[rsp]
  00062	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00066	44 8b 4c 24 68	 mov	 r9d, DWORD PTR len$[rsp]
  0006b	4c 8b 44 24 60	 mov	 r8, QWORD PTR from$[rsp]
  00070	48 8b 54 24 58	 mov	 rdx, QWORD PTR to$[rsp]
  00075	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0007a	e8 00 00 00 00	 call	 cckd_compress_zlib
  0007f	89 44 24 30	 mov	 DWORD PTR newlen$[rsp], eax

; 5974 :         break;

  00083	eb 4c		 jmp	 SHORT $LN2@cckd_compr
$LN6@cckd_compr:

; 5975 :     case CCKD_COMPRESS_BZIP2:
; 5976 :         newlen = cckd_compress_bzip2 (dev, to, from, len, parm);

  00085	8b 44 24 78	 mov	 eax, DWORD PTR parm$[rsp]
  00089	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0008d	44 8b 4c 24 68	 mov	 r9d, DWORD PTR len$[rsp]
  00092	4c 8b 44 24 60	 mov	 r8, QWORD PTR from$[rsp]
  00097	48 8b 54 24 58	 mov	 rdx, QWORD PTR to$[rsp]
  0009c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000a1	e8 00 00 00 00	 call	 cckd_compress_bzip2
  000a6	89 44 24 30	 mov	 DWORD PTR newlen$[rsp], eax

; 5977 :         break;

  000aa	eb 25		 jmp	 SHORT $LN2@cckd_compr
$LN7@cckd_compr:

; 5978 :     default:
; 5979 :         newlen = cckd_compress_bzip2 (dev, to, from, len, parm);

  000ac	8b 44 24 78	 mov	 eax, DWORD PTR parm$[rsp]
  000b0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b4	44 8b 4c 24 68	 mov	 r9d, DWORD PTR len$[rsp]
  000b9	4c 8b 44 24 60	 mov	 r8, QWORD PTR from$[rsp]
  000be	48 8b 54 24 58	 mov	 rdx, QWORD PTR to$[rsp]
  000c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000c8	e8 00 00 00 00	 call	 cckd_compress_bzip2
  000cd	89 44 24 30	 mov	 DWORD PTR newlen$[rsp], eax
$LN2@cckd_compr:

; 5980 :         break;
; 5981 :     }
; 5982 :     return newlen;

  000d1	8b 44 24 30	 mov	 eax, DWORD PTR newlen$[rsp]

; 5983 : }

  000d5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d9	c3		 ret	 0
cckd_compress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 8
to$ = 16
from$ = 24
len$ = 32
maxlen$ = 40
cckd_uncompress_bzip2 PROC

; 5927 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@cckd_uncom:

; 5928 : #if defined( CCKD_BZIP2 )
; 5929 : unsigned int newlen;
; 5930 : int rc;
; 5931 : 
; 5932 :     UNREFERENCED(dev);
; 5933 :     memcpy (to, from, CKD_TRKHDR_SIZE);
; 5934 :     newlen = maxlen - CKD_TRKHDR_SIZE;
; 5935 :     rc = BZ2_bzBuffToBuffDecompress (
; 5936 :                 (void *)&to[CKD_TRKHDR_SIZE], &newlen,
; 5937 :                 (void *)&from[CKD_TRKHDR_SIZE], len - CKD_TRKHDR_SIZE,
; 5938 :                 0, 0);
; 5939 :     if (rc == BZ_OK)
; 5940 :     {
; 5941 :         newlen += CKD_TRKHDR_SIZE;
; 5942 :         to[0] = 0;
; 5943 :     }
; 5944 :     else
; 5945 :         newlen = -1;
; 5946 : 
; 5947 :     CCKD_TRACE( "uncompress bz2 newlen %d rc %d",newlen,rc);
; 5948 : 
; 5949 :     return (int)newlen;
; 5950 : #else
; 5951 :     UNREFERENCED(dev);

  00014	33 c0		 xor	 eax, eax
  00016	85 c0		 test	 eax, eax
  00018	75 fa		 jne	 SHORT $LN4@cckd_uncom
$LN7@cckd_uncom:

; 5952 :     UNREFERENCED(to);

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN7@cckd_uncom
$LN10@cckd_uncom:

; 5953 :     UNREFERENCED(from);

  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	75 fa		 jne	 SHORT $LN10@cckd_uncom
$LN13@cckd_uncom:

; 5954 :     UNREFERENCED(len);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN13@cckd_uncom
$LN16@cckd_uncom:

; 5955 :     UNREFERENCED(maxlen);

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN16@cckd_uncom

; 5956 :     return -1;

  00032	b8 ff ff ff ff	 mov	 eax, -1

; 5957 : #endif
; 5958 : }

  00037	c3		 ret	 0
cckd_uncompress_bzip2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 8
to$ = 16
from$ = 24
len$ = 32
maxlen$ = 40
cckd_uncompress_zlib PROC

; 5892 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@cckd_uncom:

; 5893 : #if defined( HAVE_ZLIB )
; 5894 : unsigned long newlen;
; 5895 : int rc;
; 5896 : 
; 5897 :     UNREFERENCED(dev);
; 5898 :     memcpy (to, from, CKD_TRKHDR_SIZE);
; 5899 :     newlen = maxlen - CKD_TRKHDR_SIZE;
; 5900 :     rc = uncompress(&to[CKD_TRKHDR_SIZE], &newlen,
; 5901 :                 &from[CKD_TRKHDR_SIZE], len - CKD_TRKHDR_SIZE);
; 5902 :     if (rc == Z_OK)
; 5903 :     {
; 5904 :         newlen += CKD_TRKHDR_SIZE;
; 5905 :         to[0] = 0;
; 5906 :     }
; 5907 :     else
; 5908 :         newlen = -1;
; 5909 : 
; 5910 :     CCKD_TRACE( "uncompress zlib newlen %d rc %d",(int)newlen,rc);
; 5911 : 
; 5912 :     return (int)newlen;
; 5913 : #else
; 5914 :     UNREFERENCED(dev);

  00014	33 c0		 xor	 eax, eax
  00016	85 c0		 test	 eax, eax
  00018	75 fa		 jne	 SHORT $LN4@cckd_uncom
$LN7@cckd_uncom:

; 5915 :     UNREFERENCED(to);

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN7@cckd_uncom
$LN10@cckd_uncom:

; 5916 :     UNREFERENCED(from);

  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	75 fa		 jne	 SHORT $LN10@cckd_uncom
$LN13@cckd_uncom:

; 5917 :     UNREFERENCED(len);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN13@cckd_uncom
$LN16@cckd_uncom:

; 5918 :     UNREFERENCED(maxlen);

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN16@cckd_uncom

; 5919 :     return -1;

  00032	b8 ff ff ff ff	 mov	 eax, -1

; 5920 : #endif
; 5921 : }

  00037	c3		 ret	 0
cckd_uncompress_zlib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
comp$ = 144
newlen$ = 148
cckd$ = 152
to$ = 160
tv95 = 168
tv245 = 172
tv251 = 176
tv281 = 180
tv287 = 184
tv216 = 188
tv220 = 192
tv224 = 196
tv228 = 200
tv232 = 204
tv235 = 208
tv298 = 216
tv267 = 224
tv271 = 232
dev$ = 256
from$ = 264
len$ = 272
maxlen$ = 280
trk$ = 288
cckd_uncompress PROC

; 5784 : {

$LN27:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 5785 : CCKD_EXT       *cckd;
; 5786 : BYTE           *to = NULL;                /* Uncompressed buffer     */

  0001b	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR to$[rsp], 0

; 5787 : int             newlen;                   /* Uncompressed length     */
; 5788 : BYTE            comp;                     /* Compression type        */
; 5789 : 
; 5790 :     cckd = dev->cckd_ext;

  00027	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00036	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 5791 : 
; 5792 :     CCKD_TRACE( "uncompress comp %d len %d maxlen %d trk %d",

  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	48 6b c0 00	 imul	 rax, rax, 0
  00047	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  0004f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00053	83 e0 03	 and	 eax, 3
  00056	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  0005d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00061	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR maxlen$[rsp]
  00068	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0006c	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00073	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00077	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0007b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172697
  00082	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0008a	ba a1 16 00 00	 mov	 edx, 5793		; 000016a1H
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172698
  00096	e8 00 00 00 00	 call	 cckd_trace

; 5793 :                 from[0] & CCKD_COMPRESS_MASK, len, maxlen, trk);
; 5794 : 
; 5795 :     /* Extract compression type */
; 5796 :     comp = (from[0] & CCKD_COMPRESS_MASK);

  0009b	b8 01 00 00 00	 mov	 eax, 1
  000a0	48 6b c0 00	 imul	 rax, rax, 0
  000a4	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  000ac	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b0	83 e0 03	 and	 eax, 3
  000b3	88 84 24 90 00
	00 00		 mov	 BYTE PTR comp$[rsp], al

; 5797 : 
; 5798 :     /* Get a buffer to uncompress into */
; 5799 :     if (comp != CCKD_COMPRESS_NONE && cckd->newbuf == NULL)

  000ba	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  000c2	85 c0		 test	 eax, eax
  000c4	74 50		 je	 SHORT $LN4@cckd_uncom
  000c6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  000ce	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000d3	75 41		 jne	 SHORT $LN4@cckd_uncom

; 5800 :     {
; 5801 :         cckd->newbuf = cckd_malloc (dev, "newbuf", maxlen);

  000d5	48 63 84 24 18
	01 00 00	 movsxd	 rax, DWORD PTR maxlen$[rsp]
  000dd	4c 8b c0	 mov	 r8, rax
  000e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172700
  000e7	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000ef	e8 00 00 00 00	 call	 cckd_malloc
  000f4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  000fc	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 5802 :         if (cckd->newbuf == NULL)

  00100	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00108	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0010d	75 07		 jne	 SHORT $LN5@cckd_uncom

; 5803 :             return NULL;

  0010f	33 c0		 xor	 eax, eax
  00111	e9 c3 06 00 00	 jmp	 $LN1@cckd_uncom
$LN5@cckd_uncom:
$LN4@cckd_uncom:

; 5804 :     }
; 5805 : 
; 5806 :     /* Uncompress the track image */
; 5807 :     switch (comp) {

  00116	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  0011e	88 84 24 a8 00
	00 00		 mov	 BYTE PTR tv95[rsp], al
  00125	80 bc 24 a8 00
	00 00 00	 cmp	 BYTE PTR tv95[rsp], 0
  0012d	74 1d		 je	 SHORT $LN6@cckd_uncom
  0012f	80 bc 24 a8 00
	00 00 01	 cmp	 BYTE PTR tv95[rsp], 1
  00137	74 44		 je	 SHORT $LN7@cckd_uncom
  00139	80 bc 24 a8 00
	00 00 02	 cmp	 BYTE PTR tv95[rsp], 2
  00141	0f 84 83 00 00
	00		 je	 $LN8@cckd_uncom
  00147	e9 cb 00 00 00	 jmp	 $LN9@cckd_uncom
$LN6@cckd_uncom:

; 5808 : 
; 5809 :     case CCKD_COMPRESS_NONE:
; 5810 :         newlen = cckd_trklen (dev, from);

  0014c	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR from$[rsp]
  00154	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0015c	e8 00 00 00 00	 call	 cckd_trklen
  00161	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 5811 :         to = from;

  00168	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR from$[rsp]
  00170	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR to$[rsp], rax

; 5812 :         break;

  00178	e9 a5 00 00 00	 jmp	 $LN2@cckd_uncom
$LN7@cckd_uncom:

; 5813 :     case CCKD_COMPRESS_ZLIB:
; 5814 :         to = cckd->newbuf;

  0017d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00185	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00189	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR to$[rsp], rax

; 5815 :         newlen = cckd_uncompress_zlib (dev, to, from, len, maxlen);

  00191	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR maxlen$[rsp]
  00198	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0019c	44 8b 8c 24 10
	01 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  001a4	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR from$[rsp]
  001ac	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  001b4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001bc	e8 00 00 00 00	 call	 cckd_uncompress_zlib
  001c1	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 5816 :         break;

  001c8	eb 58		 jmp	 SHORT $LN2@cckd_uncom
$LN8@cckd_uncom:

; 5817 :     case CCKD_COMPRESS_BZIP2:
; 5818 :         to = cckd->newbuf;

  001ca	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  001d2	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001d6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR to$[rsp], rax

; 5819 :         newlen = cckd_uncompress_bzip2 (dev, to, from, len, maxlen);

  001de	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR maxlen$[rsp]
  001e5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001e9	44 8b 8c 24 10
	01 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  001f1	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR from$[rsp]
  001f9	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  00201	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00209	e8 00 00 00 00	 call	 cckd_uncompress_bzip2
  0020e	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 5820 :         break;

  00215	eb 0b		 jmp	 SHORT $LN2@cckd_uncom
$LN9@cckd_uncom:

; 5821 :     default:
; 5822 :         newlen = -1;

  00217	c7 84 24 94 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR newlen$[rsp], -1
$LN2@cckd_uncom:

; 5823 :         break;
; 5824 :     }
; 5825 : 
; 5826 :     /* Validate the uncompressed track image */
; 5827 :     newlen = cckd_validate (dev, to, trk, newlen);

  00222	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR newlen$[rsp]
  0022a	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00232	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  0023a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00242	e8 00 00 00 00	 call	 cckd_validate
  00247	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 5828 : 
; 5829 :     /* Return if successful */
; 5830 :     if (newlen > 0)

  0024e	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR newlen$[rsp], 0
  00256	7e 4c		 jle	 SHORT $LN10@cckd_uncom

; 5831 :     {
; 5832 :         if (to != from)

  00258	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR from$[rsp]
  00260	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR to$[rsp], rax
  00268	74 2d		 je	 SHORT $LN11@cckd_uncom

; 5833 :         {
; 5834 :             cckd->newbuf = from;

  0026a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00272	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  0027a	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 5835 :             cckd->bufused = 1;

  0027e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00286	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00289	83 c8 08	 or	 eax, 8
  0028c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00294	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN11@cckd_uncom:

; 5836 :         }
; 5837 :         return to;

  00297	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR to$[rsp]
  0029f	e9 35 05 00 00	 jmp	 $LN1@cckd_uncom
$LN10@cckd_uncom:

; 5838 :     }
; 5839 : 
; 5840 :     /* Get a buffer now if we haven't gotten one */
; 5841 :     if (cckd->newbuf == NULL)

  002a4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  002ac	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  002b1	75 41		 jne	 SHORT $LN12@cckd_uncom

; 5842 :     {
; 5843 :         cckd->newbuf = cckd_malloc (dev, "newbuf2", maxlen);

  002b3	48 63 84 24 18
	01 00 00	 movsxd	 rax, DWORD PTR maxlen$[rsp]
  002bb	4c 8b c0	 mov	 r8, rax
  002be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172709
  002c5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002cd	e8 00 00 00 00	 call	 cckd_malloc
  002d2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  002da	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 5844 :         if (cckd->newbuf == NULL)

  002de	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  002e6	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  002eb	75 07		 jne	 SHORT $LN13@cckd_uncom

; 5845 :             return NULL;

  002ed	33 c0		 xor	 eax, eax
  002ef	e9 e5 04 00 00	 jmp	 $LN1@cckd_uncom
$LN13@cckd_uncom:
$LN12@cckd_uncom:

; 5846 :     }
; 5847 : 
; 5848 :     /* Try each uncompression routine in turn */
; 5849 : 
; 5850 :     /* uncompressed */
; 5851 :     newlen = cckd_trklen   (dev, from);

  002f4	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR from$[rsp]
  002fc	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00304	e8 00 00 00 00	 call	 cckd_trklen
  00309	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 5852 :     newlen = cckd_validate (dev, from, trk, newlen);

  00310	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR newlen$[rsp]
  00318	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00320	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR from$[rsp]
  00328	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00330	e8 00 00 00 00	 call	 cckd_validate
  00335	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 5853 :     if (newlen > 0)

  0033c	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR newlen$[rsp], 0
  00344	7e 0d		 jle	 SHORT $LN14@cckd_uncom

; 5854 :         return from;

  00346	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR from$[rsp]
  0034e	e9 86 04 00 00	 jmp	 $LN1@cckd_uncom
$LN14@cckd_uncom:

; 5855 : 
; 5856 :     /* zlib compression */
; 5857 :     to = cckd->newbuf;

  00353	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0035b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0035f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR to$[rsp], rax

; 5858 :     newlen = cckd_uncompress_zlib (dev, to, from, len, maxlen);

  00367	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR maxlen$[rsp]
  0036e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00372	44 8b 8c 24 10
	01 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  0037a	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR from$[rsp]
  00382	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  0038a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00392	e8 00 00 00 00	 call	 cckd_uncompress_zlib
  00397	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 5859 :     newlen = cckd_validate        (dev, to, trk, newlen);

  0039e	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR newlen$[rsp]
  003a6	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  003ae	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  003b6	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003be	e8 00 00 00 00	 call	 cckd_validate
  003c3	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 5860 :     if (newlen > 0)

  003ca	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR newlen$[rsp], 0
  003d2	7e 3a		 jle	 SHORT $LN15@cckd_uncom

; 5861 :     {
; 5862 :         cckd->newbuf = from;

  003d4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  003dc	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  003e4	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 5863 :         cckd->bufused = 1;

  003e8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  003f0	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003f3	83 c8 08	 or	 eax, 8
  003f6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  003fe	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 5864 :         return to;

  00401	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR to$[rsp]
  00409	e9 cb 03 00 00	 jmp	 $LN1@cckd_uncom
$LN15@cckd_uncom:

; 5865 :     }
; 5866 : 
; 5867 :     /* bzip2 compression */
; 5868 :     to = cckd->newbuf;

  0040e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00416	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0041a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR to$[rsp], rax

; 5869 :     newlen = cckd_uncompress_bzip2 (dev, to, from, len, maxlen);

  00422	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR maxlen$[rsp]
  00429	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0042d	44 8b 8c 24 10
	01 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  00435	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR from$[rsp]
  0043d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  00445	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0044d	e8 00 00 00 00	 call	 cckd_uncompress_bzip2
  00452	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 5870 :     newlen = cckd_validate         (dev, to, trk, newlen);

  00459	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR newlen$[rsp]
  00461	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00469	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  00471	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00479	e8 00 00 00 00	 call	 cckd_validate
  0047e	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 5871 :     if (newlen > 0)

  00485	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR newlen$[rsp], 0
  0048d	7e 3a		 jle	 SHORT $LN16@cckd_uncom

; 5872 :     {
; 5873 :         cckd->newbuf = from;

  0048f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00497	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  0049f	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 5874 :         cckd->bufused = 1;

  004a3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  004ab	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  004ae	83 c8 08	 or	 eax, 8
  004b1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  004b9	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 5875 :         return to;

  004bc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR to$[rsp]
  004c4	e9 10 03 00 00	 jmp	 $LN1@cckd_uncom
$LN16@cckd_uncom:

; 5876 :     }
; 5877 : 
; 5878 :     /* Unable to uncompress */
; 5879 :     WRMSG (HHC00343, "E",

  004c9	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  004d2	74 15		 je	 SHORT $LN19@cckd_uncom
  004d4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004dc	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004e0	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv245[rsp], eax
  004e7	eb 0b		 jmp	 SHORT $LN20@cckd_uncom
$LN19@cckd_uncom:
  004e9	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv245[rsp], 0
$LN20@cckd_uncom:
  004f4	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  004fd	74 17		 je	 SHORT $LN21@cckd_uncom
  004ff	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00507	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0050b	d1 f8		 sar	 eax, 1
  0050d	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv251[rsp], eax
  00514	eb 0b		 jmp	 SHORT $LN22@cckd_uncom
$LN21@cckd_uncom:
  00516	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv251[rsp], 0
$LN22@cckd_uncom:
  00521	b8 01 00 00 00	 mov	 eax, 1
  00526	48 6b c0 04	 imul	 rax, rax, 4
  0052a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  00532	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00536	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv216[rsp], eax
  0053d	b9 01 00 00 00	 mov	 ecx, 1
  00542	48 6b c9 03	 imul	 rcx, rcx, 3
  00546	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR from$[rsp]
  0054e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00552	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv220[rsp], ecx
  00559	ba 01 00 00 00	 mov	 edx, 1
  0055e	48 6b d2 02	 imul	 rdx, rdx, 2
  00562	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR from$[rsp]
  0056a	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  0056f	89 94 24 c4 00
	00 00		 mov	 DWORD PTR tv224[rsp], edx
  00576	41 b8 01 00 00
	00		 mov	 r8d, 1
  0057c	4d 6b c0 01	 imul	 r8, r8, 1
  00580	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR from$[rsp]
  00588	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  0058d	44 89 84 24 c8
	00 00 00	 mov	 DWORD PTR tv228[rsp], r8d
  00595	41 b9 01 00 00
	00		 mov	 r9d, 1
  0059b	4d 6b c9 00	 imul	 r9, r9, 0
  0059f	4c 8b 94 24 08
	01 00 00	 mov	 r10, QWORD PTR from$[rsp]
  005a7	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  005ac	44 89 8c 24 cc
	00 00 00	 mov	 DWORD PTR tv232[rsp], r9d
  005b4	4c 8b 94 24 98
	00 00 00	 mov	 r10, QWORD PTR cckd$[rsp]
  005bc	41 8b 52 3c	 mov	 edx, DWORD PTR [r10+60]
  005c0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005c8	e8 00 00 00 00	 call	 cckd_sf_name
  005cd	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv235[rsp], rax
  005d5	b9 01 00 00 00	 mov	 ecx, 1
  005da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005e0	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv216[rsp]
  005e7	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  005ee	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv220[rsp]
  005f5	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  005f9	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv224[rsp]
  00600	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00604	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv228[rsp]
  0060b	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0060f	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv232[rsp]
  00616	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0061a	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00621	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00625	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv235[rsp]
  0062d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00632	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0063a	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  0063d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00641	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv245[rsp]
  00648	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0064c	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv251[rsp]
  00653	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00657	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172714
  0065e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00663	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172715
  0066a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0066f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00674	41 b9 03 00 00
	00		 mov	 r9d, 3
  0067a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172716
  00681	ba f9 16 00 00	 mov	 edx, 5881		; 000016f9H
  00686	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172717
  0068d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5880 :             LCSS_DEVNUM, cckd->sfn, cckd_sf_name(dev, cckd->sfn), trk,
; 5881 :             from[0], from[1], from[2], from[3], from[4]);
; 5882 :     if (comp & ~cckdblk.comps)

  00693	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  0069b	0f b6 0d 1c 00
	00 00		 movzx	 ecx, BYTE PTR cckdblk+28
  006a2	f7 d1		 not	 ecx
  006a4	23 c1		 and	 eax, ecx
  006a6	85 c0		 test	 eax, eax
  006a8	0f 84 29 01 00
	00		 je	 $LN17@cckd_uncom

; 5883 :         WRMSG (HHC00344, "E",

  006ae	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006b7	74 15		 je	 SHORT $LN23@cckd_uncom
  006b9	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006c1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006c5	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv281[rsp], eax
  006cc	eb 0b		 jmp	 SHORT $LN24@cckd_uncom
$LN23@cckd_uncom:
  006ce	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv281[rsp], 0
$LN24@cckd_uncom:
  006d9	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006e2	74 17		 je	 SHORT $LN25@cckd_uncom
  006e4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006ec	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  006f0	d1 f8		 sar	 eax, 1
  006f2	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv287[rsp], eax
  006f9	eb 0b		 jmp	 SHORT $LN26@cckd_uncom
$LN25@cckd_uncom:
  006fb	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv287[rsp], 0
$LN26@cckd_uncom:
  00706	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  0070e	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv267[rsp], rax
  00716	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compname
  0071d	48 89 8c 24 d8
	00 00 00	 mov	 QWORD PTR tv298[rsp], rcx
  00725	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR cckd$[rsp]
  0072d	8b 52 3c	 mov	 edx, DWORD PTR [rdx+60]
  00730	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00738	e8 00 00 00 00	 call	 cckd_sf_name
  0073d	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv271[rsp], rax
  00745	b9 01 00 00 00	 mov	 ecx, 1
  0074a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00750	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR tv298[rsp]
  00758	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv267[rsp]
  00760	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00764	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00769	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv271[rsp]
  00771	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00776	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0077e	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00781	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00785	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv281[rsp]
  0078c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00790	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv287[rsp]
  00797	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0079b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172719
  007a2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172720
  007ae	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007b8	41 b9 03 00 00
	00		 mov	 r9d, 3
  007be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172721
  007c5	ba fc 16 00 00	 mov	 edx, 5884		; 000016fcH
  007ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172722
  007d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@cckd_uncom:

; 5884 :                 LCSS_DEVNUM, cckd->sfn, cckd_sf_name(dev, cckd->sfn), compname[comp]);
; 5885 :     return NULL;

  007d7	33 c0		 xor	 eax, eax
$LN1@cckd_uncom:

; 5886 : }

  007d9	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  007e0	c3		 ret	 0
cckd_uncompress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 32
cckd$ = 40
devnum$ = 64
cckd_find_device_by_devnum PROC

; 5765 : {

$LN7:
  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5766 : DEVBLK       *dev;
; 5767 : CCKD_EXT     *cckd;
; 5768 : 
; 5769 :     cckd_lock_devchain (0);

  00009	33 c9		 xor	 ecx, ecx
  0000b	e8 00 00 00 00	 call	 cckd_lock_devchain

; 5770 :     for (dev = cckdblk.dev1st; dev; dev = cckd->devnext)

  00010	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  00017	48 89 44 24 20	 mov	 QWORD PTR dev$[rsp], rax
  0001c	eb 0d		 jmp	 SHORT $LN4@cckd_find_
$LN2@cckd_find_:
  0001e	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00026	48 89 44 24 20	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd_find_:
  0002b	48 83 7c 24 20
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00031	74 27		 je	 SHORT $LN3@cckd_find_

; 5771 :     {
; 5772 :         if (dev->devnum == devnum) break;

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  00038	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0003c	0f b7 4c 24 40	 movzx	 ecx, WORD PTR devnum$[rsp]
  00041	3b c1		 cmp	 eax, ecx
  00043	75 02		 jne	 SHORT $LN5@cckd_find_
  00045	eb 13		 jmp	 SHORT $LN3@cckd_find_
$LN5@cckd_find_:

; 5773 :         cckd = dev->cckd_ext;

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  0004c	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00053	48 89 44 24 28	 mov	 QWORD PTR cckd$[rsp], rax

; 5774 :     }

  00058	eb c4		 jmp	 SHORT $LN2@cckd_find_
$LN3@cckd_find_:

; 5775 :     cckd_unlock_devchain ();

  0005a	e8 00 00 00 00	 call	 cckd_unlock_devchain

; 5776 :     return dev;

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]

; 5777 : } /* end function cckd_find_device_by_devnum */

  00064	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00068	c3		 ret	 0
cckd_find_device_by_devnum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 8
buf$ = 16
cckd_gc_l2 PROC

; 5619 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@cckd_gc_l2:

; 5620 : #if 1 // (deprecate this function!)
; 5621 : 
; 5622 :     UNREFERENCED( dev );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@cckd_gc_l2
$LN7@cckd_gc_l2:

; 5623 :     UNREFERENCED( buf );

  00010	33 c0		 xor	 eax, eax
  00012	85 c0		 test	 eax, eax
  00014	75 fa		 jne	 SHORT $LN7@cckd_gc_l2

; 5624 : 
; 5625 :     return 0;

  00016	33 c0		 xor	 eax, eax

; 5626 : 
; 5627 : #else // (deprecate this function!)
; 5628 : 
; 5629 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 5630 : int             sfx;                    /* Shadow file index         */
; 5631 : int             i, j;                   /* Work variables            */
; 5632 : int             trk;                    /* Track number              */
; 5633 : int             len;                    /* Track length              */
; 5634 : off_t           pos, fpos;              /* File offsets              */
; 5635 : 
; 5636 :     if (dev->cckd64)
; 5637 :         return cckd64_gc_l2( dev, buf );
; 5638 : 
; 5639 :     cckd = dev->cckd_ext;
; 5640 : 
; 5641 :     obtain_lock (&cckd->filelock);
; 5642 :     sfx = cckd->sfn;
; 5643 : 
; 5644 :     if (cckd->L2ok || cckd->cdevhdr[cckd->sfn].free_total == 0)
; 5645 :         goto cckd_gc_l2_exit;
; 5646 : 
; 5647 :     /* Find any level 2 table out of bounds */
; 5648 :     for (i = 0; i < cckd->cdevhdr[sfx].num_L1tab; i++)
; 5649 :         if (cckd->L1tab[sfx][i] != CCKD_NOSIZE && cckd->L1tab[sfx][i] != CCKD_MAXSIZE
; 5650 :          && cckd->L2_bounds - CCKD_L2TAB_SIZE < (U64)cckd->L1tab[sfx][i])
; 5651 :             break;
; 5652 : 
; 5653 :     /* Return OK if no l2 tables out of bounds */
; 5654 :     if (i >= cckd->cdevhdr[sfx].num_L1tab)
; 5655 :         goto cckd_gc_l2_exit_ok;
; 5656 : 
; 5657 :     /* Relocate all track images within the bounds */
; 5658 :     pos = CCKD_L1TAB_POS + (cckd->cdevhdr[sfx].num_L1tab * CCKD_L1ENT_SIZE);
; 5659 :     i = cckd->free_idx1st;
; 5660 :     fpos = (off_t)cckd->cdevhdr[sfx].free_off;
; 5661 :     while ((U64)pos < cckd->L2_bounds)
; 5662 :     {
; 5663 :         if (i >= 0 && pos == fpos)
; 5664 :         {
; 5665 :             pos +=        cckd->ifb[i].ifb_len;
; 5666 :             fpos = (off_t)cckd->ifb[i].ifb_offnxt;
; 5667 :             i    =        cckd->ifb[i].ifb_idxnxt;
; 5668 :             j = 0;
; 5669 :         }
; 5670 :         else
; 5671 :         {
; 5672 :             for (j = 0; j < cckd->cdevhdr[sfx].num_L1tab; j++)
; 5673 :                 if (pos == (off_t)cckd->L1tab[sfx][j])
; 5674 :                 {
; 5675 :                     pos += CCKD_L2TAB_SIZE;
; 5676 :                     break;
; 5677 :                 }
; 5678 :         }
; 5679 :         if (j >= cckd->cdevhdr[sfx].num_L1tab)
; 5680 :         {
; 5681 :             /* Found a track to relocate */
; 5682 :             if (cckd_read (dev, sfx, pos, buf, CKD_TRKHDR_SIZE) < 0)
; 5683 :                 goto cckd_gc_l2_exit;
; 5684 :             if ((trk = cckd_cchh (dev, buf, -1)) < 0)
; 5685 :                 goto cckd_gc_l2_exit;
; 5686 :             CCKD_TRACE( "gc_l2 relocate trk[%d] offset 0x%x", trk, pos);
; 5687 :             if ((len = cckd_read_trkimg (dev, buf, trk, NULL)) < 0)
; 5688 :                goto cckd_gc_l2_exit;
; 5689 :             if (cckd_write_trkimg (dev, buf, len, trk, CCKD_SIZE_EXACT) < 0)
; 5690 :                goto cckd_gc_l2_exit;
; 5691 :             /* Start over */
; 5692 :             pos = CCKD_L1TAB_POS + (cckd->cdevhdr[sfx].num_L1tab * CCKD_L1ENT_SIZE);
; 5693 :             i = cckd->free_idx1st;
; 5694 :             fpos = (off_t)cckd->cdevhdr[sfx].free_off;
; 5695 :         }
; 5696 :     }
; 5697 : 
; 5698 :     do {
; 5699 :         /* Find a level 2 table to relocate */
; 5700 : 
; 5701 :         i = cckd->free_idx1st;
; 5702 :         fpos = (off_t) cckd->cdevhdr[sfx].free_off;
; 5703 : 
; 5704 :         CCKD_TRACE( "gc_l2 first free[%d] pos 0x%x len %d pending %d",
; 5705 :                     i, (int)fpos, i >= 0 ? (int)cckd->ifb[i].ifb_len : -1,
; 5706 :                     i >= 0 ? cckd->ifb[i].ifb_pending : -1 );
; 5707 : 
; 5708 :         if (i < 0 || (U64) fpos >= cckd->L2_bounds || cckd->ifb[i].ifb_pending)
; 5709 :             goto cckd_gc_l2_exit;
; 5710 : 
; 5711 :         CCKD_TRACE( "gc_l2 bounds 0x%"PRIx64" sfx %d num_L1tab %d",
; 5712 :             cckd->L2_bounds, sfx, cckd->cdevhdr[sfx].num_L1tab );
; 5713 : 
; 5714 :         if ( cckd->ifb[i].ifb_len <  CCKD_L2TAB_SIZE
; 5715 :          || (cckd->ifb[i].ifb_len != CCKD_L2TAB_SIZE
; 5716 :           && cckd->ifb[i].ifb_len <  CCKD_L2TAB_SIZE + CCKD_FREEBLK_SIZE)
; 5717 :         )
; 5718 :         {
; 5719 :             for (i=0; i < cckd->cdevhdr[sfx].num_L1tab; i++)
; 5720 :             {
; 5721 :                 if (fpos + cckd->ifb[i].ifb_len == (off_t)cckd->L1tab[sfx][i])
; 5722 :                     break;
; 5723 :             }
; 5724 :         }
; 5725 :         else
; 5726 :         {
; 5727 :             for (i=0; i < cckd->cdevhdr[sfx].num_L1tab; i++)
; 5728 :             {
; 5729 :                 if (cckd->L2_bounds - CCKD_L2TAB_SIZE < (U64)cckd->L1tab[sfx][i]
; 5730 :                  && cckd->L1tab[sfx][i] != CCKD_MAXSIZE)
; 5731 :                     break;
; 5732 :             }
; 5733 :         }
; 5734 : 
; 5735 :         if (i < cckd->cdevhdr[sfx].num_L1tab)
; 5736 :         {
; 5737 :             CCKD_TRACE( "gc_l2 relocate l2[%d] pos 0x%x",
; 5738 :                         i, cckd->L1tab[sfx][i] );
; 5739 : 
; 5740 :             if (cckd_read_l2( dev, sfx, i ) < 0)
; 5741 :                 goto cckd_gc_l2_exit;
; 5742 : 
; 5743 :             if (cckd_write_l2( dev ) < 0)
; 5744 :                 goto cckd_gc_l2_exit;
; 5745 :         }
; 5746 :     }
; 5747 :     while (i < cckd->cdevhdr[sfx].num_L1tab);
; 5748 : 
; 5749 : cckd_gc_l2_exit:
; 5750 :     release_lock (&cckd->filelock);
; 5751 :     return 0;
; 5752 : 
; 5753 : cckd_gc_l2_exit_ok:
; 5754 :     CCKD_TRACE( "gc_l2 ok%s", "" );
; 5755 :     cckd->L2ok = 1;
; 5756 :     goto cckd_gc_l2_exit;
; 5757 : 
; 5758 : #endif // (deprecate this function!)
; 5759 : }

  00018	c3		 ret	 0
cckd_gc_l2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
i$ = 112
cckd$ = 120
sfx$ = 128
moved$ = 132
flen$ = 136
ulen$ = 140
didmsg$ = 144
j$ = 148
upos$ = 152
trk$ = 160
fpos$ = 168
a$ = 176
after$ = 180
k$ = 184
len$ = 188
tv416 = 192
tv468 = 196
tv562 = 200
tv597 = 204
tv603 = 208
rc$ = 212
tv760 = 216
tv762 = 220
tv799 = 224
tv805 = 228
tv91 = 232
tv129 = 236
tv208 = 240
l2$ = 248
flags$ = 256
L1idx$ = 260
l2x$ = 264
tv83 = 272
tv589 = 280
tv791 = 288
buf$ = 304
__$ArrayPad$ = 262448
dev$ = 262480
size$ = 262488
cckd_gc_percolate PROC

; 5357 : {

$LN95:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	b8 48 01 04 00	 mov	 eax, 262472		; 00040148H
  0000f	e8 00 00 00 00	 call	 __chkstk
  00014	48 2b e0	 sub	 rsp, rax
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 30
	01 04 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5358 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 5359 : bool            didmsg = false;         /* HHC00384 issued           */

  00029	c6 84 24 90 00
	00 00 00	 mov	 BYTE PTR didmsg$[rsp], 0

; 5360 : int             rc;                     /* Return code               */
; 5361 : unsigned int    moved = 0;              /* Space moved               */

  00031	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR moved$[rsp], 0

; 5362 : int             after = 0, a;           /* New space after old       */

  0003c	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR after$[rsp], 0

; 5363 : int             sfx;                    /* File index                */
; 5364 : int             i, j, k;                /* Indexes                   */
; 5365 : int             flags;                  /* Write trkimg flags        */
; 5366 : off_t           fpos, upos;             /* File offsets              */
; 5367 : unsigned int    flen, ulen, len;        /* Lengths                   */
; 5368 : int             trk;                    /* Track number              */
; 5369 : int             L1idx, l2x;             /* Table Indexes             */
; 5370 : CCKD_L2ENT      l2;                     /* Copied level 2 entry      */
; 5371 : BYTE            buf[256*1024];          /* Buffer                    */
; 5372 : 
; 5373 :     if (dev->cckd64)

  00047	48 8b 84 24 50
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004f	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00056	24 01		 and	 al, 1
  00058	0f b6 c0	 movzx	 eax, al
  0005b	85 c0		 test	 eax, eax
  0005d	74 1a		 je	 SHORT $LN30@cckd_gc_pe

; 5374 :         return cckd64_gc_percolate( dev, size );

  0005f	48 8b 94 24 58
	01 04 00	 mov	 rdx, QWORD PTR size$[rsp]
  00067	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0006f	e8 00 00 00 00	 call	 cckd64_gc_percolate
  00074	e9 cc 13 00 00	 jmp	 $LN1@cckd_gc_pe
$LN30@cckd_gc_pe:

; 5375 : 
; 5376 :     cckd = dev->cckd_ext;

  00079	48 8b 84 24 50
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  00081	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00088	48 89 44 24 78	 mov	 QWORD PTR cckd$[rsp], rax

; 5377 :     size = size << SHIFT_1K;

  0008d	48 8b 84 24 58
	01 04 00	 mov	 rax, QWORD PTR size$[rsp]
  00095	48 c1 e0 0a	 shl	 rax, 10
  00099	48 89 84 24 58
	01 04 00	 mov	 QWORD PTR size$[rsp], rax

; 5378 : 
; 5379 :     if (cckd->cdevhdr[ cckd->sfn ].cdh_opts & CCKD_OPT_SPERRS)

  000a1	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  000a6	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  000aa	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000b1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  000b6	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  000be	83 e0 20	 and	 eax, 32			; 00000020H
  000c1	85 c0		 test	 eax, eax
  000c3	0f 84 10 01 00
	00		 je	 $LN31@cckd_gc_pe

; 5380 :     {
; 5381 :         // "Skipping garbage collection for CCKD%s file[%d] %1d:%04X %s due to space errors"
; 5382 :         if (cckdblk.gcmsgs)

  000c9	83 3d 4c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+588, 0
  000d0	0f 84 f7 00 00
	00		 je	 $LN32@cckd_gc_pe

; 5383 :             WRMSG( HHC00385, "I", "", cckd->sfn, LCSS_DEVNUM, cckd_sf_name( dev, cckd->sfn ));

  000d6	48 83 bc 24 50
	01 04 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000df	74 15		 je	 SHORT $LN71@cckd_gc_pe
  000e1	48 8b 84 24 50
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000ed	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv91[rsp], eax
  000f4	eb 0b		 jmp	 SHORT $LN72@cckd_gc_pe
$LN71@cckd_gc_pe:
  000f6	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv91[rsp], 0
$LN72@cckd_gc_pe:
  00101	48 83 bc 24 50
	01 04 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0010a	74 17		 je	 SHORT $LN73@cckd_gc_pe
  0010c	48 8b 84 24 50
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  00114	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00118	d1 f8		 sar	 eax, 1
  0011a	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv129[rsp], eax
  00121	eb 0b		 jmp	 SHORT $LN74@cckd_gc_pe
$LN73@cckd_gc_pe:
  00123	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv129[rsp], 0
$LN74@cckd_gc_pe:
  0012e	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00133	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00136	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0013e	e8 00 00 00 00	 call	 cckd_sf_name
  00143	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv83[rsp], rax
  0014b	b9 01 00 00 00	 mov	 ecx, 1
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00156	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv83[rsp]
  0015e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00163	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv91[rsp]
  0016a	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0016e	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv129[rsp]
  00175	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00179	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0017e	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00181	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172572
  0018c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172573
  00198	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0019d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172574
  001a4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ae	41 b9 03 00 00
	00		 mov	 r9d, 3
  001b4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172575
  001bb	ba 07 15 00 00	 mov	 edx, 5383		; 00001507H
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172576
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN32@cckd_gc_pe:

; 5384 :         return moved;

  001cd	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR moved$[rsp]
  001d4	e9 6c 12 00 00	 jmp	 $LN1@cckd_gc_pe
$LN31@cckd_gc_pe:

; 5385 :     }
; 5386 : 
; 5387 :     /* Debug */
; 5388 :     OBTAIN_TRACE_LOCK();

  001d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172577
  001e0	48 8d 0d f0 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+752
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5389 :     if (cckdblk.itracen)

  001ed	83 3d 10 03 00
	00 00		 cmp	 DWORD PTR cckdblk+784, 0
  001f4	0f 84 12 02 00
	00		 je	 $LN33@cckd_gc_pe

; 5390 :     {
; 5391 :         RELEASE_TRACE_LOCK();

  001fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172580
  00201	48 8d 0d f0 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+752
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5392 : 
; 5393 :         CCKD_TRACE( "gcperc size %d 1st 0x%x nbr %d largest %u",

  0020e	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00213	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00217	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0021e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00223	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  00227	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  0022e	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00233	48 63 52 3c	 movsxd	 rdx, DWORD PTR [rdx+60]
  00237	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  0023e	4c 8b 44 24 78	 mov	 r8, QWORD PTR cckd$[rsp]
  00243	41 8b 84 00 fc
	01 00 00	 mov	 eax, DWORD PTR [r8+rax+508]
  0024b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0024f	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00254	8b 84 08 00 02
	00 00		 mov	 eax, DWORD PTR [rax+rcx+512]
  0025b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0025f	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00264	8b 84 10 f4 01
	00 00		 mov	 eax, DWORD PTR [rax+rdx+500]
  0026b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0026f	48 8b 84 24 58
	01 04 00	 mov	 rax, QWORD PTR size$[rsp]
  00277	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172581
  00283	4c 8b 84 24 50
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  0028b	ba 14 15 00 00	 mov	 edx, 5396		; 00001514H
  00290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172582
  00297	e8 00 00 00 00	 call	 cckd_trace

; 5394 :                     size, cckd->cdevhdr[cckd->sfn].free_off,
; 5395 :                     cckd->cdevhdr[cckd->sfn].free_num,
; 5396 :                     cckd->cdevhdr[cckd->sfn].free_largest );
; 5397 : 
; 5398 :         fpos = (off_t) cckd->cdevhdr[cckd->sfn].free_off;

  0029c	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  002a1	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  002a5	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  002ac	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  002b1	8b 84 01 f4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+500]
  002b8	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 5399 : 
; 5400 :         for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  002c0	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  002c5	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  002c8	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
  002cc	eb 1a		 jmp	 SHORT $LN4@cckd_gc_pe
$LN2@cckd_gc_pe:
  002ce	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  002d3	48 6b c0 14	 imul	 rax, rax, 20
  002d7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  002dc	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  002e0	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  002e4	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd_gc_pe:
  002e8	83 7c 24 70 00	 cmp	 DWORD PTR i$[rsp], 0
  002ed	0f 8c 17 01 00
	00		 jl	 $LN3@cckd_gc_pe

; 5401 :         {
; 5402 :             CCKD_TRACE( "gcperc free[%4d]:%8.8x end %8.8x len %10d%cpend %d",

  002f3	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  002f8	48 6b c0 14	 imul	 rax, rax, 20
  002fc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00301	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00305	48 63 44 01 04	 movsxd	 rax, DWORD PTR [rcx+rax+4]
  0030a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR fpos$[rsp]
  00312	48 03 c8	 add	 rcx, rax
  00315	48 8b c1	 mov	 rax, rcx
  00318	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  0031d	48 6b c9 14	 imul	 rcx, rcx, 20
  00321	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00326	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0032a	48 63 0c 0a	 movsxd	 rcx, DWORD PTR [rdx+rcx]
  0032e	48 3b c1	 cmp	 rax, rcx
  00331	75 0d		 jne	 SHORT $LN75@cckd_gc_pe
  00333	c7 84 24 f0 00
	00 00 2a 00 00
	00		 mov	 DWORD PTR tv208[rsp], 42 ; 0000002aH
  0033e	eb 0b		 jmp	 SHORT $LN76@cckd_gc_pe
$LN75@cckd_gc_pe:
  00340	c7 84 24 f0 00
	00 00 20 00 00
	00		 mov	 DWORD PTR tv208[rsp], 32 ; 00000020H
$LN76@cckd_gc_pe:
  0034b	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00350	48 6b c0 14	 imul	 rax, rax, 20
  00354	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00359	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0035d	48 63 54 24 70	 movsxd	 rdx, DWORD PTR i$[rsp]
  00362	48 6b d2 14	 imul	 rdx, rdx, 20
  00366	4c 8b 44 24 78	 mov	 r8, QWORD PTR cckd$[rsp]
  0036b	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0036f	4c 63 4c 24 70	 movsxd	 r9, DWORD PTR i$[rsp]
  00374	4d 6b c9 14	 imul	 r9, r9, 20
  00378	4c 8b 54 24 78	 mov	 r10, QWORD PTR cckd$[rsp]
  0037d	4d 8b 52 70	 mov	 r10, QWORD PTR [r10+112]
  00381	47 8b 4c 0a 04	 mov	 r9d, DWORD PTR [r10+r9+4]
  00386	4c 8b 94 24 a8
	00 00 00	 mov	 r10, QWORD PTR fpos$[rsp]
  0038e	4d 03 d1	 add	 r10, r9
  00391	4d 8b ca	 mov	 r9, r10
  00394	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  00398	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0039c	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv208[rsp]
  003a3	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  003a7	41 8b 44 10 04	 mov	 eax, DWORD PTR [r8+rdx+4]
  003ac	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  003b0	44 89 4c 24 30	 mov	 DWORD PTR [rsp+48], r9d
  003b5	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR fpos$[rsp]
  003bc	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003c0	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  003c4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172583
  003cf	4c 8b 84 24 50
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  003d7	ba 1d 15 00 00	 mov	 edx, 5405		; 0000151dH
  003dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172584
  003e3	e8 00 00 00 00	 call	 cckd_trace

; 5403 :                         i,(int)fpos,(int)(fpos+cckd->ifb[i].ifb_len),(int)cckd->ifb[i].ifb_len,
; 5404 :                         fpos+(int)cckd->ifb[i].ifb_len == (int)cckd->ifb[i].ifb_offnxt ?
; 5405 :                                 '*' : ' ',cckd->ifb[i].ifb_pending );
; 5406 : 
; 5407 :             fpos = cckd->ifb[i].ifb_offnxt;

  003e8	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  003ed	48 6b c0 14	 imul	 rax, rax, 20
  003f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  003f6	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003fa	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  003fd	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 5408 :         }

  00405	e9 c4 fe ff ff	 jmp	 $LN2@cckd_gc_pe
$LN3@cckd_gc_pe:

; 5409 :     }

  0040a	eb 14		 jmp	 SHORT $LN34@cckd_gc_pe
$LN33@cckd_gc_pe:

; 5410 :     else
; 5411 :         RELEASE_TRACE_LOCK();

  0040c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172585
  00413	48 8d 0d f0 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+752
  0041a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN34@cckd_gc_pe:

; 5412 : 
; 5413 :     if (!cckd->L2ok)

  00420	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00425	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00428	c1 e8 08	 shr	 eax, 8
  0042b	83 e0 01	 and	 eax, 1
  0042e	85 c0		 test	 eax, eax
  00430	75 15		 jne	 SHORT $LN35@cckd_gc_pe

; 5414 :         cckd_gc_l2(dev, buf);

  00432	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0043a	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00442	e8 00 00 00 00	 call	 cckd_gc_l2
$LN35@cckd_gc_pe:
$LN5@cckd_gc_pe:

; 5415 : 
; 5416 :     /* garbage collection cycle... */
; 5417 :     while (moved < size && after < 4)

  00447	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR moved$[rsp]
  0044e	48 3b 84 24 58
	01 04 00	 cmp	 rax, QWORD PTR size$[rsp]
  00456	0f 83 68 0e 00
	00		 jae	 $LN6@cckd_gc_pe
  0045c	83 bc 24 b4 00
	00 00 04	 cmp	 DWORD PTR after$[rsp], 4
  00464	0f 8d 5a 0e 00
	00		 jge	 $LN6@cckd_gc_pe

; 5418 :     {
; 5419 :         obtain_lock (&cckd->filelock);

  0046a	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0046f	48 83 c0 10	 add	 rax, 16
  00473	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172587
  0047a	48 8b c8	 mov	 rcx, rax
  0047d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5420 :         sfx = cckd->sfn;

  00483	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00488	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0048b	89 84 24 80 00
	00 00		 mov	 DWORD PTR sfx$[rsp], eax

; 5421 : 
; 5422 :         /* Exit if no more free space */
; 5423 :         if (cckd->cdevhdr[sfx].free_total == 0)

  00492	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0049a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004a1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  004a6	83 bc 01 f8 01
	00 00 00	 cmp	 DWORD PTR [rcx+rax+504], 0
  004ae	75 25		 jne	 SHORT $LN36@cckd_gc_pe

; 5424 :         {
; 5425 :             release_lock( &cckd->filelock );

  004b0	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  004b5	48 83 c0 10	 add	 rax, 16
  004b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172589
  004c0	48 8b c8	 mov	 rcx, rax
  004c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5426 :             return moved;

  004c9	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR moved$[rsp]
  004d0	e9 70 0f 00 00	 jmp	 $LN1@cckd_gc_pe
$LN36@cckd_gc_pe:

; 5427 :         }
; 5428 : 
; 5429 :         /* Make sure the free space chain is built */
; 5430 :         if (!cckd->ifb) cckd_read_fsp (dev);

  004d5	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  004da	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  004df	75 0d		 jne	 SHORT $LN37@cckd_gc_pe
  004e1	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004e9	e8 00 00 00 00	 call	 cckd_read_fsp
$LN37@cckd_gc_pe:

; 5431 : 
; 5432 :         /* Find a space to start with */
; 5433 :         k = -1;

  004ee	c7 84 24 b8 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR k$[rsp], -1

; 5434 :         upos = ulen = flen = 0;

  004f9	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR flen$[rsp], 0
  00504	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR flen$[rsp]
  0050b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR ulen$[rsp], eax
  00512	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR ulen$[rsp]
  00519	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR upos$[rsp], rax

; 5435 :         fpos = cckd->cdevhdr[sfx].free_off;

  00521	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00529	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00530	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00535	8b 84 01 f4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+500]
  0053c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 5436 : 
; 5437 :         /* First non-pending free space */
; 5438 :         for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  00544	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00549	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  0054c	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
  00550	eb 1a		 jmp	 SHORT $LN9@cckd_gc_pe
$LN7@cckd_gc_pe:
  00552	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00557	48 6b c0 14	 imul	 rax, rax, 20
  0055b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00560	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00564	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  00568	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN9@cckd_gc_pe:
  0056c	83 7c 24 70 00	 cmp	 DWORD PTR i$[rsp], 0
  00571	7c 65		 jl	 SHORT $LN8@cckd_gc_pe

; 5439 :         {
; 5440 :             if (!cckd->ifb[i].ifb_pending)

  00573	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00578	48 6b c0 14	 imul	 rax, rax, 20
  0057c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00581	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00585	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  0058a	75 2a		 jne	 SHORT $LN38@cckd_gc_pe

; 5441 :             {
; 5442 :                 flen += cckd->ifb[i].ifb_len;

  0058c	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00591	48 6b c0 14	 imul	 rax, rax, 20
  00595	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0059a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0059e	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  005a2	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR flen$[rsp]
  005a9	03 c8		 add	 ecx, eax
  005ab	8b c1		 mov	 eax, ecx
  005ad	89 84 24 88 00
	00 00		 mov	 DWORD PTR flen$[rsp], eax

; 5443 :                 break;

  005b4	eb 22		 jmp	 SHORT $LN8@cckd_gc_pe
$LN38@cckd_gc_pe:

; 5444 :             }
; 5445 :             fpos = cckd->ifb[i].ifb_offnxt;

  005b6	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  005bb	48 6b c0 14	 imul	 rax, rax, 20
  005bf	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  005c4	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  005c8	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  005cb	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 5446 :         }

  005d3	e9 7a ff ff ff	 jmp	 $LN7@cckd_gc_pe
$LN8@cckd_gc_pe:

; 5447 : 
; 5448 :         /* Continue to largest if non-zero `after' */
; 5449 :         for ( ; i >= 0 && after; i = cckd->ifb[i].ifb_idxnxt)

  005d8	eb 1a		 jmp	 SHORT $LN12@cckd_gc_pe
$LN10@cckd_gc_pe:
  005da	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  005df	48 6b c0 14	 imul	 rax, rax, 20
  005e3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  005e8	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  005ec	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  005f0	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN12@cckd_gc_pe:
  005f4	83 7c 24 70 00	 cmp	 DWORD PTR i$[rsp], 0
  005f9	0f 8c b2 00 00
	00		 jl	 $LN11@cckd_gc_pe
  005ff	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR after$[rsp], 0
  00607	0f 84 a4 00 00
	00		 je	 $LN11@cckd_gc_pe

; 5450 :         {
; 5451 :             k = i;

  0060d	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  00611	89 84 24 b8 00
	00 00		 mov	 DWORD PTR k$[rsp], eax

; 5452 :             if (!cckd->ifb[i].ifb_pending) flen += cckd->ifb[i].ifb_len;

  00618	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0061d	48 6b c0 14	 imul	 rax, rax, 20
  00621	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00626	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0062a	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  0062f	75 28		 jne	 SHORT $LN39@cckd_gc_pe
  00631	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00636	48 6b c0 14	 imul	 rax, rax, 20
  0063a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0063f	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00643	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00647	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR flen$[rsp]
  0064e	03 c8		 add	 ecx, eax
  00650	8b c1		 mov	 eax, ecx
  00652	89 84 24 88 00
	00 00		 mov	 DWORD PTR flen$[rsp], eax
$LN39@cckd_gc_pe:

; 5453 :             if (cckd->ifb[i].ifb_len == cckd->cdevhdr[sfx].free_largest)

  00659	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0065e	48 6b c0 14	 imul	 rax, rax, 20
  00662	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00667	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0066b	48 63 94 24 80
	00 00 00	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  00673	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  0067a	4c 8b 44 24 78	 mov	 r8, QWORD PTR cckd$[rsp]
  0067f	41 8b 94 10 fc
	01 00 00	 mov	 edx, DWORD PTR [r8+rdx+508]
  00687	39 54 01 04	 cmp	 DWORD PTR [rcx+rax+4], edx
  0068b	75 02		 jne	 SHORT $LN40@cckd_gc_pe

; 5454 :                 break;

  0068d	eb 22		 jmp	 SHORT $LN11@cckd_gc_pe
$LN40@cckd_gc_pe:

; 5455 :             fpos = cckd->ifb[i].ifb_offnxt;

  0068f	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00694	48 6b c0 14	 imul	 rax, rax, 20
  00698	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0069d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  006a1	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  006a4	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 5456 :         }

  006ac	e9 29 ff ff ff	 jmp	 $LN10@cckd_gc_pe
$LN11@cckd_gc_pe:

; 5457 : 
; 5458 :         /* Skip following free spaces */
; 5459 :         for ( ; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  006b1	eb 1a		 jmp	 SHORT $LN15@cckd_gc_pe
$LN13@cckd_gc_pe:
  006b3	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  006b8	48 6b c0 14	 imul	 rax, rax, 20
  006bc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  006c1	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  006c5	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  006c9	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN15@cckd_gc_pe:
  006cd	83 7c 24 70 00	 cmp	 DWORD PTR i$[rsp], 0
  006d2	0f 8c a3 00 00
	00		 jl	 $LN14@cckd_gc_pe

; 5460 :         {
; 5461 :             if (!cckd->ifb[i].ifb_pending) flen += cckd->ifb[i].ifb_len;

  006d8	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  006dd	48 6b c0 14	 imul	 rax, rax, 20
  006e1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  006e6	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  006ea	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  006ef	75 28		 jne	 SHORT $LN41@cckd_gc_pe
  006f1	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  006f6	48 6b c0 14	 imul	 rax, rax, 20
  006fa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  006ff	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00703	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00707	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR flen$[rsp]
  0070e	03 c8		 add	 ecx, eax
  00710	8b c1		 mov	 eax, ecx
  00712	89 84 24 88 00
	00 00		 mov	 DWORD PTR flen$[rsp], eax
$LN41@cckd_gc_pe:

; 5462 :             if (fpos + cckd->ifb[i].ifb_len != cckd->ifb[i].ifb_offnxt) break;

  00719	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0071e	48 6b c0 14	 imul	 rax, rax, 20
  00722	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00727	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0072b	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  0072f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR fpos$[rsp]
  00737	48 03 c8	 add	 rcx, rax
  0073a	48 8b c1	 mov	 rax, rcx
  0073d	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  00742	48 6b c9 14	 imul	 rcx, rcx, 20
  00746	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  0074b	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0074f	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  00752	48 3b c1	 cmp	 rax, rcx
  00755	74 02		 je	 SHORT $LN42@cckd_gc_pe
  00757	eb 22		 jmp	 SHORT $LN14@cckd_gc_pe
$LN42@cckd_gc_pe:

; 5463 :             fpos = cckd->ifb[i].ifb_offnxt;

  00759	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0075e	48 6b c0 14	 imul	 rax, rax, 20
  00762	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00767	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0076b	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0076e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 5464 :         }

  00776	e9 38 ff ff ff	 jmp	 $LN13@cckd_gc_pe
$LN14@cckd_gc_pe:

; 5465 : 
; 5466 :         /* Space preceding largest if largest is at the end */
; 5467 :         if (i < 0 && k >= 0)

  0077b	83 7c 24 70 00	 cmp	 DWORD PTR i$[rsp], 0
  00780	0f 8d 96 01 00
	00		 jge	 $LN43@cckd_gc_pe
  00786	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR k$[rsp], 0
  0078e	0f 8c 88 01 00
	00		 jl	 $LN43@cckd_gc_pe

; 5468 :         {
; 5469 :             if (!cckd->ifb[k].ifb_pending) flen -= cckd->ifb[i].ifb_len;

  00794	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  0079c	48 6b c0 14	 imul	 rax, rax, 20
  007a0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  007a5	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  007a9	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  007ae	75 28		 jne	 SHORT $LN44@cckd_gc_pe
  007b0	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  007b5	48 6b c0 14	 imul	 rax, rax, 20
  007b9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  007be	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  007c2	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  007c6	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR flen$[rsp]
  007cd	2b c8		 sub	 ecx, eax
  007cf	8b c1		 mov	 eax, ecx
  007d1	89 84 24 88 00
	00 00		 mov	 DWORD PTR flen$[rsp], eax
$LN44@cckd_gc_pe:

; 5470 :             for (i = cckd->ifb[k].ifb_idxprv; i >= 0; i = cckd->ifb[i].ifb_idxprv)

  007d8	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR k$[rsp]
  007e0	48 6b c0 14	 imul	 rax, rax, 20
  007e4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  007e9	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  007ed	8b 44 01 08	 mov	 eax, DWORD PTR [rcx+rax+8]
  007f1	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
  007f5	eb 1a		 jmp	 SHORT $LN18@cckd_gc_pe
$LN16@cckd_gc_pe:
  007f7	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  007fc	48 6b c0 14	 imul	 rax, rax, 20
  00800	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00805	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00809	8b 44 01 08	 mov	 eax, DWORD PTR [rcx+rax+8]
  0080d	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN18@cckd_gc_pe:
  00811	83 7c 24 70 00	 cmp	 DWORD PTR i$[rsp], 0
  00816	0f 8c 00 01 00
	00		 jl	 $LN17@cckd_gc_pe

; 5471 :             {
; 5472 :                 fpos = cckd->ifb[i].ifb_idxprv >= 0

  0081c	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00821	48 6b c0 14	 imul	 rax, rax, 20
  00825	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0082a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0082e	83 7c 01 08 00	 cmp	 DWORD PTR [rcx+rax+8], 0
  00833	7c 30		 jl	 SHORT $LN77@cckd_gc_pe
  00835	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0083a	48 6b c0 14	 imul	 rax, rax, 20
  0083e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00843	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00847	48 63 44 01 08	 movsxd	 rax, DWORD PTR [rcx+rax+8]
  0084c	48 6b c0 14	 imul	 rax, rax, 20
  00850	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00855	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00859	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0085c	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv416[rsp], eax
  00863	eb 22		 jmp	 SHORT $LN78@cckd_gc_pe
$LN77@cckd_gc_pe:
  00865	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0086d	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00874	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00879	8b 84 01 f4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+500]
  00880	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv416[rsp], eax
$LN78@cckd_gc_pe:
  00887	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv416[rsp]
  0088e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 5473 :                      ? cckd->ifb[cckd->ifb[i].ifb_idxprv].ifb_offnxt
; 5474 :                      : cckd->cdevhdr[sfx].free_off;
; 5475 :                 if (fpos + cckd->ifb[i].ifb_len < cckd->ifb[i].ifb_offnxt) break;

  00896	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0089b	48 6b c0 14	 imul	 rax, rax, 20
  0089f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  008a4	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  008a8	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  008ac	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR fpos$[rsp]
  008b4	48 03 c8	 add	 rcx, rax
  008b7	48 8b c1	 mov	 rax, rcx
  008ba	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  008bf	48 6b c9 14	 imul	 rcx, rcx, 20
  008c3	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  008c8	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  008cc	8b 0c 0a	 mov	 ecx, DWORD PTR [rdx+rcx]
  008cf	48 3b c1	 cmp	 rax, rcx
  008d2	7d 02		 jge	 SHORT $LN45@cckd_gc_pe
  008d4	eb 46		 jmp	 SHORT $LN17@cckd_gc_pe
$LN45@cckd_gc_pe:

; 5476 :                 if (!cckd->ifb[i].ifb_pending) flen -= cckd->ifb[i].ifb_len;

  008d6	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  008db	48 6b c0 14	 imul	 rax, rax, 20
  008df	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  008e4	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  008e8	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  008ed	75 28		 jne	 SHORT $LN46@cckd_gc_pe
  008ef	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  008f4	48 6b c0 14	 imul	 rax, rax, 20
  008f8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  008fd	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00901	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00905	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR flen$[rsp]
  0090c	2b c8		 sub	 ecx, eax
  0090e	8b c1		 mov	 eax, ecx
  00910	89 84 24 88 00
	00 00		 mov	 DWORD PTR flen$[rsp], eax
$LN46@cckd_gc_pe:

; 5477 :             }

  00917	e9 db fe ff ff	 jmp	 $LN16@cckd_gc_pe
$LN17@cckd_gc_pe:
$LN43@cckd_gc_pe:

; 5478 :         }
; 5479 : 
; 5480 :         /* Calculate the offset/length of the used space.
; 5481 :          * If only imbedded free space is left, then start
; 5482 :          * with the first used space that is not an l2 table.
; 5483 :          */
; 5484 :         if (i >= 0)

  0091c	83 7c 24 70 00	 cmp	 DWORD PTR i$[rsp], 0
  00921	0f 8c 9f 00 00
	00		 jl	 $LN47@cckd_gc_pe

; 5485 :         {
; 5486 :             upos = fpos + cckd->ifb[i].ifb_len;

  00927	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0092c	48 6b c0 14	 imul	 rax, rax, 20
  00930	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00935	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00939	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  0093d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR fpos$[rsp]
  00945	48 03 c8	 add	 rcx, rax
  00948	48 8b c1	 mov	 rax, rcx
  0094b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR upos$[rsp], rax

; 5487 :             ulen = (unsigned int)((cckd->ifb[i].ifb_offnxt ? cckd->ifb[i].ifb_offnxt : cckd->cdevhdr[sfx].cdh_size) - upos);

  00953	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00958	48 6b c0 14	 imul	 rax, rax, 20
  0095c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00961	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00965	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  00969	74 1e		 je	 SHORT $LN79@cckd_gc_pe
  0096b	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00970	48 6b c0 14	 imul	 rax, rax, 20
  00974	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00979	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0097d	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00980	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv468[rsp], eax
  00987	eb 22		 jmp	 SHORT $LN80@cckd_gc_pe
$LN79@cckd_gc_pe:
  00989	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00991	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00998	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0099d	8b 84 01 ec 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+492]
  009a4	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv468[rsp], eax
$LN80@cckd_gc_pe:
  009ab	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv468[rsp]
  009b2	48 2b 84 24 98
	00 00 00	 sub	 rax, QWORD PTR upos$[rsp]
  009ba	89 84 24 8c 00
	00 00		 mov	 DWORD PTR ulen$[rsp], eax

; 5488 :         }

  009c1	e9 42 01 00 00	 jmp	 $LN48@cckd_gc_pe
$LN47@cckd_gc_pe:

; 5489 :         else if (!cckd->cdevhdr[sfx].free_num && cckd->cdevhdr[sfx].free_imbed)

  009c6	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  009ce	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  009d5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  009da	83 bc 01 00 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax+512], 0
  009e2	0f 85 20 01 00
	00		 jne	 $LN49@cckd_gc_pe
  009e8	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  009f0	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  009f7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  009fc	83 bc 01 04 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax+516], 0
  00a04	0f 84 fe 00 00
	00		 je	 $LN49@cckd_gc_pe

; 5490 :         {
; 5491 :             upos = (off_t)(CCKD_L1TAB_POS + cckd->cdevhdr[sfx].num_L1tab * CCKD_L1ENT_SIZE);

  00a0a	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00a12	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00a19	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00a1e	48 63 84 01 e4
	01 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+484]
  00a26	48 8d 04 85 00
	04 00 00	 lea	 rax, QWORD PTR [rax*4+1024]
  00a2e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR upos$[rsp], rax
$LN19@cckd_gc_pe:

; 5492 :             while (1)

  00a36	33 c0		 xor	 eax, eax
  00a38	83 f8 01	 cmp	 eax, 1
  00a3b	0f 84 9d 00 00
	00		 je	 $LN20@cckd_gc_pe

; 5493 :             {
; 5494 :                 for (i = 0; i < cckd->cdevhdr[sfx].num_L1tab; i++)

  00a41	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00a49	eb 0a		 jmp	 SHORT $LN23@cckd_gc_pe
$LN21@cckd_gc_pe:
  00a4b	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  00a4f	ff c0		 inc	 eax
  00a51	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN23@cckd_gc_pe:
  00a55	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00a5d	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00a64	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00a69	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  00a70	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  00a74	7d 2a		 jge	 SHORT $LN22@cckd_gc_pe

; 5495 :                     if (cckd->L1tab[sfx][i] == (U32)upos)

  00a76	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00a7e	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  00a83	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00a88	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00a90	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR upos$[rsp]
  00a97	39 14 88	 cmp	 DWORD PTR [rax+rcx*4], edx
  00a9a	75 02		 jne	 SHORT $LN50@cckd_gc_pe

; 5496 :                        break;

  00a9c	eb 02		 jmp	 SHORT $LN22@cckd_gc_pe
$LN50@cckd_gc_pe:
  00a9e	eb ab		 jmp	 SHORT $LN21@cckd_gc_pe
$LN22@cckd_gc_pe:

; 5497 :                 if (i >= cckd->cdevhdr[sfx].num_L1tab)

  00aa0	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00aa8	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00aaf	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00ab4	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  00abb	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  00abf	7c 02		 jl	 SHORT $LN51@cckd_gc_pe

; 5498 :                     break;

  00ac1	eb 1b		 jmp	 SHORT $LN20@cckd_gc_pe
$LN51@cckd_gc_pe:

; 5499 :                 upos += CCKD_L2TAB_SIZE;

  00ac3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR upos$[rsp]
  00acb	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  00ad1	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR upos$[rsp], rax

; 5500 :             }

  00ad9	e9 58 ff ff ff	 jmp	 $LN19@cckd_gc_pe
$LN20@cckd_gc_pe:

; 5501 :             ulen = (unsigned int)(cckd->cdevhdr[sfx].cdh_size - upos);

  00ade	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00ae6	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00aed	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00af2	8b 84 01 ec 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+492]
  00af9	48 2b 84 24 98
	00 00 00	 sub	 rax, QWORD PTR upos$[rsp]
  00b01	89 84 24 8c 00
	00 00		 mov	 DWORD PTR ulen$[rsp], eax
$LN49@cckd_gc_pe:
$LN48@cckd_gc_pe:

; 5502 :         }
; 5503 : 
; 5504 :         /* Return if no applicable used space */
; 5505 :         if (ulen == 0)

  00b08	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR ulen$[rsp], 0
  00b10	75 50		 jne	 SHORT $LN52@cckd_gc_pe

; 5506 :         {
; 5507 :             CCKD_TRACE( "gcperc no applicable space, moved %u", moved);

  00b12	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR moved$[rsp]
  00b19	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00b1d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172606
  00b24	4c 8b 84 24 50
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  00b2c	ba 83 15 00 00	 mov	 edx, 5507		; 00001583H
  00b31	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172607
  00b38	e8 00 00 00 00	 call	 cckd_trace

; 5508 :             release_lock( &cckd->filelock );

  00b3d	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00b42	48 83 c0 10	 add	 rax, 16
  00b46	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172608
  00b4d	48 8b c8	 mov	 rcx, rax
  00b50	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5509 :             return moved;

  00b56	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR moved$[rsp]
  00b5d	e9 e3 08 00 00	 jmp	 $LN1@cckd_gc_pe
$LN52@cckd_gc_pe:

; 5510 :         }
; 5511 : 
; 5512 :         /* Reduce ulen size to minimize `after' relocations */
; 5513 :         if (ulen > flen + 65536) ulen = flen + 65536;

  00b62	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR flen$[rsp]
  00b69	05 00 00 01 00	 add	 eax, 65536		; 00010000H
  00b6e	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR ulen$[rsp], eax
  00b75	76 13		 jbe	 SHORT $LN53@cckd_gc_pe
  00b77	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR flen$[rsp]
  00b7e	05 00 00 01 00	 add	 eax, 65536		; 00010000H
  00b83	89 84 24 8c 00
	00 00		 mov	 DWORD PTR ulen$[rsp], eax
$LN53@cckd_gc_pe:

; 5514 :         if (ulen > sizeof(buf))  ulen = sizeof(buf);

  00b8a	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR ulen$[rsp]
  00b91	48 3d 00 00 04
	00		 cmp	 rax, 262144		; 00040000H
  00b97	76 0b		 jbe	 SHORT $LN54@cckd_gc_pe
  00b99	c7 84 24 8c 00
	00 00 00 00 04
	00		 mov	 DWORD PTR ulen$[rsp], 262144 ; 00040000H
$LN54@cckd_gc_pe:

; 5515 : 
; 5516 :         CCKD_TRACE( "gcperc selected space 0x%16.16"PRIx64" len %d", upos, ulen);

  00ba4	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR ulen$[rsp]
  00bab	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00baf	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR upos$[rsp]
  00bb7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bbc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172611
  00bc3	4c 8b 84 24 50
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  00bcb	ba 8c 15 00 00	 mov	 edx, 5516		; 0000158cH
  00bd0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172612
  00bd7	e8 00 00 00 00	 call	 cckd_trace

; 5517 : 
; 5518 :         if (cckd_read (dev, sfx, upos, buf, ulen) < 0)

  00bdc	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR ulen$[rsp]
  00be3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00be7	4c 8d 8c 24 30
	01 00 00	 lea	 r9, QWORD PTR buf$[rsp]
  00bef	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR upos$[rsp]
  00bf7	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  00bfe	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c06	e8 00 00 00 00	 call	 cckd_read
  00c0b	85 c0		 test	 eax, eax
  00c0d	7d 2e		 jge	 SHORT $LN55@cckd_gc_pe

; 5519 :             return GC_PERC_ERROR();

  00c0f	c7 44 24 20 8f
	15 00 00	 mov	 DWORD PTR [rsp+32], 5519 ; 0000158fH
  00c17	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172614
  00c1e	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR moved$[rsp]
  00c26	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00c2b	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c33	e8 00 00 00 00	 call	 cckd_gc_perc_error
  00c38	e9 08 08 00 00	 jmp	 $LN1@cckd_gc_pe
$LN55@cckd_gc_pe:

; 5520 : 
; 5521 :         /* Process each space in the buffer */
; 5522 :         flags = cckd->cdevhdr[sfx].free_num < 100 ? CCKD_SIZE_EXACT : CCKD_SIZE_ANY;

  00c3d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00c45	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00c4c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00c51	83 bc 01 00 02
	00 00 64	 cmp	 DWORD PTR [rcx+rax+512], 100 ; 00000064H
  00c59	7d 0d		 jge	 SHORT $LN81@cckd_gc_pe
  00c5b	c7 84 24 c8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv562[rsp], 1
  00c66	eb 0b		 jmp	 SHORT $LN82@cckd_gc_pe
$LN81@cckd_gc_pe:
  00c68	c7 84 24 c8 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv562[rsp], 2
$LN82@cckd_gc_pe:
  00c73	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tv562[rsp]
  00c7a	89 84 24 00 01
	00 00		 mov	 DWORD PTR flags$[rsp], eax

; 5523 :         for (i = a = 0; i + CKD_TRKHDR_SIZE <= (int)ulen; i += len)

  00c81	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR a$[rsp], 0
  00c8c	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR a$[rsp]
  00c93	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
  00c97	eb 13		 jmp	 SHORT $LN26@cckd_gc_pe
$LN24@cckd_gc_pe:
  00c99	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00ca0	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  00ca4	03 c8		 add	 ecx, eax
  00ca6	8b c1		 mov	 eax, ecx
  00ca8	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN26@cckd_gc_pe:
  00cac	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00cb1	48 83 c0 05	 add	 rax, 5
  00cb5	48 63 8c 24 8c
	00 00 00	 movsxd	 rcx, DWORD PTR ulen$[rsp]
  00cbd	48 3b c1	 cmp	 rax, rcx
  00cc0	0f 8f 3d 05 00
	00		 jg	 $LN25@cckd_gc_pe

; 5524 :         {
; 5525 :             /* Check for level 2 table */
; 5526 :             for (j = 0; j < cckd->cdevhdr[sfx].num_L1tab; j++)

  00cc6	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  00cd1	eb 10		 jmp	 SHORT $LN29@cckd_gc_pe
$LN27@cckd_gc_pe:
  00cd3	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00cda	ff c0		 inc	 eax
  00cdc	89 84 24 94 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN29@cckd_gc_pe:
  00ce3	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00ceb	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00cf2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00cf7	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  00cfe	39 84 24 94 00
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  00d05	7d 39		 jge	 SHORT $LN28@cckd_gc_pe

; 5527 :                 if (cckd->L1tab[sfx][j] == (U32)(upos + i)) break;

  00d07	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00d0f	48 63 8c 24 94
	00 00 00	 movsxd	 rcx, DWORD PTR j$[rsp]
  00d17	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00d1c	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00d24	48 63 54 24 70	 movsxd	 rdx, DWORD PTR i$[rsp]
  00d29	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR upos$[rsp]
  00d31	4c 03 c2	 add	 r8, rdx
  00d34	49 8b d0	 mov	 rdx, r8
  00d37	39 14 88	 cmp	 DWORD PTR [rax+rcx*4], edx
  00d3a	75 02		 jne	 SHORT $LN56@cckd_gc_pe
  00d3c	eb 02		 jmp	 SHORT $LN28@cckd_gc_pe
$LN56@cckd_gc_pe:
  00d3e	eb 93		 jmp	 SHORT $LN27@cckd_gc_pe
$LN28@cckd_gc_pe:

; 5528 : 
; 5529 :             if (!didmsg)

  00d40	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR didmsg$[rsp]
  00d48	85 c0		 test	 eax, eax
  00d4a	0f 85 0c 01 00
	00		 jne	 $LN57@cckd_gc_pe

; 5530 :             {
; 5531 :                 // "Collecting garbage for CCKD%s file[%d] %1d:%04X %s..."
; 5532 :                 if (cckdblk.gcmsgs)

  00d50	83 3d 4c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+588, 0
  00d57	0f 84 f7 00 00
	00		 je	 $LN58@cckd_gc_pe

; 5533 :                     WRMSG( HHC00384, "I", "", cckd->sfn, LCSS_DEVNUM, cckd_sf_name( dev, cckd->sfn ));

  00d5d	48 83 bc 24 50
	01 04 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d66	74 15		 je	 SHORT $LN83@cckd_gc_pe
  00d68	48 8b 84 24 50
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d70	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00d74	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv597[rsp], eax
  00d7b	eb 0b		 jmp	 SHORT $LN84@cckd_gc_pe
$LN83@cckd_gc_pe:
  00d7d	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv597[rsp], 0
$LN84@cckd_gc_pe:
  00d88	48 83 bc 24 50
	01 04 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d91	74 17		 je	 SHORT $LN85@cckd_gc_pe
  00d93	48 8b 84 24 50
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d9b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00d9f	d1 f8		 sar	 eax, 1
  00da1	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv603[rsp], eax
  00da8	eb 0b		 jmp	 SHORT $LN86@cckd_gc_pe
$LN85@cckd_gc_pe:
  00daa	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv603[rsp], 0
$LN86@cckd_gc_pe:
  00db5	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00dba	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00dbd	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00dc5	e8 00 00 00 00	 call	 cckd_sf_name
  00dca	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv589[rsp], rax
  00dd2	b9 01 00 00 00	 mov	 ecx, 1
  00dd7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00ddd	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv589[rsp]
  00de5	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00dea	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv597[rsp]
  00df1	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00df5	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv603[rsp]
  00dfc	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00e00	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00e05	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00e08	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e0c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172618
  00e13	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e18	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172619
  00e1f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e24	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172620
  00e2b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e30	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e35	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e3b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172621
  00e42	ba 9d 15 00 00	 mov	 edx, 5533		; 0000159dH
  00e47	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172622
  00e4e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN58@cckd_gc_pe:

; 5534 :                 didmsg = true;

  00e54	c6 84 24 90 00
	00 00 01	 mov	 BYTE PTR didmsg$[rsp], 1
$LN57@cckd_gc_pe:

; 5535 :             }
; 5536 : 
; 5537 :             if (j < cckd->cdevhdr[sfx].num_L1tab)

  00e5c	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00e64	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00e6b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00e70	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  00e77	39 84 24 94 00
	00 00		 cmp	 DWORD PTR j$[rsp], eax
  00e7e	0f 8d 08 01 00
	00		 jge	 $LN59@cckd_gc_pe

; 5538 :             {
; 5539 :                 /* Moving a level 2 table */
; 5540 :                 len = CCKD_L2TAB_SIZE;

  00e84	c7 84 24 bc 00
	00 00 00 08 00
	00		 mov	 DWORD PTR len$[rsp], 2048 ; 00000800H

; 5541 :                 if (i + len > ulen) break;

  00e8f	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00e96	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  00e9a	03 c8		 add	 ecx, eax
  00e9c	8b c1		 mov	 eax, ecx
  00e9e	3b 84 24 8c 00
	00 00		 cmp	 eax, DWORD PTR ulen$[rsp]
  00ea5	76 05		 jbe	 SHORT $LN61@cckd_gc_pe
  00ea7	e9 57 03 00 00	 jmp	 $LN25@cckd_gc_pe
$LN61@cckd_gc_pe:

; 5542 :                 CCKD_TRACE( "gcperc move l2tab[%d] at pos 0x%16.16"PRIx64" len %d",

  00eac	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00eb1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR upos$[rsp]
  00eb9	48 03 c8	 add	 rcx, rax
  00ebc	48 8b c1	 mov	 rax, rcx
  00ebf	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00ec6	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00eca	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00ecf	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00ed6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00eda	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172626
  00ee1	4c 8b 84 24 50
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  00ee9	ba a7 15 00 00	 mov	 edx, 5543		; 000015a7H
  00eee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172627
  00ef5	e8 00 00 00 00	 call	 cckd_trace

; 5543 :                             j, upos + i, len);
; 5544 : 
; 5545 :                 /* Make the level 2 table active */
; 5546 :                 if (cckd_read_l2 (dev, sfx, j) < 0)

  00efa	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR j$[rsp]
  00f02	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  00f09	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f11	e8 00 00 00 00	 call	 cckd_read_l2
  00f16	85 c0		 test	 eax, eax
  00f18	7d 2e		 jge	 SHORT $LN62@cckd_gc_pe

; 5547 :                     return GC_PERC_ERROR();

  00f1a	c7 44 24 20 ab
	15 00 00	 mov	 DWORD PTR [rsp+32], 5547 ; 000015abH
  00f22	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172629
  00f29	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR moved$[rsp]
  00f31	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00f36	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f3e	e8 00 00 00 00	 call	 cckd_gc_perc_error
  00f43	e9 fd 04 00 00	 jmp	 $LN1@cckd_gc_pe
$LN62@cckd_gc_pe:

; 5548 : 
; 5549 :                 /* Write the level 2 table */
; 5550 :                 if (cckd_write_l2 (dev) < 0)

  00f48	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f50	e8 00 00 00 00	 call	 cckd_write_l2
  00f55	85 c0		 test	 eax, eax
  00f57	7d 2e		 jge	 SHORT $LN63@cckd_gc_pe

; 5551 :                     return GC_PERC_ERROR();

  00f59	c7 44 24 20 af
	15 00 00	 mov	 DWORD PTR [rsp+32], 5551 ; 000015afH
  00f61	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172631
  00f68	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR moved$[rsp]
  00f70	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00f75	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f7d	e8 00 00 00 00	 call	 cckd_gc_perc_error
  00f82	e9 be 04 00 00	 jmp	 $LN1@cckd_gc_pe
$LN63@cckd_gc_pe:

; 5552 :             }

  00f87	e9 72 02 00 00	 jmp	 $LN60@cckd_gc_pe
$LN59@cckd_gc_pe:

; 5553 :             else
; 5554 :             {
; 5555 :                 /* Moving a track image */
; 5556 :                 if ((trk = cckd_cchh (dev, buf + i, -1)) < 0)

  00f8c	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00f91	48 8d 84 04 30
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  00f99	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00f9f	48 8b d0	 mov	 rdx, rax
  00fa2	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00faa	e8 00 00 00 00	 call	 cckd_cchh
  00faf	89 84 24 a0 00
	00 00		 mov	 DWORD PTR trk$[rsp], eax
  00fb6	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR trk$[rsp], 0
  00fbe	7d 50		 jge	 SHORT $LN64@cckd_gc_pe

; 5557 :                     return GC_PERC_SPACE_ERROR();

  00fc0	c7 44 24 38 b5
	15 00 00	 mov	 DWORD PTR [rsp+56], 5557 ; 000015b5H
  00fc8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172633
  00fcf	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00fd4	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR moved$[rsp]
  00fdb	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00fdf	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00fe7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fec	44 8b 4c 24 70	 mov	 r9d, DWORD PTR i$[rsp]
  00ff1	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR upos$[rsp]
  00ff9	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00ffe	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01006	e8 00 00 00 00	 call	 cckd_gc_perc_space_error
  0100b	e9 35 04 00 00	 jmp	 $LN1@cckd_gc_pe
$LN64@cckd_gc_pe:

; 5558 : 
; 5559 :                 L1idx = trk >> 8;

  01010	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  01017	c1 f8 08	 sar	 eax, 8
  0101a	89 84 24 04 01
	00 00		 mov	 DWORD PTR L1idx$[rsp], eax

; 5560 :                 l2x = trk & 0xff;

  01021	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  01028	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0102d	89 84 24 08 01
	00 00		 mov	 DWORD PTR l2x$[rsp], eax

; 5561 : 
; 5562 :                 /* Read the lookup entry for the track */
; 5563 :                 if (cckd_read_l2ent (dev, &l2, trk) < 0)

  01034	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  0103c	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR l2$[rsp]
  01044	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0104c	e8 00 00 00 00	 call	 cckd_read_l2ent
  01051	85 c0		 test	 eax, eax
  01053	7d 2e		 jge	 SHORT $LN65@cckd_gc_pe

; 5564 :                     return GC_PERC_ERROR();

  01055	c7 44 24 20 bc
	15 00 00	 mov	 DWORD PTR [rsp+32], 5564 ; 000015bcH
  0105d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172635
  01064	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR moved$[rsp]
  0106c	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  01071	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01079	e8 00 00 00 00	 call	 cckd_gc_perc_error
  0107e	e9 c2 03 00 00	 jmp	 $LN1@cckd_gc_pe
$LN65@cckd_gc_pe:

; 5565 :                 if (l2.L2_trkoff != (U32)(upos + i))

  01083	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  01088	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR upos$[rsp]
  01090	48 03 c8	 add	 rcx, rax
  01093	48 8b c1	 mov	 rax, rcx
  01096	39 84 24 f8 00
	00 00		 cmp	 DWORD PTR l2$[rsp], eax
  0109d	74 50		 je	 SHORT $LN66@cckd_gc_pe

; 5566 :                     return GC_PERC_SPACE_ERROR();

  0109f	c7 44 24 38 be
	15 00 00	 mov	 DWORD PTR [rsp+56], 5566 ; 000015beH
  010a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172637
  010ae	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  010b3	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR moved$[rsp]
  010ba	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  010be	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  010c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010cb	44 8b 4c 24 70	 mov	 r9d, DWORD PTR i$[rsp]
  010d0	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR upos$[rsp]
  010d8	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  010dd	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010e5	e8 00 00 00 00	 call	 cckd_gc_perc_space_error
  010ea	e9 56 03 00 00	 jmp	 $LN1@cckd_gc_pe
$LN66@cckd_gc_pe:

; 5567 :                 len = (int)l2.L2_size;

  010ef	0f b7 84 24 fe
	00 00 00	 movzx	 eax, WORD PTR l2$[rsp+6]
  010f7	89 84 24 bc 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 5568 :                 if (i + l2.L2_len > (int)ulen) break;

  010fe	0f b7 84 24 fc
	00 00 00	 movzx	 eax, WORD PTR l2$[rsp+4]
  01106	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  0110a	03 c8		 add	 ecx, eax
  0110c	8b c1		 mov	 eax, ecx
  0110e	3b 84 24 8c 00
	00 00		 cmp	 eax, DWORD PTR ulen$[rsp]
  01115	7e 05		 jle	 SHORT $LN67@cckd_gc_pe
  01117	e9 e7 00 00 00	 jmp	 $LN25@cckd_gc_pe
$LN67@cckd_gc_pe:

; 5569 : 
; 5570 :                 CCKD_TRACE( "gcperc move trk %d at pos 0x%16.16"PRIx64" len %hu",

  0111c	0f b7 84 24 fc
	00 00 00	 movzx	 eax, WORD PTR l2$[rsp+4]
  01124	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  01129	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR upos$[rsp]
  01131	48 03 d1	 add	 rdx, rcx
  01134	48 8b ca	 mov	 rcx, rdx
  01137	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0113b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01140	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  01147	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0114b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172639
  01152	4c 8b 84 24 50
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  0115a	ba c3 15 00 00	 mov	 edx, 5571		; 000015c3H
  0115f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172640
  01166	e8 00 00 00 00	 call	 cckd_trace

; 5571 :                             trk, upos + i, l2.L2_len);
; 5572 : 
; 5573 :                 /* Relocate the track image somewhere else */
; 5574 :                 if ((rc = cckd_write_trkimg (dev, buf + i, (int)l2.L2_len, trk, flags)) < 0)

  0116b	0f b7 84 24 fc
	00 00 00	 movzx	 eax, WORD PTR l2$[rsp+4]
  01173	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  01178	48 8d 8c 0c 30
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rcx]
  01180	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR flags$[rsp]
  01187	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  0118b	44 8b 8c 24 a0
	00 00 00	 mov	 r9d, DWORD PTR trk$[rsp]
  01193	44 8b c0	 mov	 r8d, eax
  01196	48 8b d1	 mov	 rdx, rcx
  01199	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011a1	e8 00 00 00 00	 call	 cckd_write_trkimg
  011a6	89 84 24 d4 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  011ad	83 bc 24 d4 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  011b5	7d 2e		 jge	 SHORT $LN68@cckd_gc_pe

; 5575 :                     return GC_PERC_ERROR();

  011b7	c7 44 24 20 c7
	15 00 00	 mov	 DWORD PTR [rsp+32], 5575 ; 000015c7H
  011bf	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172642
  011c6	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR moved$[rsp]
  011ce	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  011d3	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011db	e8 00 00 00 00	 call	 cckd_gc_perc_error
  011e0	e9 60 02 00 00	 jmp	 $LN1@cckd_gc_pe
$LN68@cckd_gc_pe:

; 5576 :                 a += rc;

  011e5	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
  011ec	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR a$[rsp]
  011f3	03 c8		 add	 ecx, eax
  011f5	8b c1		 mov	 eax, ecx
  011f7	89 84 24 b0 00
	00 00		 mov	 DWORD PTR a$[rsp], eax
$LN60@cckd_gc_pe:

; 5577 :             }
; 5578 :         } /* for each space in the used space */

  011fe	e9 96 fa ff ff	 jmp	 $LN24@cckd_gc_pe
$LN25@cckd_gc_pe:

; 5579 : 
; 5580 :         /* Set `after' to 1 if first time space was relocated after */
; 5581 :         after += after ? a : (a > 0);

  01203	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR after$[rsp], 0
  0120b	74 10		 je	 SHORT $LN89@cckd_gc_pe
  0120d	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR a$[rsp]
  01214	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv762[rsp], eax
  0121b	eb 30		 jmp	 SHORT $LN90@cckd_gc_pe
$LN89@cckd_gc_pe:
  0121d	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR a$[rsp], 0
  01225	7e 0d		 jle	 SHORT $LN87@cckd_gc_pe
  01227	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv760[rsp], 1
  01232	eb 0b		 jmp	 SHORT $LN88@cckd_gc_pe
$LN87@cckd_gc_pe:
  01234	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv760[rsp], 0
$LN88@cckd_gc_pe:
  0123f	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv760[rsp]
  01246	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv762[rsp], eax
$LN90@cckd_gc_pe:
  0124d	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR tv762[rsp]
  01254	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR after$[rsp]
  0125b	03 c8		 add	 ecx, eax
  0125d	8b c1		 mov	 eax, ecx
  0125f	89 84 24 b4 00
	00 00		 mov	 DWORD PTR after$[rsp], eax

; 5582 :         moved += i;

  01266	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  0126a	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR moved$[rsp]
  01271	03 c8		 add	 ecx, eax
  01273	8b c1		 mov	 eax, ecx
  01275	89 84 24 84 00
	00 00		 mov	 DWORD PTR moved$[rsp], eax

; 5583 : 
; 5584 :         cckdblk.stats_gcolmoves++;

  0127c	48 8b 05 e0 02
	00 00		 mov	 rax, QWORD PTR cckdblk+736
  01283	48 ff c0	 inc	 rax
  01286	48 89 05 e0 02
	00 00		 mov	 QWORD PTR cckdblk+736, rax

; 5585 :         cckdblk.stats_gcolbytes += i;

  0128d	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  01292	48 8b 0d e8 02
	00 00		 mov	 rcx, QWORD PTR cckdblk+744
  01299	48 03 c8	 add	 rcx, rax
  0129c	48 8b c1	 mov	 rax, rcx
  0129f	48 89 05 e8 02
	00 00		 mov	 QWORD PTR cckdblk+744, rax

; 5586 : 
; 5587 :         release_lock( &cckd->filelock );

  012a6	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  012ab	48 83 c0 10	 add	 rax, 16
  012af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172643
  012b6	48 8b c8	 mov	 rcx, rax
  012b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5588 : 
; 5589 :     } /* while (moved < size) */

  012bf	e9 83 f1 ff ff	 jmp	 $LN5@cckd_gc_pe
$LN6@cckd_gc_pe:

; 5590 : 
; 5591 :     CCKD_TRACE( "gcperc moved %d 1st 0x%x nbr %u", moved,

  012c4	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  012c9	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  012cd	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  012d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  012d9	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  012dd	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  012e4	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  012e9	8b 84 02 00 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax+512]
  012f0	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  012f4	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  012f9	8b 84 08 f4 01
	00 00		 mov	 eax, DWORD PTR [rax+rcx+500]
  01300	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  01304	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR moved$[rsp]
  0130b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0130f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172644
  01316	4c 8b 84 24 50
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  0131e	ba d8 15 00 00	 mov	 edx, 5592		; 000015d8H
  01323	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172645
  0132a	e8 00 00 00 00	 call	 cckd_trace

; 5592 :                 cckd->cdevhdr[cckd->sfn].free_off,cckd->cdevhdr[cckd->sfn].free_num);
; 5593 :     // "Collected %u bytes of garbage for CCKD%s file[%d] %1d:%04X %s..."
; 5594 :     if (cckdblk.gcmsgs)

  0132f	83 3d 4c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+588, 0
  01336	0f 84 02 01 00
	00		 je	 $LN69@cckd_gc_pe

; 5595 :         WRMSG( HHC00386, "I", moved, "", cckd->sfn, LCSS_DEVNUM, cckd_sf_name( dev, cckd->sfn ));

  0133c	48 83 bc 24 50
	01 04 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01345	74 15		 je	 SHORT $LN91@cckd_gc_pe
  01347	48 8b 84 24 50
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  0134f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01353	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv799[rsp], eax
  0135a	eb 0b		 jmp	 SHORT $LN92@cckd_gc_pe
$LN91@cckd_gc_pe:
  0135c	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv799[rsp], 0
$LN92@cckd_gc_pe:
  01367	48 83 bc 24 50
	01 04 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01370	74 17		 je	 SHORT $LN93@cckd_gc_pe
  01372	48 8b 84 24 50
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  0137a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0137e	d1 f8		 sar	 eax, 1
  01380	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv805[rsp], eax
  01387	eb 0b		 jmp	 SHORT $LN94@cckd_gc_pe
$LN93@cckd_gc_pe:
  01389	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv805[rsp], 0
$LN94@cckd_gc_pe:
  01394	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  01399	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  0139c	48 8b 8c 24 50
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  013a4	e8 00 00 00 00	 call	 cckd_sf_name
  013a9	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv791[rsp], rax
  013b1	b9 01 00 00 00	 mov	 ecx, 1
  013b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013bc	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv791[rsp]
  013c4	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  013c9	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv799[rsp]
  013d0	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  013d4	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv805[rsp]
  013db	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  013df	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  013e4	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  013e7	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  013eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172647
  013f2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  013f7	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR moved$[rsp]
  013fe	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01402	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172648
  01409	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0140e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172649
  01415	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0141a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0141f	41 b9 03 00 00
	00		 mov	 r9d, 3
  01425	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172650
  0142c	ba db 15 00 00	 mov	 edx, 5595		; 000015dbH
  01431	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172651
  01438	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN69@cckd_gc_pe:

; 5596 :     return moved;

  0143e	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR moved$[rsp]
$LN1@cckd_gc_pe:

; 5597 : } /* end function cckd_gc_percolate */

  01445	48 8b 8c 24 30
	01 04 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0144d	48 33 cc	 xor	 rcx, rsp
  01450	e8 00 00 00 00	 call	 __security_check_cookie
  01455	48 81 c4 48 01
	04 00		 add	 rsp, 262472		; 00040148H
  0145c	c3		 ret	 0
cckd_gc_percolate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
tv74 = 96
tv86 = 100
tv92 = 104
tv146 = 108
tv152 = 112
tv174 = 116
tv180 = 120
cckd$ = 128
gc$ = 136
tv75 = 144
tv135 = 152
tv163 = 160
dev$ = 192
cckd_gc_rpt_state PROC

; 5137 : {

$LN24:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 5138 :     CCKD_EXT*  cckd;
; 5139 :     int        gc;
; 5140 : 
; 5141 :     if (dev->cckd64)

  0000c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00014	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0001b	24 01		 and	 al, 1
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 12		 je	 SHORT $LN4@cckd_gc_rp

; 5142 :     {
; 5143 :         cckd64_gc_rpt_state( dev );

  00024	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 cckd64_gc_rpt_state

; 5144 :         return;

  00031	e9 31 03 00 00	 jmp	 $LN1@cckd_gc_rp
$LN4@cckd_gc_rp:

; 5145 :     }
; 5146 : 
; 5147 :     cckd = dev->cckd_ext;

  00036	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003e	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00045	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 5148 : 
; 5149 :     /* Retrieve and report garbage collector state, but ONLY if
; 5150 :        the image is over 100MB in size. This prevents "scaring"
; 5151 :        the user about SEVERELY fragmented files when the file
; 5152 :        is too small to be much of a concern, as is usually the
; 5153 :        case with e.g. shadow files.
; 5154 :     */
; 5155 :     if (cckd->cdevhdr->cdh_size < (100 * _1M))

  0004d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00055	81 b8 ec 01 00
	00 00 00 40 06	 cmp	 DWORD PTR [rax+492], 104857600 ; 06400000H
  0005f	73 05		 jae	 SHORT $LN5@cckd_gc_rp

; 5156 :         return;

  00061	e9 01 03 00 00	 jmp	 $LN1@cckd_gc_rp
$LN5@cckd_gc_rp:

; 5157 : 
; 5158 :     gc = cckd_gc_state( dev );

  00066	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0006e	e8 00 00 00 00	 call	 cckd_gc_state
  00073	89 84 24 88 00
	00 00		 mov	 DWORD PTR gc$[rsp], eax

; 5159 : 
; 5160 :     switch (gc)

  0007a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR gc$[rsp]
  00081	89 44 24 60	 mov	 DWORD PTR tv74[rsp], eax
  00085	83 7c 24 60 00	 cmp	 DWORD PTR tv74[rsp], 0
  0008a	74 22		 je	 SHORT $LN6@cckd_gc_rp
  0008c	83 7c 24 60 01	 cmp	 DWORD PTR tv74[rsp], 1
  00091	74 1b		 je	 SHORT $LN7@cckd_gc_rp
  00093	83 7c 24 60 02	 cmp	 DWORD PTR tv74[rsp], 2
  00098	0f 84 fa 00 00
	00		 je	 $LN8@cckd_gc_rp
  0009e	83 7c 24 60 03	 cmp	 DWORD PTR tv74[rsp], 3
  000a3	0f 84 d9 01 00
	00		 je	 $LN9@cckd_gc_rp
  000a9	e9 b9 02 00 00	 jmp	 $LN10@cckd_gc_rp
$LN6@cckd_gc_rp:
$LN7@cckd_gc_rp:

; 5161 :     {
; 5162 :         case 0:     // critical!
; 5163 :         case 1:     // severe
; 5164 : 
; 5165 :             // "%1d:%04X CCKD%s image %s is SEVERELY fragmented!"
; 5166 :             WRMSG( HHC00387, "W", LCSS_DEVNUM, "",

  000ae	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000b7	74 12		 je	 SHORT $LN12@cckd_gc_rp
  000b9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000c5	89 44 24 64	 mov	 DWORD PTR tv86[rsp], eax
  000c9	eb 08		 jmp	 SHORT $LN13@cckd_gc_rp
$LN12@cckd_gc_rp:
  000cb	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN13@cckd_gc_rp:
  000d3	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000dc	74 14		 je	 SHORT $LN14@cckd_gc_rp
  000de	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000ea	d1 f8		 sar	 eax, 1
  000ec	89 44 24 68	 mov	 DWORD PTR tv92[rsp], eax
  000f0	eb 08		 jmp	 SHORT $LN15@cckd_gc_rp
$LN14@cckd_gc_rp:
  000f2	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN15@cckd_gc_rp:
  000fa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00102	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00105	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0010d	e8 00 00 00 00	 call	 cckd_sf_name
  00112	48 8b c8	 mov	 rcx, rax
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trimloc
  0011b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  00123	b9 01 00 00 00	 mov	 ecx, 1
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv75[rsp]
  00136	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172373
  00142	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00147	8b 4c 24 64	 mov	 ecx, DWORD PTR tv86[rsp]
  0014b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0014f	8b 4c 24 68	 mov	 ecx, DWORD PTR tv92[rsp]
  00153	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172374
  0015e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00163	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172375
  0016a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0016f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00174	41 b9 03 00 00
	00		 mov	 r9d, 3
  0017a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172376
  00181	ba 2f 14 00 00	 mov	 edx, 5167		; 0000142fH
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172377
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5167 :                 TRIMLOC( cckd_sf_name( dev, cckd->sfn )));
; 5168 :             break;

  00193	e9 cf 01 00 00	 jmp	 $LN2@cckd_gc_rp
$LN8@cckd_gc_rp:

; 5169 : 
; 5170 :         case 2:     // moderate
; 5171 : 
; 5172 :             // "%1d:%04X CCKD%s image %s is moderately fragmented"
; 5173 :             WRMSG( HHC00388, "W", LCSS_DEVNUM, "",

  00198	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001a1	74 12		 je	 SHORT $LN16@cckd_gc_rp
  001a3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ab	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001af	89 44 24 6c	 mov	 DWORD PTR tv146[rsp], eax
  001b3	eb 08		 jmp	 SHORT $LN17@cckd_gc_rp
$LN16@cckd_gc_rp:
  001b5	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv146[rsp], 0
$LN17@cckd_gc_rp:
  001bd	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001c6	74 14		 je	 SHORT $LN18@cckd_gc_rp
  001c8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001d4	d1 f8		 sar	 eax, 1
  001d6	89 44 24 70	 mov	 DWORD PTR tv152[rsp], eax
  001da	eb 08		 jmp	 SHORT $LN19@cckd_gc_rp
$LN18@cckd_gc_rp:
  001dc	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN19@cckd_gc_rp:
  001e4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  001ec	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  001ef	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f7	e8 00 00 00 00	 call	 cckd_sf_name
  001fc	48 8b c8	 mov	 rcx, rax
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trimloc
  00205	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
  0020d	b9 01 00 00 00	 mov	 ecx, 1
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00218	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv135[rsp]
  00220	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00225	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172379
  0022c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00231	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv146[rsp]
  00235	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00239	8b 4c 24 70	 mov	 ecx, DWORD PTR tv152[rsp]
  0023d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172380
  00248	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0024d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172381
  00254	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00259	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00264	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172382
  0026b	ba 36 14 00 00	 mov	 edx, 5174		; 00001436H
  00270	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172383
  00277	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5174 :                 TRIMLOC( cckd_sf_name( dev, cckd->sfn )));
; 5175 :             break;

  0027d	e9 e5 00 00 00	 jmp	 $LN2@cckd_gc_rp
$LN9@cckd_gc_rp:

; 5176 : 
; 5177 :         case 3:     // light
; 5178 : 
; 5179 :             // "%1d:%04X CCKD%s image %s is slightly fragmented"
; 5180 :             WRMSG( HHC00389, "I", LCSS_DEVNUM, "",

  00282	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0028b	74 12		 je	 SHORT $LN20@cckd_gc_rp
  0028d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00295	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00299	89 44 24 74	 mov	 DWORD PTR tv174[rsp], eax
  0029d	eb 08		 jmp	 SHORT $LN21@cckd_gc_rp
$LN20@cckd_gc_rp:
  0029f	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN21@cckd_gc_rp:
  002a7	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002b0	74 14		 je	 SHORT $LN22@cckd_gc_rp
  002b2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ba	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002be	d1 f8		 sar	 eax, 1
  002c0	89 44 24 78	 mov	 DWORD PTR tv180[rsp], eax
  002c4	eb 08		 jmp	 SHORT $LN23@cckd_gc_rp
$LN22@cckd_gc_rp:
  002c6	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN23@cckd_gc_rp:
  002ce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  002d6	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  002d9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e1	e8 00 00 00 00	 call	 cckd_sf_name
  002e6	48 8b c8	 mov	 rcx, rax
  002e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trimloc
  002ef	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv163[rsp], rax
  002f7	b9 01 00 00 00	 mov	 ecx, 1
  002fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00302	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv163[rsp]
  0030a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0030f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172385
  00316	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0031b	8b 4c 24 74	 mov	 ecx, DWORD PTR tv174[rsp]
  0031f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00323	8b 4c 24 78	 mov	 ecx, DWORD PTR tv180[rsp]
  00327	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0032b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172386
  00332	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00337	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172387
  0033e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00343	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00348	41 b9 03 00 00
	00		 mov	 r9d, 3
  0034e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172388
  00355	ba 3d 14 00 00	 mov	 edx, 5181		; 0000143dH
  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172389
  00361	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@cckd_gc_rp:
$LN2@cckd_gc_rp:
$LN1@cckd_gc_rp:

; 5181 :                 TRIMLOC( cckd_sf_name( dev, cckd->sfn )));
; 5182 :             break;
; 5183 : 
; 5184 :         default:    // less than light
; 5185 : 
; 5186 :             break;  // (don't bother reporting it)
; 5187 :     }
; 5188 : }

  00367	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0036e	c3		 ret	 0
cckd_gc_rpt_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
gc$ = 32
size$ = 40
cckd$ = 48
fsiz$ = 56
dev$ = 80
cckd_gc_state PROC

; 5194 : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5195 :     CCKD_EXT*  cckd;                    /* -> cckd extension         */
; 5196 :     S64        size, fsiz;              /* File size, free size      */
; 5197 :     int        gc;                      /* Garbage collection state  */
; 5198 : 
; 5199 :     if (dev->cckd64)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	74 0f		 je	 SHORT $LN2@cckd_gc_st

; 5200 :         return cckd64_gc_state( dev );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd64_gc_state
  00028	e9 92 01 00 00	 jmp	 $LN1@cckd_gc_st
$LN2@cckd_gc_st:

; 5201 : 
; 5202 :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 30	 mov	 QWORD PTR cckd$[rsp], rax

; 5203 : 
; 5204 :     /* Determine garbage state */
; 5205 :     size = (S64) cckd->cdevhdr[ cckd->sfn ].cdh_size;

  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00043	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00047	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00053	8b 84 01 ec 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+492]
  0005a	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 5206 :     fsiz = (S64) cckd->cdevhdr[ cckd->sfn ].free_total;

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00064	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00068	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0006f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00074	8b 84 01 f8 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+504]
  0007b	48 89 44 24 38	 mov	 QWORD PTR fsiz$[rsp], rax

; 5207 : 
; 5208 :     if      (fsiz >= (size = size/2)) gc = 0; // critical   50% - 100%

  00080	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  00085	48 99		 cdq
  00087	48 2b c2	 sub	 rax, rdx
  0008a	48 d1 f8	 sar	 rax, 1
  0008d	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax
  00092	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  00097	48 39 44 24 38	 cmp	 QWORD PTR fsiz$[rsp], rax
  0009c	7c 0d		 jl	 SHORT $LN3@cckd_gc_st
  0009e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR gc$[rsp], 0
  000a6	e9 80 00 00 00	 jmp	 $LN4@cckd_gc_st
$LN3@cckd_gc_st:

; 5209 :     else if (fsiz >= (size = size/2)) gc = 1; // severe     25% - 50%

  000ab	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000b0	48 99		 cdq
  000b2	48 2b c2	 sub	 rax, rdx
  000b5	48 d1 f8	 sar	 rax, 1
  000b8	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax
  000bd	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000c2	48 39 44 24 38	 cmp	 QWORD PTR fsiz$[rsp], rax
  000c7	7c 0a		 jl	 SHORT $LN5@cckd_gc_st
  000c9	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR gc$[rsp], 1
  000d1	eb 58		 jmp	 SHORT $LN6@cckd_gc_st
$LN5@cckd_gc_st:

; 5210 :     else if (fsiz >= (size = size/2)) gc = 2; // moderate 12.5% - 25%

  000d3	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000d8	48 99		 cdq
  000da	48 2b c2	 sub	 rax, rdx
  000dd	48 d1 f8	 sar	 rax, 1
  000e0	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax
  000e5	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000ea	48 39 44 24 38	 cmp	 QWORD PTR fsiz$[rsp], rax
  000ef	7c 0a		 jl	 SHORT $LN7@cckd_gc_st
  000f1	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR gc$[rsp], 2
  000f9	eb 30		 jmp	 SHORT $LN8@cckd_gc_st
$LN7@cckd_gc_st:

; 5211 :     else if (fsiz >= (size = size/2)) gc = 3; // light     6.3% - 12.5%

  000fb	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  00100	48 99		 cdq
  00102	48 2b c2	 sub	 rax, rdx
  00105	48 d1 f8	 sar	 rax, 1
  00108	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax
  0010d	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  00112	48 39 44 24 38	 cmp	 QWORD PTR fsiz$[rsp], rax
  00117	7c 0a		 jl	 SHORT $LN9@cckd_gc_st
  00119	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR gc$[rsp], 3
  00121	eb 08		 jmp	 SHORT $LN10@cckd_gc_st
$LN9@cckd_gc_st:

; 5212 :     else                              gc = 4; // none        0% - 6.3%

  00123	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR gc$[rsp], 4
$LN10@cckd_gc_st:
$LN8@cckd_gc_st:
$LN6@cckd_gc_st:
$LN4@cckd_gc_st:

; 5213 : 
; 5214 :     /* Adjust the state based on the number of free spaces */
; 5215 :     if (cckd->cdevhdr[ cckd->sfn ].free_num >  800 && gc > 0) gc--;

  0012b	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00130	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00134	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0013b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00140	81 bc 01 00 02
	00 00 20 03 00
	00		 cmp	 DWORD PTR [rcx+rax+512], 800 ; 00000320H
  0014b	7e 11		 jle	 SHORT $LN11@cckd_gc_st
  0014d	83 7c 24 20 00	 cmp	 DWORD PTR gc$[rsp], 0
  00152	7e 0a		 jle	 SHORT $LN11@cckd_gc_st
  00154	8b 44 24 20	 mov	 eax, DWORD PTR gc$[rsp]
  00158	ff c8		 dec	 eax
  0015a	89 44 24 20	 mov	 DWORD PTR gc$[rsp], eax
$LN11@cckd_gc_st:

; 5216 :     if (cckd->cdevhdr[ cckd->sfn ].free_num > 1800 && gc > 0) gc--;

  0015e	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00163	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00167	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0016e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00173	81 bc 01 00 02
	00 00 08 07 00
	00		 cmp	 DWORD PTR [rcx+rax+512], 1800 ; 00000708H
  0017e	7e 11		 jle	 SHORT $LN12@cckd_gc_st
  00180	83 7c 24 20 00	 cmp	 DWORD PTR gc$[rsp], 0
  00185	7e 0a		 jle	 SHORT $LN12@cckd_gc_st
  00187	8b 44 24 20	 mov	 eax, DWORD PTR gc$[rsp]
  0018b	ff c8		 dec	 eax
  0018d	89 44 24 20	 mov	 DWORD PTR gc$[rsp], eax
$LN12@cckd_gc_st:

; 5217 :     if (cckd->cdevhdr[ cckd->sfn ].free_num > 3000)           gc = 0;

  00191	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00196	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0019a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001a1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  001a6	81 bc 01 00 02
	00 00 b8 0b 00
	00		 cmp	 DWORD PTR [rcx+rax+512], 3000 ; 00000bb8H
  001b1	7e 08		 jle	 SHORT $LN13@cckd_gc_st
  001b3	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR gc$[rsp], 0
$LN13@cckd_gc_st:

; 5218 : 
; 5219 :     return gc;

  001bb	8b 44 24 20	 mov	 eax, DWORD PTR gc$[rsp]
$LN1@cckd_gc_st:

; 5220 : }

  001bf	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c3	c3		 ret	 0
cckd_gc_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
gc$ = 32
rc$ = 36
cckd$ = 40
size$ = 48
tv260 = 56
tv264 = 64
tv172 = 72
dev$ = 96
tv_now$ = 104
cckd_gcol_dev PROC

; 5226 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5227 : int             rc;                     /* Return code               */
; 5228 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 5229 : U64             size;                   /* Percolate size            */
; 5230 : int             gc;                     /* Garbage collection state  */
; 5231 : 
; 5232 :     if (dev->cckd64)

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00013	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0001a	24 01		 and	 al, 1
  0001c	0f b6 c0	 movzx	 eax, al
  0001f	85 c0		 test	 eax, eax
  00021	74 14		 je	 SHORT $LN4@cckd_gcol_

; 5233 :     {
; 5234 :         cckd64_gcol_dev( dev, tv_now );

  00023	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv_now$[rsp]
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0002d	e8 00 00 00 00	 call	 cckd64_gcol_dev

; 5235 :         return;

  00032	e9 06 04 00 00	 jmp	 $LN1@cckd_gcol_
$LN4@cckd_gcol_:

; 5236 :     }
; 5237 : 
; 5238 :     cckd = dev->cckd_ext;

  00037	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00043	48 89 44 24 28	 mov	 QWORD PTR cckd$[rsp], rax

; 5239 : 
; 5240 :     obtain_lock (&cckd->cckdiolock);

  00048	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0004d	48 83 c0 18	 add	 rax, 24
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172424
  00058	48 8b c8	 mov	 rcx, rax
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5241 :     {
; 5242 :         /* Bypass if merging or stopping */
; 5243 :         if (cckd->merging || cckd->stopping)

  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00066	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00069	c1 e8 05	 shr	 eax, 5
  0006c	83 e0 01	 and	 eax, 1
  0006f	85 c0		 test	 eax, eax
  00071	75 12		 jne	 SHORT $LN6@cckd_gcol_
  00073	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00078	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0007b	c1 e8 06	 shr	 eax, 6
  0007e	83 e0 01	 and	 eax, 1
  00081	85 c0		 test	 eax, eax
  00083	74 1e		 je	 SHORT $LN5@cckd_gcol_
$LN6@cckd_gcol_:

; 5244 :         {
; 5245 :             release_lock (&cckd->cckdiolock);

  00085	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0008a	48 83 c0 18	 add	 rax, 24
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172427
  00095	48 8b c8	 mov	 rcx, rax
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5246 :             return;

  0009e	e9 9a 03 00 00	 jmp	 $LN1@cckd_gcol_
$LN5@cckd_gcol_:

; 5247 :         }
; 5248 : 
; 5249 :         /* Bypass if not opened read-write */
; 5250 :         if (cckd->open[cckd->sfn] != CCKD_OPEN_RW)

  000a3	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  000a8	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  000ac	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  000b1	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  000b9	83 f8 03	 cmp	 eax, 3
  000bc	74 1e		 je	 SHORT $LN7@cckd_gcol_

; 5251 :         {
; 5252 :             release_lock (&cckd->cckdiolock);

  000be	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  000c3	48 83 c0 18	 add	 rax, 24
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172429
  000ce	48 8b c8	 mov	 rcx, rax
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5253 :             return;

  000d7	e9 61 03 00 00	 jmp	 $LN1@cckd_gcol_
$LN7@cckd_gcol_:

; 5254 :         }
; 5255 : 
; 5256 :         /* Free newbuf if it hasn't been used */
; 5257 :         if (!cckd->cckdioact && !cckd->bufused && cckd->newbuf)

  000dc	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  000e1	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000e4	c1 e8 02	 shr	 eax, 2
  000e7	83 e0 01	 and	 eax, 1
  000ea	85 c0		 test	 eax, eax
  000ec	75 41		 jne	 SHORT $LN8@cckd_gcol_
  000ee	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  000f3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000f6	c1 e8 03	 shr	 eax, 3
  000f9	83 e0 01	 and	 eax, 1
  000fc	85 c0		 test	 eax, eax
  000fe	75 2f		 jne	 SHORT $LN8@cckd_gcol_
  00100	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00105	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0010a	74 23		 je	 SHORT $LN8@cckd_gcol_

; 5258 :             cckd->newbuf = cckd_free (dev, "newbuf", cckd->newbuf);

  0010c	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00111	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00115	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172431
  0011c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00121	e8 00 00 00 00	 call	 cckd_free
  00126	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  0012b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN8@cckd_gcol_:

; 5259 : 
; 5260 :         cckd->bufused = 0;

  0012f	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00134	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00137	83 e0 f7	 and	 eax, -9			; fffffff7H
  0013a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  0013f	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 5261 : 
; 5262 :         /* If OPENED bit not on then flush if updated */
; 5263 :         if (!(cckd->cdevhdr[cckd->sfn].cdh_opts & CCKD_OPT_OPENED))

  00142	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00147	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0014b	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00152	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  00157	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  0015f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00164	85 c0		 test	 eax, eax
  00166	75 3a		 jne	 SHORT $LN9@cckd_gcol_

; 5264 :         {
; 5265 :             if (cckd->updated) cckd_flush_cache (dev);

  00168	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0016d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00170	c1 e8 04	 shr	 eax, 4
  00173	83 e0 01	 and	 eax, 1
  00176	85 c0		 test	 eax, eax
  00178	74 0a		 je	 SHORT $LN10@cckd_gcol_
  0017a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0017f	e8 00 00 00 00	 call	 cckd_flush_cache
$LN10@cckd_gcol_:

; 5266 :             release_lock (&cckd->cckdiolock);

  00184	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00189	48 83 c0 18	 add	 rax, 24
  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172434
  00194	48 8b c8	 mov	 rcx, rax
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5267 :             return;

  0019d	e9 9b 02 00 00	 jmp	 $LN1@cckd_gcol_
$LN9@cckd_gcol_:

; 5268 :         }
; 5269 : 
; 5270 :         /* Determine garbage state */
; 5271 :         gc = cckd_gc_state( dev );

  001a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001a7	e8 00 00 00 00	 call	 cckd_gc_state
  001ac	89 44 24 20	 mov	 DWORD PTR gc$[rsp], eax

; 5272 : 
; 5273 :         /* Set the size */
; 5274 :         if (cckdblk.gcparm > 0) size = gctab[gc] << cckdblk.gcparm;

  001b0	83 3d 48 00 00
	00 00		 cmp	 DWORD PTR cckdblk+72, 0
  001b7	7e 2d		 jle	 SHORT $LN11@cckd_gcol_
  001b9	48 63 44 24 20	 movsxd	 rax, DWORD PTR gc$[rsp]
  001be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gctab
  001c5	48 89 4c 24 38	 mov	 QWORD PTR tv260[rsp], rcx
  001ca	8b 15 48 00 00
	00		 mov	 edx, DWORD PTR cckdblk+72
  001d0	0f b6 ca	 movzx	 ecx, dl
  001d3	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv260[rsp]
  001d8	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  001db	d3 e0		 shl	 eax, cl
  001dd	48 98		 cdqe
  001df	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax
  001e4	eb 5a		 jmp	 SHORT $LN12@cckd_gcol_
$LN11@cckd_gcol_:

; 5275 :         else if (cckdblk.gcparm < 0) size = gctab[gc] >> abs(cckdblk.gcparm);

  001e6	83 3d 48 00 00
	00 00		 cmp	 DWORD PTR cckdblk+72, 0
  001ed	7d 3c		 jge	 SHORT $LN13@cckd_gcol_
  001ef	48 63 44 24 20	 movsxd	 rax, DWORD PTR gc$[rsp]
  001f4	48 89 44 24 48	 mov	 QWORD PTR tv172[rsp], rax
  001f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gctab
  00200	48 89 4c 24 40	 mov	 QWORD PTR tv264[rsp], rcx
  00205	8b 0d 48 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+72
  0020b	e8 00 00 00 00	 call	 abs
  00210	0f b6 c8	 movzx	 ecx, al
  00213	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv264[rsp]
  00218	48 8b 44 24 48	 mov	 rax, QWORD PTR tv172[rsp]
  0021d	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00220	d3 f8		 sar	 eax, cl
  00222	48 98		 cdqe
  00224	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax
  00229	eb 15		 jmp	 SHORT $LN14@cckd_gcol_
$LN13@cckd_gcol_:

; 5276 :         else size = gctab[gc];

  0022b	48 63 44 24 20	 movsxd	 rax, DWORD PTR gc$[rsp]
  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gctab
  00237	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  0023b	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax
$LN14@cckd_gcol_:
$LN12@cckd_gcol_:

; 5277 : 
; 5278 :         if (size > cckd->cdevhdr[cckd->sfn].cdh_used >> SHIFT_1K)

  00240	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00245	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00249	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00250	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  00255	8b 84 01 f0 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+496]
  0025c	c1 e8 0a	 shr	 eax, 10
  0025f	8b c0		 mov	 eax, eax
  00261	48 39 44 24 30	 cmp	 QWORD PTR size$[rsp], rax
  00266	76 26		 jbe	 SHORT $LN15@cckd_gcol_

; 5279 :             size = cckd->cdevhdr[cckd->sfn].cdh_used >> SHIFT_1K;

  00268	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0026d	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00271	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00278	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  0027d	8b 84 01 f0 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+496]
  00284	c1 e8 0a	 shr	 eax, 10
  00287	8b c0		 mov	 eax, eax
  00289	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax
$LN15@cckd_gcol_:

; 5280 :         if (size < 64)

  0028e	48 83 7c 24 30
	40		 cmp	 QWORD PTR size$[rsp], 64 ; 00000040H
  00294	73 09		 jae	 SHORT $LN16@cckd_gcol_

; 5281 :             size = 64;

  00296	48 c7 44 24 30
	40 00 00 00	 mov	 QWORD PTR size$[rsp], 64 ; 00000040H
$LN16@cckd_gcol_:

; 5282 :     }
; 5283 :     release_lock (&cckd->cckdiolock);

  0029f	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  002a4	48 83 c0 18	 add	 rax, 24
  002a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172441
  002af	48 8b c8	 mov	 rcx, rax
  002b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5284 : 
; 5285 :     /* Call the garbage collector */
; 5286 :     cckd_gc_percolate( dev, size );

  002b8	48 8b 54 24 30	 mov	 rdx, QWORD PTR size$[rsp]
  002bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002c2	e8 00 00 00 00	 call	 cckd_gc_percolate

; 5287 : 
; 5288 :     /* Schedule any updated tracks to be written */
; 5289 :     obtain_lock (&cckd->cckdiolock);

  002c7	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  002cc	48 83 c0 18	 add	 rax, 24
  002d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172442
  002d7	48 8b c8	 mov	 rcx, rax
  002da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5290 :     {
; 5291 :         cckd_flush_cache (dev);

  002e0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002e5	e8 00 00 00 00	 call	 cckd_flush_cache
$LN2@cckd_gcol_:

; 5292 : 
; 5293 :         while (cckdblk.fsync && cckd->wrpending)

  002ea	83 3d 5c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+604, 0
  002f1	74 53		 je	 SHORT $LN3@cckd_gcol_
  002f3	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  002f8	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  002fc	74 48		 je	 SHORT $LN3@cckd_gcol_

; 5294 :         {
; 5295 :             cckd->cckdwaiters++;

  002fe	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00303	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00306	ff c0		 inc	 eax
  00308	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  0030d	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 5296 :             {
; 5297 :                 wait_condition (&cckd->cckdiocond, &cckd->cckdiolock);

  00310	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00315	48 83 c0 18	 add	 rax, 24
  00319	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  0031e	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00322	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172443
  00329	48 8b d0	 mov	 rdx, rax
  0032c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 5298 :             }
; 5299 :             cckd->cckdwaiters--;

  00332	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00337	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0033a	ff c8		 dec	 eax
  0033c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  00341	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 5300 :         }

  00344	eb a4		 jmp	 SHORT $LN2@cckd_gcol_
$LN3@cckd_gcol_:

; 5301 :     }
; 5302 :     release_lock (&cckd->cckdiolock);

  00346	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0034b	48 83 c0 18	 add	 rax, 24
  0034f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172444
  00356	48 8b c8	 mov	 rcx, rax
  00359	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5303 : 
; 5304 :     /* Sync the file */
; 5305 :     if (cckdblk.fsync && cckd->lastsync + 10 <= tv_now->tv_sec)

  0035f	83 3d 5c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+604, 0
  00366	74 7a		 je	 SHORT $LN17@cckd_gcol_
  00368	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0036d	8b 80 8c 00 00
	00		 mov	 eax, DWORD PTR [rax+140]
  00373	83 c0 0a	 add	 eax, 10
  00376	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv_now$[rsp]
  0037b	3b 01		 cmp	 eax, DWORD PTR [rcx]
  0037d	7f 63		 jg	 SHORT $LN17@cckd_gcol_

; 5306 :     {
; 5307 :         obtain_lock( &cckd->filelock );

  0037f	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00384	48 83 c0 10	 add	 rax, 16
  00388	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172446
  0038f	48 8b c8	 mov	 rcx, rax
  00392	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5308 :         {
; 5309 :             rc = fdatasync (cckd->fd[cckd->sfn]);

  00398	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0039d	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  003a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  003a6	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  003ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__commit
  003b3	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 5310 :             cckd->lastsync = tv_now->tv_sec;

  003b7	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  003bc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv_now$[rsp]
  003c1	8b 09		 mov	 ecx, DWORD PTR [rcx]
  003c3	89 88 8c 00 00
	00		 mov	 DWORD PTR [rax+140], ecx

; 5311 :         }
; 5312 :         release_lock( &cckd->filelock );

  003c9	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  003ce	48 83 c0 10	 add	 rax, 16
  003d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172447
  003d9	48 8b c8	 mov	 rcx, rax
  003dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN17@cckd_gcol_:

; 5313 :     }
; 5314 : 
; 5315 :     /* Flush the free space */
; 5316 :     if (cckd->cdevhdr[cckd->sfn].free_num)

  003e2	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  003e7	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  003eb	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  003f2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  003f7	83 bc 01 00 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax+512], 0
  003ff	74 3c		 je	 SHORT $LN18@cckd_gcol_

; 5317 :     {
; 5318 :         obtain_lock( &cckd->filelock );

  00401	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00406	48 83 c0 10	 add	 rax, 16
  0040a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172449
  00411	48 8b c8	 mov	 rcx, rax
  00414	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5319 :         {
; 5320 :             cckd_flush_space (dev);

  0041a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0041f	e8 00 00 00 00	 call	 cckd_flush_space

; 5321 :         }
; 5322 :         release_lock( &cckd->filelock );

  00424	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00429	48 83 c0 10	 add	 rax, 16
  0042d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172450
  00434	48 8b c8	 mov	 rcx, rax
  00437	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN18@cckd_gcol_:
$LN1@cckd_gcol_:

; 5323 :     }
; 5324 : }

  0043d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00441	c3		 ret	 0
cckd_gcol_dev ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
tv_now$ = 96
gcol$ = 104
dev$ = 112
tv78 = 120
tv83 = 124
tv131 = 128
tv137 = 132
tv156 = 136
tv161 = 140
tv257 = 144
tv262 = 148
gcs$ = 152
cckd$ = 160
tt_now$ = 168
tm$ = 176
__$ArrayPad$ = 192
arg$ = 224
cckd_gcol PROC

; 5012 : {

$LN26:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@cckd_gcol:

; 5013 : int             gcol;                   /* Identifier                */
; 5014 : DEVBLK         *dev;                    /* -> device block           */
; 5015 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 5016 : struct timeval  tv_now;                 /* Time-of-day (as timeval)  */
; 5017 : time_t          tt_now;                 /* Time-of-day (as time_t)   */
; 5018 : struct timespec tm;                     /* Time-of-day to wait       */
; 5019 : int             gcs;
; 5020 : 
; 5021 :     UNREFERENCED( arg );

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN4@cckd_gcol

; 5022 : 
; 5023 :     gettimeofday (&tv_now, NULL);

  00024	33 d2		 xor	 edx, edx
  00026	48 8d 4c 24 60	 lea	 rcx, QWORD PTR tv_now$[rsp]
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 5024 : 
; 5025 :     obtain_lock (&cckdblk.gclock);

  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172298
  00038	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5026 : 
; 5027 :     gcol = ++cckdblk.gca;

  00045	8b 05 3c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+60
  0004b	ff c0		 inc	 eax
  0004d	89 05 3c 00 00
	00		 mov	 DWORD PTR cckdblk+60, eax
  00053	8b 05 3c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+60
  00059	89 44 24 68	 mov	 DWORD PTR gcol$[rsp], eax

; 5028 : 
; 5029 :     /* Return without messages if too many already started */
; 5030 :     if (gcol > cckdblk.gcmax)

  0005d	8b 05 40 00 00
	00		 mov	 eax, DWORD PTR cckdblk+64
  00063	39 44 24 68	 cmp	 DWORD PTR gcol$[rsp], eax
  00067	0f 8e bd 01 00
	00		 jle	 $LN10@cckd_gcol

; 5031 :     {
; 5032 :         --cckdblk.gcs;

  0006d	8b 05 38 00 00
	00		 mov	 eax, DWORD PTR cckdblk+56
  00073	ff c8		 dec	 eax
  00075	89 05 38 00 00
	00		 mov	 DWORD PTR cckdblk+56, eax

; 5033 :         --cckdblk.gca;

  0007b	8b 05 3c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+60
  00081	ff c8		 dec	 eax
  00083	89 05 3c 00 00
	00		 mov	 DWORD PTR cckdblk+60, eax

; 5034 : 
; 5035 :         if (!cckdblk.gcs)

  00089	83 3d 38 00 00
	00 00		 cmp	 DWORD PTR cckdblk+56, 0
  00090	0f 85 a5 00 00
	00		 jne	 $LN11@cckd_gcol

; 5036 :         {
; 5037 :             if (!cckdblk.batch || cckdblk.batchml > 1)

  00096	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  0009c	83 e0 01	 and	 eax, 1
  0009f	85 c0		 test	 eax, eax
  000a1	74 0d		 je	 SHORT $LN14@cckd_gcol
  000a3	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  000aa	0f 8e 86 00 00
	00		 jle	 $LN13@cckd_gcol
$LN14@cckd_gcol:

; 5038 :                 // "Thread id "TIDPAT", prio %d, name '%s' ended"
; 5039 :                 LOG_THREAD_END( CCKD_GC_THREAD_NAME  );

  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  000b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172305
  000bd	8b c8		 mov	 ecx, eax
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  000c5	89 44 24 78	 mov	 DWORD PTR tv78[rsp], eax
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  000cf	89 44 24 7c	 mov	 DWORD PTR tv83[rsp], eax
  000d3	b9 01 00 00 00	 mov	 ecx, 1
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172304
  000e5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000ea	8b 4c 24 78	 mov	 ecx, DWORD PTR tv78[rsp]
  000ee	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f2	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv83[rsp]
  000f6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172306
  00101	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172307
  0010d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00112	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00117	41 b9 03 00 00
	00		 mov	 r9d, 3
  0011d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172308
  00124	ba af 13 00 00	 mov	 edx, 5039		; 000013afH
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172309
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@cckd_gcol:

; 5040 :         }

  00136	e9 c0 00 00 00	 jmp	 $LN12@cckd_gcol
$LN11@cckd_gcol:

; 5041 :         else
; 5042 :             if (!cckdblk.batch || cckdblk.batchml > 0)

  0013b	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00141	83 e0 01	 and	 eax, 1
  00144	85 c0		 test	 eax, eax
  00146	74 0d		 je	 SHORT $LN16@cckd_gcol
  00148	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR cckdblk+24, 0
  0014f	0f 8e a6 00 00
	00		 jle	 $LN15@cckd_gcol
$LN16@cckd_gcol:

; 5043 :                 // "Ending thread "TIDPAT" %s, pri=%d, started=%d, max=%d exceeded"
; 5044 :                 WRMSG( HHC00108, "W", TID_CAST( thread_id()), CCKD_GC_THREAD_NAME,

  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0015b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172312
  00162	8b c8		 mov	 ecx, eax
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  0016a	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv131[rsp], eax
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00177	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv137[rsp], eax
  0017e	b9 01 00 00 00	 mov	 ecx, 1
  00183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00189	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+64
  0018f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00193	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+56
  00199	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0019d	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv131[rsp]
  001a4	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172313
  001af	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001b4	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv137[rsp]
  001bb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172314
  001c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172315
  001d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172316
  001e9	ba b5 13 00 00	 mov	 edx, 5045		; 000013b5H
  001ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172317
  001f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN15@cckd_gcol:
$LN12@cckd_gcol:

; 5045 :                     get_thread_priority(), cckdblk.gcs, cckdblk.gcmax );
; 5046 : 
; 5047 :         release_lock( &cckdblk.gclock );

  001fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172318
  00202	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  00209	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5048 :         signal_condition( &cckdblk.termcond );  /* signal if last gcol thread ending before init. */

  0020f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172319
  00216	48 8d 0d 60 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+608
  0021d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 5049 :         return NULL;        /* back to the shadows again  */

  00223	33 c0		 xor	 eax, eax
  00225	e9 82 03 00 00	 jmp	 $LN1@cckd_gcol
$LN10@cckd_gcol:

; 5050 :     }
; 5051 : 
; 5052 :     if (!cckdblk.batch || cckdblk.batchml > 1)

  0022a	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00230	83 e0 01	 and	 eax, 1
  00233	85 c0		 test	 eax, eax
  00235	74 0d		 je	 SHORT $LN18@cckd_gcol
  00237	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  0023e	0f 8e 92 00 00
	00		 jle	 $LN17@cckd_gcol
$LN18@cckd_gcol:

; 5053 :         // "Thread id "TIDPAT", prio %d, name '%s' started"
; 5054 :         LOG_THREAD_BEGIN( CCKD_GC_THREAD_NAME  );

  00244	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0024a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172323
  00251	8b c8		 mov	 ecx, eax
  00253	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  00259	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv156[rsp], eax
  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00266	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv161[rsp], eax
  0026d	b9 01 00 00 00	 mov	 ecx, 1
  00272	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00278	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172322
  0027f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00284	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv156[rsp]
  0028b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0028f	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv161[rsp]
  00296	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0029a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172324
  002a1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172325
  002ad	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b7	41 b9 03 00 00
	00		 mov	 r9d, 3
  002bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172326
  002c4	ba be 13 00 00	 mov	 edx, 5054		; 000013beH
  002c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172327
  002d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@cckd_gcol:
$LN5@cckd_gcol:

; 5055 : 
; 5056 :     while (gcol <= cckdblk.gcmax)

  002d6	8b 05 40 00 00
	00		 mov	 eax, DWORD PTR cckdblk+64
  002dc	39 44 24 68	 cmp	 DWORD PTR gcol$[rsp], eax
  002e0	0f 8f bd 01 00
	00		 jg	 $LN6@cckd_gcol

; 5057 :     {
; 5058 :         // "Begin CCKD garbage collection"
; 5059 :         if (cckdblk.gcmsgs)

  002e6	83 3d 4c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+588, 0
  002ed	74 47		 je	 SHORT $LN19@cckd_gcol

; 5060 :             WRMSG( HHC00382, "I" );

  002ef	b9 01 00 00 00	 mov	 ecx, 1
  002f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172329
  00301	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00306	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172330
  0030d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00312	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00317	41 b9 03 00 00
	00		 mov	 r9d, 3
  0031d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172331
  00324	ba c4 13 00 00	 mov	 edx, 5060		; 000013c4H
  00329	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172332
  00330	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN19@cckd_gcol:

; 5061 : 
; 5062 :         /* Perform collection on each device */
; 5063 :         cckd_lock_devchain(0);

  00336	33 c9		 xor	 ecx, ecx
  00338	e8 00 00 00 00	 call	 cckd_lock_devchain

; 5064 :         {
; 5065 :             for (dev = cckdblk.dev1st; dev; dev = cckd->devnext)

  0033d	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  00344	48 89 44 24 70	 mov	 QWORD PTR dev$[rsp], rax
  00349	eb 10		 jmp	 SHORT $LN9@cckd_gcol
$LN7@cckd_gcol:
  0034b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00353	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00356	48 89 44 24 70	 mov	 QWORD PTR dev$[rsp], rax
$LN9@cckd_gcol:
  0035b	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00361	74 25		 je	 SHORT $LN8@cckd_gcol

; 5066 :             {
; 5067 :                 cckd = dev->cckd_ext;

  00363	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00368	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0036f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 5068 :                 cckd_gcol_dev( dev, &tv_now );

  00377	48 8d 54 24 60	 lea	 rdx, QWORD PTR tv_now$[rsp]
  0037c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00381	e8 00 00 00 00	 call	 cckd_gcol_dev

; 5069 :             }

  00386	eb c3		 jmp	 SHORT $LN7@cckd_gcol
$LN8@cckd_gcol:

; 5070 :         }
; 5071 :         cckd_unlock_devchain();

  00388	e8 00 00 00 00	 call	 cckd_unlock_devchain

; 5072 : 
; 5073 :         // "End CCKD garbage collection"
; 5074 :         if (cckdblk.gcmsgs)

  0038d	83 3d 4c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+588, 0
  00394	74 47		 je	 SHORT $LN20@cckd_gcol

; 5075 :             WRMSG( HHC00383, "I" );

  00396	b9 01 00 00 00	 mov	 ecx, 1
  0039b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172334
  003a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172335
  003b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003be	41 b9 03 00 00
	00		 mov	 r9d, 3
  003c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172336
  003cb	ba d3 13 00 00	 mov	 edx, 5075		; 000013d3H
  003d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172337
  003d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN20@cckd_gcol:

; 5076 : 
; 5077 :         /* If we're in manual on-demand mode, then we're done. */
; 5078 :         if (cckdblk.gcint <= 0)

  003dd	83 3d 44 00 00
	00 00		 cmp	 DWORD PTR cckdblk+68, 0
  003e4	7f 05		 jg	 SHORT $LN21@cckd_gcol

; 5079 :             break;

  003e6	e9 b8 00 00 00	 jmp	 $LN6@cckd_gcol
$LN21@cckd_gcol:

; 5080 : 
; 5081 :         /* Otherwise, wait a bit before starting the next cycle */
; 5082 : 
; 5083 :         // Get the time of day again for cckd_gcol_dev's file sync check
; 5084 :         gettimeofday (&tv_now, NULL);

  003eb	33 d2		 xor	 edx, edx
  003ed	48 8d 4c 24 60	 lea	 rcx, QWORD PTR tv_now$[rsp]
  003f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 5085 :         tt_now = tv_now.tv_sec + ((tv_now.tv_usec + 500000)/1000000);

  003f8	8b 44 24 64	 mov	 eax, DWORD PTR tv_now$[rsp+4]
  003fc	05 20 a1 07 00	 add	 eax, 500000		; 0007a120H
  00401	99		 cdq
  00402	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00407	f7 f9		 idiv	 ecx
  00409	8b 4c 24 60	 mov	 ecx, DWORD PTR tv_now$[rsp]
  0040d	03 c8		 add	 ecx, eax
  0040f	8b c1		 mov	 eax, ecx
  00411	48 98		 cdqe
  00413	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tt_now$[rsp], rax

; 5086 :         CCKD_TRACE( CCKD_GC_THREAD_NAME " wait %d seconds at %s",

  0041b	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR tt_now$[rsp]
  00423	e8 00 00 00 00	 call	 ctime
  00428	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0042d	8b 05 44 00 00
	00		 mov	 eax, DWORD PTR cckdblk+68
  00433	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00437	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172339
  0043e	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00443	ba df 13 00 00	 mov	 edx, 5087		; 000013dfH
  00448	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172340
  0044f	e8 00 00 00 00	 call	 cckd_trace

; 5087 :                     cckdblk.gcint, ctime (&tt_now));
; 5088 : 
; 5089 :         tm.tv_sec = tv_now.tv_sec + cckdblk.gcint;

  00454	8b 05 44 00 00
	00		 mov	 eax, DWORD PTR cckdblk+68
  0045a	8b 4c 24 60	 mov	 ecx, DWORD PTR tv_now$[rsp]
  0045e	03 c8		 add	 ecx, eax
  00460	8b c1		 mov	 eax, ecx
  00462	48 98		 cdqe
  00464	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tm$[rsp], rax

; 5090 :         tm.tv_nsec = tv_now.tv_usec * 1000;

  0046c	69 44 24 64 e8
	03 00 00	 imul	 eax, DWORD PTR tv_now$[rsp+4], 1000 ; 000003e8H
  00474	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tm$[rsp+8], eax

; 5091 :         timed_wait_condition( &cckdblk.gccond, &cckdblk.gclock, &tm );

  0047b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172341
  00482	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR tm$[rsp]
  0048a	48 8d 15 28 00
	00 00		 lea	 rdx, OFFSET FLAT:cckdblk+40
  00491	48 8d 0d 30 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+48
  00498	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_timed_wait_condition

; 5092 :     }

  0049e	e9 33 fe ff ff	 jmp	 $LN5@cckd_gcol
$LN6@cckd_gcol:

; 5093 : 
; 5094 :     if (!cckdblk.batch || cckdblk.batchml > 1)

  004a3	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  004a9	83 e0 01	 and	 eax, 1
  004ac	85 c0		 test	 eax, eax
  004ae	74 0d		 je	 SHORT $LN23@cckd_gcol
  004b0	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  004b7	0f 8e 92 00 00
	00		 jle	 $LN22@cckd_gcol
$LN23@cckd_gcol:

; 5095 :         // "Thread id "TIDPAT", prio %d, name '%s' ended"
; 5096 :         LOG_THREAD_END( CCKD_GC_THREAD_NAME  );

  004bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  004c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172345
  004ca	8b c8		 mov	 ecx, eax
  004cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  004d2	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv257[rsp], eax
  004d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  004df	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv262[rsp], eax
  004e6	b9 01 00 00 00	 mov	 ecx, 1
  004eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172344
  004f8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  004fd	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv257[rsp]
  00504	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00508	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv262[rsp]
  0050f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00513	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172346
  0051a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0051f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172347
  00526	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0052b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00530	41 b9 03 00 00
	00		 mov	 r9d, 3
  00536	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172348
  0053d	ba e8 13 00 00	 mov	 edx, 5096		; 000013e8H
  00542	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172349
  00549	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN22@cckd_gcol:

; 5097 : 
; 5098 :     cckdblk.gcs--;

  0054f	8b 05 38 00 00
	00		 mov	 eax, DWORD PTR cckdblk+56
  00555	ff c8		 dec	 eax
  00557	89 05 38 00 00
	00		 mov	 DWORD PTR cckdblk+56, eax

; 5099 :     cckdblk.gca--;

  0055d	8b 05 3c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+60
  00563	ff c8		 dec	 eax
  00565	89 05 3c 00 00
	00		 mov	 DWORD PTR cckdblk+60, eax

; 5100 : 
; 5101 :     gcs = cckdblk.gcs;

  0056b	8b 05 38 00 00
	00		 mov	 eax, DWORD PTR cckdblk+56
  00571	89 84 24 98 00
	00 00		 mov	 DWORD PTR gcs$[rsp], eax

; 5102 : 
; 5103 :     release_lock( &cckdblk.gclock );

  00578	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172350
  0057f	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  00586	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5104 : 
; 5105 :     if (!gcs)

  0058c	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR gcs$[rsp], 0
  00594	75 14		 jne	 SHORT $LN24@cckd_gcol

; 5106 :         signal_condition( &cckdblk.termcond );

  00596	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172352
  0059d	48 8d 0d 60 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+608
  005a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN24@cckd_gcol:

; 5107 : 
; 5108 :     return NULL;

  005aa	33 c0		 xor	 eax, eax
$LN1@cckd_gcol:

; 5109 : } /* end thread cckd_gcol */

  005ac	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005b4	48 33 cc	 xor	 rcx, rsp
  005b7	e8 00 00 00 00	 call	 __security_check_cookie
  005bc	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  005c3	c3		 ret	 0
cckd_gcol ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
flag$ = 96
rc$ = 100
tv172 = 104
tid$ = 108
cckd$ = 112
dev$ = 120
tv168 = 128
cckd_gcstart PROC

; 4933 : {

$LN13:
  00000	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 4934 :     DEVBLK*    dev;
; 4935 :     CCKD_EXT*  cckd;
; 4936 :     TID tid;
; 4937 :     int flag = 0;

  00007	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR flag$[rsp], 0

; 4938 :     int rc;
; 4939 : 
; 4940 :     cckd_lock_devchain(0);

  0000f	33 c9		 xor	 ecx, ecx
  00011	e8 00 00 00 00	 call	 cckd_lock_devchain

; 4941 :     {
; 4942 :         for (dev = cckdblk.dev1st; dev; dev = cckd->devnext)

  00016	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  0001d	48 89 44 24 78	 mov	 QWORD PTR dev$[rsp], rax
  00022	eb 0d		 jmp	 SHORT $LN4@cckd_gcsta
$LN2@cckd_gcsta:
  00024	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00029	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002c	48 89 44 24 78	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd_gcsta:
  00031	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00037	0f 84 ce 00 00
	00		 je	 $LN3@cckd_gcsta

; 4943 :         {
; 4944 :             cckd = dev->cckd_ext;

  0003d	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00042	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00049	48 89 44 24 70	 mov	 QWORD PTR cckd$[rsp], rax

; 4945 : 
; 4946 :             if (dev->cckd64)

  0004e	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00053	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0005a	24 01		 and	 al, 1
  0005c	0f b6 c0	 movzx	 eax, al
  0005f	85 c0		 test	 eax, eax
  00061	74 02		 je	 SHORT $LN5@cckd_gcsta

; 4947 :                 continue;

  00063	eb bf		 jmp	 SHORT $LN2@cckd_gcsta
$LN5@cckd_gcsta:

; 4948 : 
; 4949 :             obtain_lock( &cckd->filelock );

  00065	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0006a	48 83 c0 10	 add	 rax, 16
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172248
  00075	48 8b c8	 mov	 rcx, rax
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4950 :             {
; 4951 :                 if (cckd->cdevhdr[ cckd->sfn ].free_total)

  0007e	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00083	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00087	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0008e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00093	83 bc 01 f8 01
	00 00 00	 cmp	 DWORD PTR [rcx+rax+504], 0
  0009b	74 50		 je	 SHORT $LN6@cckd_gcsta

; 4952 :                 {
; 4953 :                     cckd->cdevhdr[ cckd->sfn ].cdh_opts |= (CCKD_OPT_OPENED | CCKD_OPT_OPENRW);

  0009d	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  000a2	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  000a6	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000ad	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  000b2	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  000ba	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  000bf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  000c4	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  000c8	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  000cf	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  000d4	88 84 0a e3 01
	00 00		 mov	 BYTE PTR [rdx+rcx+483], al

; 4954 :                     cckd_write_chdr( dev );

  000db	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  000e0	e8 00 00 00 00	 call	 cckd_write_chdr

; 4955 :                     flag = 1;

  000e5	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR flag$[rsp], 1
$LN6@cckd_gcsta:

; 4956 :                 }
; 4957 :             }
; 4958 :             release_lock( &cckd->filelock );

  000ed	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  000f2	48 83 c0 10	 add	 rax, 16
  000f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172250
  000fd	48 8b c8	 mov	 rcx, rax
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4959 :         }

  00106	e9 19 ff ff ff	 jmp	 $LN2@cckd_gcsta
$LN3@cckd_gcsta:

; 4960 :     }
; 4961 :     cckd_unlock_devchain();

  0010b	e8 00 00 00 00	 call	 cckd_unlock_devchain

; 4962 : 
; 4963 :     /* Schedule the garbage collector */
; 4964 :     if (flag && cckdblk.gcs < cckdblk.gcmax)

  00110	83 7c 24 60 00	 cmp	 DWORD PTR flag$[rsp], 0
  00115	0f 84 f3 01 00
	00		 je	 $LN7@cckd_gcsta
  0011b	8b 05 40 00 00
	00		 mov	 eax, DWORD PTR cckdblk+64
  00121	39 05 38 00 00
	00		 cmp	 DWORD PTR cckdblk+56, eax
  00127	0f 8d e1 01 00
	00		 jge	 $LN7@cckd_gcsta

; 4965 :     {
; 4966 :         /* ensure read integrity for gc count */
; 4967 :         obtain_lock( &cckdblk.gclock );

  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172252
  00134	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4968 :         {
; 4969 :             if (cckdblk.gcs < cckdblk.gcmax)

  00141	8b 05 40 00 00
	00		 mov	 eax, DWORD PTR cckdblk+64
  00147	39 05 38 00 00
	00		 cmp	 DWORD PTR cckdblk+56, eax
  0014d	0f 8d a7 01 00
	00		 jge	 $LN8@cckd_gcsta

; 4970 :             {
; 4971 :                 /* Schedule a new garbage collector thread  */
; 4972 :                 if (!cckdblk.batch || cckdblk.batchml > 1)

  00153	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00159	83 e0 01	 and	 eax, 1
  0015c	85 c0		 test	 eax, eax
  0015e	74 09		 je	 SHORT $LN10@cckd_gcsta
  00160	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  00167	7e 71		 jle	 SHORT $LN9@cckd_gcsta
$LN10@cckd_gcsta:

; 4973 :                     // "Starting thread %s, active=%d, started=%d, max=%d"
; 4974 :                     WRMSG( HHC00107, "I", CCKD_GC_THREAD_NAME "() by command line",

  00169	b9 01 00 00 00	 mov	 ecx, 1
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00174	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+64
  0017a	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0017e	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+56
  00184	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00188	8b 0d 3c 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+60
  0018e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172256
  00199	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0019e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172257
  001a5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172258
  001b1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bb	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172259
  001c8	ba 6f 13 00 00	 mov	 edx, 4975		; 0000136fH
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172260
  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@cckd_gcsta:

; 4975 :                         cckdblk.gca, cckdblk.gcs, cckdblk.gcmax );
; 4976 : 
; 4977 :                 ++cckdblk.gcs;

  001da	8b 05 38 00 00
	00		 mov	 eax, DWORD PTR cckdblk+56
  001e0	ff c0		 inc	 eax
  001e2	89 05 38 00 00
	00		 mov	 DWORD PTR cckdblk+56, eax

; 4978 : 
; 4979 :                 /* Release lock across thread create to prevent interlock  */
; 4980 :                 release_lock( &cckdblk.gclock );

  001e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172261
  001ef	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4981 :                 {
; 4982 :                     rc = create_thread( &tid, JOINABLE, cckd_gcol, NULL, CCKD_GC_THREAD_NAME );

  001fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00203	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  00209	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172262
  00210	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00215	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172263
  0021c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00221	45 33 c9	 xor	 r9d, r9d
  00224	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cckd_gcol
  0022b	48 8b d0	 mov	 rdx, rax
  0022e	48 8d 4c 24 6c	 lea	 rcx, QWORD PTR tid$[rsp]
  00233	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00239	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 4983 :                 }
; 4984 :                 obtain_lock( &cckdblk.gclock );

  0023d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172264
  00244	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  0024b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4985 : 
; 4986 :                 if (rc)

  00251	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  00256	0f 84 9e 00 00
	00		 je	 $LN11@cckd_gcsta

; 4987 :                 {
; 4988 :                     // "Error in function create_thread() for %s %d of %d: %s"
; 4989 :                     WRMSG( HHC00106, "E", CCKD_GC_THREAD_NAME "() by command line",

  0025c	8b 4c 24 64	 mov	 ecx, DWORD PTR rc$[rsp]
  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00266	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv168[rsp], rax
  0026e	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+56
  00274	ff c9		 dec	 ecx
  00276	89 4c 24 68	 mov	 DWORD PTR tv172[rsp], ecx
  0027a	b9 01 00 00 00	 mov	 ecx, 1
  0027f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00285	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv168[rsp]
  0028d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00292	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+64
  00298	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0029c	8b 4c 24 68	 mov	 ecx, DWORD PTR tv172[rsp]
  002a0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172266
  002ab	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172267
  002b7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172268
  002c3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002cd	41 b9 03 00 00
	00		 mov	 r9d, 3
  002d3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172269
  002da	ba 7e 13 00 00	 mov	 edx, 4990		; 0000137eH
  002df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172270
  002e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4990 :                         cckdblk.gcs-1, cckdblk.gcmax, strerror( rc ));
; 4991 : 
; 4992 :                     --cckdblk.gcs;

  002ec	8b 05 38 00 00
	00		 mov	 eax, DWORD PTR cckdblk+56
  002f2	ff c8		 dec	 eax
  002f4	89 05 38 00 00
	00		 mov	 DWORD PTR cckdblk+56, eax
$LN11@cckd_gcsta:
$LN8@cckd_gcsta:

; 4993 :                 }
; 4994 :             }
; 4995 :         }
; 4996 :         release_lock( &cckdblk.gclock );

  002fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172271
  00301	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  00308	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN7@cckd_gcsta:

; 4997 :     }
; 4998 : }

  0030e	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00315	c3		 ret	 0
cckd_gcstart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
cckd_unlock_devchain PROC

; 4917 : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4918 :     obtain_lock( &cckdblk.devlock );

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172231
  0000b	48 8d 0d 30 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+560
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4919 :     {
; 4920 :         if (cckdblk.devusers < 0) cckdblk.devusers++;

  00018	83 3d 40 02 00
	00 00		 cmp	 DWORD PTR cckdblk+576, 0
  0001f	7d 10		 jge	 SHORT $LN2@cckd_unloc
  00021	8b 05 40 02 00
	00		 mov	 eax, DWORD PTR cckdblk+576
  00027	ff c0		 inc	 eax
  00029	89 05 40 02 00
	00		 mov	 DWORD PTR cckdblk+576, eax
  0002f	eb 0e		 jmp	 SHORT $LN3@cckd_unloc
$LN2@cckd_unloc:

; 4921 :         else                      cckdblk.devusers--;

  00031	8b 05 40 02 00
	00		 mov	 eax, DWORD PTR cckdblk+576
  00037	ff c8		 dec	 eax
  00039	89 05 40 02 00
	00		 mov	 DWORD PTR cckdblk+576, eax
$LN3@cckd_unloc:

; 4922 : 
; 4923 :         if (!cckdblk.devusers && cckdblk.devwaiters)

  0003f	83 3d 40 02 00
	00 00		 cmp	 DWORD PTR cckdblk+576, 0
  00046	75 1d		 jne	 SHORT $LN4@cckd_unloc
  00048	83 3d 44 02 00
	00 00		 cmp	 DWORD PTR cckdblk+580, 0
  0004f	74 14		 je	 SHORT $LN4@cckd_unloc

; 4924 :             signal_condition( &cckdblk.devcond );

  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172235
  00058	48 8d 0d 38 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+568
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN4@cckd_unloc:

; 4925 :     }
; 4926 :     release_lock( &cckdblk.devlock );

  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172236
  0006c	48 8d 0d 30 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+560
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4927 : }

  00079	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007d	c3		 ret	 0
cckd_unlock_devchain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
flag$ = 48
cckd_lock_devchain PROC

; 4880 : {

$LN9:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4881 :     obtain_lock( &cckdblk.devlock );

  00008	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172223
  0000f	48 8d 0d 30 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+560
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN2@cckd_lock_:

; 4882 :     {
; 4883 :         while (( flag && cckdblk.devusers != 0)
; 4884 :             || (!flag && cckdblk.devusers <  0))

  0001c	83 7c 24 30 00	 cmp	 DWORD PTR flag$[rsp], 0
  00021	74 09		 je	 SHORT $LN5@cckd_lock_
  00023	83 3d 40 02 00
	00 00		 cmp	 DWORD PTR cckdblk+576, 0
  0002a	75 10		 jne	 SHORT $LN4@cckd_lock_
$LN5@cckd_lock_:
  0002c	83 7c 24 30 00	 cmp	 DWORD PTR flag$[rsp], 0
  00031	75 42		 jne	 SHORT $LN3@cckd_lock_
  00033	83 3d 40 02 00
	00 00		 cmp	 DWORD PTR cckdblk+576, 0
  0003a	7d 39		 jge	 SHORT $LN3@cckd_lock_
$LN4@cckd_lock_:

; 4885 :         {
; 4886 :             cckdblk.devwaiters++;

  0003c	8b 05 44 02 00
	00		 mov	 eax, DWORD PTR cckdblk+580
  00042	ff c0		 inc	 eax
  00044	89 05 44 02 00
	00		 mov	 DWORD PTR cckdblk+580, eax

; 4887 :             {
; 4888 : #if FALSE
; 4889 :                 {
; 4890 :                     struct timespec  tm;
; 4891 :                     struct timeval   now;
; 4892 :                     int              timeout;
; 4893 : 
; 4894 :                     gettimeofday( &now, NULL );
; 4895 :                     tm.tv_sec = now.tv_sec + 2;
; 4896 :                     tm.tv_nsec = now.tv_usec * 1000;
; 4897 :                     timeout = timed_wait_condition( &cckdblk.devcond, &cckdblk.devlock, &tm );
; 4898 :                     if (timeout) cckd_print_itrace();
; 4899 :                 }
; 4900 : #else
; 4901 :                 wait_condition( &cckdblk.devcond, &cckdblk.devlock );

  0004a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172226
  00051	48 8d 15 30 02
	00 00		 lea	 rdx, OFFSET FLAT:cckdblk+560
  00058	48 8d 0d 38 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+568
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 4902 : #endif
; 4903 :             }
; 4904 :             cckdblk.devwaiters--;

  00065	8b 05 44 02 00
	00		 mov	 eax, DWORD PTR cckdblk+580
  0006b	ff c8		 dec	 eax
  0006d	89 05 44 02 00
	00		 mov	 DWORD PTR cckdblk+580, eax

; 4905 :         }

  00073	eb a7		 jmp	 SHORT $LN2@cckd_lock_
$LN3@cckd_lock_:

; 4906 : 
; 4907 :         if (flag) cckdblk.devusers--;

  00075	83 7c 24 30 00	 cmp	 DWORD PTR flag$[rsp], 0
  0007a	74 10		 je	 SHORT $LN6@cckd_lock_
  0007c	8b 05 40 02 00
	00		 mov	 eax, DWORD PTR cckdblk+576
  00082	ff c8		 dec	 eax
  00084	89 05 40 02 00
	00		 mov	 DWORD PTR cckdblk+576, eax
  0008a	eb 0e		 jmp	 SHORT $LN7@cckd_lock_
$LN6@cckd_lock_:

; 4908 :         else      cckdblk.devusers++;

  0008c	8b 05 40 02 00
	00		 mov	 eax, DWORD PTR cckdblk+576
  00092	ff c0		 inc	 eax
  00094	89 05 40 02 00
	00		 mov	 DWORD PTR cckdblk+576, eax
$LN7@cckd_lock_:

; 4909 :     }
; 4910 :     release_lock( &cckdblk.devlock );

  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172229
  000a1	48 8d 0d 30 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+560
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4911 : }

  000ae	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b2	c3		 ret	 0
cckd_lock_devchain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
cckd$ = 96
l1size$ = 104
tv131 = 108
tv137 = 112
tv159 = 116
tv165 = 120
tv94 = 124
tv154 = 128
tv82 = 136
tv247 = 144
tv290 = 152
tv298 = 160
devhdr$ = 176
__$ArrayPad$ = 688
dev$ = 736
cckd_sf_new PROC

; 4030 : {

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec c8 02
	00 00		 sub	 rsp, 712		; 000002c8H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4031 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 4032 : int             l1size;                 /* Size of level 1 table     */
; 4033 : CKD_DEVHDR      devhdr;                 /* Device header             */
; 4034 : 
; 4035 :     if (dev->cckd64)

  00020	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00028	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0002f	24 01		 and	 al, 1
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	74 12		 je	 SHORT $LN2@cckd_sf_ne

; 4036 :         return cckd64_sf_new( dev );

  00038	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00040	e8 00 00 00 00	 call	 cckd64_sf_new
  00045	e9 1d 06 00 00	 jmp	 $LN1@cckd_sf_ne
$LN2@cckd_sf_ne:

; 4037 : 
; 4038 :     cckd = dev->cckd_ext;

  0004a	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00059	48 89 44 24 60	 mov	 QWORD PTR cckd$[rsp], rax

; 4039 : 
; 4040 :     CCKD_TRACE( "file[%d] sf_new %s", cckd->sfn+1,

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00063	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00066	ff c0		 inc	 eax
  00068	8b d0		 mov	 edx, eax
  0006a	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00072	e8 00 00 00 00	 call	 cckd_sf_name
  00077	48 85 c0	 test	 rax, rax
  0007a	74 23		 je	 SHORT $LN11@cckd_sf_ne
  0007c	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00081	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00084	ff c0		 inc	 eax
  00086	8b d0		 mov	 edx, eax
  00088	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00090	e8 00 00 00 00	 call	 cckd_sf_name
  00095	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
  0009d	eb 0f		 jmp	 SHORT $LN12@cckd_sf_ne
$LN11@cckd_sf_ne:
  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171720
  000a6	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
$LN12@cckd_sf_ne:
  000ae	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  000b3	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  000b6	ff c0		 inc	 eax
  000b8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv82[rsp]
  000c0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000c5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000c9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171721
  000d0	4c 8b 84 24 e0
	02 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000d8	ba ca 0f 00 00	 mov	 edx, 4042		; 00000fcaH
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171722
  000e4	e8 00 00 00 00	 call	 cckd_trace

; 4041 :                 cckd_sf_name(dev, cckd->sfn+1) ?
; 4042 :                 (char *)cckd_sf_name(dev, cckd->sfn+1) : "(none)");
; 4043 : 
; 4044 :     /* Error if no shadow file name */
; 4045 :     if (dev->dasdsfn == NULL)

  000e9	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f1	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  000f9	0f 85 c3 00 00
	00		 jne	 $LN3@cckd_sf_ne

; 4046 :     {
; 4047 :         WRMSG (HHC00313, "E", LCSS_DEVNUM, cckd->sfn+1);

  000ff	48 83 bc 24 e0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00108	74 12		 je	 SHORT $LN13@cckd_sf_ne
  0010a	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00112	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00116	89 44 24 6c	 mov	 DWORD PTR tv131[rsp], eax
  0011a	eb 08		 jmp	 SHORT $LN14@cckd_sf_ne
$LN13@cckd_sf_ne:
  0011c	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN14@cckd_sf_ne:
  00124	48 83 bc 24 e0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0012d	74 14		 je	 SHORT $LN15@cckd_sf_ne
  0012f	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00137	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0013b	d1 f8		 sar	 eax, 1
  0013d	89 44 24 70	 mov	 DWORD PTR tv137[rsp], eax
  00141	eb 08		 jmp	 SHORT $LN16@cckd_sf_ne
$LN15@cckd_sf_ne:
  00143	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN16@cckd_sf_ne:
  0014b	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00150	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00153	ff c0		 inc	 eax
  00155	89 44 24 7c	 mov	 DWORD PTR tv94[rsp], eax
  00159	b9 01 00 00 00	 mov	 ecx, 1
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00164	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv94[rsp]
  00168	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0016c	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv131[rsp]
  00170	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00174	8b 4c 24 70	 mov	 ecx, DWORD PTR tv137[rsp]
  00178	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171724
  00183	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00188	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171725
  0018f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00194	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00199	41 b9 03 00 00
	00		 mov	 r9d, 3
  0019f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171726
  001a6	ba cf 0f 00 00	 mov	 edx, 4047		; 00000fcfH
  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171727
  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4048 :         return -1;

  001b8	b8 ff ff ff ff	 mov	 eax, -1
  001bd	e9 a5 04 00 00	 jmp	 $LN1@cckd_sf_ne
$LN3@cckd_sf_ne:

; 4049 :     }
; 4050 : 
; 4051 :     /* Error if max number of shadow files exceeded */
; 4052 :     if (cckd->sfn+1 == CCKD_MAX_SF)

  001c2	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  001c7	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  001ca	ff c0		 inc	 eax
  001cc	83 f8 08	 cmp	 eax, 8
  001cf	0f 85 dd 00 00
	00		 jne	 $LN4@cckd_sf_ne

; 4053 :     {
; 4054 :         WRMSG (HHC00314, "E", LCSS_DEVNUM, cckd->sfn+1, dev->dasdsfn);

  001d5	48 83 bc 24 e0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001de	74 12		 je	 SHORT $LN17@cckd_sf_ne
  001e0	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001ec	89 44 24 74	 mov	 DWORD PTR tv159[rsp], eax
  001f0	eb 08		 jmp	 SHORT $LN18@cckd_sf_ne
$LN17@cckd_sf_ne:
  001f2	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN18@cckd_sf_ne:
  001fa	48 83 bc 24 e0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00203	74 14		 je	 SHORT $LN19@cckd_sf_ne
  00205	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00211	d1 f8		 sar	 eax, 1
  00213	89 44 24 78	 mov	 DWORD PTR tv165[rsp], eax
  00217	eb 08		 jmp	 SHORT $LN20@cckd_sf_ne
$LN19@cckd_sf_ne:
  00219	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
$LN20@cckd_sf_ne:
  00221	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00226	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00229	ff c0		 inc	 eax
  0022b	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv154[rsp], eax
  00232	b9 01 00 00 00	 mov	 ecx, 1
  00237	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0023d	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00245	48 8b 89 70 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4464]
  0024c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00251	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv154[rsp]
  00258	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0025c	8b 4c 24 74	 mov	 ecx, DWORD PTR tv159[rsp]
  00260	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00264	8b 4c 24 78	 mov	 ecx, DWORD PTR tv165[rsp]
  00268	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0026c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171729
  00273	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00278	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171730
  0027f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00284	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00289	41 b9 03 00 00
	00		 mov	 r9d, 3
  0028f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171731
  00296	ba d6 0f 00 00	 mov	 edx, 4054		; 00000fd6H
  0029b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171732
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4055 :         return -1;

  002a8	b8 ff ff ff ff	 mov	 eax, -1
  002ad	e9 b5 03 00 00	 jmp	 $LN1@cckd_sf_ne
$LN4@cckd_sf_ne:

; 4056 :     }
; 4057 : 
; 4058 :     /* Harden the current file */
; 4059 :     cckd_harden (dev);

  002b2	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002ba	e8 00 00 00 00	 call	 cckd_harden

; 4060 : 
; 4061 :     /* Open the new shadow file */
; 4062 :     if (cckd_open(dev, cckd->sfn+1, O_RDWR|O_CREAT|O_EXCL|O_BINARY,
; 4063 :                                       S_IRUSR | S_IWUSR | S_IRGRP) < 0)

  002bf	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  002c4	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  002c7	ff c0		 inc	 eax
  002c9	41 b9 80 01 00
	00		 mov	 r9d, 384		; 00000180H
  002cf	41 b8 02 85 00
	00		 mov	 r8d, 34050		; 00008502H
  002d5	8b d0		 mov	 edx, eax
  002d7	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002df	e8 00 00 00 00	 call	 cckd_open
  002e4	85 c0		 test	 eax, eax
  002e6	7d 0a		 jge	 SHORT $LN5@cckd_sf_ne

; 4064 :         return -1;

  002e8	b8 ff ff ff ff	 mov	 eax, -1
  002ed	e9 75 03 00 00	 jmp	 $LN1@cckd_sf_ne
$LN5@cckd_sf_ne:

; 4065 : 
; 4066 :     /* Read previous file's device header */
; 4067 :     if (cckd_read (dev, cckd->sfn, 0, &devhdr, CKD_DEVHDR_SIZE) < 0)

  002f2	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  002fa	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR devhdr$[rsp]
  00302	45 33 c0	 xor	 r8d, r8d
  00305	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0030a	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  0030d	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00315	e8 00 00 00 00	 call	 cckd_read
  0031a	85 c0		 test	 eax, eax
  0031c	7d 05		 jge	 SHORT $LN6@cckd_sf_ne

; 4068 :         goto sf_new_error;

  0031e	e9 97 02 00 00	 jmp	 $sf_new_error$22
$LN6@cckd_sf_ne:

; 4069 : 
; 4070 :     /* Make sure identifier is CKD_S370 or FBA_S370 */
; 4071 :     devhdr.dh_devid[4] = 'S';

  00323	b8 01 00 00 00	 mov	 eax, 1
  00328	48 6b c0 04	 imul	 rax, rax, 4
  0032c	c6 84 04 b0 00
	00 00 53	 mov	 BYTE PTR devhdr$[rsp+rax], 83 ; 00000053H

; 4072 : 
; 4073 :     /* Write new file's device header */
; 4074 :     if (cckd_write (dev, cckd->sfn+1, 0, &devhdr, CKD_DEVHDR_SIZE) < 0)

  00334	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00339	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0033c	ff c0		 inc	 eax
  0033e	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  00346	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR devhdr$[rsp]
  0034e	45 33 c0	 xor	 r8d, r8d
  00351	8b d0		 mov	 edx, eax
  00353	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0035b	e8 00 00 00 00	 call	 cckd_write
  00360	85 c0		 test	 eax, eax
  00362	7d 05		 jge	 SHORT $LN7@cckd_sf_ne

; 4075 :         goto sf_new_error;

  00364	e9 51 02 00 00	 jmp	 $sf_new_error$22
$LN7@cckd_sf_ne:

; 4076 : 
; 4077 :     /* Build the compressed device header */
; 4078 :     memcpy (&cckd->cdevhdr[cckd->sfn+1], &cckd->cdevhdr[cckd->sfn], CCKD_DEVHDR_SIZE);

  00369	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0036e	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00372	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00379	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0037e	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00381	ff c1		 inc	 ecx
  00383	48 63 c9	 movsxd	 rcx, ecx
  00386	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  0038d	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00392	4c 8b 44 24 60	 mov	 r8, QWORD PTR cckd$[rsp]
  00397	48 8d bc 0a e0
	01 00 00	 lea	 rdi, QWORD PTR [rdx+rcx+480]
  0039f	49 8d b4 00 e0
	01 00 00	 lea	 rsi, QWORD PTR [r8+rax+480]
  003a7	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  003ac	f3 a4		 rep movsb

; 4079 :     l1size = cckd->cdevhdr[cckd->sfn+1].num_L1tab * CCKD_L1ENT_SIZE;

  003ae	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  003b3	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  003b6	ff c0		 inc	 eax
  003b8	48 98		 cdqe
  003ba	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  003c1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  003c6	48 63 84 01 e4
	01 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+484]
  003ce	48 c1 e0 02	 shl	 rax, 2
  003d2	89 44 24 68	 mov	 DWORD PTR l1size$[rsp], eax

; 4080 :     cckd->cdevhdr[cckd->sfn+1].cdh_size =

  003d6	48 63 44 24 68	 movsxd	 rax, DWORD PTR l1size$[rsp]
  003db	48 05 00 04 00
	00		 add	 rax, 1024		; 00000400H
  003e1	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv247[rsp], rax
  003e9	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  003ee	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  003f1	ff c0		 inc	 eax
  003f3	48 98		 cdqe
  003f5	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  003fc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00401	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR tv247[rsp]
  00408	89 94 01 f0 01
	00 00		 mov	 DWORD PTR [rcx+rax+496], edx
  0040f	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00414	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00417	ff c0		 inc	 eax
  00419	48 98		 cdqe
  0041b	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00422	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00427	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR tv247[rsp]
  0042e	89 94 01 ec 01
	00 00		 mov	 DWORD PTR [rcx+rax+492], edx

; 4081 :     cckd->cdevhdr[cckd->sfn+1].cdh_used = CKD_DEVHDR_SIZE + CCKD_DEVHDR_SIZE + l1size;
; 4082 :     cckd->cdevhdr[cckd->sfn+1].free_off =

  00435	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0043a	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0043d	ff c0		 inc	 eax
  0043f	48 98		 cdqe
  00441	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00448	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0044d	c7 84 01 04 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+516], 0
  00458	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0045d	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00460	ff c0		 inc	 eax
  00462	48 98		 cdqe
  00464	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0046b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00470	c7 84 01 00 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+512], 0
  0047b	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00480	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00483	ff c0		 inc	 eax
  00485	48 98		 cdqe
  00487	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0048e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00493	c7 84 01 fc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+508], 0
  0049e	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  004a3	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  004a6	ff c0		 inc	 eax
  004a8	48 98		 cdqe
  004aa	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  004b6	c7 84 01 f8 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+504], 0
  004c1	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  004c6	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  004c9	ff c0		 inc	 eax
  004cb	48 98		 cdqe
  004cd	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  004d9	c7 84 01 f4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+500], 0

; 4083 :     cckd->cdevhdr[cckd->sfn+1].free_total =
; 4084 :     cckd->cdevhdr[cckd->sfn+1].free_largest =
; 4085 :     cckd->cdevhdr[cckd->sfn+1].free_num =
; 4086 :     cckd->cdevhdr[cckd->sfn+1].free_imbed = 0;
; 4087 : 
; 4088 :     /* Init the level 1 table */
; 4089 :     if ((cckd->L1tab[cckd->sfn+1] = cckd_malloc (dev, "l1", l1size)) == NULL)

  004e4	48 63 44 24 68	 movsxd	 rax, DWORD PTR l1size$[rsp]
  004e9	4c 8b c0	 mov	 r8, rax
  004ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171737
  004f3	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004fb	e8 00 00 00 00	 call	 cckd_malloc
  00500	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv290[rsp], rax
  00508	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0050d	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00510	ff c0		 inc	 eax
  00512	48 98		 cdqe
  00514	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00519	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR tv290[rsp]
  00521	48 89 94 c1 98
	01 00 00	 mov	 QWORD PTR [rcx+rax*8+408], rdx
  00529	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR tv290[rsp], 0
  00532	75 05		 jne	 SHORT $LN8@cckd_sf_ne

; 4090 :         goto sf_new_error;

  00534	e9 81 00 00 00	 jmp	 $sf_new_error$22
$LN8@cckd_sf_ne:

; 4091 :     memset (cckd->L1tab[cckd->sfn+1], 0xff, l1size);

  00539	48 63 44 24 68	 movsxd	 rax, DWORD PTR l1size$[rsp]
  0053e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv298[rsp], rax
  00546	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0054b	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  0054e	ff c1		 inc	 ecx
  00550	48 63 c9	 movsxd	 rcx, ecx
  00553	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00558	48 8b bc ca 98
	01 00 00	 mov	 rdi, QWORD PTR [rdx+rcx*8+408]
  00560	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00565	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv298[rsp]
  0056d	f3 aa		 rep stosb

; 4092 : 
; 4093 :     /* Make the new file active */
; 4094 :     cckd->sfn++;

  0056f	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00574	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00577	ff c0		 inc	 eax
  00579	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0057e	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 4095 : 
; 4096 :     /* Harden the new file */
; 4097 :     if (cckd_harden (dev) < 0)

  00581	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00589	e8 00 00 00 00	 call	 cckd_harden
  0058e	85 c0		 test	 eax, eax
  00590	7d 14		 jge	 SHORT $LN9@cckd_sf_ne

; 4098 :     {
; 4099 :         cckd->sfn--;

  00592	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00597	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0059a	ff c8		 dec	 eax
  0059c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  005a1	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 4100 :         goto sf_new_error;

  005a4	eb 14		 jmp	 SHORT $sf_new_error$22
$LN9@cckd_sf_ne:

; 4101 :     }
; 4102 : 
; 4103 :     /* Re-read the l1 to set L2_bounds, L2ok */
; 4104 :     cckd_read_l1 (dev);

  005a6	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005ae	e8 00 00 00 00	 call	 cckd_read_l1

; 4105 : 
; 4106 :     return 0;

  005b3	33 c0		 xor	 eax, eax
  005b5	e9 ad 00 00 00	 jmp	 $LN1@cckd_sf_ne
$sf_new_error$22:

; 4107 : 
; 4108 : sf_new_error:
; 4109 :     cckd->L1tab[cckd->sfn+1] = cckd_free(dev, "l1", cckd->L1tab[cckd->sfn+1]);

  005ba	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  005bf	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  005c2	ff c0		 inc	 eax
  005c4	48 98		 cdqe
  005c6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  005cb	4c 8b 84 c1 98
	01 00 00	 mov	 r8, QWORD PTR [rcx+rax*8+408]
  005d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171739
  005da	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005e2	e8 00 00 00 00	 call	 cckd_free
  005e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  005ec	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  005ef	ff c1		 inc	 ecx
  005f1	48 63 c9	 movsxd	 rcx, ecx
  005f4	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  005f9	48 89 84 ca 98
	01 00 00	 mov	 QWORD PTR [rdx+rcx*8+408], rax

; 4110 :     cckd_close (dev, cckd->sfn+1);

  00601	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00606	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00609	ff c0		 inc	 eax
  0060b	8b d0		 mov	 edx, eax
  0060d	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00615	e8 00 00 00 00	 call	 cckd_close

; 4111 :     cckd->open[cckd->sfn+1] = CCKD_OPEN_NONE;

  0061a	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0061f	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00622	ff c0		 inc	 eax
  00624	48 98		 cdqe
  00626	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0062b	c6 84 01 1d 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+285], 0

; 4112 :     unlink (cckd_sf_name (dev, cckd->sfn+1));

  00633	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00638	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0063b	ff c0		 inc	 eax
  0063d	8b d0		 mov	 edx, eax
  0063f	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00647	e8 00 00 00 00	 call	 cckd_sf_name
  0064c	48 8b c8	 mov	 rcx, rax
  0064f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_unlink

; 4113 : 
; 4114 :     /* Re-read the l1 to set L2_bounds, L2ok */
; 4115 :     cckd_read_l1 (dev);

  00655	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0065d	e8 00 00 00 00	 call	 cckd_read_l1

; 4116 : 
; 4117 :     return -1;

  00662	b8 ff ff ff ff	 mov	 eax, -1
$LN1@cckd_sf_ne:

; 4118 : 
; 4119 : } /* end function cckd_sf_new */

  00667	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0066f	48 33 cc	 xor	 rcx, rsp
  00672	e8 00 00 00 00	 call	 __security_check_cookie
  00677	48 81 c4 c8 02
	00 00		 add	 rsp, 712		; 000002c8H
  0067e	5f		 pop	 rdi
  0067f	5e		 pop	 rsi
  00680	c3		 ret	 0
cckd_sf_new ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
i$ = 128
cckd$ = 136
j$1 = 144
dev2$2 = 152
tv147 = 160
tv153 = 164
tv215 = 168
tv221 = 172
rc$ = 176
tv288 = 180
tv294 = 184
tv133 = 188
tv137 = 192
cckd2$3 = 200
tv86 = 208
tv95 = 216
tv139 = 224
tv276 = 232
tv280 = 240
st$ = 248
devhdr$ = 304
pathname$ = 816
__$ArrayPad$ = 1088
dev$ = 1120
cckd_sf_init PROC

; 3921 : {

$LN46:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 04
	00 00		 sub	 rsp, 1112		; 00000458H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 40
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3922 : CKD_DEVHDR      devhdr;                 /* Device header             */
; 3923 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3924 : int             rc;                     /* Return code               */
; 3925 : int             i;                      /* Index                     */
; 3926 : struct stat     st;                     /* stat() buffer             */
; 3927 : char            pathname[MAX_PATH];     /* file path in host format  */
; 3928 : 
; 3929 :     if (dev->cckd64)

  0001e	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0002d	24 01		 and	 al, 1
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	74 12		 je	 SHORT $LN17@cckd_sf_in

; 3930 :         return cckd64_sf_init( dev );

  00036	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0003e	e8 00 00 00 00	 call	 cckd64_sf_init
  00043	e9 3c 07 00 00	 jmp	 $LN1@cckd_sf_in
$LN17@cckd_sf_in:

; 3931 : 
; 3932 :     cckd = dev->cckd_ext;

  00048	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00050	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00057	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 3933 : 
; 3934 :     /* return if no shadow files */
; 3935 :     if (dev->dasdsfn == NULL) return 0;

  0005f	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00067	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  0006f	75 07		 jne	 SHORT $LN18@cckd_sf_in
  00071	33 c0		 xor	 eax, eax
  00073	e9 0c 07 00 00	 jmp	 $LN1@cckd_sf_in
$LN18@cckd_sf_in:

; 3936 : 
; 3937 :     /* Check for shadow file name collision */
; 3938 :     for (i = 1; i <= CCKD_MAX_SF && dev->dasdsfn != NULL; i++)

  00078	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR i$[rsp], 1
  00083	eb 10		 jmp	 SHORT $LN4@cckd_sf_in
$LN2@cckd_sf_in:
  00085	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0008c	ff c0		 inc	 eax
  0008e	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd_sf_in:
  00095	83 bc 24 80 00
	00 00 08	 cmp	 DWORD PTR i$[rsp], 8
  0009d	0f 8f 74 02 00
	00		 jg	 $LN3@cckd_sf_in
  000a3	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ab	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  000b3	0f 84 5e 02 00
	00		 je	 $LN3@cckd_sf_in

; 3939 :     {
; 3940 :      DEVBLK       *dev2;
; 3941 :      CCKD_EXT     *cckd2;
; 3942 :      int           j;
; 3943 : 
; 3944 :         for (dev2 = cckdblk.dev1st; dev2; dev2 = cckd2->devnext)

  000b9	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  000c0	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR dev2$2[rsp], rax
  000c8	eb 13		 jmp	 SHORT $LN7@cckd_sf_in
$LN5@cckd_sf_in:
  000ca	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR cckd2$3[rsp]
  000d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d5	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR dev2$2[rsp], rax
$LN7@cckd_sf_in:
  000dd	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR dev2$2[rsp], 0
  000e6	0f 84 26 02 00
	00		 je	 $LN6@cckd_sf_in

; 3945 :         {
; 3946 :             cckd2 = dev2->cckd_ext;

  000ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev2$2[rsp]
  000f4	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  000fb	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR cckd2$3[rsp], rax

; 3947 :             if (dev2 == dev) continue;

  00103	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010b	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR dev2$2[rsp], rax
  00113	75 02		 jne	 SHORT $LN19@cckd_sf_in
  00115	eb b3		 jmp	 SHORT $LN5@cckd_sf_in
$LN19@cckd_sf_in:

; 3948 :             for (j = 0; j <= CCKD_MAX_SF && dev2->dasdsfn != NULL; j++)

  00117	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$1[rsp], 0
  00122	eb 10		 jmp	 SHORT $LN10@cckd_sf_in
$LN8@cckd_sf_in:
  00124	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR j$1[rsp]
  0012b	ff c0		 inc	 eax
  0012d	89 84 24 90 00
	00 00		 mov	 DWORD PTR j$1[rsp], eax
$LN10@cckd_sf_in:
  00134	83 bc 24 90 00
	00 00 08	 cmp	 DWORD PTR j$1[rsp], 8
  0013c	0f 8f cb 01 00
	00		 jg	 $LN9@cckd_sf_in
  00142	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev2$2[rsp]
  0014a	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  00152	0f 84 b5 01 00
	00		 je	 $LN9@cckd_sf_in

; 3949 :             {
; 3950 :                 if (strcmp (cckd_sf_name(dev, i),cckd_sf_name(dev2, j)) == 0)

  00158	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR j$1[rsp]
  0015f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev2$2[rsp]
  00167	e8 00 00 00 00	 call	 cckd_sf_name
  0016c	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv86[rsp], rax
  00174	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  0017b	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00183	e8 00 00 00 00	 call	 cckd_sf_name
  00188	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv86[rsp]
  00190	48 8b d1	 mov	 rdx, rcx
  00193	48 8b c8	 mov	 rcx, rax
  00196	e8 00 00 00 00	 call	 strcmp
  0019b	85 c0		 test	 eax, eax
  0019d	0f 85 65 01 00
	00		 jne	 $LN20@cckd_sf_in

; 3951 :                 {
; 3952 :                     // "%1d:%04X CCKD file[%d] %s: shadow file name collides with %1d:%04X file[%d] %s"
; 3953 :                     WRMSG (HHC00311, "E", LCSS_DEVNUM,  i, cckd_sf_name(dev,  i),

  001a3	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001ac	74 15		 je	 SHORT $LN34@cckd_sf_in
  001ae	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001b6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001ba	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv147[rsp], eax
  001c1	eb 0b		 jmp	 SHORT $LN35@cckd_sf_in
$LN34@cckd_sf_in:
  001c3	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv147[rsp], 0
$LN35@cckd_sf_in:
  001ce	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001d7	74 17		 je	 SHORT $LN36@cckd_sf_in
  001d9	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e1	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001e5	d1 f8		 sar	 eax, 1
  001e7	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv153[rsp], eax
  001ee	eb 0b		 jmp	 SHORT $LN37@cckd_sf_in
$LN36@cckd_sf_in:
  001f0	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv153[rsp], 0
$LN37@cckd_sf_in:
  001fb	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR j$1[rsp]
  00202	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev2$2[rsp]
  0020a	e8 00 00 00 00	 call	 cckd_sf_name
  0020f	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv95[rsp], rax
  00217	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev2$2[rsp]
  0021f	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00223	89 8c 24 bc 00
	00 00		 mov	 DWORD PTR tv133[rsp], ecx
  0022a	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR dev2$2[rsp]
  00232	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00236	d1 fa		 sar	 edx, 1
  00238	89 94 24 c0 00
	00 00		 mov	 DWORD PTR tv137[rsp], edx
  0023f	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00246	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0024e	e8 00 00 00 00	 call	 cckd_sf_name
  00253	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv139[rsp], rax
  0025b	b9 01 00 00 00	 mov	 ecx, 1
  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00266	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv95[rsp]
  0026e	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  00273	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR j$1[rsp]
  0027a	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0027e	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv133[rsp]
  00285	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00289	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv137[rsp]
  00290	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00294	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv139[rsp]
  0029c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002a1	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  002a8	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  002ac	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv147[rsp]
  002b3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002b7	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv153[rsp]
  002be	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171673
  002c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171674
  002d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002df	41 b9 03 00 00
	00		 mov	 r9d, 3
  002e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171675
  002ec	ba 72 0f 00 00	 mov	 edx, 3954		; 00000f72H
  002f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171676
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3954 :                                          SSID_TO_LCSS(dev2->ssid), dev2->devnum, j, cckd_sf_name(dev2, j));
; 3955 :                     return -1;

  002fe	b8 ff ff ff ff	 mov	 eax, -1
  00303	e9 7c 04 00 00	 jmp	 $LN1@cckd_sf_in
$LN20@cckd_sf_in:

; 3956 :                 }
; 3957 :             }

  00308	e9 17 fe ff ff	 jmp	 $LN8@cckd_sf_in
$LN9@cckd_sf_in:

; 3958 :         }

  0030d	e9 b8 fd ff ff	 jmp	 $LN5@cckd_sf_in
$LN6@cckd_sf_in:

; 3959 :     }

  00312	e9 6e fd ff ff	 jmp	 $LN2@cckd_sf_in
$LN3@cckd_sf_in:

; 3960 : 
; 3961 :     /* open all existing shadow files */
; 3962 :     for (cckd->sfn = 1; cckd->sfn <= CCKD_MAX_SF; cckd->sfn++)

  00317	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0031f	c7 40 3c 01 00
	00 00		 mov	 DWORD PTR [rax+60], 1
  00326	eb 18		 jmp	 SHORT $LN13@cckd_sf_in
$LN11@cckd_sf_in:
  00328	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00330	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00333	ff c0		 inc	 eax
  00335	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0033d	89 41 3c	 mov	 DWORD PTR [rcx+60], eax
$LN13@cckd_sf_in:
  00340	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00348	83 78 3c 08	 cmp	 DWORD PTR [rax+60], 8
  0034c	0f 8f 14 02 00
	00		 jg	 $LN12@cckd_sf_in

; 3963 :     {
; 3964 :         /* If no more shadow files remaining then we're done */
; 3965 :         hostpath( pathname, cckd_sf_name( dev, cckd->sfn ), sizeof( pathname ));

  00352	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0035a	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  0035d	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00365	e8 00 00 00 00	 call	 cckd_sf_name
  0036a	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00370	48 8b d0	 mov	 rdx, rax
  00373	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0037b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 3966 :         if (stat( pathname, &st ) < 0)

  00381	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR st$[rsp]
  00389	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00391	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64
  00397	85 c0		 test	 eax, eax
  00399	7d 05		 jge	 SHORT $LN21@cckd_sf_in

; 3967 :             break;

  0039b	e9 c6 01 00 00	 jmp	 $LN12@cckd_sf_in
$LN21@cckd_sf_in:

; 3968 : 
; 3969 :         /* Try to open the shadow file read-write then read-only */
; 3970 :         if (    cckd_open( dev, cckd->sfn, O_RDWR   | O_BINARY, 1 ) < 0)

  003a0	41 b9 01 00 00
	00		 mov	 r9d, 1
  003a6	41 b8 02 80 00
	00		 mov	 r8d, 32770		; 00008002H
  003ac	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  003b4	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  003b7	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003bf	e8 00 00 00 00	 call	 cckd_open
  003c4	85 c0		 test	 eax, eax
  003c6	7d 2a		 jge	 SHORT $LN22@cckd_sf_in

; 3971 :             if (cckd_open( dev, cckd->sfn, O_RDONLY | O_BINARY, 0 ) < 0)

  003c8	45 33 c9	 xor	 r9d, r9d
  003cb	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  003d1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  003d9	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  003dc	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003e4	e8 00 00 00 00	 call	 cckd_open
  003e9	85 c0		 test	 eax, eax
  003eb	7d 05		 jge	 SHORT $LN23@cckd_sf_in

; 3972 :                 break;

  003ed	e9 74 01 00 00	 jmp	 $LN12@cckd_sf_in
$LN23@cckd_sf_in:
$LN22@cckd_sf_in:

; 3973 : 
; 3974 :         /* Make sure shadow file type matches base image type */
; 3975 :         if (cckd_read( dev, cckd->sfn, 0, &devhdr, CKD_DEVHDR_SIZE ) < 0)

  003f2	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  003fa	4c 8d 8c 24 30
	01 00 00	 lea	 r9, QWORD PTR devhdr$[rsp]
  00402	45 33 c0	 xor	 r8d, r8d
  00405	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0040d	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00410	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00418	e8 00 00 00 00	 call	 cckd_read
  0041d	85 c0		 test	 eax, eax
  0041f	7d 0a		 jge	 SHORT $LN24@cckd_sf_in

; 3976 :             return -1;

  00421	b8 ff ff ff ff	 mov	 eax, -1
  00426	e9 59 03 00 00	 jmp	 $LN1@cckd_sf_in
$LN24@cckd_sf_in:

; 3977 :         if (!is_dh_devid_typ( devhdr.dh_devid, ANY32_SF_TYP ))

  0042b	ba 00 20 00 20	 mov	 edx, 536879104		; 20002000H
  00430	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  00438	e8 00 00 00 00	 call	 is_dh_devid_typ
  0043d	0f b6 c0	 movzx	 eax, al
  00440	85 c0		 test	 eax, eax
  00442	0f 85 db 00 00
	00		 jne	 $LN25@cckd_sf_in

; 3978 :         {
; 3979 :             // "%1d:%04X CCKD file[%d] %s: cckd/64 format differs from base"
; 3980 :             WRMSG( HHC00351, "E", LCSS_DEVNUM, cckd->sfn, pathname );

  00448	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00451	74 15		 je	 SHORT $LN38@cckd_sf_in
  00453	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0045b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0045f	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv215[rsp], eax
  00466	eb 0b		 jmp	 SHORT $LN39@cckd_sf_in
$LN38@cckd_sf_in:
  00468	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv215[rsp], 0
$LN39@cckd_sf_in:
  00473	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0047c	74 17		 je	 SHORT $LN40@cckd_sf_in
  0047e	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00486	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0048a	d1 f8		 sar	 eax, 1
  0048c	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv221[rsp], eax
  00493	eb 0b		 jmp	 SHORT $LN41@cckd_sf_in
$LN40@cckd_sf_in:
  00495	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv221[rsp], 0
$LN41@cckd_sf_in:
  004a0	b9 01 00 00 00	 mov	 ecx, 1
  004a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004ab	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  004b3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  004b8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  004c0	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  004c3	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  004c7	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv215[rsp]
  004ce	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004d2	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv221[rsp]
  004d9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171682
  004e4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171683
  004f0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004fa	41 b9 03 00 00
	00		 mov	 r9d, 3
  00500	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171684
  00507	ba 8c 0f 00 00	 mov	 edx, 3980		; 00000f8cH
  0050c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171685
  00513	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3981 :             return -1;

  00519	b8 ff ff ff ff	 mov	 eax, -1
  0051e	e9 61 02 00 00	 jmp	 $LN1@cckd_sf_in
$LN25@cckd_sf_in:

; 3982 :         }
; 3983 : 
; 3984 :         /* Call the chkdsk function */
; 3985 :         if ((rc = cckd_chkdsk( dev, 0 )) < 0)

  00523	33 d2		 xor	 edx, edx
  00525	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0052d	e8 00 00 00 00	 call	 cckd_chkdsk
  00532	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  00539	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00541	7d 0a		 jge	 SHORT $LN26@cckd_sf_in

; 3986 :             return -1;

  00543	b8 ff ff ff ff	 mov	 eax, -1
  00548	e9 37 02 00 00	 jmp	 $LN1@cckd_sf_in
$LN26@cckd_sf_in:

; 3987 : 
; 3988 :         /* Perform initial read */
; 3989 :         rc = cckd_read_init( dev );

  0054d	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00555	e8 00 00 00 00	 call	 cckd_read_init
  0055a	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3990 :     }

  00561	e9 c2 fd ff ff	 jmp	 $LN11@cckd_sf_in
$LN12@cckd_sf_in:

; 3991 : 
; 3992 :     /* Backup to the last opened file number */
; 3993 :     cckd->sfn--;

  00566	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0056e	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00571	ff c8		 dec	 eax
  00573	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0057b	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 3994 : 
; 3995 :     /* If the last file was opened read-only then create a new one */
; 3996 :     if (cckd->open[cckd->sfn] == CCKD_OPEN_RO)

  0057e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00586	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0058a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00592	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  0059a	83 f8 01	 cmp	 eax, 1
  0059d	75 52		 jne	 SHORT $LN27@cckd_sf_in

; 3997 :     {
; 3998 :         /* but ONLY IF not explicit batch utility READ-ONLY open */
; 3999 :         if (!(1

  0059f	33 c0		 xor	 eax, eax
  005a1	83 f8 01	 cmp	 eax, 1
  005a4	74 30		 je	 SHORT $LN29@cckd_sf_in
  005a6	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005ae	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005b4	c1 e8 0a	 shr	 eax, 10
  005b7	83 e0 01	 and	 eax, 1
  005ba	85 c0		 test	 eax, eax
  005bc	74 18		 je	 SHORT $LN29@cckd_sf_in
  005be	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005c6	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  005cc	c1 e8 12	 shr	 eax, 18
  005cf	83 e0 01	 and	 eax, 1
  005d2	85 c0		 test	 eax, eax
  005d4	75 1b		 jne	 SHORT $LN28@cckd_sf_in
$LN29@cckd_sf_in:

; 4000 :               && dev->batch
; 4001 :               && dev->ckdrdonly
; 4002 :         ))
; 4003 :         {
; 4004 :             /* NOT explicit batch utility read-only open: create new shadow file */
; 4005 :             if (cckd_sf_new(dev) < 0)

  005d6	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005de	e8 00 00 00 00	 call	 cckd_sf_new
  005e3	85 c0		 test	 eax, eax
  005e5	7d 0a		 jge	 SHORT $LN30@cckd_sf_in

; 4006 :                 return -1;

  005e7	b8 ff ff ff ff	 mov	 eax, -1
  005ec	e9 93 01 00 00	 jmp	 $LN1@cckd_sf_in
$LN30@cckd_sf_in:
$LN28@cckd_sf_in:
$LN27@cckd_sf_in:

; 4007 :         }
; 4008 :     }
; 4009 : 
; 4010 :     /* Re-open previous rdwr files rdonly */
; 4011 :     for (i = 0; i < cckd->sfn; i++)

  005f1	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  005fc	eb 10		 jmp	 SHORT $LN16@cckd_sf_in
$LN14@cckd_sf_in:
  005fe	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00605	ff c0		 inc	 eax
  00607	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN16@cckd_sf_in:
  0060e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00616	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00619	39 84 24 80 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00620	0f 8d 5c 01 00
	00		 jge	 $LN15@cckd_sf_in

; 4012 :     {
; 4013 :         if (cckd->open[i] == CCKD_OPEN_RO) continue;

  00626	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0062e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00636	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  0063e	83 f8 01	 cmp	 eax, 1
  00641	75 02		 jne	 SHORT $LN31@cckd_sf_in
  00643	eb b9		 jmp	 SHORT $LN14@cckd_sf_in
$LN31@cckd_sf_in:

; 4014 :         if (cckd_open (dev, i, O_RDONLY|O_BINARY, 0) < 0)

  00645	45 33 c9	 xor	 r9d, r9d
  00648	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  0064e	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00655	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0065d	e8 00 00 00 00	 call	 cckd_open
  00662	85 c0		 test	 eax, eax
  00664	0f 8d 13 01 00
	00		 jge	 $LN32@cckd_sf_in

; 4015 :         {
; 4016 :             // "%1d:%04X CCKD file[%d] %s: error re-opening readonly: %s"
; 4017 :             WRMSG (HHC00312, "E", LCSS_DEVNUM, i, cckd_sf_name(dev, i), strerror(errno));

  0066a	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00673	74 15		 je	 SHORT $LN42@cckd_sf_in
  00675	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0067d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00681	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv288[rsp], eax
  00688	eb 0b		 jmp	 SHORT $LN43@cckd_sf_in
$LN42@cckd_sf_in:
  0068a	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv288[rsp], 0
$LN43@cckd_sf_in:
  00695	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0069e	74 17		 je	 SHORT $LN44@cckd_sf_in
  006a0	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006a8	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  006ac	d1 f8		 sar	 eax, 1
  006ae	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv294[rsp], eax
  006b5	eb 0b		 jmp	 SHORT $LN45@cckd_sf_in
$LN44@cckd_sf_in:
  006b7	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv294[rsp], 0
$LN45@cckd_sf_in:
  006c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  006c8	8b 08		 mov	 ecx, DWORD PTR [rax]
  006ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  006d0	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv276[rsp], rax
  006d8	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  006df	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006e7	e8 00 00 00 00	 call	 cckd_sf_name
  006ec	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv280[rsp], rax
  006f4	b9 01 00 00 00	 mov	 ecx, 1
  006f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006ff	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv276[rsp]
  00707	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0070c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv280[rsp]
  00714	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00719	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00720	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00724	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv288[rsp]
  0072b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0072f	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv294[rsp]
  00736	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0073a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171693
  00741	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00746	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171694
  0074d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00752	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00757	41 b9 03 00 00
	00		 mov	 r9d, 3
  0075d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171695
  00764	ba b1 0f 00 00	 mov	 edx, 4017		; 00000fb1H
  00769	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171696
  00770	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4018 :             return -1;

  00776	b8 ff ff ff ff	 mov	 eax, -1
  0077b	eb 07		 jmp	 SHORT $LN1@cckd_sf_in
$LN32@cckd_sf_in:

; 4019 :         }
; 4020 :     }

  0077d	e9 7c fe ff ff	 jmp	 $LN14@cckd_sf_in
$LN15@cckd_sf_in:

; 4021 : 
; 4022 :     return 0;

  00782	33 c0		 xor	 eax, eax
$LN1@cckd_sf_in:

; 4023 : 
; 4024 : } /* end function cckd_sf_init */

  00784	48 8b 8c 24 40
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0078c	48 33 cc	 xor	 rcx, rsp
  0078f	e8 00 00 00 00	 call	 __security_check_cookie
  00794	48 81 c4 58 04
	00 00		 add	 rsp, 1112		; 00000458H
  0079b	c3		 ret	 0
cckd_sf_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 8
sfx$ = 16
cckd_sf_name PROC

; 3862 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 3863 :     /* Return base file name if index is 0 */
; 3864 :     if (sfx == 0)

  00009	83 7c 24 10 00	 cmp	 DWORD PTR sfx$[rsp], 0
  0000e	75 0d		 jne	 SHORT $LN2@cckd_sf_na

; 3865 :         return dev->filename;

  00010	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  00015	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0001b	eb 53		 jmp	 SHORT $LN1@cckd_sf_na
$LN2@cckd_sf_na:

; 3866 : 
; 3867 :     /* Error if no shadow file name specified or number exceeded */
; 3868 :     if (dev->dasdsfn == NULL || sfx > CCKD_MAX_SF)

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  00022	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  0002a	74 07		 je	 SHORT $LN4@cckd_sf_na
  0002c	83 7c 24 10 08	 cmp	 DWORD PTR sfx$[rsp], 8
  00031	7e 04		 jle	 SHORT $LN3@cckd_sf_na
$LN4@cckd_sf_na:

; 3869 :         return NULL;

  00033	33 c0		 xor	 eax, eax
  00035	eb 39		 jmp	 SHORT $LN1@cckd_sf_na
$LN3@cckd_sf_na:

; 3870 : 
; 3871 :     /* Set the suffix character in the shadow file name */
; 3872 :     if (sfx > 0)

  00037	83 7c 24 10 00	 cmp	 DWORD PTR sfx$[rsp], 0
  0003c	7e 17		 jle	 SHORT $LN5@cckd_sf_na

; 3873 :         *dev->dasdsfx = (char)('0' + sfx);

  0003e	8b 44 24 10	 mov	 eax, DWORD PTR sfx$[rsp]
  00042	83 c0 30	 add	 eax, 48			; 00000030H
  00045	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dev$[rsp]
  0004a	48 8b 89 78 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4472]
  00051	88 01		 mov	 BYTE PTR [rcx], al
  00053	eb 0f		 jmp	 SHORT $LN6@cckd_sf_na
$LN5@cckd_sf_na:

; 3874 :     else
; 3875 :         *dev->dasdsfx = '*';

  00055	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  0005a	48 8b 80 78 11
	00 00		 mov	 rax, QWORD PTR [rax+4472]
  00061	c6 00 2a	 mov	 BYTE PTR [rax], 42	; 0000002aH
$LN6@cckd_sf_na:

; 3876 : 
; 3877 :     return dev->dasdsfn;

  00064	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  00069	48 8b 80 70 11
	00 00		 mov	 rax, QWORD PTR [rax+4464]
$LN1@cckd_sf_na:

; 3878 : 
; 3879 : } /* end function cckd_sf_name */

  00070	c3		 ret	 0
cckd_sf_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
fn$1 = 32
pathname$ = 48
__$ArrayPad$ = 320
dev$ = 352
sfn$ = 360
cckd_sf_parse_sfn PROC

; 3885 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3886 :     char pathname[MAX_PATH];
; 3887 :     if ('\"' == sfn[0]) sfn++;

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 00	 imul	 rax, rax, 0
  0002c	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR sfn$[rsp]
  00034	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00038	83 f8 22	 cmp	 eax, 34			; 00000022H
  0003b	75 13		 jne	 SHORT $LN2@cckd_sf_pa
  0003d	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR sfn$[rsp]
  00045	48 ff c0	 inc	 rax
  00048	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR sfn$[rsp], rax
$LN2@cckd_sf_pa:

; 3888 :     hostpath(pathname, sfn, sizeof(pathname));

  00050	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00056	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR sfn$[rsp]
  0005e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pathname$[rsp]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 3889 :     dev->dasdsfn = strdup(pathname);

  00069	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pathname$[rsp]
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00074	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0007c	48 89 81 70 11
	00 00		 mov	 QWORD PTR [rcx+4464], rax

; 3890 :     if (dev->dasdsfn)

  00083	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008b	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  00093	0f 84 cc 00 00
	00		 je	 $LN3@cckd_sf_pa

; 3891 :     {
; 3892 :         /*
; 3893 :         **         Set the pointer to the suffix character
; 3894 :         **
; 3895 :         ** The shadow file name should have spot where the shadow file
; 3896 :         ** number will be set.  This is either the character preceding
; 3897 :         ** the last period after the last slash (i.e. the last character
; 3898 :         ** of the filename, immediately before the file extension), or
; 3899 :         ** the very last character of the filename itself if the file
; 3900 :         ** extension was not specified.
; 3901 :         */
; 3902 :         char* fn;
; 3903 :         if ((fn = strrchr( dev->dasdsfn, PATHSEPC )) != NULL)

  00099	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  0009e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a6	48 8b 88 70 11
	00 00		 mov	 rcx, QWORD PTR [rax+4464]
  000ad	e8 00 00 00 00	 call	 strrchr
  000b2	48 89 44 24 20	 mov	 QWORD PTR fn$1[rsp], rax
  000b7	48 83 7c 24 20
	00		 cmp	 QWORD PTR fn$1[rsp], 0
  000bd	74 0f		 je	 SHORT $LN4@cckd_sf_pa

; 3904 :             fn++;

  000bf	48 8b 44 24 20	 mov	 rax, QWORD PTR fn$1[rsp]
  000c4	48 ff c0	 inc	 rax
  000c7	48 89 44 24 20	 mov	 QWORD PTR fn$1[rsp], rax
  000cc	eb 14		 jmp	 SHORT $LN5@cckd_sf_pa
$LN4@cckd_sf_pa:

; 3905 :         else
; 3906 :             fn = dev->dasdsfn;

  000ce	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d6	48 8b 80 70 11
	00 00		 mov	 rax, QWORD PTR [rax+4464]
  000dd	48 89 44 24 20	 mov	 QWORD PTR fn$1[rsp], rax
$LN5@cckd_sf_pa:

; 3907 : 
; 3908 :         dev->dasdsfx = strrchr( fn, '.' );  /* Find last period */

  000e2	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  000e7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR fn$1[rsp]
  000ec	e8 00 00 00 00	 call	 strrchr
  000f1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000f9	48 89 81 78 11
	00 00		 mov	 QWORD PTR [rcx+4472], rax

; 3909 : 
; 3910 :         if (dev->dasdsfx == NULL)

  00100	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00108	48 83 b8 78 11
	00 00 00	 cmp	 QWORD PTR [rax+4472], 0
  00110	75 32		 jne	 SHORT $LN6@cckd_sf_pa

; 3911 :             dev->dasdsfx = dev->dasdsfn + strlen(dev->dasdsfn);

  00112	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011a	48 8b 88 70 11
	00 00		 mov	 rcx, QWORD PTR [rax+4464]
  00121	e8 00 00 00 00	 call	 strlen
  00126	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0012e	48 03 81 70 11
	00 00		 add	 rax, QWORD PTR [rcx+4464]
  00135	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0013d	48 89 81 78 11
	00 00		 mov	 QWORD PTR [rcx+4472], rax
$LN6@cckd_sf_pa:

; 3912 : 
; 3913 :         dev->dasdsfx--;     /* Shadow file number will go here */

  00144	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014c	48 8b 80 78 11
	00 00		 mov	 rax, QWORD PTR [rax+4472]
  00153	48 ff c8	 dec	 rax
  00156	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0015e	48 89 81 78 11
	00 00		 mov	 QWORD PTR [rcx+4472], rax
$LN3@cckd_sf_pa:

; 3914 :     }
; 3915 : }

  00165	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0016d	48 33 cc	 xor	 rcx, rsp
  00170	e8 00 00 00 00	 call	 __security_check_cookie
  00175	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  0017c	c3		 ret	 0
cckd_sf_parse_sfn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
sz$ = 160
r$ = 164
vlen$ = 168
tv208 = 172
kl$ = 176
dl$ = 180
tv156 = 184
cckd$ = 192
rn$ = 200
__$ArrayPad$ = 208
dev$ = 288
buf$ = 296
trk$ = 304
len$ = 312
cckd_validate PROC

; 3776 : {

$LN23:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	53		 push	 rbx
  00015	55		 push	 rbp
  00016	56		 push	 rsi
  00017	57		 push	 rdi
  00018	41 54		 push	 r12
  0001a	41 56		 push	 r14
  0001c	41 57		 push	 r15
  0001e	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002c	48 33 c4	 xor	 rax, rsp
  0002f	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3777 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3778 : int             r;                      /* Record number             */
; 3779 : int             sz;                     /* Track size                */
; 3780 : int             vlen;                   /* Validation length         */
; 3781 : int             kl, dl;                 /* Key/Data lengths          */
; 3782 : CKD_RECHDR      rn;                     /* Record-n (r0, r1 ... rn)  */
; 3783 : 
; 3784 :     cckd = dev->cckd_ext;

  00037	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003f	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00046	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 3785 : 
; 3786 :     if (!buf || len < 0)

  0004e	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00057	74 0a		 je	 SHORT $LN6@cckd_valid
  00059	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00061	7d 0a		 jge	 SHORT $LN5@cckd_valid
$LN6@cckd_valid:

; 3787 :         return -1;

  00063	b8 ff ff ff ff	 mov	 eax, -1
  00068	e9 ee 05 00 00	 jmp	 $LN1@cckd_valid
$LN5@cckd_valid:

; 3788 : 
; 3789 :     CCKD_TRACE( "validating %s %d len %d %2.2x%2.2x%2.2x%2.2x%2.2x "

  0006d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00075	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00078	83 e0 01	 and	 eax, 1
  0007b	85 c0		 test	 eax, eax
  0007d	74 11		 je	 SHORT $LN19@cckd_valid
  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171584
  00086	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv156[rsp], rax
  0008e	eb 0f		 jmp	 SHORT $LN20@cckd_valid
$LN19@cckd_valid:
  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171585
  00097	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv156[rsp], rax
$LN20@cckd_valid:
  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 0c	 imul	 rax, rax, 12
  000a8	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  000b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	48 6b c9 0b	 imul	 rcx, rcx, 11
  000bd	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000c5	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000c9	ba 01 00 00 00	 mov	 edx, 1
  000ce	48 6b d2 0a	 imul	 rdx, rdx, 10
  000d2	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  000da	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  000df	41 b8 01 00 00
	00		 mov	 r8d, 1
  000e5	4d 6b c0 09	 imul	 r8, r8, 9
  000e9	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  000f1	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  000f6	41 b9 01 00 00
	00		 mov	 r9d, 1
  000fc	4d 6b c9 08	 imul	 r9, r9, 8
  00100	4c 8b 94 24 28
	01 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  00108	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  0010d	41 ba 01 00 00
	00		 mov	 r10d, 1
  00113	4d 6b d2 07	 imul	 r10, r10, 7
  00117	4c 8b 9c 24 28
	01 00 00	 mov	 r11, QWORD PTR buf$[rsp]
  0011f	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  00124	41 bb 01 00 00
	00		 mov	 r11d, 1
  0012a	4d 6b db 06	 imul	 r11, r11, 6
  0012e	48 8b 9c 24 28
	01 00 00	 mov	 rbx, QWORD PTR buf$[rsp]
  00136	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  0013b	41 bb 01 00 00
	00		 mov	 r11d, 1
  00141	4d 6b db 05	 imul	 r11, r11, 5
  00145	48 8b bc 24 28
	01 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  0014d	42 0f b6 3c 1f	 movzx	 edi, BYTE PTR [rdi+r11]
  00152	41 bb 01 00 00
	00		 mov	 r11d, 1
  00158	4d 6b db 04	 imul	 r11, r11, 4
  0015c	48 8b b4 24 28
	01 00 00	 mov	 rsi, QWORD PTR buf$[rsp]
  00164	42 0f b6 34 1e	 movzx	 esi, BYTE PTR [rsi+r11]
  00169	41 bb 01 00 00
	00		 mov	 r11d, 1
  0016f	4d 6b db 03	 imul	 r11, r11, 3
  00173	48 8b ac 24 28
	01 00 00	 mov	 rbp, QWORD PTR buf$[rsp]
  0017b	41 0f b6 2c 2b	 movzx	 ebp, BYTE PTR [r11+rbp]
  00180	41 bb 01 00 00
	00		 mov	 r11d, 1
  00186	4d 6b db 02	 imul	 r11, r11, 2
  0018a	4c 8b b4 24 28
	01 00 00	 mov	 r14, QWORD PTR buf$[rsp]
  00192	47 0f b6 1c 1e	 movzx	 r11d, BYTE PTR [r14+r11]
  00197	41 be 01 00 00
	00		 mov	 r14d, 1
  0019d	4d 6b f6 01	 imul	 r14, r14, 1
  001a1	4c 8b bc 24 28
	01 00 00	 mov	 r15, QWORD PTR buf$[rsp]
  001a9	47 0f b6 34 37	 movzx	 r14d, BYTE PTR [r15+r14]
  001ae	41 bf 01 00 00
	00		 mov	 r15d, 1
  001b4	4d 6b ff 00	 imul	 r15, r15, 0
  001b8	4c 8b a4 24 28
	01 00 00	 mov	 r12, QWORD PTR buf$[rsp]
  001c0	47 0f b6 3c 3c	 movzx	 r15d, BYTE PTR [r12+r15]
  001c5	89 84 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], eax
  001cc	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  001d3	89 94 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], edx
  001da	44 89 84 24 80
	00 00 00	 mov	 DWORD PTR [rsp+128], r8d
  001e2	44 89 4c 24 78	 mov	 DWORD PTR [rsp+120], r9d
  001e7	44 89 54 24 70	 mov	 DWORD PTR [rsp+112], r10d
  001ec	89 5c 24 68	 mov	 DWORD PTR [rsp+104], ebx
  001f0	89 7c 24 60	 mov	 DWORD PTR [rsp+96], edi
  001f4	89 74 24 58	 mov	 DWORD PTR [rsp+88], esi
  001f8	89 6c 24 50	 mov	 DWORD PTR [rsp+80], ebp
  001fc	44 89 5c 24 48	 mov	 DWORD PTR [rsp+72], r11d
  00201	44 89 74 24 40	 mov	 DWORD PTR [rsp+64], r14d
  00206	44 89 7c 24 38	 mov	 DWORD PTR [rsp+56], r15d
  0020b	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00212	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00216	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0021d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00221	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv156[rsp]
  00229	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171586
  00235	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0023d	ba d2 0e 00 00	 mov	 edx, 3794		; 00000ed2H
  00242	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171587
  00249	e8 00 00 00 00	 call	 cckd_trace

; 3790 :                 "%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
; 3791 :                 cckd->ckddasd ? "trk" : "blkgrp", trk, len,
; 3792 :                 buf[0], buf[ 1], buf[ 2], buf[ 3], buf[4], // trkhdr
; 3793 :                 buf[5], buf[ 6], buf[ 7], buf[ 8],         // r0 (0-3)
; 3794 :                 buf[9], buf[10], buf[11], buf[12] );       // r0 (4-7)
; 3795 : 
; 3796 :     /* FBA dasd check */
; 3797 :     if (cckd->fbadasd)

  0024e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00256	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00259	d1 e8		 shr	 eax, 1
  0025b	83 e0 01	 and	 eax, 1
  0025e	85 c0		 test	 eax, eax
  00260	74 5c		 je	 SHORT $LN7@cckd_valid

; 3798 :     {
; 3799 :         if (!len || len == CKD_TRKHDR_SIZE + CFBA_BLKGRP_SIZE)

  00262	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  0026a	74 10		 je	 SHORT $LN9@cckd_valid
  0026c	48 63 84 24 38
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00274	48 3d 05 f0 00
	00		 cmp	 rax, 61445		; 0000f005H
  0027a	75 0c		 jne	 SHORT $LN8@cckd_valid
$LN9@cckd_valid:

; 3800 :             return len;

  0027c	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00283	e9 d3 03 00 00	 jmp	 $LN1@cckd_valid
$LN8@cckd_valid:

; 3801 :         CCKD_TRACE( "validation failed: bad length%s", "" );

  00288	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171591
  0028f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00294	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171592
  0029b	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  002a3	ba d9 0e 00 00	 mov	 edx, 3801		; 00000ed9H
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171593
  002af	e8 00 00 00 00	 call	 cckd_trace

; 3802 :         return -1;

  002b4	b8 ff ff ff ff	 mov	 eax, -1
  002b9	e9 9d 03 00 00	 jmp	 $LN1@cckd_valid
$LN7@cckd_valid:

; 3803 :     }
; 3804 : 
; 3805 :     /* validate record 0 */
; 3806 : 
; 3807 :     memcpy( &rn, &buf[CKD_TRKHDR_SIZE], CKD_R0_SIZE );

  002be	b8 01 00 00 00	 mov	 eax, 1
  002c3	48 6b c0 05	 imul	 rax, rax, 5
  002c7	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  002cf	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  002d3	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR rn$[rsp], rax

; 3808 :     rn.cyl[0] &= 0x7f; /* fix for ovflow */

  002db	b8 01 00 00 00	 mov	 eax, 1
  002e0	48 6b c0 00	 imul	 rax, rax, 0
  002e4	0f b6 84 04 c8
	00 00 00	 movzx	 eax, BYTE PTR rn$[rsp+rax]
  002ec	83 e0 7f	 and	 eax, 127		; 0000007fH
  002ef	b9 01 00 00 00	 mov	 ecx, 1
  002f4	48 6b c9 00	 imul	 rcx, rcx, 0
  002f8	88 84 0c c8 00
	00 00		 mov	 BYTE PTR rn$[rsp+rcx], al

; 3809 : 
; 3810 :     if (0
; 3811 :         || rn.rec  != 0
; 3812 :         || rn.klen != 0
; 3813 :         || fetch_hw( rn.dlen ) != CKD_R0_DLEN

  002ff	33 c0		 xor	 eax, eax
  00301	85 c0		 test	 eax, eax
  00303	75 35		 jne	 SHORT $LN11@cckd_valid
  00305	0f b6 84 24 cc
	00 00 00	 movzx	 eax, BYTE PTR rn$[rsp+4]
  0030d	85 c0		 test	 eax, eax
  0030f	75 29		 jne	 SHORT $LN11@cckd_valid
  00311	0f b6 84 24 cd
	00 00 00	 movzx	 eax, BYTE PTR rn$[rsp+5]
  00319	85 c0		 test	 eax, eax
  0031b	75 1d		 jne	 SHORT $LN11@cckd_valid
  0031d	48 8d 8c 24 ce
	00 00 00	 lea	 rcx, QWORD PTR rn$[rsp+6]
  00325	e8 00 00 00 00	 call	 fetch_hw_noswap
  0032a	0f b7 c8	 movzx	 ecx, ax
  0032d	e8 00 00 00 00	 call	 _byteswap_ushort
  00332	0f b7 c0	 movzx	 eax, ax
  00335	83 f8 08	 cmp	 eax, 8
  00338	74 36		 je	 SHORT $LN10@cckd_valid
$LN11@cckd_valid:

; 3814 :     )
; 3815 :     {
; 3816 :         CCKD_TRACE( "validation failed: bad r0%s", "" );

  0033a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171596
  00341	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00346	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171597
  0034d	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00355	ba e8 0e 00 00	 mov	 edx, 3816		; 00000ee8H
  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171598
  00361	e8 00 00 00 00	 call	 cckd_trace

; 3817 :         return -1;

  00366	b8 ff ff ff ff	 mov	 eax, -1
  0036b	e9 eb 02 00 00	 jmp	 $LN1@cckd_valid
$LN10@cckd_valid:

; 3818 :     }
; 3819 : 
; 3820 :     /* validate records 1 thru n */
; 3821 : 
; 3822 :     vlen = len > 0 ? len : dev->ckdtrksz;

  00370	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00378	7e 10		 jle	 SHORT $LN21@cckd_valid
  0037a	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00381	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv208[rsp], eax
  00388	eb 15		 jmp	 SHORT $LN22@cckd_valid
$LN21@cckd_valid:
  0038a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00392	8b 80 c4 12 00
	00		 mov	 eax, DWORD PTR [rax+4804]
  00398	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv208[rsp], eax
$LN22@cckd_valid:
  0039f	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv208[rsp]
  003a6	89 84 24 a8 00
	00 00		 mov	 DWORD PTR vlen$[rsp], eax

; 3823 : 
; 3824 :     for (r = 1, sz = CKD_TRKHDR_SIZE + (CKD_R0_SIZE + CKD_R0_DLEN);

  003ad	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR r$[rsp], 1
  003b8	c7 84 24 a0 00
	00 00 15 00 00
	00		 mov	 DWORD PTR sz$[rsp], 21
  003c3	eb 3a		 jmp	 SHORT $LN4@cckd_valid
$LN2@cckd_valid:

; 3826 :         sz += CKD_RECHDR_SIZE + kl + dl, r++)

  003c5	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR kl$[rsp]
  003cd	48 63 8c 24 b4
	00 00 00	 movsxd	 rcx, DWORD PTR dl$[rsp]
  003d5	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  003da	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR sz$[rsp]
  003e2	48 03 c8	 add	 rcx, rax
  003e5	48 8b c1	 mov	 rax, rcx
  003e8	89 84 24 a0 00
	00 00		 mov	 DWORD PTR sz$[rsp], eax
  003ef	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR r$[rsp]
  003f6	ff c0		 inc	 eax
  003f8	89 84 24 a4 00
	00 00		 mov	 DWORD PTR r$[rsp], eax
$LN4@cckd_valid:

; 3825 :         sz +  CKD_ENDTRK_SIZE <= vlen;

  003ff	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR sz$[rsp]
  00407	48 83 c0 08	 add	 rax, 8
  0040b	48 63 8c 24 a8
	00 00 00	 movsxd	 rcx, DWORD PTR vlen$[rsp]
  00413	48 3b c1	 cmp	 rax, rcx
  00416	0f 8f c8 01 00
	00		 jg	 $LN3@cckd_valid

; 3827 :     {
; 3828 :         memcpy( &rn, &buf[sz], CKD_RECHDR_SIZE );

  0041c	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR sz$[rsp]
  00424	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0042c	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00430	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR rn$[rsp], rax

; 3829 : 
; 3830 :         if (memcmp( &rn, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  00438	41 b8 08 00 00
	00		 mov	 r8d, 8
  0043e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  00445	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR rn$[rsp]
  0044d	e8 00 00 00 00	 call	 memcmp
  00452	85 c0		 test	 eax, eax
  00454	75 05		 jne	 SHORT $LN12@cckd_valid

; 3831 :             break;

  00456	e9 89 01 00 00	 jmp	 $LN3@cckd_valid
$LN12@cckd_valid:

; 3832 : 
; 3833 :         kl = rn.klen;

  0045b	0f b6 84 24 cd
	00 00 00	 movzx	 eax, BYTE PTR rn$[rsp+5]
  00463	89 84 24 b0 00
	00 00		 mov	 DWORD PTR kl$[rsp], eax

; 3834 :         dl = fetch_hw( rn.dlen );

  0046a	48 8d 8c 24 ce
	00 00 00	 lea	 rcx, QWORD PTR rn$[rsp+6]
  00472	e8 00 00 00 00	 call	 fetch_hw_noswap
  00477	0f b7 c8	 movzx	 ecx, ax
  0047a	e8 00 00 00 00	 call	 _byteswap_ushort
  0047f	0f b7 c0	 movzx	 eax, ax
  00482	89 84 24 b4 00
	00 00		 mov	 DWORD PTR dl$[rsp], eax

; 3835 : 
; 3836 :         if (rn.rec == 0 || sz + CKD_RECHDR_SIZE + kl + dl >= vlen)

  00489	0f b6 84 24 cc
	00 00 00	 movzx	 eax, BYTE PTR rn$[rsp+4]
  00491	85 c0		 test	 eax, eax
  00493	74 31		 je	 SHORT $LN14@cckd_valid
  00495	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR sz$[rsp]
  0049d	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR kl$[rsp]
  004a5	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  004aa	48 63 8c 24 b4
	00 00 00	 movsxd	 rcx, DWORD PTR dl$[rsp]
  004b2	48 03 c1	 add	 rax, rcx
  004b5	48 63 8c 24 a8
	00 00 00	 movsxd	 rcx, DWORD PTR vlen$[rsp]
  004bd	48 3b c1	 cmp	 rax, rcx
  004c0	0f 8c 19 01 00
	00		 jl	 $LN13@cckd_valid
$LN14@cckd_valid:

; 3837 :         {
; 3838 :             CCKD_TRACE( "validation failed: bad r%d "

  004c6	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sz$[rsp]
  004cd	83 c0 07	 add	 eax, 7
  004d0	48 98		 cdqe
  004d2	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  004da	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004de	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR sz$[rsp]
  004e5	83 c1 06	 add	 ecx, 6
  004e8	48 63 c9	 movsxd	 rcx, ecx
  004eb	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  004f3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  004f7	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR sz$[rsp]
  004fe	83 c2 05	 add	 edx, 5
  00501	48 63 d2	 movsxd	 rdx, edx
  00504	48 8b 9c 24 28
	01 00 00	 mov	 rbx, QWORD PTR buf$[rsp]
  0050c	0f b6 14 13	 movzx	 edx, BYTE PTR [rbx+rdx]
  00510	8b 9c 24 a0 00
	00 00		 mov	 ebx, DWORD PTR sz$[rsp]
  00517	83 c3 04	 add	 ebx, 4
  0051a	48 63 db	 movsxd	 rbx, ebx
  0051d	48 8b bc 24 28
	01 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  00525	0f b6 1c 1f	 movzx	 ebx, BYTE PTR [rdi+rbx]
  00529	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR sz$[rsp]
  00530	83 c7 03	 add	 edi, 3
  00533	48 63 ff	 movsxd	 rdi, edi
  00536	48 8b b4 24 28
	01 00 00	 mov	 rsi, QWORD PTR buf$[rsp]
  0053e	0f b6 3c 3e	 movzx	 edi, BYTE PTR [rsi+rdi]
  00542	8b b4 24 a0 00
	00 00		 mov	 esi, DWORD PTR sz$[rsp]
  00549	83 c6 02	 add	 esi, 2
  0054c	48 63 f6	 movsxd	 rsi, esi
  0054f	48 8b ac 24 28
	01 00 00	 mov	 rbp, QWORD PTR buf$[rsp]
  00557	0f b6 34 2e	 movzx	 esi, BYTE PTR [rsi+rbp]
  0055b	8b ac 24 a0 00
	00 00		 mov	 ebp, DWORD PTR sz$[rsp]
  00562	ff c5		 inc	 ebp
  00564	48 63 ed	 movsxd	 rbp, ebp
  00567	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  0056f	41 0f b6 2c 28	 movzx	 ebp, BYTE PTR [r8+rbp]
  00574	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR sz$[rsp]
  0057c	4d 63 c0	 movsxd	 r8, r8d
  0057f	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  00587	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  0058c	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00590	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00594	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  00598	89 5c 24 48	 mov	 DWORD PTR [rsp+72], ebx
  0059c	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  005a0	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  005a4	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  005a8	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  005ad	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR r$[rsp]
  005b4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005b8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171602
  005bf	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  005c7	ba 01 0f 00 00	 mov	 edx, 3841		; 00000f01H
  005cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171603
  005d3	e8 00 00 00 00	 call	 cckd_trace

; 3839 :                         "%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
; 3840 :                         r, buf[sz+0], buf[sz+1], buf[sz+2], buf[sz+3],
; 3841 :                            buf[sz+4], buf[sz+5], buf[sz+6], buf[sz+7] );
; 3842 :              return -1;

  005d8	b8 ff ff ff ff	 mov	 eax, -1
  005dd	eb 7c		 jmp	 SHORT $LN1@cckd_valid
$LN13@cckd_valid:

; 3843 :         }
; 3844 :     }

  005df	e9 e1 fd ff ff	 jmp	 $LN2@cckd_valid
$LN3@cckd_valid:

; 3845 : 
; 3846 :     sz += CKD_ENDTRK_SIZE;

  005e4	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR sz$[rsp]
  005ec	48 83 c0 08	 add	 rax, 8
  005f0	89 84 24 a0 00
	00 00		 mov	 DWORD PTR sz$[rsp], eax

; 3847 : 
; 3848 :     if ((len > 0 && sz != len) || sz > vlen)

  005f7	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  005ff	7e 10		 jle	 SHORT $LN17@cckd_valid
  00601	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00608	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR sz$[rsp], eax
  0060f	75 10		 jne	 SHORT $LN16@cckd_valid
$LN17@cckd_valid:
  00611	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR vlen$[rsp]
  00618	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR sz$[rsp], eax
  0061f	7e 33		 jle	 SHORT $LN15@cckd_valid
$LN16@cckd_valid:

; 3849 :     {
; 3850 :         CCKD_TRACE( "validation failed: no eot%s", "" );

  00621	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171607
  00628	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0062d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171608
  00634	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0063c	ba 0a 0f 00 00	 mov	 edx, 3850		; 00000f0aH
  00641	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171609
  00648	e8 00 00 00 00	 call	 cckd_trace

; 3851 :         return -1;

  0064d	b8 ff ff ff ff	 mov	 eax, -1
  00652	eb 07		 jmp	 SHORT $LN1@cckd_valid
$LN15@cckd_valid:

; 3852 :     }
; 3853 : 
; 3854 :     return sz;

  00654	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sz$[rsp]
$LN1@cckd_valid:

; 3855 : 
; 3856 : } /* end function cckd_validate */

  0065b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00663	48 33 cc	 xor	 rcx, rsp
  00666	e8 00 00 00 00	 call	 __security_check_cookie
  0066b	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  00672	41 5f		 pop	 r15
  00674	41 5e		 pop	 r14
  00676	41 5c		 pop	 r12
  00678	5f		 pop	 rdi
  00679	5e		 pop	 rsi
  0067a	5d		 pop	 rbp
  0067b	5b		 pop	 rbx
  0067c	c3		 ret	 0
cckd_validate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
badcomp$ = 160
t$ = 164
cckd$ = 168
cyl$ = 176
head$ = 180
tv170 = 184
tv176 = 188
tv253 = 192
tv259 = 196
tv313 = 200
tv319 = 204
tv372 = 208
tv378 = 212
tv141 = 216
tv145 = 220
tv149 = 224
tv153 = 228
tv157 = 232
tv224 = 236
tv228 = 240
tv232 = 244
tv236 = 248
tv240 = 252
tv332 = 256
tv336 = 260
tv340 = 264
tv344 = 268
tv348 = 272
tv138 = 276
tv296 = 280
tv301 = 288
tv355 = 296
tv360 = 304
tv160 = 312
tv243 = 320
tv389 = 328
tv288 = 336
tv303 = 344
tv362 = 352
dev$ = 384
buf$ = 392
trk$ = 400
cckd_cchh PROC

; 3690 : {

$LN44:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H

; 3691 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3692 : U16             cyl;                    /* Cylinder                  */
; 3693 : U16             head;                   /* Head                      */
; 3694 : int             t;                      /* Calculated track          */
; 3695 : BYTE            badcomp=0;              /* 1=Unsupported compression */

  00016	c6 84 24 a0 00
	00 00 00	 mov	 BYTE PTR badcomp$[rsp], 0

; 3696 : 
; 3697 :     cckd = dev->cckd_ext;

  0001e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0002d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 3698 : 
; 3699 :     /* CKD dasd header verification */
; 3700 :     if (cckd->ckddasd)

  00035	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0003d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00040	83 e0 01	 and	 eax, 1
  00043	85 c0		 test	 eax, eax
  00045	0f 84 76 03 00
	00		 je	 $LN2@cckd_cchh

; 3701 :     {
; 3702 :         cyl = fetch_hw (buf + 1);

  0004b	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00053	48 ff c0	 inc	 rax
  00056	48 8b c8	 mov	 rcx, rax
  00059	e8 00 00 00 00	 call	 fetch_hw_noswap
  0005e	0f b7 c8	 movzx	 ecx, ax
  00061	e8 00 00 00 00	 call	 _byteswap_ushort
  00066	66 89 84 24 b0
	00 00 00	 mov	 WORD PTR cyl$[rsp], ax

; 3703 :         head = fetch_hw (buf + 3);

  0006e	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00076	48 83 c0 03	 add	 rax, 3
  0007a	48 8b c8	 mov	 rcx, rax
  0007d	e8 00 00 00 00	 call	 fetch_hw_noswap
  00082	0f b7 c8	 movzx	 ecx, ax
  00085	e8 00 00 00 00	 call	 _byteswap_ushort
  0008a	66 89 84 24 b4
	00 00 00	 mov	 WORD PTR head$[rsp], ax

; 3704 :         t = cyl * dev->ckdheads + head;

  00092	0f b7 84 24 b0
	00 00 00	 movzx	 eax, WORD PTR cyl$[rsp]
  0009a	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a2	0f af 81 c0 12
	00 00		 imul	 eax, DWORD PTR [rcx+4800]
  000a9	0f b7 8c 24 b4
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  000b1	03 c1		 add	 eax, ecx
  000b3	89 84 24 a4 00
	00 00		 mov	 DWORD PTR t$[rsp], eax

; 3705 : 
; 3706 :         if (1
; 3707 :             && cyl  < dev->ckdcyls
; 3708 :             && head < dev->ckdheads
; 3709 :             && (trk == -1 || t == trk)

  000ba	33 c0		 xor	 eax, eax
  000bc	83 f8 01	 cmp	 eax, 1
  000bf	0f 84 f7 02 00
	00		 je	 $LN4@cckd_cchh
  000c5	0f b7 84 24 b0
	00 00 00	 movzx	 eax, WORD PTR cyl$[rsp]
  000cd	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000d5	3b 81 b8 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4792]
  000db	0f 8d db 02 00
	00		 jge	 $LN4@cckd_cchh
  000e1	0f b7 84 24 b4
	00 00 00	 movzx	 eax, WORD PTR head$[rsp]
  000e9	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000f1	3b 81 c0 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4800]
  000f7	0f 8d bf 02 00
	00		 jge	 $LN4@cckd_cchh
  000fd	83 bc 24 90 01
	00 00 ff	 cmp	 DWORD PTR trk$[rsp], -1
  00105	74 14		 je	 SHORT $LN5@cckd_cchh
  00107	8b 84 24 90 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0010e	39 84 24 a4 00
	00 00		 cmp	 DWORD PTR t$[rsp], eax
  00115	0f 85 a1 02 00
	00		 jne	 $LN4@cckd_cchh
$LN5@cckd_cchh:

; 3710 :         )
; 3711 :         {
; 3712 :             if (buf[0] & ~cckdblk.comps)

  0011b	b8 01 00 00 00	 mov	 eax, 1
  00120	48 6b c0 00	 imul	 rax, rax, 0
  00124	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0012c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00130	0f b6 0d 1c 00
	00 00		 movzx	 ecx, BYTE PTR cckdblk+28
  00137	f7 d1		 not	 ecx
  00139	23 c1		 and	 eax, ecx
  0013b	85 c0		 test	 eax, eax
  0013d	0f 84 3f 02 00
	00		 je	 $LN6@cckd_cchh

; 3713 :             {
; 3714 :                 if (buf[0] & ~CCKD_COMPRESS_MASK)

  00143	b8 01 00 00 00	 mov	 eax, 1
  00148	48 6b c0 00	 imul	 rax, rax, 0
  0014c	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00154	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00158	83 e0 fc	 and	 eax, -4
  0015b	85 c0		 test	 eax, eax
  0015d	0f 84 1f 02 00
	00		 je	 $LN7@cckd_cchh

; 3715 :                 {
; 3716 :                     if (cckdblk.bytemsgs++ < 10)

  00163	8b 05 18 03 00
	00		 mov	 eax, DWORD PTR cckdblk+792
  00169	89 84 24 14 01
	00 00		 mov	 DWORD PTR tv138[rsp], eax
  00170	8b 05 18 03 00
	00		 mov	 eax, DWORD PTR cckdblk+792
  00176	ff c0		 inc	 eax
  00178	89 05 18 03 00
	00		 mov	 DWORD PTR cckdblk+792, eax
  0017e	83 bc 24 14 01
	00 00 0a	 cmp	 DWORD PTR tv138[rsp], 10
  00186	0f 8d ca 01 00
	00		 jge	 $LN8@cckd_cchh

; 3717 :                         // "%1d:%04X CCKD file[%d] %s: invalid byte 0 trk %d, buf %2.2x%2.2x%2.2x%2.2x%2.2x"
; 3718 :                         WRMSG (HHC00307, "E", LCSS_DEVNUM, cckd->sfn,

  0018c	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00195	74 15		 je	 SHORT $LN20@cckd_cchh
  00197	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001a3	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv170[rsp], eax
  001aa	eb 0b		 jmp	 SHORT $LN21@cckd_cchh
$LN20@cckd_cchh:
  001ac	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv170[rsp], 0
$LN21@cckd_cchh:
  001b7	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001c0	74 17		 je	 SHORT $LN22@cckd_cchh
  001c2	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ca	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001ce	d1 f8		 sar	 eax, 1
  001d0	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv176[rsp], eax
  001d7	eb 0b		 jmp	 SHORT $LN23@cckd_cchh
$LN22@cckd_cchh:
  001d9	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv176[rsp], 0
$LN23@cckd_cchh:
  001e4	b8 01 00 00 00	 mov	 eax, 1
  001e9	48 6b c0 04	 imul	 rax, rax, 4
  001ed	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  001f5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f9	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv141[rsp], eax
  00200	b9 01 00 00 00	 mov	 ecx, 1
  00205	48 6b c9 03	 imul	 rcx, rcx, 3
  00209	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00211	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00215	89 8c 24 dc 00
	00 00		 mov	 DWORD PTR tv145[rsp], ecx
  0021c	ba 01 00 00 00	 mov	 edx, 1
  00221	48 6b d2 02	 imul	 rdx, rdx, 2
  00225	4c 8b 84 24 88
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  0022d	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00232	89 94 24 e0 00
	00 00		 mov	 DWORD PTR tv149[rsp], edx
  00239	41 b8 01 00 00
	00		 mov	 r8d, 1
  0023f	4d 6b c0 01	 imul	 r8, r8, 1
  00243	4c 8b 8c 24 88
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  0024b	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00250	44 89 84 24 e4
	00 00 00	 mov	 DWORD PTR tv153[rsp], r8d
  00258	41 b9 01 00 00
	00		 mov	 r9d, 1
  0025e	4d 6b c9 00	 imul	 r9, r9, 0
  00262	4c 8b 94 24 88
	01 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  0026a	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  0026f	44 89 8c 24 e8
	00 00 00	 mov	 DWORD PTR tv157[rsp], r9d
  00277	4c 8b 94 24 a8
	00 00 00	 mov	 r10, QWORD PTR cckd$[rsp]
  0027f	41 8b 52 3c	 mov	 edx, DWORD PTR [r10+60]
  00283	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0028b	e8 00 00 00 00	 call	 cckd_sf_name
  00290	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv160[rsp], rax
  00298	b9 01 00 00 00	 mov	 ecx, 1
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a3	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv141[rsp]
  002aa	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  002b1	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv145[rsp]
  002b8	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  002bc	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv149[rsp]
  002c3	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  002c7	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv153[rsp]
  002ce	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  002d2	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv157[rsp]
  002d9	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  002dd	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR t$[rsp]
  002e4	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  002e8	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv160[rsp]
  002f0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002f5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  002fd	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00300	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00304	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv170[rsp]
  0030b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0030f	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv176[rsp]
  00316	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0031a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171510
  00321	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171511
  0032d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00332	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00337	41 b9 03 00 00
	00		 mov	 r9d, 3
  0033d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171512
  00344	ba 87 0e 00 00	 mov	 edx, 3719		; 00000e87H
  00349	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171513
  00350	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@cckd_cchh:

; 3719 :                             cckd_sf_name (dev, cckd->sfn), t, buf[0],buf[1],buf[2],buf[3],buf[4]);
; 3720 :                     buf[0] &= CCKD_COMPRESS_MASK;

  00356	b8 01 00 00 00	 mov	 eax, 1
  0035b	48 6b c0 00	 imul	 rax, rax, 0
  0035f	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00367	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0036b	83 e0 03	 and	 eax, 3
  0036e	b9 01 00 00 00	 mov	 ecx, 1
  00373	48 6b c9 00	 imul	 rcx, rcx, 0
  00377	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0037f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN7@cckd_cchh:
$LN6@cckd_cchh:

; 3721 :                 }
; 3722 :             }
; 3723 :             if (buf[0] & ~cckdblk.comps)

  00382	b8 01 00 00 00	 mov	 eax, 1
  00387	48 6b c0 00	 imul	 rax, rax, 0
  0038b	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00393	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00397	0f b6 0d 1c 00
	00 00		 movzx	 ecx, BYTE PTR cckdblk+28
  0039e	f7 d1		 not	 ecx
  003a0	23 c1		 and	 eax, ecx
  003a2	85 c0		 test	 eax, eax
  003a4	74 0a		 je	 SHORT $LN9@cckd_cchh

; 3724 :                 badcomp = 1;

  003a6	c6 84 24 a0 00
	00 00 01	 mov	 BYTE PTR badcomp$[rsp], 1
  003ae	eb 0c		 jmp	 SHORT $LN10@cckd_cchh
$LN9@cckd_cchh:

; 3725 :             else
; 3726 :                 return t;

  003b0	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR t$[rsp]
  003b7	e9 13 07 00 00	 jmp	 $LN1@cckd_cchh
$LN10@cckd_cchh:
$LN4@cckd_cchh:

; 3727 :         }
; 3728 :     }

  003bc	e9 d2 02 00 00	 jmp	 $LN3@cckd_cchh
$LN2@cckd_cchh:

; 3729 :     /* FBA dasd header verification */
; 3730 :     else
; 3731 :     {
; 3732 :         t = fetch_fw (buf + 1);

  003c1	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  003c9	48 ff c0	 inc	 rax
  003cc	48 8b c8	 mov	 rcx, rax
  003cf	e8 00 00 00 00	 call	 fetch_fw_noswap
  003d4	8b c8		 mov	 ecx, eax
  003d6	e8 00 00 00 00	 call	 _byteswap_ulong
  003db	89 84 24 a4 00
	00 00		 mov	 DWORD PTR t$[rsp], eax

; 3733 :         if (t < dev->fbanumblk && (trk == -1 || t == trk))

  003e2	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003ea	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  003f0	39 84 24 a4 00
	00 00		 cmp	 DWORD PTR t$[rsp], eax
  003f7	0f 8d 96 02 00
	00		 jge	 $LN11@cckd_cchh
  003fd	83 bc 24 90 01
	00 00 ff	 cmp	 DWORD PTR trk$[rsp], -1
  00405	74 14		 je	 SHORT $LN12@cckd_cchh
  00407	8b 84 24 90 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0040e	39 84 24 a4 00
	00 00		 cmp	 DWORD PTR t$[rsp], eax
  00415	0f 85 78 02 00
	00		 jne	 $LN11@cckd_cchh
$LN12@cckd_cchh:

; 3734 :         {
; 3735 :             if (buf[0] & ~cckdblk.comps)

  0041b	b8 01 00 00 00	 mov	 eax, 1
  00420	48 6b c0 00	 imul	 rax, rax, 0
  00424	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0042c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00430	0f b6 0d 1c 00
	00 00		 movzx	 ecx, BYTE PTR cckdblk+28
  00437	f7 d1		 not	 ecx
  00439	23 c1		 and	 eax, ecx
  0043b	85 c0		 test	 eax, eax
  0043d	0f 84 16 02 00
	00		 je	 $LN13@cckd_cchh

; 3736 :             {
; 3737 :                 if (buf[0] & ~CCKD_COMPRESS_MASK)

  00443	b8 01 00 00 00	 mov	 eax, 1
  00448	48 6b c0 00	 imul	 rax, rax, 0
  0044c	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00454	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00458	83 e0 fc	 and	 eax, -4
  0045b	85 c0		 test	 eax, eax
  0045d	0f 84 f6 01 00
	00		 je	 $LN14@cckd_cchh

; 3738 :                 {
; 3739 :                     // "%1d:%04X CCKD file[%d] %s: invalid byte 0 blkgrp %d, buf %2.2x%2.2x%2.2x%2.2x%2.2x"
; 3740 :                     WRMSG (HHC00308, "E", LCSS_DEVNUM, cckd->sfn,

  00463	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0046c	74 15		 je	 SHORT $LN24@cckd_cchh
  0046e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00476	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0047a	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv253[rsp], eax
  00481	eb 0b		 jmp	 SHORT $LN25@cckd_cchh
$LN24@cckd_cchh:
  00483	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv253[rsp], 0
$LN25@cckd_cchh:
  0048e	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00497	74 17		 je	 SHORT $LN26@cckd_cchh
  00499	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004a1	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  004a5	d1 f8		 sar	 eax, 1
  004a7	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv259[rsp], eax
  004ae	eb 0b		 jmp	 SHORT $LN27@cckd_cchh
$LN26@cckd_cchh:
  004b0	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv259[rsp], 0
$LN27@cckd_cchh:
  004bb	b8 01 00 00 00	 mov	 eax, 1
  004c0	48 6b c0 04	 imul	 rax, rax, 4
  004c4	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  004cc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004d0	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv224[rsp], eax
  004d7	b9 01 00 00 00	 mov	 ecx, 1
  004dc	48 6b c9 03	 imul	 rcx, rcx, 3
  004e0	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  004e8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  004ec	89 8c 24 f0 00
	00 00		 mov	 DWORD PTR tv228[rsp], ecx
  004f3	ba 01 00 00 00	 mov	 edx, 1
  004f8	48 6b d2 02	 imul	 rdx, rdx, 2
  004fc	4c 8b 84 24 88
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  00504	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00509	89 94 24 f4 00
	00 00		 mov	 DWORD PTR tv232[rsp], edx
  00510	41 b8 01 00 00
	00		 mov	 r8d, 1
  00516	4d 6b c0 01	 imul	 r8, r8, 1
  0051a	4c 8b 8c 24 88
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  00522	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00527	44 89 84 24 f8
	00 00 00	 mov	 DWORD PTR tv236[rsp], r8d
  0052f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00535	4d 6b c9 00	 imul	 r9, r9, 0
  00539	4c 8b 94 24 88
	01 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  00541	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  00546	44 89 8c 24 fc
	00 00 00	 mov	 DWORD PTR tv240[rsp], r9d
  0054e	4c 8b 94 24 a8
	00 00 00	 mov	 r10, QWORD PTR cckd$[rsp]
  00556	41 8b 52 3c	 mov	 edx, DWORD PTR [r10+60]
  0055a	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00562	e8 00 00 00 00	 call	 cckd_sf_name
  00567	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv243[rsp], rax
  0056f	b9 01 00 00 00	 mov	 ecx, 1
  00574	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0057a	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv224[rsp]
  00581	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  00588	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv228[rsp]
  0058f	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00593	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv232[rsp]
  0059a	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  0059e	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv236[rsp]
  005a5	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  005a9	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv240[rsp]
  005b0	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  005b4	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR t$[rsp]
  005bb	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  005bf	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv243[rsp]
  005c7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005cc	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  005d4	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  005d7	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  005db	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv253[rsp]
  005e2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005e6	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv259[rsp]
  005ed	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171520
  005f8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171521
  00604	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00609	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0060e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00614	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171522
  0061b	ba 9d 0e 00 00	 mov	 edx, 3741		; 00000e9dH
  00620	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171523
  00627	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3741 :                             cckd_sf_name (dev, cckd->sfn), t, buf[0],buf[1],buf[2],buf[3],buf[4]);
; 3742 :                     buf[0] &= CCKD_COMPRESS_MASK;

  0062d	b8 01 00 00 00	 mov	 eax, 1
  00632	48 6b c0 00	 imul	 rax, rax, 0
  00636	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0063e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00642	83 e0 03	 and	 eax, 3
  00645	b9 01 00 00 00	 mov	 ecx, 1
  0064a	48 6b c9 00	 imul	 rcx, rcx, 0
  0064e	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00656	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN14@cckd_cchh:
$LN13@cckd_cchh:

; 3743 :                 }
; 3744 :             }
; 3745 :             if (buf[0] & ~cckdblk.comps)

  00659	b8 01 00 00 00	 mov	 eax, 1
  0065e	48 6b c0 00	 imul	 rax, rax, 0
  00662	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0066a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0066e	0f b6 0d 1c 00
	00 00		 movzx	 ecx, BYTE PTR cckdblk+28
  00675	f7 d1		 not	 ecx
  00677	23 c1		 and	 eax, ecx
  00679	85 c0		 test	 eax, eax
  0067b	74 0a		 je	 SHORT $LN15@cckd_cchh

; 3746 :                 badcomp = 1;

  0067d	c6 84 24 a0 00
	00 00 01	 mov	 BYTE PTR badcomp$[rsp], 1
  00685	eb 0c		 jmp	 SHORT $LN16@cckd_cchh
$LN15@cckd_cchh:

; 3747 :             else
; 3748 :                 return t;

  00687	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR t$[rsp]
  0068e	e9 3c 04 00 00	 jmp	 $LN1@cckd_cchh
$LN16@cckd_cchh:
$LN11@cckd_cchh:
$LN3@cckd_cchh:

; 3749 :         }
; 3750 :     }
; 3751 : 
; 3752 :     if (badcomp)

  00693	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR badcomp$[rsp]
  0069b	85 c0		 test	 eax, eax
  0069d	0f 84 c4 01 00
	00		 je	 $LN17@cckd_cchh

; 3753 :     {
; 3754 :         // "%1d:%04X CCKD file[%d] %s: invalid %s hdr %s %d: %s compression unsupported"
; 3755 :         WRMSG (HHC00309, "E", LCSS_DEVNUM, cckd->sfn, cckd_sf_name (dev, cckd->sfn),

  006a3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  006ab	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  006ae	83 e0 01	 and	 eax, 1
  006b1	85 c0		 test	 eax, eax
  006b3	74 11		 je	 SHORT $LN28@cckd_cchh
  006b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171528
  006bc	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv296[rsp], rax
  006c4	eb 0f		 jmp	 SHORT $LN29@cckd_cchh
$LN28@cckd_cchh:
  006c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171529
  006cd	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv296[rsp], rax
$LN29@cckd_cchh:
  006d5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  006dd	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  006e0	83 e0 01	 and	 eax, 1
  006e3	85 c0		 test	 eax, eax
  006e5	74 11		 je	 SHORT $LN30@cckd_cchh
  006e7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171530
  006ee	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv301[rsp], rax
  006f6	eb 0f		 jmp	 SHORT $LN31@cckd_cchh
$LN30@cckd_cchh:
  006f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171531
  006ff	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv301[rsp], rax
$LN31@cckd_cchh:
  00707	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00710	74 15		 je	 SHORT $LN32@cckd_cchh
  00712	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0071a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0071e	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv313[rsp], eax
  00725	eb 0b		 jmp	 SHORT $LN33@cckd_cchh
$LN32@cckd_cchh:
  00727	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv313[rsp], 0
$LN33@cckd_cchh:
  00732	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0073b	74 17		 je	 SHORT $LN34@cckd_cchh
  0073d	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00745	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00749	d1 f8		 sar	 eax, 1
  0074b	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv319[rsp], eax
  00752	eb 0b		 jmp	 SHORT $LN35@cckd_cchh
$LN34@cckd_cchh:
  00754	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv319[rsp], 0
$LN35@cckd_cchh:
  0075f	b8 01 00 00 00	 mov	 eax, 1
  00764	48 6b c0 00	 imul	 rax, rax, 0
  00768	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00770	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00774	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv288[rsp], rax
  0077c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compname
  00783	48 89 8c 24 48
	01 00 00	 mov	 QWORD PTR tv389[rsp], rcx
  0078b	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR cckd$[rsp]
  00793	8b 52 3c	 mov	 edx, DWORD PTR [rdx+60]
  00796	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0079e	e8 00 00 00 00	 call	 cckd_sf_name
  007a3	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv303[rsp], rax
  007ab	b9 01 00 00 00	 mov	 ecx, 1
  007b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007b6	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR tv389[rsp]
  007be	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv288[rsp]
  007c6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  007ca	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  007cf	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR t$[rsp]
  007d6	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  007da	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv296[rsp]
  007e2	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  007e7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv301[rsp]
  007ef	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  007f4	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv303[rsp]
  007fc	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00801	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00809	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  0080c	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00810	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv313[rsp]
  00817	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0081b	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv319[rsp]
  00822	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00826	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171532
  0082d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00832	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171533
  00839	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0083e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00843	41 b9 03 00 00
	00		 mov	 r9d, 3
  00849	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171534
  00850	ba ad 0e 00 00	 mov	 edx, 3757		; 00000eadH
  00855	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171535
  0085c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3756 :                 cckd->ckddasd ? "trk" : "blk",
; 3757 :                 cckd->ckddasd ? "trk" : "blk", t, compname[buf[0]]);
; 3758 :     }

  00862	e9 63 02 00 00	 jmp	 $LN18@cckd_cchh
$LN17@cckd_cchh:

; 3759 :     else
; 3760 :     {
; 3761 :         // "%1d:%04X CCKD file[%d] %s: invalid %s hdr %s %d buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x"
; 3762 :         WRMSG (HHC00310, "E", LCSS_DEVNUM, cckd->sfn, cckd_sf_name (dev, cckd->sfn),

  00867	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0086f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00872	83 e0 01	 and	 eax, 1
  00875	85 c0		 test	 eax, eax
  00877	74 11		 je	 SHORT $LN36@cckd_cchh
  00879	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171536
  00880	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv355[rsp], rax
  00888	eb 0f		 jmp	 SHORT $LN37@cckd_cchh
$LN36@cckd_cchh:
  0088a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171537
  00891	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv355[rsp], rax
$LN37@cckd_cchh:
  00899	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  008a1	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  008a4	83 e0 01	 and	 eax, 1
  008a7	85 c0		 test	 eax, eax
  008a9	74 11		 je	 SHORT $LN38@cckd_cchh
  008ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171538
  008b2	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv360[rsp], rax
  008ba	eb 0f		 jmp	 SHORT $LN39@cckd_cchh
$LN38@cckd_cchh:
  008bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171539
  008c3	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv360[rsp], rax
$LN39@cckd_cchh:
  008cb	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  008d4	74 15		 je	 SHORT $LN40@cckd_cchh
  008d6	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008de	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  008e2	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv372[rsp], eax
  008e9	eb 0b		 jmp	 SHORT $LN41@cckd_cchh
$LN40@cckd_cchh:
  008eb	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv372[rsp], 0
$LN41@cckd_cchh:
  008f6	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  008ff	74 17		 je	 SHORT $LN42@cckd_cchh
  00901	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00909	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0090d	d1 f8		 sar	 eax, 1
  0090f	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv378[rsp], eax
  00916	eb 0b		 jmp	 SHORT $LN43@cckd_cchh
$LN42@cckd_cchh:
  00918	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv378[rsp], 0
$LN43@cckd_cchh:
  00923	b8 01 00 00 00	 mov	 eax, 1
  00928	48 6b c0 04	 imul	 rax, rax, 4
  0092c	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00934	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00938	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv332[rsp], eax
  0093f	b9 01 00 00 00	 mov	 ecx, 1
  00944	48 6b c9 03	 imul	 rcx, rcx, 3
  00948	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00950	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00954	89 8c 24 04 01
	00 00		 mov	 DWORD PTR tv336[rsp], ecx
  0095b	ba 01 00 00 00	 mov	 edx, 1
  00960	48 6b d2 02	 imul	 rdx, rdx, 2
  00964	4c 8b 84 24 88
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  0096c	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00971	89 94 24 08 01
	00 00		 mov	 DWORD PTR tv340[rsp], edx
  00978	41 b8 01 00 00
	00		 mov	 r8d, 1
  0097e	4d 6b c0 01	 imul	 r8, r8, 1
  00982	4c 8b 8c 24 88
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  0098a	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  0098f	44 89 84 24 0c
	01 00 00	 mov	 DWORD PTR tv344[rsp], r8d
  00997	41 b9 01 00 00
	00		 mov	 r9d, 1
  0099d	4d 6b c9 00	 imul	 r9, r9, 0
  009a1	4c 8b 94 24 88
	01 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  009a9	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  009ae	44 89 8c 24 10
	01 00 00	 mov	 DWORD PTR tv348[rsp], r9d
  009b6	4c 8b 94 24 a8
	00 00 00	 mov	 r10, QWORD PTR cckd$[rsp]
  009be	41 8b 52 3c	 mov	 edx, DWORD PTR [r10+60]
  009c2	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009ca	e8 00 00 00 00	 call	 cckd_sf_name
  009cf	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv362[rsp], rax
  009d7	b9 01 00 00 00	 mov	 ecx, 1
  009dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009e2	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv332[rsp]
  009e9	89 8c 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], ecx
  009f0	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv336[rsp]
  009f7	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  009fe	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv340[rsp]
  00a05	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  00a0c	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv344[rsp]
  00a13	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  00a1a	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv348[rsp]
  00a21	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00a25	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00a2d	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  00a32	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00a39	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00a3d	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv355[rsp]
  00a45	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00a4a	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv360[rsp]
  00a52	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00a57	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv362[rsp]
  00a5f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00a64	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00a6c	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00a6f	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00a73	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv372[rsp]
  00a7a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a7e	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv378[rsp]
  00a85	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a89	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171540
  00a90	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a95	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171541
  00a9c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00aa1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00aa6	41 b9 03 00 00
	00		 mov	 r9d, 3
  00aac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171542
  00ab3	ba b5 0e 00 00	 mov	 edx, 3765		; 00000eb5H
  00ab8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171543
  00abf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3763 :                 cckd->ckddasd ? "trk" : "blk",
; 3764 :                 cckd->ckddasd ? "trk" : "blk", trk,
; 3765 :                 buf, buf[0], buf[1], buf[2], buf[3], buf[4]);
; 3766 :         cckd_print_itrace ();

  00ac5	e8 00 00 00 00	 call	 cckd_print_itrace
$LN18@cckd_cchh:

; 3767 :     }
; 3768 : 
; 3769 :     return -1;

  00aca	b8 ff ff ff ff	 mov	 eax, -1
$LN1@cckd_cchh:

; 3770 : } /* end function cckd_cchh */

  00acf	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  00ad6	c3		 ret	 0
cckd_cchh ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
rc$ = 32
cckd$ = 40
buf2$ = 48
__$ArrayPad$ = 65584
dev$ = 65616
buf$ = 65624
trk$ = 65632
len$ = 65640
cckd_check_null_trk PROC

; 3660 : {

$LN11:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	b8 48 00 01 00	 mov	 eax, 65608		; 00010048H
  00019	e8 00 00 00 00	 call	 __chkstk
  0001e	48 2b e0	 sub	 rsp, rax
  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00028	48 33 c4	 xor	 rax, rsp
  0002b	48 89 84 24 30
	00 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3661 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3662 : int             rc;                     /* Return code               */
; 3663 : BYTE            buf2[65536];            /* Null track buffer         */
; 3664 : 
; 3665 :     if (dev->cckd64)

  00033	48 8b 84 24 50
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00042	24 01		 and	 al, 1
  00044	0f b6 c0	 movzx	 eax, al
  00047	85 c0		 test	 eax, eax
  00049	74 2a		 je	 SHORT $LN2@cckd_check

; 3666 :         return cckd64_check_null_trk( dev, buf, trk, len );

  0004b	44 8b 8c 24 68
	00 01 00	 mov	 r9d, DWORD PTR len$[rsp]
  00053	44 8b 84 24 60
	00 01 00	 mov	 r8d, DWORD PTR trk$[rsp]
  0005b	48 8b 94 24 58
	00 01 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00063	48 8b 8c 24 50
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0006b	e8 00 00 00 00	 call	 cckd64_check_null_trk
  00070	e9 e2 00 00 00	 jmp	 $LN1@cckd_check
$LN2@cckd_check:

; 3667 : 
; 3668 :     cckd = dev->cckd_ext;

  00075	48 8b 84 24 50
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007d	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00084	48 89 44 24 28	 mov	 QWORD PTR cckd$[rsp], rax

; 3669 :     rc = len;

  00089	8b 84 24 68 00
	01 00		 mov	 eax, DWORD PTR len$[rsp]
  00090	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 3670 : 
; 3671 :     if (len == CKD_NULLTRK_SIZE0)

  00094	48 63 84 24 68
	00 01 00	 movsxd	 rax, DWORD PTR len$[rsp]
  0009c	48 83 f8 25	 cmp	 rax, 37			; 00000025H
  000a0	75 0d		 jne	 SHORT $LN3@cckd_check

; 3672 :         rc = CKD_NULLTRK_FMT0;

  000a2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
  000aa	e9 a4 00 00 00	 jmp	 $LN4@cckd_check
$LN3@cckd_check:

; 3673 :     else if (len == CKD_NULLTRK_SIZE1)

  000af	48 63 84 24 68
	00 01 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000b7	48 83 f8 1d	 cmp	 rax, 29
  000bb	75 0d		 jne	 SHORT $LN5@cckd_check

; 3674 :         rc = CKD_NULLTRK_FMT1;

  000bd	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
  000c5	e9 89 00 00 00	 jmp	 $LN6@cckd_check
$LN5@cckd_check:

; 3675 :     else if (len == CKD_NULLTRK_SIZE2 && dev->oslinux
; 3676 :           && (!cckd->notnull || cckdblk.linuxnull))

  000ca	48 63 84 24 68
	00 01 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000d2	48 3d 7d c0 00
	00		 cmp	 rax, 49277		; 0000c07dH
  000d8	75 79		 jne	 SHORT $LN7@cckd_check
  000da	48 8b 84 24 50
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000e8	c1 e8 0d	 shr	 eax, 13
  000eb	83 e0 01	 and	 eax, 1
  000ee	85 c0		 test	 eax, eax
  000f0	74 61		 je	 SHORT $LN7@cckd_check
  000f2	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  000f7	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000fa	c1 e8 07	 shr	 eax, 7
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 09		 je	 SHORT $LN8@cckd_check
  00104	83 3d 58 02 00
	00 00		 cmp	 DWORD PTR cckdblk+600, 0
  0010b	74 46		 je	 SHORT $LN7@cckd_check
$LN8@cckd_check:

; 3677 :     {
; 3678 :          cckd_null_trk (dev, buf2, trk, 0);

  0010d	45 33 c9	 xor	 r9d, r9d
  00110	44 8b 84 24 60
	00 01 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00118	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf2$[rsp]
  0011d	48 8b 8c 24 50
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00125	e8 00 00 00 00	 call	 cckd_null_trk

; 3679 :          if (memcmp(buf, buf2, len) == 0)

  0012a	48 63 84 24 68
	00 01 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00132	4c 8b c0	 mov	 r8, rax
  00135	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf2$[rsp]
  0013a	48 8b 8c 24 58
	00 01 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00142	e8 00 00 00 00	 call	 memcmp
  00147	85 c0		 test	 eax, eax
  00149	75 08		 jne	 SHORT $LN9@cckd_check

; 3680 :             rc = CKD_NULLTRK_FMT2;

  0014b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR rc$[rsp], 2
$LN9@cckd_check:
$LN7@cckd_check:
$LN6@cckd_check:
$LN4@cckd_check:

; 3681 :     }
; 3682 : 
; 3683 :     return rc;

  00153	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cckd_check:

; 3684 : }

  00157	48 8b 8c 24 30
	00 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0015f	48 33 cc	 xor	 rcx, rsp
  00162	e8 00 00 00 00	 call	 __security_check_cookie
  00167	48 81 c4 48 00
	01 00		 add	 rsp, 65608		; 00010048H
  0016e	c3		 ret	 0
cckd_check_null_trk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
r$ = 64
pos$ = 72
rechdr$ = 80
cyl$ = 88
head$ = 92
len$ = 96
i$ = 100
cckd$ = 104
trkhdr$ = 112
tv240 = 120
tv226 = 128
dev$ = 160
buf$ = 168
trk$ = 176
nullfmt$ = 184
cckd_null_trk PROC

; 3550 : {

$LN18:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 3551 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3552 : int             i;                      /* Loop counter              */
; 3553 : CKD_TRKHDR     *trkhdr;                 /* -> Track header           */
; 3554 : CKD_RECHDR     *rechdr;                 /* -> Record header          */
; 3555 : U32             cyl;                    /* Cylinder number           */
; 3556 : U32             head;                   /* Head number               */
; 3557 : BYTE            r;                      /* Record number             */
; 3558 : BYTE           *pos;                    /* -> Next position in buffer*/
; 3559 : int             len;                    /* Length of null track      */
; 3560 : 
; 3561 :     if (dev->cckd64)

  0001c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00024	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0002b	24 01		 and	 al, 1
  0002d	0f b6 c0	 movzx	 eax, al
  00030	85 c0		 test	 eax, eax
  00032	74 2a		 je	 SHORT $LN5@cckd_null_

; 3562 :         return cckd64_null_trk( dev, buf, trk, nullfmt );

  00034	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR nullfmt$[rsp]
  0003c	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00044	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0004c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00054	e8 00 00 00 00	 call	 cckd64_null_trk
  00059	e9 2c 04 00 00	 jmp	 $LN1@cckd_null_
$LN5@cckd_null_:

; 3563 : 
; 3564 :     cckd = dev->cckd_ext;

  0005e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00066	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0006d	48 89 44 24 68	 mov	 QWORD PTR cckd$[rsp], rax

; 3565 : 
; 3566 :     if (nullfmt < 0 || nullfmt > CKD_NULLTRK_FMTMAX)

  00072	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR nullfmt$[rsp], 0
  0007a	7c 0a		 jl	 SHORT $LN8@cckd_null_
  0007c	83 bc 24 b8 00
	00 00 02	 cmp	 DWORD PTR nullfmt$[rsp], 2
  00084	7e 26		 jle	 SHORT $LN6@cckd_null_
$LN8@cckd_null_:

; 3567 :         nullfmt = cckd->cdevhdr[cckd->sfn].cdh_nullfmt;

  00086	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0008b	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0008f	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00096	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  0009b	0f b6 84 01 0c
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+524]
  000a3	89 84 24 b8 00
	00 00		 mov	 DWORD PTR nullfmt$[rsp], eax
  000aa	eb 37		 jmp	 SHORT $LN7@cckd_null_
$LN6@cckd_null_:

; 3568 : 
; 3569 :     // FIXME
; 3570 :     // Compatibility check for nullfmt bug and linux -- 18 May 2005
; 3571 :     // Remove at some reasonable date in the future
; 3572 :     else if (nullfmt == 0
; 3573 :      && cckd->cdevhdr[cckd->sfn].cdh_nullfmt == CKD_NULLTRK_FMT2)

  000ac	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR nullfmt$[rsp], 0
  000b4	75 2d		 jne	 SHORT $LN9@cckd_null_
  000b6	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  000bb	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  000bf	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000c6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  000cb	0f b6 84 01 0c
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+524]
  000d3	83 f8 02	 cmp	 eax, 2
  000d6	75 0b		 jne	 SHORT $LN9@cckd_null_

; 3574 :         nullfmt = CKD_NULLTRK_FMT2;

  000d8	c7 84 24 b8 00
	00 00 02 00 00
	00		 mov	 DWORD PTR nullfmt$[rsp], 2
$LN9@cckd_null_:
$LN7@cckd_null_:

; 3575 : 
; 3576 :     if (cckd->ckddasd)

  000e3	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  000e8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000eb	83 e0 01	 and	 eax, 1
  000ee	85 c0		 test	 eax, eax
  000f0	0f 84 d8 02 00
	00		 je	 $LN10@cckd_null_

; 3577 :     {
; 3578 : 
; 3579 :         /* cylinder and head calculations */
; 3580 :         cyl = trk / dev->ckdheads;

  000f6	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  000fd	99		 cdq
  000fe	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00106	f7 b9 c0 12 00
	00		 idiv	 DWORD PTR [rcx+4800]
  0010c	89 44 24 58	 mov	 DWORD PTR cyl$[rsp], eax

; 3581 :         head = trk % dev->ckdheads;

  00110	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00117	99		 cdq
  00118	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00120	f7 b9 c0 12 00
	00		 idiv	 DWORD PTR [rcx+4800]
  00126	8b c2		 mov	 eax, edx
  00128	89 44 24 5c	 mov	 DWORD PTR head$[rsp], eax

; 3582 : 
; 3583 :         /* Build the track header */
; 3584 :         trkhdr = (CKD_TRKHDR*)buf;

  0012c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00134	48 89 44 24 70	 mov	 QWORD PTR trkhdr$[rsp], rax

; 3585 :         trkhdr->bin = 0;

  00139	48 8b 44 24 70	 mov	 rax, QWORD PTR trkhdr$[rsp]
  0013e	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3586 :         store_hw( &trkhdr->cyl,  (U16) cyl  );

  00141	0f b7 4c 24 58	 movzx	 ecx, WORD PTR cyl$[rsp]
  00146	e8 00 00 00 00	 call	 _byteswap_ushort
  0014b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  00150	48 ff c1	 inc	 rcx
  00153	0f b7 d0	 movzx	 edx, ax
  00156	e8 00 00 00 00	 call	 store_hw_noswap

; 3587 :         store_hw( &trkhdr->head, (U16) head );

  0015b	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR head$[rsp]
  00160	e8 00 00 00 00	 call	 _byteswap_ushort
  00165	48 8b 4c 24 70	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  0016a	48 83 c1 03	 add	 rcx, 3
  0016e	0f b7 d0	 movzx	 edx, ax
  00171	e8 00 00 00 00	 call	 store_hw_noswap

; 3588 :         pos = buf + CKD_TRKHDR_SIZE;

  00176	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0017e	48 83 c0 05	 add	 rax, 5
  00182	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 3589 : 
; 3590 :         /* Build record zero (R0): KL=0, DL=8 */
; 3591 :         r = 0;

  00187	c6 44 24 40 00	 mov	 BYTE PTR r$[rsp], 0

; 3592 :         rechdr = (CKD_RECHDR*)pos;

  0018c	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  00191	48 89 44 24 50	 mov	 QWORD PTR rechdr$[rsp], rax

; 3593 :         pos += CKD_RECHDR_SIZE;

  00196	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  0019b	48 83 c0 08	 add	 rax, 8
  0019f	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 3594 :         store_hw( &rechdr->cyl,  (U16) cyl  );

  001a4	0f b7 4c 24 58	 movzx	 ecx, WORD PTR cyl$[rsp]
  001a9	e8 00 00 00 00	 call	 _byteswap_ushort
  001ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  001b3	0f b7 d0	 movzx	 edx, ax
  001b6	e8 00 00 00 00	 call	 store_hw_noswap

; 3595 :         store_hw( &rechdr->head, (U16) head );

  001bb	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR head$[rsp]
  001c0	e8 00 00 00 00	 call	 _byteswap_ushort
  001c5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  001ca	48 83 c1 02	 add	 rcx, 2
  001ce	0f b7 d0	 movzx	 edx, ax
  001d1	e8 00 00 00 00	 call	 store_hw_noswap

; 3596 :         rechdr->rec = r;

  001d6	48 8b 44 24 50	 mov	 rax, QWORD PTR rechdr$[rsp]
  001db	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR r$[rsp]
  001e0	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 3597 :         rechdr->klen = 0;

  001e3	48 8b 44 24 50	 mov	 rax, QWORD PTR rechdr$[rsp]
  001e8	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 3598 :         store_hw( &rechdr->dlen, CKD_R0_DLEN );

  001ec	66 b9 08 00	 mov	 cx, 8
  001f0	e8 00 00 00 00	 call	 _byteswap_ushort
  001f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  001fa	48 83 c1 06	 add	 rcx, 6
  001fe	0f b7 d0	 movzx	 edx, ax
  00201	e8 00 00 00 00	 call	 store_hw_noswap

; 3599 :         memset( pos, 0,          CKD_R0_DLEN );

  00206	48 8b 7c 24 48	 mov	 rdi, QWORD PTR pos$[rsp]
  0020b	33 c0		 xor	 eax, eax
  0020d	b9 08 00 00 00	 mov	 ecx, 8
  00212	f3 aa		 rep stosb

; 3600 :         pos +=                   CKD_R0_DLEN;

  00214	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  00219	48 83 c0 08	 add	 rax, 8
  0021d	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 3601 :         r++;

  00222	0f b6 44 24 40	 movzx	 eax, BYTE PTR r$[rsp]
  00227	fe c0		 inc	 al
  00229	88 44 24 40	 mov	 BYTE PTR r$[rsp], al

; 3602 : 
; 3603 :         /* Specific null track formatting */
; 3604 :         if (nullfmt == CKD_NULLTRK_FMT0)

  0022d	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR nullfmt$[rsp], 0
  00235	0f 85 88 00 00
	00		 jne	 $LN12@cckd_null_

; 3605 :         {
; 3606 :             rechdr = (CKD_RECHDR*)pos;

  0023b	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  00240	48 89 44 24 50	 mov	 QWORD PTR rechdr$[rsp], rax

; 3607 :             pos += CKD_RECHDR_SIZE;

  00245	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  0024a	48 83 c0 08	 add	 rax, 8
  0024e	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 3608 : 
; 3609 :             /* Build record one (R1): EOF record (KL=0, DL=0) */
; 3610 :             store_hw( &rechdr->cyl,  (U16) cyl  );

  00253	0f b7 4c 24 58	 movzx	 ecx, WORD PTR cyl$[rsp]
  00258	e8 00 00 00 00	 call	 _byteswap_ushort
  0025d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00262	0f b7 d0	 movzx	 edx, ax
  00265	e8 00 00 00 00	 call	 store_hw_noswap

; 3611 :             store_hw( &rechdr->head, (U16) head );

  0026a	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR head$[rsp]
  0026f	e8 00 00 00 00	 call	 _byteswap_ushort
  00274	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00279	48 83 c1 02	 add	 rcx, 2
  0027d	0f b7 d0	 movzx	 edx, ax
  00280	e8 00 00 00 00	 call	 store_hw_noswap

; 3612 :             rechdr->rec = r;

  00285	48 8b 44 24 50	 mov	 rax, QWORD PTR rechdr$[rsp]
  0028a	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR r$[rsp]
  0028f	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 3613 :             rechdr->klen = 0;

  00292	48 8b 44 24 50	 mov	 rax, QWORD PTR rechdr$[rsp]
  00297	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 3614 :             store_hw(&rechdr->dlen, 0);

  0029b	33 c9		 xor	 ecx, ecx
  0029d	e8 00 00 00 00	 call	 _byteswap_ushort
  002a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  002a7	48 83 c1 06	 add	 rcx, 6
  002ab	0f b7 d0	 movzx	 edx, ax
  002ae	e8 00 00 00 00	 call	 store_hw_noswap

; 3615 :             r++;

  002b3	0f b6 44 24 40	 movzx	 eax, BYTE PTR r$[rsp]
  002b8	fe c0		 inc	 al
  002ba	88 44 24 40	 mov	 BYTE PTR r$[rsp], al

; 3616 :         }

  002be	e9 d5 00 00 00	 jmp	 $LN13@cckd_null_
$LN12@cckd_null_:

; 3617 :         else if (nullfmt == CKD_NULLTRK_FMT2)

  002c3	83 bc 24 b8 00
	00 00 02	 cmp	 DWORD PTR nullfmt$[rsp], 2
  002cb	0f 85 c7 00 00
	00		 jne	 $LN14@cckd_null_

; 3618 :         {
; 3619 :             /* Build 12 binary-0 data blocks, 4K each (KL=0, DL=4K) */
; 3620 :             for (i = 0; i < 12; i++)

  002d1	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002d9	eb 0a		 jmp	 SHORT $LN4@cckd_null_
$LN2@cckd_null_:
  002db	8b 44 24 64	 mov	 eax, DWORD PTR i$[rsp]
  002df	ff c0		 inc	 eax
  002e1	89 44 24 64	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd_null_:
  002e5	83 7c 24 64 0c	 cmp	 DWORD PTR i$[rsp], 12
  002ea	0f 8d a8 00 00
	00		 jge	 $LN3@cckd_null_

; 3621 :             {
; 3622 :                 rechdr = (CKD_RECHDR*)pos;

  002f0	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  002f5	48 89 44 24 50	 mov	 QWORD PTR rechdr$[rsp], rax

; 3623 :                 pos += CKD_RECHDR_SIZE;

  002fa	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  002ff	48 83 c0 08	 add	 rax, 8
  00303	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 3624 : 
; 3625 :                 store_hw( &rechdr->cyl,  (U16) cyl);

  00308	0f b7 4c 24 58	 movzx	 ecx, WORD PTR cyl$[rsp]
  0030d	e8 00 00 00 00	 call	 _byteswap_ushort
  00312	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00317	0f b7 d0	 movzx	 edx, ax
  0031a	e8 00 00 00 00	 call	 store_hw_noswap

; 3626 :                 store_hw( &rechdr->head, (U16) head);

  0031f	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR head$[rsp]
  00324	e8 00 00 00 00	 call	 _byteswap_ushort
  00329	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0032e	48 83 c1 02	 add	 rcx, 2
  00332	0f b7 d0	 movzx	 edx, ax
  00335	e8 00 00 00 00	 call	 store_hw_noswap

; 3627 :                 rechdr->rec = r;

  0033a	48 8b 44 24 50	 mov	 rax, QWORD PTR rechdr$[rsp]
  0033f	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR r$[rsp]
  00344	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 3628 :                 rechdr->klen = 0;

  00347	48 8b 44 24 50	 mov	 rax, QWORD PTR rechdr$[rsp]
  0034c	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 3629 :                 store_hw( &rechdr->dlen, CKD_NULL_FMT2_DLEN );

  00350	66 b9 00 10	 mov	 cx, 4096		; 00001000H
  00354	e8 00 00 00 00	 call	 _byteswap_ushort
  00359	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0035e	48 83 c1 06	 add	 rcx, 6
  00362	0f b7 d0	 movzx	 edx, ax
  00365	e8 00 00 00 00	 call	 store_hw_noswap

; 3630 :                 r++;

  0036a	0f b6 44 24 40	 movzx	 eax, BYTE PTR r$[rsp]
  0036f	fe c0		 inc	 al
  00371	88 44 24 40	 mov	 BYTE PTR r$[rsp], al

; 3631 :                 memset( pos, 0,          CKD_NULL_FMT2_DLEN );

  00375	48 8b 7c 24 48	 mov	 rdi, QWORD PTR pos$[rsp]
  0037a	33 c0		 xor	 eax, eax
  0037c	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00381	f3 aa		 rep stosb

; 3632 :                 pos +=                   CKD_NULL_FMT2_DLEN;

  00383	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  00388	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0038e	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 3633 :             }

  00393	e9 43 ff ff ff	 jmp	 $LN2@cckd_null_
$LN3@cckd_null_:
$LN14@cckd_null_:
$LN13@cckd_null_:

; 3634 :         }
; 3635 : 
; 3636 :         /* Build the end of track marker */
; 3637 :         memcpy( pos, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  00398	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  0039d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR CKD_ENDTRK
  003a4	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3638 :         pos +=                    CKD_ENDTRK_SIZE;

  003a7	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  003ac	48 83 c0 08	 add	 rax, 8
  003b0	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 3639 :         len = (int)(pos - buf);

  003b5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  003bd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pos$[rsp]
  003c2	48 2b c8	 sub	 rcx, rax
  003c5	48 8b c1	 mov	 rax, rcx
  003c8	89 44 24 60	 mov	 DWORD PTR len$[rsp], eax

; 3640 :     }

  003cc	eb 47		 jmp	 SHORT $LN11@cckd_null_
$LN10@cckd_null_:

; 3641 :     else
; 3642 :     {
; 3643 :         len = CKD_TRKHDR_SIZE + CFBA_BLKGRP_SIZE;

  003ce	c7 44 24 60 05
	f0 00 00	 mov	 DWORD PTR len$[rsp], 61445 ; 0000f005H

; 3644 :         memset( buf, 0, len );

  003d6	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$[rsp]
  003db	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv226[rsp], rax
  003e3	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  003eb	33 c0		 xor	 eax, eax
  003ed	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv226[rsp]
  003f5	f3 aa		 rep stosb

; 3645 :         store_fw( buf+1, trk );

  003f7	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  003fe	e8 00 00 00 00	 call	 _byteswap_ulong
  00403	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0040b	48 ff c1	 inc	 rcx
  0040e	8b d0		 mov	 edx, eax
  00410	e8 00 00 00 00	 call	 store_fw_noswap
$LN11@cckd_null_:

; 3646 :     }
; 3647 : 
; 3648 :     CCKD_TRACE( "null_trk %s %d format %d size %d",

  00415	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0041a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0041d	83 e0 01	 and	 eax, 1
  00420	85 c0		 test	 eax, eax
  00422	74 0e		 je	 SHORT $LN16@cckd_null_
  00424	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171448
  0042b	48 89 44 24 78	 mov	 QWORD PTR tv240[rsp], rax
  00430	eb 0c		 jmp	 SHORT $LN17@cckd_null_
$LN16@cckd_null_:
  00432	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171449
  00439	48 89 44 24 78	 mov	 QWORD PTR tv240[rsp], rax
$LN17@cckd_null_:
  0043e	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00442	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00446	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR nullfmt$[rsp]
  0044d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00451	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00458	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0045c	48 8b 44 24 78	 mov	 rax, QWORD PTR tv240[rsp]
  00461	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00466	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171450
  0046d	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00475	ba 41 0e 00 00	 mov	 edx, 3649		; 00000e41H
  0047a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171451
  00481	e8 00 00 00 00	 call	 cckd_trace

; 3649 :                 cckd->ckddasd ? "trk" : "blkgrp", trk, nullfmt, len);
; 3650 : 
; 3651 :     return len;

  00486	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
$LN1@cckd_null_:

; 3652 : 
; 3653 : } /* end function cckd_null_trk */

  0048a	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00491	5f		 pop	 rdi
  00492	c3		 ret	 0
cckd_null_trk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
size$ = 112
tv145 = 116
tv151 = 120
tv91 = 124
tv130 = 128
tv133 = 132
trkhdr$1 = 136
cckd$ = 144
tv135 = 152
dev$ = 176
buf$ = 184
cckd_trklen PROC

; 3519 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 3520 :     CCKD_EXT*  cckd;                    /* -> cckd extension         */
; 3521 :     int        size;                    /* Track size                */
; 3522 : 
; 3523 :     if ((cckd = dev->cckd_ext)->fbadasd)

  00011	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00019	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00020	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax
  00028	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00030	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00033	d1 e8		 shr	 eax, 1
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 0a		 je	 SHORT $LN2@cckd_trkle

; 3524 :         return CKD_TRKHDR_SIZE + CFBA_BLKGRP_SIZE;

  0003c	b8 05 f0 00 00	 mov	 eax, 61445		; 0000f005H
  00041	e9 d2 01 00 00	 jmp	 $LN1@cckd_trkle
$LN2@cckd_trkle:

; 3525 : 
; 3526 :     size = ckd_tracklen( dev, buf );

  00046	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0004e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00056	e8 00 00 00 00	 call	 ckd_tracklen
  0005b	89 44 24 70	 mov	 DWORD PTR size$[rsp], eax

; 3527 : 
; 3528 :     /* check for missing end-of-track indicator */
; 3529 :     if (0
; 3530 :         || size > dev->ckdtrksz
; 3531 :         || memcmp( &buf[ size - CKD_ENDTRK_SIZE ], &CKD_ENDTRK, CKD_ENDTRK_SIZE ) != 0

  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 43		 jne	 SHORT $LN4@cckd_trkle
  00065	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006d	8b 80 c4 12 00
	00		 mov	 eax, DWORD PTR [rax+4804]
  00073	39 44 24 70	 cmp	 DWORD PTR size$[rsp], eax
  00077	7f 2f		 jg	 SHORT $LN4@cckd_trkle
  00079	48 63 44 24 70	 movsxd	 rax, DWORD PTR size$[rsp]
  0007e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00086	48 8d 44 01 f8	 lea	 rax, QWORD PTR [rcx+rax-8]
  0008b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  00098	48 8b c8	 mov	 rcx, rax
  0009b	e8 00 00 00 00	 call	 memcmp
  000a0	85 c0		 test	 eax, eax
  000a2	0f 84 6c 01 00
	00		 je	 $LN3@cckd_trkle
$LN4@cckd_trkle:

; 3532 :     )
; 3533 :     {
; 3534 :         CKD_TRKHDR*  trkhdr  = (CKD_TRKHDR*) buf;

  000a8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  000b0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR trkhdr$1[rsp], rax

; 3535 : 
; 3536 :         // "%1d:%04X CCKD file[%d] %s: trklen error for BCCHH = %2.2x%4.4x%4.4x"
; 3537 :         WRMSG( HHC00306, "E", LCSS_DEVNUM, cckd->sfn, cckd_sf_name( dev, cckd->sfn ),

  000b8	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000c1	74 12		 je	 SHORT $LN6@cckd_trkle
  000c3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000cb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000cf	89 44 24 74	 mov	 DWORD PTR tv145[rsp], eax
  000d3	eb 08		 jmp	 SHORT $LN7@cckd_trkle
$LN6@cckd_trkle:
  000d5	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN7@cckd_trkle:
  000dd	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000e6	74 14		 je	 SHORT $LN8@cckd_trkle
  000e8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000f4	d1 f8		 sar	 eax, 1
  000f6	89 44 24 78	 mov	 DWORD PTR tv151[rsp], eax
  000fa	eb 08		 jmp	 SHORT $LN9@cckd_trkle
$LN8@cckd_trkle:
  000fc	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN9@cckd_trkle:
  00104	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR trkhdr$1[rsp]
  0010c	48 83 c0 03	 add	 rax, 3
  00110	48 8b c8	 mov	 rcx, rax
  00113	e8 00 00 00 00	 call	 fetch_hw_noswap
  00118	0f b7 c8	 movzx	 ecx, ax
  0011b	e8 00 00 00 00	 call	 _byteswap_ushort
  00120	0f b7 c0	 movzx	 eax, ax
  00123	89 44 24 7c	 mov	 DWORD PTR tv91[rsp], eax
  00127	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR trkhdr$1[rsp]
  0012f	48 ff c1	 inc	 rcx
  00132	e8 00 00 00 00	 call	 fetch_hw_noswap
  00137	0f b7 c8	 movzx	 ecx, ax
  0013a	e8 00 00 00 00	 call	 _byteswap_ushort
  0013f	0f b7 c0	 movzx	 eax, ax
  00142	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv130[rsp], eax
  00149	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR trkhdr$1[rsp]
  00151	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00154	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv133[rsp], ecx
  0015b	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR cckd$[rsp]
  00163	8b 52 3c	 mov	 edx, DWORD PTR [rdx+60]
  00166	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0016e	e8 00 00 00 00	 call	 cckd_sf_name
  00173	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
  0017b	b9 01 00 00 00	 mov	 ecx, 1
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00186	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv91[rsp]
  0018a	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0018e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv130[rsp]
  00195	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00199	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv133[rsp]
  001a0	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  001a4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv135[rsp]
  001ac	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001b1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  001b9	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  001bc	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001c0	8b 4c 24 74	 mov	 ecx, DWORD PTR tv145[rsp]
  001c4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001c8	8b 4c 24 78	 mov	 ecx, DWORD PTR tv151[rsp]
  001cc	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171388
  001d7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171389
  001e3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ed	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171390
  001fa	ba d2 0d 00 00	 mov	 edx, 3538		; 00000dd2H
  001ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171391
  00206	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3538 :                trkhdr->bin, fetch_hw( trkhdr->cyl ), fetch_hw( trkhdr->head ));
; 3539 : 
; 3540 :         size = -1;

  0020c	c7 44 24 70 ff
	ff ff ff	 mov	 DWORD PTR size$[rsp], -1
$LN3@cckd_trkle:

; 3541 :     }
; 3542 : 
; 3543 :     return size;

  00214	8b 44 24 70	 mov	 eax, DWORD PTR size$[rsp]
$LN1@cckd_trkle:

; 3544 : }

  00218	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0021f	c3		 ret	 0
cckd_trklen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
rc$ = 48
cckd$ = 56
dev$ = 80
cckd_harden PROC

; 3477 : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3478 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3479 : int             rc=0;                   /* Return code               */

  00009	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 3480 : 
; 3481 :     if (dev->cckd64)

  00011	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00016	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0001d	24 01		 and	 al, 1
  0001f	0f b6 c0	 movzx	 eax, al
  00022	85 c0		 test	 eax, eax
  00024	74 0f		 je	 SHORT $LN2@cckd_harde

; 3482 :         return cckd64_harden( dev );

  00026	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0002b	e8 00 00 00 00	 call	 cckd64_harden
  00030	e9 39 01 00 00	 jmp	 $LN1@cckd_harde
$LN2@cckd_harde:

; 3483 : 
; 3484 :     cckd = dev->cckd_ext;

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0003a	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00041	48 89 44 24 38	 mov	 QWORD PTR cckd$[rsp], rax

; 3485 : 
; 3486 :     if ((dev->ckdrdonly && cckd->sfn == 0)
; 3487 :      || cckd->open[cckd->sfn] != CCKD_OPEN_RW)

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0004b	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00051	c1 e8 12	 shr	 eax, 18
  00054	83 e0 01	 and	 eax, 1
  00057	85 c0		 test	 eax, eax
  00059	74 0b		 je	 SHORT $LN5@cckd_harde
  0005b	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00060	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00064	74 1b		 je	 SHORT $LN4@cckd_harde
$LN5@cckd_harde:
  00066	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0006b	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0006f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00074	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  0007c	83 f8 03	 cmp	 eax, 3
  0007f	74 07		 je	 SHORT $LN3@cckd_harde
$LN4@cckd_harde:

; 3488 :         return 0;

  00081	33 c0		 xor	 eax, eax
  00083	e9 e6 00 00 00	 jmp	 $LN1@cckd_harde
$LN3@cckd_harde:

; 3489 : 
; 3490 :     CCKD_TRACE( "file[%d] harden", cckd->sfn);

  00088	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0008d	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00090	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00094	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171365
  0009b	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  000a0	ba a2 0d 00 00	 mov	 edx, 3490		; 00000da2H
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171366
  000ac	e8 00 00 00 00	 call	 cckd_trace

; 3491 : 
; 3492 :     /* Write the compressed device header */
; 3493 :     if (cckd_write_chdr (dev) < 0)

  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000b6	e8 00 00 00 00	 call	 cckd_write_chdr
  000bb	85 c0		 test	 eax, eax
  000bd	7d 08		 jge	 SHORT $LN6@cckd_harde

; 3494 :         rc = -1;

  000bf	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN6@cckd_harde:

; 3495 : 
; 3496 :     /* Write the level 1 table */
; 3497 :     if (cckd_write_l1 (dev) < 0)

  000c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000cc	e8 00 00 00 00	 call	 cckd_write_l1
  000d1	85 c0		 test	 eax, eax
  000d3	7d 08		 jge	 SHORT $LN7@cckd_harde

; 3498 :         rc = -1;

  000d5	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN7@cckd_harde:

; 3499 : 
; 3500 :     /* Write the free space chain */
; 3501 :     if (cckd_write_fsp (dev) < 0)

  000dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000e2	e8 00 00 00 00	 call	 cckd_write_fsp
  000e7	85 c0		 test	 eax, eax
  000e9	7d 08		 jge	 SHORT $LN8@cckd_harde

; 3502 :         rc = -1;

  000eb	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN8@cckd_harde:

; 3503 : 
; 3504 :     /* Re-write the compressed device header */
; 3505 :     cckd->cdevhdr[cckd->sfn].cdh_opts &= ~CCKD_OPT_OPENED;

  000f3	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  000f8	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  000fc	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00103	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00108	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  00110	0f ba f0 07	 btr	 eax, 7
  00114	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00119	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  0011d	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00124	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  00129	88 84 0a e3 01
	00 00		 mov	 BYTE PTR [rdx+rcx+483], al

; 3506 :     if (cckd_write_chdr (dev) < 0)

  00130	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00135	e8 00 00 00 00	 call	 cckd_write_chdr
  0013a	85 c0		 test	 eax, eax
  0013c	7d 08		 jge	 SHORT $LN9@cckd_harde

; 3507 :         rc = -1;

  0013e	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN9@cckd_harde:

; 3508 : 
; 3509 :     if (cckdblk.fsync)

  00146	83 3d 5c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+604, 0
  0014d	74 1b		 je	 SHORT $LN10@cckd_harde

; 3510 :         fdatasync (cckd->fd[cckd->sfn]);

  0014f	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00154	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00158	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0015d	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__commit
$LN10@cckd_harde:

; 3511 : 
; 3512 :     return rc;

  0016a	8b 44 24 30	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cckd_harde:

; 3513 : } /* cckd_harden */

  0016e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00172	c3		 ret	 0
cckd_harden ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
sfx$ = 112
oldl2$ = 120
cckd$ = 128
l2$ = 136
l2x$ = 144
size$ = 148
rc$ = 152
after$ = 156
L1idx$ = 160
off$ = 168
dev$ = 192
buf$ = 200
len$ = 208
trk$ = 216
flags$ = 224
cckd_write_trkimg PROC

; 3389 : {

$LN12:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 3390 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3391 : int             rc;                     /* Return code               */
; 3392 : off_t           off;                    /* File offset               */
; 3393 : CCKD_L2ENT      l2, oldl2;              /* Level 2 entries           */
; 3394 : int             sfx,L1idx,l2x;          /* Lookup table indices      */
; 3395 : int             after = 0;              /* 1=New track after old     */

  0001b	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR after$[rsp], 0

; 3396 : int             size;                   /* Size of new track         */
; 3397 : 
; 3398 :     if (dev->cckd64)

  00026	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00035	24 01		 and	 al, 1
  00037	0f b6 c0	 movzx	 eax, al
  0003a	85 c0		 test	 eax, eax
  0003c	74 35		 je	 SHORT $LN2@cckd_write

; 3399 :         return cckd64_write_trkimg( dev, buf, len, trk, flags );

  0003e	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00045	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00049	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR trk$[rsp]
  00051	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00059	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00061	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00069	e8 00 00 00 00	 call	 cckd64_write_trkimg
  0006e	e9 25 04 00 00	 jmp	 $LN1@cckd_write
$LN2@cckd_write:

; 3400 : 
; 3401 :     cckd = dev->cckd_ext;

  00073	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007b	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00082	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 3402 : 
; 3403 :     sfx = cckd->sfn;

  0008a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00092	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00095	89 44 24 70	 mov	 DWORD PTR sfx$[rsp], eax

; 3404 :     L1idx = trk >> 8;

  00099	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  000a0	c1 f8 08	 sar	 eax, 8
  000a3	89 84 24 a0 00
	00 00		 mov	 DWORD PTR L1idx$[rsp], eax

; 3405 :     l2x = trk & 0xff;

  000aa	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  000b1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b6	89 84 24 90 00
	00 00		 mov	 DWORD PTR l2x$[rsp], eax

; 3406 : 
; 3407 :     CCKD_TRACE( "file[%d] trk[%d] write_trkimg len %d buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x",

  000bd	b8 01 00 00 00	 mov	 eax, 1
  000c2	48 6b c0 04	 imul	 rax, rax, 4
  000c6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  000ce	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d2	b9 01 00 00 00	 mov	 ecx, 1
  000d7	48 6b c9 03	 imul	 rcx, rcx, 3
  000db	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000e3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000e7	ba 01 00 00 00	 mov	 edx, 1
  000ec	48 6b d2 02	 imul	 rdx, rdx, 2
  000f0	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  000f8	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  000fd	41 b8 01 00 00
	00		 mov	 r8d, 1
  00103	4d 6b c0 01	 imul	 r8, r8, 1
  00107	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  0010f	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00114	41 b9 01 00 00
	00		 mov	 r9d, 1
  0011a	4d 6b c9 00	 imul	 r9, r9, 0
  0011e	4c 8b 94 24 c8
	00 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  00126	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  0012b	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  0012f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00133	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  00137	44 89 44 24 48	 mov	 DWORD PTR [rsp+72], r8d
  0013c	44 89 4c 24 40	 mov	 DWORD PTR [rsp+64], r9d
  00141	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00149	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0014e	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00155	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00159	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00160	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00164	8b 44 24 70	 mov	 eax, DWORD PTR sfx$[rsp]
  00168	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0016c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171344
  00173	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0017b	ba 50 0d 00 00	 mov	 edx, 3408		; 00000d50H
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171345
  00187	e8 00 00 00 00	 call	 cckd_trace

; 3408 :                 sfx, trk, len, buf, buf[0], buf[1], buf[2], buf[3], buf[4]);
; 3409 : 
; 3410 :     /* Validate the new track image */
; 3411 :     if (cckd_cchh (dev, buf, trk) < 0)

  0018c	44 8b 84 24 d8
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00194	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0019c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a4	e8 00 00 00 00	 call	 cckd_cchh
  001a9	85 c0		 test	 eax, eax
  001ab	7d 0a		 jge	 SHORT $LN3@cckd_write

; 3412 :         return -1;

  001ad	b8 ff ff ff ff	 mov	 eax, -1
  001b2	e9 e1 02 00 00	 jmp	 $LN1@cckd_write
$LN3@cckd_write:

; 3413 : 
; 3414 :     /* Get the level 2 table for the track in the active file */
; 3415 :     if (cckd_read_l2 (dev, sfx, L1idx) < 0)

  001b7	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR L1idx$[rsp]
  001bf	8b 54 24 70	 mov	 edx, DWORD PTR sfx$[rsp]
  001c3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001cb	e8 00 00 00 00	 call	 cckd_read_l2
  001d0	85 c0		 test	 eax, eax
  001d2	7d 0a		 jge	 SHORT $LN4@cckd_write

; 3416 :         return -1;

  001d4	b8 ff ff ff ff	 mov	 eax, -1
  001d9	e9 ba 02 00 00	 jmp	 $LN1@cckd_write
$LN4@cckd_write:

; 3417 : 
; 3418 :     /* Save the level 2 entry for the track */
; 3419 :     oldl2.L2_trkoff = cckd->L2tab[l2x].L2_trkoff;

  001de	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR l2x$[rsp]
  001e6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ee	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  001f2	8b 04 c1	 mov	 eax, DWORD PTR [rcx+rax*8]
  001f5	89 44 24 78	 mov	 DWORD PTR oldl2$[rsp], eax

; 3420 :     oldl2.L2_len    = cckd->L2tab[l2x].L2_len;

  001f9	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR l2x$[rsp]
  00201	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00209	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0020d	0f b7 44 c1 04	 movzx	 eax, WORD PTR [rcx+rax*8+4]
  00212	66 89 44 24 7c	 mov	 WORD PTR oldl2$[rsp+4], ax

; 3421 :     oldl2.L2_size   = cckd->L2tab[l2x].L2_size;

  00217	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR l2x$[rsp]
  0021f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00227	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0022b	0f b7 44 c1 06	 movzx	 eax, WORD PTR [rcx+rax*8+6]
  00230	66 89 44 24 7e	 mov	 WORD PTR oldl2$[rsp+6], ax

; 3422 :     CCKD_TRACE( "file[%d] trk[%d] write_trkimg oldl2 0x%x %d %d",

  00235	0f b7 44 24 7e	 movzx	 eax, WORD PTR oldl2$[rsp+6]
  0023a	0f b7 4c 24 7c	 movzx	 ecx, WORD PTR oldl2$[rsp+4]
  0023f	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00243	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00247	8b 44 24 78	 mov	 eax, DWORD PTR oldl2$[rsp]
  0024b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0024f	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00256	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0025a	8b 44 24 70	 mov	 eax, DWORD PTR sfx$[rsp]
  0025e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00262	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171348
  00269	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00271	ba 5f 0d 00 00	 mov	 edx, 3423		; 00000d5fH
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171349
  0027d	e8 00 00 00 00	 call	 cckd_trace

; 3423 :                 sfx, trk, oldl2.L2_trkoff, oldl2.L2_len, oldl2.L2_size);
; 3424 : 
; 3425 :     /* Check if writing a null track */
; 3426 :     len = cckd_check_null_trk(dev, buf, trk, len);

  00282	44 8b 8c 24 d0
	00 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  0028a	44 8b 84 24 d8
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00292	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0029a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002a2	e8 00 00 00 00	 call	 cckd_check_null_trk
  002a7	89 84 24 d0 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 3427 : 
; 3428 :     if (len > CKD_NULLTRK_FMTMAX)

  002ae	83 bc 24 d0 00
	00 00 02	 cmp	 DWORD PTR len$[rsp], 2
  002b6	0f 8e 61 01 00
	00		 jle	 $LN5@cckd_write

; 3429 :     {
; 3430 :         /* Get space for the track image */
; 3431 :         size = len;

  002bc	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  002c3	89 84 24 94 00
	00 00		 mov	 DWORD PTR size$[rsp], eax

; 3432 :         if ((off = cckd_get_space (dev, &size, flags)) < 0)

  002ca	44 8b 84 24 e0
	00 00 00	 mov	 r8d, DWORD PTR flags$[rsp]
  002d2	48 8d 94 24 94
	00 00 00	 lea	 rdx, QWORD PTR size$[rsp]
  002da	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e2	e8 00 00 00 00	 call	 cckd_get_space
  002e7	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR off$[rsp], rax
  002ef	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR off$[rsp], 0
  002f8	7d 0a		 jge	 SHORT $LN7@cckd_write

; 3433 :             return -1;

  002fa	b8 ff ff ff ff	 mov	 eax, -1
  002ff	e9 94 01 00 00	 jmp	 $LN1@cckd_write
$LN7@cckd_write:

; 3434 : 
; 3435 :         l2.L2_trkoff = (U32)off;

  00304	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR off$[rsp]
  0030b	89 84 24 88 00
	00 00		 mov	 DWORD PTR l2$[rsp], eax

; 3436 :         l2.L2_len    = (U16)len;

  00312	0f b7 84 24 d0
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  0031a	66 89 84 24 8c
	00 00 00	 mov	 WORD PTR l2$[rsp+4], ax

; 3437 :         l2.L2_size   = (U16)size;

  00322	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR size$[rsp]
  0032a	66 89 84 24 8e
	00 00 00	 mov	 WORD PTR l2$[rsp+6], ax

; 3438 : 
; 3439 :         if (1
; 3440 :             && oldl2.L2_trkoff != CCKD_NOSIZE
; 3441 :             && oldl2.L2_trkoff != CCKD_MAXSIZE
; 3442 :             && oldl2.L2_trkoff < l2.L2_trkoff

  00332	33 c0		 xor	 eax, eax
  00334	83 f8 01	 cmp	 eax, 1
  00337	74 26		 je	 SHORT $LN8@cckd_write
  00339	83 7c 24 78 00	 cmp	 DWORD PTR oldl2$[rsp], 0
  0033e	74 1f		 je	 SHORT $LN8@cckd_write
  00340	83 7c 24 78 ff	 cmp	 DWORD PTR oldl2$[rsp], -1 ; ffffffffH
  00345	74 18		 je	 SHORT $LN8@cckd_write
  00347	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR l2$[rsp]
  0034e	39 44 24 78	 cmp	 DWORD PTR oldl2$[rsp], eax
  00352	73 0b		 jae	 SHORT $LN8@cckd_write

; 3443 :         )
; 3444 :             after = 1;

  00354	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR after$[rsp], 1
$LN8@cckd_write:

; 3445 : 
; 3446 :         /* Write the track image */
; 3447 :         if ((rc = cckd_write (dev, sfx, off, buf, len)) < 0)

  0035f	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00366	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0036a	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  00372	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR off$[rsp]
  0037a	8b 54 24 70	 mov	 edx, DWORD PTR sfx$[rsp]
  0037e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00386	e8 00 00 00 00	 call	 cckd_write
  0038b	89 84 24 98 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  00392	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0039a	7d 0a		 jge	 SHORT $LN9@cckd_write

; 3448 :             return -1;

  0039c	b8 ff ff ff ff	 mov	 eax, -1
  003a1	e9 f2 00 00 00	 jmp	 $LN1@cckd_write
$LN9@cckd_write:

; 3449 : 
; 3450 :         cckd->writes[sfx]++;

  003a6	48 63 44 24 70	 movsxd	 rax, DWORD PTR sfx$[rsp]
  003ab	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  003b3	8b 84 81 70 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+368]
  003ba	ff c0		 inc	 eax
  003bc	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  003c1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR cckd$[rsp]
  003c9	89 84 8a 70 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+368], eax

; 3451 :         cckd->totwrites++;

  003d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  003d8	8b 80 d8 00 00
	00		 mov	 eax, DWORD PTR [rax+216]
  003de	ff c0		 inc	 eax
  003e0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  003e8	89 81 d8 00 00
	00		 mov	 DWORD PTR [rcx+216], eax

; 3452 :         cckdblk.stats_writes++;

  003ee	48 8b 05 d0 02
	00 00		 mov	 rax, QWORD PTR cckdblk+720
  003f5	48 ff c0	 inc	 rax
  003f8	48 89 05 d0 02
	00 00		 mov	 QWORD PTR cckdblk+720, rax

; 3453 :         cckdblk.stats_writebytes += rc;

  003ff	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR rc$[rsp]
  00407	48 8b 0d d8 02
	00 00		 mov	 rcx, QWORD PTR cckdblk+728
  0040e	48 03 c8	 add	 rcx, rax
  00411	48 8b c1	 mov	 rax, rcx
  00414	48 89 05 d8 02
	00 00		 mov	 QWORD PTR cckdblk+728, rax

; 3454 :     }

  0041b	eb 2b		 jmp	 SHORT $LN6@cckd_write
$LN5@cckd_write:

; 3455 :     else
; 3456 :     {
; 3457 :         l2.L2_trkoff = 0;

  0041d	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR l2$[rsp], 0

; 3458 :         l2.L2_len = l2.L2_size = (U16)len;

  00428	0f b7 84 24 d0
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  00430	66 89 84 24 8e
	00 00 00	 mov	 WORD PTR l2$[rsp+6], ax
  00438	0f b7 84 24 8e
	00 00 00	 movzx	 eax, WORD PTR l2$[rsp+6]
  00440	66 89 84 24 8c
	00 00 00	 mov	 WORD PTR l2$[rsp+4], ax
$LN6@cckd_write:

; 3459 :     }
; 3460 : 
; 3461 :     /* Update the level 2 entry */
; 3462 :     if (cckd_write_l2ent (dev, &l2, trk) < 0)

  00448	44 8b 84 24 d8
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00450	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR l2$[rsp]
  00458	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00460	e8 00 00 00 00	 call	 cckd_write_l2ent
  00465	85 c0		 test	 eax, eax
  00467	7d 07		 jge	 SHORT $LN10@cckd_write

; 3463 :         return -1;

  00469	b8 ff ff ff ff	 mov	 eax, -1
  0046e	eb 28		 jmp	 SHORT $LN1@cckd_write
$LN10@cckd_write:

; 3464 : 
; 3465 :     /* Release the previous space */
; 3466 :     cckd_rel_space (dev, (off_t)oldl2.L2_trkoff, (int)oldl2.L2_len, (int)oldl2.L2_size);

  00470	0f b7 44 24 7e	 movzx	 eax, WORD PTR oldl2$[rsp+6]
  00475	0f b7 4c 24 7c	 movzx	 ecx, WORD PTR oldl2$[rsp+4]
  0047a	8b 54 24 78	 mov	 edx, DWORD PTR oldl2$[rsp]
  0047e	44 8b c8	 mov	 r9d, eax
  00481	44 8b c1	 mov	 r8d, ecx
  00484	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0048c	e8 00 00 00 00	 call	 cckd_rel_space

; 3467 : 
; 3468 :     /* `after' is 1 if the new offset is after the old offset */
; 3469 :     return after;

  00491	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR after$[rsp]
$LN1@cckd_write:

; 3470 : 
; 3471 : } /* end function cckd_write_trkimg */

  00498	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0049f	c3		 ret	 0
cckd_write_trkimg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
sfx$ = 48
rc$ = 52
cckd$ = 56
l2$ = 64
dev$ = 96
buf$ = 104
trk$ = 112
unitstat$ = 120
cckd_read_trkimg PROC

; 3337 : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3338 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3339 : int             rc;                     /* Return code               */
; 3340 : int             sfx;                    /* File index                */
; 3341 : CCKD_L2ENT      l2;                     /* Level 2 entry             */
; 3342 : 
; 3343 :     cckd = dev->cckd_ext;

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00024	48 89 44 24 38	 mov	 QWORD PTR cckd$[rsp], rax

; 3344 : 
; 3345 :     CCKD_TRACE( "trk[%d] read_trkimg", trk);

  00029	8b 44 24 70	 mov	 eax, DWORD PTR trk$[rsp]
  0002d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00031	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171303
  00038	4c 8b 44 24 60	 mov	 r8, QWORD PTR dev$[rsp]
  0003d	ba 11 0d 00 00	 mov	 edx, 3345		; 00000d11H
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171304
  00049	e8 00 00 00 00	 call	 cckd_trace

; 3346 : 
; 3347 :     /* Read level 2 entry for the track */
; 3348 :     if ((sfx = cckd_read_l2ent (dev, &l2, trk)) < 0)

  0004e	44 8b 44 24 70	 mov	 r8d, DWORD PTR trk$[rsp]
  00053	48 8d 54 24 40	 lea	 rdx, QWORD PTR l2$[rsp]
  00058	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0005d	e8 00 00 00 00	 call	 cckd_read_l2ent
  00062	89 44 24 30	 mov	 DWORD PTR sfx$[rsp], eax
  00066	83 7c 24 30 00	 cmp	 DWORD PTR sfx$[rsp], 0
  0006b	7d 05		 jge	 SHORT $LN2@cckd_read_

; 3349 :         goto cckd_read_trkimg_error;

  0006d	e9 13 01 00 00	 jmp	 $cckd_read_trkimg_error$11
$LN2@cckd_read_:

; 3350 : 
; 3351 :     /* Read the track image or build a null track image */
; 3352 :     if (l2.L2_trkoff != 0)

  00072	83 7c 24 40 00	 cmp	 DWORD PTR l2$[rsp], 0
  00077	0f 84 c8 00 00
	00		 je	 $LN3@cckd_read_

; 3353 :     {
; 3354 :         rc = cckd_read (dev, sfx, (off_t)l2.L2_trkoff, buf, (size_t)l2.L2_len);

  0007d	0f b7 44 24 44	 movzx	 eax, WORD PTR l2$[rsp+4]
  00082	8b 4c 24 40	 mov	 ecx, DWORD PTR l2$[rsp]
  00086	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0008a	4c 8b 4c 24 68	 mov	 r9, QWORD PTR buf$[rsp]
  0008f	44 8b c1	 mov	 r8d, ecx
  00092	8b 54 24 30	 mov	 edx, DWORD PTR sfx$[rsp]
  00096	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0009b	e8 00 00 00 00	 call	 cckd_read
  000a0	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 3355 :         if (rc < 0)

  000a4	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000a9	7d 05		 jge	 SHORT $LN5@cckd_read_

; 3356 :             goto cckd_read_trkimg_error;

  000ab	e9 d5 00 00 00	 jmp	 $cckd_read_trkimg_error$11
$LN5@cckd_read_:

; 3357 : 
; 3358 :         cckd->reads[sfx]++;

  000b0	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000b5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000ba	8b 84 81 28 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+296]
  000c1	ff c0		 inc	 eax
  000c3	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  000c8	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  000cd	89 84 8a 28 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+296], eax

; 3359 :         cckd->totreads++;

  000d4	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  000d9	8b 80 d4 00 00
	00		 mov	 eax, DWORD PTR [rax+212]
  000df	ff c0		 inc	 eax
  000e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000e6	89 81 d4 00 00
	00		 mov	 DWORD PTR [rcx+212], eax

; 3360 :         cckdblk.stats_reads++;

  000ec	48 8b 05 c0 02
	00 00		 mov	 rax, QWORD PTR cckdblk+704
  000f3	48 ff c0	 inc	 rax
  000f6	48 89 05 c0 02
	00 00		 mov	 QWORD PTR cckdblk+704, rax

; 3361 :         cckdblk.stats_readbytes += rc;

  000fd	48 63 44 24 34	 movsxd	 rax, DWORD PTR rc$[rsp]
  00102	48 8b 0d c8 02
	00 00		 mov	 rcx, QWORD PTR cckdblk+712
  00109	48 03 c8	 add	 rcx, rax
  0010c	48 8b c1	 mov	 rax, rcx
  0010f	48 89 05 c8 02
	00 00		 mov	 QWORD PTR cckdblk+712, rax

; 3362 :         if (cckd->notnull == 0 && trk > 1) cckd->notnull = 1;

  00116	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0011b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0011e	c1 e8 07	 shr	 eax, 7
  00121	83 e0 01	 and	 eax, 1
  00124	85 c0		 test	 eax, eax
  00126	75 1b		 jne	 SHORT $LN6@cckd_read_
  00128	83 7c 24 70 01	 cmp	 DWORD PTR trk$[rsp], 1
  0012d	7e 14		 jle	 SHORT $LN6@cckd_read_
  0012f	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00134	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00137	0f ba e8 07	 bts	 eax, 7
  0013b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00140	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN6@cckd_read_:

; 3363 :     }

  00143	eb 20		 jmp	 SHORT $LN4@cckd_read_
$LN3@cckd_read_:

; 3364 :     else
; 3365 :         rc = cckd_null_trk (dev, buf, trk, l2.L2_len);

  00145	0f b7 44 24 44	 movzx	 eax, WORD PTR l2$[rsp+4]
  0014a	44 8b c8	 mov	 r9d, eax
  0014d	44 8b 44 24 70	 mov	 r8d, DWORD PTR trk$[rsp]
  00152	48 8b 54 24 68	 mov	 rdx, QWORD PTR buf$[rsp]
  00157	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0015c	e8 00 00 00 00	 call	 cckd_null_trk
  00161	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
$LN4@cckd_read_:

; 3366 : 
; 3367 :     /* Validate the track image */
; 3368 :     if (cckd_cchh (dev, buf, trk) < 0)

  00165	44 8b 44 24 70	 mov	 r8d, DWORD PTR trk$[rsp]
  0016a	48 8b 54 24 68	 mov	 rdx, QWORD PTR buf$[rsp]
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00174	e8 00 00 00 00	 call	 cckd_cchh
  00179	85 c0		 test	 eax, eax
  0017b	7d 02		 jge	 SHORT $LN7@cckd_read_

; 3369 :         goto cckd_read_trkimg_error;

  0017d	eb 06		 jmp	 SHORT $cckd_read_trkimg_error$11
$LN7@cckd_read_:

; 3370 : 
; 3371 :     return rc;

  0017f	8b 44 24 34	 mov	 eax, DWORD PTR rc$[rsp]
  00183	eb 43		 jmp	 SHORT $LN1@cckd_read_
$cckd_read_trkimg_error$11:

; 3372 : 
; 3373 : cckd_read_trkimg_error:
; 3374 : 
; 3375 :     if (unitstat)

  00185	48 83 7c 24 78
	00		 cmp	 QWORD PTR unitstat$[rsp], 0
  0018b	74 24		 je	 SHORT $LN8@cckd_read_

; 3376 :     {
; 3377 :         ckd_build_sense (dev, SENSE_EC, 0, 0, FORMAT_1, MESSAGE_0);

  0018d	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00192	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00197	45 33 c9	 xor	 r9d, r9d
  0019a	45 33 c0	 xor	 r8d, r8d
  0019d	b2 10		 mov	 dl, 16
  0019f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001a4	e8 00 00 00 00	 call	 ckd_build_sense

; 3378 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  001a9	48 8b 44 24 78	 mov	 rax, QWORD PTR unitstat$[rsp]
  001ae	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN8@cckd_read_:

; 3379 :     }
; 3380 : 
; 3381 :     return cckd_null_trk (dev, buf, trk, 0);

  001b1	45 33 c9	 xor	 r9d, r9d
  001b4	44 8b 44 24 70	 mov	 r8d, DWORD PTR trk$[rsp]
  001b9	48 8b 54 24 68	 mov	 rdx, QWORD PTR buf$[rsp]
  001be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001c3	e8 00 00 00 00	 call	 cckd_null_trk
$LN1@cckd_read_:

; 3382 : 
; 3383 : } /* end function cckd_read_trkimg */

  001c8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001cc	c3		 ret	 0
cckd_read_trkimg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
l2x$ = 96
sfx$ = 100
L1idx$ = 104
cckd$ = 112
off$ = 120
dev$ = 144
l2$ = 152
trk$ = 160
cckd_write_l2ent PROC

; 3297 : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 3298 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3299 : int             sfx,L1idx,l2x;          /* Lookup table indices      */
; 3300 : off_t           off;                    /* L2 entry offset           */
; 3301 : 
; 3302 :     if (dev->cckd64)

  00016	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00025	24 01		 and	 al, 1
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	74 22		 je	 SHORT $LN2@cckd_write

; 3303 :         return cckd64_write_l2ent( dev, (CCKD64_L2ENT*) l2, trk );

  0002e	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00036	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR l2$[rsp]
  0003e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00046	e8 00 00 00 00	 call	 cckd64_write_l2ent
  0004b	e9 b4 01 00 00	 jmp	 $LN1@cckd_write
$LN2@cckd_write:

; 3304 : 
; 3305 :     cckd = dev->cckd_ext;

  00050	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00058	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0005f	48 89 44 24 70	 mov	 QWORD PTR cckd$[rsp], rax

; 3306 : 
; 3307 :     /* Error return if no available level 2 table */
; 3308 :     if (!cckd->L2tab) return -1;

  00064	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00069	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  0006e	75 0a		 jne	 SHORT $LN3@cckd_write
  00070	b8 ff ff ff ff	 mov	 eax, -1
  00075	e9 8a 01 00 00	 jmp	 $LN1@cckd_write
$LN3@cckd_write:

; 3309 : 
; 3310 :     sfx = cckd->sfn;

  0007a	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0007f	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00082	89 44 24 64	 mov	 DWORD PTR sfx$[rsp], eax

; 3311 :     L1idx = trk >> 8;

  00086	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0008d	c1 f8 08	 sar	 eax, 8
  00090	89 44 24 68	 mov	 DWORD PTR L1idx$[rsp], eax

; 3312 :     l2x = trk & 0xff;

  00094	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0009b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a0	89 44 24 60	 mov	 DWORD PTR l2x$[rsp], eax

; 3313 : 
; 3314 :     /* Copy the new entry if passed */
; 3315 :     if (l2) memcpy (&cckd->L2tab[l2x], l2, CCKD_L2ENT_SIZE);

  000a4	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR l2$[rsp], 0
  000ad	74 1d		 je	 SHORT $LN4@cckd_write
  000af	48 63 44 24 60	 movsxd	 rax, DWORD PTR l2x$[rsp]
  000b4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  000b9	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  000bd	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR l2$[rsp]
  000c5	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000c8	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
$LN4@cckd_write:

; 3316 : 
; 3317 :     CCKD_TRACE( "file[%d] l2[%d,%d] trk[%d] write_l2ent 0x%x %d %d",

  000cc	48 63 44 24 60	 movsxd	 rax, DWORD PTR l2x$[rsp]
  000d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  000d6	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  000da	0f b7 44 c1 06	 movzx	 eax, WORD PTR [rcx+rax*8+6]
  000df	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR l2x$[rsp]
  000e4	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  000e9	48 8b 52 48	 mov	 rdx, QWORD PTR [rdx+72]
  000ed	0f b7 4c ca 04	 movzx	 ecx, WORD PTR [rdx+rcx*8+4]
  000f2	48 63 54 24 60	 movsxd	 rdx, DWORD PTR l2x$[rsp]
  000f7	4c 8b 44 24 70	 mov	 r8, QWORD PTR cckd$[rsp]
  000fc	4d 8b 40 48	 mov	 r8, QWORD PTR [r8+72]
  00100	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00104	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00108	41 8b 04 d0	 mov	 eax, DWORD PTR [r8+rdx*8]
  0010c	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00110	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00117	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0011b	8b 44 24 60	 mov	 eax, DWORD PTR l2x$[rsp]
  0011f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00123	8b 44 24 68	 mov	 eax, DWORD PTR L1idx$[rsp]
  00127	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0012b	8b 44 24 64	 mov	 eax, DWORD PTR sfx$[rsp]
  0012f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00133	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171282
  0013a	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00142	ba f7 0c 00 00	 mov	 edx, 3319		; 00000cf7H
  00147	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171283
  0014e	e8 00 00 00 00	 call	 cckd_trace

; 3318 :                 sfx, L1idx, l2x, trk,
; 3319 :                 cckd->L2tab[l2x].L2_trkoff, cckd->L2tab[l2x].L2_len, cckd->L2tab[l2x].L2_size);
; 3320 : 
; 3321 :     /* If no level 2 table for this file, then write a new one */
; 3322 :     if (cckd->L1tab[sfx][L1idx] == CCKD_NOSIZE || cckd->L1tab[sfx][L1idx] == CCKD_MAXSIZE)

  00153	48 63 44 24 64	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00158	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  0015d	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  00162	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  0016a	83 3c 88 00	 cmp	 DWORD PTR [rax+rcx*4], 0
  0016e	74 1d		 je	 SHORT $LN6@cckd_write
  00170	48 63 44 24 64	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00175	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  0017a	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  0017f	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00187	83 3c 88 ff	 cmp	 DWORD PTR [rax+rcx*4], -1 ; ffffffffH
  0018b	75 0f		 jne	 SHORT $LN5@cckd_write
$LN6@cckd_write:

; 3323 :         return cckd_write_l2 (dev);

  0018d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00195	e8 00 00 00 00	 call	 cckd_write_l2
  0019a	eb 68		 jmp	 SHORT $LN1@cckd_write
$LN5@cckd_write:

; 3324 : 
; 3325 :     /* Write the level 2 table entry */
; 3326 :     off = (off_t)(cckd->L1tab[sfx][L1idx] + l2x * CCKD_L2ENT_SIZE);

  0019c	48 63 44 24 64	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001a1	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  001a6	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  001ab	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  001b3	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  001b6	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR l2x$[rsp]
  001bb	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  001bf	48 89 44 24 78	 mov	 QWORD PTR off$[rsp], rax

; 3327 :     if (cckd_write (dev, sfx, off, &cckd->L2tab[l2x], CCKD_L2ENT_SIZE) < 0)

  001c4	48 63 44 24 60	 movsxd	 rax, DWORD PTR l2x$[rsp]
  001c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ce	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  001d2	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  001d6	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  001de	4c 8b c8	 mov	 r9, rax
  001e1	4c 8b 44 24 78	 mov	 r8, QWORD PTR off$[rsp]
  001e6	8b 54 24 64	 mov	 edx, DWORD PTR sfx$[rsp]
  001ea	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f2	e8 00 00 00 00	 call	 cckd_write
  001f7	85 c0		 test	 eax, eax
  001f9	7d 07		 jge	 SHORT $LN7@cckd_write

; 3328 :         return -1;

  001fb	b8 ff ff ff ff	 mov	 eax, -1
  00200	eb 02		 jmp	 SHORT $LN1@cckd_write
$LN7@cckd_write:

; 3329 : 
; 3330 :     return 0;

  00202	33 c0		 xor	 eax, eax
$LN1@cckd_write:

; 3331 : } /* end function cckd_write_l2ent */

  00204	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0020b	c3		 ret	 0
cckd_write_l2ent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
sfx$ = 96
l2x$ = 100
L1idx$ = 104
tv156 = 108
tv165 = 112
tv173 = 116
cckd$ = 120
dev$ = 144
l2$ = 152
trk$ = 160
cckd_read_l2ent PROC

; 3245 : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 3246 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3247 : int             sfx,L1idx,l2x;          /* Lookup table indices      */
; 3248 : 
; 3249 :     if (dev->cckd64)

  00016	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00025	24 01		 and	 al, 1
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	74 22		 je	 SHORT $LN5@cckd_read_

; 3250 :         return cckd64_read_l2ent( dev, (CCKD64_L2ENT*) l2, trk );

  0002e	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00036	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR l2$[rsp]
  0003e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00046	e8 00 00 00 00	 call	 cckd64_read_l2ent
  0004b	e9 8c 02 00 00	 jmp	 $LN1@cckd_read_
$LN5@cckd_read_:

; 3251 : 
; 3252 :     cckd = dev->cckd_ext;

  00050	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00058	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0005f	48 89 44 24 78	 mov	 QWORD PTR cckd$[rsp], rax

; 3253 : 
; 3254 :     L1idx = trk >> 8;

  00064	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0006b	c1 f8 08	 sar	 eax, 8
  0006e	89 44 24 68	 mov	 DWORD PTR L1idx$[rsp], eax

; 3255 :     l2x = trk & 0xff;

  00072	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00079	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0007e	89 44 24 64	 mov	 DWORD PTR l2x$[rsp], eax

; 3256 : 
; 3257 :     if (l2 != NULL) l2->L2_trkoff = l2->L2_len = l2->L2_size = 0;

  00082	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR l2$[rsp], 0
  0008b	74 2a		 je	 SHORT $LN6@cckd_read_
  0008d	33 c0		 xor	 eax, eax
  0008f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR l2$[rsp]
  00097	66 89 41 06	 mov	 WORD PTR [rcx+6], ax
  0009b	33 c0		 xor	 eax, eax
  0009d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR l2$[rsp]
  000a5	66 89 41 04	 mov	 WORD PTR [rcx+4], ax
  000a9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR l2$[rsp]
  000b1	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN6@cckd_read_:

; 3258 : 
; 3259 :     for (sfx = cckd->sfn; sfx >= 0; sfx--)

  000b7	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  000bc	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  000bf	89 44 24 60	 mov	 DWORD PTR sfx$[rsp], eax
  000c3	eb 0a		 jmp	 SHORT $LN4@cckd_read_
$LN2@cckd_read_:
  000c5	8b 44 24 60	 mov	 eax, DWORD PTR sfx$[rsp]
  000c9	ff c8		 dec	 eax
  000cb	89 44 24 60	 mov	 DWORD PTR sfx$[rsp], eax
$LN4@cckd_read_:
  000cf	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  000d4	0f 8c c2 00 00
	00		 jl	 $LN3@cckd_read_

; 3260 :     {
; 3261 :         CCKD_TRACE( "file[%d] l2[%d,%d] trk[%d] read_l2ent 0x%x",

  000da	48 63 44 24 60	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000df	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000e4	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  000e9	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000f1	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  000f4	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  000f8	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  000ff	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00103	8b 44 24 64	 mov	 eax, DWORD PTR l2x$[rsp]
  00107	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0010b	8b 44 24 68	 mov	 eax, DWORD PTR L1idx$[rsp]
  0010f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00113	8b 44 24 60	 mov	 eax, DWORD PTR sfx$[rsp]
  00117	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0011b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171248
  00122	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0012a	ba be 0c 00 00	 mov	 edx, 3262		; 00000cbeH
  0012f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171249
  00136	e8 00 00 00 00	 call	 cckd_trace

; 3262 :                     sfx, L1idx, l2x, trk, cckd->L1tab[sfx][L1idx]);
; 3263 : 
; 3264 :         /* Continue if l2 table not in this file */
; 3265 :         if (cckd->L1tab[sfx][L1idx] == CCKD_MAXSIZE)

  0013b	48 63 44 24 60	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00140	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  00145	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  0014a	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00152	83 3c 88 ff	 cmp	 DWORD PTR [rax+rcx*4], -1 ; ffffffffH
  00156	75 05		 jne	 SHORT $LN7@cckd_read_

; 3266 :             continue;

  00158	e9 68 ff ff ff	 jmp	 $LN2@cckd_read_
$LN7@cckd_read_:

; 3267 : 
; 3268 :         /* Read l2 table from this file */
; 3269 :         if (cckd_read_l2 (dev, sfx, L1idx) < 0)

  0015d	44 8b 44 24 68	 mov	 r8d, DWORD PTR L1idx$[rsp]
  00162	8b 54 24 60	 mov	 edx, DWORD PTR sfx$[rsp]
  00166	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0016e	e8 00 00 00 00	 call	 cckd_read_l2
  00173	85 c0		 test	 eax, eax
  00175	7d 0a		 jge	 SHORT $LN8@cckd_read_

; 3270 :             return -1;

  00177	b8 ff ff ff ff	 mov	 eax, -1
  0017c	e9 5b 01 00 00	 jmp	 $LN1@cckd_read_
$LN8@cckd_read_:

; 3271 : 
; 3272 :         /* Exit loop if track is in this file */
; 3273 :         if (cckd->L2tab[l2x].L2_trkoff != CCKD_MAXSIZE)

  00181	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  00186	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0018b	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0018f	83 3c c1 ff	 cmp	 DWORD PTR [rcx+rax*8], -1 ; ffffffffH
  00193	74 02		 je	 SHORT $LN9@cckd_read_

; 3274 :             break;

  00195	eb 05		 jmp	 SHORT $LN3@cckd_read_
$LN9@cckd_read_:

; 3275 :     }

  00197	e9 29 ff ff ff	 jmp	 $LN2@cckd_read_
$LN3@cckd_read_:

; 3276 : 
; 3277 :     CCKD_TRACE( "file[%d] l2[%d,%d] trk[%d] read_l2ent 0x%x %d %d",

  0019c	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  001a1	7c 19		 jl	 SHORT $LN12@cckd_read_
  001a3	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  001a8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ad	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  001b1	0f b7 44 c1 06	 movzx	 eax, WORD PTR [rcx+rax*8+6]
  001b6	89 44 24 6c	 mov	 DWORD PTR tv156[rsp], eax
  001ba	eb 08		 jmp	 SHORT $LN13@cckd_read_
$LN12@cckd_read_:
  001bc	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
$LN13@cckd_read_:
  001c4	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  001c9	7c 19		 jl	 SHORT $LN14@cckd_read_
  001cb	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  001d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001d5	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  001d9	0f b7 44 c1 04	 movzx	 eax, WORD PTR [rcx+rax*8+4]
  001de	89 44 24 70	 mov	 DWORD PTR tv165[rsp], eax
  001e2	eb 08		 jmp	 SHORT $LN15@cckd_read_
$LN14@cckd_read_:
  001e4	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
$LN15@cckd_read_:
  001ec	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  001f1	7c 17		 jl	 SHORT $LN16@cckd_read_
  001f3	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  001f8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001fd	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00201	8b 04 c1	 mov	 eax, DWORD PTR [rcx+rax*8]
  00204	89 44 24 74	 mov	 DWORD PTR tv173[rsp], eax
  00208	eb 08		 jmp	 SHORT $LN17@cckd_read_
$LN16@cckd_read_:
  0020a	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv173[rsp], 0
$LN17@cckd_read_:
  00212	8b 44 24 6c	 mov	 eax, DWORD PTR tv156[rsp]
  00216	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  0021a	8b 44 24 70	 mov	 eax, DWORD PTR tv165[rsp]
  0021e	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00222	8b 44 24 74	 mov	 eax, DWORD PTR tv173[rsp]
  00226	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0022a	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00231	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00235	8b 44 24 64	 mov	 eax, DWORD PTR l2x$[rsp]
  00239	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0023d	8b 44 24 68	 mov	 eax, DWORD PTR L1idx$[rsp]
  00241	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00245	8b 44 24 60	 mov	 eax, DWORD PTR sfx$[rsp]
  00249	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0024d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171253
  00254	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0025c	ba d0 0c 00 00	 mov	 edx, 3280		; 00000cd0H
  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171254
  00268	e8 00 00 00 00	 call	 cckd_trace

; 3278 :                 sfx, L1idx, l2x, trk, sfx >= 0 ? cckd->L2tab[l2x].L2_trkoff : 0,
; 3279 :                 sfx >= 0 ? cckd->L2tab[l2x].L2_len : 0,
; 3280 :                 sfx >= 0 ? cckd->L2tab[l2x].L2_size : 0);
; 3281 : 
; 3282 :     if (l2 != NULL && sfx >= 0)

  0026d	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR l2$[rsp], 0
  00276	74 60		 je	 SHORT $LN10@cckd_read_
  00278	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  0027d	7c 59		 jl	 SHORT $LN10@cckd_read_

; 3283 :     {
; 3284 :         l2->L2_trkoff  = cckd->L2tab[l2x].L2_trkoff;

  0027f	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  00284	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00289	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0028d	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR l2$[rsp]
  00295	8b 04 c1	 mov	 eax, DWORD PTR [rcx+rax*8]
  00298	89 02		 mov	 DWORD PTR [rdx], eax

; 3285 :         l2->L2_len  = cckd->L2tab[l2x].L2_len;

  0029a	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  0029f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  002a4	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  002a8	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR l2$[rsp]
  002b0	0f b7 44 c1 04	 movzx	 eax, WORD PTR [rcx+rax*8+4]
  002b5	66 89 42 04	 mov	 WORD PTR [rdx+4], ax

; 3286 :         l2->L2_size = cckd->L2tab[l2x].L2_size;

  002b9	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  002be	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  002c3	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  002c7	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR l2$[rsp]
  002cf	0f b7 44 c1 06	 movzx	 eax, WORD PTR [rcx+rax*8+6]
  002d4	66 89 42 06	 mov	 WORD PTR [rdx+6], ax
$LN10@cckd_read_:

; 3287 :     }
; 3288 : 
; 3289 :     return sfx;

  002d8	8b 44 24 60	 mov	 eax, DWORD PTR sfx$[rsp]
$LN1@cckd_read_:

; 3290 : 
; 3291 : } /* end function cckd_read_l2ent */

  002dc	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002e3	c3		 ret	 0
cckd_read_l2ent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
sfx$ = 48
L1idx$ = 52
fix$ = 56
size$ = 60
cckd$ = 64
off$ = 72
old_off$ = 80
dev$ = 112
cckd_write_l2 PROC

; 3189 : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3190 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3191 : int             sfx,L1idx;              /* Lookup table indices      */
; 3192 : off_t           off, old_off;           /* New/old L2 file offsets   */
; 3193 : int             size = CCKD_L2TAB_SIZE; /* L2 table size             */

  00009	c7 44 24 3c 00
	08 00 00	 mov	 DWORD PTR size$[rsp], 2048 ; 00000800H

; 3194 : int             fix;                    /* Null format type          */
; 3195 : 
; 3196 :     if (dev->cckd64)

  00011	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00016	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0001d	24 01		 and	 al, 1
  0001f	0f b6 c0	 movzx	 eax, al
  00022	85 c0		 test	 eax, eax
  00024	74 0f		 je	 SHORT $LN2@cckd_write

; 3197 :         return cckd64_write_l2( dev );

  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0002b	e8 00 00 00 00	 call	 cckd64_write_l2
  00030	e9 16 02 00 00	 jmp	 $LN1@cckd_write
$LN2@cckd_write:

; 3198 : 
; 3199 :     cckd = dev->cckd_ext;

  00035	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0003a	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00041	48 89 44 24 40	 mov	 QWORD PTR cckd$[rsp], rax

; 3200 :     sfx = cckd->sfn;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  0004b	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0004e	89 44 24 30	 mov	 DWORD PTR sfx$[rsp], eax

; 3201 :     L1idx = cckd->L1idx;

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00057	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0005a	89 44 24 34	 mov	 DWORD PTR L1idx$[rsp], eax

; 3202 :     fix = cckd->cdevhdr[sfx].cdh_nullfmt;

  0005e	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00063	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0006a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0006f	0f b6 84 01 0c
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+524]
  00077	89 44 24 38	 mov	 DWORD PTR fix$[rsp], eax

; 3203 :     cckd->L2ok = 0;

  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00080	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00083	0f ba f0 08	 btr	 eax, 8
  00087	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0008c	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3204 : 
; 3205 :     CCKD_TRACE( "file[%d] write_l2 %d", sfx, L1idx);

  0008f	8b 44 24 34	 mov	 eax, DWORD PTR L1idx$[rsp]
  00093	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00097	8b 44 24 30	 mov	 eax, DWORD PTR sfx$[rsp]
  0009b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0009f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171214
  000a6	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  000ab	ba 85 0c 00 00	 mov	 edx, 3205		; 00000c85H
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171215
  000b7	e8 00 00 00 00	 call	 cckd_trace

; 3206 : 
; 3207 :     if (sfx < 0 || L1idx < 0) return -1;

  000bc	83 7c 24 30 00	 cmp	 DWORD PTR sfx$[rsp], 0
  000c1	7c 07		 jl	 SHORT $LN4@cckd_write
  000c3	83 7c 24 34 00	 cmp	 DWORD PTR L1idx$[rsp], 0
  000c8	7d 0a		 jge	 SHORT $LN3@cckd_write
$LN4@cckd_write:
  000ca	b8 ff ff ff ff	 mov	 eax, -1
  000cf	e9 77 01 00 00	 jmp	 $LN1@cckd_write
$LN3@cckd_write:

; 3208 : 
; 3209 :     old_off = (off_t)cckd->L1tab[sfx][L1idx];

  000d4	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000d9	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000de	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  000e3	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000eb	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  000ee	48 89 44 24 50	 mov	 QWORD PTR old_off$[rsp], rax

; 3210 : 
; 3211 :     if (cckd->L1tab[sfx][L1idx] == CCKD_NOSIZE || cckd->L1tab[sfx][L1idx] == CCKD_MAXSIZE)

  000f3	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000f8	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000fd	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00102	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  0010a	83 3c 88 00	 cmp	 DWORD PTR [rax+rcx*4], 0
  0010e	74 1d		 je	 SHORT $LN6@cckd_write
  00110	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00115	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  0011a	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  0011f	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00127	83 3c 88 ff	 cmp	 DWORD PTR [rax+rcx*4], -1 ; ffffffffH
  0012b	75 18		 jne	 SHORT $LN5@cckd_write
$LN6@cckd_write:

; 3212 :         cckd->L2_bounds += CCKD_L2TAB_SIZE;

  0012d	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00132	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00136	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  0013c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00141	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
$LN5@cckd_write:

; 3213 : 
; 3214 :     /* Write the L2 table if it's not empty */
; 3215 :     if (memcmp( cckd->L2tab, &empty_l2[fix], CCKD_L2TAB_SIZE ))

  00145	48 63 44 24 38	 movsxd	 rax, DWORD PTR fix$[rsp]
  0014a	48 69 c0 00 08
	00 00		 imul	 rax, rax, 2048		; 00000800H
  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:empty_l2
  00158	48 03 c8	 add	 rcx, rax
  0015b	48 8b c1	 mov	 rax, rcx
  0015e	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00164	48 8b d0	 mov	 rdx, rax
  00167	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  0016c	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  00170	e8 00 00 00 00	 call	 memcmp
  00175	85 c0		 test	 eax, eax
  00177	74 5d		 je	 SHORT $LN7@cckd_write

; 3216 :     {
; 3217 :         if ((off = cckd_get_space( dev, &size, CCKD_L2SPACE )) < 0)

  00179	41 b8 04 00 00
	00		 mov	 r8d, 4
  0017f	48 8d 54 24 3c	 lea	 rdx, QWORD PTR size$[rsp]
  00184	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00189	e8 00 00 00 00	 call	 cckd_get_space
  0018e	48 89 44 24 48	 mov	 QWORD PTR off$[rsp], rax
  00193	48 83 7c 24 48
	00		 cmp	 QWORD PTR off$[rsp], 0
  00199	7d 0a		 jge	 SHORT $LN9@cckd_write

; 3218 :             return -1;

  0019b	b8 ff ff ff ff	 mov	 eax, -1
  001a0	e9 a6 00 00 00	 jmp	 $LN1@cckd_write
$LN9@cckd_write:

; 3219 :         if (cckd_write( dev, sfx, off, cckd->L2tab, CCKD_L2TAB_SIZE ) < 0)

  001a5	c7 44 24 20 00
	08 00 00	 mov	 DWORD PTR [rsp+32], 2048 ; 00000800H
  001ad	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  001b2	4c 8b 48 48	 mov	 r9, QWORD PTR [rax+72]
  001b6	4c 8b 44 24 48	 mov	 r8, QWORD PTR off$[rsp]
  001bb	8b 54 24 30	 mov	 edx, DWORD PTR sfx$[rsp]
  001bf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001c4	e8 00 00 00 00	 call	 cckd_write
  001c9	85 c0		 test	 eax, eax
  001cb	7d 07		 jge	 SHORT $LN10@cckd_write

; 3220 :             return -1;

  001cd	b8 ff ff ff ff	 mov	 eax, -1
  001d2	eb 77		 jmp	 SHORT $LN1@cckd_write
$LN10@cckd_write:

; 3221 :     }

  001d4	eb 21		 jmp	 SHORT $LN8@cckd_write
$LN7@cckd_write:

; 3222 :     else
; 3223 :     {
; 3224 :         off = 0;

  001d6	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR off$[rsp], 0

; 3225 :         cckd->L2_bounds -= CCKD_L2TAB_SIZE;

  001df	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  001e4	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001e8	48 2d 00 08 00
	00		 sub	 rax, 2048		; 00000800H
  001ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  001f3	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
$LN8@cckd_write:

; 3226 :     }
; 3227 : 
; 3228 :     /* Free the old L2 space */
; 3229 :     cckd_rel_space( dev, old_off, CCKD_L2TAB_SIZE, CCKD_L2TAB_SIZE );

  001f7	41 b9 00 08 00
	00		 mov	 r9d, 2048		; 00000800H
  001fd	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00203	48 8b 54 24 50	 mov	 rdx, QWORD PTR old_off$[rsp]
  00208	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0020d	e8 00 00 00 00	 call	 cckd_rel_space

; 3230 : 
; 3231 :     /* Update level 1 table */
; 3232 :     cckd->L1tab[sfx][L1idx] = (U32)off;

  00212	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00217	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  0021c	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00221	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00229	8b 54 24 48	 mov	 edx, DWORD PTR off$[rsp]
  0022d	89 14 88	 mov	 DWORD PTR [rax+rcx*4], edx

; 3233 : 
; 3234 :     if (cckd_write_l1ent( dev, L1idx ) < 0)

  00230	8b 54 24 34	 mov	 edx, DWORD PTR L1idx$[rsp]
  00234	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00239	e8 00 00 00 00	 call	 cckd_write_l1ent
  0023e	85 c0		 test	 eax, eax
  00240	7d 07		 jge	 SHORT $LN11@cckd_write

; 3235 :         return -1;

  00242	b8 ff ff ff ff	 mov	 eax, -1
  00247	eb 02		 jmp	 SHORT $LN1@cckd_write
$LN11@cckd_write:

; 3236 : 
; 3237 :     return 0;

  00249	33 c0		 xor	 eax, eax
$LN1@cckd_write:

; 3238 : 
; 3239 : } /* end function cckd_write_l2 */

  0024b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0024f	c3		 ret	 0
cckd_write_l2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
tv66 = 32
answer$ = 64
ix$ = 72
i$ = 80
data$ = 88
cckd_steal_l2_scan PROC

; 3177 : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@cckd_steal:

; 3178 :     UNREFERENCED(data);

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@cckd_steal

; 3179 :     if (*answer < 0) *answer = i;

  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR answer$[rsp]
  00022	83 38 00	 cmp	 DWORD PTR [rax], 0
  00025	7d 0d		 jge	 SHORT $LN5@cckd_steal
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR answer$[rsp]
  0002c	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  00030	89 08		 mov	 DWORD PTR [rax], ecx
  00032	eb 37		 jmp	 SHORT $LN6@cckd_steal
$LN5@cckd_steal:

; 3180 :     else if (cache_getage(ix, i) < cache_getage(ix, *answer))

  00034	8b 54 24 50	 mov	 edx, DWORD PTR i$[rsp]
  00038	8b 4c 24 48	 mov	 ecx, DWORD PTR ix$[rsp]
  0003c	e8 00 00 00 00	 call	 cache_getage
  00041	48 89 44 24 20	 mov	 QWORD PTR tv66[rsp], rax
  00046	48 8b 4c 24 40	 mov	 rcx, QWORD PTR answer$[rsp]
  0004b	8b 11		 mov	 edx, DWORD PTR [rcx]
  0004d	8b 4c 24 48	 mov	 ecx, DWORD PTR ix$[rsp]
  00051	e8 00 00 00 00	 call	 cache_getage
  00056	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv66[rsp]
  0005b	48 3b c8	 cmp	 rcx, rax
  0005e	73 0b		 jae	 SHORT $LN7@cckd_steal

; 3181 :         *answer = i;

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR answer$[rsp]
  00065	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  00069	89 08		 mov	 DWORD PTR [rax], ecx
$LN7@cckd_steal:
$LN6@cckd_steal:

; 3182 :     return 0;

  0006b	33 c0		 xor	 eax, eax

; 3183 : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
cckd_steal_l2_scan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
devnum$ = 32
sfx$ = 36
i$ = 40
L1idx$ = 44
cckd$ = 48
dev$ = 56
cckd_steal_l2 PROC

; 3157 : {

$LN7:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3158 : DEVBLK         *dev;                    /* -> device block           */
; 3159 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3160 : int             i;                      /* Stolen cache index        */
; 3161 : U16             sfx;                    /* Cached suffix             */
; 3162 : U16             devnum;                 /* Cached device number      */
; 3163 : U32             L1idx;                  /* Cached level 1 index      */
; 3164 : 
; 3165 :     i = cache_scan (CACHE_L2, cckd_steal_l2_scan, NULL);

  00004	45 33 c0	 xor	 r8d, r8d
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cckd_steal_l2_scan
  0000e	b9 01 00 00 00	 mov	 ecx, 1
  00013	e8 00 00 00 00	 call	 cache_scan
  00018	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd_steal:

; 3166 :     L2_CACHE_GETKEY(i, sfx, devnum, L1idx);

  0001c	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  00020	b9 01 00 00 00	 mov	 ecx, 1
  00025	e8 00 00 00 00	 call	 cache_getkey
  0002a	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  0002e	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00034	66 89 44 24 24	 mov	 WORD PTR sfx$[rsp], ax
  00039	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  0003d	b9 01 00 00 00	 mov	 ecx, 1
  00042	e8 00 00 00 00	 call	 cache_getkey
  00047	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0004b	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00051	66 89 44 24 20	 mov	 WORD PTR devnum$[rsp], ax
  00056	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  0005a	b9 01 00 00 00	 mov	 ecx, 1
  0005f	e8 00 00 00 00	 call	 cache_getkey
  00064	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00069	48 23 c1	 and	 rax, rcx
  0006c	89 44 24 2c	 mov	 DWORD PTR L1idx$[rsp], eax
  00070	33 c0		 xor	 eax, eax
  00072	85 c0		 test	 eax, eax
  00074	75 a6		 jne	 SHORT $LN4@cckd_steal

; 3167 :     dev = cckd_find_device_by_devnum(devnum);

  00076	0f b7 4c 24 20	 movzx	 ecx, WORD PTR devnum$[rsp]
  0007b	e8 00 00 00 00	 call	 cckd_find_device_by_devnum
  00080	48 89 44 24 38	 mov	 QWORD PTR dev$[rsp], rax

; 3168 :     if (dev->cckd64)

  00085	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0008a	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00091	24 01		 and	 al, 1
  00093	0f b6 c0	 movzx	 eax, al
  00096	85 c0		 test	 eax, eax
  00098	74 07		 je	 SHORT $LN5@cckd_steal

; 3169 :         return cckd64_steal_l2();

  0009a	e8 00 00 00 00	 call	 cckd64_steal_l2
  0009f	eb 57		 jmp	 SHORT $LN1@cckd_steal
$LN5@cckd_steal:

; 3170 :     cckd = dev->cckd_ext;

  000a1	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  000a6	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  000ad	48 89 44 24 30	 mov	 QWORD PTR cckd$[rsp], rax

; 3171 :     cckd->L2_active = cckd->sfx = cckd->L1idx = -1;

  000b2	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  000b7	c7 40 44 ff ff
	ff ff		 mov	 DWORD PTR [rax+68], -1
  000be	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  000c3	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
  000ca	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  000cf	c7 40 50 ff ff
	ff ff		 mov	 DWORD PTR [rax+80], -1

; 3172 :     cckd->L2tab = NULL;

  000d6	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  000db	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 3173 :     cache_release(CACHE_L2, i, 0);

  000e3	45 33 c0	 xor	 r8d, r8d
  000e6	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  000ea	b9 01 00 00 00	 mov	 ecx, 1
  000ef	e8 00 00 00 00	 call	 cache_release

; 3174 :     return i;

  000f4	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
$LN1@cckd_steal:

; 3175 : }

  000f8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fc	c3		 ret	 0
cckd_steal_l2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
devnum$ = 64
sfx$ = 68
L1idx$ = 72
dev$ = 80
answer$ = 112
ix$ = 120
i$ = 128
data$ = 136
cckd_purge_l2_scan PROC

; 3136 : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3137 : U16             sfx;                    /* Cached suffix             */
; 3138 : U16             devnum;                 /* Cached device number      */
; 3139 : U32             L1idx;                  /* Cached level 1 index      */
; 3140 : DEVBLK         *dev = data;             /* -> device block           */

  00017	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0001f	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd_purge:

; 3141 : 
; 3142 :     UNREFERENCED(answer);

  00024	33 c0		 xor	 eax, eax
  00026	85 c0		 test	 eax, eax
  00028	75 fa		 jne	 SHORT $LN4@cckd_purge
$LN7@cckd_purge:

; 3143 :     L2_CACHE_GETKEY(i, sfx, devnum, L1idx);

  0002a	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	e8 00 00 00 00	 call	 cache_getkey
  0003b	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  0003f	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00045	66 89 44 24 44	 mov	 WORD PTR sfx$[rsp], ax
  0004a	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00051	b9 01 00 00 00	 mov	 ecx, 1
  00056	e8 00 00 00 00	 call	 cache_getkey
  0005b	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0005f	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00065	66 89 44 24 40	 mov	 WORD PTR devnum$[rsp], ax
  0006a	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00071	b9 01 00 00 00	 mov	 ecx, 1
  00076	e8 00 00 00 00	 call	 cache_getkey
  0007b	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00080	48 23 c1	 and	 rax, rcx
  00083	89 44 24 48	 mov	 DWORD PTR L1idx$[rsp], eax
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 9d		 jne	 SHORT $LN7@cckd_purge

; 3144 :     if (dev == NULL || devnum == dev->devnum)

  0008d	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00093	74 12		 je	 SHORT $LN9@cckd_purge
  00095	0f b7 44 24 40	 movzx	 eax, WORD PTR devnum$[rsp]
  0009a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0009f	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  000a3	3b c1		 cmp	 eax, ecx
  000a5	75 55		 jne	 SHORT $LN8@cckd_purge
$LN9@cckd_purge:

; 3145 :     {
; 3146 :         CCKD_TRACE( "purge l2cache[%d] %4.4X sfx %d ix %d purged",

  000a7	0f b7 44 24 44	 movzx	 eax, WORD PTR sfx$[rsp]
  000ac	0f b7 4c 24 40	 movzx	 ecx, WORD PTR devnum$[rsp]
  000b1	8b 54 24 48	 mov	 edx, DWORD PTR L1idx$[rsp]
  000b5	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  000b9	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000bd	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  000c1	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  000c8	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000cc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171151
  000d3	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  000d8	ba 4b 0c 00 00	 mov	 edx, 3147		; 00000c4bH
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171152
  000e4	e8 00 00 00 00	 call	 cckd_trace

; 3147 :                     i, devnum, sfx, L1idx);
; 3148 :         cache_release(ix, i, 0);

  000e9	45 33 c0	 xor	 r8d, r8d
  000ec	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  000f3	8b 4c 24 78	 mov	 ecx, DWORD PTR ix$[rsp]
  000f7	e8 00 00 00 00	 call	 cache_release
$LN8@cckd_purge:

; 3149 :     }
; 3150 :     return 0;

  000fc	33 c0		 xor	 eax, eax

; 3151 : }

  000fe	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00102	c3		 ret	 0
cckd_purge_l2_scan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
cckd$ = 48
dev$ = 80
cckd_purge_l2 PROC

; 3116 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3117 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3118 : 
; 3119 :     if (dev->cckd64)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	74 0f		 je	 SHORT $LN2@cckd_purge

; 3120 :     {
; 3121 :         cckd64_purge_l2( dev );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd64_purge_l2

; 3122 :         return;

  00028	e9 95 00 00 00	 jmp	 $LN1@cckd_purge
$LN2@cckd_purge:

; 3123 :     }
; 3124 : 
; 3125 :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 30	 mov	 QWORD PTR cckd$[rsp], rax

; 3126 : 
; 3127 :     CCKD_TRACE( "purge_l2%s", "");

  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171123
  00045	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171124
  00051	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  00056	ba 37 0c 00 00	 mov	 edx, 3127		; 00000c37H
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171125
  00062	e8 00 00 00 00	 call	 cckd_trace

; 3128 : 
; 3129 :     cache_lock (CACHE_L2);

  00067	b9 01 00 00 00	 mov	 ecx, 1
  0006c	e8 00 00 00 00	 call	 cache_lock

; 3130 :     cckd->L2_active = cckd->sfx = cckd->L1idx = -1;

  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00076	c7 40 44 ff ff
	ff ff		 mov	 DWORD PTR [rax+68], -1
  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00082	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
  00089	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  0008e	c7 40 50 ff ff
	ff ff		 mov	 DWORD PTR [rax+80], -1

; 3131 :     cckd->L2tab = NULL;

  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  0009a	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 3132 :     cache_scan (CACHE_L2, cckd_purge_l2_scan, dev);

  000a2	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cckd_purge_l2_scan
  000ae	b9 01 00 00 00	 mov	 ecx, 1
  000b3	e8 00 00 00 00	 call	 cache_scan

; 3133 :     cache_unlock (CACHE_L2);

  000b8	b9 01 00 00 00	 mov	 ecx, 1
  000bd	e8 00 00 00 00	 call	 cache_unlock
$LN1@cckd_purge:

; 3134 : }

  000c2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c6	c3		 ret	 0
cckd_purge_l2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
lru$ = 80
fnd$ = 84
i$ = 88
nullfmt$ = 92
cckd$ = 96
buf$ = 104
off$ = 112
dev$ = 144
sfx$ = 152
L1idx$ = 160
cckd_read_l2 PROC

; 3005 : {

$LN19:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 3006 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 3007 : off_t           off;                    /* L2 file offset            */
; 3008 : int             fnd;                    /* Found cache               */
; 3009 : int             lru;                    /* Oldest available cache    */
; 3010 : CCKD_L2ENT     *buf;                    /* -> Cache buffer           */
; 3011 : int             i;                      /* Loop index                */
; 3012 : int             nullfmt;                /* Null track format         */
; 3013 : 
; 3014 :     if (dev->cckd64)

  00016	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00025	24 01		 and	 al, 1
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	74 21		 je	 SHORT $LN5@cckd_read_

; 3015 :         return cckd64_read_l2( dev, sfx, L1idx );

  0002e	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR L1idx$[rsp]
  00036	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  0003d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00045	e8 00 00 00 00	 call	 cckd64_read_l2
  0004a	e9 fd 05 00 00	 jmp	 $LN1@cckd_read_
$LN5@cckd_read_:

; 3016 : 
; 3017 :     cckd = dev->cckd_ext;

  0004f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00057	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0005e	48 89 44 24 60	 mov	 QWORD PTR cckd$[rsp], rax

; 3018 :     nullfmt = cckd->cdevhdr[cckd->sfn].cdh_nullfmt;

  00063	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00068	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0006c	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00073	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00078	0f b6 84 01 0c
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+524]
  00080	89 44 24 5c	 mov	 DWORD PTR nullfmt$[rsp], eax

; 3019 : 
; 3020 :     CCKD_TRACE( "file[%d] read_l2 %d active %d %d %d",

  00084	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00089	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0008c	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00090	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00095	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00098	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0009c	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  000a1	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  000a4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000a8	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR L1idx$[rsp]
  000af	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000b3	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  000ba	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000be	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171093
  000c5	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000cd	ba cd 0b 00 00	 mov	 edx, 3021		; 00000bcdH
  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171094
  000d9	e8 00 00 00 00	 call	 cckd_trace

; 3021 :                 sfx, L1idx, cckd->sfx, cckd->L1idx, cckd->L2_active);
; 3022 : 
; 3023 :     /* Return if table is already active */
; 3024 :     if (sfx == cckd->sfx && L1idx == cckd->L1idx) return 0;

  000de	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  000e3	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  000e6	39 84 24 98 00
	00 00		 cmp	 DWORD PTR sfx$[rsp], eax
  000ed	75 18		 jne	 SHORT $LN6@cckd_read_
  000ef	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  000f4	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000f7	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR L1idx$[rsp], eax
  000fe	75 07		 jne	 SHORT $LN6@cckd_read_
  00100	33 c0		 xor	 eax, eax
  00102	e9 45 05 00 00	 jmp	 $LN1@cckd_read_
$LN6@cckd_read_:

; 3025 : 
; 3026 :     cache_lock(CACHE_L2);

  00107	b9 01 00 00 00	 mov	 ecx, 1
  0010c	e8 00 00 00 00	 call	 cache_lock

; 3027 : 
; 3028 :     /* Inactivate the previous entry */
; 3029 :     if (cckd->L2_active >= 0)

  00111	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00116	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  0011a	7c 1b		 jl	 SHORT $LN7@cckd_read_

; 3030 :         cache_setflag(CACHE_L2, cckd->L2_active, ~L2_CACHE_ACTIVE, 0);

  0011c	45 33 c9	 xor	 r9d, r9d
  0011f	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  00125	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0012a	8b 50 50	 mov	 edx, DWORD PTR [rax+80]
  0012d	b9 01 00 00 00	 mov	 ecx, 1
  00132	e8 00 00 00 00	 call	 cache_setflag
$LN7@cckd_read_:

; 3031 :     cckd->L2tab = NULL;

  00137	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0013c	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 3032 :     cckd->L2_active = cckd->sfx = cckd->L1idx = -1;

  00144	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00149	c7 40 44 ff ff
	ff ff		 mov	 DWORD PTR [rax+68], -1
  00150	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00155	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
  0015c	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00161	c7 40 50 ff ff
	ff ff		 mov	 DWORD PTR [rax+80], -1

; 3033 : 
; 3034 :     /* scan the cache array for the l2tab */
; 3035 :     fnd = cache_lookup (CACHE_L2, L2_CACHE_SETKEY(sfx, dev->devnum, L1idx), &lru);

  00168	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00170	48 c1 e0 30	 shl	 rax, 48			; 00000030H
  00174	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0017c	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00180	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  00184	48 0b c1	 or	 rax, rcx
  00187	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  0018f	48 0b c1	 or	 rax, rcx
  00192	4c 8d 44 24 50	 lea	 r8, QWORD PTR lru$[rsp]
  00197	48 8b d0	 mov	 rdx, rax
  0019a	b9 01 00 00 00	 mov	 ecx, 1
  0019f	e8 00 00 00 00	 call	 cache_lookup
  001a4	89 44 24 54	 mov	 DWORD PTR fnd$[rsp], eax

; 3036 : 
; 3037 :     /* check for level 2 cache hit */
; 3038 :     if (fnd >= 0)

  001a8	83 7c 24 54 00	 cmp	 DWORD PTR fnd$[rsp], 0
  001ad	0f 8c cc 00 00
	00		 jl	 $LN8@cckd_read_

; 3039 :     {
; 3040 :         CCKD_TRACE( "l2[%d,%d] cache[%d] hit", sfx, L1idx, fnd);

  001b3	8b 44 24 54	 mov	 eax, DWORD PTR fnd$[rsp]
  001b7	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001bb	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR L1idx$[rsp]
  001c2	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001c6	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  001cd	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001d1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171098
  001d8	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  001e0	ba e0 0b 00 00	 mov	 edx, 3040		; 00000be0H
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171099
  001ec	e8 00 00 00 00	 call	 cckd_trace

; 3041 :         cache_setflag (CACHE_L2, fnd, 0, L2_CACHE_ACTIVE);

  001f1	41 b9 00 00 00
	80		 mov	 r9d, -2147483648	; 80000000H
  001f7	45 33 c0	 xor	 r8d, r8d
  001fa	8b 54 24 54	 mov	 edx, DWORD PTR fnd$[rsp]
  001fe	b9 01 00 00 00	 mov	 ecx, 1
  00203	e8 00 00 00 00	 call	 cache_setflag

; 3042 :         cache_setage (CACHE_L2, fnd);

  00208	8b 54 24 54	 mov	 edx, DWORD PTR fnd$[rsp]
  0020c	b9 01 00 00 00	 mov	 ecx, 1
  00211	e8 00 00 00 00	 call	 cache_setage

; 3043 :         cckdblk.stats_l2cachehits++;

  00216	48 8b 05 a8 02
	00 00		 mov	 rax, QWORD PTR cckdblk+680
  0021d	48 ff c0	 inc	 rax
  00220	48 89 05 a8 02
	00 00		 mov	 QWORD PTR cckdblk+680, rax

; 3044 :         cache_unlock (CACHE_L2);

  00227	b9 01 00 00 00	 mov	 ecx, 1
  0022c	e8 00 00 00 00	 call	 cache_unlock

; 3045 :         cckd->sfx = sfx;

  00231	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00236	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  0023d	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 3046 :         cckd->L1idx = L1idx;

  00240	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00245	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR L1idx$[rsp]
  0024c	89 48 44	 mov	 DWORD PTR [rax+68], ecx

; 3047 :         cckd->L2tab = cache_getbuf(CACHE_L2, fnd, 0);

  0024f	45 33 c0	 xor	 r8d, r8d
  00252	8b 54 24 54	 mov	 edx, DWORD PTR fnd$[rsp]
  00256	b9 01 00 00 00	 mov	 ecx, 1
  0025b	e8 00 00 00 00	 call	 cache_getbuf
  00260	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00265	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax

; 3048 :         cckd->L2_active = fnd;

  00269	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0026e	8b 4c 24 54	 mov	 ecx, DWORD PTR fnd$[rsp]
  00272	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 3049 :         return 1;

  00275	b8 01 00 00 00	 mov	 eax, 1
  0027a	e9 cd 03 00 00	 jmp	 $LN1@cckd_read_
$LN8@cckd_read_:

; 3050 :     }
; 3051 : 
; 3052 :     CCKD_TRACE( "l2[%d,%d] cache[%d] miss", sfx, L1idx, lru);

  0027f	8b 44 24 50	 mov	 eax, DWORD PTR lru$[rsp]
  00283	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00287	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR L1idx$[rsp]
  0028e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00292	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  00299	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0029d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171100
  002a4	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  002ac	ba ec 0b 00 00	 mov	 edx, 3052		; 00000becH
  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171101
  002b8	e8 00 00 00 00	 call	 cckd_trace

; 3053 : 
; 3054 :     /* Steal an entry if all are busy */
; 3055 :     if (lru < 0) lru = cckd_steal_l2();

  002bd	83 7c 24 50 00	 cmp	 DWORD PTR lru$[rsp], 0
  002c2	7d 09		 jge	 SHORT $LN9@cckd_read_
  002c4	e8 00 00 00 00	 call	 cckd_steal_l2
  002c9	89 44 24 50	 mov	 DWORD PTR lru$[rsp], eax
$LN9@cckd_read_:

; 3056 : 
; 3057 :     /* Make the entry active */
; 3058 :     cache_setkey (CACHE_L2, lru, L2_CACHE_SETKEY(sfx, dev->devnum, L1idx));

  002cd	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  002d5	48 c1 e0 30	 shl	 rax, 48			; 00000030H
  002d9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e1	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002e5	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  002e9	48 0b c1	 or	 rax, rcx
  002ec	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  002f4	48 0b c1	 or	 rax, rcx
  002f7	4c 8b c0	 mov	 r8, rax
  002fa	8b 54 24 50	 mov	 edx, DWORD PTR lru$[rsp]
  002fe	b9 01 00 00 00	 mov	 ecx, 1
  00303	e8 00 00 00 00	 call	 cache_setkey

; 3059 :     cache_setflag (CACHE_L2, lru, 0, L2_CACHE_ACTIVE);

  00308	41 b9 00 00 00
	80		 mov	 r9d, -2147483648	; 80000000H
  0030e	45 33 c0	 xor	 r8d, r8d
  00311	8b 54 24 50	 mov	 edx, DWORD PTR lru$[rsp]
  00315	b9 01 00 00 00	 mov	 ecx, 1
  0031a	e8 00 00 00 00	 call	 cache_setflag

; 3060 :     cache_setage (CACHE_L2, lru);

  0031f	8b 54 24 50	 mov	 edx, DWORD PTR lru$[rsp]
  00323	b9 01 00 00 00	 mov	 ecx, 1
  00328	e8 00 00 00 00	 call	 cache_setage

; 3061 :     buf = cache_getbuf(CACHE_L2, lru, CCKD_L2TAB_SIZE);

  0032d	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00333	8b 54 24 50	 mov	 edx, DWORD PTR lru$[rsp]
  00337	b9 01 00 00 00	 mov	 ecx, 1
  0033c	e8 00 00 00 00	 call	 cache_getbuf
  00341	48 89 44 24 68	 mov	 QWORD PTR buf$[rsp], rax

; 3062 :     cckdblk.stats_l2cachemisses++;

  00346	48 8b 05 b0 02
	00 00		 mov	 rax, QWORD PTR cckdblk+688
  0034d	48 ff c0	 inc	 rax
  00350	48 89 05 b0 02
	00 00		 mov	 QWORD PTR cckdblk+688, rax

; 3063 :     cache_unlock (CACHE_L2);

  00357	b9 01 00 00 00	 mov	 ecx, 1
  0035c	e8 00 00 00 00	 call	 cache_unlock

; 3064 :     if (buf == NULL) return -1;

  00361	48 83 7c 24 68
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00367	75 0a		 jne	 SHORT $LN10@cckd_read_
  00369	b8 ff ff ff ff	 mov	 eax, -1
  0036e	e9 d9 02 00 00	 jmp	 $LN1@cckd_read_
$LN10@cckd_read_:

; 3065 : 
; 3066 :     /* Check for null table */
; 3067 :     if (cckd->L1tab[sfx][L1idx] == 0)

  00373	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0037b	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  00383	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00388	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00390	83 3c 88 00	 cmp	 DWORD PTR [rax+rcx*4], 0
  00394	0f 85 a8 00 00
	00		 jne	 $LN11@cckd_read_

; 3068 :     {
; 3069 :         memset(buf, 0, CCKD_L2TAB_SIZE);

  0039a	48 8b 7c 24 68	 mov	 rdi, QWORD PTR buf$[rsp]
  0039f	33 c0		 xor	 eax, eax
  003a1	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  003a6	f3 aa		 rep stosb

; 3070 :         if (nullfmt)

  003a8	83 7c 24 5c 00	 cmp	 DWORD PTR nullfmt$[rsp], 0
  003ad	74 48		 je	 SHORT $LN13@cckd_read_

; 3071 :             for (i = 0; i < 256; i++)

  003af	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003b7	eb 0a		 jmp	 SHORT $LN4@cckd_read_
$LN2@cckd_read_:
  003b9	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  003bd	ff c0		 inc	 eax
  003bf	89 44 24 58	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd_read_:
  003c3	81 7c 24 58 00
	01 00 00	 cmp	 DWORD PTR i$[rsp], 256	; 00000100H
  003cb	7d 2a		 jge	 SHORT $LN3@cckd_read_

; 3072 :                 buf[i].L2_len = buf[i].L2_size = nullfmt;

  003cd	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  003d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  003d7	0f b7 54 24 5c	 movzx	 edx, WORD PTR nullfmt$[rsp]
  003dc	66 89 54 c1 06	 mov	 WORD PTR [rcx+rax*8+6], dx
  003e1	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  003e6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  003eb	0f b7 54 24 5c	 movzx	 edx, WORD PTR nullfmt$[rsp]
  003f0	66 89 54 c1 04	 mov	 WORD PTR [rcx+rax*8+4], dx
  003f5	eb c2		 jmp	 SHORT $LN2@cckd_read_
$LN3@cckd_read_:
$LN13@cckd_read_:

; 3073 :         CCKD_TRACE( "l2[%d,%d] cache[%d] null fmt[%d]", sfx, L1idx, lru, nullfmt);

  003f7	8b 44 24 5c	 mov	 eax, DWORD PTR nullfmt$[rsp]
  003fb	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  003ff	8b 44 24 50	 mov	 eax, DWORD PTR lru$[rsp]
  00403	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00407	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR L1idx$[rsp]
  0040e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00412	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  00419	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0041d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171107
  00424	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0042c	ba 01 0c 00 00	 mov	 edx, 3073		; 00000c01H
  00431	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171108
  00438	e8 00 00 00 00	 call	 cckd_trace

; 3074 :     }

  0043d	e9 d0 01 00 00	 jmp	 $LN12@cckd_read_
$LN11@cckd_read_:

; 3075 :     else if (cckd->L1tab[sfx][L1idx] == CCKD_MAXSIZE)

  00442	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0044a	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  00452	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00457	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  0045f	83 3c 88 ff	 cmp	 DWORD PTR [rax+rcx*4], -1 ; ffffffffH
  00463	75 54		 jne	 SHORT $LN14@cckd_read_

; 3076 :     {
; 3077 :         memset(buf, 0xff, CCKD_L2TAB_SIZE);

  00465	48 8b 7c 24 68	 mov	 rdi, QWORD PTR buf$[rsp]
  0046a	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0046f	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00474	f3 aa		 rep stosb

; 3078 :         CCKD_TRACE( "l2[%d,%d] cache[%d] null 0xff", sfx, L1idx, lru);

  00476	8b 44 24 50	 mov	 eax, DWORD PTR lru$[rsp]
  0047a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0047e	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR L1idx$[rsp]
  00485	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00489	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  00490	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00494	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171111
  0049b	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  004a3	ba 06 0c 00 00	 mov	 edx, 3078		; 00000c06H
  004a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171112
  004af	e8 00 00 00 00	 call	 cckd_trace

; 3079 :     }

  004b4	e9 59 01 00 00	 jmp	 $LN15@cckd_read_
$LN14@cckd_read_:

; 3080 :     /* Read the new level 2 table */
; 3081 :     else
; 3082 :     {
; 3083 :         off = (off_t)cckd->L1tab[sfx][L1idx];

  004b9	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  004c1	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  004c9	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  004ce	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  004d6	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  004d9	48 89 44 24 70	 mov	 QWORD PTR off$[rsp], rax

; 3084 :         if (cckd_read (dev, sfx, off, buf, CCKD_L2TAB_SIZE) < 0)

  004de	c7 44 24 20 00
	08 00 00	 mov	 DWORD PTR [rsp+32], 2048 ; 00000800H
  004e6	4c 8b 4c 24 68	 mov	 r9, QWORD PTR buf$[rsp]
  004eb	4c 8b 44 24 70	 mov	 r8, QWORD PTR off$[rsp]
  004f0	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  004f7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004ff	e8 00 00 00 00	 call	 cckd_read
  00504	85 c0		 test	 eax, eax
  00506	7d 32		 jge	 SHORT $LN16@cckd_read_

; 3085 :         {
; 3086 :             cache_lock(CACHE_L2);

  00508	b9 01 00 00 00	 mov	 ecx, 1
  0050d	e8 00 00 00 00	 call	 cache_lock

; 3087 :             cache_setflag(CACHE_L2, lru, 0, 0);

  00512	45 33 c9	 xor	 r9d, r9d
  00515	45 33 c0	 xor	 r8d, r8d
  00518	8b 54 24 50	 mov	 edx, DWORD PTR lru$[rsp]
  0051c	b9 01 00 00 00	 mov	 ecx, 1
  00521	e8 00 00 00 00	 call	 cache_setflag

; 3088 :             cache_unlock(CACHE_L2);

  00526	b9 01 00 00 00	 mov	 ecx, 1
  0052b	e8 00 00 00 00	 call	 cache_unlock

; 3089 :             return -1;

  00530	b8 ff ff ff ff	 mov	 eax, -1
  00535	e9 12 01 00 00	 jmp	 $LN1@cckd_read_
$LN16@cckd_read_:

; 3090 :         }
; 3091 : 
; 3092 :         if (cckd->swapend[sfx])

  0053a	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00542	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00547	0f b6 84 01 14
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+276]
  0054f	85 c0		 test	 eax, eax
  00551	74 0a		 je	 SHORT $LN17@cckd_read_

; 3093 :             cckd_swapend_l2 (buf);

  00553	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  00558	e8 00 00 00 00	 call	 cckd_swapend_l2
$LN17@cckd_read_:

; 3094 : 
; 3095 :         CCKD_TRACE( "file[%d] cache[%d] l2[%d] read offset 0x%8.8"PRIx32,

  0055d	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00565	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  0056d	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00572	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  0057a	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0057d	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00581	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR L1idx$[rsp]
  00588	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0058c	8b 44 24 50	 mov	 eax, DWORD PTR lru$[rsp]
  00590	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00594	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  0059b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0059f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171115
  005a6	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  005ae	ba 18 0c 00 00	 mov	 edx, 3096		; 00000c18H
  005b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171116
  005ba	e8 00 00 00 00	 call	 cckd_trace

; 3096 :                     sfx, lru, L1idx, cckd->L1tab[sfx][L1idx]);
; 3097 : 
; 3098 :         cckd->L2_reads[sfx]++;

  005bf	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  005c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  005cc	8b 84 81 4c 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+332]
  005d3	ff c0		 inc	 eax
  005d5	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  005dd	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  005e2	89 84 8a 4c 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+332], eax

; 3099 :         cckd->totl2reads++;

  005e9	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  005ee	8b 80 dc 00 00
	00		 mov	 eax, DWORD PTR [rax+220]
  005f4	ff c0		 inc	 eax
  005f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  005fb	89 81 dc 00 00
	00		 mov	 DWORD PTR [rcx+220], eax

; 3100 :         cckdblk.stats_l2reads++;

  00601	48 8b 05 b8 02
	00 00		 mov	 rax, QWORD PTR cckdblk+696
  00608	48 ff c0	 inc	 rax
  0060b	48 89 05 b8 02
	00 00		 mov	 QWORD PTR cckdblk+696, rax
$LN15@cckd_read_:
$LN12@cckd_read_:

; 3101 :     }
; 3102 : 
; 3103 :     cckd->sfx = sfx;

  00612	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00617	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  0061e	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 3104 :     cckd->L1idx = L1idx;

  00621	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00626	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR L1idx$[rsp]
  0062d	89 48 44	 mov	 DWORD PTR [rax+68], ecx

; 3105 :     cckd->L2tab = buf;

  00630	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00635	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  0063a	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 3106 :     cckd->L2_active = lru;

  0063e	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00643	8b 4c 24 50	 mov	 ecx, DWORD PTR lru$[rsp]
  00647	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 3107 : 
; 3108 :     return 0;

  0064a	33 c0		 xor	 eax, eax
$LN1@cckd_read_:

; 3109 : 
; 3110 : } /* end function cckd_read_l2 */

  0064c	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00653	5f		 pop	 rdi
  00654	c3		 ret	 0
cckd_read_l2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
i$ = 48
cckd$ = 56
sfx$ = 64
fpos$ = 72
j$ = 80
n$ = 84
fsp$ = 88
ppos$ = 96
rc$ = 100
tv197 = 104
dev$ = 128
cckd_write_fsp PROC

; 2908 : {

$LN30:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2909 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 2910 : off_t           fpos;                   /* Free space offset         */
; 2911 : U32             ppos;                   /* Previous free space offset*/
; 2912 : int             sfx;                    /* File index                */
; 2913 : int             i, j, n;                /* Work variables            */
; 2914 : int             rc;                     /* Return code               */
; 2915 : CCKD_FREEBLK   *fsp = NULL;             /* -> new format free space  */

  00009	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR fsp$[rsp], 0

; 2916 : 
; 2917 :     if (dev->cckd64)

  00012	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001a	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00021	24 01		 and	 al, 1
  00023	0f b6 c0	 movzx	 eax, al
  00026	85 c0		 test	 eax, eax
  00028	74 12		 je	 SHORT $LN14@cckd_write

; 2918 :         return cckd64_write_fsp( dev );

  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00032	e8 00 00 00 00	 call	 cckd64_write_fsp
  00037	e9 0a 05 00 00	 jmp	 $LN1@cckd_write
$LN14@cckd_write:

; 2919 : 
; 2920 :     cckd = dev->cckd_ext;

  0003c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00044	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0004b	48 89 44 24 38	 mov	 QWORD PTR cckd$[rsp], rax

; 2921 :     sfx = cckd->sfn;

  00050	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00055	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00058	89 44 24 40	 mov	 DWORD PTR sfx$[rsp], eax

; 2922 : 
; 2923 :     if (!cckd->ifb)

  0005c	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00061	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00066	75 07		 jne	 SHORT $LN15@cckd_write

; 2924 :         return 0;

  00068	33 c0		 xor	 eax, eax
  0006a	e9 d7 04 00 00	 jmp	 $LN1@cckd_write
$LN15@cckd_write:

; 2925 : 
; 2926 :     CCKD_TRACE( "file[%d] write_fsp number %d",

  0006f	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00074	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0007b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00080	8b 84 01 00 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+512]
  00087	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0008b	8b 44 24 40	 mov	 eax, DWORD PTR sfx$[rsp]
  0008f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00093	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171037
  0009a	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000a2	ba 6f 0b 00 00	 mov	 edx, 2927		; 00000b6fH
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171038
  000ae	e8 00 00 00 00	 call	 cckd_trace

; 2927 :                 sfx, cckd->cdevhdr[sfx].free_num);
; 2928 : 
; 2929 :     /* get rid of pending free space */
; 2930 :     for (i = 0; i < CCKD_MAX_FREEPEND; i++)

  000b3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000bb	eb 0a		 jmp	 SHORT $LN4@cckd_write
$LN2@cckd_write:
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000c1	ff c0		 inc	 eax
  000c3	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd_write:
  000c7	83 7c 24 30 04	 cmp	 DWORD PTR i$[rsp], 4
  000cc	7d 0f		 jge	 SHORT $LN3@cckd_write

; 2931 :         cckd_flush_space(dev);

  000ce	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000d6	e8 00 00 00 00	 call	 cckd_flush_space
  000db	eb e0		 jmp	 SHORT $LN2@cckd_write
$LN3@cckd_write:

; 2932 : 
; 2933 :     /* sanity checks */
; 2934 :     if (cckd->cdevhdr[sfx].free_num == 0 || cckd->cdevhdr[sfx].free_off == 0)

  000dd	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000e2	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000e9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000ee	83 bc 01 00 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax+512], 0
  000f6	74 1b		 je	 SHORT $LN17@cckd_write
  000f8	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000fd	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00104	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00109	83 bc 01 f4 01
	00 00 00	 cmp	 DWORD PTR [rcx+rax+500], 0
  00111	75 62		 jne	 SHORT $LN16@cckd_write
$LN17@cckd_write:

; 2935 :     {
; 2936 :         cckd->cdevhdr[sfx].free_num = cckd->cdevhdr[sfx].free_off = 0;

  00113	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00118	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0011f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00124	c7 84 01 f4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+500], 0
  0012f	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00134	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0013b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00140	c7 84 01 00 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+512], 0

; 2937 :         cckd->free_idx1st = cckd->free_idxlast = cckd->free_idxavail = -1;

  0014b	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00150	c7 80 84 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+132], -1
  0015a	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0015f	c7 80 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+128], -1
  00169	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0016e	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1
$LN16@cckd_write:

; 2938 :     }
; 2939 : 
; 2940 :     /* Write any free spaces */
; 2941 :     if (cckd->cdevhdr[sfx].free_off)

  00175	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0017a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00181	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00186	83 bc 01 f4 01
	00 00 00	 cmp	 DWORD PTR [rcx+rax+500], 0
  0018e	0f 84 54 03 00
	00		 je	 $LN18@cckd_write

; 2942 :     {
; 2943 :         /* size needed for new format free space */
; 2944 :         n = (cckd->cdevhdr[sfx].free_num+1) * CCKD_FREEBLK_SIZE;

  00194	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00199	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  001a5	8b 84 01 00 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+512]
  001ac	ff c0		 inc	 eax
  001ae	48 98		 cdqe
  001b0	48 c1 e0 03	 shl	 rax, 3
  001b4	89 44 24 54	 mov	 DWORD PTR n$[rsp], eax

; 2945 : 
; 2946 :         /* look for existing free space to fit new format free space */
; 2947 :         fpos = 0;

  001b8	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR fpos$[rsp], 0

; 2948 :         for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  001c1	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  001c6	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  001c9	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  001cd	eb 1a		 jmp	 SHORT $LN7@cckd_write
$LN5@cckd_write:
  001cf	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  001d4	48 6b c0 14	 imul	 rax, rax, 20
  001d8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  001dd	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  001e1	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  001e5	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@cckd_write:
  001e9	83 7c 24 30 00	 cmp	 DWORD PTR i$[rsp], 0
  001ee	7c 20		 jl	 SHORT $LN6@cckd_write

; 2949 :             if (n <= (int)cckd->ifb[i].ifb_len)

  001f0	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  001f5	48 6b c0 14	 imul	 rax, rax, 20
  001f9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  001fe	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00202	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00206	39 44 24 54	 cmp	 DWORD PTR n$[rsp], eax
  0020a	7f 02		 jg	 SHORT $LN19@cckd_write

; 2950 :                 break;

  0020c	eb 02		 jmp	 SHORT $LN6@cckd_write
$LN19@cckd_write:
  0020e	eb bf		 jmp	 SHORT $LN5@cckd_write
$LN6@cckd_write:

; 2951 :         if (i >= 0)

  00210	83 7c 24 30 00	 cmp	 DWORD PTR i$[rsp], 0
  00215	7c 6e		 jl	 SHORT $LN20@cckd_write

; 2952 :             fpos = cckd->ifb[i].ifb_idxprv < 0

  00217	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0021c	48 6b c0 14	 imul	 rax, rax, 20
  00220	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00225	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00229	83 7c 01 08 00	 cmp	 DWORD PTR [rcx+rax+8], 0
  0022e	7d 1f		 jge	 SHORT $LN28@cckd_write
  00230	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00235	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0023c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00241	8b 84 01 f4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+500]
  00248	48 89 44 24 68	 mov	 QWORD PTR tv197[rsp], rax
  0024d	eb 2c		 jmp	 SHORT $LN29@cckd_write
$LN28@cckd_write:
  0024f	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00254	48 6b c0 14	 imul	 rax, rax, 20
  00258	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0025d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00261	48 63 44 01 08	 movsxd	 rax, DWORD PTR [rcx+rax+8]
  00266	48 6b c0 14	 imul	 rax, rax, 20
  0026a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0026f	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00273	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00276	48 89 44 24 68	 mov	 QWORD PTR tv197[rsp], rax
$LN29@cckd_write:
  0027b	48 8b 44 24 68	 mov	 rax, QWORD PTR tv197[rsp]
  00280	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax
$LN20@cckd_write:

; 2953 :                  ? (off_t)cckd->cdevhdr[sfx].free_off
; 2954 :                  : (off_t)cckd->ifb[cckd->ifb[i].ifb_idxprv].ifb_offnxt;
; 2955 : 
; 2956 :         /* if no applicable space see if we can append to the file */
; 2957 :         if (fpos == 0 && (cckd->cckd_maxsize - cckd->cdevhdr[sfx].cdh_size) >= (U64)n)

  00285	48 83 7c 24 48
	00		 cmp	 QWORD PTR fpos$[rsp], 0
  0028b	75 4e		 jne	 SHORT $LN21@cckd_write
  0028d	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00292	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00299	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0029e	8b 84 01 ec 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+492]
  002a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  002aa	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  002ae	48 2b c8	 sub	 rcx, rax
  002b1	48 8b c1	 mov	 rax, rcx
  002b4	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR n$[rsp]
  002b9	48 3b c1	 cmp	 rax, rcx
  002bc	72 1d		 jb	 SHORT $LN21@cckd_write

; 2958 :             fpos = (off_t)cckd->cdevhdr[sfx].cdh_size;

  002be	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  002c3	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  002ca	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  002cf	8b 84 01 ec 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+492]
  002d6	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax
$LN21@cckd_write:

; 2959 : 
; 2960 :         if (fpos && (fsp = cckd_malloc (dev, "fsp", n)) == NULL)

  002db	48 83 7c 24 48
	00		 cmp	 QWORD PTR fpos$[rsp], 0
  002e1	74 32		 je	 SHORT $LN22@cckd_write
  002e3	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  002e8	4c 8b c0	 mov	 r8, rax
  002eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171046
  002f2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002fa	e8 00 00 00 00	 call	 cckd_malloc
  002ff	48 89 44 24 58	 mov	 QWORD PTR fsp$[rsp], rax
  00304	48 83 7c 24 58
	00		 cmp	 QWORD PTR fsp$[rsp], 0
  0030a	75 09		 jne	 SHORT $LN22@cckd_write

; 2961 :             fpos = 0;

  0030c	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR fpos$[rsp], 0
$LN22@cckd_write:

; 2962 : 
; 2963 :         if (fpos)

  00315	48 83 7c 24 48
	00		 cmp	 QWORD PTR fpos$[rsp], 0
  0031b	0f 84 3e 01 00
	00		 je	 $LN23@cckd_write

; 2964 :         {
; 2965 :             /* New format free space */
; 2966 :             memcpy (&fsp[0], "FREE_BLK", 8);

  00321	b8 08 00 00 00	 mov	 eax, 8
  00326	48 6b c0 00	 imul	 rax, rax, 0
  0032a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR fsp$[rsp]
  0032f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR $SG171049
  00336	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 2967 :             ppos = cckd->cdevhdr[sfx].free_off;

  0033a	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0033f	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00346	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0034b	8b 84 01 f4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+500]
  00352	89 44 24 60	 mov	 DWORD PTR ppos$[rsp], eax

; 2968 :             for (i = cckd->free_idx1st, j = 1; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  00356	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0035b	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  0035e	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00362	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR j$[rsp], 1
  0036a	eb 1a		 jmp	 SHORT $LN10@cckd_write
$LN8@cckd_write:
  0036c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00371	48 6b c0 14	 imul	 rax, rax, 20
  00375	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0037a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0037e	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  00382	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@cckd_write:
  00386	83 7c 24 30 00	 cmp	 DWORD PTR i$[rsp], 0
  0038b	7c 5b		 jl	 SHORT $LN9@cckd_write

; 2969 :             {
; 2970 :                 fsp[j].fb_offnxt = ppos;

  0038d	48 63 44 24 50	 movsxd	 rax, DWORD PTR j$[rsp]
  00392	48 8b 4c 24 58	 mov	 rcx, QWORD PTR fsp$[rsp]
  00397	8b 54 24 60	 mov	 edx, DWORD PTR ppos$[rsp]
  0039b	89 14 c1	 mov	 DWORD PTR [rcx+rax*8], edx

; 2971 :                 fsp[j++].fb_len = cckd->ifb[i].ifb_len;

  0039e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  003a3	48 6b c0 14	 imul	 rax, rax, 20
  003a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  003ac	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003b0	48 63 54 24 50	 movsxd	 rdx, DWORD PTR j$[rsp]
  003b5	4c 8b 44 24 58	 mov	 r8, QWORD PTR fsp$[rsp]
  003ba	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  003be	41 89 44 d0 04	 mov	 DWORD PTR [r8+rdx*8+4], eax
  003c3	8b 44 24 50	 mov	 eax, DWORD PTR j$[rsp]
  003c7	ff c0		 inc	 eax
  003c9	89 44 24 50	 mov	 DWORD PTR j$[rsp], eax

; 2972 :                 ppos = cckd->ifb[i].ifb_offnxt;

  003cd	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  003d2	48 6b c0 14	 imul	 rax, rax, 20
  003d6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  003db	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003df	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  003e2	89 44 24 60	 mov	 DWORD PTR ppos$[rsp], eax

; 2973 :             }

  003e6	eb 84		 jmp	 SHORT $LN8@cckd_write
$LN9@cckd_write:

; 2974 :             rc = cckd_write (dev, sfx, fpos, fsp, n);

  003e8	8b 44 24 54	 mov	 eax, DWORD PTR n$[rsp]
  003ec	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003f0	4c 8b 4c 24 58	 mov	 r9, QWORD PTR fsp$[rsp]
  003f5	4c 8b 44 24 48	 mov	 r8, QWORD PTR fpos$[rsp]
  003fa	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  003fe	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00406	e8 00 00 00 00	 call	 cckd_write
  0040b	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 2975 :             fsp = cckd_free (dev, "fsp", fsp);

  0040f	4c 8b 44 24 58	 mov	 r8, QWORD PTR fsp$[rsp]
  00414	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171050
  0041b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00423	e8 00 00 00 00	 call	 cckd_free
  00428	48 89 44 24 58	 mov	 QWORD PTR fsp$[rsp], rax

; 2976 :             if (rc < 0)

  0042d	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  00432	7d 0a		 jge	 SHORT $LN25@cckd_write

; 2977 :                 return -1;

  00434	b8 ff ff ff ff	 mov	 eax, -1
  00439	e9 08 01 00 00	 jmp	 $LN1@cckd_write
$LN25@cckd_write:

; 2978 :             cckd->cdevhdr[sfx].free_off = (U32)fpos;

  0043e	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00443	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0044a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0044f	8b 54 24 48	 mov	 edx, DWORD PTR fpos$[rsp]
  00453	89 94 01 f4 01
	00 00		 mov	 DWORD PTR [rcx+rax+500], edx

; 2979 :         } /* new format free space */

  0045a	e9 89 00 00 00	 jmp	 $LN24@cckd_write
$LN23@cckd_write:

; 2980 :         else
; 2981 :         {
; 2982 :             /* Old format free space */
; 2983 :             for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  0045f	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00464	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00467	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  0046b	eb 1a		 jmp	 SHORT $LN13@cckd_write
$LN11@cckd_write:
  0046d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00472	48 6b c0 14	 imul	 rax, rax, 20
  00476	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0047b	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0047f	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  00483	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@cckd_write:
  00487	83 7c 24 30 00	 cmp	 DWORD PTR i$[rsp], 0
  0048c	7c 5a		 jl	 SHORT $LN12@cckd_write

; 2984 :             {
; 2985 :                 if (cckd_write (dev, sfx, fpos, &cckd->ifb[i], CCKD_FREEBLK_SIZE) < 0)

  0048e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00493	48 6b c0 14	 imul	 rax, rax, 20
  00497	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0049c	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  004a0	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  004a8	4c 8b c8	 mov	 r9, rax
  004ab	4c 8b 44 24 48	 mov	 r8, QWORD PTR fpos$[rsp]
  004b0	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  004b4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004bc	e8 00 00 00 00	 call	 cckd_write
  004c1	85 c0		 test	 eax, eax
  004c3	7d 07		 jge	 SHORT $LN26@cckd_write

; 2986 :                     return -1;

  004c5	b8 ff ff ff ff	 mov	 eax, -1
  004ca	eb 7a		 jmp	 SHORT $LN1@cckd_write
$LN26@cckd_write:

; 2987 :                 fpos = (off_t)cckd->ifb[i].ifb_offnxt;

  004cc	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  004d1	48 6b c0 14	 imul	 rax, rax, 20
  004d5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  004da	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004de	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  004e1	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax

; 2988 :             }

  004e6	eb 85		 jmp	 SHORT $LN11@cckd_write
$LN12@cckd_write:
$LN24@cckd_write:
$LN18@cckd_write:

; 2989 :         } /* old format free space */
; 2990 :     } /* if (cckd->cdevhdr[sfx].free_off) */
; 2991 : 
; 2992 :     /* Free the free space array */
; 2993 :     cckd->ifb = cckd_free (dev, "ifb", cckd->ifb);

  004e8	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  004ed	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  004f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171053
  004f8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00500	e8 00 00 00 00	 call	 cckd_free
  00505	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0050a	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 2994 :     cckd->free_count = 0;

  0050e	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00513	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [rax+120], 0

; 2995 :     cckd->free_idx1st = cckd->free_idxlast = cckd->free_idxavail = -1;

  0051a	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0051f	c7 80 84 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+132], -1
  00529	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0052e	c7 80 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+128], -1
  00538	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0053d	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1

; 2996 : 
; 2997 :     return 0;

  00544	33 c0		 xor	 eax, eax
$LN1@cckd_write:

; 2998 : 
; 2999 : } /* end function cckd_write_fsp */

  00546	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0054a	c3		 ret	 0
cckd_write_fsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
i$ = 48
cckd$ = 56
sfx$ = 64
fpos$ = 72
fsp$1 = 80
tv139 = 88
n$2 = 92
tv369 = 96
ofree$3 = 100
tv141 = 104
freeblk$ = 112
dev$ = 144
cckd_read_fsp PROC

; 2797 : {

$LN29:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2798 : CCKD_EXT*       cckd;                   /* -> cckd extension         */
; 2799 : off_t           fpos;                   /* Free space offset         */
; 2800 : int             sfx;                    /* File index                */
; 2801 : int             i;                      /* Index                     */
; 2802 : CCKD_FREEBLK    freeblk;                /* First freeblk read        */
; 2803 : 
; 2804 :     if (dev->cckd64)

  0000c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00014	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0001b	24 01		 and	 al, 1
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 12		 je	 SHORT $LN11@cckd_read_

; 2805 :         return cckd64_read_fsp( dev );

  00024	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 cckd64_read_fsp
  00031	e9 71 06 00 00	 jmp	 $LN1@cckd_read_
$LN11@cckd_read_:

; 2806 : 
; 2807 :     cckd = dev->cckd_ext;

  00036	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003e	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00045	48 89 44 24 38	 mov	 QWORD PTR cckd$[rsp], rax

; 2808 :     sfx = cckd->sfn;

  0004a	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0004f	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00052	89 44 24 40	 mov	 DWORD PTR sfx$[rsp], eax

; 2809 : 
; 2810 :     CCKD_TRACE( "file[%d] read_fsp number %d",

  00056	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0005b	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00062	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00067	8b 84 01 00 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+512]
  0006e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00072	8b 44 24 40	 mov	 eax, DWORD PTR sfx$[rsp]
  00076	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0007a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170979
  00081	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00089	ba fb 0a 00 00	 mov	 edx, 2811		; 00000afbH
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170980
  00095	e8 00 00 00 00	 call	 cckd_trace

; 2811 :                 sfx, cckd->cdevhdr[sfx].free_num );
; 2812 : 
; 2813 :     cckd->ifb = cckd_free( dev, "ifb", cckd->ifb );

  0009a	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0009f	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170981
  000aa	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000b2	e8 00 00 00 00	 call	 cckd_free
  000b7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000bc	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 2814 : 
; 2815 :     cckd->free_count    =  0;

  000c0	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  000c5	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [rax+120], 0

; 2816 :     cckd->free_idx1st   = -1;

  000cc	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  000d1	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1

; 2817 :     cckd->free_idxlast  = -1;

  000d8	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  000dd	c7 80 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+128], -1

; 2818 :     cckd->free_idxavail = -1;

  000e7	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  000ec	c7 80 84 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+132], -1

; 2819 : 
; 2820 :     /* Get storage for the internal free space chain
; 2821 :      * in a multiple of 1024 entries
; 2822 :      */
; 2823 :     i = (int) ROUND_UP( cckd->cdevhdr[sfx].free_num, CCKD_IFB_ENTS_INCR );

  000f6	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000fb	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00102	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00107	83 bc 01 00 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax+512], 0
  0010f	74 35		 je	 SHORT $LN25@cckd_read_
  00111	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00116	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0011d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00122	8b 84 01 00 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+512]
  00129	05 ff 03 00 00	 add	 eax, 1023		; 000003ffH
  0012e	99		 cdq
  0012f	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  00135	03 c2		 add	 eax, edx
  00137	c1 f8 0a	 sar	 eax, 10
  0013a	69 c0 00 04 00
	00		 imul	 eax, eax, 1024		; 00000400H
  00140	89 44 24 58	 mov	 DWORD PTR tv139[rsp], eax
  00144	eb 08		 jmp	 SHORT $LN26@cckd_read_
$LN25@cckd_read_:
  00146	c7 44 24 58 00
	04 00 00	 mov	 DWORD PTR tv139[rsp], 1024 ; 00000400H
$LN26@cckd_read_:
  0014e	8b 44 24 58	 mov	 eax, DWORD PTR tv139[rsp]
  00152	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax

; 2824 :     if (!(cckd->ifb = cckd_calloc( dev, "ifb", i, CCKD_IFREEBLK_SIZE )))

  00156	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0015b	41 b9 14 00 00
	00		 mov	 r9d, 20
  00161	4c 8b c0	 mov	 r8, rax
  00164	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170983
  0016b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00173	e8 00 00 00 00	 call	 cckd_calloc
  00178	48 89 44 24 68	 mov	 QWORD PTR tv141[rsp], rax
  0017d	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00182	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv141[rsp]
  00187	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
  0018b	48 83 7c 24 68
	00		 cmp	 QWORD PTR tv141[rsp], 0
  00191	75 0a		 jne	 SHORT $LN12@cckd_read_

; 2825 :         return -1;

  00193	b8 ff ff ff ff	 mov	 eax, -1
  00198	e9 0a 05 00 00	 jmp	 $LN1@cckd_read_
$LN12@cckd_read_:

; 2826 : 
; 2827 :     cckd->free_count = i;

  0019d	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  001a2	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  001a6	89 48 78	 mov	 DWORD PTR [rax+120], ecx

; 2828 : 
; 2829 :     /* Build the doubly linked internal free space chain */
; 2830 :     if (cckd->cdevhdr[sfx].free_num)

  001a9	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001ae	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001b5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ba	83 bc 01 00 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax+512], 0
  001c2	0f 84 ea 03 00
	00		 je	 $LN13@cckd_read_

; 2831 :     {
; 2832 :         cckd->free_idx1st = 0;

  001c8	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  001cd	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0

; 2833 : 
; 2834 :         /* Read the first freeblk to determine old/new format */
; 2835 :         fpos = (off_t)cckd->cdevhdr[sfx].free_off;

  001d4	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001d9	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001e0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  001e5	8b 84 01 f4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+500]
  001ec	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax

; 2836 :         if (cckd_read (dev, sfx, fpos, &freeblk, CCKD_FREEBLK_SIZE) < 0)

  001f1	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  001f9	4c 8d 4c 24 70	 lea	 r9, QWORD PTR freeblk$[rsp]
  001fe	4c 8b 44 24 48	 mov	 r8, QWORD PTR fpos$[rsp]
  00203	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  00207	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0020f	e8 00 00 00 00	 call	 cckd_read
  00214	85 c0		 test	 eax, eax
  00216	7d 0a		 jge	 SHORT $LN14@cckd_read_

; 2837 :             return -1;

  00218	b8 ff ff ff ff	 mov	 eax, -1
  0021d	e9 85 04 00 00	 jmp	 $LN1@cckd_read_
$LN14@cckd_read_:

; 2838 : 
; 2839 :         if (memcmp(&freeblk, "FREE_BLK", 8) == 0)

  00222	41 b8 08 00 00
	00		 mov	 r8d, 8
  00228	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170988
  0022f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR freeblk$[rsp]
  00234	e8 00 00 00 00	 call	 memcmp
  00239	85 c0		 test	 eax, eax
  0023b	0f 85 58 02 00
	00		 jne	 $LN15@cckd_read_

; 2840 :         {
; 2841 :             /* new format free space */
; 2842 :             CCKD_FREEBLK *fsp;
; 2843 :             U32 ofree = cckd->cdevhdr[sfx].free_off;

  00241	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00246	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0024d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00252	8b 84 01 f4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+500]
  00259	89 44 24 64	 mov	 DWORD PTR ofree$3[rsp], eax

; 2844 :             int n = cckd->cdevhdr[sfx].free_num * CCKD_FREEBLK_SIZE;

  0025d	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00262	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00269	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0026e	48 63 84 01 00
	02 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+512]
  00276	48 c1 e0 03	 shl	 rax, 3
  0027a	89 44 24 5c	 mov	 DWORD PTR n$2[rsp], eax

; 2845 :             if ((fsp = cckd_malloc (dev, "fsp", n)) == NULL)

  0027e	48 63 44 24 5c	 movsxd	 rax, DWORD PTR n$2[rsp]
  00283	4c 8b c0	 mov	 r8, rax
  00286	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170990
  0028d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00295	e8 00 00 00 00	 call	 cckd_malloc
  0029a	48 89 44 24 50	 mov	 QWORD PTR fsp$1[rsp], rax
  0029f	48 83 7c 24 50
	00		 cmp	 QWORD PTR fsp$1[rsp], 0
  002a5	75 0a		 jne	 SHORT $LN17@cckd_read_

; 2846 :                 return -1;

  002a7	b8 ff ff ff ff	 mov	 eax, -1
  002ac	e9 f6 03 00 00	 jmp	 $LN1@cckd_read_
$LN17@cckd_read_:

; 2847 :             fpos += CCKD_FREEBLK_SIZE;

  002b1	48 8b 44 24 48	 mov	 rax, QWORD PTR fpos$[rsp]
  002b6	48 83 c0 08	 add	 rax, 8
  002ba	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax

; 2848 :             if (cckd_read (dev, sfx, fpos, fsp, n) < 0)

  002bf	8b 44 24 5c	 mov	 eax, DWORD PTR n$2[rsp]
  002c3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002c7	4c 8b 4c 24 50	 mov	 r9, QWORD PTR fsp$1[rsp]
  002cc	4c 8b 44 24 48	 mov	 r8, QWORD PTR fpos$[rsp]
  002d1	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  002d5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002dd	e8 00 00 00 00	 call	 cckd_read
  002e2	85 c0		 test	 eax, eax
  002e4	7d 0a		 jge	 SHORT $LN18@cckd_read_

; 2849 :                 return -1;

  002e6	b8 ff ff ff ff	 mov	 eax, -1
  002eb	e9 b7 03 00 00	 jmp	 $LN1@cckd_read_
$LN18@cckd_read_:

; 2850 :             for (i = 0; i < cckd->cdevhdr[sfx].free_num; i++)

  002f0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002f8	eb 0a		 jmp	 SHORT $LN4@cckd_read_
$LN2@cckd_read_:
  002fa	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  002fe	ff c0		 inc	 eax
  00300	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd_read_:
  00304	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00309	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00310	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00315	8b 84 01 00 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+512]
  0031c	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00320	0f 8d d1 00 00
	00		 jge	 $LN3@cckd_read_

; 2851 :             {
; 2852 :                 if (i == 0)

  00326	83 7c 24 30 00	 cmp	 DWORD PTR i$[rsp], 0
  0032b	75 28		 jne	 SHORT $LN19@cckd_read_

; 2853 :                     cckd->cdevhdr[sfx].free_off = fsp[i].fb_offnxt;

  0032d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00332	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00337	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  0033e	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  00343	4c 8b 44 24 50	 mov	 r8, QWORD PTR fsp$1[rsp]
  00348	41 8b 04 c0	 mov	 eax, DWORD PTR [r8+rax*8]
  0034c	89 84 0a f4 01
	00 00		 mov	 DWORD PTR [rdx+rcx+500], eax
  00353	eb 27		 jmp	 SHORT $LN20@cckd_read_
$LN19@cckd_read_:

; 2854 :                 else
; 2855 :                     cckd->ifb[i-1].ifb_offnxt = fsp[i].fb_offnxt;

  00355	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0035a	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  0035e	ff c9		 dec	 ecx
  00360	48 63 c9	 movsxd	 rcx, ecx
  00363	48 6b c9 14	 imul	 rcx, rcx, 20
  00367	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  0036c	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00370	4c 8b 44 24 50	 mov	 r8, QWORD PTR fsp$1[rsp]
  00375	41 8b 04 c0	 mov	 eax, DWORD PTR [r8+rax*8]
  00379	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax
$LN20@cckd_read_:

; 2856 :                 cckd->ifb[i].ifb_offnxt  = 0;

  0037c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00381	48 6b c0 14	 imul	 rax, rax, 20
  00385	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0038a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0038e	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [rcx+rax], 0

; 2857 :                 cckd->ifb[i].ifb_len  = fsp[i].fb_len;

  00395	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0039a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0039f	48 6b c9 14	 imul	 rcx, rcx, 20
  003a3	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  003a8	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  003ac	4c 8b 44 24 50	 mov	 r8, QWORD PTR fsp$1[rsp]
  003b1	41 8b 44 c0 04	 mov	 eax, DWORD PTR [r8+rax*8+4]
  003b6	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax

; 2858 :                 cckd->ifb[i].ifb_idxprv = i - 1;

  003ba	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  003be	ff c8		 dec	 eax
  003c0	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003c5	48 6b c9 14	 imul	 rcx, rcx, 20
  003c9	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  003ce	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  003d2	89 44 0a 08	 mov	 DWORD PTR [rdx+rcx+8], eax

; 2859 :                 cckd->ifb[i].ifb_idxnxt = i + 1;

  003d6	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  003da	ff c0		 inc	 eax
  003dc	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003e1	48 6b c9 14	 imul	 rcx, rcx, 20
  003e5	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  003ea	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  003ee	89 44 0a 0c	 mov	 DWORD PTR [rdx+rcx+12], eax

; 2860 :             }

  003f2	e9 03 ff ff ff	 jmp	 $LN2@cckd_read_
$LN3@cckd_read_:

; 2861 :             cckd->ifb[i-1].ifb_idxnxt = -1;

  003f7	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  003fb	ff c8		 dec	 eax
  003fd	48 98		 cdqe
  003ff	48 6b c0 14	 imul	 rax, rax, 20
  00403	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00408	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0040c	c7 44 01 0c ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+12], -1

; 2862 :             cckd->free_idxlast = i-1;

  00414	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00418	ff c8		 dec	 eax
  0041a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0041f	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 2863 :             fsp = cckd_free (dev, "fsp", fsp);

  00425	4c 8b 44 24 50	 mov	 r8, QWORD PTR fsp$1[rsp]
  0042a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170994
  00431	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00439	e8 00 00 00 00	 call	 cckd_free
  0043e	48 89 44 24 50	 mov	 QWORD PTR fsp$1[rsp], rax

; 2864 : 
; 2865 :             /* truncate if new format free space was at the end */
; 2866 :             if (ofree == cckd->cdevhdr[sfx].cdh_size)

  00443	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00448	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0044f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00454	8b 84 01 ec 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+492]
  0045b	39 44 24 64	 cmp	 DWORD PTR ofree$3[rsp], eax
  0045f	75 33		 jne	 SHORT $LN21@cckd_read_

; 2867 :             {
; 2868 :                 fpos = (off_t)cckd->cdevhdr[sfx].cdh_size;

  00461	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00466	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0046d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00472	8b 84 01 ec 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+492]
  00479	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax

; 2869 :                 cckd_ftruncate(dev, sfx, fpos);

  0047e	4c 8b 44 24 48	 mov	 r8, QWORD PTR fpos$[rsp]
  00483	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  00487	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0048f	e8 00 00 00 00	 call	 cckd_ftruncate
$LN21@cckd_read_:

; 2870 :             }
; 2871 :         } /* new format free space */

  00494	e9 19 01 00 00	 jmp	 $LN16@cckd_read_
$LN15@cckd_read_:

; 2872 :         else
; 2873 :         {
; 2874 :             /* old format free space */
; 2875 :             fpos = (off_t)cckd->cdevhdr[sfx].free_off;

  00499	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0049e	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004a5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  004aa	8b 84 01 f4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+500]
  004b1	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax

; 2876 :             for (i = 0; i < cckd->cdevhdr[sfx].free_num; i++)

  004b6	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004be	eb 0a		 jmp	 SHORT $LN7@cckd_read_
$LN5@cckd_read_:
  004c0	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004c4	ff c0		 inc	 eax
  004c6	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@cckd_read_:
  004ca	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  004cf	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004d6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  004db	8b 84 01 00 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+512]
  004e2	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  004e6	0f 8d 98 00 00
	00		 jge	 $LN6@cckd_read_

; 2877 :             {
; 2878 :                 if (cckd_read (dev, sfx, fpos, &cckd->ifb[i], CCKD_FREEBLK_SIZE) < 0)

  004ec	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  004f1	48 6b c0 14	 imul	 rax, rax, 20
  004f5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  004fa	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  004fe	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  00506	4c 8b c8	 mov	 r9, rax
  00509	4c 8b 44 24 48	 mov	 r8, QWORD PTR fpos$[rsp]
  0050e	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  00512	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0051a	e8 00 00 00 00	 call	 cckd_read
  0051f	85 c0		 test	 eax, eax
  00521	7d 0a		 jge	 SHORT $LN22@cckd_read_

; 2879 :                     return -1;

  00523	b8 ff ff ff ff	 mov	 eax, -1
  00528	e9 7a 01 00 00	 jmp	 $LN1@cckd_read_
$LN22@cckd_read_:

; 2880 :                 cckd->ifb[i].ifb_idxprv = i - 1;

  0052d	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00531	ff c8		 dec	 eax
  00533	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00538	48 6b c9 14	 imul	 rcx, rcx, 20
  0053c	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  00541	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00545	89 44 0a 08	 mov	 DWORD PTR [rdx+rcx+8], eax

; 2881 :                 cckd->ifb[i].ifb_idxnxt = i + 1;

  00549	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0054d	ff c0		 inc	 eax
  0054f	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00554	48 6b c9 14	 imul	 rcx, rcx, 20
  00558	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  0055d	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00561	89 44 0a 0c	 mov	 DWORD PTR [rdx+rcx+12], eax

; 2882 :                 fpos = (off_t)cckd->ifb[i].ifb_offnxt;

  00565	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0056a	48 6b c0 14	 imul	 rax, rax, 20
  0056e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00573	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00577	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0057a	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax

; 2883 :             }

  0057f	e9 3c ff ff ff	 jmp	 $LN5@cckd_read_
$LN6@cckd_read_:

; 2884 :             cckd->ifb[i-1].ifb_idxnxt = -1;

  00584	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00588	ff c8		 dec	 eax
  0058a	48 98		 cdqe
  0058c	48 6b c0 14	 imul	 rax, rax, 20
  00590	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00595	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00599	c7 44 01 0c ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+12], -1

; 2885 :             cckd->free_idxlast = i-1;

  005a1	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005a5	ff c8		 dec	 eax
  005a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  005ac	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax
$LN16@cckd_read_:
$LN13@cckd_read_:

; 2886 :         } /* old format free space */
; 2887 :     } /* if (cckd->cdevhdr[sfx].free_num) */
; 2888 : 
; 2889 :     /* Build singly linked chain of available free space entries */
; 2890 :     if (cckd->cdevhdr[sfx].free_num < cckd->free_count)

  005b2	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  005b7	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  005be	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  005c3	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  005c8	8b 52 78	 mov	 edx, DWORD PTR [rdx+120]
  005cb	39 94 01 00 02
	00 00		 cmp	 DWORD PTR [rcx+rax+512], edx
  005d2	0f 8d 87 00 00
	00		 jge	 $LN23@cckd_read_

; 2891 :     {
; 2892 :         cckd->free_idxavail = cckd->cdevhdr[sfx].free_num;

  005d8	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  005dd	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  005e4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  005e9	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  005ee	8b 84 02 00 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax+512]
  005f5	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax

; 2893 :         for (i = cckd->free_idxavail; i < cckd->free_count; i++)

  005fb	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00600	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00606	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  0060a	eb 0a		 jmp	 SHORT $LN10@cckd_read_
$LN8@cckd_read_:
  0060c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00610	ff c0		 inc	 eax
  00612	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@cckd_read_:
  00616	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0061b	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  0061e	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00622	7d 1e		 jge	 SHORT $LN9@cckd_read_

; 2894 :             cckd->ifb[i].ifb_idxnxt = i + 1;

  00624	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00628	ff c0		 inc	 eax
  0062a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0062f	48 6b c9 14	 imul	 rcx, rcx, 20
  00633	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  00638	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0063c	89 44 0a 0c	 mov	 DWORD PTR [rdx+rcx+12], eax
  00640	eb ca		 jmp	 SHORT $LN8@cckd_read_
$LN9@cckd_read_:

; 2895 :         cckd->ifb[i-1].ifb_idxnxt = -1;

  00642	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00646	ff c8		 dec	 eax
  00648	48 98		 cdqe
  0064a	48 6b c0 14	 imul	 rax, rax, 20
  0064e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00653	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00657	c7 44 01 0c ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+12], -1
$LN23@cckd_read_:

; 2896 :     }
; 2897 : 
; 2898 :     /* Set minimum free space size */
; 2899 :     cckd->free_minsize = CCKD_MIN_FREESIZE( cckd->free_count );

  0065f	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00664	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  00667	83 c0 60	 add	 eax, 96			; 00000060H
  0066a	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0066f	7d 0a		 jge	 SHORT $LN27@cckd_read_
  00671	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv369[rsp], 0
  00679	eb 1b		 jmp	 SHORT $LN28@cckd_read_
$LN27@cckd_read_:
  0067b	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00680	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  00683	99		 cdq
  00684	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  0068a	03 c2		 add	 eax, edx
  0068c	c1 f8 0a	 sar	 eax, 10
  0068f	6b c0 20	 imul	 eax, eax, 32		; 00000020H
  00692	89 44 24 60	 mov	 DWORD PTR tv369[rsp], eax
$LN28@cckd_read_:
  00696	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0069b	8b 4c 24 60	 mov	 ecx, DWORD PTR tv369[rsp]
  0069f	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx

; 2900 :     return 0;

  006a5	33 c0		 xor	 eax, eax
$LN1@cckd_read_:

; 2901 : 
; 2902 : } /* end function cckd_read_fsp */

  006a7	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  006ae	c3		 ret	 0
cckd_read_fsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
sfx$ = 96
imgtyp$ = 100
cckd$ = 104
tv152 = 112
tv158 = 116
tv144 = 120
devhdr$ = 128
__$ArrayPad$ = 640
dev$ = 672
cckd_read_init PROC

; 2748 : {

$LN18:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 02
	00 00		 sub	 rsp, 664		; 00000298H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2749 :     CCKD_EXT*       cckd;               /* -> cckd extension         */
; 2750 :     int             sfx;                /* File index                */
; 2751 :     CKD_DEVHDR      devhdr;             /* Device header             */
; 2752 :     U32             imgtyp;             /* Dasd device image type    */
; 2753 : 
; 2754 :     if (dev->cckd64)

  0001e	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0002d	24 01		 and	 al, 1
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	74 12		 je	 SHORT $LN2@cckd_read_

; 2755 :         return cckd64_read_init( dev );

  00036	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0003e	e8 00 00 00 00	 call	 cckd64_read_init
  00043	e9 42 02 00 00	 jmp	 $LN1@cckd_read_
$LN2@cckd_read_:

; 2756 : 
; 2757 :     cckd = dev->cckd_ext;

  00048	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00050	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00057	48 89 44 24 68	 mov	 QWORD PTR cckd$[rsp], rax

; 2758 :     sfx  = cckd->sfn;

  0005c	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00061	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00064	89 44 24 60	 mov	 DWORD PTR sfx$[rsp], eax

; 2759 : 
; 2760 :     CCKD_TRACE( "file[%d] read_init", sfx );

  00068	8b 44 24 60	 mov	 eax, DWORD PTR sfx$[rsp]
  0006c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00070	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170926
  00077	4c 8b 84 24 a0
	02 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0007f	ba c8 0a 00 00	 mov	 edx, 2760		; 00000ac8H
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170927
  0008b	e8 00 00 00 00	 call	 cckd_trace

; 2761 : 
; 2762 :     /* Read the device header */
; 2763 :     if (cckd_read( dev, sfx, 0, &devhdr, CKD_DEVHDR_SIZE ) < 0)

  00090	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  00098	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR devhdr$[rsp]
  000a0	45 33 c0	 xor	 r8d, r8d
  000a3	8b 54 24 60	 mov	 edx, DWORD PTR sfx$[rsp]
  000a7	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000af	e8 00 00 00 00	 call	 cckd_read
  000b4	85 c0		 test	 eax, eax
  000b6	7d 0a		 jge	 SHORT $LN3@cckd_read_

; 2764 :         return -1;

  000b8	b8 ff ff ff ff	 mov	 eax, -1
  000bd	e9 c8 01 00 00	 jmp	 $LN1@cckd_read_
$LN3@cckd_read_:

; 2765 : 
; 2766 :     /* Check the device hdr */
; 2767 :     imgtyp = dh_devid_typ( devhdr.dh_devid );

  000c2	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  000ca	e8 00 00 00 00	 call	 dh_devid_typ
  000cf	89 44 24 64	 mov	 DWORD PTR imgtyp$[rsp], eax

; 2768 : 
; 2769 :          if (!sfx && (imgtyp & CKD_C370_TYP)) cckd->ckddasd = 1;

  000d3	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  000d8	75 25		 jne	 SHORT $LN4@cckd_read_
  000da	8b 44 24 64	 mov	 eax, DWORD PTR imgtyp$[rsp]
  000de	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  000e3	85 c0		 test	 eax, eax
  000e5	74 18		 je	 SHORT $LN4@cckd_read_
  000e7	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000ef	83 c8 01	 or	 eax, 1
  000f2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  000f7	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  000fa	e9 59 01 00 00	 jmp	 $LN5@cckd_read_
$LN4@cckd_read_:

; 2770 :     else if (!sfx && (imgtyp & FBA_C370_TYP)) cckd->fbadasd = 1;

  000ff	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  00104	75 25		 jne	 SHORT $LN6@cckd_read_
  00106	8b 44 24 64	 mov	 eax, DWORD PTR imgtyp$[rsp]
  0010a	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  0010f	85 c0		 test	 eax, eax
  00111	74 18		 je	 SHORT $LN6@cckd_read_
  00113	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00118	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0011b	83 c8 02	 or	 eax, 2
  0011e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00123	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00126	e9 2d 01 00 00	 jmp	 $LN7@cckd_read_
$LN6@cckd_read_:

; 2771 :     else if (1
; 2772 :             && !(sfx && (imgtyp & CKD32_SF_TYP) && cckd->ckddasd)
; 2773 :             && !(sfx && (imgtyp & FBA32_SF_TYP) && cckd->fbadasd)

  0012b	33 c0		 xor	 eax, eax
  0012d	83 f8 01	 cmp	 eax, 1
  00130	0f 84 22 01 00
	00		 je	 $LN8@cckd_read_
  00136	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  0013b	74 20		 je	 SHORT $LN9@cckd_read_
  0013d	8b 44 24 64	 mov	 eax, DWORD PTR imgtyp$[rsp]
  00141	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00146	85 c0		 test	 eax, eax
  00148	74 13		 je	 SHORT $LN9@cckd_read_
  0014a	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0014f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00152	83 e0 01	 and	 eax, 1
  00155	85 c0		 test	 eax, eax
  00157	0f 85 fb 00 00
	00		 jne	 $LN8@cckd_read_
$LN9@cckd_read_:
  0015d	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  00162	74 22		 je	 SHORT $LN10@cckd_read_
  00164	8b 44 24 64	 mov	 eax, DWORD PTR imgtyp$[rsp]
  00168	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  0016d	85 c0		 test	 eax, eax
  0016f	74 15		 je	 SHORT $LN10@cckd_read_
  00171	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00176	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00179	d1 e8		 shr	 eax, 1
  0017b	83 e0 01	 and	 eax, 1
  0017e	85 c0		 test	 eax, eax
  00180	0f 85 d2 00 00
	00		 jne	 $LN8@cckd_read_
$LN10@cckd_read_:

; 2774 :     )
; 2775 :     {
; 2776 :         // "%1d:%04X CCKD file[%d] %s: device header id error"
; 2777 :         WRMSG( HHC00305, "E", LCSS_DEVNUM,

  00186	48 83 bc 24 a0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0018f	74 12		 je	 SHORT $LN14@cckd_read_
  00191	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00199	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0019d	89 44 24 70	 mov	 DWORD PTR tv152[rsp], eax
  001a1	eb 08		 jmp	 SHORT $LN15@cckd_read_
$LN14@cckd_read_:
  001a3	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN15@cckd_read_:
  001ab	48 83 bc 24 a0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001b4	74 14		 je	 SHORT $LN16@cckd_read_
  001b6	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001be	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001c2	d1 f8		 sar	 eax, 1
  001c4	89 44 24 74	 mov	 DWORD PTR tv158[rsp], eax
  001c8	eb 08		 jmp	 SHORT $LN17@cckd_read_
$LN16@cckd_read_:
  001ca	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
$LN17@cckd_read_:
  001d2	8b 54 24 60	 mov	 edx, DWORD PTR sfx$[rsp]
  001d6	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001de	e8 00 00 00 00	 call	 cckd_sf_name
  001e3	48 89 44 24 78	 mov	 QWORD PTR tv144[rsp], rax
  001e8	b9 01 00 00 00	 mov	 ecx, 1
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001f3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv144[rsp]
  001f8	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001fd	8b 4c 24 60	 mov	 ecx, DWORD PTR sfx$[rsp]
  00201	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00205	8b 4c 24 70	 mov	 ecx, DWORD PTR tv152[rsp]
  00209	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0020d	8b 4c 24 74	 mov	 ecx, DWORD PTR tv158[rsp]
  00211	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00215	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170936
  0021c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170937
  00228	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0022d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00232	41 b9 03 00 00
	00		 mov	 r9d, 3
  00238	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170938
  0023f	ba da 0a 00 00	 mov	 edx, 2778		; 00000adaH
  00244	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170939
  0024b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2778 :             sfx, cckd_sf_name( dev, sfx ));
; 2779 :         return -1;

  00251	b8 ff ff ff ff	 mov	 eax, -1
  00256	eb 32		 jmp	 SHORT $LN1@cckd_read_
$LN8@cckd_read_:
$LN7@cckd_read_:
$LN5@cckd_read_:

; 2780 :     }
; 2781 : 
; 2782 :     /* Read the compressed header */
; 2783 :     if (cckd_read_chdr( dev ) < 0)

  00258	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00260	e8 00 00 00 00	 call	 cckd_read_chdr
  00265	85 c0		 test	 eax, eax
  00267	7d 07		 jge	 SHORT $LN11@cckd_read_

; 2784 :         return -1;

  00269	b8 ff ff ff ff	 mov	 eax, -1
  0026e	eb 1a		 jmp	 SHORT $LN1@cckd_read_
$LN11@cckd_read_:

; 2785 : 
; 2786 :     /* Read the level 1 table */
; 2787 :     if (cckd_read_l1( dev ) < 0)

  00270	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00278	e8 00 00 00 00	 call	 cckd_read_l1
  0027d	85 c0		 test	 eax, eax
  0027f	7d 07		 jge	 SHORT $LN12@cckd_read_

; 2788 :         return -1;

  00281	b8 ff ff ff ff	 mov	 eax, -1
  00286	eb 02		 jmp	 SHORT $LN1@cckd_read_
$LN12@cckd_read_:

; 2789 : 
; 2790 :     return 0;

  00288	33 c0		 xor	 eax, eax
$LN1@cckd_read_:

; 2791 : } /* end function cckd_read_init */

  0028a	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00292	48 33 cc	 xor	 rcx, rsp
  00295	e8 00 00 00 00	 call	 __security_check_cookie
  0029a	48 81 c4 98 02
	00 00		 add	 rsp, 664		; 00000298H
  002a1	c3		 ret	 0
cckd_read_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
sfx$ = 64
cckd$ = 72
off$ = 80
dev$ = 112
L1idx$ = 120
cckd_write_l1ent PROC

; 2722 : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2723 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 2724 : int             sfx;                    /* File index                */
; 2725 : off_t           off;                    /* Offset to l1 entry        */
; 2726 : 
; 2727 :     if (dev->cckd64)

  0000d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00012	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00019	24 01		 and	 al, 1
  0001b	0f b6 c0	 movzx	 eax, al
  0001e	85 c0		 test	 eax, eax
  00020	74 13		 je	 SHORT $LN2@cckd_write

; 2728 :         return cckd64_write_l1ent( dev, L1idx );

  00022	8b 54 24 78	 mov	 edx, DWORD PTR L1idx$[rsp]
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0002b	e8 00 00 00 00	 call	 cckd64_write_l1ent
  00030	e9 ac 00 00 00	 jmp	 $LN1@cckd_write
$LN2@cckd_write:

; 2729 : 
; 2730 :     cckd = dev->cckd_ext;

  00035	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0003a	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00041	48 89 44 24 48	 mov	 QWORD PTR cckd$[rsp], rax

; 2731 :     sfx = cckd->sfn;

  00046	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  0004b	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0004e	89 44 24 40	 mov	 DWORD PTR sfx$[rsp], eax

; 2732 :     off = (off_t)(CCKD_L1TAB_POS + L1idx * CCKD_L1ENT_SIZE);

  00052	48 63 44 24 78	 movsxd	 rax, DWORD PTR L1idx$[rsp]
  00057	48 8d 04 85 00
	04 00 00	 lea	 rax, QWORD PTR [rax*4+1024]
  0005f	48 89 44 24 50	 mov	 QWORD PTR off$[rsp], rax

; 2733 : 
; 2734 :     CCKD_TRACE( "file[%d] write_l1ent[%d] , 0x%16.16"PRIx64,

  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR off$[rsp]
  00069	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0006e	8b 44 24 78	 mov	 eax, DWORD PTR L1idx$[rsp]
  00072	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00076	8b 44 24 40	 mov	 eax, DWORD PTR sfx$[rsp]
  0007a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0007e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170913
  00085	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  0008a	ba af 0a 00 00	 mov	 edx, 2735		; 00000aafH
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170914
  00096	e8 00 00 00 00	 call	 cckd_trace

; 2735 :                 sfx, L1idx, off);
; 2736 : 
; 2737 :     if (cckd_write (dev, sfx, off, &cckd->L1tab[sfx][L1idx], CCKD_L1ENT_SIZE) < 0)

  0009b	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000a0	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000a5	48 8b 54 24 48	 mov	 rdx, QWORD PTR cckd$[rsp]
  000aa	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000b2	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  000b6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000be	4c 8b c8	 mov	 r9, rax
  000c1	4c 8b 44 24 50	 mov	 r8, QWORD PTR off$[rsp]
  000c6	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  000ca	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000cf	e8 00 00 00 00	 call	 cckd_write
  000d4	85 c0		 test	 eax, eax
  000d6	7d 07		 jge	 SHORT $LN3@cckd_write

; 2738 :         return -1;

  000d8	b8 ff ff ff ff	 mov	 eax, -1
  000dd	eb 02		 jmp	 SHORT $LN1@cckd_write
$LN3@cckd_write:

; 2739 : 
; 2740 :     return 0;

  000df	33 c0		 xor	 eax, eax
$LN1@cckd_write:

; 2741 : 
; 2742 : } /* end function cckd_write_l1ent */

  000e1	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000e5	c3		 ret	 0
cckd_write_l1ent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
sfx$ = 64
len$ = 68
cckd$ = 72
dev$ = 96
cckd_write_l1 PROC

; 2696 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2697 : CCKD_EXT        *cckd;                  /* -> cckd extension         */
; 2698 : int             sfx;                    /* File index                */
; 2699 : int             len;                    /* Length of level 1 table   */
; 2700 : 
; 2701 :     if (dev->cckd64)

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	74 0f		 je	 SHORT $LN2@cckd_write

; 2702 :         return cckd64_write_l1( dev );

  0001e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd64_write_l1
  00028	e9 af 00 00 00	 jmp	 $LN1@cckd_write
$LN2@cckd_write:

; 2703 : 
; 2704 :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 48	 mov	 QWORD PTR cckd$[rsp], rax

; 2705 :     sfx = cckd->sfn;

  0003e	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  00043	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00046	89 44 24 40	 mov	 DWORD PTR sfx$[rsp], eax

; 2706 :     len = cckd->cdevhdr[sfx].num_L1tab * CCKD_L1ENT_SIZE;

  0004a	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0004f	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00056	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cckd$[rsp]
  0005b	48 63 84 01 e4
	01 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+484]
  00063	48 c1 e0 02	 shl	 rax, 2
  00067	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 2707 : 
; 2708 :     CCKD_TRACE( "file[%d] write_l1 0x%"PRIx64" len %d",

  0006b	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  0006f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00073	48 c7 44 24 28
	00 04 00 00	 mov	 QWORD PTR [rsp+40], 1024 ; 00000400H
  0007c	8b 44 24 40	 mov	 eax, DWORD PTR sfx$[rsp]
  00080	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00084	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170892
  0008b	4c 8b 44 24 60	 mov	 r8, QWORD PTR dev$[rsp]
  00090	ba 95 0a 00 00	 mov	 edx, 2709		; 00000a95H
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170893
  0009c	e8 00 00 00 00	 call	 cckd_trace

; 2709 :                 sfx, (U64)CCKD_L1TAB_POS, len);
; 2710 : 
; 2711 :     if (cckd_write (dev, sfx, CCKD_L1TAB_POS, cckd->L1tab[sfx], len) < 0)

  000a1	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000a6	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  000aa	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000ae	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cckd$[rsp]
  000b3	4c 8b 8c c1 98
	01 00 00	 mov	 r9, QWORD PTR [rcx+rax*8+408]
  000bb	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  000c1	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  000c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000ca	e8 00 00 00 00	 call	 cckd_write
  000cf	85 c0		 test	 eax, eax
  000d1	7d 07		 jge	 SHORT $LN3@cckd_write

; 2712 :         return -1;

  000d3	b8 ff ff ff ff	 mov	 eax, -1
  000d8	eb 02		 jmp	 SHORT $LN1@cckd_write
$LN3@cckd_write:

; 2713 : 
; 2714 :     return 0;

  000da	33 c0		 xor	 eax, eax
$LN1@cckd_write:

; 2715 : 
; 2716 : } /* end function cckd_write_l1 */

  000dc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e0	c3		 ret	 0
cckd_write_l1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
sfx$ = 48
i$ = 52
len$ = 56
cckd$ = 64
tv134 = 72
tv143 = 80
tv152 = 88
dev$ = 112
cckd_read_l1 PROC

; 2640 : {

$LN18:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 2641 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 2642 : int             sfx;                    /* File index                */
; 2643 : int             len;                    /* Length of level 1 table   */
; 2644 : int             i;                      /* Work integer              */
; 2645 : 
; 2646 :     if (dev->cckd64)

  0000a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0000f	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00016	24 01		 and	 al, 1
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	74 0f		 je	 SHORT $LN8@cckd_read_

; 2647 :         return cckd64_read_l1( dev );

  0001f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00024	e8 00 00 00 00	 call	 cckd64_read_l1
  00029	e9 3d 03 00 00	 jmp	 $LN1@cckd_read_
$LN8@cckd_read_:

; 2648 : 
; 2649 :     cckd = dev->cckd_ext;

  0002e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00033	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0003a	48 89 44 24 40	 mov	 QWORD PTR cckd$[rsp], rax

; 2650 :     sfx = cckd->sfn;

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00044	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00047	89 44 24 30	 mov	 DWORD PTR sfx$[rsp], eax

; 2651 : 
; 2652 :     CCKD_TRACE( "file[%d] read_l1 offset 0x%"PRIx64,

  0004b	48 c7 44 24 28
	00 04 00 00	 mov	 QWORD PTR [rsp+40], 1024 ; 00000400H
  00054	8b 44 24 30	 mov	 eax, DWORD PTR sfx$[rsp]
  00058	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0005c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170862
  00063	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00068	ba 5d 0a 00 00	 mov	 edx, 2653		; 00000a5dH
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170863
  00074	e8 00 00 00 00	 call	 cckd_trace

; 2653 :                 sfx, (U64)CCKD_L1TAB_POS);
; 2654 : 
; 2655 :     /* Free the old level 1 table if it exists */
; 2656 :     cckd->L1tab[sfx] = cckd_free (dev, "l1", cckd->L1tab[sfx]);

  00079	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00083	4c 8b 84 c1 98
	01 00 00	 mov	 r8, QWORD PTR [rcx+rax*8+408]
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170864
  00092	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00097	e8 00 00 00 00	 call	 cckd_free
  0009c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  000a1	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  000a6	48 89 84 ca 98
	01 00 00	 mov	 QWORD PTR [rdx+rcx*8+408], rax

; 2657 : 
; 2658 :     /* Allocate the level 1 table */
; 2659 :     len = cckd->cdevhdr[sfx].num_L1tab * CCKD_L1ENT_SIZE;

  000ae	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000b3	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  000bf	48 63 84 01 e4
	01 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+484]
  000c7	48 c1 e0 02	 shl	 rax, 2
  000cb	89 44 24 38	 mov	 DWORD PTR len$[rsp], eax

; 2660 :     if ((cckd->L1tab[sfx] = cckd_malloc (dev, "l1", len)) == NULL)

  000cf	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$[rsp]
  000d4	4c 8b c0	 mov	 r8, rax
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170866
  000de	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000e3	e8 00 00 00 00	 call	 cckd_malloc
  000e8	48 89 44 24 48	 mov	 QWORD PTR tv134[rsp], rax
  000ed	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000f2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  000f7	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv134[rsp]
  000fc	48 89 94 c1 98
	01 00 00	 mov	 QWORD PTR [rcx+rax*8+408], rdx
  00104	48 83 7c 24 48
	00		 cmp	 QWORD PTR tv134[rsp], 0
  0010a	75 0a		 jne	 SHORT $LN9@cckd_read_

; 2661 :         return -1;

  0010c	b8 ff ff ff ff	 mov	 eax, -1
  00111	e9 55 02 00 00	 jmp	 $LN1@cckd_read_
$LN9@cckd_read_:

; 2662 :     if ( sfx )

  00116	83 7c 24 30 00	 cmp	 DWORD PTR sfx$[rsp], 0
  0011b	74 2a		 je	 SHORT $LN10@cckd_read_

; 2663 :         memset(cckd->L1tab[sfx], 0xFF, len);

  0011d	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$[rsp]
  00122	48 89 44 24 50	 mov	 QWORD PTR tv143[rsp], rax
  00127	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0012c	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00131	48 8b bc ca 98
	01 00 00	 mov	 rdi, QWORD PTR [rdx+rcx*8+408]
  00139	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0013e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv143[rsp]
  00143	f3 aa		 rep stosb
  00145	eb 25		 jmp	 SHORT $LN11@cckd_read_
$LN10@cckd_read_:

; 2664 :     else
; 2665 :         memset(cckd->L1tab[sfx], 0, len);

  00147	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$[rsp]
  0014c	48 89 44 24 58	 mov	 QWORD PTR tv152[rsp], rax
  00151	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00156	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  0015b	48 8b bc ca 98
	01 00 00	 mov	 rdi, QWORD PTR [rdx+rcx*8+408]
  00163	33 c0		 xor	 eax, eax
  00165	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv152[rsp]
  0016a	f3 aa		 rep stosb
$LN11@cckd_read_:

; 2666 : 
; 2667 :     /* Read the level 1 table */
; 2668 :     if (cckd_read (dev, sfx, CCKD_L1TAB_POS, cckd->L1tab[sfx], len) < 0)

  0016c	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00171	8b 4c 24 38	 mov	 ecx, DWORD PTR len$[rsp]
  00175	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00179	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0017e	4c 8b 8c c1 98
	01 00 00	 mov	 r9, QWORD PTR [rcx+rax*8+408]
  00186	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  0018c	8b 54 24 30	 mov	 edx, DWORD PTR sfx$[rsp]
  00190	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00195	e8 00 00 00 00	 call	 cckd_read
  0019a	85 c0		 test	 eax, eax
  0019c	7d 0a		 jge	 SHORT $LN12@cckd_read_

; 2669 :         return -1;

  0019e	b8 ff ff ff ff	 mov	 eax, -1
  001a3	e9 c3 01 00 00	 jmp	 $LN1@cckd_read_
$LN12@cckd_read_:

; 2670 : 
; 2671 :     /* Fix endianness */
; 2672 :     if (cckd->swapend[sfx])

  001a8	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  001b2	0f b6 84 01 14
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+276]
  001ba	85 c0		 test	 eax, eax
  001bc	74 2f		 je	 SHORT $LN13@cckd_read_

; 2673 :         cckd_swapend_l1 (cckd->L1tab[sfx], cckd->cdevhdr[sfx].num_L1tab);

  001be	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001c3	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001ca	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  001cf	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  001d4	8b 94 02 e4 01
	00 00		 mov	 edx, DWORD PTR [rdx+rax+484]
  001db	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  001e0	48 8b 8c c8 98
	01 00 00	 mov	 rcx, QWORD PTR [rax+rcx*8+408]
  001e8	e8 00 00 00 00	 call	 cckd_swapend_l1
$LN13@cckd_read_:

; 2674 : 
; 2675 :     /* Determine bounds */
; 2676 :     cckd->L2_bounds = CCKD_L1TAB_POS + len;

  001ed	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$[rsp]
  001f2	48 05 00 04 00
	00		 add	 rax, 1024		; 00000400H
  001f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  001fd	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 2677 :     for (i = 0; i < cckd->cdevhdr[sfx].num_L1tab; i++)

  00201	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00209	eb 0a		 jmp	 SHORT $LN4@cckd_read_
$LN2@cckd_read_:
  0020b	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0020f	ff c0		 inc	 eax
  00211	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd_read_:
  00215	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0021a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00221	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00226	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  0022d	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  00231	7d 54		 jge	 SHORT $LN3@cckd_read_

; 2678 :         if (cckd->L1tab[sfx][i] != CCKD_NOSIZE && cckd->L1tab[sfx][i] != CCKD_MAXSIZE)

  00233	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00238	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  0023d	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00242	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  0024a	83 3c 88 00	 cmp	 DWORD PTR [rax+rcx*4], 0
  0024e	74 35		 je	 SHORT $LN14@cckd_read_
  00250	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00255	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  0025a	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  0025f	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00267	83 3c 88 ff	 cmp	 DWORD PTR [rax+rcx*4], -1 ; ffffffffH
  0026b	74 18		 je	 SHORT $LN14@cckd_read_

; 2679 :             cckd->L2_bounds += CCKD_L2TAB_SIZE;

  0026d	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00272	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00276	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  0027c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00281	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
$LN14@cckd_read_:
  00285	eb 84		 jmp	 SHORT $LN2@cckd_read_
$LN3@cckd_read_:

; 2680 : 
; 2681 :     /* Check if all l2 tables are within bounds */
; 2682 :     cckd->L2ok = 1;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  0028c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0028f	0f ba e8 08	 bts	 eax, 8
  00293	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00298	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 2683 :     for (i = 0; i < cckd->cdevhdr[sfx].num_L1tab && cckd->L2ok; i++)

  0029b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002a3	eb 0a		 jmp	 SHORT $LN7@cckd_read_
$LN5@cckd_read_:
  002a5	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  002a9	ff c0		 inc	 eax
  002ab	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN7@cckd_read_:
  002af	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  002b4	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  002bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  002c0	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  002c7	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  002cb	0f 8d 98 00 00
	00		 jge	 $LN6@cckd_read_
  002d1	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  002d6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002d9	c1 e8 08	 shr	 eax, 8
  002dc	83 e0 01	 and	 eax, 1
  002df	85 c0		 test	 eax, eax
  002e1	0f 84 82 00 00
	00		 je	 $LN6@cckd_read_

; 2684 :         if (cckd->L1tab[sfx][i] != CCKD_NOSIZE && cckd->L1tab[sfx][i] != CCKD_MAXSIZE)

  002e7	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  002ec	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  002f1	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  002f6	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  002fe	83 3c 88 00	 cmp	 DWORD PTR [rax+rcx*4], 0
  00302	74 60		 je	 SHORT $LN15@cckd_read_
  00304	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00309	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  0030e	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00313	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  0031b	83 3c 88 ff	 cmp	 DWORD PTR [rax+rcx*4], -1 ; ffffffffH
  0031f	74 43		 je	 SHORT $LN15@cckd_read_

; 2685 :             if (cckd->L1tab[sfx][i] > cckd->L2_bounds - CCKD_L2TAB_SIZE)

  00321	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00326	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  0032b	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00330	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00338	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0033b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00340	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00344	48 81 e9 00 08
	00 00		 sub	 rcx, 2048		; 00000800H
  0034b	48 3b c1	 cmp	 rax, rcx
  0034e	76 14		 jbe	 SHORT $LN16@cckd_read_

; 2686 :                 cckd->L2ok = 0;

  00350	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00355	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00358	0f ba f0 08	 btr	 eax, 8
  0035c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00361	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN16@cckd_read_:
$LN15@cckd_read_:
  00364	e9 3c ff ff ff	 jmp	 $LN5@cckd_read_
$LN6@cckd_read_:

; 2687 : 
; 2688 :     return 0;

  00369	33 c0		 xor	 eax, eax
$LN1@cckd_read_:

; 2689 : 
; 2690 : } /* end function cckd_read_l1 */

  0036b	48 83 c4 60	 add	 rsp, 96			; 00000060H
  0036f	5f		 pop	 rdi
  00370	c3		 ret	 0
cckd_read_l1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
sfx$ = 48
cckd$ = 56
dev$ = 80
cckd_write_chdr PROC

; 2612 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2613 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 2614 : int             sfx;                    /* File index                */
; 2615 : 
; 2616 :     if (dev->cckd64)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	74 0f		 je	 SHORT $LN2@cckd_write

; 2617 :         return cckd64_write_chdr( dev );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd64_write_chdr
  00028	e9 f9 00 00 00	 jmp	 $LN1@cckd_write
$LN2@cckd_write:

; 2618 : 
; 2619 :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 38	 mov	 QWORD PTR cckd$[rsp], rax

; 2620 :     sfx = cckd->sfn;

  0003e	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00043	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00046	89 44 24 30	 mov	 DWORD PTR sfx$[rsp], eax

; 2621 : 
; 2622 :     CCKD_TRACE( "file[%d] write_chdr", sfx);

  0004a	8b 44 24 30	 mov	 eax, DWORD PTR sfx$[rsp]
  0004e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00052	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170819
  00059	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  0005e	ba 3e 0a 00 00	 mov	 edx, 2622		; 00000a3eH
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170820
  0006a	e8 00 00 00 00	 call	 cckd_trace

; 2623 : 
; 2624 :     /* Set version.release.modlvl */
; 2625 :     cckd->cdevhdr[sfx].cdh_vrm[0] = CCKD_VERSION;

  0006f	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00074	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0007b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00080	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  00088	b9 01 00 00 00	 mov	 ecx, 1
  0008d	48 6b c9 00	 imul	 rcx, rcx, 0
  00091	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2626 :     cckd->cdevhdr[sfx].cdh_vrm[1] = CCKD_RELEASE;

  00095	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0009a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000a1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000a6	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  000ae	b9 01 00 00 00	 mov	 ecx, 1
  000b3	48 6b c9 01	 imul	 rcx, rcx, 1
  000b7	c6 04 08 03	 mov	 BYTE PTR [rax+rcx], 3

; 2627 :     cckd->cdevhdr[sfx].cdh_vrm[2] = CCKD_MODLVL;

  000bb	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000c0	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000c7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000cc	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  000d4	b9 01 00 00 00	 mov	 ecx, 1
  000d9	48 6b c9 02	 imul	 rcx, rcx, 2
  000dd	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 2628 : 
; 2629 :     if (cckd_write (dev, sfx, CCKD_DEVHDR_POS, &cckd->cdevhdr[sfx], CCKD_DEVHDR_SIZE) < 0)

  000e1	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000e6	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000f2	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  000fa	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  00102	4c 8b c8	 mov	 r9, rax
  00105	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0010b	8b 54 24 30	 mov	 edx, DWORD PTR sfx$[rsp]
  0010f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00114	e8 00 00 00 00	 call	 cckd_write
  00119	85 c0		 test	 eax, eax
  0011b	7d 07		 jge	 SHORT $LN3@cckd_write

; 2630 :         return -1;

  0011d	b8 ff ff ff ff	 mov	 eax, -1
  00122	eb 02		 jmp	 SHORT $LN1@cckd_write
$LN3@cckd_write:

; 2631 : 
; 2632 :     return 0;

  00124	33 c0		 xor	 eax, eax
$LN1@cckd_write:

; 2633 : 
; 2634 : } /* end function cckd_write_chdr */

  00126	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012a	c3		 ret	 0
cckd_write_chdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
sfx$ = 48
tv138 = 52
cckd$ = 56
dev$ = 80
cckd_read_chdr PROC

; 2559 : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 2560 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 2561 : int             sfx;                    /* File index                */
; 2562 : 
; 2563 :     if (dev->cckd64)

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0000f	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00016	24 01		 and	 al, 1
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	74 0f		 je	 SHORT $LN2@cckd_read_

; 2564 :         return cckd64_read_chdr( dev );

  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00024	e8 00 00 00 00	 call	 cckd64_read_chdr
  00029	e9 41 02 00 00	 jmp	 $LN1@cckd_read_
$LN2@cckd_read_:

; 2565 : 
; 2566 :     cckd = dev->cckd_ext;

  0002e	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00033	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0003a	48 89 44 24 38	 mov	 QWORD PTR cckd$[rsp], rax

; 2567 :     sfx = cckd->sfn;

  0003f	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00044	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00047	89 44 24 30	 mov	 DWORD PTR sfx$[rsp], eax

; 2568 : 
; 2569 :     CCKD_TRACE( "file[%d] read_chdr", sfx);

  0004b	8b 44 24 30	 mov	 eax, DWORD PTR sfx$[rsp]
  0004f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00053	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170799
  0005a	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  0005f	ba 09 0a 00 00	 mov	 edx, 2569		; 00000a09H
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170800
  0006b	e8 00 00 00 00	 call	 cckd_trace

; 2570 : 
; 2571 :     memset(&cckd->cdevhdr[sfx], 0, CCKD_DEVHDR_SIZE);

  00070	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00075	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0007c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00081	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  00089	48 8b f8	 mov	 rdi, rax
  0008c	33 c0		 xor	 eax, eax
  0008e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00093	f3 aa		 rep stosb

; 2572 : 
; 2573 :     /* Read the device header */
; 2574 :     if (cckd_read (dev, sfx, CKD_DEVHDR_SIZE, &cckd->cdevhdr[sfx], CCKD_DEVHDR_SIZE) < 0)

  00095	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0009a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000a1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000a6	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  000ae	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  000b6	4c 8b c8	 mov	 r9, rax
  000b9	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  000bf	8b 54 24 30	 mov	 edx, DWORD PTR sfx$[rsp]
  000c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000c8	e8 00 00 00 00	 call	 cckd_read
  000cd	85 c0		 test	 eax, eax
  000cf	7d 0a		 jge	 SHORT $LN3@cckd_read_

; 2575 :         return -1;

  000d1	b8 ff ff ff ff	 mov	 eax, -1
  000d6	e9 94 01 00 00	 jmp	 $LN1@cckd_read_
$LN3@cckd_read_:

; 2576 : 
; 2577 :     /* Check endian format */
; 2578 :     cckd->swapend[sfx] = 0;

  000db	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000e0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000e5	c6 84 01 14 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+276], 0

; 2579 :     if ((cckd->cdevhdr[sfx].cdh_opts & CCKD_OPT_BIGEND) != cckd_def_opt_bigend())

  000ed	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000f2	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000f9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000fe	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  00106	83 e0 02	 and	 eax, 2
  00109	89 44 24 34	 mov	 DWORD PTR tv138[rsp], eax
  0010d	e8 00 00 00 00	 call	 cckd_def_opt_bigend
  00112	8b 4c 24 34	 mov	 ecx, DWORD PTR tv138[rsp]
  00116	3b c8		 cmp	 ecx, eax
  00118	0f 84 85 00 00
	00		 je	 $LN4@cckd_read_

; 2580 :     {
; 2581 :         if (cckd->open[sfx] == CCKD_OPEN_RW)

  0011e	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00123	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00128	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  00130	83 f8 03	 cmp	 eax, 3
  00133	75 3b		 jne	 SHORT $LN5@cckd_read_

; 2582 :         {
; 2583 :             if (cckd_swapend (dev) < 0)

  00135	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0013a	e8 00 00 00 00	 call	 cckd_swapend
  0013f	85 c0		 test	 eax, eax
  00141	7d 0a		 jge	 SHORT $LN7@cckd_read_

; 2584 :                 return -1;

  00143	b8 ff ff ff ff	 mov	 eax, -1
  00148	e9 22 01 00 00	 jmp	 $LN1@cckd_read_
$LN7@cckd_read_:

; 2585 :             cckd_swapend_chdr (&cckd->cdevhdr[sfx]);

  0014d	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00152	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00159	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0015e	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  00166	48 8b c8	 mov	 rcx, rax
  00169	e8 00 00 00 00	 call	 cckd_swapend_chdr

; 2586 :         }

  0016e	eb 33		 jmp	 SHORT $LN6@cckd_read_
$LN5@cckd_read_:

; 2587 :         else
; 2588 :         {
; 2589 :             cckd->swapend[sfx] = 1;

  00170	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00175	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0017a	c6 84 01 14 01
	00 00 01	 mov	 BYTE PTR [rcx+rax+276], 1

; 2590 :             cckd_swapend_chdr (&cckd->cdevhdr[sfx]);

  00182	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00187	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0018e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00193	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  0019b	48 8b c8	 mov	 rcx, rax
  0019e	e8 00 00 00 00	 call	 cckd_swapend_chdr
$LN6@cckd_read_:
$LN4@cckd_read_:

; 2591 :         }
; 2592 :     }
; 2593 : 
; 2594 :     /* Set default null format */
; 2595 :     if (cckd->cdevhdr[sfx].cdh_nullfmt > CKD_NULLTRK_FMTMAX)

  001a3	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001a8	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001af	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  001b4	0f b6 84 01 0c
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+524]
  001bc	83 f8 02	 cmp	 eax, 2
  001bf	7e 19		 jle	 SHORT $LN8@cckd_read_

; 2596 :         cckd->cdevhdr[sfx].cdh_nullfmt = 0;

  001c1	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001c6	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001cd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  001d2	c6 84 01 0c 02
	00 00 00	 mov	 BYTE PTR [rcx+rax+524], 0
$LN8@cckd_read_:

; 2597 : 
; 2598 :     if (cckd->cdevhdr[sfx].cdh_nullfmt == 0 && dev->oslinux && dev->devtype == 0x3390)

  001da	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001df	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001e6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  001eb	0f b6 84 01 0c
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+524]
  001f3	85 c0		 test	 eax, eax
  001f5	75 3e		 jne	 SHORT $LN9@cckd_read_
  001f7	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001fc	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00202	c1 e8 0d	 shr	 eax, 13
  00205	83 e0 01	 and	 eax, 1
  00208	85 c0		 test	 eax, eax
  0020a	74 29		 je	 SHORT $LN9@cckd_read_
  0020c	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00211	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00215	3d 90 33 00 00	 cmp	 eax, 13200		; 00003390H
  0021a	75 19		 jne	 SHORT $LN9@cckd_read_

; 2599 :         cckd->cdevhdr[sfx].cdh_nullfmt = CKD_NULLTRK_FMT2;

  0021c	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00221	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00228	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0022d	c6 84 01 0c 02
	00 00 02	 mov	 BYTE PTR [rcx+rax+524], 2
$LN9@cckd_read_:

; 2600 : 
; 2601 :     if (cckd->cdevhdr[sfx].cdh_nullfmt == CKD_NULLTRK_FMT2)

  00235	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0023a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00241	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00246	0f b6 84 01 0c
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+524]
  0024e	83 f8 02	 cmp	 eax, 2
  00251	75 1a		 jne	 SHORT $LN10@cckd_read_

; 2602 :         dev->oslinux = 1;

  00253	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00258	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0025e	0f ba e8 0d	 bts	 eax, 13
  00262	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00267	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN10@cckd_read_:

; 2603 : 
; 2604 :     return 0;

  0026d	33 c0		 xor	 eax, eax
$LN1@cckd_read_:

; 2605 : 
; 2606 : } /* end function cckd_read_chdr */

  0026f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00273	5f		 pop	 rdi
  00274	c3		 ret	 0
cckd_read_chdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
i$ = 64
sfx$ = 68
p$ = 72
n$ = 76
pos$ = 80
ppos$ = 84
cckd$ = 88
dev$ = 112
cckd_flush_space PROC

; 2439 : {

$LN25:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2440 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 2441 : int             p,i,n;                  /* Free free space indexes   */
; 2442 : int             sfx;                    /* Shadow file index         */
; 2443 : U32             ppos, pos;              /* Free space offsets        */
; 2444 : 
; 2445 :     if (dev->cckd64)

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	74 0f		 je	 SHORT $LN10@cckd_flush

; 2446 :     {
; 2447 :         cckd64_flush_space( dev );

  0001e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd64_flush_space

; 2448 :         return;

  00028	e9 21 08 00 00	 jmp	 $LN1@cckd_flush
$LN10@cckd_flush:

; 2449 :     }
; 2450 : 
; 2451 :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 58	 mov	 QWORD PTR cckd$[rsp], rax

; 2452 :     sfx = cckd->sfn;

  0003e	48 8b 44 24 58	 mov	 rax, QWORD PTR cckd$[rsp]
  00043	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00046	89 44 24 44	 mov	 DWORD PTR sfx$[rsp], eax

; 2453 : 
; 2454 :     CCKD_TRACE( "flush_space nbr %d",cckd->cdevhdr[sfx].free_num);

  0004a	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0004f	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00056	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  0005b	8b 84 01 00 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+512]
  00062	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00066	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170768
  0006d	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00072	ba 96 09 00 00	 mov	 edx, 2454		; 00000996H
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170769
  0007e	e8 00 00 00 00	 call	 cckd_trace

; 2455 : 
; 2456 :     /* Make sure the free space chain is built */
; 2457 :     if (!cckd->ifb) cckd_read_fsp (dev);

  00083	48 8b 44 24 58	 mov	 rax, QWORD PTR cckd$[rsp]
  00088	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0008d	75 0a		 jne	 SHORT $LN11@cckd_flush
  0008f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00094	e8 00 00 00 00	 call	 cckd_read_fsp
$LN11@cckd_flush:

; 2458 : 
; 2459 :     CCKD_CHK_SPACE(dev);
; 2460 : 
; 2461 :     if (cckd->cdevhdr[sfx].free_num == 0 || cckd->cdevhdr[sfx].free_off == 0)

  00099	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0009e	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000a5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  000aa	83 bc 01 00 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax+512], 0
  000b2	74 1b		 je	 SHORT $LN13@cckd_flush
  000b4	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000b9	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  000c5	83 bc 01 f4 01
	00 00 00	 cmp	 DWORD PTR [rcx+rax+500], 0
  000cd	75 62		 jne	 SHORT $LN12@cckd_flush
$LN13@cckd_flush:

; 2462 :     {
; 2463 :         cckd->cdevhdr[sfx].free_num = cckd->cdevhdr[sfx].free_off = 0;

  000cf	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000d4	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000db	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  000e0	c7 84 01 f4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+500], 0
  000eb	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000f0	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  000fc	c7 84 01 00 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+512], 0

; 2464 :         cckd->free_idx1st = cckd->free_idxlast = cckd->free_idxavail = -1;

  00107	48 8b 44 24 58	 mov	 rax, QWORD PTR cckd$[rsp]
  0010c	c7 80 84 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+132], -1
  00116	48 8b 44 24 58	 mov	 rax, QWORD PTR cckd$[rsp]
  0011b	c7 80 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+128], -1
  00125	48 8b 44 24 58	 mov	 rax, QWORD PTR cckd$[rsp]
  0012a	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1
$LN12@cckd_flush:

; 2465 :     }
; 2466 : 
; 2467 :     pos = cckd->cdevhdr[sfx].free_off;

  00131	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00136	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0013d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00142	8b 84 01 f4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+500]
  00149	89 44 24 50	 mov	 DWORD PTR pos$[rsp], eax

; 2468 :     ppos = p = -1;

  0014d	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR p$[rsp], -1
  00155	8b 44 24 48	 mov	 eax, DWORD PTR p$[rsp]
  00159	89 44 24 54	 mov	 DWORD PTR ppos$[rsp], eax

; 2469 :     cckd->cdevhdr[sfx].free_num = cckd->cdevhdr[sfx].free_largest = 0;

  0015d	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00162	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00169	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  0016e	c7 84 01 fc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+508], 0
  00179	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0017e	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00185	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  0018a	c7 84 01 00 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+512], 0

; 2470 :     for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  00195	48 8b 44 24 58	 mov	 rax, QWORD PTR cckd$[rsp]
  0019a	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  0019d	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  001a1	eb 1a		 jmp	 SHORT $LN4@cckd_flush
$LN2@cckd_flush:
  001a3	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001a8	48 6b c0 14	 imul	 rax, rax, 20
  001ac	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  001b1	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  001b5	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  001b9	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd_flush:
  001bd	83 7c 24 40 00	 cmp	 DWORD PTR i$[rsp], 0
  001c2	0f 8c e3 02 00
	00		 jl	 $LN3@cckd_flush

; 2471 :     {
; 2472 :         /* Decrement the pending count */
; 2473 :         if (cckd->ifb[i].ifb_pending)

  001c8	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001cd	48 6b c0 14	 imul	 rax, rax, 20
  001d1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  001d6	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  001da	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  001df	74 2e		 je	 SHORT $LN14@cckd_flush

; 2474 :             --cckd->ifb[i].ifb_pending;

  001e1	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001e6	48 6b c0 14	 imul	 rax, rax, 20
  001ea	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ef	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  001f3	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  001f7	ff c8		 dec	 eax
  001f9	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  001fe	48 6b c9 14	 imul	 rcx, rcx, 20
  00202	48 8b 54 24 58	 mov	 rdx, QWORD PTR cckd$[rsp]
  00207	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0020b	89 44 0a 10	 mov	 DWORD PTR [rdx+rcx+16], eax
$LN14@cckd_flush:
$LN5@cckd_flush:

; 2475 : 
; 2476 :         /* Combine adjacent free spaces */
; 2477 :         while (pos + cckd->ifb[i].ifb_len == cckd->ifb[i].ifb_offnxt)

  0020f	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00214	48 6b c0 14	 imul	 rax, rax, 20
  00218	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  0021d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00221	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00225	8b 4c 24 50	 mov	 ecx, DWORD PTR pos$[rsp]
  00229	03 c8		 add	 ecx, eax
  0022b	8b c1		 mov	 eax, ecx
  0022d	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00232	48 6b c9 14	 imul	 rcx, rcx, 20
  00236	48 8b 54 24 58	 mov	 rdx, QWORD PTR cckd$[rsp]
  0023b	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0023f	3b 04 0a	 cmp	 eax, DWORD PTR [rdx+rcx]
  00242	0f 85 8a 01 00
	00		 jne	 $LN6@cckd_flush

; 2478 :         {
; 2479 :             n = cckd->ifb[i].ifb_idxnxt;

  00248	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0024d	48 6b c0 14	 imul	 rax, rax, 20
  00251	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00256	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0025a	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  0025e	89 44 24 4c	 mov	 DWORD PTR n$[rsp], eax

; 2480 :             if (cckd->ifb[n].ifb_pending > cckd->ifb[i].ifb_pending + 1
; 2481 :              || cckd->ifb[n].ifb_pending < cckd->ifb[i].ifb_pending)

  00262	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  00267	48 6b c0 14	 imul	 rax, rax, 20
  0026b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00270	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00274	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  00279	48 6b d2 14	 imul	 rdx, rdx, 20
  0027d	4c 8b 44 24 58	 mov	 r8, QWORD PTR cckd$[rsp]
  00282	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00286	41 8b 54 10 10	 mov	 edx, DWORD PTR [r8+rdx+16]
  0028b	ff c2		 inc	 edx
  0028d	39 54 01 10	 cmp	 DWORD PTR [rcx+rax+16], edx
  00291	7f 2f		 jg	 SHORT $LN16@cckd_flush
  00293	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  00298	48 6b c0 14	 imul	 rax, rax, 20
  0029c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  002a1	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  002a5	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  002aa	48 6b d2 14	 imul	 rdx, rdx, 20
  002ae	4c 8b 44 24 58	 mov	 r8, QWORD PTR cckd$[rsp]
  002b3	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  002b7	41 8b 54 10 10	 mov	 edx, DWORD PTR [r8+rdx+16]
  002bc	39 54 01 10	 cmp	 DWORD PTR [rcx+rax+16], edx
  002c0	7d 05		 jge	 SHORT $LN15@cckd_flush
$LN16@cckd_flush:

; 2482 :                 break;

  002c2	e9 0b 01 00 00	 jmp	 $LN6@cckd_flush
$LN15@cckd_flush:

; 2483 :             cckd->ifb[i].ifb_offnxt  = cckd->ifb[n].ifb_offnxt;

  002c7	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  002cc	48 6b c0 14	 imul	 rax, rax, 20
  002d0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  002d5	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  002d9	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  002de	48 6b d2 14	 imul	 rdx, rdx, 20
  002e2	4c 8b 44 24 58	 mov	 r8, QWORD PTR cckd$[rsp]
  002e7	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  002eb	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  002ee	41 89 04 10	 mov	 DWORD PTR [r8+rdx], eax

; 2484 :             cckd->ifb[i].ifb_len += cckd->ifb[n].ifb_len;

  002f2	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  002f7	48 6b c0 14	 imul	 rax, rax, 20
  002fb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00300	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00304	48 63 54 24 4c	 movsxd	 rdx, DWORD PTR n$[rsp]
  00309	48 6b d2 14	 imul	 rdx, rdx, 20
  0030d	4c 8b 44 24 58	 mov	 r8, QWORD PTR cckd$[rsp]
  00312	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00316	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  0031a	41 03 44 10 04	 add	 eax, DWORD PTR [r8+rdx+4]
  0031f	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00324	48 6b c9 14	 imul	 rcx, rcx, 20
  00328	48 8b 54 24 58	 mov	 rdx, QWORD PTR cckd$[rsp]
  0032d	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00331	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax

; 2485 :             cckd->ifb[i].ifb_idxnxt = cckd->ifb[n].ifb_idxnxt;

  00335	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  0033a	48 6b c0 14	 imul	 rax, rax, 20
  0033e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00343	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00347	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  0034c	48 6b d2 14	 imul	 rdx, rdx, 20
  00350	4c 8b 44 24 58	 mov	 r8, QWORD PTR cckd$[rsp]
  00355	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00359	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  0035d	41 89 44 10 0c	 mov	 DWORD PTR [r8+rdx+12], eax

; 2486 :             cckd->ifb[n].ifb_idxnxt = cckd->free_idxavail;

  00362	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  00367	48 6b c0 14	 imul	 rax, rax, 20
  0036b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00370	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00374	48 8b 54 24 58	 mov	 rdx, QWORD PTR cckd$[rsp]
  00379	8b 92 84 00 00
	00		 mov	 edx, DWORD PTR [rdx+132]
  0037f	89 54 01 0c	 mov	 DWORD PTR [rcx+rax+12], edx

; 2487 :             cckd->free_idxavail = n;

  00383	48 8b 44 24 58	 mov	 rax, QWORD PTR cckd$[rsp]
  00388	8b 4c 24 4c	 mov	 ecx, DWORD PTR n$[rsp]
  0038c	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx

; 2488 :             n = cckd->ifb[i].ifb_idxnxt;

  00392	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00397	48 6b c0 14	 imul	 rax, rax, 20
  0039b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  003a0	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003a4	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  003a8	89 44 24 4c	 mov	 DWORD PTR n$[rsp], eax

; 2489 :             if (n >= 0)

  003ac	83 7c 24 4c 00	 cmp	 DWORD PTR n$[rsp], 0
  003b1	7c 1a		 jl	 SHORT $LN17@cckd_flush

; 2490 :                 cckd->ifb[n].ifb_idxprv = i;

  003b3	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  003b8	48 6b c0 14	 imul	 rax, rax, 20
  003bc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  003c1	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003c5	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  003c9	89 54 01 08	 mov	 DWORD PTR [rcx+rax+8], edx
$LN17@cckd_flush:

; 2491 : 
; 2492 :         }

  003cd	e9 3d fe ff ff	 jmp	 $LN5@cckd_flush
$LN6@cckd_flush:

; 2493 :         ppos = pos;

  003d2	8b 44 24 50	 mov	 eax, DWORD PTR pos$[rsp]
  003d6	89 44 24 54	 mov	 DWORD PTR ppos$[rsp], eax

; 2494 :         pos = cckd->ifb[i].ifb_offnxt;

  003da	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  003df	48 6b c0 14	 imul	 rax, rax, 20
  003e3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  003e8	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003ec	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  003ef	89 44 24 50	 mov	 DWORD PTR pos$[rsp], eax

; 2495 :         cckd->cdevhdr[sfx].free_num++;

  003f3	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  003f8	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  003ff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00404	8b 84 01 00 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+512]
  0040b	ff c0		 inc	 eax
  0040d	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00412	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00419	48 8b 54 24 58	 mov	 rdx, QWORD PTR cckd$[rsp]
  0041e	89 84 0a 00 02
	00 00		 mov	 DWORD PTR [rdx+rcx+512], eax

; 2496 :         if (cckd->ifb[i].ifb_len > cckd->cdevhdr[sfx].free_largest
; 2497 :          && !cckd->ifb[i].ifb_pending)

  00425	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0042a	48 6b c0 14	 imul	 rax, rax, 20
  0042e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00433	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00437	48 63 54 24 44	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  0043c	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  00443	4c 8b 44 24 58	 mov	 r8, QWORD PTR cckd$[rsp]
  00448	41 8b 94 10 fc
	01 00 00	 mov	 edx, DWORD PTR [r8+rdx+508]
  00450	39 54 01 04	 cmp	 DWORD PTR [rcx+rax+4], edx
  00454	76 48		 jbe	 SHORT $LN18@cckd_flush
  00456	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0045b	48 6b c0 14	 imul	 rax, rax, 20
  0045f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00464	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00468	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  0046d	75 2f		 jne	 SHORT $LN18@cckd_flush

; 2498 :             cckd->cdevhdr[sfx].free_largest = cckd->ifb[i].ifb_len;

  0046f	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00474	48 6b c0 14	 imul	 rax, rax, 20
  00478	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  0047d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00481	48 63 54 24 44	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  00486	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  0048d	4c 8b 44 24 58	 mov	 r8, QWORD PTR cckd$[rsp]
  00492	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00496	41 89 84 10 fc
	01 00 00	 mov	 DWORD PTR [r8+rdx+508], eax
$LN18@cckd_flush:

; 2499 :         p = i;

  0049e	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  004a2	89 44 24 48	 mov	 DWORD PTR p$[rsp], eax

; 2500 :     }

  004a6	e9 f8 fc ff ff	 jmp	 $LN2@cckd_flush
$LN3@cckd_flush:

; 2501 :     cckd->free_idxlast = p;

  004ab	48 8b 44 24 58	 mov	 rax, QWORD PTR cckd$[rsp]
  004b0	8b 4c 24 48	 mov	 ecx, DWORD PTR p$[rsp]
  004b4	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx

; 2502 : 
; 2503 :     CCKD_TRACE( "rel_flush_space nbr %d (after merge)",

  004ba	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  004bf	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  004cb	8b 84 01 00 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+512]
  004d2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  004d6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170778
  004dd	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  004e2	ba c8 09 00 00	 mov	 edx, 2504		; 000009c8H
  004e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170779
  004ee	e8 00 00 00 00	 call	 cckd_trace

; 2504 :                 cckd->cdevhdr[sfx].free_num);
; 2505 : 
; 2506 :     /* If the last free space is at the end of the file then release it */
; 2507 :     if (p >= 0 && ppos + cckd->ifb[p].ifb_len == cckd->cdevhdr[sfx].cdh_size
; 2508 :      && !cckd->ifb[p].ifb_pending)

  004f3	83 7c 24 48 00	 cmp	 DWORD PTR p$[rsp], 0
  004f8	0f 8c 50 03 00
	00		 jl	 $LN19@cckd_flush
  004fe	48 63 44 24 48	 movsxd	 rax, DWORD PTR p$[rsp]
  00503	48 6b c0 14	 imul	 rax, rax, 20
  00507	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  0050c	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00510	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00514	8b 4c 24 54	 mov	 ecx, DWORD PTR ppos$[rsp]
  00518	03 c8		 add	 ecx, eax
  0051a	8b c1		 mov	 eax, ecx
  0051c	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00521	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00528	48 8b 54 24 58	 mov	 rdx, QWORD PTR cckd$[rsp]
  0052d	3b 84 0a ec 01
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx+492]
  00534	0f 85 14 03 00
	00		 jne	 $LN19@cckd_flush
  0053a	48 63 44 24 48	 movsxd	 rax, DWORD PTR p$[rsp]
  0053f	48 6b c0 14	 imul	 rax, rax, 20
  00543	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00548	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0054c	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  00551	0f 85 f7 02 00
	00		 jne	 $LN19@cckd_flush

; 2509 :     {
; 2510 :         i = p;

  00557	8b 44 24 48	 mov	 eax, DWORD PTR p$[rsp]
  0055b	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 2511 :         p = cckd->ifb[i].ifb_idxprv;

  0055f	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00564	48 6b c0 14	 imul	 rax, rax, 20
  00568	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  0056d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00571	8b 44 01 08	 mov	 eax, DWORD PTR [rcx+rax+8]
  00575	89 44 24 48	 mov	 DWORD PTR p$[rsp], eax

; 2512 : 
; 2513 :         CCKD_TRACE( "file[%d] rel_flush_space atend 0x%16.16"PRIx64" len %d",

  00579	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0057e	48 6b c0 14	 imul	 rax, rax, 20
  00582	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00587	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0058b	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  0058f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00593	8b 44 24 54	 mov	 eax, DWORD PTR ppos$[rsp]
  00597	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0059b	8b 44 24 44	 mov	 eax, DWORD PTR sfx$[rsp]
  0059f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005a3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170781
  005aa	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  005af	ba d2 09 00 00	 mov	 edx, 2514		; 000009d2H
  005b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170782
  005bb	e8 00 00 00 00	 call	 cckd_trace

; 2514 :                     sfx, ppos, cckd->ifb[i].ifb_len);
; 2515 : 
; 2516 :         /* Remove the entry from the chain */
; 2517 :         if (p >= 0)

  005c0	83 7c 24 48 00	 cmp	 DWORD PTR p$[rsp], 0
  005c5	7c 35		 jl	 SHORT $LN20@cckd_flush

; 2518 :         {
; 2519 :             cckd->ifb[p].ifb_offnxt = 0;

  005c7	48 63 44 24 48	 movsxd	 rax, DWORD PTR p$[rsp]
  005cc	48 6b c0 14	 imul	 rax, rax, 20
  005d0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  005d5	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  005d9	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [rcx+rax], 0

; 2520 :             cckd->ifb[p].ifb_idxnxt = -1;

  005e0	48 63 44 24 48	 movsxd	 rax, DWORD PTR p$[rsp]
  005e5	48 6b c0 14	 imul	 rax, rax, 20
  005e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  005ee	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  005f2	c7 44 01 0c ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+12], -1

; 2521 :         }

  005fa	eb 28		 jmp	 SHORT $LN21@cckd_flush
$LN20@cckd_flush:

; 2522 :         else
; 2523 :         {
; 2524 :             cckd->cdevhdr[sfx].free_off = 0;

  005fc	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00601	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00608	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  0060d	c7 84 01 f4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+500], 0

; 2525 :             cckd->free_idx1st = -1;

  00618	48 8b 44 24 58	 mov	 rax, QWORD PTR cckd$[rsp]
  0061d	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1
$LN21@cckd_flush:

; 2526 :         }
; 2527 :         cckd->free_idxlast = p;

  00624	48 8b 44 24 58	 mov	 rax, QWORD PTR cckd$[rsp]
  00629	8b 4c 24 48	 mov	 ecx, DWORD PTR p$[rsp]
  0062d	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx

; 2528 : 
; 2529 :         /* Add the entry to the available chain */
; 2530 :         cckd->ifb[i].ifb_idxnxt = cckd->free_idxavail;

  00633	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00638	48 6b c0 14	 imul	 rax, rax, 20
  0063c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00641	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00645	48 8b 54 24 58	 mov	 rdx, QWORD PTR cckd$[rsp]
  0064a	8b 92 84 00 00
	00		 mov	 edx, DWORD PTR [rdx+132]
  00650	89 54 01 0c	 mov	 DWORD PTR [rcx+rax+12], edx

; 2531 :         cckd->free_idxavail = i;

  00654	48 8b 44 24 58	 mov	 rax, QWORD PTR cckd$[rsp]
  00659	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  0065d	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx

; 2532 : 
; 2533 :         /* Update the device header */
; 2534 :         cckd->cdevhdr[sfx].cdh_size -= cckd->ifb[i].ifb_len;

  00663	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00668	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0066f	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00674	48 6b c9 14	 imul	 rcx, rcx, 20
  00678	48 8b 54 24 58	 mov	 rdx, QWORD PTR cckd$[rsp]
  0067d	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00681	4c 8b 44 24 58	 mov	 r8, QWORD PTR cckd$[rsp]
  00686	8b 4c 0a 04	 mov	 ecx, DWORD PTR [rdx+rcx+4]
  0068a	41 8b 84 00 ec
	01 00 00	 mov	 eax, DWORD PTR [r8+rax+492]
  00692	2b c1		 sub	 eax, ecx
  00694	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00699	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  006a0	48 8b 54 24 58	 mov	 rdx, QWORD PTR cckd$[rsp]
  006a5	89 84 0a ec 01
	00 00		 mov	 DWORD PTR [rdx+rcx+492], eax

; 2535 :         cckd->cdevhdr[sfx].free_total -= cckd->ifb[i].ifb_len;

  006ac	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  006b1	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  006b8	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  006bd	48 6b c9 14	 imul	 rcx, rcx, 20
  006c1	48 8b 54 24 58	 mov	 rdx, QWORD PTR cckd$[rsp]
  006c6	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  006ca	4c 8b 44 24 58	 mov	 r8, QWORD PTR cckd$[rsp]
  006cf	8b 4c 0a 04	 mov	 ecx, DWORD PTR [rdx+rcx+4]
  006d3	41 8b 84 00 f8
	01 00 00	 mov	 eax, DWORD PTR [r8+rax+504]
  006db	2b c1		 sub	 eax, ecx
  006dd	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  006e2	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  006e9	48 8b 54 24 58	 mov	 rdx, QWORD PTR cckd$[rsp]
  006ee	89 84 0a f8 01
	00 00		 mov	 DWORD PTR [rdx+rcx+504], eax

; 2536 :         cckd->cdevhdr[sfx].free_num--;

  006f5	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  006fa	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00701	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00706	8b 84 01 00 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+512]
  0070d	ff c8		 dec	 eax
  0070f	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00714	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  0071b	48 8b 54 24 58	 mov	 rdx, QWORD PTR cckd$[rsp]
  00720	89 84 0a 00 02
	00 00		 mov	 DWORD PTR [rdx+rcx+512], eax

; 2537 :         if (cckd->ifb[i].ifb_len >= cckd->cdevhdr[sfx].free_largest)

  00727	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0072c	48 6b c0 14	 imul	 rax, rax, 20
  00730	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00735	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00739	48 63 54 24 44	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  0073e	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  00745	4c 8b 44 24 58	 mov	 r8, QWORD PTR cckd$[rsp]
  0074a	41 8b 94 10 fc
	01 00 00	 mov	 edx, DWORD PTR [r8+rdx+508]
  00752	39 54 01 04	 cmp	 DWORD PTR [rcx+rax+4], edx
  00756	0f 82 c9 00 00
	00		 jb	 $LN22@cckd_flush

; 2538 :         {
; 2539 :             cckd->cdevhdr[sfx].free_largest = 0;

  0075c	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00761	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00768	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  0076d	c7 84 01 fc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+508], 0

; 2540 :             for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  00778	48 8b 44 24 58	 mov	 rax, QWORD PTR cckd$[rsp]
  0077d	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00780	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  00784	eb 1a		 jmp	 SHORT $LN9@cckd_flush
$LN7@cckd_flush:
  00786	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0078b	48 6b c0 14	 imul	 rax, rax, 20
  0078f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00794	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00798	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  0079c	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN9@cckd_flush:
  007a0	83 7c 24 40 00	 cmp	 DWORD PTR i$[rsp], 0
  007a5	7c 7e		 jl	 SHORT $LN8@cckd_flush

; 2541 :                 if (cckd->ifb[i].ifb_len > cckd->cdevhdr[sfx].free_largest
; 2542 :                  && cckd->ifb[i].ifb_pending == 0)

  007a7	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  007ac	48 6b c0 14	 imul	 rax, rax, 20
  007b0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  007b5	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  007b9	48 63 54 24 44	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  007be	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  007c5	4c 8b 44 24 58	 mov	 r8, QWORD PTR cckd$[rsp]
  007ca	41 8b 94 10 fc
	01 00 00	 mov	 edx, DWORD PTR [r8+rdx+508]
  007d2	39 54 01 04	 cmp	 DWORD PTR [rcx+rax+4], edx
  007d6	76 48		 jbe	 SHORT $LN23@cckd_flush
  007d8	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  007dd	48 6b c0 14	 imul	 rax, rax, 20
  007e1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  007e6	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  007ea	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  007ef	75 2f		 jne	 SHORT $LN23@cckd_flush

; 2543 :                     cckd->cdevhdr[sfx].free_largest = cckd->ifb[i].ifb_len;

  007f1	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  007f6	48 6b c0 14	 imul	 rax, rax, 20
  007fa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  007ff	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00803	48 63 54 24 44	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  00808	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  0080f	4c 8b 44 24 58	 mov	 r8, QWORD PTR cckd$[rsp]
  00814	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00818	41 89 84 10 fc
	01 00 00	 mov	 DWORD PTR [r8+rdx+508], eax
$LN23@cckd_flush:
  00820	e9 61 ff ff ff	 jmp	 $LN7@cckd_flush
$LN8@cckd_flush:
$LN22@cckd_flush:

; 2544 :         }
; 2545 : 
; 2546 :         /* Truncate the file */
; 2547 :         cckd_ftruncate (dev, sfx, (off_t)cckd->cdevhdr[sfx].cdh_size);

  00825	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0082a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00831	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  00836	8b 84 01 ec 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+492]
  0083d	44 8b c0	 mov	 r8d, eax
  00840	8b 54 24 44	 mov	 edx, DWORD PTR sfx$[rsp]
  00844	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00849	e8 00 00 00 00	 call	 cckd_ftruncate
$LN19@cckd_flush:
$LN1@cckd_flush:

; 2548 : 
; 2549 :     } /* Release space at end of the file */
; 2550 : 
; 2551 :     CCKD_CHK_SPACE(dev);
; 2552 : 
; 2553 : } /* end function cckd_flush_space */

  0084e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00852	c3		 ret	 0
cckd_flush_space ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
cckd$ = 64
i$ = 72
sfx$ = 76
p$ = 80
n$ = 84
pending$ = 88
fsize$ = 92
tv142 = 96
new_free_count$1 = 100
tv214 = 104
npos$ = 112
ppos$ = 120
tv179 = 128
dev$ = 160
pos$ = 168
len$ = 176
size$ = 184
cckd_rel_space PROC

; 2329 : {

$LN27:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2330 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 2331 : int             sfx;                    /* Shadow file index         */
; 2332 : off_t           ppos, npos;             /* Prev/next free offsets    */
; 2333 : int             i, p, n;                /* Free space indexes        */
; 2334 : int             pending;                /* Calculated pending value  */
; 2335 : int             fsize = size;           /* Free space size           */

  0001b	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  00022	89 44 24 5c	 mov	 DWORD PTR fsize$[rsp], eax

; 2336 : 
; 2337 :     if (dev->cckd64)

  00026	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00035	24 01		 and	 al, 1
  00037	0f b6 c0	 movzx	 eax, al
  0003a	85 c0		 test	 eax, eax
  0003c	74 2a		 je	 SHORT $LN8@cckd_rel_s

; 2338 :     {
; 2339 :         cckd64_rel_space( dev, pos, len, size );

  0003e	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR size$[rsp]
  00046	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0004e	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pos$[rsp]
  00056	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0005e	e8 00 00 00 00	 call	 cckd64_rel_space

; 2340 :         return;

  00063	e9 08 06 00 00	 jmp	 $LN1@cckd_rel_s
$LN8@cckd_rel_s:

; 2341 :     }
; 2342 : 
; 2343 :     if (len <= CKD_NULLTRK_FMTMAX || pos == CCKD_NOSIZE || pos == CCKD_MAXSIZE)

  00068	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR len$[rsp], 2
  00070	7e 1a		 jle	 SHORT $LN10@cckd_rel_s
  00072	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR pos$[rsp], 0
  0007b	74 0f		 je	 SHORT $LN10@cckd_rel_s
  0007d	b8 ff ff ff ff	 mov	 eax, -1
  00082	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR pos$[rsp], rax
  0008a	75 05		 jne	 SHORT $LN9@cckd_rel_s
$LN10@cckd_rel_s:

; 2344 :         return;

  0008c	e9 df 05 00 00	 jmp	 $LN1@cckd_rel_s
$LN9@cckd_rel_s:

; 2345 : 
; 2346 :     cckd = dev->cckd_ext;

  00091	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  000a0	48 89 44 24 40	 mov	 QWORD PTR cckd$[rsp], rax

; 2347 :     sfx = cckd->sfn;

  000a5	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  000aa	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  000ad	89 44 24 4c	 mov	 DWORD PTR sfx$[rsp], eax

; 2348 : 
; 2349 :     CCKD_TRACE( "rel_space offset 0x%16.16"PRIx64" len %d size %d",

  000b1	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  000b8	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000bc	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  000c3	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000c7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pos$[rsp]
  000cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170734
  000db	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000e3	ba 2e 09 00 00	 mov	 edx, 2350		; 0000092eH
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170735
  000ef	e8 00 00 00 00	 call	 cckd_trace

; 2350 :                 pos, len, size);
; 2351 : 
; 2352 :     if (!cckd->ifb) cckd_read_fsp (dev);

  000f4	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  000f9	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  000fe	75 0d		 jne	 SHORT $LN11@cckd_rel_s
  00100	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00108	e8 00 00 00 00	 call	 cckd_read_fsp
$LN11@cckd_rel_s:

; 2353 : 
; 2354 :     CCKD_CHK_SPACE(dev);
; 2355 : 
; 2356 :     /* Scan free space chain */
; 2357 :     ppos = -1;

  0010d	48 c7 44 24 78
	ff ff ff ff	 mov	 QWORD PTR ppos$[rsp], -1

; 2358 :     npos = cckd->cdevhdr[sfx].free_off;

  00116	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0011b	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00122	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00127	8b 84 01 f4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+500]
  0012e	48 89 44 24 70	 mov	 QWORD PTR npos$[rsp], rax

; 2359 :     for (p = -1, n = cckd->free_idx1st; n >= 0; n = cckd->ifb[n].ifb_idxnxt)

  00133	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR p$[rsp], -1
  0013b	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00140	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00143	89 44 24 54	 mov	 DWORD PTR n$[rsp], eax
  00147	eb 1a		 jmp	 SHORT $LN4@cckd_rel_s
$LN2@cckd_rel_s:
  00149	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  0014e	48 6b c0 14	 imul	 rax, rax, 20
  00152	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00157	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0015b	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  0015f	89 44 24 54	 mov	 DWORD PTR n$[rsp], eax
$LN4@cckd_rel_s:
  00163	83 7c 24 54 00	 cmp	 DWORD PTR n$[rsp], 0
  00168	7c 3f		 jl	 SHORT $LN3@cckd_rel_s

; 2360 :     {
; 2361 :         if (pos < npos) break;

  0016a	48 8b 44 24 70	 mov	 rax, QWORD PTR npos$[rsp]
  0016f	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR pos$[rsp], rax
  00177	7d 02		 jge	 SHORT $LN12@cckd_rel_s
  00179	eb 2e		 jmp	 SHORT $LN3@cckd_rel_s
$LN12@cckd_rel_s:

; 2362 :         ppos = npos;

  0017b	48 8b 44 24 70	 mov	 rax, QWORD PTR npos$[rsp]
  00180	48 89 44 24 78	 mov	 QWORD PTR ppos$[rsp], rax

; 2363 :         npos = cckd->ifb[n].ifb_offnxt;

  00185	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  0018a	48 6b c0 14	 imul	 rax, rax, 20
  0018e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00193	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00197	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0019a	48 89 44 24 70	 mov	 QWORD PTR npos$[rsp], rax

; 2364 :         p = n;

  0019f	8b 44 24 54	 mov	 eax, DWORD PTR n$[rsp]
  001a3	89 44 24 50	 mov	 DWORD PTR p$[rsp], eax

; 2365 :     }

  001a7	eb a0		 jmp	 SHORT $LN2@cckd_rel_s
$LN3@cckd_rel_s:

; 2366 : 
; 2367 :     /* Calculate the `pending' value */
; 2368 :     pending = cckdblk.freepend >= 0 ? cckdblk.freepend : 1 + (1 - cckdblk.fsync);

  001a9	83 3d 48 02 00
	00 00		 cmp	 DWORD PTR cckdblk+584, 0
  001b0	7c 0c		 jl	 SHORT $LN23@cckd_rel_s
  001b2	8b 05 48 02 00
	00		 mov	 eax, DWORD PTR cckdblk+584
  001b8	89 44 24 60	 mov	 DWORD PTR tv142[rsp], eax
  001bc	eb 11		 jmp	 SHORT $LN24@cckd_rel_s
$LN23@cckd_rel_s:
  001be	b8 01 00 00 00	 mov	 eax, 1
  001c3	2b 05 5c 02 00
	00		 sub	 eax, DWORD PTR cckdblk+604
  001c9	ff c0		 inc	 eax
  001cb	89 44 24 60	 mov	 DWORD PTR tv142[rsp], eax
$LN24@cckd_rel_s:
  001cf	8b 44 24 60	 mov	 eax, DWORD PTR tv142[rsp]
  001d3	89 44 24 58	 mov	 DWORD PTR pending$[rsp], eax

; 2369 : 
; 2370 :     /* If possible use previous adjacent free space otherwise get an available one */
; 2371 :     if (p >= 0 && ppos + cckd->ifb[p].ifb_len == pos && cckd->ifb[p].ifb_pending == pending)

  001d7	83 7c 24 50 00	 cmp	 DWORD PTR p$[rsp], 0
  001dc	0f 8c 99 00 00
	00		 jl	 $LN13@cckd_rel_s
  001e2	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  001e7	48 6b c0 14	 imul	 rax, rax, 20
  001eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  001f0	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  001f4	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  001f8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ppos$[rsp]
  001fd	48 03 c8	 add	 rcx, rax
  00200	48 8b c1	 mov	 rax, rcx
  00203	48 3b 84 24 a8
	00 00 00	 cmp	 rax, QWORD PTR pos$[rsp]
  0020b	75 6e		 jne	 SHORT $LN13@cckd_rel_s
  0020d	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  00212	48 6b c0 14	 imul	 rax, rax, 20
  00216	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0021b	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0021f	8b 54 24 58	 mov	 edx, DWORD PTR pending$[rsp]
  00223	39 54 01 10	 cmp	 DWORD PTR [rcx+rax+16], edx
  00227	75 52		 jne	 SHORT $LN13@cckd_rel_s

; 2372 :     {
; 2373 :         cckd->ifb[p].ifb_len += size;

  00229	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  0022e	48 6b c0 14	 imul	 rax, rax, 20
  00232	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00237	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0023b	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  0023f	03 84 24 b8 00
	00 00		 add	 eax, DWORD PTR size$[rsp]
  00246	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR p$[rsp]
  0024b	48 6b c9 14	 imul	 rcx, rcx, 20
  0024f	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00254	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00258	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax

; 2374 :         fsize = cckd->ifb[p].ifb_len;

  0025c	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  00261	48 6b c0 14	 imul	 rax, rax, 20
  00265	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0026a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0026e	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00272	89 44 24 5c	 mov	 DWORD PTR fsize$[rsp], eax

; 2375 :     }

  00276	e9 00 03 00 00	 jmp	 $LN14@cckd_rel_s
$LN13@cckd_rel_s:

; 2376 :     else
; 2377 :     {
; 2378 :         /* Increase the size of the free space array if necessary */
; 2379 :         if (cckd->free_idxavail < 0)

  0027b	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00280	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00287	0f 8d 2c 01 00
	00		 jge	 $LN15@cckd_rel_s

; 2380 :         {
; 2381 :             int new_free_count = cckd->free_count + CCKD_IFB_ENTS_INCR;

  0028d	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00292	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  00295	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  0029a	89 44 24 64	 mov	 DWORD PTR new_free_count$1[rsp], eax

; 2382 :             if (!(cckd->ifb = cckd_realloc( dev, "ifb", cckd->ifb, new_free_count * CCKD_IFREEBLK_SIZE )))

  0029e	48 63 44 24 64	 movsxd	 rax, DWORD PTR new_free_count$1[rsp]
  002a3	48 6b c0 14	 imul	 rax, rax, 20
  002a7	4c 8b c8	 mov	 r9, rax
  002aa	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  002af	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  002b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170742
  002ba	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002c2	e8 00 00 00 00	 call	 cckd_realloc
  002c7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv179[rsp], rax
  002cf	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  002d4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv179[rsp]
  002dc	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
  002e0	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tv179[rsp], 0
  002e9	75 05		 jne	 SHORT $LN16@cckd_rel_s

; 2383 :                 return;

  002eb	e9 80 03 00 00	 jmp	 $LN1@cckd_rel_s
$LN16@cckd_rel_s:

; 2384 :             cckd->free_idxavail = cckd->free_count;

  002f0	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  002f5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  002fa	8b 49 78	 mov	 ecx, DWORD PTR [rcx+120]
  002fd	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx

; 2385 :             cckd->free_count = new_free_count;

  00303	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00308	8b 4c 24 64	 mov	 ecx, DWORD PTR new_free_count$1[rsp]
  0030c	89 48 78	 mov	 DWORD PTR [rax+120], ecx

; 2386 :             for (i = cckd->free_idxavail; i < cckd->free_count; i++)

  0030f	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00314	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  0031a	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
  0031e	eb 0a		 jmp	 SHORT $LN7@cckd_rel_s
$LN5@cckd_rel_s:
  00320	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00324	ff c0		 inc	 eax
  00326	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN7@cckd_rel_s:
  0032a	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  0032f	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  00332	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  00336	7d 1e		 jge	 SHORT $LN6@cckd_rel_s

; 2387 :                 cckd->ifb[i].ifb_idxnxt = i + 1;

  00338	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  0033c	ff c0		 inc	 eax
  0033e	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR i$[rsp]
  00343	48 6b c9 14	 imul	 rcx, rcx, 20
  00347	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  0034c	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00350	89 44 0a 0c	 mov	 DWORD PTR [rdx+rcx+12], eax
  00354	eb ca		 jmp	 SHORT $LN5@cckd_rel_s
$LN6@cckd_rel_s:

; 2388 :             cckd->ifb[i-1].ifb_idxnxt = -1;

  00356	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  0035a	ff c8		 dec	 eax
  0035c	48 98		 cdqe
  0035e	48 6b c0 14	 imul	 rax, rax, 20
  00362	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00367	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0036b	c7 44 01 0c ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+12], -1

; 2389 :             cckd->free_minsize = CCKD_MIN_FREESIZE( cckd->free_count );

  00373	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00378	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  0037b	83 c0 60	 add	 eax, 96			; 00000060H
  0037e	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  00383	7d 0a		 jge	 SHORT $LN25@cckd_rel_s
  00385	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
  0038d	eb 1b		 jmp	 SHORT $LN26@cckd_rel_s
$LN25@cckd_rel_s:
  0038f	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00394	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  00397	99		 cdq
  00398	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  0039e	03 c2		 add	 eax, edx
  003a0	c1 f8 0a	 sar	 eax, 10
  003a3	6b c0 20	 imul	 eax, eax, 32		; 00000020H
  003a6	89 44 24 68	 mov	 DWORD PTR tv214[rsp], eax
$LN26@cckd_rel_s:
  003aa	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  003af	8b 4c 24 68	 mov	 ecx, DWORD PTR tv214[rsp]
  003b3	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx
$LN15@cckd_rel_s:

; 2390 :         }
; 2391 : 
; 2392 :         /* Get an available free space entry */
; 2393 :         i = cckd->free_idxavail;

  003b9	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  003be	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  003c4	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax

; 2394 :         cckd->free_idxavail = cckd->ifb[i].ifb_idxnxt;

  003c8	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  003cd	48 6b c0 14	 imul	 rax, rax, 20
  003d1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  003d6	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003da	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  003df	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  003e3	89 82 84 00 00
	00		 mov	 DWORD PTR [rdx+132], eax

; 2395 :         cckd->cdevhdr[sfx].free_num++;

  003e9	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  003ee	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  003f5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  003fa	8b 84 01 00 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+512]
  00401	ff c0		 inc	 eax
  00403	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00408	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  0040f	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00414	89 84 0a 00 02
	00 00		 mov	 DWORD PTR [rdx+rcx+512], eax

; 2396 : 
; 2397 :         /* Update the new entry */
; 2398 :         cckd->ifb[i].ifb_idxprv = p;

  0041b	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  00420	48 6b c0 14	 imul	 rax, rax, 20
  00424	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00429	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0042d	8b 54 24 50	 mov	 edx, DWORD PTR p$[rsp]
  00431	89 54 01 08	 mov	 DWORD PTR [rcx+rax+8], edx

; 2399 :         cckd->ifb[i].ifb_idxnxt = n;

  00435	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  0043a	48 6b c0 14	 imul	 rax, rax, 20
  0043e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00443	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00447	8b 54 24 54	 mov	 edx, DWORD PTR n$[rsp]
  0044b	89 54 01 0c	 mov	 DWORD PTR [rcx+rax+12], edx

; 2400 :         cckd->ifb[i].ifb_len = size;

  0044f	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  00454	48 6b c0 14	 imul	 rax, rax, 20
  00458	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0045d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00461	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR size$[rsp]
  00468	89 54 01 04	 mov	 DWORD PTR [rcx+rax+4], edx

; 2401 :         cckd->ifb[i].ifb_pending = pending;

  0046c	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  00471	48 6b c0 14	 imul	 rax, rax, 20
  00475	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0047a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0047e	8b 54 24 58	 mov	 edx, DWORD PTR pending$[rsp]
  00482	89 54 01 10	 mov	 DWORD PTR [rcx+rax+16], edx

; 2402 : 
; 2403 :         /* Update the previous entry */
; 2404 :         if (p >= 0)

  00486	83 7c 24 50 00	 cmp	 DWORD PTR p$[rsp], 0
  0048b	7c 63		 jl	 SHORT $LN17@cckd_rel_s

; 2405 :         {
; 2406 :             cckd->ifb[i].ifb_offnxt = cckd->ifb[p].ifb_offnxt;

  0048d	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  00492	48 6b c0 14	 imul	 rax, rax, 20
  00496	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0049b	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0049f	48 63 54 24 48	 movsxd	 rdx, DWORD PTR i$[rsp]
  004a4	48 6b d2 14	 imul	 rdx, rdx, 20
  004a8	4c 8b 44 24 40	 mov	 r8, QWORD PTR cckd$[rsp]
  004ad	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  004b1	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  004b4	41 89 04 10	 mov	 DWORD PTR [r8+rdx], eax

; 2407 :             cckd->ifb[p].ifb_offnxt = (U32)pos;

  004b8	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  004bd	48 6b c0 14	 imul	 rax, rax, 20
  004c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  004c6	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004ca	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR pos$[rsp]
  004d1	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 2408 :             cckd->ifb[p].ifb_idxnxt = i;

  004d4	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  004d9	48 6b c0 14	 imul	 rax, rax, 20
  004dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  004e2	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004e6	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  004ea	89 54 01 0c	 mov	 DWORD PTR [rcx+rax+12], edx

; 2409 :         }

  004ee	eb 59		 jmp	 SHORT $LN18@cckd_rel_s
$LN17@cckd_rel_s:

; 2410 :         else
; 2411 :         {
; 2412 :             cckd->ifb[i].ifb_offnxt = cckd->cdevhdr[sfx].free_off;

  004f0	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  004f5	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004fc	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR i$[rsp]
  00501	48 6b c9 14	 imul	 rcx, rcx, 20
  00505	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  0050a	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0050e	4c 8b 44 24 40	 mov	 r8, QWORD PTR cckd$[rsp]
  00513	41 8b 84 00 f4
	01 00 00	 mov	 eax, DWORD PTR [r8+rax+500]
  0051b	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2413 :             cckd->cdevhdr[sfx].free_off = (U32)pos;

  0051e	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00523	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0052a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0052f	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR pos$[rsp]
  00536	89 94 01 f4 01
	00 00		 mov	 DWORD PTR [rcx+rax+500], edx

; 2414 :             cckd->free_idx1st = i;

  0053d	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00542	8b 4c 24 48	 mov	 ecx, DWORD PTR i$[rsp]
  00546	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
$LN18@cckd_rel_s:

; 2415 :         }
; 2416 : 
; 2417 :         /* Update the next entry */
; 2418 :         if (n >= 0)

  00549	83 7c 24 54 00	 cmp	 DWORD PTR n$[rsp], 0
  0054e	7c 1c		 jl	 SHORT $LN19@cckd_rel_s

; 2419 :             cckd->ifb[n].ifb_idxprv = i;

  00550	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  00555	48 6b c0 14	 imul	 rax, rax, 20
  00559	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0055e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00562	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  00566	89 54 01 08	 mov	 DWORD PTR [rcx+rax+8], edx
  0056a	eb 0f		 jmp	 SHORT $LN20@cckd_rel_s
$LN19@cckd_rel_s:

; 2420 :         else
; 2421 :             cckd->free_idxlast = i;

  0056c	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00571	8b 4c 24 48	 mov	 ecx, DWORD PTR i$[rsp]
  00575	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx
$LN20@cckd_rel_s:
$LN14@cckd_rel_s:

; 2422 :     }
; 2423 : 
; 2424 :     /* Update the free space statistics */
; 2425 :     cckd->cdevhdr[sfx].cdh_used -= len;

  0057b	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00580	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00587	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0058c	8b 94 24 b0 00
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00593	8b 84 01 f0 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+496]
  0059a	2b c2		 sub	 eax, edx
  0059c	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  005a1	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  005a8	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  005ad	89 84 0a f0 01
	00 00		 mov	 DWORD PTR [rdx+rcx+496], eax

; 2426 :     cckd->cdevhdr[sfx].free_total += len;

  005b4	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  005b9	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  005c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  005c5	8b 84 01 f8 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+504]
  005cc	03 84 24 b0 00
	00 00		 add	 eax, DWORD PTR len$[rsp]
  005d3	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  005d8	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  005df	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  005e4	89 84 0a f8 01
	00 00		 mov	 DWORD PTR [rdx+rcx+504], eax

; 2427 :     cckd->cdevhdr[sfx].free_imbed -= size - len;

  005eb	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  005f0	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  005f7	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  005fe	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR size$[rsp]
  00605	2b d1		 sub	 edx, ecx
  00607	8b ca		 mov	 ecx, edx
  00609	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  0060e	8b 84 02 04 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax+516]
  00615	2b c1		 sub	 eax, ecx
  00617	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0061c	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00623	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00628	89 84 0a 04 02
	00 00		 mov	 DWORD PTR [rdx+rcx+516], eax

; 2428 :     if (!pending && (U32)fsize > cckd->cdevhdr[sfx].free_largest)

  0062f	83 7c 24 58 00	 cmp	 DWORD PTR pending$[rsp], 0
  00634	75 3a		 jne	 SHORT $LN21@cckd_rel_s
  00636	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0063b	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00642	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00647	8b 84 01 fc 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+508]
  0064e	39 44 24 5c	 cmp	 DWORD PTR fsize$[rsp], eax
  00652	76 1c		 jbe	 SHORT $LN21@cckd_rel_s

; 2429 :         cckd->cdevhdr[sfx].free_largest = (U32)fsize;

  00654	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00659	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00660	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00665	8b 54 24 5c	 mov	 edx, DWORD PTR fsize$[rsp]
  00669	89 94 01 fc 01
	00 00		 mov	 DWORD PTR [rcx+rax+508], edx
$LN21@cckd_rel_s:
$LN1@cckd_rel_s:

; 2430 : 
; 2431 :     CCKD_CHK_SPACE(dev);
; 2432 : 
; 2433 : } /* end function cckd_rel_space */

  00670	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00677	c3		 ret	 0
cckd_rel_space ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
cckd$ = 96
sfx$ = 104
i$ = 108
len$ = 112
p$ = 116
i$1 = 120
n$ = 124
flen$ = 128
fpos$ = 136
tv162 = 144
tv168 = 148
len2$ = 152
tv152 = 160
tv154 = 168
dev$ = 192
size$ = 200
flags$ = 208
cckd_get_space PROC

; 2184 : {

$LN34:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2185 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 2186 : int             i,p,n;                  /* Free space indexes        */
; 2187 : int             len2;                   /* Other lengths             */
; 2188 : off_t           fpos;                   /* Free space offset         */
; 2189 : unsigned int    flen;                   /* Free space size           */
; 2190 : int             sfx;                    /* Shadow file index         */
; 2191 : int             len;                    /* Requested length          */
; 2192 : 
; 2193 :     if (dev->cckd64)

  00016	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00025	24 01		 and	 al, 1
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	74 22		 je	 SHORT $LN8@cckd_get_s

; 2194 :         return cckd64_get_space( dev, size, flags );

  0002e	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR flags$[rsp]
  00036	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR size$[rsp]
  0003e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00046	e8 00 00 00 00	 call	 cckd64_get_space
  0004b	e9 78 08 00 00	 jmp	 $LN1@cckd_get_s
$LN8@cckd_get_s:

; 2195 : 
; 2196 :     cckd = dev->cckd_ext;

  00050	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00058	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0005f	48 89 44 24 60	 mov	 QWORD PTR cckd$[rsp], rax

; 2197 :     sfx = cckd->sfn;

  00064	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00069	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0006c	89 44 24 68	 mov	 DWORD PTR sfx$[rsp], eax

; 2198 : 
; 2199 :     len = *size;

  00070	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  00078	8b 00		 mov	 eax, DWORD PTR [rax]
  0007a	89 44 24 70	 mov	 DWORD PTR len$[rsp], eax

; 2200 : 
; 2201 :     if (flags & CCKD_L2SPACE)

  0007e	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00085	83 e0 04	 and	 eax, 4
  00088	85 c0		 test	 eax, eax
  0008a	74 27		 je	 SHORT $LN9@cckd_get_s

; 2202 :     {
; 2203 :         flags |= CCKD_SIZE_EXACT;

  0008c	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00093	83 c8 01	 or	 eax, 1
  00096	89 84 24 d0 00
	00 00		 mov	 DWORD PTR flags$[rsp], eax

; 2204 :         len = *size = CCKD_L2TAB_SIZE;

  0009d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  000a5	c7 00 00 08 00
	00		 mov	 DWORD PTR [rax], 2048	; 00000800H
  000ab	c7 44 24 70 00
	08 00 00	 mov	 DWORD PTR len$[rsp], 2048 ; 00000800H
$LN9@cckd_get_s:

; 2205 :     }
; 2206 : 
; 2207 :     CCKD_TRACE( "get_space len %d largest %d flags 0x%2.2x",

  000b3	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000b8	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000bf	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR flags$[rsp]
  000c6	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  000ca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  000cf	8b 84 01 fc 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+508]
  000d6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000da	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  000de	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000e2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170668
  000e9	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000f1	ba a0 08 00 00	 mov	 edx, 2208		; 000008a0H
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170669
  000fd	e8 00 00 00 00	 call	 cckd_trace

; 2208 :                 len, cckd->cdevhdr[sfx].free_largest, flags);
; 2209 : 
; 2210 :     if (len <= CKD_NULLTRK_FMTMAX)

  00102	83 7c 24 70 02	 cmp	 DWORD PTR len$[rsp], 2
  00107	7f 07		 jg	 SHORT $LN10@cckd_get_s

; 2211 :         return 0;

  00109	33 c0		 xor	 eax, eax
  0010b	e9 b8 07 00 00	 jmp	 $LN1@cckd_get_s
$LN10@cckd_get_s:

; 2212 : 
; 2213 :     if (!cckd->ifb)

  00110	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00115	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0011a	75 0d		 jne	 SHORT $LN11@cckd_get_s

; 2214 :         cckd_read_fsp (dev);

  0011c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00124	e8 00 00 00 00	 call	 cckd_read_fsp
$LN11@cckd_get_s:

; 2215 : 
; 2216 :     len2 = len + CCKD_FREEBLK_SIZE;

  00129	48 63 44 24 70	 movsxd	 rax, DWORD PTR len$[rsp]
  0012e	48 83 c0 08	 add	 rax, 8
  00132	89 84 24 98 00
	00 00		 mov	 DWORD PTR len2$[rsp], eax

; 2217 : 
; 2218 :     /* Get space at the end if no space is large enough */
; 2219 :     if (len2 > (int)cckd->cdevhdr[sfx].free_largest
; 2220 :      && len != (int)cckd->cdevhdr[sfx].free_largest)

  00139	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0013e	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00145	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0014a	8b 84 01 fc 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+508]
  00151	39 84 24 98 00
	00 00		 cmp	 DWORD PTR len2$[rsp], eax
  00158	0f 8e 22 02 00
	00		 jle	 $LN12@cckd_get_s
  0015e	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00163	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0016a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0016f	8b 84 01 fc 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+508]
  00176	39 44 24 70	 cmp	 DWORD PTR len$[rsp], eax
  0017a	0f 84 00 02 00
	00		 je	 $LN12@cckd_get_s
$cckd_get_space_atend$35:

; 2221 :     {
; 2222 : 
; 2223 : cckd_get_space_atend:
; 2224 : 
; 2225 :         fpos = (off_t)cckd->cdevhdr[sfx].cdh_size;

  00180	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00185	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0018c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00191	8b 84 01 ec 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+492]
  00198	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 2226 :         if ((U64)fpos > (cckd->cckd_maxsize - len))

  001a0	48 63 44 24 70	 movsxd	 rax, DWORD PTR len$[rsp]
  001a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  001aa	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001ae	48 2b c8	 sub	 rcx, rax
  001b1	48 8b c1	 mov	 rax, rcx
  001b4	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR fpos$[rsp], rax
  001bc	0f 86 14 01 00
	00		 jbe	 $LN13@cckd_get_s

; 2227 :         {
; 2228 :             // "%1d:%04X CCKD file[%d] %s: get space error, size exceeds %"PRId64"M"
; 2229 :             WRMSG (HHC00304, "E", LCSS_DEVNUM, sfx, cckd_sf_name (dev, sfx),

  001c2	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001cb	74 15		 je	 SHORT $LN30@cckd_get_s
  001cd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001d9	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv162[rsp], eax
  001e0	eb 0b		 jmp	 SHORT $LN31@cckd_get_s
$LN30@cckd_get_s:
  001e2	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv162[rsp], 0
$LN31@cckd_get_s:
  001ed	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001f6	74 17		 je	 SHORT $LN32@cckd_get_s
  001f8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00200	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00204	d1 f8		 sar	 eax, 1
  00206	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv168[rsp], eax
  0020d	eb 0b		 jmp	 SHORT $LN33@cckd_get_s
$LN32@cckd_get_s:
  0020f	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv168[rsp], 0
$LN33@cckd_get_s:
  0021a	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0021f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00223	48 c1 e8 14	 shr	 rax, 20
  00227	48 ff c0	 inc	 rax
  0022a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv152[rsp], rax
  00232	8b 54 24 68	 mov	 edx, DWORD PTR sfx$[rsp]
  00236	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0023e	e8 00 00 00 00	 call	 cckd_sf_name
  00243	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv154[rsp], rax
  0024b	b9 01 00 00 00	 mov	 ecx, 1
  00250	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00256	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv152[rsp]
  0025e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00263	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv154[rsp]
  0026b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00270	8b 4c 24 68	 mov	 ecx, DWORD PTR sfx$[rsp]
  00274	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00278	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv162[rsp]
  0027f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00283	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv168[rsp]
  0028a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0028e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170674
  00295	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0029a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170675
  002a1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ab	41 b9 03 00 00
	00		 mov	 r9d, 3
  002b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170676
  002b8	ba b6 08 00 00	 mov	 edx, 2230		; 000008b6H
  002bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170677
  002c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2230 :                 (S64) (cckd->cckd_maxsize >> 20) + 1);
; 2231 :             return -1;

  002ca	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  002d1	e9 f2 05 00 00	 jmp	 $LN1@cckd_get_s
$LN13@cckd_get_s:

; 2232 :         }
; 2233 :         cckd->cdevhdr[sfx].cdh_size += len;

  002d6	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  002db	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  002e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  002e7	8b 84 01 ec 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+492]
  002ee	03 44 24 70	 add	 eax, DWORD PTR len$[rsp]
  002f2	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  002f7	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  002fe	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00303	89 84 0a ec 01
	00 00		 mov	 DWORD PTR [rdx+rcx+492], eax

; 2234 :         cckd->cdevhdr[sfx].cdh_used += len;

  0030a	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0030f	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00316	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0031b	8b 84 01 f0 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+496]
  00322	03 44 24 70	 add	 eax, DWORD PTR len$[rsp]
  00326	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0032b	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00332	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00337	89 84 0a f0 01
	00 00		 mov	 DWORD PTR [rdx+rcx+496], eax

; 2235 : 
; 2236 :         CCKD_TRACE( "get_space atend 0x%16.16"PRIx64" len %d",fpos, len);

  0033e	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  00342	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00346	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR fpos$[rsp]
  0034e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00353	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170678
  0035a	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00362	ba bc 08 00 00	 mov	 edx, 2236		; 000008bcH
  00367	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170679
  0036e	e8 00 00 00 00	 call	 cckd_trace

; 2237 : 
; 2238 :         return fpos;

  00373	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR fpos$[rsp]
  0037b	e9 48 05 00 00	 jmp	 $LN1@cckd_get_s
$LN12@cckd_get_s:

; 2239 :     }
; 2240 : 
; 2241 :     /* Scan free space chain */
; 2242 :     fpos = (off_t)cckd->cdevhdr[sfx].free_off;

  00380	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00385	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0038c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00391	8b 84 01 f4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+500]
  00398	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 2243 :     for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  003a0	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  003a5	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  003a8	89 44 24 6c	 mov	 DWORD PTR i$[rsp], eax
  003ac	eb 1a		 jmp	 SHORT $LN4@cckd_get_s
$LN2@cckd_get_s:
  003ae	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  003b3	48 6b c0 14	 imul	 rax, rax, 20
  003b7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  003bc	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003c0	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  003c4	89 44 24 6c	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd_get_s:
  003c8	83 7c 24 6c 00	 cmp	 DWORD PTR i$[rsp], 0
  003cd	0f 8c 99 00 00
	00		 jl	 $LN3@cckd_get_s

; 2244 :     {
; 2245 :         if (cckd->ifb[i].ifb_pending == 0
; 2246 :          && (len2 <= (int)cckd->ifb[i].ifb_len || len == (int)cckd->ifb[i].ifb_len)
; 2247 :          && ((flags & CCKD_L2SPACE) || (U64)fpos >= cckd->L2_bounds))

  003d3	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  003d8	48 6b c0 14	 imul	 rax, rax, 20
  003dc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  003e1	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003e5	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  003ea	75 5e		 jne	 SHORT $LN14@cckd_get_s
  003ec	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  003f1	48 6b c0 14	 imul	 rax, rax, 20
  003f5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  003fa	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003fe	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00402	39 84 24 98 00
	00 00		 cmp	 DWORD PTR len2$[rsp], eax
  00409	7e 1c		 jle	 SHORT $LN15@cckd_get_s
  0040b	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  00410	48 6b c0 14	 imul	 rax, rax, 20
  00414	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00419	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0041d	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00421	39 44 24 70	 cmp	 DWORD PTR len$[rsp], eax
  00425	75 23		 jne	 SHORT $LN14@cckd_get_s
$LN15@cckd_get_s:
  00427	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  0042e	83 e0 04	 and	 eax, 4
  00431	85 c0		 test	 eax, eax
  00433	75 13		 jne	 SHORT $LN16@cckd_get_s
  00435	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0043a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0043e	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR fpos$[rsp], rax
  00446	72 02		 jb	 SHORT $LN14@cckd_get_s
$LN16@cckd_get_s:

; 2248 :             break;

  00448	eb 22		 jmp	 SHORT $LN3@cckd_get_s
$LN14@cckd_get_s:

; 2249 :         fpos = (off_t)cckd->ifb[i].ifb_offnxt;

  0044a	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  0044f	48 6b c0 14	 imul	 rax, rax, 20
  00453	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00458	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0045c	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0045f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 2250 :     }

  00467	e9 42 ff ff ff	 jmp	 $LN2@cckd_get_s
$LN3@cckd_get_s:

; 2251 : 
; 2252 :     /* This can happen if largest comes before L2_bounds */
; 2253 :     if (i < 0) goto cckd_get_space_atend;

  0046c	83 7c 24 6c 00	 cmp	 DWORD PTR i$[rsp], 0
  00471	7d 05		 jge	 SHORT $LN17@cckd_get_s
  00473	e9 08 fd ff ff	 jmp	 $cckd_get_space_atend$35
$LN17@cckd_get_s:

; 2254 : 
; 2255 :     flen = cckd->ifb[i].ifb_len;

  00478	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  0047d	48 6b c0 14	 imul	 rax, rax, 20
  00481	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00486	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0048a	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  0048e	89 84 24 80 00
	00 00		 mov	 DWORD PTR flen$[rsp], eax

; 2256 :     p = cckd->ifb[i].ifb_idxprv;

  00495	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  0049a	48 6b c0 14	 imul	 rax, rax, 20
  0049e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  004a3	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004a7	8b 44 01 08	 mov	 eax, DWORD PTR [rcx+rax+8]
  004ab	89 44 24 74	 mov	 DWORD PTR p$[rsp], eax

; 2257 :     n = cckd->ifb[i].ifb_idxnxt;

  004af	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  004b4	48 6b c0 14	 imul	 rax, rax, 20
  004b8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  004bd	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004c1	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  004c5	89 44 24 7c	 mov	 DWORD PTR n$[rsp], eax

; 2258 : 
; 2259 :     /*
; 2260 :      * If `CCKD_SIZE_ANY' bit is set and the left over space is small
; 2261 :      * enough, then use the entire free space
; 2262 :      */
; 2263 :     if ((flags & CCKD_SIZE_ANY) && flen <= cckd->free_minsize)

  004c9	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  004d0	83 e0 02	 and	 eax, 2
  004d3	85 c0		 test	 eax, eax
  004d5	74 25		 je	 SHORT $LN18@cckd_get_s
  004d7	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  004dc	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  004e2	39 84 24 80 00
	00 00		 cmp	 DWORD PTR flen$[rsp], eax
  004e9	77 11		 ja	 SHORT $LN18@cckd_get_s

; 2264 :         *size = (int)flen;

  004eb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  004f3	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR flen$[rsp]
  004fa	89 08		 mov	 DWORD PTR [rax], ecx
$LN18@cckd_get_s:

; 2265 : 
; 2266 :     /* Remove the new space from free space */
; 2267 :     if (*size < (int)flen)

  004fc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  00504	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR flen$[rsp]
  0050b	39 08		 cmp	 DWORD PTR [rax], ecx
  0050d	0f 8d b4 00 00
	00		 jge	 $LN19@cckd_get_s

; 2268 :     {
; 2269 :         cckd->ifb[i].ifb_len -= *size;

  00513	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  00518	48 6b c0 14	 imul	 rax, rax, 20
  0051c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00521	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00525	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR size$[rsp]
  0052d	8b 12		 mov	 edx, DWORD PTR [rdx]
  0052f	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  00533	2b c2		 sub	 eax, edx
  00535	48 63 4c 24 6c	 movsxd	 rcx, DWORD PTR i$[rsp]
  0053a	48 6b c9 14	 imul	 rcx, rcx, 20
  0053e	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00543	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00547	89 44 0a 04	 mov	 DWORD PTR [rdx+rcx+4], eax

; 2270 :         if (p >= 0)

  0054b	83 7c 24 74 00	 cmp	 DWORD PTR p$[rsp], 0
  00550	7c 36		 jl	 SHORT $LN21@cckd_get_s

; 2271 :             cckd->ifb[p].ifb_offnxt += *size;

  00552	48 63 44 24 74	 movsxd	 rax, DWORD PTR p$[rsp]
  00557	48 6b c0 14	 imul	 rax, rax, 20
  0055b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00560	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00564	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00567	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR size$[rsp]
  0056f	03 01		 add	 eax, DWORD PTR [rcx]
  00571	48 63 4c 24 74	 movsxd	 rcx, DWORD PTR p$[rsp]
  00576	48 6b c9 14	 imul	 rcx, rcx, 20
  0057a	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  0057f	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00583	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax
  00586	eb 3a		 jmp	 SHORT $LN22@cckd_get_s
$LN21@cckd_get_s:

; 2272 :         else
; 2273 :             cckd->cdevhdr[sfx].free_off += *size;

  00588	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0058d	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00594	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00599	8b 84 01 f4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+500]
  005a0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR size$[rsp]
  005a8	03 01		 add	 eax, DWORD PTR [rcx]
  005aa	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  005af	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  005b6	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  005bb	89 84 0a f4 01
	00 00		 mov	 DWORD PTR [rdx+rcx+500], eax
$LN22@cckd_get_s:

; 2274 :     }

  005c2	e9 1c 01 00 00	 jmp	 $LN20@cckd_get_s
$LN19@cckd_get_s:

; 2275 :     else
; 2276 :     {
; 2277 :         cckd->cdevhdr[sfx].free_num--;

  005c7	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  005cc	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  005d3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  005d8	8b 84 01 00 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+512]
  005df	ff c8		 dec	 eax
  005e1	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  005e6	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  005ed	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  005f2	89 84 0a 00 02
	00 00		 mov	 DWORD PTR [rdx+rcx+512], eax

; 2278 : 
; 2279 :         /* Remove the free space entry from the chain */
; 2280 :         if (p >= 0)

  005f9	83 7c 24 74 00	 cmp	 DWORD PTR p$[rsp], 0
  005fe	7c 47		 jl	 SHORT $LN23@cckd_get_s

; 2281 :         {
; 2282 :             cckd->ifb[p].ifb_offnxt = cckd->ifb[i].ifb_offnxt;

  00600	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  00605	48 6b c0 14	 imul	 rax, rax, 20
  00609	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0060e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00612	48 63 54 24 74	 movsxd	 rdx, DWORD PTR p$[rsp]
  00617	48 6b d2 14	 imul	 rdx, rdx, 20
  0061b	4c 8b 44 24 60	 mov	 r8, QWORD PTR cckd$[rsp]
  00620	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00624	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00627	41 89 04 10	 mov	 DWORD PTR [r8+rdx], eax

; 2283 :             cckd->ifb[p].ifb_idxnxt = n;

  0062b	48 63 44 24 74	 movsxd	 rax, DWORD PTR p$[rsp]
  00630	48 6b c0 14	 imul	 rax, rax, 20
  00634	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00639	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0063d	8b 54 24 7c	 mov	 edx, DWORD PTR n$[rsp]
  00641	89 54 01 0c	 mov	 DWORD PTR [rcx+rax+12], edx

; 2284 :         }

  00645	eb 3a		 jmp	 SHORT $LN24@cckd_get_s
$LN23@cckd_get_s:

; 2285 :         else
; 2286 :         {
; 2287 :             cckd->cdevhdr[sfx].free_off = cckd->ifb[i].ifb_offnxt;

  00647	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  0064c	48 6b c0 14	 imul	 rax, rax, 20
  00650	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00655	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00659	48 63 54 24 68	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  0065e	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  00665	4c 8b 44 24 60	 mov	 r8, QWORD PTR cckd$[rsp]
  0066a	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0066d	41 89 84 10 f4
	01 00 00	 mov	 DWORD PTR [r8+rdx+500], eax

; 2288 :             cckd->free_idx1st = n;

  00675	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0067a	8b 4c 24 7c	 mov	 ecx, DWORD PTR n$[rsp]
  0067e	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
$LN24@cckd_get_s:

; 2289 :         }
; 2290 : 
; 2291 :         if (n >= 0)

  00681	83 7c 24 7c 00	 cmp	 DWORD PTR n$[rsp], 0
  00686	7c 1c		 jl	 SHORT $LN25@cckd_get_s

; 2292 :             cckd->ifb[n].ifb_idxprv = p;

  00688	48 63 44 24 7c	 movsxd	 rax, DWORD PTR n$[rsp]
  0068d	48 6b c0 14	 imul	 rax, rax, 20
  00691	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00696	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0069a	8b 54 24 74	 mov	 edx, DWORD PTR p$[rsp]
  0069e	89 54 01 08	 mov	 DWORD PTR [rcx+rax+8], edx
  006a2	eb 0f		 jmp	 SHORT $LN26@cckd_get_s
$LN25@cckd_get_s:

; 2293 :         else
; 2294 :             cckd->free_idxlast = p;

  006a4	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  006a9	8b 4c 24 74	 mov	 ecx, DWORD PTR p$[rsp]
  006ad	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx
$LN26@cckd_get_s:

; 2295 : 
; 2296 :         /* Add entry to the available queue */
; 2297 :         cckd->ifb[i].ifb_idxnxt = cckd->free_idxavail;

  006b3	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  006b8	48 6b c0 14	 imul	 rax, rax, 20
  006bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  006c1	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  006c5	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  006ca	8b 92 84 00 00
	00		 mov	 edx, DWORD PTR [rdx+132]
  006d0	89 54 01 0c	 mov	 DWORD PTR [rcx+rax+12], edx

; 2298 :         cckd->free_idxavail = i;

  006d4	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  006d9	8b 4c 24 6c	 mov	 ecx, DWORD PTR i$[rsp]
  006dd	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
$LN20@cckd_get_s:

; 2299 :     }
; 2300 : 
; 2301 :     /* Find the largest free space if we got the largest */
; 2302 :     if (flen >= cckd->cdevhdr[sfx].free_largest)

  006e3	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  006e8	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  006ef	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  006f4	8b 84 01 fc 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+508]
  006fb	39 84 24 80 00
	00 00		 cmp	 DWORD PTR flen$[rsp], eax
  00702	0f 82 c9 00 00
	00		 jb	 $LN27@cckd_get_s

; 2303 :     {
; 2304 :         int i;
; 2305 :         cckd->cdevhdr[sfx].free_largest = 0;

  00708	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0070d	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00714	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00719	c7 84 01 fc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+508], 0

; 2306 :         for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  00724	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00729	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  0072c	89 44 24 78	 mov	 DWORD PTR i$1[rsp], eax
  00730	eb 1a		 jmp	 SHORT $LN7@cckd_get_s
$LN5@cckd_get_s:
  00732	48 63 44 24 78	 movsxd	 rax, DWORD PTR i$1[rsp]
  00737	48 6b c0 14	 imul	 rax, rax, 20
  0073b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00740	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00744	8b 44 01 0c	 mov	 eax, DWORD PTR [rcx+rax+12]
  00748	89 44 24 78	 mov	 DWORD PTR i$1[rsp], eax
$LN7@cckd_get_s:
  0074c	83 7c 24 78 00	 cmp	 DWORD PTR i$1[rsp], 0
  00751	7c 7e		 jl	 SHORT $LN6@cckd_get_s

; 2307 :             if (cckd->ifb[i].ifb_len > cckd->cdevhdr[sfx].free_largest
; 2308 :              && cckd->ifb[i].ifb_pending == 0)

  00753	48 63 44 24 78	 movsxd	 rax, DWORD PTR i$1[rsp]
  00758	48 6b c0 14	 imul	 rax, rax, 20
  0075c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00761	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00765	48 63 54 24 68	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  0076a	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  00771	4c 8b 44 24 60	 mov	 r8, QWORD PTR cckd$[rsp]
  00776	41 8b 94 10 fc
	01 00 00	 mov	 edx, DWORD PTR [r8+rdx+508]
  0077e	39 54 01 04	 cmp	 DWORD PTR [rcx+rax+4], edx
  00782	76 48		 jbe	 SHORT $LN28@cckd_get_s
  00784	48 63 44 24 78	 movsxd	 rax, DWORD PTR i$1[rsp]
  00789	48 6b c0 14	 imul	 rax, rax, 20
  0078d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00792	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00796	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  0079b	75 2f		 jne	 SHORT $LN28@cckd_get_s

; 2309 :                 cckd->cdevhdr[sfx].free_largest = cckd->ifb[i].ifb_len;

  0079d	48 63 44 24 78	 movsxd	 rax, DWORD PTR i$1[rsp]
  007a2	48 6b c0 14	 imul	 rax, rax, 20
  007a6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  007ab	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  007af	48 63 54 24 68	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  007b4	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  007bb	4c 8b 44 24 60	 mov	 r8, QWORD PTR cckd$[rsp]
  007c0	8b 44 01 04	 mov	 eax, DWORD PTR [rcx+rax+4]
  007c4	41 89 84 10 fc
	01 00 00	 mov	 DWORD PTR [r8+rdx+508], eax
$LN28@cckd_get_s:
  007cc	e9 61 ff ff ff	 jmp	 $LN5@cckd_get_s
$LN6@cckd_get_s:
$LN27@cckd_get_s:

; 2310 :     }
; 2311 : 
; 2312 :     /* Update free space stats */
; 2313 :     cckd->cdevhdr[sfx].cdh_used += len;

  007d1	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  007d6	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  007dd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  007e2	8b 84 01 f0 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+496]
  007e9	03 44 24 70	 add	 eax, DWORD PTR len$[rsp]
  007ed	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  007f2	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  007f9	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  007fe	89 84 0a f0 01
	00 00		 mov	 DWORD PTR [rdx+rcx+496], eax

; 2314 :     cckd->cdevhdr[sfx].free_total -= len;

  00805	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0080a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00811	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00816	8b 54 24 70	 mov	 edx, DWORD PTR len$[rsp]
  0081a	8b 84 01 f8 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+504]
  00821	2b c2		 sub	 eax, edx
  00823	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00828	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  0082f	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00834	89 84 0a f8 01
	00 00		 mov	 DWORD PTR [rdx+rcx+504], eax

; 2315 : 
; 2316 :     cckd->cdevhdr[sfx].free_imbed += *size - len;

  0083b	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00840	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00847	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR size$[rsp]
  0084f	8b 54 24 70	 mov	 edx, DWORD PTR len$[rsp]
  00853	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00855	2b ca		 sub	 ecx, edx
  00857	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  0085c	03 8c 02 04 02
	00 00		 add	 ecx, DWORD PTR [rdx+rax+516]
  00863	8b c1		 mov	 eax, ecx
  00865	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0086a	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00871	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00876	89 84 0a 04 02
	00 00		 mov	 DWORD PTR [rdx+rcx+516], eax

; 2317 : 
; 2318 :     CCKD_TRACE( "get_space found 0x%16.16"PRIx64" len %d size %d",

  0087d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  00885	8b 00		 mov	 eax, DWORD PTR [rax]
  00887	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0088b	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  0088f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00893	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR fpos$[rsp]
  0089b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008a0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170695
  008a7	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  008af	ba 0f 09 00 00	 mov	 edx, 2319		; 0000090fH
  008b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170696
  008bb	e8 00 00 00 00	 call	 cckd_trace

; 2319 :                 fpos, len, *size);
; 2320 : 
; 2321 :     return fpos;

  008c0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR fpos$[rsp]
$LN1@cckd_get_s:

; 2322 : 
; 2323 : } /* end function cckd_get_space */

  008c8	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  008cf	c3		 ret	 0
cckd_get_space ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
cckd$ = 112
len$ = 120
trk$ = 124
dev$ = 128
buf$ = 136
devnum$ = 144
parm$ = 148
comp$ = 152
bufl$ = 156
tv135 = 160
tv136 = 164
tv145 = 168
tv192 = 172
tv196 = 176
rc$ = 180
tv330 = 184
flag$ = 188
bufp$ = 192
tid$ = 200
tv326 = 208
buf2$ = 224
__$ArrayPad$ = 65760
writer$ = 65792
o$ = 65800
cckd_writer_write PROC

; 1945 : {

$LN28:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	b8 f8 00 01 00	 mov	 eax, 65784		; 000100f8H
  0000d	e8 00 00 00 00	 call	 __chkstk
  00012	48 2b e0	 sub	 rsp, rax
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 e0
	00 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@cckd_write:

; 1946 : TID             tid;                    /* Writer thead id           */
; 1947 : CCKD_EXT*       cckd;                   /* -> cckd extension         */
; 1948 : DEVBLK*         dev;                    /* Device block              */
; 1949 : U16             devnum;                 /* Device number             */
; 1950 : int             rc;                     /* (work) return code        */
; 1951 : int             trk;                    /* Track number              */
; 1952 : BYTE*           buf;                    /* Buffer                    */
; 1953 : BYTE*           bufp;                   /* Buffer to be written      */
; 1954 : int             len, bufl;              /* Buffer lengths            */
; 1955 : int             comp;                   /* Compression algorithm     */
; 1956 : int             parm;                   /* Compression parameter     */
; 1957 : U32             flag;                   /* Cache flag                */
; 1958 : BYTE            buf2[ 64*1024 ];        /* 64K Compress buffer       */
; 1959 : 
; 1960 :     /* Prepare to compress */
; 1961 :     CCKD_CACHE_GETKEY( o, devnum, trk );

  00027	8b 94 24 08 01
	01 00		 mov	 edx, DWORD PTR o$[rsp]
  0002e	33 c9		 xor	 ecx, ecx
  00030	e8 00 00 00 00	 call	 cache_getkey
  00035	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00039	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  0003f	66 89 84 24 90
	00 00 00	 mov	 WORD PTR devnum$[rsp], ax
  00047	8b 94 24 08 01
	01 00		 mov	 edx, DWORD PTR o$[rsp]
  0004e	33 c9		 xor	 ecx, ecx
  00050	e8 00 00 00 00	 call	 cache_getkey
  00055	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0005a	48 23 c1	 and	 rax, rcx
  0005d	89 44 24 7c	 mov	 DWORD PTR trk$[rsp], eax
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 c0		 jne	 SHORT $LN4@cckd_write

; 1962 :     dev = cckd_find_device_by_devnum( devnum );

  00067	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR devnum$[rsp]
  0006f	e8 00 00 00 00	 call	 cckd_find_device_by_devnum
  00074	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax

; 1963 : 
; 1964 :     if (dev->cckd64)

  0007c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00084	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0008b	24 01		 and	 al, 1
  0008d	0f b6 c0	 movzx	 eax, al
  00090	85 c0		 test	 eax, eax
  00092	74 18		 je	 SHORT $LN5@cckd_write

; 1965 :     {
; 1966 :         cckd64_writer_write( writer, o );

  00094	8b 94 24 08 01
	01 00		 mov	 edx, DWORD PTR o$[rsp]
  0009b	8b 8c 24 00 01
	01 00		 mov	 ecx, DWORD PTR writer$[rsp]
  000a2	e8 00 00 00 00	 call	 cckd64_writer_write

; 1967 :         return;

  000a7	e9 e3 07 00 00	 jmp	 $LN1@cckd_write
$LN5@cckd_write:

; 1968 :     }
; 1969 : 
; 1970 :     cckd = dev->cckd_ext;

  000ac	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b4	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  000bb	48 89 44 24 70	 mov	 QWORD PTR cckd$[rsp], rax

; 1971 :     buf  = cache_getbuf( CACHE_DEVBUF, o, 0 );

  000c0	45 33 c0	 xor	 r8d, r8d
  000c3	8b 94 24 08 01
	01 00		 mov	 edx, DWORD PTR o$[rsp]
  000ca	33 c9		 xor	 ecx, ecx
  000cc	e8 00 00 00 00	 call	 cache_getbuf
  000d1	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1972 :     len  = cckd_trklen( dev, buf );

  000d9	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000e1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000e9	e8 00 00 00 00	 call	 cckd_trklen
  000ee	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax

; 1973 : 
; 1974 :     comp = len < CCKD_COMPRESS_MIN ? CCKD_COMPRESS_NONE :

  000f2	81 7c 24 78 00
	02 00 00	 cmp	 DWORD PTR len$[rsp], 512 ; 00000200H
  000fa	7d 0d		 jge	 SHORT $LN20@cckd_write
  000fc	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv136[rsp], 0
  00107	eb 50		 jmp	 SHORT $LN21@cckd_write
$LN20@cckd_write:
  00109	0f b6 05 1d 00
	00 00		 movzx	 eax, BYTE PTR cckdblk+29
  00110	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00115	75 26		 jne	 SHORT $LN18@cckd_write
  00117	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0011c	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00120	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00127	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  0012c	0f b6 84 01 0d
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+525]
  00134	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv135[rsp], eax
  0013b	eb 0e		 jmp	 SHORT $LN19@cckd_write
$LN18@cckd_write:
  0013d	0f b6 05 1d 00
	00 00		 movzx	 eax, BYTE PTR cckdblk+29
  00144	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv135[rsp], eax
$LN19@cckd_write:
  0014b	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv135[rsp]
  00152	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv136[rsp], eax
$LN21@cckd_write:
  00159	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv136[rsp]
  00160	89 84 24 98 00
	00 00		 mov	 DWORD PTR comp$[rsp], eax

; 1975 :          cckdblk.comp == 0xff ? cckd->cdevhdr[ cckd->sfn ].cmp_algo
; 1976 :                               : cckdblk.comp;
; 1977 : 
; 1978 :     parm = cckdblk.compparm < 0 ? cckd->cdevhdr[ cckd->sfn ].cmp_parm

  00167	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR cckdblk+32, 0
  0016e	7d 26		 jge	 SHORT $LN22@cckd_write
  00170	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00175	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00179	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00180	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00185	0f bf 84 01 0e
	02 00 00	 movsx	 eax, WORD PTR [rcx+rax+526]
  0018d	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv145[rsp], eax
  00194	eb 0d		 jmp	 SHORT $LN23@cckd_write
$LN22@cckd_write:
  00196	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR cckdblk+32
  0019c	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv145[rsp], eax
$LN23@cckd_write:
  001a3	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv145[rsp]
  001aa	89 84 24 94 00
	00 00		 mov	 DWORD PTR parm$[rsp], eax

; 1979 :                                 : cckdblk.compparm;
; 1980 : 
; 1981 :     CCKD_TRACE( "%d wrtrk[%d] %d len %d buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x",

  001b1	b8 01 00 00 00	 mov	 eax, 1
  001b6	48 6b c0 04	 imul	 rax, rax, 4
  001ba	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  001c2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c6	b9 01 00 00 00	 mov	 ecx, 1
  001cb	48 6b c9 03	 imul	 rcx, rcx, 3
  001cf	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  001d7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001db	ba 01 00 00 00	 mov	 edx, 1
  001e0	48 6b d2 02	 imul	 rdx, rdx, 2
  001e4	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  001ec	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  001f1	41 b8 01 00 00
	00		 mov	 r8d, 1
  001f7	4d 6b c0 01	 imul	 r8, r8, 1
  001fb	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  00203	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00208	41 b9 01 00 00
	00		 mov	 r9d, 1
  0020e	4d 6b c9 00	 imul	 r9, r9, 0
  00212	4c 8b 94 24 88
	00 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  0021a	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  0021f	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  00223	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00227	89 54 24 58	 mov	 DWORD PTR [rsp+88], edx
  0022b	44 89 44 24 50	 mov	 DWORD PTR [rsp+80], r8d
  00230	44 89 4c 24 48	 mov	 DWORD PTR [rsp+72], r9d
  00235	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0023d	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00242	8b 44 24 78	 mov	 eax, DWORD PTR len$[rsp]
  00246	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0024a	8b 44 24 7c	 mov	 eax, DWORD PTR trk$[rsp]
  0024e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00252	8b 84 24 08 01
	01 00		 mov	 eax, DWORD PTR o$[rsp]
  00259	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0025d	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR writer$[rsp]
  00264	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00268	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170584
  0026f	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00277	ba be 07 00 00	 mov	 edx, 1982		; 000007beH
  0027c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170585
  00283	e8 00 00 00 00	 call	 cckd_trace

; 1982 :                 writer, o, trk, len, buf, buf[0], buf[1],buf[2],buf[3],buf[4] );
; 1983 : 
; 1984 :     /* Compress the image if not null */
; 1985 :     if ((len = cckd_check_null_trk( dev, buf, trk, len )) > CKD_NULLTRK_FMTMAX)

  00288	44 8b 4c 24 78	 mov	 r9d, DWORD PTR len$[rsp]
  0028d	44 8b 44 24 7c	 mov	 r8d, DWORD PTR trk$[rsp]
  00292	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0029a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002a2	e8 00 00 00 00	 call	 cckd_check_null_trk
  002a7	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax
  002ab	83 7c 24 78 02	 cmp	 DWORD PTR len$[rsp], 2
  002b0	0f 8e a3 01 00
	00		 jle	 $LN6@cckd_write

; 1986 :     {
; 1987 :         /* Stress adjustments */
; 1988 :         if (1
; 1989 :             && !cckdblk.nostress
; 1990 :             && (0

  002b6	33 c0		 xor	 eax, eax
  002b8	83 f8 01	 cmp	 eax, 1
  002bb	0f 84 9d 00 00
	00		 je	 $LN8@cckd_write
  002c1	83 3d 54 02 00
	00 00		 cmp	 DWORD PTR cckdblk+596, 0
  002c8	0f 85 90 00 00
	00		 jne	 $LN8@cckd_write
  002ce	33 c0		 xor	 eax, eax
  002d0	85 c0		 test	 eax, eax
  002d2	75 17		 jne	 SHORT $LN9@cckd_write
  002d4	33 c9		 xor	 ecx, ecx
  002d6	e8 00 00 00 00	 call	 cache_waiters
  002db	85 c0		 test	 eax, eax
  002dd	75 0c		 jne	 SHORT $LN9@cckd_write
  002df	33 c9		 xor	 ecx, ecx
  002e1	e8 00 00 00 00	 call	 cache_busy
  002e6	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  002e9	7e 73		 jle	 SHORT $LN8@cckd_write
$LN9@cckd_write:

; 1991 :                 || cache_waiters ( CACHE_DEVBUF )
; 1992 :                 || cache_busy    ( CACHE_DEVBUF ) > 90
; 1993 :                )
; 1994 :         )
; 1995 :         {
; 1996 :             cckdblk.stats_stresswrites++;

  002eb	48 8b 05 a0 02
	00 00		 mov	 rax, QWORD PTR cckdblk+672
  002f2	48 ff c0	 inc	 rax
  002f5	48 89 05 a0 02
	00 00		 mov	 QWORD PTR cckdblk+672, rax

; 1997 : 
; 1998 :             comp = len < CCKD_STRESS_MINLEN ? CCKD_COMPRESS_NONE

  002fc	81 7c 24 78 00
	10 00 00	 cmp	 DWORD PTR len$[rsp], 4096 ; 00001000H
  00304	7d 0d		 jge	 SHORT $LN24@cckd_write
  00306	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv192[rsp], 0
  00311	eb 0b		 jmp	 SHORT $LN25@cckd_write
$LN24@cckd_write:
  00313	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv192[rsp], 0
$LN25@cckd_write:
  0031e	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv192[rsp]
  00325	89 84 24 98 00
	00 00		 mov	 DWORD PTR comp$[rsp], eax

; 1999 :                                             : CCKD_STRESS_COMP;
; 2000 : 
; 2001 :             parm = cache_busy(CACHE_DEVBUF) <= 95 ? CCKD_STRESS_PARM1

  0032c	33 c9		 xor	 ecx, ecx
  0032e	e8 00 00 00 00	 call	 cache_busy
  00333	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00336	7f 0d		 jg	 SHORT $LN26@cckd_write
  00338	c7 84 24 b0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv196[rsp], 4
  00343	eb 0b		 jmp	 SHORT $LN27@cckd_write
$LN26@cckd_write:
  00345	c7 84 24 b0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv196[rsp], 2
$LN27@cckd_write:
  00350	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv196[rsp]
  00357	89 84 24 94 00
	00 00		 mov	 DWORD PTR parm$[rsp], eax
$LN8@cckd_write:

; 2002 :                                                   : CCKD_STRESS_PARM2;
; 2003 :         }
; 2004 : 
; 2005 :         /* Compress the track image */
; 2006 :         CCKD_TRACE( "%d wrtrk[%d] %d comp %s parm %d",

  0035e	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR comp$[rsp]
  00366	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compname
  0036d	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR parm$[rsp]
  00374	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  00378	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0037c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00381	8b 44 24 7c	 mov	 eax, DWORD PTR trk$[rsp]
  00385	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00389	8b 84 24 08 01
	01 00		 mov	 eax, DWORD PTR o$[rsp]
  00390	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00394	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR writer$[rsp]
  0039b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0039f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170590
  003a6	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  003ae	ba d7 07 00 00	 mov	 edx, 2007		; 000007d7H
  003b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170591
  003ba	e8 00 00 00 00	 call	 cckd_trace

; 2007 :                     writer, o, trk, compname[ comp ], parm );
; 2008 : 
; 2009 :         bufp = (BYTE*) &buf2;

  003bf	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR buf2$[rsp]
  003c7	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR bufp$[rsp], rax

; 2010 :         bufl = cckd_compress( dev, &bufp, buf, len, comp, parm );

  003cf	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR parm$[rsp]
  003d6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003da	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR comp$[rsp]
  003e1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003e5	44 8b 4c 24 78	 mov	 r9d, DWORD PTR len$[rsp]
  003ea	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  003f2	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR bufp$[rsp]
  003fa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00402	e8 00 00 00 00	 call	 cckd_compress
  00407	89 84 24 9c 00
	00 00		 mov	 DWORD PTR bufl$[rsp], eax

; 2011 : 
; 2012 :         CCKD_TRACE( "%d wrtrk[%d] %d compressed length %d",

  0040e	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR bufl$[rsp]
  00415	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00419	8b 44 24 7c	 mov	 eax, DWORD PTR trk$[rsp]
  0041d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00421	8b 84 24 08 01
	01 00		 mov	 eax, DWORD PTR o$[rsp]
  00428	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0042c	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR writer$[rsp]
  00433	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00437	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170592
  0043e	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00446	ba dd 07 00 00	 mov	 edx, 2013		; 000007ddH
  0044b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170593
  00452	e8 00 00 00 00	 call	 cckd_trace

; 2013 :                     writer, o, trk, bufl );
; 2014 :     }

  00457	eb 1b		 jmp	 SHORT $LN7@cckd_write
$LN6@cckd_write:

; 2015 :     else
; 2016 :     {
; 2017 :         bufp = buf;

  00459	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00461	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR bufp$[rsp], rax

; 2018 :         bufl = len;

  00469	8b 44 24 78	 mov	 eax, DWORD PTR len$[rsp]
  0046d	89 84 24 9c 00
	00 00		 mov	 DWORD PTR bufl$[rsp], eax
$LN7@cckd_write:

; 2019 :     }
; 2020 : 
; 2021 :     obtain_lock( &cckd->filelock );

  00474	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00479	48 83 c0 10	 add	 rax, 16
  0047d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170594
  00484	48 8b c8	 mov	 rcx, rax
  00487	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2022 :     {
; 2023 :         /* Turn on read-write header bits if not already on */
; 2024 :         if (!(cckd->cdevhdr[ cckd->sfn ].cdh_opts & CCKD_OPT_OPENED))

  0048d	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00492	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00496	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0049d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  004a2	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  004aa	25 80 00 00 00	 and	 eax, 128		; 00000080H
  004af	85 c0		 test	 eax, eax
  004b1	75 4b		 jne	 SHORT $LN10@cckd_write

; 2025 :         {
; 2026 :             cckd->cdevhdr[ cckd->sfn ].cdh_opts |= (CCKD_OPT_OPENED | CCKD_OPT_OPENRW);

  004b3	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  004b8	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  004bc	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004c3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  004c8	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  004d0	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  004d5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  004da	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  004de	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  004e5	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  004ea	88 84 0a e3 01
	00 00		 mov	 BYTE PTR [rdx+rcx+483], al

; 2027 :             cckd_write_chdr( dev );

  004f1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004f9	e8 00 00 00 00	 call	 cckd_write_chdr
$LN10@cckd_write:

; 2028 :         }
; 2029 : 
; 2030 :         /* Write the track image */
; 2031 :         cckd_write_trkimg( dev, bufp, bufl, trk, CCKD_SIZE_ANY );

  004fe	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00506	44 8b 4c 24 7c	 mov	 r9d, DWORD PTR trk$[rsp]
  0050b	44 8b 84 24 9c
	00 00 00	 mov	 r8d, DWORD PTR bufl$[rsp]
  00513	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR bufp$[rsp]
  0051b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00523	e8 00 00 00 00	 call	 cckd_write_trkimg

; 2032 :     }
; 2033 :     release_lock( &cckd->filelock );

  00528	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0052d	48 83 c0 10	 add	 rax, 16
  00531	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170596
  00538	48 8b c8	 mov	 rcx, rax
  0053b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2034 : 
; 2035 :     /* Schedule the garbage collector */
; 2036 :     obtain_lock( &cckdblk.gclock );/* ensure read integrity for gc count */

  00541	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170597
  00548	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  0054f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2037 :     {
; 2038 :         if (cckdblk.gcint > 0 && cckdblk.gcs < cckdblk.gcmax)

  00555	83 3d 44 00 00
	00 00		 cmp	 DWORD PTR cckdblk+68, 0
  0055c	0f 8e cb 01 00
	00		 jle	 $LN11@cckd_write
  00562	8b 05 40 00 00
	00		 mov	 eax, DWORD PTR cckdblk+64
  00568	39 05 38 00 00
	00		 cmp	 DWORD PTR cckdblk+56, eax
  0056e	0f 8d b9 01 00
	00		 jge	 $LN11@cckd_write

; 2039 :         {
; 2040 :             /* Schedule a new garbage collector thread */
; 2041 : 
; 2042 :             if (!cckdblk.batch || cckdblk.batchml > 1)

  00574	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  0057a	83 e0 01	 and	 eax, 1
  0057d	85 c0		 test	 eax, eax
  0057f	74 09		 je	 SHORT $LN13@cckd_write
  00581	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  00588	7e 71		 jle	 SHORT $LN12@cckd_write
$LN13@cckd_write:

; 2043 :                 // "Starting thread %s, active=%d, started=%d, max=%d"
; 2044 :                 WRMSG( HHC00107, "I", CCKD_GC_THREAD_NAME "()",

  0058a	b9 01 00 00 00	 mov	 ecx, 1
  0058f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00595	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+64
  0059b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0059f	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+56
  005a5	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  005a9	8b 0d 3c 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+60
  005af	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170601
  005ba	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170602
  005c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170603
  005d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  005e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170604
  005e9	ba fd 07 00 00	 mov	 edx, 2045		; 000007fdH
  005ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170605
  005f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@cckd_write:

; 2045 :                     cckdblk.gca, cckdblk.gcs, cckdblk.gcmax );
; 2046 : 
; 2047 :             ++cckdblk.gcs;

  005fb	8b 05 38 00 00
	00		 mov	 eax, DWORD PTR cckdblk+56
  00601	ff c0		 inc	 eax
  00603	89 05 38 00 00
	00		 mov	 DWORD PTR cckdblk+56, eax

; 2048 : 
; 2049 :             /* Release lock across thread create to prevent interlock  */
; 2050 :             release_lock( &cckdblk.gclock );

  00609	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170606
  00610	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  00617	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2051 :             {
; 2052 :                 rc = create_thread( &tid, JOINABLE, cckd_gcol, NULL, CCKD_GC_THREAD_NAME );

  0061d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00624	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  0062a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170607
  00631	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00636	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170608
  0063d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00642	45 33 c9	 xor	 r9d, r9d
  00645	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cckd_gcol
  0064c	48 8b d0	 mov	 rdx, rax
  0064f	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR tid$[rsp]
  00657	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  0065d	89 84 24 b4 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2053 :             }
; 2054 :             obtain_lock( &cckdblk.gclock );

  00664	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170609
  0066b	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  00672	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2055 : 
; 2056 :             if (rc)

  00678	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00680	0f 84 a7 00 00
	00		 je	 $LN14@cckd_write

; 2057 :             {
; 2058 :                 // "Error in function create_thread() for %s %d of %d: %s"
; 2059 :                 WRMSG( HHC00106, "E", CCKD_GC_THREAD_NAME "()",

  00686	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR rc$[rsp]
  0068d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00693	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv326[rsp], rax
  0069b	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+56
  006a1	ff c9		 dec	 ecx
  006a3	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv330[rsp], ecx
  006aa	b9 01 00 00 00	 mov	 ecx, 1
  006af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006b5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv326[rsp]
  006bd	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006c2	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+64
  006c8	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  006cc	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv330[rsp]
  006d3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170611
  006de	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170612
  006ea	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170613
  006f6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00700	41 b9 03 00 00
	00		 mov	 r9d, 3
  00706	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170614
  0070d	ba 0c 08 00 00	 mov	 edx, 2060		; 0000080cH
  00712	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170615
  00719	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2060 :                     cckdblk.gcs-1, cckdblk.gcmax, strerror( rc ));
; 2061 : 
; 2062 :                 --cckdblk.gcs;

  0071f	8b 05 38 00 00
	00		 mov	 eax, DWORD PTR cckdblk+56
  00725	ff c8		 dec	 eax
  00727	89 05 38 00 00
	00		 mov	 DWORD PTR cckdblk+56, eax
$LN14@cckd_write:
$LN11@cckd_write:

; 2063 :             }
; 2064 :         }
; 2065 :     }
; 2066 :     release_lock( &cckdblk.gclock );

  0072d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170616
  00734	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  0073b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2067 : 
; 2068 :     obtain_lock( &cckd->cckdiolock );

  00741	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00746	48 83 c0 18	 add	 rax, 24
  0074a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170617
  00751	48 8b c8	 mov	 rcx, rax
  00754	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2069 :     {
; 2070 :         cache_lock( CACHE_DEVBUF );

  0075a	33 c9		 xor	 ecx, ecx
  0075c	e8 00 00 00 00	 call	 cache_lock

; 2071 :         {
; 2072 :             flag = cache_setflag( CACHE_DEVBUF, o, ~CCKD_CACHE_WRITING, 0 );

  00761	45 33 c9	 xor	 r9d, r9d
  00764	41 b8 ff ff ff
	df		 mov	 r8d, -536870913		; dfffffffH
  0076a	8b 94 24 08 01
	01 00		 mov	 edx, DWORD PTR o$[rsp]
  00771	33 c9		 xor	 ecx, ecx
  00773	e8 00 00 00 00	 call	 cache_setflag
  00778	89 84 24 bc 00
	00 00		 mov	 DWORD PTR flag$[rsp], eax

; 2073 :         }
; 2074 :         cache_unlock( CACHE_DEVBUF );

  0077f	33 c9		 xor	 ecx, ecx
  00781	e8 00 00 00 00	 call	 cache_unlock

; 2075 : 
; 2076 :         cckd->wrpending--;

  00786	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0078b	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  0078e	ff c8		 dec	 eax
  00790	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00795	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 2077 : 
; 2078 :         if (1
; 2079 :             && cckd->cckdwaiters
; 2080 :             && (0

  00798	33 c0		 xor	 eax, eax
  0079a	83 f8 01	 cmp	 eax, 1
  0079d	0f 84 83 00 00
	00		 je	 $LN15@cckd_write
  007a3	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  007a8	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  007ac	74 78		 je	 SHORT $LN15@cckd_write
  007ae	33 c0		 xor	 eax, eax
  007b0	85 c0		 test	 eax, eax
  007b2	75 1b		 jne	 SHORT $LN16@cckd_write
  007b4	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR flag$[rsp]
  007bb	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  007c0	85 c0		 test	 eax, eax
  007c2	75 0b		 jne	 SHORT $LN16@cckd_write
  007c4	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  007c9	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  007cd	75 57		 jne	 SHORT $LN15@cckd_write
$LN16@cckd_write:

; 2081 :                 || (flag & CCKD_CACHE_IOWAIT)
; 2082 :                 || !cckd->wrpending
; 2083 :                )
; 2084 :         )
; 2085 :         {
; 2086 :             CCKD_TRACE( "writer[%d] cache[%2.2d] %d signalling write complete",

  007cf	8b 44 24 7c	 mov	 eax, DWORD PTR trk$[rsp]
  007d3	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  007d7	8b 84 24 08 01
	01 00		 mov	 eax, DWORD PTR o$[rsp]
  007de	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  007e2	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR writer$[rsp]
  007e9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  007ed	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170620
  007f4	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  007fc	ba 27 08 00 00	 mov	 edx, 2087		; 00000827H
  00801	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170621
  00808	e8 00 00 00 00	 call	 cckd_trace

; 2087 :                        writer, o, trk );
; 2088 : 
; 2089 :             broadcast_condition( &cckd->cckdiocond );

  0080d	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00812	48 83 c0 20	 add	 rax, 32			; 00000020H
  00816	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170622
  0081d	48 8b c8	 mov	 rcx, rax
  00820	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN15@cckd_write:

; 2090 :         }
; 2091 :     }
; 2092 :     release_lock( &cckd->cckdiolock );

  00826	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0082b	48 83 c0 18	 add	 rax, 24
  0082f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170623
  00836	48 8b c8	 mov	 rcx, rax
  00839	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2093 : 
; 2094 :     CCKD_TRACE( "%d wrtrk[%2.2d] %d complete flags:%8.8x",

  0083f	8b 94 24 08 01
	01 00		 mov	 edx, DWORD PTR o$[rsp]
  00846	33 c9		 xor	 ecx, ecx
  00848	e8 00 00 00 00	 call	 cache_getflag
  0084d	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00851	8b 44 24 7c	 mov	 eax, DWORD PTR trk$[rsp]
  00855	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00859	8b 84 24 08 01
	01 00		 mov	 eax, DWORD PTR o$[rsp]
  00860	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00864	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR writer$[rsp]
  0086b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0086f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170624
  00876	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0087e	ba 2f 08 00 00	 mov	 edx, 2095		; 0000082fH
  00883	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170625
  0088a	e8 00 00 00 00	 call	 cckd_trace
$LN1@cckd_write:

; 2095 :                 writer, o, trk, cache_getflag( CACHE_DEVBUF, o ));
; 2096 : 
; 2097 : } /* end function cckd_writer_write */

  0088f	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00897	48 33 cc	 xor	 rcx, rsp
  0089a	e8 00 00 00 00	 call	 __security_check_cookie
  0089f	48 81 c4 f8 00
	01 00		 add	 rsp, 65784		; 000100f8H
  008a6	c3		 ret	 0
cckd_writer_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
tv78 = 32
o$ = 64
ix$ = 72
i$ = 80
data$ = 88
cckd_writer_scan PROC

; 1925 : {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@cckd_write:

; 1926 :     UNREFERENCED( data );

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@cckd_write

; 1927 : 
; 1928 :     if (1
; 1929 :         && (cache_getflag( ix, i ) & DEVBUF_TYPE_COMP)
; 1930 :         && (cache_getflag( ix, i ) & CCKD_CACHE_WRITE)
; 1931 :         && (0

  0001d	33 c0		 xor	 eax, eax
  0001f	83 f8 01	 cmp	 eax, 1
  00022	74 71		 je	 SHORT $LN5@cckd_write
  00024	8b 54 24 50	 mov	 edx, DWORD PTR i$[rsp]
  00028	8b 4c 24 48	 mov	 ecx, DWORD PTR ix$[rsp]
  0002c	e8 00 00 00 00	 call	 cache_getflag
  00031	83 e0 40	 and	 eax, 64			; 00000040H
  00034	85 c0		 test	 eax, eax
  00036	74 5d		 je	 SHORT $LN5@cckd_write
  00038	8b 54 24 50	 mov	 edx, DWORD PTR i$[rsp]
  0003c	8b 4c 24 48	 mov	 ecx, DWORD PTR ix$[rsp]
  00040	e8 00 00 00 00	 call	 cache_getflag
  00045	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0004a	85 c0		 test	 eax, eax
  0004c	74 47		 je	 SHORT $LN5@cckd_write
  0004e	33 c0		 xor	 eax, eax
  00050	85 c0		 test	 eax, eax
  00052	75 36		 jne	 SHORT $LN6@cckd_write
  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  00059	83 38 ff	 cmp	 DWORD PTR [rax], -1
  0005c	74 2c		 je	 SHORT $LN6@cckd_write
  0005e	8b 54 24 50	 mov	 edx, DWORD PTR i$[rsp]
  00062	8b 4c 24 48	 mov	 ecx, DWORD PTR ix$[rsp]
  00066	e8 00 00 00 00	 call	 cache_getage
  0006b	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR o$[rsp]
  00075	8b 11		 mov	 edx, DWORD PTR [rcx]
  00077	8b 4c 24 48	 mov	 ecx, DWORD PTR ix$[rsp]
  0007b	e8 00 00 00 00	 call	 cache_getage
  00080	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv78[rsp]
  00085	48 3b c8	 cmp	 rcx, rax
  00088	73 0b		 jae	 SHORT $LN5@cckd_write
$LN6@cckd_write:

; 1932 :             || *o == -1
; 1933 :             || cache_getage( ix, i ) < cache_getage( ix, *o )
; 1934 :            )
; 1935 :     )
; 1936 :         *o = i;

  0008a	48 8b 44 24 40	 mov	 rax, QWORD PTR o$[rsp]
  0008f	8b 4c 24 50	 mov	 ecx, DWORD PTR i$[rsp]
  00093	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@cckd_write:

; 1937 : 
; 1938 :     return 0;

  00095	33 c0		 xor	 eax, eax

; 1939 : }

  00097	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009b	c3		 ret	 0
cckd_writer_scan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
writer$ = 96
o$ = 100
rc$ = 104
tv88 = 108
tv93 = 112
tv141 = 116
tv147 = 120
tv166 = 124
tv171 = 128
tv274 = 132
tv297 = 136
tv302 = 140
wrs$ = 144
tid$ = 148
tv270 = 152
threadname$ = 160
__$ArrayPad$ = 200
arg$ = 224
cckd_writer PROC

; 1777 : {

$LN32:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@cckd_write:

; 1778 : int             writer;                 /* Writer identifier         */
; 1779 : int             o;                      /* Cache entry found         */
; 1780 : TID             tid;                    /* Writer thead id           */
; 1781 : char            threadname[40];
; 1782 : int             rc;
; 1783 : int             wrs;
; 1784 : 
; 1785 :     UNREFERENCED( arg );

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN4@cckd_write

; 1786 : 
; 1787 :     /* Set the writer thread's priority just BELOW the CPU threads'
; 1788 :        in order to minimize any potential impact from compression.
; 1789 :     */
; 1790 :     if (!cckdblk.batch)

  00024	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  0002a	83 e0 01	 and	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	75 30		 jne	 SHORT $LN7@cckd_write

; 1791 :     {
; 1792 :         cckdblk.wrprio = sysblk.cpuprio - 1;

  00031	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00038	8b 80 6c 13 00
	00		 mov	 eax, DWORD PTR [rax+4972]
  0003e	ff c8		 dec	 eax
  00040	89 05 74 00 00
	00		 mov	 DWORD PTR cckdblk+116, eax

; 1793 :         set_thread_priority( cckdblk.wrprio );

  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0004c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170476
  00053	8b 15 74 00 00
	00		 mov	 edx, DWORD PTR cckdblk+116
  00059	8b c8		 mov	 ecx, eax
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_prio
$LN7@cckd_write:

; 1794 :     }
; 1795 : 
; 1796 :     obtain_lock( &cckdblk.wrlock );

  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170477
  00068	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1797 : 
; 1798 :     writer = ++cckdblk.wra;

  00075	8b 05 6c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+108
  0007b	ff c0		 inc	 eax
  0007d	89 05 6c 00 00
	00		 mov	 DWORD PTR cckdblk+108, eax
  00083	8b 05 6c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+108
  00089	89 44 24 60	 mov	 DWORD PTR writer$[rsp], eax

; 1799 :     MSGBUF( threadname, CCKD_WR_THREAD_NAME " thread %d", writer );

  0008d	44 8b 4c 24 60	 mov	 r9d, DWORD PTR writer$[rsp]
  00092	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170478
  00099	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0009e	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1800 : 
; 1801 :     /* Return with message if too many already started */
; 1802 :     if (writer > cckdblk.wrmax)

  000ac	8b 05 70 00 00
	00		 mov	 eax, DWORD PTR cckdblk+112
  000b2	39 44 24 60	 cmp	 DWORD PTR writer$[rsp], eax
  000b6	0f 8e b1 01 00
	00		 jle	 $LN8@cckd_write

; 1803 :     {
; 1804 :         --cckdblk.wrs;  /* decrease threads started */

  000bc	8b 05 68 00 00
	00		 mov	 eax, DWORD PTR cckdblk+104
  000c2	ff c8		 dec	 eax
  000c4	89 05 68 00 00
	00		 mov	 DWORD PTR cckdblk+104, eax

; 1805 :         --cckdblk.wra;  /* decrease threads active  */

  000ca	8b 05 6c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+108
  000d0	ff c8		 dec	 eax
  000d2	89 05 6c 00 00
	00		 mov	 DWORD PTR cckdblk+108, eax

; 1806 : 
; 1807 :         if (!cckdblk.wrmax)  /* choose thread termination message  */

  000d8	83 3d 70 00 00
	00 00		 cmp	 DWORD PTR cckdblk+112, 0
  000df	0f 85 a6 00 00
	00		 jne	 $LN9@cckd_write

; 1808 :         {
; 1809 :             if (!cckdblk.batch || cckdblk.batchml > 1)

  000e5	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  000eb	83 e0 01	 and	 eax, 1
  000ee	85 c0		 test	 eax, eax
  000f0	74 0d		 je	 SHORT $LN12@cckd_write
  000f2	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  000f9	0f 8e 87 00 00
	00		 jle	 $LN11@cckd_write
$LN12@cckd_write:

; 1810 :               // "Thread id "TIDPAT", prio %d, name '%s' ended"
; 1811 :               LOG_THREAD_END( threadname  );

  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00105	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170484
  0010c	8b c8		 mov	 ecx, eax
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  00114	89 44 24 6c	 mov	 DWORD PTR tv88[rsp], eax
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0011e	89 44 24 70	 mov	 DWORD PTR tv93[rsp], eax
  00122	b9 01 00 00 00	 mov	 ecx, 1
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012d	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  00135	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0013a	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv88[rsp]
  0013e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00142	8b 4c 24 70	 mov	 ecx, DWORD PTR tv93[rsp]
  00146	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170485
  00151	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170486
  0015d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00162	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00167	41 b9 03 00 00
	00		 mov	 r9d, 3
  0016d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170487
  00174	ba 13 07 00 00	 mov	 edx, 1811		; 00000713H
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170488
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN11@cckd_write:

; 1812 :         }

  00186	e9 b3 00 00 00	 jmp	 $LN10@cckd_write
$LN9@cckd_write:

; 1813 :         else
; 1814 :             if (!cckdblk.batch || cckdblk.batchml > 0)

  0018b	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00191	83 e0 01	 and	 eax, 1
  00194	85 c0		 test	 eax, eax
  00196	74 0d		 je	 SHORT $LN14@cckd_write
  00198	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR cckdblk+24, 0
  0019f	0f 8e 99 00 00
	00		 jle	 $LN13@cckd_write
$LN14@cckd_write:

; 1815 :                 // "Ending thread "TIDPAT" %s, pri=%d, started=%d, max=%d exceeded"
; 1816 :                 WRMSG( HHC00108, "W", TID_CAST( thread_id()), threadname,

  001a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  001ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170491
  001b2	8b c8		 mov	 ecx, eax
  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  001ba	89 44 24 74	 mov	 DWORD PTR tv141[rsp], eax
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  001c4	89 44 24 78	 mov	 DWORD PTR tv147[rsp], eax
  001c8	b9 01 00 00 00	 mov	 ecx, 1
  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001d3	8b 0d 70 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+112
  001d9	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  001dd	8b 4c 24 60	 mov	 ecx, DWORD PTR writer$[rsp]
  001e1	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  001e5	8b 4c 24 74	 mov	 ecx, DWORD PTR tv141[rsp]
  001e9	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001ed	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  001f5	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001fa	8b 4c 24 78	 mov	 ecx, DWORD PTR tv147[rsp]
  001fe	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170492
  00209	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170493
  00215	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0021f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00225	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170494
  0022c	ba 19 07 00 00	 mov	 edx, 1817		; 00000719H
  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170495
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@cckd_write:
$LN10@cckd_write:

; 1817 :                 get_thread_priority(), writer, cckdblk.wrmax );
; 1818 : 
; 1819 :         release_lock( &cckdblk.wrlock );

  0023e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170496
  00245	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1820 :         signal_condition( &cckdblk.termcond );/* shutting down */

  00252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170497
  00259	48 8d 0d 60 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+608
  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 1821 :         return NULL;

  00266	33 c0		 xor	 eax, eax
  00268	e9 9a 04 00 00	 jmp	 $LN1@cckd_write
$LN8@cckd_write:

; 1822 :     }
; 1823 : 
; 1824 :     if (!cckdblk.batch || cckdblk.batchml > 1)

  0026d	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00273	83 e0 01	 and	 eax, 1
  00276	85 c0		 test	 eax, eax
  00278	74 0d		 je	 SHORT $LN16@cckd_write
  0027a	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  00281	0f 8e 8d 00 00
	00		 jle	 $LN15@cckd_write
$LN16@cckd_write:

; 1825 :         // "Thread id "TIDPAT", prio %d, name '%s' started"
; 1826 :         LOG_THREAD_BEGIN( threadname  );

  00287	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0028d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170500
  00294	8b c8		 mov	 ecx, eax
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  0029c	89 44 24 7c	 mov	 DWORD PTR tv166[rsp], eax
  002a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  002a6	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv171[rsp], eax
  002ad	b9 01 00 00 00	 mov	 ecx, 1
  002b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b8	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  002c0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002c5	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv166[rsp]
  002c9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002cd	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv171[rsp]
  002d4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170501
  002df	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170502
  002eb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f5	41 b9 03 00 00
	00		 mov	 r9d, 3
  002fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170503
  00302	ba 22 07 00 00	 mov	 edx, 1826		; 00000722H
  00307	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170504
  0030e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN15@cckd_write:
$LN31@cckd_write:
$LN5@cckd_write:

; 1827 : 
; 1828 :     while (writer <= cckdblk.wrmax || cckdblk.wrpending)

  00314	8b 05 70 00 00
	00		 mov	 eax, DWORD PTR cckdblk+112
  0031a	39 44 24 60	 cmp	 DWORD PTR writer$[rsp], eax
  0031e	7e 0d		 jle	 SHORT $LN17@cckd_write
  00320	83 3d 60 00 00
	00 00		 cmp	 DWORD PTR cckdblk+96, 0
  00327	0f 84 d0 02 00
	00		 je	 $LN6@cckd_write
$LN17@cckd_write:

; 1829 :     {
; 1830 :         /* Wait for work */
; 1831 :         if (cckdblk.wrpending == 0)

  0032d	83 3d 60 00 00
	00 00		 cmp	 DWORD PTR cckdblk+96, 0
  00334	75 37		 jne	 SHORT $LN18@cckd_write

; 1832 :         {
; 1833 :             cckdblk.wrwaiting++;

  00336	8b 05 64 00 00
	00		 mov	 eax, DWORD PTR cckdblk+100
  0033c	ff c0		 inc	 eax
  0033e	89 05 64 00 00
	00		 mov	 DWORD PTR cckdblk+100, eax

; 1834 :             {
; 1835 :                 wait_condition( &cckdblk.wrcond, &cckdblk.wrlock );

  00344	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170507
  0034b	48 8d 15 50 00
	00 00		 lea	 rdx, OFFSET FLAT:cckdblk+80
  00352	48 8d 0d 58 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+88
  00359	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 1836 :             }
; 1837 :             cckdblk.wrwaiting--;

  0035f	8b 05 64 00 00
	00		 mov	 eax, DWORD PTR cckdblk+100
  00365	ff c8		 dec	 eax
  00367	89 05 64 00 00
	00		 mov	 DWORD PTR cckdblk+100, eax
$LN18@cckd_write:

; 1838 :         }
; 1839 : 
; 1840 :         /* Scan the cache for the oldest pending write */
; 1841 :         cache_lock( CACHE_DEVBUF );

  0036d	33 c9		 xor	 ecx, ecx
  0036f	e8 00 00 00 00	 call	 cache_lock

; 1842 :         {
; 1843 :             o = cache_scan( CACHE_DEVBUF, cckd_writer_scan, NULL );

  00374	45 33 c0	 xor	 r8d, r8d
  00377	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cckd_writer_scan
  0037e	33 c9		 xor	 ecx, ecx
  00380	e8 00 00 00 00	 call	 cache_scan
  00385	89 44 24 64	 mov	 DWORD PTR o$[rsp], eax

; 1844 : 
; 1845 :             /* Possibly shutting down if no writes pending */
; 1846 :             if (o < 0)

  00389	83 7c 24 64 00	 cmp	 DWORD PTR o$[rsp], 0
  0038e	7d 16		 jge	 SHORT $LN19@cckd_write

; 1847 :             {
; 1848 :                 cache_unlock( CACHE_DEVBUF );

  00390	33 c9		 xor	 ecx, ecx
  00392	e8 00 00 00 00	 call	 cache_unlock

; 1849 :                 cckdblk.wrpending = 0;

  00397	c7 05 60 00 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+96, 0

; 1850 :                 continue;

  003a1	e9 6e ff ff ff	 jmp	 $LN5@cckd_write
$LN19@cckd_write:

; 1851 :             }
; 1852 : 
; 1853 :             /* We will process this cache entry. Clear flags to prevent
; 1854 :                any other writer threads from trying to process it too. */
; 1855 :             cache_setflag( CACHE_DEVBUF, o, ~CCKD_CACHE_WRITE, CCKD_CACHE_WRITING );

  003a6	41 b9 00 00 00
	20		 mov	 r9d, 536870912		; 20000000H
  003ac	41 b8 ff ff ff
	fb		 mov	 r8d, -67108865		; fbffffffH
  003b2	8b 54 24 64	 mov	 edx, DWORD PTR o$[rsp]
  003b6	33 c9		 xor	 ecx, ecx
  003b8	e8 00 00 00 00	 call	 cache_setflag

; 1856 :         }
; 1857 :         cache_unlock (CACHE_DEVBUF);

  003bd	33 c9		 xor	 ecx, ecx
  003bf	e8 00 00 00 00	 call	 cache_unlock

; 1858 : 
; 1859 :         /* Schedule the other writers if any writes are still pending */
; 1860 : 
; 1861 :         cckdblk.wrpending--;

  003c4	8b 05 60 00 00
	00		 mov	 eax, DWORD PTR cckdblk+96
  003ca	ff c8		 dec	 eax
  003cc	89 05 60 00 00
	00		 mov	 DWORD PTR cckdblk+96, eax

; 1862 : 
; 1863 :         if (cckdblk.wrpending)

  003d2	83 3d 60 00 00
	00 00		 cmp	 DWORD PTR cckdblk+96, 0
  003d9	0f 84 e4 01 00
	00		 je	 $LN20@cckd_write

; 1864 :         {
; 1865 :             if (cckdblk.wrwaiting)

  003df	83 3d 64 00 00
	00 00		 cmp	 DWORD PTR cckdblk+100, 0
  003e6	74 19		 je	 SHORT $LN21@cckd_write

; 1866 :             {
; 1867 :                 signal_condition( &cckdblk.wrcond );

  003e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170512
  003ef	48 8d 0d 58 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+88
  003f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 1868 :             }

  003fc	e9 c2 01 00 00	 jmp	 $LN22@cckd_write
$LN21@cckd_write:

; 1869 :             else if (cckdblk.wrs < cckdblk.wrmax)

  00401	8b 05 70 00 00
	00		 mov	 eax, DWORD PTR cckdblk+112
  00407	39 05 68 00 00
	00		 cmp	 DWORD PTR cckdblk+104, eax
  0040d	0f 8d b0 01 00
	00		 jge	 $LN23@cckd_write

; 1870 :             {
; 1871 :                 /* Schedule a new writer thread */
; 1872 : 
; 1873 :                 if (!cckdblk.batch || cckdblk.batchml > 1)

  00413	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00419	83 e0 01	 and	 eax, 1
  0041c	85 c0		 test	 eax, eax
  0041e	74 09		 je	 SHORT $LN25@cckd_write
  00420	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  00427	7e 71		 jle	 SHORT $LN24@cckd_write
$LN25@cckd_write:

; 1874 :                     // "Starting thread %s, active=%d, started=%d, max=%d"
; 1875 :                     WRMSG( HHC00107, "I", CCKD_WR_THREAD_NAME "() from " CCKD_WR_THREAD_NAME "()",

  00429	b9 01 00 00 00	 mov	 ecx, 1
  0042e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00434	8b 0d 70 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+112
  0043a	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0043e	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+104
  00444	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00448	8b 0d 6c 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+108
  0044e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00452	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170516
  00459	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0045e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170517
  00465	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0046a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170518
  00471	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00476	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0047b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00481	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170519
  00488	ba 54 07 00 00	 mov	 edx, 1876		; 00000754H
  0048d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170520
  00494	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN24@cckd_write:

; 1876 :                         cckdblk.wra, cckdblk.wrs, cckdblk.wrmax );
; 1877 : 
; 1878 :                 ++cckdblk.wrs;

  0049a	8b 05 68 00 00
	00		 mov	 eax, DWORD PTR cckdblk+104
  004a0	ff c0		 inc	 eax
  004a2	89 05 68 00 00
	00		 mov	 DWORD PTR cckdblk+104, eax

; 1879 : 
; 1880 :                 /* Release lock across thread create to prevent interlock  */
; 1881 :                 release_lock( &cckdblk.wrlock );

  004a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170521
  004af	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  004b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1882 :                 {
; 1883 :                     rc = create_thread( &tid, JOINABLE, cckd_writer, NULL, CCKD_WR_THREAD_NAME );

  004bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004c3	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  004c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170522
  004d0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170523
  004dc	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004e1	45 33 c9	 xor	 r9d, r9d
  004e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cckd_writer
  004eb	48 8b d0	 mov	 rdx, rax
  004ee	48 8d 8c 24 94
	00 00 00	 lea	 rcx, QWORD PTR tid$[rsp]
  004f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  004fc	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 1884 :                 }
; 1885 :                 obtain_lock( &cckdblk.wrlock );

  00500	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170524
  00507	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  0050e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1886 : 
; 1887 :                 if (rc)

  00514	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  00519	0f 84 a4 00 00
	00		 je	 $LN26@cckd_write

; 1888 :                 {
; 1889 :                     // "Error in function create_thread() for %s %d of %d: %s"
; 1890 :                     WRMSG( HHC00106, "E", CCKD_WR_THREAD_NAME "() from " CCKD_WR_THREAD_NAME "()",

  0051f	8b 4c 24 68	 mov	 ecx, DWORD PTR rc$[rsp]
  00523	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00529	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv270[rsp], rax
  00531	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+104
  00537	ff c9		 dec	 ecx
  00539	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv274[rsp], ecx
  00540	b9 01 00 00 00	 mov	 ecx, 1
  00545	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0054b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv270[rsp]
  00553	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00558	8b 0d 70 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+112
  0055e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00562	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv274[rsp]
  00569	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0056d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170526
  00574	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00579	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170527
  00580	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00585	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170528
  0058c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00591	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00596	41 b9 03 00 00
	00		 mov	 r9d, 3
  0059c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170529
  005a3	ba 63 07 00 00	 mov	 edx, 1891		; 00000763H
  005a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170530
  005af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1891 :                         cckdblk.wrs-1, cckdblk.wrmax, strerror( rc ));
; 1892 : 
; 1893 :                     --cckdblk.wrs;

  005b5	8b 05 68 00 00
	00		 mov	 eax, DWORD PTR cckdblk+104
  005bb	ff c8		 dec	 eax
  005bd	89 05 68 00 00
	00		 mov	 DWORD PTR cckdblk+104, eax
$LN26@cckd_write:
$LN23@cckd_write:
$LN22@cckd_write:
$LN20@cckd_write:

; 1894 :                 }
; 1895 :             }
; 1896 :         }
; 1897 : 
; 1898 :         /* Write the updated track image */
; 1899 :         release_lock( &cckdblk.wrlock );

  005c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170531
  005ca	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  005d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1900 :         {
; 1901 :             cckd_writer_write( writer, o );

  005d7	8b 54 24 64	 mov	 edx, DWORD PTR o$[rsp]
  005db	8b 4c 24 60	 mov	 ecx, DWORD PTR writer$[rsp]
  005df	e8 00 00 00 00	 call	 cckd_writer_write

; 1902 :         }
; 1903 :         obtain_lock( &cckdblk.wrlock );

  005e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170532
  005eb	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  005f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1904 :     }

  005f8	e9 17 fd ff ff	 jmp	 $LN31@cckd_write
$LN6@cckd_write:

; 1905 :     /* end while (writer <= cckdblk.wrmax || cckdblk.wrpending) */
; 1906 : 
; 1907 :     if (!cckdblk.batch || cckdblk.batchml > 1)

  005fd	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00603	83 e0 01	 and	 eax, 1
  00606	85 c0		 test	 eax, eax
  00608	74 0d		 je	 SHORT $LN28@cckd_write
  0060a	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  00611	0f 8e 93 00 00
	00		 jle	 $LN27@cckd_write
$LN28@cckd_write:

; 1908 :         // "Thread id "TIDPAT", prio %d, name '%s' ended"
; 1909 :         LOG_THREAD_END( threadname  );

  00617	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0061d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170535
  00624	8b c8		 mov	 ecx, eax
  00626	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  0062c	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv297[rsp], eax
  00633	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00639	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv302[rsp], eax
  00640	b9 01 00 00 00	 mov	 ecx, 1
  00645	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0064b	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  00653	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00658	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv297[rsp]
  0065f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00663	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv302[rsp]
  0066a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0066e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170536
  00675	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0067a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170537
  00681	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00686	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0068b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00691	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170538
  00698	ba 75 07 00 00	 mov	 edx, 1909		; 00000775H
  0069d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170539
  006a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN27@cckd_write:

; 1910 : 
; 1911 :     cckdblk.wrs--;

  006aa	8b 05 68 00 00
	00		 mov	 eax, DWORD PTR cckdblk+104
  006b0	ff c8		 dec	 eax
  006b2	89 05 68 00 00
	00		 mov	 DWORD PTR cckdblk+104, eax

; 1912 :     cckdblk.wra--;

  006b8	8b 05 6c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+108
  006be	ff c8		 dec	 eax
  006c0	89 05 6c 00 00
	00		 mov	 DWORD PTR cckdblk+108, eax

; 1913 : 
; 1914 :     wrs = cckdblk.wrs;

  006c6	8b 05 68 00 00
	00		 mov	 eax, DWORD PTR cckdblk+104
  006cc	89 84 24 90 00
	00 00		 mov	 DWORD PTR wrs$[rsp], eax

; 1915 : 
; 1916 :     release_lock( &cckdblk.wrlock );

  006d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170540
  006da	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  006e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1917 : 
; 1918 :     if (!wrs)

  006e7	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR wrs$[rsp], 0
  006ef	75 14		 jne	 SHORT $LN29@cckd_write

; 1919 :         signal_condition( &cckdblk.termcond );

  006f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170542
  006f8	48 8d 0d 60 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+608
  006ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN29@cckd_write:

; 1920 : 
; 1921 :     return NULL;

  00705	33 c0		 xor	 eax, eax
$LN1@cckd_write:

; 1922 : } /* end thread cckd_writer */

  00707	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0070f	48 33 cc	 xor	 rcx, rsp
  00712	e8 00 00 00 00	 call	 __security_check_cookie
  00717	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0071e	c3		 ret	 0
cckd_writer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
devnum$ = 64
trk$ = 68
dev$ = 72
answer$ = 96
ix$ = 104
i$ = 112
data$ = 120
cckd_purge_cache_scan PROC

; 1757 : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1758 : U16             devnum;                 /* Cached device number      */
; 1759 : U32             trk;                    /* Cached track              */
; 1760 : DEVBLK         *dev = data;             /* -> device block           */

  00017	48 8b 44 24 78	 mov	 rax, QWORD PTR data$[rsp]
  0001c	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd_purge:

; 1761 : 
; 1762 :     UNREFERENCED(answer);

  00021	33 c0		 xor	 eax, eax
  00023	85 c0		 test	 eax, eax
  00025	75 fa		 jne	 SHORT $LN4@cckd_purge
$LN7@cckd_purge:

; 1763 :     CCKD_CACHE_GETKEY(i, devnum, trk);

  00027	8b 54 24 70	 mov	 edx, DWORD PTR i$[rsp]
  0002b	33 c9		 xor	 ecx, ecx
  0002d	e8 00 00 00 00	 call	 cache_getkey
  00032	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00036	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  0003c	66 89 44 24 40	 mov	 WORD PTR devnum$[rsp], ax
  00041	8b 54 24 70	 mov	 edx, DWORD PTR i$[rsp]
  00045	33 c9		 xor	 ecx, ecx
  00047	e8 00 00 00 00	 call	 cache_getkey
  0004c	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00051	48 23 c1	 and	 rax, rcx
  00054	89 44 24 44	 mov	 DWORD PTR trk$[rsp], eax
  00058	33 c0		 xor	 eax, eax
  0005a	85 c0		 test	 eax, eax
  0005c	75 c9		 jne	 SHORT $LN7@cckd_purge

; 1764 :     if (dev->devnum == devnum)

  0005e	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00063	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00067	0f b7 4c 24 40	 movzx	 ecx, WORD PTR devnum$[rsp]
  0006c	3b c1		 cmp	 eax, ecx
  0006e	75 46		 jne	 SHORT $LN8@cckd_purge

; 1765 :     {
; 1766 :         cache_release (ix, i, 0);

  00070	45 33 c0	 xor	 r8d, r8d
  00073	8b 54 24 70	 mov	 edx, DWORD PTR i$[rsp]
  00077	8b 4c 24 68	 mov	 ecx, DWORD PTR ix$[rsp]
  0007b	e8 00 00 00 00	 call	 cache_release

; 1767 :         CCKD_TRACE( "purge cache[%d] %4.4X trk %d purged",

  00080	0f b7 44 24 40	 movzx	 eax, WORD PTR devnum$[rsp]
  00085	8b 4c 24 44	 mov	 ecx, DWORD PTR trk$[rsp]
  00089	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0008d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00091	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  00095	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00099	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170451
  000a0	4c 8b 44 24 48	 mov	 r8, QWORD PTR dev$[rsp]
  000a5	ba e8 06 00 00	 mov	 edx, 1768		; 000006e8H
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170452
  000b1	e8 00 00 00 00	 call	 cckd_trace
$LN8@cckd_purge:

; 1768 :                     i, devnum, trk);
; 1769 :     }
; 1770 :     return 0;

  000b6	33 c0		 xor	 eax, eax

; 1771 : }

  000b8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000bc	c3		 ret	 0
cckd_purge_cache_scan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 48
cckd_purge_cache PROC

; 1744 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1745 :     if (dev->cckd64)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	74 0c		 je	 SHORT $LN2@cckd_purge

; 1746 :     {
; 1747 :         cckd64_purge_cache( dev );

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd64_purge_cache

; 1748 :         return;

  00028	eb 21		 jmp	 SHORT $LN1@cckd_purge
$LN2@cckd_purge:

; 1749 :     }
; 1750 : 
; 1751 :     /* Scan cache and purge entries */
; 1752 :     cache_lock (CACHE_DEVBUF);

  0002a	33 c9		 xor	 ecx, ecx
  0002c	e8 00 00 00 00	 call	 cache_lock

; 1753 :     cache_scan (CACHE_DEVBUF, cckd_purge_cache_scan, dev);

  00031	4c 8b 44 24 30	 mov	 r8, QWORD PTR dev$[rsp]
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cckd_purge_cache_scan
  0003d	33 c9		 xor	 ecx, ecx
  0003f	e8 00 00 00 00	 call	 cache_scan

; 1754 :     cache_unlock (CACHE_DEVBUF);

  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 cache_unlock
$LN1@cckd_purge:

; 1755 : }

  0004b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004f	c3		 ret	 0
cckd_purge_cache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 32
cckd$ = 40
cckd_flush_cache_all PROC

; 1721 : {

$LN7:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1722 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 1723 : DEVBLK         *dev = NULL;             /* -> device block           */

  00004	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR dev$[rsp], 0

; 1724 : 
; 1725 :     cckd_lock_devchain(0);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 cckd_lock_devchain

; 1726 :     for (dev = cckdblk.dev1st; dev; dev = cckd->devnext)

  00014	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  0001b	48 89 44 24 20	 mov	 QWORD PTR dev$[rsp], rax
  00020	eb 0d		 jmp	 SHORT $LN4@cckd_flush
$LN2@cckd_flush:
  00022	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 89 44 24 20	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd_flush:
  0002f	48 83 7c 24 20
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00035	74 76		 je	 SHORT $LN3@cckd_flush

; 1727 :     {
; 1728 :         cckd = dev->cckd_ext;

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00043	48 89 44 24 28	 mov	 QWORD PTR cckd$[rsp], rax

; 1729 :         obtain_lock (&cckd->cckdiolock);

  00048	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0004d	48 83 c0 18	 add	 rax, 24
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170423
  00058	48 8b c8	 mov	 rcx, rax
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1730 :         if (!cckd->merging && !cckd->stopping)

  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00066	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00069	c1 e8 05	 shr	 eax, 5
  0006c	83 e0 01	 and	 eax, 1
  0006f	85 c0		 test	 eax, eax
  00071	75 1c		 jne	 SHORT $LN5@cckd_flush
  00073	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00078	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0007b	c1 e8 06	 shr	 eax, 6
  0007e	83 e0 01	 and	 eax, 1
  00081	85 c0		 test	 eax, eax
  00083	75 0a		 jne	 SHORT $LN5@cckd_flush

; 1731 :             cckd_flush_cache(dev);

  00085	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  0008a	e8 00 00 00 00	 call	 cckd_flush_cache
$LN5@cckd_flush:

; 1732 :         release_lock (&cckd->cckdiolock);

  0008f	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00094	48 83 c0 18	 add	 rax, 24
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170425
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1733 :     }

  000a8	e9 75 ff ff ff	 jmp	 $LN2@cckd_flush
$LN3@cckd_flush:

; 1734 :     cckd_unlock_devchain();

  000ad	e8 00 00 00 00	 call	 cckd_unlock_devchain

; 1735 : }

  000b2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b6	c3		 ret	 0
cckd_flush_cache_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
devnum$ = 64
trk$ = 68
cckd$ = 72
dev$ = 80
answer$ = 112
ix$ = 120
i$ = 128
data$ = 136
cckd_flush_cache_scan PROC

; 1699 : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1700 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 1701 : U16             devnum;                 /* Cached device number      */
; 1702 : U32             trk;                    /* Cached track              */
; 1703 : DEVBLK         *dev = data;             /* -> device block           */

  00017	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0001f	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd_flush:

; 1704 : 
; 1705 :     UNREFERENCED(answer);

  00024	33 c0		 xor	 eax, eax
  00026	85 c0		 test	 eax, eax
  00028	75 fa		 jne	 SHORT $LN4@cckd_flush

; 1706 :     cckd = dev->cckd_ext;

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00036	48 89 44 24 48	 mov	 QWORD PTR cckd$[rsp], rax
$LN7@cckd_flush:

; 1707 :     CCKD_CACHE_GETKEY(i, devnum, trk);

  0003b	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00042	33 c9		 xor	 ecx, ecx
  00044	e8 00 00 00 00	 call	 cache_getkey
  00049	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0004d	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00053	66 89 44 24 40	 mov	 WORD PTR devnum$[rsp], ax
  00058	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  0005f	33 c9		 xor	 ecx, ecx
  00061	e8 00 00 00 00	 call	 cache_getkey
  00066	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0006b	48 23 c1	 and	 rax, rcx
  0006e	89 44 24 44	 mov	 DWORD PTR trk$[rsp], eax
  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 c3		 jne	 SHORT $LN7@cckd_flush

; 1708 :     if ((cache_getflag(ix,i) & CACHE_BUSY) == CCKD_CACHE_UPDATED
; 1709 :      && dev->devnum == devnum)

  00078	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  0007f	8b 4c 24 78	 mov	 ecx, DWORD PTR ix$[rsp]
  00083	e8 00 00 00 00	 call	 cache_getflag
  00088	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  0008d	3d 00 00 00 08	 cmp	 eax, 134217728		; 08000000H
  00092	0f 85 97 00 00
	00		 jne	 $LN8@cckd_flush
  00098	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0009d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000a1	0f b7 4c 24 40	 movzx	 ecx, WORD PTR devnum$[rsp]
  000a6	3b c1		 cmp	 eax, ecx
  000a8	0f 85 81 00 00
	00		 jne	 $LN8@cckd_flush

; 1710 :     {
; 1711 :         cache_setflag (ix, i, ~CCKD_CACHE_UPDATED, CCKD_CACHE_WRITE);

  000ae	41 b9 00 00 00
	04		 mov	 r9d, 67108864		; 04000000H
  000b4	41 b8 ff ff ff
	f7		 mov	 r8d, -134217729		; f7ffffffH
  000ba	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  000c1	8b 4c 24 78	 mov	 ecx, DWORD PTR ix$[rsp]
  000c5	e8 00 00 00 00	 call	 cache_setflag

; 1712 :         ++cckd->wrpending;

  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  000cf	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  000d2	ff c0		 inc	 eax
  000d4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cckd$[rsp]
  000d9	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 1713 :         ++cckdblk.wrpending;

  000dc	8b 05 60 00 00
	00		 mov	 eax, DWORD PTR cckdblk+96
  000e2	ff c0		 inc	 eax
  000e4	89 05 60 00 00
	00		 mov	 DWORD PTR cckdblk+96, eax

; 1714 :         CCKD_TRACE( "flush file[%d] cache[%d] %4.4X trk %d",

  000ea	0f b7 44 24 40	 movzx	 eax, WORD PTR devnum$[rsp]
  000ef	8b 4c 24 44	 mov	 ecx, DWORD PTR trk$[rsp]
  000f3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f7	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000fb	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00102	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00106	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  0010b	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0010e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00112	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170414
  00119	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  0011e	ba b3 06 00 00	 mov	 edx, 1715		; 000006b3H
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170415
  0012a	e8 00 00 00 00	 call	 cckd_trace
$LN8@cckd_flush:

; 1715 :                     cckd->sfn, i, devnum, trk);
; 1716 :     }
; 1717 :     return 0;

  0012f	33 c0		 xor	 eax, eax

; 1718 : }

  00131	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00135	c3		 ret	 0
cckd_flush_cache_scan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
rc$ = 96
tv147 = 100
tid$ = 104
tv143 = 112
dev$ = 144
cckd_flush_cache PROC

; 1646 : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1647 : int             rc;                     /* Return code               */
; 1648 : TID             tid;                    /* Writer thread id          */
; 1649 : 
; 1650 :     if (dev->cckd64)

  0000c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00014	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0001b	24 01		 and	 al, 1
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 12		 je	 SHORT $LN2@cckd_flush

; 1651 :     {
; 1652 :         cckd64_flush_cache( dev );

  00024	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 cckd64_flush_cache

; 1653 :         return;

  00031	e9 2e 02 00 00	 jmp	 $LN1@cckd_flush
$LN2@cckd_flush:

; 1654 :     }
; 1655 : 
; 1656 :     /* Scan cache for updated cache entries */
; 1657 :     obtain_lock (&cckdblk.wrlock);

  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170368
  0003d	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1658 :     cache_lock (CACHE_DEVBUF);

  0004a	33 c9		 xor	 ecx, ecx
  0004c	e8 00 00 00 00	 call	 cache_lock

; 1659 :     cache_scan (CACHE_DEVBUF, cckd_flush_cache_scan, dev);

  00051	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cckd_flush_cache_scan
  00060	33 c9		 xor	 ecx, ecx
  00062	e8 00 00 00 00	 call	 cache_scan

; 1660 :     cache_unlock (CACHE_DEVBUF);

  00067	33 c9		 xor	 ecx, ecx
  00069	e8 00 00 00 00	 call	 cache_unlock

; 1661 : 
; 1662 :     /* Schedule the writer if any writes are pending */
; 1663 :     if (cckdblk.wrpending)

  0006e	83 3d 60 00 00
	00 00		 cmp	 DWORD PTR cckdblk+96, 0
  00075	0f 84 d5 01 00
	00		 je	 $LN3@cckd_flush

; 1664 :     {
; 1665 :         if (cckdblk.wrwaiting)

  0007b	83 3d 64 00 00
	00 00		 cmp	 DWORD PTR cckdblk+100, 0
  00082	74 19		 je	 SHORT $LN4@cckd_flush

; 1666 :             signal_condition (&cckdblk.wrcond);

  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170372
  0008b	48 8d 0d 58 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+88
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
  00098	e9 b3 01 00 00	 jmp	 $LN5@cckd_flush
$LN4@cckd_flush:

; 1667 :         else if (cckdblk.wrs < cckdblk.wrmax)

  0009d	8b 05 70 00 00
	00		 mov	 eax, DWORD PTR cckdblk+112
  000a3	39 05 68 00 00
	00		 cmp	 DWORD PTR cckdblk+104, eax
  000a9	0f 8d a1 01 00
	00		 jge	 $LN6@cckd_flush

; 1668 :         {
; 1669 :             /* Schedule a new writer thread  */
; 1670 :             if (!cckdblk.batch || cckdblk.batchml > 1)

  000af	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  000b5	83 e0 01	 and	 eax, 1
  000b8	85 c0		 test	 eax, eax
  000ba	74 09		 je	 SHORT $LN8@cckd_flush
  000bc	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  000c3	7e 71		 jle	 SHORT $LN7@cckd_flush
$LN8@cckd_flush:

; 1671 :                 // "Starting thread %s, active=%d, started=%d, max=%d"
; 1672 :                 WRMSG(HHC00107, "I", CCKD_WR_THREAD_NAME "()",

  000c5	b9 01 00 00 00	 mov	 ecx, 1
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d0	8b 0d 70 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+112
  000d6	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  000da	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+104
  000e0	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000e4	8b 0d 6c 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+108
  000ea	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170376
  000f5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170377
  00101	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170378
  0010d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00112	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00117	41 b9 03 00 00
	00		 mov	 r9d, 3
  0011d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170379
  00124	ba 89 06 00 00	 mov	 edx, 1673		; 00000689H
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170380
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@cckd_flush:

; 1673 :                     cckdblk.wra, cckdblk.wrs, cckdblk.wrmax);
; 1674 : 
; 1675 :             ++cckdblk.wrs;

  00136	8b 05 68 00 00
	00		 mov	 eax, DWORD PTR cckdblk+104
  0013c	ff c0		 inc	 eax
  0013e	89 05 68 00 00
	00		 mov	 DWORD PTR cckdblk+104, eax

; 1676 : 
; 1677 :             /* Release lock across thread create to prevent interlock  */
; 1678 :             release_lock(&cckdblk.wrlock);

  00144	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170381
  0014b	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1679 :             {
; 1680 :                 rc = create_thread( &tid, JOINABLE, cckd_writer, NULL, CCKD_WR_THREAD_NAME );

  00158	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0015f	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170382
  0016c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170383
  00178	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0017d	45 33 c9	 xor	 r9d, r9d
  00180	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cckd_writer
  00187	48 8b d0	 mov	 rdx, rax
  0018a	48 8d 4c 24 68	 lea	 rcx, QWORD PTR tid$[rsp]
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00195	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 1681 :             }
; 1682 :             obtain_lock(&cckdblk.wrlock);

  00199	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170384
  001a0	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1683 : 
; 1684 :             if (rc)

  001ad	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  001b2	0f 84 98 00 00
	00		 je	 $LN9@cckd_flush

; 1685 :             {
; 1686 :                 // "Error in function create_thread() for %s %d of %d: %s"
; 1687 :                 WRMSG(HHC00106, "E", CCKD_WR_THREAD_NAME "()",

  001b8	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001c2	48 89 44 24 70	 mov	 QWORD PTR tv143[rsp], rax
  001c7	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+104
  001cd	ff c9		 dec	 ecx
  001cf	89 4c 24 64	 mov	 DWORD PTR tv147[rsp], ecx
  001d3	b9 01 00 00 00	 mov	 ecx, 1
  001d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001de	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv143[rsp]
  001e3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001e8	8b 0d 70 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+112
  001ee	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001f2	8b 4c 24 64	 mov	 ecx, DWORD PTR tv147[rsp]
  001f6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170386
  00201	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170387
  0020d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170388
  00219	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00223	41 b9 03 00 00
	00		 mov	 r9d, 3
  00229	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170389
  00230	ba 98 06 00 00	 mov	 edx, 1688		; 00000698H
  00235	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170390
  0023c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1688 :                     cckdblk.wrs-1, cckdblk.wrmax, strerror(rc));
; 1689 : 
; 1690 :                 --cckdblk.wrs;

  00242	8b 05 68 00 00
	00		 mov	 eax, DWORD PTR cckdblk+104
  00248	ff c8		 dec	 eax
  0024a	89 05 68 00 00
	00		 mov	 DWORD PTR cckdblk+104, eax
$LN9@cckd_flush:
$LN6@cckd_flush:
$LN5@cckd_flush:
$LN3@cckd_flush:

; 1691 :             }
; 1692 :         }
; 1693 :     }
; 1694 : 
; 1695 :     release_lock (&cckdblk.wrlock);

  00250	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170391
  00257	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  0025e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@cckd_flush:

; 1696 : }

  00264	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0026b	c3		 ret	 0
cckd_flush_cache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
r$ = 96
ra$ = 100
cckd$ = 104
rc$ = 112
tv80 = 116
tv85 = 120
tv133 = 124
tv139 = 128
tv158 = 132
tv163 = 136
tv283 = 140
trk$ = 144
tv325 = 148
tv330 = 152
ras$ = 156
dev$ = 160
tid$ = 168
tv279 = 176
threadname$ = 184
__$ArrayPad$ = 224
arg$ = 256
cckd_ra	PROC

; 1504 : {

$LN35:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@cckd_ra:

; 1505 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 1506 : DEVBLK         *dev;                    /* Readahead devblk          */
; 1507 : int             trk;                    /* Readahead track           */
; 1508 : int             ra;                     /* Readahead index           */
; 1509 : int             r;                      /* Readahead queue index     */
; 1510 : TID             tid;                    /* Readahead thread id       */
; 1511 : char            threadname[40];
; 1512 : int             rc;
; 1513 : int             ras;
; 1514 : 
; 1515 :     UNREFERENCED(arg);

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN4@cckd_ra

; 1516 : 
; 1517 :     obtain_lock(&cckdblk.ralock);

  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170292
  0002b	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1518 : 
; 1519 :     ra = ++cckdblk.raa;  /* increment nr ra threads dispatched */

  00038	8b 05 8c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+140
  0003e	ff c0		 inc	 eax
  00040	89 05 8c 00 00
	00		 mov	 DWORD PTR cckdblk+140, eax
  00046	8b 05 8c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+140
  0004c	89 44 24 64	 mov	 DWORD PTR ra$[rsp], eax

; 1520 :     MSGBUF( threadname, CCKD_RA_THREAD_NAME " thread %d", ra );

  00050	44 8b 4c 24 64	 mov	 r9d, DWORD PTR ra$[rsp]
  00055	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170293
  0005c	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00061	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1521 : 
; 1522 :     /* Return if too many already started */
; 1523 :     if (ra > cckdblk.ramax)

  0006f	8b 05 90 00 00
	00		 mov	 eax, DWORD PTR cckdblk+144
  00075	39 44 24 64	 cmp	 DWORD PTR ra$[rsp], eax
  00079	0f 8e b7 01 00
	00		 jle	 $LN7@cckd_ra

; 1524 :     {
; 1525 :         --cckdblk.ras;  /* decrement count started */

  0007f	8b 05 88 00 00
	00		 mov	 eax, DWORD PTR cckdblk+136
  00085	ff c8		 dec	 eax
  00087	89 05 88 00 00
	00		 mov	 DWORD PTR cckdblk+136, eax

; 1526 :         --cckdblk.raa;  /* decrement count running */

  0008d	8b 05 8c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+140
  00093	ff c8		 dec	 eax
  00095	89 05 8c 00 00
	00		 mov	 DWORD PTR cckdblk+140, eax

; 1527 : 
; 1528 :         if (!cckdblk.ramax)

  0009b	83 3d 90 00 00
	00 00		 cmp	 DWORD PTR cckdblk+144, 0
  000a2	0f 85 a6 00 00
	00		 jne	 $LN8@cckd_ra

; 1529 :         {
; 1530 :             if (!cckdblk.batch || cckdblk.batchml > 1)

  000a8	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  000ae	83 e0 01	 and	 eax, 1
  000b1	85 c0		 test	 eax, eax
  000b3	74 0d		 je	 SHORT $LN11@cckd_ra
  000b5	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  000bc	0f 8e 87 00 00
	00		 jle	 $LN10@cckd_ra
$LN11@cckd_ra:

; 1531 :                 // "Thread id "TIDPAT", prio %d, name '%s' ended"
; 1532 :                 LOG_THREAD_END( threadname );

  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170299
  000cf	8b c8		 mov	 ecx, eax
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  000d7	89 44 24 74	 mov	 DWORD PTR tv80[rsp], eax
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  000e1	89 44 24 78	 mov	 DWORD PTR tv85[rsp], eax
  000e5	b9 01 00 00 00	 mov	 ecx, 1
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f0	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  000f8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000fd	8b 4c 24 74	 mov	 ecx, DWORD PTR tv80[rsp]
  00101	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00105	8b 4c 24 78	 mov	 ecx, DWORD PTR tv85[rsp]
  00109	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170300
  00114	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170301
  00120	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00125	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00130	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170302
  00137	ba fc 05 00 00	 mov	 edx, 1532		; 000005fcH
  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170303
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@cckd_ra:

; 1533 :         }

  00149	e9 b9 00 00 00	 jmp	 $LN9@cckd_ra
$LN8@cckd_ra:

; 1534 :         else
; 1535 :             if (!cckdblk.batch || cckdblk.batchml > 0)

  0014e	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00154	83 e0 01	 and	 eax, 1
  00157	85 c0		 test	 eax, eax
  00159	74 0d		 je	 SHORT $LN13@cckd_ra
  0015b	83 3d 18 00 00
	00 00		 cmp	 DWORD PTR cckdblk+24, 0
  00162	0f 8e 9f 00 00
	00		 jle	 $LN12@cckd_ra
$LN13@cckd_ra:

; 1536 :                 // "Ending thread "TIDPAT" %s, pri=%d, started=%d, max=%d exceeded"
; 1537 :                 WRMSG( HHC00108, "W", TID_CAST( thread_id()), threadname,

  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0016e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170306
  00175	8b c8		 mov	 ecx, eax
  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  0017d	89 44 24 7c	 mov	 DWORD PTR tv133[rsp], eax
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00187	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv139[rsp], eax
  0018e	b9 01 00 00 00	 mov	 ecx, 1
  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00199	8b 0d 90 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+144
  0019f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  001a3	8b 4c 24 64	 mov	 ecx, DWORD PTR ra$[rsp]
  001a7	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  001ab	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv133[rsp]
  001af	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001b3	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  001bb	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001c0	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv139[rsp]
  001c7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170307
  001d2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170308
  001de	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e8	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170309
  001f5	ba 02 06 00 00	 mov	 edx, 1538		; 00000602H
  001fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170310
  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@cckd_ra:
$LN9@cckd_ra:

; 1538 :                     get_thread_priority(), ra, cckdblk.ramax );
; 1539 : 
; 1540 :         release_lock( &cckdblk.ralock );

  00207	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170311
  0020e	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1541 :         signal_condition( &cckdblk.termcond );

  0021b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170312
  00222	48 8d 0d 60 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+608
  00229	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 1542 :         return NULL;

  0022f	33 c0		 xor	 eax, eax
  00231	e9 7f 05 00 00	 jmp	 $LN1@cckd_ra
$LN7@cckd_ra:

; 1543 :     }
; 1544 : 
; 1545 :     if (!cckdblk.batch || cckdblk.batchml > 1)

  00236	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  0023c	83 e0 01	 and	 eax, 1
  0023f	85 c0		 test	 eax, eax
  00241	74 0d		 je	 SHORT $LN15@cckd_ra
  00243	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  0024a	0f 8e 93 00 00
	00		 jle	 $LN14@cckd_ra
$LN15@cckd_ra:

; 1546 :         // "Thread id "TIDPAT", prio %d, name '%s' started"
; 1547 :         LOG_THREAD_BEGIN( threadname );

  00250	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00256	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170315
  0025d	8b c8		 mov	 ecx, eax
  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  00265	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv158[rsp], eax
  0026c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00272	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv163[rsp], eax
  00279	b9 01 00 00 00	 mov	 ecx, 1
  0027e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00284	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  0028c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00291	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv158[rsp]
  00298	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0029c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv163[rsp]
  002a3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170316
  002ae	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170317
  002ba	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c4	41 b9 03 00 00
	00		 mov	 r9d, 3
  002ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170318
  002d1	ba 0b 06 00 00	 mov	 edx, 1547		; 0000060bH
  002d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170319
  002dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@cckd_ra:
$LN34@cckd_ra:
$LN33@cckd_ra:
$LN5@cckd_ra:

; 1548 : 
; 1549 :     while (ra <= cckdblk.ramax)   /* continue until ramax=0 (shutdown) or max reduced by command line */

  002e3	8b 05 90 00 00
	00		 mov	 eax, DWORD PTR cckdblk+144
  002e9	39 44 24 64	 cmp	 DWORD PTR ra$[rsp], eax
  002ed	0f 8f b8 03 00
	00		 jg	 $LN6@cckd_ra

; 1550 :     {
; 1551 :         if (cckdblk.ra1st < 0)

  002f3	83 3d 20 02 00
	00 00		 cmp	 DWORD PTR cckdblk+544, 0
  002fa	7d 37		 jge	 SHORT $LN16@cckd_ra

; 1552 :         {
; 1553 :             cckdblk.rawaiting++;

  002fc	8b 05 94 00 00
	00		 mov	 eax, DWORD PTR cckdblk+148
  00302	ff c0		 inc	 eax
  00304	89 05 94 00 00
	00		 mov	 DWORD PTR cckdblk+148, eax

; 1554 :             wait_condition (&cckdblk.racond, &cckdblk.ralock);

  0030a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170321
  00311	48 8d 15 78 00
	00 00		 lea	 rdx, OFFSET FLAT:cckdblk+120
  00318	48 8d 0d 80 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+128
  0031f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 1555 :             cckdblk.rawaiting--;

  00325	8b 05 94 00 00
	00		 mov	 eax, DWORD PTR cckdblk+148
  0032b	ff c8		 dec	 eax
  0032d	89 05 94 00 00
	00		 mov	 DWORD PTR cckdblk+148, eax
$LN16@cckd_ra:

; 1556 :         }
; 1557 : 
; 1558 :         /* Possibly shutting down if no writes pending */
; 1559 :         if (cckdblk.ra1st < 0)

  00333	83 3d 20 02 00
	00 00		 cmp	 DWORD PTR cckdblk+544, 0
  0033a	7d 02		 jge	 SHORT $LN17@cckd_ra

; 1560 :             continue;

  0033c	eb a5		 jmp	 SHORT $LN5@cckd_ra
$LN17@cckd_ra:

; 1561 : 
; 1562 :         r = cckdblk.ra1st;

  0033e	8b 05 20 02 00
	00		 mov	 eax, DWORD PTR cckdblk+544
  00344	89 44 24 60	 mov	 DWORD PTR r$[rsp], eax

; 1563 :         trk = cckdblk.ra[r].ra_trk;

  00348	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  0034d	48 6b c0 18	 imul	 rax, rax, 24
  00351	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  00358	8b 44 01 08	 mov	 eax, DWORD PTR [rcx+rax+8]
  0035c	89 84 24 90 00
	00 00		 mov	 DWORD PTR trk$[rsp], eax

; 1564 :         dev = cckdblk.ra[r].ra_dev;

  00363	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  00368	48 6b c0 18	 imul	 rax, rax, 24
  0036c	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  00373	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00377	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax

; 1565 : 
; 1566 :         cckd = dev->cckd_ext;

  0037f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00387	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0038e	48 89 44 24 68	 mov	 QWORD PTR cckd$[rsp], rax

; 1567 : 
; 1568 :         /* Requeue the 1st entry to the readahead free queue */
; 1569 :         cckdblk.ra1st = cckdblk.ra[r].ra_idxnxt;

  00393	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  00398	48 6b c0 18	 imul	 rax, rax, 24
  0039c	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  003a3	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  003a7	89 05 20 02 00
	00		 mov	 DWORD PTR cckdblk+544, eax

; 1570 :         if (cckdblk.ra[r].ra_idxnxt > -1)

  003ad	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  003b2	48 6b c0 18	 imul	 rax, rax, 24
  003b6	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  003bd	83 7c 01 10 ff	 cmp	 DWORD PTR [rcx+rax+16], -1
  003c2	7e 2a		 jle	 SHORT $LN18@cckd_ra

; 1571 :             cckdblk.ra[cckdblk.ra[r].ra_idxnxt].ra_idxprv = -1;

  003c4	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  003c9	48 6b c0 18	 imul	 rax, rax, 24
  003cd	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  003d4	48 63 44 01 10	 movsxd	 rax, DWORD PTR [rcx+rax+16]
  003d9	48 6b c0 18	 imul	 rax, rax, 24
  003dd	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  003e4	c7 44 01 0c ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+12], -1
  003ec	eb 0a		 jmp	 SHORT $LN19@cckd_ra
$LN18@cckd_ra:

; 1572 :         else cckdblk.ralast = -1;

  003ee	c7 05 24 02 00
	00 ff ff ff ff	 mov	 DWORD PTR cckdblk+548, -1
$LN19@cckd_ra:

; 1573 :         cckdblk.ra[r].ra_idxnxt = cckdblk.rafree;

  003f8	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  003fd	48 6b c0 18	 imul	 rax, rax, 24
  00401	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  00408	8b 15 28 02 00
	00		 mov	 edx, DWORD PTR cckdblk+552
  0040e	89 54 01 10	 mov	 DWORD PTR [rcx+rax+16], edx

; 1574 :         cckdblk.rafree = r;

  00412	8b 44 24 60	 mov	 eax, DWORD PTR r$[rsp]
  00416	89 05 28 02 00
	00		 mov	 DWORD PTR cckdblk+552, eax

; 1575 : 
; 1576 :         /* Schedule the other readaheads if any are still pending */
; 1577 :         if (cckdblk.ra1st)

  0041c	83 3d 20 02 00
	00 00		 cmp	 DWORD PTR cckdblk+544, 0
  00423	0f 84 e4 01 00
	00		 je	 $LN20@cckd_ra

; 1578 :         {
; 1579 :             if (cckdblk.rawaiting)

  00429	83 3d 94 00 00
	00 00		 cmp	 DWORD PTR cckdblk+148, 0
  00430	74 19		 je	 SHORT $LN21@cckd_ra

; 1580 :                 signal_condition (&cckdblk.racond);

  00432	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170328
  00439	48 8d 0d 80 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+128
  00440	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
  00446	e9 c2 01 00 00	 jmp	 $LN22@cckd_ra
$LN21@cckd_ra:

; 1581 :             else if (cckdblk.ras < cckdblk.ramax)

  0044b	8b 05 90 00 00
	00		 mov	 eax, DWORD PTR cckdblk+144
  00451	39 05 88 00 00
	00		 cmp	 DWORD PTR cckdblk+136, eax
  00457	0f 8d b0 01 00
	00		 jge	 $LN23@cckd_ra

; 1582 :             {
; 1583 :                 /* Schedule a new read-ahead thread  */
; 1584 :                 if (!cckdblk.batch || cckdblk.batchml > 1)

  0045d	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00463	83 e0 01	 and	 eax, 1
  00466	85 c0		 test	 eax, eax
  00468	74 09		 je	 SHORT $LN25@cckd_ra
  0046a	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  00471	7e 71		 jle	 SHORT $LN24@cckd_ra
$LN25@cckd_ra:

; 1585 :                     // "Starting thread %s, active=%d, started=%d, max=%d"
; 1586 :                     WRMSG(HHC00107, "I", CCKD_RA_THREAD_NAME "() from " CCKD_RA_THREAD_NAME "()",

  00473	b9 01 00 00 00	 mov	 ecx, 1
  00478	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0047e	8b 0d 90 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+144
  00484	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00488	8b 0d 88 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+136
  0048e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00492	8b 0d 8c 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+140
  00498	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0049c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170332
  004a3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170333
  004af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170334
  004bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  004cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170335
  004d2	ba 33 06 00 00	 mov	 edx, 1587		; 00000633H
  004d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170336
  004de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN24@cckd_ra:

; 1587 :                         cckdblk.raa, cckdblk.ras, cckdblk.ramax);
; 1588 : 
; 1589 :                 ++cckdblk.ras;

  004e4	8b 05 88 00 00
	00		 mov	 eax, DWORD PTR cckdblk+136
  004ea	ff c0		 inc	 eax
  004ec	89 05 88 00 00
	00		 mov	 DWORD PTR cckdblk+136, eax

; 1590 : 
; 1591 :                 /* Release lock across thread create to prevent interlock  */
; 1592 :                 release_lock(&cckdblk.ralock);

  004f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170337
  004f9	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  00500	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1593 :                 {
; 1594 :                     rc = create_thread( &tid, JOINABLE, cckd_ra, NULL, CCKD_RA_THREAD_NAME );

  00506	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0050d	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  00513	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170338
  0051a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0051f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170339
  00526	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0052b	45 33 c9	 xor	 r9d, r9d
  0052e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cckd_ra
  00535	48 8b d0	 mov	 rdx, rax
  00538	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR tid$[rsp]
  00540	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00546	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 1595 :                 }
; 1596 :                 obtain_lock(&cckdblk.ralock);

  0054a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170340
  00551	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  00558	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1597 : 
; 1598 :                 if (rc)

  0055e	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00563	0f 84 a4 00 00
	00		 je	 $LN26@cckd_ra

; 1599 :                 {
; 1600 :                     // "Error in function create_thread() for %s %d of %d: %s"
; 1601 :                     WRMSG(HHC00106, "E", CCKD_RA_THREAD_NAME "() from " CCKD_RA_THREAD_NAME "()",

  00569	8b 4c 24 70	 mov	 ecx, DWORD PTR rc$[rsp]
  0056d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00573	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
  0057b	8b 0d 88 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+136
  00581	ff c9		 dec	 ecx
  00583	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR tv283[rsp], ecx
  0058a	b9 01 00 00 00	 mov	 ecx, 1
  0058f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00595	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv279[rsp]
  0059d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005a2	8b 0d 90 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+144
  005a8	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  005ac	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv283[rsp]
  005b3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170342
  005be	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170343
  005ca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170344
  005d6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005e0	41 b9 03 00 00
	00		 mov	 r9d, 3
  005e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170345
  005ed	ba 42 06 00 00	 mov	 edx, 1602		; 00000642H
  005f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170346
  005f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1602 :                         cckdblk.ras-1, cckdblk.ramax, strerror(rc));
; 1603 :                     --cckdblk.ras;

  005ff	8b 05 88 00 00
	00		 mov	 eax, DWORD PTR cckdblk+136
  00605	ff c8		 dec	 eax
  00607	89 05 88 00 00
	00		 mov	 DWORD PTR cckdblk+136, eax
$LN26@cckd_ra:
$LN23@cckd_ra:
$LN22@cckd_ra:
$LN20@cckd_ra:

; 1604 :                 }
; 1605 :             }
; 1606 :         }
; 1607 : 
; 1608 :         if (!cckd || cckd->stopping || cckd->merging) continue;

  0060d	48 83 7c 24 68
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  00613	74 24		 je	 SHORT $LN28@cckd_ra
  00615	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0061a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0061d	c1 e8 06	 shr	 eax, 6
  00620	83 e0 01	 and	 eax, 1
  00623	85 c0		 test	 eax, eax
  00625	75 12		 jne	 SHORT $LN28@cckd_ra
  00627	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0062c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0062f	c1 e8 05	 shr	 eax, 5
  00632	83 e0 01	 and	 eax, 1
  00635	85 c0		 test	 eax, eax
  00637	74 05		 je	 SHORT $LN27@cckd_ra
$LN28@cckd_ra:
  00639	e9 a5 fc ff ff	 jmp	 $LN33@cckd_ra
$LN27@cckd_ra:

; 1609 : 
; 1610 :         cckd->ras++;

  0063e	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00643	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00646	ff c0		 inc	 eax
  00648	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  0064d	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 1611 : 
; 1612 :         release_lock (&cckdblk.ralock);

  00650	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170349
  00657	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  0065e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1613 :         {
; 1614 :             /* Read the readahead track */
; 1615 :             cckd_read_trk (dev, trk, ra, NULL);

  00664	45 33 c9	 xor	 r9d, r9d
  00667	44 8b 44 24 64	 mov	 r8d, DWORD PTR ra$[rsp]
  0066c	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  00673	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0067b	e8 00 00 00 00	 call	 cckd_read_trk

; 1616 :         }
; 1617 :         obtain_lock (&cckdblk.ralock);

  00680	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170350
  00687	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  0068e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1618 : 
; 1619 :         cckd->ras--;

  00694	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00699	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  0069c	ff c8		 dec	 eax
  0069e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  006a3	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 1620 :     }

  006a6	e9 38 fc ff ff	 jmp	 $LN34@cckd_ra
$LN6@cckd_ra:

; 1621 : 
; 1622 :     if (!cckdblk.batch || cckdblk.batchml > 1)

  006ab	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  006b1	83 e0 01	 and	 eax, 1
  006b4	85 c0		 test	 eax, eax
  006b6	74 0d		 je	 SHORT $LN30@cckd_ra
  006b8	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  006bf	0f 8e 93 00 00
	00		 jle	 $LN29@cckd_ra
$LN30@cckd_ra:

; 1623 :         // "Thread id "TIDPAT", prio %d, name '%s' ended"
; 1624 :         LOG_THREAD_END( threadname );

  006c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  006cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170353
  006d2	8b c8		 mov	 ecx, eax
  006d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  006da	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv325[rsp], eax
  006e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  006e7	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv330[rsp], eax
  006ee	b9 01 00 00 00	 mov	 ecx, 1
  006f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006f9	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR threadname$[rsp]
  00701	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00706	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv325[rsp]
  0070d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00711	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv330[rsp]
  00718	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0071c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170354
  00723	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00728	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170355
  0072f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00734	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00739	41 b9 03 00 00
	00		 mov	 r9d, 3
  0073f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170356
  00746	ba 58 06 00 00	 mov	 edx, 1624		; 00000658H
  0074b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170357
  00752	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN29@cckd_ra:

; 1625 : 
; 1626 :     --cckdblk.ras;

  00758	8b 05 88 00 00
	00		 mov	 eax, DWORD PTR cckdblk+136
  0075e	ff c8		 dec	 eax
  00760	89 05 88 00 00
	00		 mov	 DWORD PTR cckdblk+136, eax

; 1627 :     --cckdblk.raa;

  00766	8b 05 8c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+140
  0076c	ff c8		 dec	 eax
  0076e	89 05 8c 00 00
	00		 mov	 DWORD PTR cckdblk+140, eax

; 1628 : 
; 1629 :     ras = cckdblk.ras;

  00774	8b 05 88 00 00
	00		 mov	 eax, DWORD PTR cckdblk+136
  0077a	89 84 24 9c 00
	00 00		 mov	 DWORD PTR ras$[rsp], eax

; 1630 : 
; 1631 :     release_lock( &cckdblk.ralock );

  00781	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170358
  00788	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  0078f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1632 : 
; 1633 :     if (!ras)

  00795	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR ras$[rsp], 0
  0079d	75 14		 jne	 SHORT $LN31@cckd_ra

; 1634 :         signal_condition( &cckdblk.termcond );

  0079f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170360
  007a6	48 8d 0d 60 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+608
  007ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN31@cckd_ra:

; 1635 : 
; 1636 :     return NULL;

  007b3	33 c0		 xor	 eax, eax
$LN1@cckd_ra:

; 1637 : } /* end thread cckd_ra_thread */

  007b5	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007bd	48 33 cc	 xor	 rcx, rsp
  007c0	e8 00 00 00 00	 call	 __security_check_cookie
  007c5	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  007cc	c3		 ret	 0
cckd_ra	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
devnum$ = 32
k$ = 36
trk$ = 40
dev$ = 48
cckd$ = 56
answer$ = 80
ix$ = 88
i$ = 96
data$ = 104
cckd_readahead_scan PROC

; 1480 : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1481 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 1482 : U16             devnum;                 /* Cached device number      */
; 1483 : U32             trk;                    /* Cached track              */
; 1484 : DEVBLK         *dev = data;             /* -> device block           */

  00017	48 8b 44 24 68	 mov	 rax, QWORD PTR data$[rsp]
  0001c	48 89 44 24 30	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd_reada:

; 1485 : int             k;                      /* Index                     */
; 1486 : 
; 1487 :     UNREFERENCED(answer);

  00021	33 c0		 xor	 eax, eax
  00023	85 c0		 test	 eax, eax
  00025	75 fa		 jne	 SHORT $LN4@cckd_reada
$LN7@cckd_reada:

; 1488 :     UNREFERENCED(ix);

  00027	33 c0		 xor	 eax, eax
  00029	85 c0		 test	 eax, eax
  0002b	75 fa		 jne	 SHORT $LN7@cckd_reada

; 1489 :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 38	 mov	 QWORD PTR cckd$[rsp], rax
$LN10@cckd_reada:

; 1490 :     CCKD_CACHE_GETKEY(i, devnum, trk);

  0003e	8b 54 24 60	 mov	 edx, DWORD PTR i$[rsp]
  00042	33 c9		 xor	 ecx, ecx
  00044	e8 00 00 00 00	 call	 cache_getkey
  00049	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0004d	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00053	66 89 44 24 20	 mov	 WORD PTR devnum$[rsp], ax
  00058	8b 54 24 60	 mov	 edx, DWORD PTR i$[rsp]
  0005c	33 c9		 xor	 ecx, ecx
  0005e	e8 00 00 00 00	 call	 cache_getkey
  00063	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00068	48 23 c1	 and	 rax, rcx
  0006b	89 44 24 28	 mov	 DWORD PTR trk$[rsp], eax
  0006f	33 c0		 xor	 eax, eax
  00071	85 c0		 test	 eax, eax
  00073	75 c9		 jne	 SHORT $LN10@cckd_reada

; 1491 :     if (devnum == dev->devnum)

  00075	0f b7 44 24 20	 movzx	 eax, WORD PTR devnum$[rsp]
  0007a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0007f	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00083	3b c1		 cmp	 eax, ecx
  00085	75 42		 jne	 SHORT $LN11@cckd_reada

; 1492 :     {
; 1493 :         k = (int)trk - cckd->ratrk;

  00087	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0008c	8b 80 d0 00 00
	00		 mov	 eax, DWORD PTR [rax+208]
  00092	8b 4c 24 28	 mov	 ecx, DWORD PTR trk$[rsp]
  00096	2b c8		 sub	 ecx, eax
  00098	8b c1		 mov	 eax, ecx
  0009a	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax

; 1494 :         if (k > 0 && k <= cckdblk.readaheads)

  0009e	83 7c 24 24 00	 cmp	 DWORD PTR k$[rsp], 0
  000a3	7e 24		 jle	 SHORT $LN12@cckd_reada
  000a5	8b 05 9c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+156
  000ab	39 44 24 24	 cmp	 DWORD PTR k$[rsp], eax
  000af	7f 18		 jg	 SHORT $LN12@cckd_reada

; 1495 :             cckd->ralkup[k-1] = 1;

  000b1	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  000b5	ff c8		 dec	 eax
  000b7	48 98		 cdqe
  000b9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000be	c7 84 81 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+144], 1
$LN12@cckd_reada:
$LN11@cckd_reada:

; 1496 :     }
; 1497 :     return 0;

  000c9	33 c0		 xor	 eax, eax

; 1498 : }

  000cb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000cf	c3		 ret	 0
cckd_readahead_scan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
r$ = 96
i$ = 100
rc$ = 104
tv219 = 108
tid$ = 112
cckd$ = 120
tv215 = 128
dev$ = 160
trk$ = 168
cckd_readahead PROC

; 1390 : {

$LN24:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 1391 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 1392 : int             i, r;                   /* Indexes                   */
; 1393 : TID             tid;                    /* Readahead thread id       */
; 1394 : int             rc;
; 1395 : 
; 1396 :     cckd = dev->cckd_ext;

  00011	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00019	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00020	48 89 44 24 78	 mov	 QWORD PTR cckd$[rsp], rax

; 1397 : 
; 1398 :     if (cckdblk.ramax < 1 || cckdblk.readaheads < 1)

  00025	83 3d 90 00 00
	00 01		 cmp	 DWORD PTR cckdblk+144, 1
  0002c	7c 09		 jl	 SHORT $LN9@cckd_reada
  0002e	83 3d 9c 00 00
	00 01		 cmp	 DWORD PTR cckdblk+156, 1
  00035	7d 05		 jge	 SHORT $LN8@cckd_reada
$LN9@cckd_reada:

; 1399 :         return;

  00037	e9 74 04 00 00	 jmp	 $LN1@cckd_reada
$LN8@cckd_reada:

; 1400 : 
; 1401 :     obtain_lock (&cckdblk.ralock);

  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170209
  00043	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1402 : 
; 1403 :     /* Scan the cache to see if the tracks are already there */
; 1404 :     memset( cckd->ralkup, 0, sizeof(cckd->ralkup) );

  00050	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00055	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  0005b	48 8b f8	 mov	 rdi, rax
  0005e	33 c0		 xor	 eax, eax
  00060	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00065	f3 aa		 rep stosb

; 1405 :     cckd->ratrk = trk;

  00067	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0006c	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00073	89 88 d0 00 00
	00		 mov	 DWORD PTR [rax+208], ecx

; 1406 :     cache_lock(CACHE_DEVBUF);

  00079	33 c9		 xor	 ecx, ecx
  0007b	e8 00 00 00 00	 call	 cache_lock

; 1407 :     cache_scan(CACHE_DEVBUF, cckd_readahead_scan, dev);

  00080	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cckd_readahead_scan
  0008f	33 c9		 xor	 ecx, ecx
  00091	e8 00 00 00 00	 call	 cache_scan

; 1408 :     cache_unlock(CACHE_DEVBUF);

  00096	33 c9		 xor	 ecx, ecx
  00098	e8 00 00 00 00	 call	 cache_unlock

; 1409 : 
; 1410 :     /* Scan the queue to see if the tracks are already there */
; 1411 :     for (r = cckdblk.ra1st; r >= 0; r = cckdblk.ra[r].ra_idxnxt)

  0009d	8b 05 20 02 00
	00		 mov	 eax, DWORD PTR cckdblk+544
  000a3	89 44 24 60	 mov	 DWORD PTR r$[rsp], eax
  000a7	eb 18		 jmp	 SHORT $LN4@cckd_reada
$LN2@cckd_reada:
  000a9	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  000ae	48 6b c0 18	 imul	 rax, rax, 24
  000b2	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  000b9	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  000bd	89 44 24 60	 mov	 DWORD PTR r$[rsp], eax
$LN4@cckd_reada:
  000c1	83 7c 24 60 00	 cmp	 DWORD PTR r$[rsp], 0
  000c6	7c 6f		 jl	 SHORT $LN3@cckd_reada

; 1412 :         if (cckdblk.ra[r].ra_dev == dev)

  000c8	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  000cd	48 6b c0 18	 imul	 rax, rax, 24
  000d1	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  000d8	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000e0	48 39 14 01	 cmp	 QWORD PTR [rcx+rax], rdx
  000e4	75 4c		 jne	 SHORT $LN10@cckd_reada

; 1413 :         {
; 1414 :             i = cckdblk.ra[r].ra_trk - trk;

  000e6	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  000eb	48 6b c0 18	 imul	 rax, rax, 24
  000ef	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  000f6	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  000fd	8b 44 01 08	 mov	 eax, DWORD PTR [rcx+rax+8]
  00101	2b c2		 sub	 eax, edx
  00103	89 44 24 64	 mov	 DWORD PTR i$[rsp], eax

; 1415 :             if (i > 0 && i <= cckdblk.readaheads)

  00107	83 7c 24 64 00	 cmp	 DWORD PTR i$[rsp], 0
  0010c	7e 24		 jle	 SHORT $LN11@cckd_reada
  0010e	8b 05 9c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+156
  00114	39 44 24 64	 cmp	 DWORD PTR i$[rsp], eax
  00118	7f 18		 jg	 SHORT $LN11@cckd_reada

; 1416 :                 cckd->ralkup[i-1] = 1;

  0011a	8b 44 24 64	 mov	 eax, DWORD PTR i$[rsp]
  0011e	ff c8		 dec	 eax
  00120	48 98		 cdqe
  00122	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00127	c7 84 81 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+144], 1
$LN11@cckd_reada:
$LN10@cckd_reada:

; 1417 :         }

  00132	e9 72 ff ff ff	 jmp	 $LN2@cckd_reada
$LN3@cckd_reada:

; 1418 : 
; 1419 :     /* Queue the tracks to the readahead queue */
; 1420 :     for (i = 1; i <= cckdblk.readaheads && cckdblk.rafree >= 0; i++)

  00137	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  0013f	eb 0a		 jmp	 SHORT $LN7@cckd_reada
$LN5@cckd_reada:
  00141	8b 44 24 64	 mov	 eax, DWORD PTR i$[rsp]
  00145	ff c0		 inc	 eax
  00147	89 44 24 64	 mov	 DWORD PTR i$[rsp], eax
$LN7@cckd_reada:
  0014b	8b 05 9c 00 00
	00		 mov	 eax, DWORD PTR cckdblk+156
  00151	39 44 24 64	 cmp	 DWORD PTR i$[rsp], eax
  00155	0f 8f 59 01 00
	00		 jg	 $LN6@cckd_reada
  0015b	83 3d 28 02 00
	00 00		 cmp	 DWORD PTR cckdblk+552, 0
  00162	0f 8c 4c 01 00
	00		 jl	 $LN6@cckd_reada

; 1421 :     {
; 1422 :         if (cckd->ralkup[i-1]) continue;

  00168	8b 44 24 64	 mov	 eax, DWORD PTR i$[rsp]
  0016c	ff c8		 dec	 eax
  0016e	48 98		 cdqe
  00170	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00175	83 bc 81 90 00
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+144], 0
  0017d	74 02		 je	 SHORT $LN12@cckd_reada
  0017f	eb c0		 jmp	 SHORT $LN5@cckd_reada
$LN12@cckd_reada:

; 1423 :         if (trk + i >= dev->ckdtrks) break;

  00181	8b 44 24 64	 mov	 eax, DWORD PTR i$[rsp]
  00185	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  0018c	03 c8		 add	 ecx, eax
  0018e	8b c1		 mov	 eax, ecx
  00190	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00198	3b 81 bc 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4796]
  0019e	7c 05		 jl	 SHORT $LN13@cckd_reada
  001a0	e9 0f 01 00 00	 jmp	 $LN6@cckd_reada
$LN13@cckd_reada:

; 1424 :         r = cckdblk.rafree;

  001a5	8b 05 28 02 00
	00		 mov	 eax, DWORD PTR cckdblk+552
  001ab	89 44 24 60	 mov	 DWORD PTR r$[rsp], eax

; 1425 :         cckdblk.rafree = cckdblk.ra[r].ra_idxnxt;

  001af	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  001b4	48 6b c0 18	 imul	 rax, rax, 24
  001b8	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  001bf	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  001c3	89 05 28 02 00
	00		 mov	 DWORD PTR cckdblk+552, eax

; 1426 :         if (cckdblk.ralast < 0)

  001c9	83 3d 24 02 00
	00 00		 cmp	 DWORD PTR cckdblk+548, 0
  001d0	7d 48		 jge	 SHORT $LN14@cckd_reada

; 1427 :         {
; 1428 :             cckdblk.ra1st = cckdblk.ralast = r;

  001d2	8b 44 24 60	 mov	 eax, DWORD PTR r$[rsp]
  001d6	89 05 24 02 00
	00		 mov	 DWORD PTR cckdblk+548, eax
  001dc	8b 05 24 02 00
	00		 mov	 eax, DWORD PTR cckdblk+548
  001e2	89 05 20 02 00
	00		 mov	 DWORD PTR cckdblk+544, eax

; 1429 :             cckdblk.ra[r].ra_idxprv = cckdblk.ra[r].ra_idxnxt = -1;

  001e8	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  001ed	48 6b c0 18	 imul	 rax, rax, 24
  001f1	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  001f8	c7 44 01 10 ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+16], -1
  00200	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  00205	48 6b c0 18	 imul	 rax, rax, 24
  00209	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  00210	c7 44 01 0c ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+12], -1

; 1430 :         }

  00218	eb 56		 jmp	 SHORT $LN15@cckd_reada
$LN14@cckd_reada:

; 1431 :         else
; 1432 :         {
; 1433 :             cckdblk.ra[cckdblk.ralast].ra_idxnxt = r;

  0021a	48 63 05 24 02
	00 00		 movsxd	 rax, DWORD PTR cckdblk+548
  00221	48 6b c0 18	 imul	 rax, rax, 24
  00225	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  0022c	8b 54 24 60	 mov	 edx, DWORD PTR r$[rsp]
  00230	89 54 01 10	 mov	 DWORD PTR [rcx+rax+16], edx

; 1434 :             cckdblk.ra[r].ra_idxprv = cckdblk.ralast;

  00234	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  00239	48 6b c0 18	 imul	 rax, rax, 24
  0023d	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  00244	8b 15 24 02 00
	00		 mov	 edx, DWORD PTR cckdblk+548
  0024a	89 54 01 0c	 mov	 DWORD PTR [rcx+rax+12], edx

; 1435 :             cckdblk.ra[r].ra_idxnxt = -1;

  0024e	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  00253	48 6b c0 18	 imul	 rax, rax, 24
  00257	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  0025e	c7 44 01 10 ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+16], -1

; 1436 :             cckdblk.ralast = r;

  00266	8b 44 24 60	 mov	 eax, DWORD PTR r$[rsp]
  0026a	89 05 24 02 00
	00		 mov	 DWORD PTR cckdblk+548, eax
$LN15@cckd_reada:

; 1437 :         }
; 1438 :         cckdblk.ra[r].ra_trk = trk + i;

  00270	8b 44 24 64	 mov	 eax, DWORD PTR i$[rsp]
  00274	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  0027b	03 c8		 add	 ecx, eax
  0027d	8b c1		 mov	 eax, ecx
  0027f	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR r$[rsp]
  00284	48 6b c9 18	 imul	 rcx, rcx, 24
  00288	48 8d 15 a0 00
	00 00		 lea	 rdx, OFFSET FLAT:cckdblk+160
  0028f	89 44 0a 08	 mov	 DWORD PTR [rdx+rcx+8], eax

; 1439 :         cckdblk.ra[r].ra_dev = dev;

  00293	48 63 44 24 60	 movsxd	 rax, DWORD PTR r$[rsp]
  00298	48 6b c0 18	 imul	 rax, rax, 24
  0029c	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  002a3	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002ab	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 1440 :     }

  002af	e9 8d fe ff ff	 jmp	 $LN5@cckd_reada
$LN6@cckd_reada:

; 1441 : 
; 1442 :     /* Schedule the readahead if any are pending */
; 1443 :     if (cckdblk.ra1st >= 0)

  002b4	83 3d 20 02 00
	00 00		 cmp	 DWORD PTR cckdblk+544, 0
  002bb	0f 8c db 01 00
	00		 jl	 $LN16@cckd_reada

; 1444 :     {
; 1445 :         if (cckdblk.rawaiting)

  002c1	83 3d 94 00 00
	00 00		 cmp	 DWORD PTR cckdblk+148, 0
  002c8	74 19		 je	 SHORT $LN17@cckd_reada

; 1446 :             signal_condition(&cckdblk.racond);

  002ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170219
  002d1	48 8d 0d 80 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+128
  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
  002de	e9 b9 01 00 00	 jmp	 $LN18@cckd_reada
$LN17@cckd_reada:

; 1447 :         else if (cckdblk.ras < cckdblk.ramax)

  002e3	8b 05 90 00 00
	00		 mov	 eax, DWORD PTR cckdblk+144
  002e9	39 05 88 00 00
	00		 cmp	 DWORD PTR cckdblk+136, eax
  002ef	0f 8d a7 01 00
	00		 jge	 $LN19@cckd_reada

; 1448 :         {
; 1449 :             /* Schedule a new read-ahead thread  */
; 1450 :             if (!cckdblk.batch || cckdblk.batchml > 1)

  002f5	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  002fb	83 e0 01	 and	 eax, 1
  002fe	85 c0		 test	 eax, eax
  00300	74 09		 je	 SHORT $LN21@cckd_reada
  00302	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  00309	7e 71		 jle	 SHORT $LN20@cckd_reada
$LN21@cckd_reada:

; 1451 :                 // "Starting thread %s, active=%d, started=%d, max=%d"
; 1452 :                 WRMSG(HHC00107, "I", CCKD_RA_THREAD_NAME "()",

  0030b	b9 01 00 00 00	 mov	 ecx, 1
  00310	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00316	8b 0d 90 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+144
  0031c	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00320	8b 0d 88 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+136
  00326	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0032a	8b 0d 8c 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+140
  00330	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00334	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170223
  0033b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00340	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170224
  00347	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0034c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170225
  00353	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00358	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0035d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00363	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170226
  0036a	ba ad 05 00 00	 mov	 edx, 1453		; 000005adH
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170227
  00376	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN20@cckd_reada:

; 1453 :                     cckdblk.raa, cckdblk.ras, cckdblk.ramax);
; 1454 : 
; 1455 :             ++cckdblk.ras;

  0037c	8b 05 88 00 00
	00		 mov	 eax, DWORD PTR cckdblk+136
  00382	ff c0		 inc	 eax
  00384	89 05 88 00 00
	00		 mov	 DWORD PTR cckdblk+136, eax

; 1456 : 
; 1457 :             /* Release lock across thread create to prevent interlock  */
; 1458 :             release_lock(&cckdblk.ralock);

  0038a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170228
  00391	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1459 :             {
; 1460 :                 rc = create_thread( &tid, JOINABLE, cckd_ra, NULL, CCKD_RA_THREAD_NAME );

  0039e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003a5	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  003ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170229
  003b2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170230
  003be	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003c3	45 33 c9	 xor	 r9d, r9d
  003c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cckd_ra
  003cd	48 8b d0	 mov	 rdx, rax
  003d0	48 8d 4c 24 70	 lea	 rcx, QWORD PTR tid$[rsp]
  003d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  003db	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 1461 :             }
; 1462 :             obtain_lock(&cckdblk.ralock);

  003df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170231
  003e6	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  003ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1463 : 
; 1464 :             if (rc)

  003f3	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  003f8	0f 84 9e 00 00
	00		 je	 $LN22@cckd_reada

; 1465 :             {
; 1466 :                 // "Error in function create_thread() for %s %d of %d: %s"
; 1467 :                 WRMSG(HHC00106, "E", CCKD_RA_THREAD_NAME "()",

  003fe	8b 4c 24 68	 mov	 ecx, DWORD PTR rc$[rsp]
  00402	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00408	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
  00410	8b 0d 88 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+136
  00416	ff c9		 dec	 ecx
  00418	89 4c 24 6c	 mov	 DWORD PTR tv219[rsp], ecx
  0041c	b9 01 00 00 00	 mov	 ecx, 1
  00421	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00427	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv215[rsp]
  0042f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00434	8b 0d 90 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+144
  0043a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0043e	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv219[rsp]
  00442	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00446	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170233
  0044d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00452	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170234
  00459	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0045e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170235
  00465	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0046a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0046f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00475	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170236
  0047c	ba bc 05 00 00	 mov	 edx, 1468		; 000005bcH
  00481	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170237
  00488	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1468 :                     cckdblk.ras-1, cckdblk.ramax, strerror(rc));
; 1469 : 
; 1470 :                 --cckdblk.ras;

  0048e	8b 05 88 00 00
	00		 mov	 eax, DWORD PTR cckdblk+136
  00494	ff c8		 dec	 eax
  00496	89 05 88 00 00
	00		 mov	 DWORD PTR cckdblk+136, eax
$LN22@cckd_reada:
$LN19@cckd_reada:
$LN18@cckd_reada:
$LN16@cckd_reada:

; 1471 :             }
; 1472 :         }
; 1473 :     }
; 1474 : 
; 1475 :     release_lock (&cckdblk.ralock);

  0049c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170238
  004a3	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  004aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@cckd_reada:

; 1476 : 
; 1477 : } /* end function cckd_readahead */

  004b0	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  004b7	5f		 pop	 rdi
  004b8	c3		 ret	 0
cckd_readahead ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
lru$ = 112
cckd$ = 120
fnd$ = 128
buf$ = 136
curtrk$ = 144
devnum$ = 148
tv400 = 152
maxlen$ = 156
oldtrk$ = 160
len$ = 164
flag$ = 168
tv85 = 176
tv227 = 184
tv438 = 192
dev$ = 224
trk$ = 232
ra$ = 240
unitstat$ = 248
cckd_read_trk PROC

; 1186 : {

$LN35:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H

; 1187 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 1188 : int             fnd;                    /* Cache index for hit       */
; 1189 : int             lru;                    /* Oldest unused cache index */
; 1190 : int             len;                    /* Length of track image     */
; 1191 : int             maxlen;                 /* Length for buffer         */
; 1192 : int             curtrk = -1;            /* Current track (at entry)  */

  0001b	c7 84 24 90 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR curtrk$[rsp], -1

; 1193 : U16             devnum;                 /* Device number             */
; 1194 : U32             oldtrk;                 /* Stolen track number       */
; 1195 : U32             flag;                   /* Cache flag                */
; 1196 : BYTE           *buf;                    /* Read buffer               */
; 1197 : 
; 1198 :     if (dev->cckd64)

  00026	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00035	24 01		 and	 al, 1
  00037	0f b6 c0	 movzx	 eax, al
  0003a	85 c0		 test	 eax, eax
  0003c	74 29		 je	 SHORT $LN7@cckd_read_

; 1199 :         return cckd64_read_trk( dev, trk, ra, unitstat );

  0003e	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  00046	44 8b 84 24 f0
	00 00 00	 mov	 r8d, DWORD PTR ra$[rsp]
  0004e	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  00055	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0005d	e8 00 00 00 00	 call	 cckd64_read_trk
  00062	e9 89 0b 00 00	 jmp	 $LN1@cckd_read_
$LN7@cckd_read_:

; 1200 : 
; 1201 :     cckd = dev->cckd_ext;

  00067	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006f	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00076	48 89 44 24 78	 mov	 QWORD PTR cckd$[rsp], rax

; 1202 : 
; 1203 :     CCKD_TRACE( "%d rdtrk     %d", ra, trk);

  0007b	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00082	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00086	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  0008d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00091	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170136
  00098	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000a0	ba b3 04 00 00	 mov	 edx, 1203		; 000004b3H
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170137
  000ac	e8 00 00 00 00	 call	 cckd_trace

; 1204 : 
; 1205 :     maxlen = cckd->ckddasd ? dev->ckdtrksz

  000b1	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  000b6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000b9	83 e0 01	 and	 eax, 1
  000bc	85 c0		 test	 eax, eax
  000be	74 19		 je	 SHORT $LN29@cckd_read_
  000c0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c8	48 63 80 c4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4804]
  000cf	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv85[rsp], rax
  000d7	eb 0c		 jmp	 SHORT $LN30@cckd_read_
$LN29@cckd_read_:
  000d9	48 c7 84 24 b0
	00 00 00 05 f0
	00 00		 mov	 QWORD PTR tv85[rsp], 61445 ; 0000f005H
$LN30@cckd_read_:
  000e5	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv85[rsp]
  000ec	89 84 24 9c 00
	00 00		 mov	 DWORD PTR maxlen$[rsp], eax

; 1206 :                            : CFBA_BLKGRP_SIZE + CKD_TRKHDR_SIZE;
; 1207 : 
; 1208 :     if (!ra) obtain_lock (&cckd->cckdiolock);

  000f3	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  000fb	75 19		 jne	 SHORT $LN8@cckd_read_
  000fd	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00102	48 83 c0 18	 add	 rax, 24
  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170139
  0010d	48 8b c8	 mov	 rcx, rax
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN8@cckd_read_:

; 1209 : 
; 1210 :     cache_lock (CACHE_DEVBUF);

  00116	33 c9		 xor	 ecx, ecx
  00118	e8 00 00 00 00	 call	 cache_lock

; 1211 : 
; 1212 :     /* Inactivate the old entry */
; 1213 :     if (!ra)

  0011d	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  00125	75 68		 jne	 SHORT $LN9@cckd_read_

; 1214 :     {
; 1215 :         curtrk = dev->bufcur;

  00127	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0012f	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  00135	89 84 24 90 00
	00 00		 mov	 DWORD PTR curtrk$[rsp], eax

; 1216 :         if (dev->cache >= 0)

  0013c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00144	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  0014b	7c 1e		 jl	 SHORT $LN10@cckd_read_

; 1217 :             cache_setflag(CACHE_DEVBUF, dev->cache, ~CCKD_CACHE_ACTIVE, 0);

  0014d	45 33 c9	 xor	 r9d, r9d
  00150	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  00156	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0015e	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00164	33 c9		 xor	 ecx, ecx
  00166	e8 00 00 00 00	 call	 cache_setflag
$LN10@cckd_read_:

; 1218 :         dev->bufcur = dev->cache = -1;

  0016b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00173	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0017d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00185	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1
$LN9@cckd_read_:
$cckd_read_trk_retry$36:

; 1219 :     }
; 1220 : 
; 1221 : cckd_read_trk_retry:
; 1222 : 
; 1223 :     /* scan the cache array for the track */
; 1224 :     fnd = cache_lookup (CACHE_DEVBUF, CCKD_CACHE_SETKEY(dev->devnum, trk), &lru);

  0018f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00197	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0019b	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0019f	48 63 8c 24 e8
	00 00 00	 movsxd	 rcx, DWORD PTR trk$[rsp]
  001a7	48 0b c1	 or	 rax, rcx
  001aa	4c 8d 44 24 70	 lea	 r8, QWORD PTR lru$[rsp]
  001af	48 8b d0	 mov	 rdx, rax
  001b2	33 c9		 xor	 ecx, ecx
  001b4	e8 00 00 00 00	 call	 cache_lookup
  001b9	89 84 24 80 00
	00 00		 mov	 DWORD PTR fnd$[rsp], eax

; 1225 : 
; 1226 :     /* check for cache hit */
; 1227 :     if (fnd >= 0)

  001c0	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR fnd$[rsp], 0
  001c8	0f 8c cf 03 00
	00		 jl	 $LN11@cckd_read_

; 1228 :     {
; 1229 :         if (ra) /* readahead doesn't care about a cache hit */

  001ce	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  001d6	74 13		 je	 SHORT $LN12@cckd_read_

; 1230 :         {   cache_unlock (CACHE_DEVBUF);

  001d8	33 c9		 xor	 ecx, ecx
  001da	e8 00 00 00 00	 call	 cache_unlock

; 1231 :             return fnd;

  001df	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR fnd$[rsp]
  001e6	e9 05 0a 00 00	 jmp	 $LN1@cckd_read_
$LN12@cckd_read_:

; 1232 :         }
; 1233 : 
; 1234 :         /* Mark the new entry active */
; 1235 :         cache_setflag(CACHE_DEVBUF, fnd, ~0, CCKD_CACHE_ACTIVE | CCKD_CACHE_USED);

  001eb	41 b9 00 00 80
	80		 mov	 r9d, -2139095040	; 80800000H
  001f1	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  001f7	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  001fe	33 c9		 xor	 ecx, ecx
  00200	e8 00 00 00 00	 call	 cache_setflag

; 1236 :         cache_setage(CACHE_DEVBUF, fnd);

  00205	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  0020c	33 c9		 xor	 ecx, ecx
  0020e	e8 00 00 00 00	 call	 cache_setage

; 1237 : 
; 1238 :         /* If the entry is pending write then change it to `updated' */
; 1239 :         if (cache_getflag(CACHE_DEVBUF, fnd) & CCKD_CACHE_WRITE)

  00213	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  0021a	33 c9		 xor	 ecx, ecx
  0021c	e8 00 00 00 00	 call	 cache_getflag
  00221	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00226	85 c0		 test	 eax, eax
  00228	74 5b		 je	 SHORT $LN13@cckd_read_

; 1240 :         {
; 1241 :             cache_setflag(CACHE_DEVBUF, fnd, ~CCKD_CACHE_WRITE, CCKD_CACHE_UPDATED);

  0022a	41 b9 00 00 00
	08		 mov	 r9d, 134217728		; 08000000H
  00230	41 b8 ff ff ff
	fb		 mov	 r8d, -67108865		; fbffffffH
  00236	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  0023d	33 c9		 xor	 ecx, ecx
  0023f	e8 00 00 00 00	 call	 cache_setflag

; 1242 :             cckd->wrpending--;

  00244	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00249	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  0024c	ff c8		 dec	 eax
  0024e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00253	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 1243 :             if (cckd->cckdwaiters && !cckd->wrpending)

  00256	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0025b	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0025f	74 24		 je	 SHORT $LN14@cckd_read_
  00261	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00266	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  0026a	75 19		 jne	 SHORT $LN14@cckd_read_

; 1244 :                 broadcast_condition (&cckd->cckdiocond);

  0026c	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00271	48 83 c0 20	 add	 rax, 32			; 00000020H
  00275	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170146
  0027c	48 8b c8	 mov	 rcx, rax
  0027f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN14@cckd_read_:
$LN13@cckd_read_:

; 1245 :         }
; 1246 :         buf = cache_getbuf(CACHE_DEVBUF, fnd, 0);

  00285	45 33 c0	 xor	 r8d, r8d
  00288	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  0028f	33 c9		 xor	 ecx, ecx
  00291	e8 00 00 00 00	 call	 cache_getbuf
  00296	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1247 : 
; 1248 :         cache_unlock (CACHE_DEVBUF);

  0029e	33 c9		 xor	 ecx, ecx
  002a0	e8 00 00 00 00	 call	 cache_unlock

; 1249 : 
; 1250 :         CCKD_TRACE( "%d rdtrk[%d] %d cache hit buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x",

  002a5	b8 01 00 00 00	 mov	 eax, 1
  002aa	48 6b c0 04	 imul	 rax, rax, 4
  002ae	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  002b6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ba	b9 01 00 00 00	 mov	 ecx, 1
  002bf	48 6b c9 03	 imul	 rcx, rcx, 3
  002c3	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  002cb	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002cf	ba 01 00 00 00	 mov	 edx, 1
  002d4	48 6b d2 02	 imul	 rdx, rdx, 2
  002d8	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  002e0	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  002e5	41 b8 01 00 00
	00		 mov	 r8d, 1
  002eb	4d 6b c0 01	 imul	 r8, r8, 1
  002ef	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  002f7	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  002fc	41 b9 01 00 00
	00		 mov	 r9d, 1
  00302	4d 6b c9 00	 imul	 r9, r9, 0
  00306	4c 8b 94 24 88
	00 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  0030e	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  00313	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00317	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0031b	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  0031f	44 89 44 24 48	 mov	 DWORD PTR [rsp+72], r8d
  00324	44 89 4c 24 40	 mov	 DWORD PTR [rsp+64], r9d
  00329	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00331	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00336	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0033d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00341	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR fnd$[rsp]
  00348	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0034c	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  00353	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00357	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170147
  0035e	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00366	ba e3 04 00 00	 mov	 edx, 1251		; 000004e3H
  0036b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170148
  00372	e8 00 00 00 00	 call	 cckd_trace

; 1251 :                     ra, fnd, trk, buf, buf[0], buf[1], buf[2], buf[3], buf[4]);
; 1252 : 
; 1253 :         cckdblk.stats_switches++;  cckd->switches++;

  00377	48 8b 05 68 02
	00 00		 mov	 rax, QWORD PTR cckdblk+616
  0037e	48 ff c0	 inc	 rax
  00381	48 89 05 68 02
	00 00		 mov	 QWORD PTR cckdblk+616, rax
  00388	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0038d	8b 80 e8 00 00
	00		 mov	 eax, DWORD PTR [rax+232]
  00393	ff c0		 inc	 eax
  00395	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0039a	89 81 e8 00 00
	00		 mov	 DWORD PTR [rcx+232], eax

; 1254 :         cckdblk.stats_cachehits++; cckd->cachehits++;

  003a0	48 8b 05 70 02
	00 00		 mov	 rax, QWORD PTR cckdblk+624
  003a7	48 ff c0	 inc	 rax
  003aa	48 89 05 70 02
	00 00		 mov	 QWORD PTR cckdblk+624, rax
  003b1	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  003b6	8b 80 e0 00 00
	00		 mov	 eax, DWORD PTR [rax+224]
  003bc	ff c0		 inc	 eax
  003be	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  003c3	89 81 e0 00 00
	00		 mov	 DWORD PTR [rcx+224], eax
$LN2@cckd_read_:

; 1255 : 
; 1256 :         /* if read/write is in progress then wait for it to finish */
; 1257 :         while (cache_getflag(CACHE_DEVBUF, fnd) & CCKD_CACHE_IOBUSY)

  003c9	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  003d0	33 c9		 xor	 ecx, ecx
  003d2	e8 00 00 00 00	 call	 cache_getflag
  003d7	25 00 00 00 60	 and	 eax, 1610612736		; 60000000H
  003dc	85 c0		 test	 eax, eax
  003de	0f 84 53 01 00
	00		 je	 $LN3@cckd_read_

; 1258 :         {
; 1259 :             cckdblk.stats_iowaits++;

  003e4	48 8b 05 90 02
	00 00		 mov	 rax, QWORD PTR cckdblk+656
  003eb	48 ff c0	 inc	 rax
  003ee	48 89 05 90 02
	00 00		 mov	 QWORD PTR cckdblk+656, rax

; 1260 :             CCKD_TRACE( "%d rdtrk[%d] %d waiting for %s", ra, fnd, trk,

  003f5	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  003fc	33 c9		 xor	 ecx, ecx
  003fe	e8 00 00 00 00	 call	 cache_getflag
  00403	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00408	85 c0		 test	 eax, eax
  0040a	74 11		 je	 SHORT $LN31@cckd_read_
  0040c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170149
  00413	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv227[rsp], rax
  0041b	eb 0f		 jmp	 SHORT $LN32@cckd_read_
$LN31@cckd_read_:
  0041d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170150
  00424	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv227[rsp], rax
$LN32@cckd_read_:
  0042c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv227[rsp]
  00434	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00439	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00440	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00444	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR fnd$[rsp]
  0044b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0044f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  00456	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0045a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170151
  00461	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00469	ba ee 04 00 00	 mov	 edx, 1262		; 000004eeH
  0046e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170152
  00475	e8 00 00 00 00	 call	 cckd_trace

; 1261 :                         cache_getflag(CACHE_DEVBUF, fnd) & CCKD_CACHE_READING ?
; 1262 :                         "read" : "write");
; 1263 :             cache_setflag (CACHE_DEVBUF, fnd, ~0, CCKD_CACHE_IOWAIT);

  0047a	41 b9 00 00 00
	10		 mov	 r9d, 268435456		; 10000000H
  00480	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  00486	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  0048d	33 c9		 xor	 ecx, ecx
  0048f	e8 00 00 00 00	 call	 cache_setflag

; 1264 :             cckd->cckdwaiters++;

  00494	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00499	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0049c	ff c0		 inc	 eax
  0049e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  004a3	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1265 :             wait_condition (&cckd->cckdiocond, &cckd->cckdiolock);

  004a6	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  004ab	48 83 c0 18	 add	 rax, 24
  004af	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  004b4	48 83 c1 20	 add	 rcx, 32			; 00000020H
  004b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170153
  004bf	48 8b d0	 mov	 rdx, rax
  004c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 1266 :             cckd->cckdwaiters--;

  004c8	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  004cd	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  004d0	ff c8		 dec	 eax
  004d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  004d7	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1267 :             cache_setflag (CACHE_DEVBUF, fnd, ~CCKD_CACHE_IOWAIT, 0);

  004da	45 33 c9	 xor	 r9d, r9d
  004dd	41 b8 ff ff ff
	ef		 mov	 r8d, -268435457		; efffffffH
  004e3	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  004ea	33 c9		 xor	 ecx, ecx
  004ec	e8 00 00 00 00	 call	 cache_setflag

; 1268 :             CCKD_TRACE( "%d rdtrk[%d] %d io wait complete",

  004f1	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  004f8	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  004fc	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR fnd$[rsp]
  00503	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00507	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  0050e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00512	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170154
  00519	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00521	ba f5 04 00 00	 mov	 edx, 1269		; 000004f5H
  00526	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170155
  0052d	e8 00 00 00 00	 call	 cckd_trace

; 1269 :                         ra, fnd, trk);
; 1270 :         }

  00532	e9 92 fe ff ff	 jmp	 $LN2@cckd_read_
$LN3@cckd_read_:

; 1271 : 
; 1272 :         release_lock (&cckd->cckdiolock);

  00537	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0053c	48 83 c0 18	 add	 rax, 24
  00540	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170156
  00547	48 8b c8	 mov	 rcx, rax
  0054a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1273 : 
; 1274 :         /* Asynchrously schedule readaheads */
; 1275 :         if (curtrk > 0 && trk > curtrk && trk <= curtrk + 2)

  00550	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR curtrk$[rsp], 0
  00558	7e 37		 jle	 SHORT $LN15@cckd_read_
  0055a	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR curtrk$[rsp]
  00561	39 84 24 e8 00
	00 00		 cmp	 DWORD PTR trk$[rsp], eax
  00568	7e 27		 jle	 SHORT $LN15@cckd_read_
  0056a	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR curtrk$[rsp]
  00571	83 c0 02	 add	 eax, 2
  00574	39 84 24 e8 00
	00 00		 cmp	 DWORD PTR trk$[rsp], eax
  0057b	7f 14		 jg	 SHORT $LN15@cckd_read_

; 1276 :             cckd_readahead (dev, trk);

  0057d	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  00584	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0058c	e8 00 00 00 00	 call	 cckd_readahead
$LN15@cckd_read_:

; 1277 : 
; 1278 :         return fnd;

  00591	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR fnd$[rsp]
  00598	e9 53 06 00 00	 jmp	 $LN1@cckd_read_
$LN11@cckd_read_:

; 1279 : 
; 1280 :     } /* cache hit */
; 1281 : 
; 1282 :     CCKD_TRACE( "%d rdtrk[%d] %d cache miss", ra, lru, trk);

  0059d	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  005a4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  005a8	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
  005ac	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005b0	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  005b7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005bb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170158
  005c2	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  005ca	ba 02 05 00 00	 mov	 edx, 1282		; 00000502H
  005cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170159
  005d6	e8 00 00 00 00	 call	 cckd_trace

; 1283 : 
; 1284 :     /* If no cache entry was stolen, then flush all outstanding writes.
; 1285 :        This requires us to release our locks.  cache_wait should be
; 1286 :        called with only the cache_lock held.  Fortunately, cache waits
; 1287 :        occur very rarely. */
; 1288 :     if (lru < 0) /* No available entry to be stolen */

  005db	83 7c 24 70 00	 cmp	 DWORD PTR lru$[rsp], 0
  005e0	0f 8d c2 00 00
	00		 jge	 $LN16@cckd_read_

; 1289 :     {
; 1290 :         CCKD_TRACE( "%d rdtrk[%d] %d no available cache entry",

  005e6	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  005ed	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  005f1	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
  005f5	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005f9	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  00600	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00604	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170161
  0060b	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00613	ba 0b 05 00 00	 mov	 edx, 1291		; 0000050bH
  00618	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170162
  0061f	e8 00 00 00 00	 call	 cckd_trace

; 1291 :                     ra, lru, trk);
; 1292 :         cache_unlock (CACHE_DEVBUF);

  00624	33 c9		 xor	 ecx, ecx
  00626	e8 00 00 00 00	 call	 cache_unlock

; 1293 :         if (!ra) release_lock (&cckd->cckdiolock);

  0062b	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  00633	75 19		 jne	 SHORT $LN17@cckd_read_
  00635	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0063a	48 83 c0 18	 add	 rax, 24
  0063e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170164
  00645	48 8b c8	 mov	 rcx, rax
  00648	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN17@cckd_read_:

; 1294 :         cckd_flush_cache_all();

  0064e	e8 00 00 00 00	 call	 cckd_flush_cache_all

; 1295 :         cache_lock (CACHE_DEVBUF);

  00653	33 c9		 xor	 ecx, ecx
  00655	e8 00 00 00 00	 call	 cache_lock

; 1296 :         cckdblk.stats_cachewaits++;

  0065a	48 8b 05 98 02
	00 00		 mov	 rax, QWORD PTR cckdblk+664
  00661	48 ff c0	 inc	 rax
  00664	48 89 05 98 02
	00 00		 mov	 QWORD PTR cckdblk+664, rax

; 1297 :         cache_wait (CACHE_DEVBUF);

  0066b	33 c9		 xor	 ecx, ecx
  0066d	e8 00 00 00 00	 call	 cache_wait

; 1298 :         if (!ra)

  00672	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  0067a	75 27		 jne	 SHORT $LN18@cckd_read_

; 1299 :         {
; 1300 :             cache_unlock (CACHE_DEVBUF);

  0067c	33 c9		 xor	 ecx, ecx
  0067e	e8 00 00 00 00	 call	 cache_unlock

; 1301 :             obtain_lock (&cckd->cckdiolock);

  00683	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00688	48 83 c0 18	 add	 rax, 24
  0068c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170166
  00693	48 8b c8	 mov	 rcx, rax
  00696	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1302 :             cache_lock (CACHE_DEVBUF);

  0069c	33 c9		 xor	 ecx, ecx
  0069e	e8 00 00 00 00	 call	 cache_lock
$LN18@cckd_read_:

; 1303 :         }
; 1304 :         goto cckd_read_trk_retry;

  006a3	e9 e7 fa ff ff	 jmp	 $cckd_read_trk_retry$36
$LN16@cckd_read_:
$LN6@cckd_read_:

; 1305 :     }
; 1306 : 
; 1307 :     CCKD_CACHE_GETKEY(lru, devnum, oldtrk);

  006a8	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  006ac	33 c9		 xor	 ecx, ecx
  006ae	e8 00 00 00 00	 call	 cache_getkey
  006b3	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  006b7	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  006bd	66 89 84 24 94
	00 00 00	 mov	 WORD PTR devnum$[rsp], ax
  006c5	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  006c9	33 c9		 xor	 ecx, ecx
  006cb	e8 00 00 00 00	 call	 cache_getkey
  006d0	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  006d5	48 23 c1	 and	 rax, rcx
  006d8	89 84 24 a0 00
	00 00		 mov	 DWORD PTR oldtrk$[rsp], eax
  006df	33 c0		 xor	 eax, eax
  006e1	85 c0		 test	 eax, eax
  006e3	75 c3		 jne	 SHORT $LN6@cckd_read_

; 1308 :     if (devnum != 0)

  006e5	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  006ed	85 c0		 test	 eax, eax
  006ef	0f 84 92 00 00
	00		 je	 $LN19@cckd_read_

; 1309 :     {
; 1310 :         CCKD_TRACE( "%d rdtrk[%d] %d dropping %4.4X:%d from cache",

  006f5	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  006fd	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR oldtrk$[rsp]
  00704	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00708	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0070c	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00713	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00717	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
  0071b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0071f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  00726	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0072a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170168
  00731	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00739	ba 1f 05 00 00	 mov	 edx, 1311		; 0000051fH
  0073e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170169
  00745	e8 00 00 00 00	 call	 cckd_trace

; 1311 :                     ra, lru, trk, devnum, oldtrk);
; 1312 :         if (!(cache_getflag(CACHE_DEVBUF, lru) & CCKD_CACHE_USED))

  0074a	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  0074e	33 c9		 xor	 ecx, ecx
  00750	e8 00 00 00 00	 call	 cache_getflag
  00755	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  0075a	85 c0		 test	 eax, eax
  0075c	75 29		 jne	 SHORT $LN20@cckd_read_

; 1313 :         {
; 1314 :             cckdblk.stats_readaheadmisses++;  cckd->misses++;

  0075e	48 8b 05 88 02
	00 00		 mov	 rax, QWORD PTR cckdblk+648
  00765	48 ff c0	 inc	 rax
  00768	48 89 05 88 02
	00 00		 mov	 QWORD PTR cckdblk+648, rax
  0076f	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00774	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [rax+236]
  0077a	ff c0		 inc	 eax
  0077c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00781	89 81 ec 00 00
	00		 mov	 DWORD PTR [rcx+236], eax
$LN20@cckd_read_:
$LN19@cckd_read_:

; 1315 :         }
; 1316 :     }
; 1317 : 
; 1318 :     /* Initialize the entry */
; 1319 :     cache_setkey(CACHE_DEVBUF, lru, CCKD_CACHE_SETKEY(dev->devnum, trk));

  00787	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0078f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00793	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  00797	48 63 8c 24 e8
	00 00 00	 movsxd	 rcx, DWORD PTR trk$[rsp]
  0079f	48 0b c1	 or	 rax, rcx
  007a2	4c 8b c0	 mov	 r8, rax
  007a5	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  007a9	33 c9		 xor	 ecx, ecx
  007ab	e8 00 00 00 00	 call	 cache_setkey

; 1320 :     cache_setflag(CACHE_DEVBUF, lru, 0, CCKD_CACHE_READING);

  007b0	41 b9 00 00 00
	40		 mov	 r9d, 1073741824		; 40000000H
  007b6	45 33 c0	 xor	 r8d, r8d
  007b9	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  007bd	33 c9		 xor	 ecx, ecx
  007bf	e8 00 00 00 00	 call	 cache_setflag

; 1321 :     cache_setage(CACHE_DEVBUF, lru);

  007c4	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  007c8	33 c9		 xor	 ecx, ecx
  007ca	e8 00 00 00 00	 call	 cache_setage

; 1322 :     cache_setval(CACHE_DEVBUF, lru, 0);

  007cf	45 33 c0	 xor	 r8d, r8d
  007d2	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  007d6	33 c9		 xor	 ecx, ecx
  007d8	e8 00 00 00 00	 call	 cache_setval

; 1323 :     if (!ra)

  007dd	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  007e5	75 51		 jne	 SHORT $LN21@cckd_read_

; 1324 :     {
; 1325 :         cckdblk.stats_switches++; cckd->switches++;

  007e7	48 8b 05 68 02
	00 00		 mov	 rax, QWORD PTR cckdblk+616
  007ee	48 ff c0	 inc	 rax
  007f1	48 89 05 68 02
	00 00		 mov	 QWORD PTR cckdblk+616, rax
  007f8	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  007fd	8b 80 e8 00 00
	00		 mov	 eax, DWORD PTR [rax+232]
  00803	ff c0		 inc	 eax
  00805	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0080a	89 81 e8 00 00
	00		 mov	 DWORD PTR [rcx+232], eax

; 1326 :         cckdblk.stats_cachemisses++;

  00810	48 8b 05 78 02
	00 00		 mov	 rax, QWORD PTR cckdblk+632
  00817	48 ff c0	 inc	 rax
  0081a	48 89 05 78 02
	00 00		 mov	 QWORD PTR cckdblk+632, rax

; 1327 :         cache_setflag(CACHE_DEVBUF, lru, ~0, CCKD_CACHE_ACTIVE|CCKD_CACHE_USED);

  00821	41 b9 00 00 80
	80		 mov	 r9d, -2139095040	; 80800000H
  00827	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  0082d	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  00831	33 c9		 xor	 ecx, ecx
  00833	e8 00 00 00 00	 call	 cache_setflag
$LN21@cckd_read_:

; 1328 :     }
; 1329 :     cache_setflag(CACHE_DEVBUF, lru, ~CACHE_TYPE,

  00838	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0083d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00840	83 e0 01	 and	 eax, 1
  00843	85 c0		 test	 eax, eax
  00845	74 0d		 je	 SHORT $LN33@cckd_read_
  00847	c7 84 24 98 00
	00 00 42 00 00
	00		 mov	 DWORD PTR tv400[rsp], 66 ; 00000042H
  00852	eb 0b		 jmp	 SHORT $LN34@cckd_read_
$LN33@cckd_read_:
  00854	c7 84 24 98 00
	00 00 41 00 00
	00		 mov	 DWORD PTR tv400[rsp], 65 ; 00000041H
$LN34@cckd_read_:
  0085f	44 8b 8c 24 98
	00 00 00	 mov	 r9d, DWORD PTR tv400[rsp]
  00867	41 b8 00 ff ff
	ff		 mov	 r8d, -256		; ffffff00H
  0086d	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  00871	33 c9		 xor	 ecx, ecx
  00873	e8 00 00 00 00	 call	 cache_setflag

; 1330 :                   cckd->ckddasd ? DEVBUF_TYPE_CCKD : DEVBUF_TYPE_CFBA);
; 1331 :     buf = cache_getbuf(CACHE_DEVBUF, lru, maxlen);

  00878	44 8b 84 24 9c
	00 00 00	 mov	 r8d, DWORD PTR maxlen$[rsp]
  00880	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  00884	33 c9		 xor	 ecx, ecx
  00886	e8 00 00 00 00	 call	 cache_getbuf
  0088b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1332 : 
; 1333 :     CCKD_TRACE( "%d rdtrk[%d] %d buf %p len %d",

  00893	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  00897	33 c9		 xor	 ecx, ecx
  00899	e8 00 00 00 00	 call	 cache_getlen
  0089e	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  008a2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  008aa	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  008af	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  008b6	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  008ba	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
  008be	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  008c2	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  008c9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  008cd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170172
  008d4	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  008dc	ba 36 05 00 00	 mov	 edx, 1334		; 00000536H
  008e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170173
  008e8	e8 00 00 00 00	 call	 cckd_trace

; 1334 :                 ra, lru, trk, buf, cache_getlen(CACHE_DEVBUF, lru));
; 1335 : 
; 1336 :     cache_unlock (CACHE_DEVBUF);

  008ed	33 c9		 xor	 ecx, ecx
  008ef	e8 00 00 00 00	 call	 cache_unlock

; 1337 : 
; 1338 :     if (!ra) release_lock (&cckd->cckdiolock);

  008f4	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  008fc	75 19		 jne	 SHORT $LN22@cckd_read_
  008fe	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00903	48 83 c0 18	 add	 rax, 24
  00907	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170175
  0090e	48 8b c8	 mov	 rcx, rax
  00911	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN22@cckd_read_:

; 1339 : 
; 1340 :     /* Asynchronously schedule readaheads */
; 1341 :     if (!ra && curtrk > 0 && trk > curtrk && trk <= curtrk + 2)

  00917	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  0091f	75 41		 jne	 SHORT $LN23@cckd_read_
  00921	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR curtrk$[rsp], 0
  00929	7e 37		 jle	 SHORT $LN23@cckd_read_
  0092b	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR curtrk$[rsp]
  00932	39 84 24 e8 00
	00 00		 cmp	 DWORD PTR trk$[rsp], eax
  00939	7e 27		 jle	 SHORT $LN23@cckd_read_
  0093b	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR curtrk$[rsp]
  00942	83 c0 02	 add	 eax, 2
  00945	39 84 24 e8 00
	00 00		 cmp	 DWORD PTR trk$[rsp], eax
  0094c	7f 14		 jg	 SHORT $LN23@cckd_read_

; 1342 :         cckd_readahead (dev, trk);

  0094e	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  00955	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0095d	e8 00 00 00 00	 call	 cckd_readahead
$LN23@cckd_read_:

; 1343 : 
; 1344 :     /* Clear the buffer if batch mode */
; 1345 :     if (dev->batch) memset(buf, 0, maxlen);

  00962	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0096a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00970	c1 e8 0a	 shr	 eax, 10
  00973	83 e0 01	 and	 eax, 1
  00976	85 c0		 test	 eax, eax
  00978	74 24		 je	 SHORT $LN24@cckd_read_
  0097a	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR maxlen$[rsp]
  00982	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv438[rsp], rax
  0098a	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  00992	33 c0		 xor	 eax, eax
  00994	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv438[rsp]
  0099c	f3 aa		 rep stosb
$LN24@cckd_read_:

; 1346 : 
; 1347 :     /* Read the track image */
; 1348 :     obtain_lock( &cckd->filelock );

  0099e	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  009a3	48 83 c0 10	 add	 rax, 16
  009a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170178
  009ae	48 8b c8	 mov	 rcx, rax
  009b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1349 :     {
; 1350 :         len = cckd_read_trkimg (dev, buf, trk, unitstat);

  009b7	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  009bf	44 8b 84 24 e8
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  009c7	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  009cf	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009d7	e8 00 00 00 00	 call	 cckd_read_trkimg
  009dc	89 84 24 a4 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 1351 :     }
; 1352 :     release_lock( &cckd->filelock );

  009e3	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  009e8	48 83 c0 10	 add	 rax, 16
  009ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170179
  009f3	48 8b c8	 mov	 rcx, rax
  009f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1353 : 
; 1354 :     cache_setval (CACHE_DEVBUF, lru, len);

  009fc	44 8b 84 24 a4
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00a04	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  00a08	33 c9		 xor	 ecx, ecx
  00a0a	e8 00 00 00 00	 call	 cache_setval

; 1355 : 
; 1356 :     obtain_lock (&cckd->cckdiolock);

  00a0f	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00a14	48 83 c0 18	 add	 rax, 24
  00a18	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170180
  00a1f	48 8b c8	 mov	 rcx, rax
  00a22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1357 : 
; 1358 :     /* Turn off the READING bit */
; 1359 :     cache_lock (CACHE_DEVBUF);

  00a28	33 c9		 xor	 ecx, ecx
  00a2a	e8 00 00 00 00	 call	 cache_lock

; 1360 :     flag = cache_setflag(CACHE_DEVBUF, lru, ~CCKD_CACHE_READING, 0);

  00a2f	45 33 c9	 xor	 r9d, r9d
  00a32	41 b8 ff ff ff
	bf		 mov	 r8d, -1073741825	; bfffffffH
  00a38	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  00a3c	33 c9		 xor	 ecx, ecx
  00a3e	e8 00 00 00 00	 call	 cache_setflag
  00a43	89 84 24 a8 00
	00 00		 mov	 DWORD PTR flag$[rsp], eax

; 1361 :     cache_unlock (CACHE_DEVBUF);

  00a4a	33 c9		 xor	 ecx, ecx
  00a4c	e8 00 00 00 00	 call	 cache_unlock

; 1362 : 
; 1363 :     /* Wakeup other thread waiting for this read */
; 1364 :     if (cckd->cckdwaiters && (flag & CCKD_CACHE_IOWAIT))

  00a51	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00a56	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00a5a	74 67		 je	 SHORT $LN25@cckd_read_
  00a5c	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR flag$[rsp]
  00a63	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00a68	85 c0		 test	 eax, eax
  00a6a	74 57		 je	 SHORT $LN25@cckd_read_

; 1365 :     {   CCKD_TRACE( "%d rdtrk[%d] %d signalling read complete",

  00a6c	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00a73	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00a77	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
  00a7b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00a7f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  00a86	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00a8a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170182
  00a91	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00a99	ba 56 05 00 00	 mov	 edx, 1366		; 00000556H
  00a9e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170183
  00aa5	e8 00 00 00 00	 call	 cckd_trace

; 1366 :                     ra, lru, trk);
; 1367 :         broadcast_condition (&cckd->cckdiocond);

  00aaa	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00aaf	48 83 c0 20	 add	 rax, 32			; 00000020H
  00ab3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170184
  00aba	48 8b c8	 mov	 rcx, rax
  00abd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN25@cckd_read_:

; 1368 :     }
; 1369 : 
; 1370 :     release_lock (&cckd->cckdiolock);

  00ac3	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00ac8	48 83 c0 18	 add	 rax, 24
  00acc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170185
  00ad3	48 8b c8	 mov	 rcx, rax
  00ad6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1371 : 
; 1372 :     if (ra)

  00adc	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  00ae4	74 29		 je	 SHORT $LN26@cckd_read_

; 1373 :     {
; 1374 :         cckdblk.stats_readaheads++; cckd->readaheads++;

  00ae6	48 8b 05 80 02
	00 00		 mov	 rax, QWORD PTR cckdblk+640
  00aed	48 ff c0	 inc	 rax
  00af0	48 89 05 80 02
	00 00		 mov	 QWORD PTR cckdblk+640, rax
  00af7	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00afc	8b 80 e4 00 00
	00		 mov	 eax, DWORD PTR [rax+228]
  00b02	ff c0		 inc	 eax
  00b04	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00b09	89 81 e4 00 00
	00		 mov	 DWORD PTR [rcx+228], eax
$LN26@cckd_read_:

; 1375 :     }
; 1376 : 
; 1377 :     CCKD_TRACE( "%d rdtrk[%d] %d complete buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x",

  00b0f	b8 01 00 00 00	 mov	 eax, 1
  00b14	48 6b c0 04	 imul	 rax, rax, 4
  00b18	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00b20	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b24	b9 01 00 00 00	 mov	 ecx, 1
  00b29	48 6b c9 03	 imul	 rcx, rcx, 3
  00b2d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00b35	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00b39	ba 01 00 00 00	 mov	 edx, 1
  00b3e	48 6b d2 02	 imul	 rdx, rdx, 2
  00b42	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  00b4a	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  00b4e	bf 01 00 00 00	 mov	 edi, 1
  00b53	48 6b ff 01	 imul	 rdi, rdi, 1
  00b57	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  00b5f	41 0f b6 3c 38	 movzx	 edi, BYTE PTR [r8+rdi]
  00b64	41 b8 01 00 00
	00		 mov	 r8d, 1
  00b6a	4d 6b c0 00	 imul	 r8, r8, 0
  00b6e	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  00b76	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00b7b	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00b7f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00b83	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  00b87	89 7c 24 48	 mov	 DWORD PTR [rsp+72], edi
  00b8b	44 89 44 24 40	 mov	 DWORD PTR [rsp+64], r8d
  00b90	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00b98	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00b9d	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00ba4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00ba8	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
  00bac	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00bb0	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  00bb7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00bbb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170187
  00bc2	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00bca	ba 62 05 00 00	 mov	 edx, 1378		; 00000562H
  00bcf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170188
  00bd6	e8 00 00 00 00	 call	 cckd_trace

; 1378 :                 ra, lru, trk, buf, buf[0], buf[1], buf[2], buf[3], buf[4]);
; 1379 : 
; 1380 :     if (cache_busy_percent(CACHE_DEVBUF) > 80) cckd_flush_cache_all();

  00bdb	33 c9		 xor	 ecx, ecx
  00bdd	e8 00 00 00 00	 call	 cache_busy_percent
  00be2	83 f8 50	 cmp	 eax, 80			; 00000050H
  00be5	7e 05		 jle	 SHORT $LN27@cckd_read_
  00be7	e8 00 00 00 00	 call	 cckd_flush_cache_all
$LN27@cckd_read_:

; 1381 : 
; 1382 :     return lru;

  00bec	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
$LN1@cckd_read_:

; 1383 : 
; 1384 : } /* end function cckd_read_trk */

  00bf0	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00bf7	5f		 pop	 rdi
  00bf8	c3		 ret	 0
cckd_read_trk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
L1idx$ = 32
sfx$ = 36
l2x$ = 40
rc$ = 44
cckd$ = 48
l2$ = 56
dev$ = 80
cfba_used PROC

; 1144 : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1145 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 1146 : int             rc;                     /* Return code               */
; 1147 : int             L1idx, l2x;             /* Lookup table indexes      */
; 1148 : int             sfx;                    /* Shadow file suffix        */
; 1149 : CCKD_L2ENT      l2;                     /* Copied level 2 entry      */
; 1150 : 
; 1151 :     if (dev->cckd64)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	74 0f		 je	 SHORT $LN10@cfba_used

; 1152 :         return cfba64_used( dev );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cfba64_used
  00028	e9 35 01 00 00	 jmp	 $LN1@cfba_used
$LN10@cfba_used:

; 1153 : 
; 1154 :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 30	 mov	 QWORD PTR cckd$[rsp], rax

; 1155 : 
; 1156 :     obtain_lock( &cckd->filelock );

  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00043	48 83 c0 10	 add	 rax, 16
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170095
  0004e	48 8b c8	 mov	 rcx, rax
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1157 :     {
; 1158 :         /* Find the last used level 1 table entry */
; 1159 :         for (L1idx = cckd->cdevhdr[0].num_L1tab - 1; L1idx > 0; L1idx--)

  00057	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0005c	48 6b c0 00	 imul	 rax, rax, 0
  00060	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00065	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  0006c	ff c8		 dec	 eax
  0006e	89 44 24 20	 mov	 DWORD PTR L1idx$[rsp], eax
  00072	eb 0a		 jmp	 SHORT $LN4@cfba_used
$LN2@cfba_used:
  00074	8b 44 24 20	 mov	 eax, DWORD PTR L1idx$[rsp]
  00078	ff c8		 dec	 eax
  0007a	89 44 24 20	 mov	 DWORD PTR L1idx$[rsp], eax
$LN4@cfba_used:
  0007e	83 7c 24 20 00	 cmp	 DWORD PTR L1idx$[rsp], 0
  00083	7e 5d		 jle	 SHORT $LN3@cfba_used

; 1160 :         {
; 1161 :             sfx = cckd->sfn;

  00085	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  0008a	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0008d	89 44 24 24	 mov	 DWORD PTR sfx$[rsp], eax
$LN5@cfba_used:

; 1162 :             while (cckd->L1tab[sfx][L1idx] == CCKD_MAXSIZE && sfx > 0) sfx--;

  00091	48 63 44 24 24	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00096	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  0009b	48 8b 54 24 30	 mov	 rdx, QWORD PTR cckd$[rsp]
  000a0	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000a8	83 3c 88 ff	 cmp	 DWORD PTR [rax+rcx*4], -1 ; ffffffffH
  000ac	75 13		 jne	 SHORT $LN6@cfba_used
  000ae	83 7c 24 24 00	 cmp	 DWORD PTR sfx$[rsp], 0
  000b3	7e 0c		 jle	 SHORT $LN6@cfba_used
  000b5	8b 44 24 24	 mov	 eax, DWORD PTR sfx$[rsp]
  000b9	ff c8		 dec	 eax
  000bb	89 44 24 24	 mov	 DWORD PTR sfx$[rsp], eax
  000bf	eb d0		 jmp	 SHORT $LN5@cfba_used
$LN6@cfba_used:

; 1163 :             if (cckd->L1tab[sfx][L1idx]) break;

  000c1	48 63 44 24 24	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000c6	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000cb	48 8b 54 24 30	 mov	 rdx, QWORD PTR cckd$[rsp]
  000d0	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000d8	83 3c 88 00	 cmp	 DWORD PTR [rax+rcx*4], 0
  000dc	74 02		 je	 SHORT $LN11@cfba_used
  000de	eb 02		 jmp	 SHORT $LN3@cfba_used
$LN11@cfba_used:

; 1164 :         }

  000e0	eb 92		 jmp	 SHORT $LN2@cfba_used
$LN3@cfba_used:

; 1165 : 
; 1166 :         /* Find the last used level 2 table entry */
; 1167 :         for (l2x = 255; l2x >= 0; l2x--)

  000e2	c7 44 24 28 ff
	00 00 00	 mov	 DWORD PTR l2x$[rsp], 255 ; 000000ffH
  000ea	eb 0a		 jmp	 SHORT $LN9@cfba_used
$LN7@cfba_used:
  000ec	8b 44 24 28	 mov	 eax, DWORD PTR l2x$[rsp]
  000f0	ff c8		 dec	 eax
  000f2	89 44 24 28	 mov	 DWORD PTR l2x$[rsp], eax
$LN9@cfba_used:
  000f6	83 7c 24 28 00	 cmp	 DWORD PTR l2x$[rsp], 0
  000fb	7c 34		 jl	 SHORT $LN8@cfba_used

; 1168 :         {
; 1169 :             rc = cckd_read_l2ent (dev, &l2, L1idx * 256 + l2x);

  000fd	69 44 24 20 00
	01 00 00	 imul	 eax, DWORD PTR L1idx$[rsp], 256 ; 00000100H
  00105	03 44 24 28	 add	 eax, DWORD PTR l2x$[rsp]
  00109	44 8b c0	 mov	 r8d, eax
  0010c	48 8d 54 24 38	 lea	 rdx, QWORD PTR l2$[rsp]
  00111	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00116	e8 00 00 00 00	 call	 cckd_read_l2ent
  0011b	89 44 24 2c	 mov	 DWORD PTR rc$[rsp], eax

; 1170 :             if (rc < 0 || l2.L2_trkoff != 0) break;

  0011f	83 7c 24 2c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00124	7c 07		 jl	 SHORT $LN13@cfba_used
  00126	83 7c 24 38 00	 cmp	 DWORD PTR l2$[rsp], 0
  0012b	74 02		 je	 SHORT $LN12@cfba_used
$LN13@cfba_used:
  0012d	eb 02		 jmp	 SHORT $LN8@cfba_used
$LN12@cfba_used:

; 1171 :         }

  0012f	eb bb		 jmp	 SHORT $LN7@cfba_used
$LN8@cfba_used:

; 1172 :     }
; 1173 :     release_lock( &cckd->filelock );

  00131	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00136	48 83 c0 10	 add	 rax, 16
  0013a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170099
  00141	48 8b c8	 mov	 rcx, rax
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1174 : 
; 1175 :     return (L1idx * 256 + l2x + CFBA_BLKS_PER_GRP) / CFBA_BLKS_PER_GRP;

  0014a	69 44 24 20 00
	01 00 00	 imul	 eax, DWORD PTR L1idx$[rsp], 256 ; 00000100H
  00152	8b 4c 24 28	 mov	 ecx, DWORD PTR l2x$[rsp]
  00156	8d 44 08 78	 lea	 eax, DWORD PTR [rax+rcx+120]
  0015a	99		 cdq
  0015b	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00160	f7 f9		 idiv	 ecx
$LN1@cfba_used:

; 1176 : }

  00162	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00166	c3		 ret	 0
cfba_used ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
L1idx$ = 32
sfx$ = 36
l2x$ = 40
rc$ = 44
cckd$ = 48
l2$ = 56
dev$ = 80
cckd_used PROC

; 973  : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 974  : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 975  : int             rc;                     /* Return code               */
; 976  : int             L1idx, l2x;             /* Lookup table indexes      */
; 977  : int             sfx;                    /* Shadow file suffix        */
; 978  : CCKD_L2ENT      l2;                     /* Copied level 2 entry      */
; 979  : 
; 980  :     if (dev->cckd64)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	74 0f		 je	 SHORT $LN10@cckd_used

; 981  :         return cckd64_used( dev );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd64_used
  00028	e9 40 01 00 00	 jmp	 $LN1@cckd_used
$LN10@cckd_used:

; 982  : 
; 983  :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 30	 mov	 QWORD PTR cckd$[rsp], rax

; 984  : 
; 985  :     obtain_lock( &cckd->filelock );

  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00043	48 83 c0 10	 add	 rax, 16
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170009
  0004e	48 8b c8	 mov	 rcx, rax
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 986  :     {
; 987  :         /* Find the last used level 1 table entry */
; 988  :         for (L1idx = cckd->cdevhdr[0].num_L1tab - 1; L1idx > 0; L1idx--)

  00057	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0005c	48 6b c0 00	 imul	 rax, rax, 0
  00060	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00065	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  0006c	ff c8		 dec	 eax
  0006e	89 44 24 20	 mov	 DWORD PTR L1idx$[rsp], eax
  00072	eb 0a		 jmp	 SHORT $LN4@cckd_used
$LN2@cckd_used:
  00074	8b 44 24 20	 mov	 eax, DWORD PTR L1idx$[rsp]
  00078	ff c8		 dec	 eax
  0007a	89 44 24 20	 mov	 DWORD PTR L1idx$[rsp], eax
$LN4@cckd_used:
  0007e	83 7c 24 20 00	 cmp	 DWORD PTR L1idx$[rsp], 0
  00083	7e 5d		 jle	 SHORT $LN3@cckd_used

; 989  :         {
; 990  :             sfx = cckd->sfn;

  00085	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  0008a	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0008d	89 44 24 24	 mov	 DWORD PTR sfx$[rsp], eax
$LN5@cckd_used:

; 991  :             while (cckd->L1tab[sfx][L1idx] == CCKD_MAXSIZE && sfx > 0) sfx--;

  00091	48 63 44 24 24	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00096	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  0009b	48 8b 54 24 30	 mov	 rdx, QWORD PTR cckd$[rsp]
  000a0	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000a8	83 3c 88 ff	 cmp	 DWORD PTR [rax+rcx*4], -1 ; ffffffffH
  000ac	75 13		 jne	 SHORT $LN6@cckd_used
  000ae	83 7c 24 24 00	 cmp	 DWORD PTR sfx$[rsp], 0
  000b3	7e 0c		 jle	 SHORT $LN6@cckd_used
  000b5	8b 44 24 24	 mov	 eax, DWORD PTR sfx$[rsp]
  000b9	ff c8		 dec	 eax
  000bb	89 44 24 24	 mov	 DWORD PTR sfx$[rsp], eax
  000bf	eb d0		 jmp	 SHORT $LN5@cckd_used
$LN6@cckd_used:

; 992  :             if (cckd->L1tab[sfx][L1idx]) break;

  000c1	48 63 44 24 24	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000c6	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000cb	48 8b 54 24 30	 mov	 rdx, QWORD PTR cckd$[rsp]
  000d0	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000d8	83 3c 88 00	 cmp	 DWORD PTR [rax+rcx*4], 0
  000dc	74 02		 je	 SHORT $LN11@cckd_used
  000de	eb 02		 jmp	 SHORT $LN3@cckd_used
$LN11@cckd_used:

; 993  :         }

  000e0	eb 92		 jmp	 SHORT $LN2@cckd_used
$LN3@cckd_used:

; 994  : 
; 995  :         /* Find the last used level 2 table entry */
; 996  :         for (l2x = 255; l2x >= 0; l2x--)

  000e2	c7 44 24 28 ff
	00 00 00	 mov	 DWORD PTR l2x$[rsp], 255 ; 000000ffH
  000ea	eb 0a		 jmp	 SHORT $LN9@cckd_used
$LN7@cckd_used:
  000ec	8b 44 24 28	 mov	 eax, DWORD PTR l2x$[rsp]
  000f0	ff c8		 dec	 eax
  000f2	89 44 24 28	 mov	 DWORD PTR l2x$[rsp], eax
$LN9@cckd_used:
  000f6	83 7c 24 28 00	 cmp	 DWORD PTR l2x$[rsp], 0
  000fb	7c 34		 jl	 SHORT $LN8@cckd_used

; 997  :         {
; 998  :             rc = cckd_read_l2ent (dev, &l2, L1idx * 256 + l2x);

  000fd	69 44 24 20 00
	01 00 00	 imul	 eax, DWORD PTR L1idx$[rsp], 256 ; 00000100H
  00105	03 44 24 28	 add	 eax, DWORD PTR l2x$[rsp]
  00109	44 8b c0	 mov	 r8d, eax
  0010c	48 8d 54 24 38	 lea	 rdx, QWORD PTR l2$[rsp]
  00111	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00116	e8 00 00 00 00	 call	 cckd_read_l2ent
  0011b	89 44 24 2c	 mov	 DWORD PTR rc$[rsp], eax

; 999  :             if (rc < 0 || l2.L2_trkoff != 0) break;

  0011f	83 7c 24 2c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00124	7c 07		 jl	 SHORT $LN13@cckd_used
  00126	83 7c 24 38 00	 cmp	 DWORD PTR l2$[rsp], 0
  0012b	74 02		 je	 SHORT $LN12@cckd_used
$LN13@cckd_used:
  0012d	eb 02		 jmp	 SHORT $LN8@cckd_used
$LN12@cckd_used:

; 1000 :         }

  0012f	eb bb		 jmp	 SHORT $LN7@cckd_used
$LN8@cckd_used:

; 1001 :     }
; 1002 :     release_lock( &cckd->filelock );

  00131	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00136	48 83 c0 10	 add	 rax, 16
  0013a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170013
  00141	48 8b c8	 mov	 rcx, rax
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1003 : 
; 1004 :     return (L1idx * 256 + l2x + dev->ckdheads) / dev->ckdheads;

  0014a	69 44 24 20 00
	01 00 00	 imul	 eax, DWORD PTR L1idx$[rsp], 256 ; 00000100H
  00152	03 44 24 28	 add	 eax, DWORD PTR l2x$[rsp]
  00156	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0015b	03 81 c0 12 00
	00		 add	 eax, DWORD PTR [rcx+4800]
  00161	99		 cdq
  00162	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00167	f7 b9 c0 12 00
	00		 idiv	 DWORD PTR [rcx+4800]
$LN1@cckd_used:

; 1005 : }

  0016d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00171	c3		 ret	 0
cckd_used ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
dev$ = 64
id$ = 72
p$ = 80
cckd_free PROC

; 812  : {

$LN4:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 813  :     CCKD_TRACE( "%s free %p", id, p );

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00018	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0001d	48 8b 44 24 48	 mov	 rax, QWORD PTR id$[rsp]
  00022	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00027	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169931
  0002e	4c 8b 44 24 40	 mov	 r8, QWORD PTR dev$[rsp]
  00033	ba 2d 03 00 00	 mov	 edx, 813		; 0000032dH
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169932
  0003f	e8 00 00 00 00	 call	 cckd_trace

; 814  :     if (p) free( p );

  00044	48 83 7c 24 50
	00		 cmp	 QWORD PTR p$[rsp], 0
  0004a	74 0b		 je	 SHORT $LN2@cckd_free
  0004c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@cckd_free:

; 815  :     return NULL;

  00057	33 c0		 xor	 eax, eax

; 816  : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
cckd_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
tv92 = 96
tv130 = 100
p2$ = 104
tv79 = 112
buf$1 = 128
__$ArrayPad$ = 192
dev$ = 224
id$ = 232
p$ = 240
size$ = 248
cckd_realloc PROC

; 789  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 790  :     void* p2 = NULL;

  0002d	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR p2$[rsp], 0

; 791  : 
; 792  :     if (size)

  00036	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR size$[rsp], 0
  0003f	74 1b		 je	 SHORT $LN2@cckd_reall

; 793  :         p2 = realloc( p, size );

  00041	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR size$[rsp]
  00049	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00057	48 89 44 24 68	 mov	 QWORD PTR p2$[rsp], rax
$LN2@cckd_reall:

; 794  :     CCKD_TRACE( "%s realloc %p len %ld", id, p, (long) size );

  0005c	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  00063	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00067	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  0006f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00074	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR id$[rsp]
  0007c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00081	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169914
  00088	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00090	ba 1a 03 00 00	 mov	 edx, 794		; 0000031aH
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169915
  0009c	e8 00 00 00 00	 call	 cckd_trace

; 795  : 
; 796  :     if (!p2)

  000a1	48 83 7c 24 68
	00		 cmp	 QWORD PTR p2$[rsp], 0
  000a7	0f 85 ff 00 00
	00		 jne	 $LN3@cckd_reall

; 797  :     {
; 798  :         char buf[64];
; 799  :         MSGBUF( buf, "realloc( %p, %d )", p, (int) size );

  000ad	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  000b4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b8	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR p$[rsp]
  000c0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169917
  000c7	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  000cc	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 800  :         // "%1d:%04X CCKD file: error in function %s: %s"
; 801  :         WRMSG( HHC00303, "E", LCSS_DEVNUM, buf, strerror( errno ));

  000da	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000e3	74 12		 je	 SHORT $LN5@cckd_reall
  000e5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ed	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000f1	89 44 24 60	 mov	 DWORD PTR tv92[rsp], eax
  000f5	eb 08		 jmp	 SHORT $LN6@cckd_reall
$LN5@cckd_reall:
  000f7	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN6@cckd_reall:
  000ff	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00108	74 14		 je	 SHORT $LN7@cckd_reall
  0010a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00112	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00116	d1 f8		 sar	 eax, 1
  00118	89 44 24 64	 mov	 DWORD PTR tv130[rsp], eax
  0011c	eb 08		 jmp	 SHORT $LN8@cckd_reall
$LN7@cckd_reall:
  0011e	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN8@cckd_reall:
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0012c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00134	48 89 44 24 70	 mov	 QWORD PTR tv79[rsp], rax
  00139	b9 01 00 00 00	 mov	 ecx, 1
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00144	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv79[rsp]
  00149	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0014e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00156	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0015b	8b 4c 24 60	 mov	 ecx, DWORD PTR tv92[rsp]
  0015f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00163	8b 4c 24 64	 mov	 ecx, DWORD PTR tv130[rsp]
  00167	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169918
  00172	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169919
  0017e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00183	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00188	41 b9 03 00 00
	00		 mov	 r9d, 3
  0018e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169920
  00195	ba 21 03 00 00	 mov	 edx, 801		; 00000321H
  0019a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169921
  001a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 802  :         cckd_print_itrace();

  001a7	e8 00 00 00 00	 call	 cckd_print_itrace
$LN3@cckd_reall:

; 803  :     }
; 804  : 
; 805  :     return p2;

  001ac	48 8b 44 24 68	 mov	 rax, QWORD PTR p2$[rsp]

; 806  : }

  001b1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b9	48 33 cc	 xor	 rcx, rsp
  001bc	e8 00 00 00 00	 call	 __security_check_cookie
  001c1	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  001c8	c3		 ret	 0
cckd_realloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
tv95 = 96
tv133 = 100
p$ = 104
tv82 = 112
buf$1 = 128
__$ArrayPad$ = 192
dev$ = 224
id$ = 232
n$ = 240
size$ = 248
cckd_calloc PROC

; 766  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 767  :     void* p = NULL;

  0002d	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR p$[rsp], 0

; 768  : 
; 769  :     if (n && size)

  00036	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR n$[rsp], 0
  0003f	74 26		 je	 SHORT $LN2@cckd_callo
  00041	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR size$[rsp], 0
  0004a	74 1b		 je	 SHORT $LN2@cckd_callo

; 770  :         p = calloc( n, size );

  0004c	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR size$[rsp]
  00054	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00062	48 89 44 24 68	 mov	 QWORD PTR p$[rsp], rax
$LN2@cckd_callo:

; 771  :     CCKD_TRACE( "%s calloc %p len %ld", id, p, n * (long) size );

  00067	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR size$[rsp]
  0006f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR n$[rsp]
  00077	48 0f af c8	 imul	 rcx, rax
  0007b	48 8b c1	 mov	 rax, rcx
  0007e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00083	48 8b 44 24 68	 mov	 rax, QWORD PTR p$[rsp]
  00088	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR id$[rsp]
  00095	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169891
  000a1	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000a9	ba 03 03 00 00	 mov	 edx, 771		; 00000303H
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169892
  000b5	e8 00 00 00 00	 call	 cckd_trace

; 772  : 
; 773  :     if (!p)

  000ba	48 83 7c 24 68
	00		 cmp	 QWORD PTR p$[rsp], 0
  000c0	0f 85 ff 00 00
	00		 jne	 $LN3@cckd_callo

; 774  :     {
; 775  :         char buf[64];
; 776  :         MSGBUF( buf, "calloc( %d, %d )", (int) n, (int) size );

  000c6	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  000cd	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000d1	44 8b 8c 24 f0
	00 00 00	 mov	 r9d, DWORD PTR n$[rsp]
  000d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169894
  000e0	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  000e5	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 777  :         // "%1d:%04X CCKD file: error in function %s: %s"
; 778  :         WRMSG( HHC00303, "E", LCSS_DEVNUM, buf, strerror( errno ));

  000f3	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000fc	74 12		 je	 SHORT $LN5@cckd_callo
  000fe	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00106	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0010a	89 44 24 60	 mov	 DWORD PTR tv95[rsp], eax
  0010e	eb 08		 jmp	 SHORT $LN6@cckd_callo
$LN5@cckd_callo:
  00110	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN6@cckd_callo:
  00118	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00121	74 14		 je	 SHORT $LN7@cckd_callo
  00123	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0012b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0012f	d1 f8		 sar	 eax, 1
  00131	89 44 24 64	 mov	 DWORD PTR tv133[rsp], eax
  00135	eb 08		 jmp	 SHORT $LN8@cckd_callo
$LN7@cckd_callo:
  00137	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN8@cckd_callo:
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00145	8b 08		 mov	 ecx, DWORD PTR [rax]
  00147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0014d	48 89 44 24 70	 mov	 QWORD PTR tv82[rsp], rax
  00152	b9 01 00 00 00	 mov	 ecx, 1
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0015d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv82[rsp]
  00162	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00167	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0016f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00174	8b 4c 24 60	 mov	 ecx, DWORD PTR tv95[rsp]
  00178	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0017c	8b 4c 24 64	 mov	 ecx, DWORD PTR tv133[rsp]
  00180	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169895
  0018b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169896
  00197	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0019c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a1	41 b9 03 00 00
	00		 mov	 r9d, 3
  001a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169897
  001ae	ba 0a 03 00 00	 mov	 edx, 778		; 0000030aH
  001b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169898
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 779  :         cckd_print_itrace();

  001c0	e8 00 00 00 00	 call	 cckd_print_itrace
$LN3@cckd_callo:

; 780  :     }
; 781  : 
; 782  :     return p;

  001c5	48 8b 44 24 68	 mov	 rax, QWORD PTR p$[rsp]

; 783  : }

  001ca	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d2	48 33 cc	 xor	 rcx, rsp
  001d5	e8 00 00 00 00	 call	 __security_check_cookie
  001da	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  001e1	c3		 ret	 0
cckd_calloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
tv90 = 96
tv128 = 100
p$ = 104
tv78 = 112
buf$1 = 128
__$ArrayPad$ = 192
dev$ = 224
id$ = 232
size$ = 240
cckd_malloc PROC

; 743  : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 744  :     void* p = NULL;

  00028	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR p$[rsp], 0

; 745  : 
; 746  :     if (size)

  00031	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR size$[rsp], 0
  0003a	74 13		 je	 SHORT $LN2@cckd_mallo

; 747  :         p = malloc( size );

  0003c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR size$[rsp]
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0004a	48 89 44 24 68	 mov	 QWORD PTR p$[rsp], rax
$LN2@cckd_mallo:

; 748  :     CCKD_TRACE( "%s malloc %p len %ld", id, p, (long) size );

  0004f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  00056	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0005a	48 8b 44 24 68	 mov	 rax, QWORD PTR p$[rsp]
  0005f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00064	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR id$[rsp]
  0006c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00071	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169867
  00078	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00080	ba ec 02 00 00	 mov	 edx, 748		; 000002ecH
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169868
  0008c	e8 00 00 00 00	 call	 cckd_trace

; 749  : 
; 750  :     if (!p)

  00091	48 83 7c 24 68
	00		 cmp	 QWORD PTR p$[rsp], 0
  00097	0f 85 f4 00 00
	00		 jne	 $LN3@cckd_mallo

; 751  :     {
; 752  :         char buf[64];
; 753  :         MSGBUF( buf, "malloc( %d )", (int) size );

  0009d	44 8b 8c 24 f0
	00 00 00	 mov	 r9d, DWORD PTR size$[rsp]
  000a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169870
  000ac	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  000b1	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 754  :         // "%1d:%04X CCKD file: error in function %s: %s"
; 755  :         WRMSG( HHC00303, "E", LCSS_DEVNUM, buf, strerror( errno ));

  000bf	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000c8	74 12		 je	 SHORT $LN5@cckd_mallo
  000ca	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000d6	89 44 24 60	 mov	 DWORD PTR tv90[rsp], eax
  000da	eb 08		 jmp	 SHORT $LN6@cckd_mallo
$LN5@cckd_mallo:
  000dc	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN6@cckd_mallo:
  000e4	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000ed	74 14		 je	 SHORT $LN7@cckd_mallo
  000ef	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000fb	d1 f8		 sar	 eax, 1
  000fd	89 44 24 64	 mov	 DWORD PTR tv128[rsp], eax
  00101	eb 08		 jmp	 SHORT $LN8@cckd_mallo
$LN7@cckd_mallo:
  00103	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN8@cckd_mallo:
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00111	8b 08		 mov	 ecx, DWORD PTR [rax]
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00119	48 89 44 24 70	 mov	 QWORD PTR tv78[rsp], rax
  0011e	b9 01 00 00 00	 mov	 ecx, 1
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00129	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv78[rsp]
  0012e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00133	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0013b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00140	8b 4c 24 60	 mov	 ecx, DWORD PTR tv90[rsp]
  00144	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00148	8b 4c 24 64	 mov	 ecx, DWORD PTR tv128[rsp]
  0014c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169871
  00157	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169872
  00163	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00168	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00173	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169873
  0017a	ba f3 02 00 00	 mov	 edx, 755		; 000002f3H
  0017f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169874
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 756  :         cckd_print_itrace();

  0018c	e8 00 00 00 00	 call	 cckd_print_itrace
$LN3@cckd_mallo:

; 757  :     }
; 758  : 
; 759  :     return p;

  00191	48 8b 44 24 68	 mov	 rax, QWORD PTR p$[rsp]

; 760  : }

  00196	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0019e	48 33 cc	 xor	 rcx, rsp
  001a1	e8 00 00 00 00	 call	 __security_check_cookie
  001a6	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  001ad	c3		 ret	 0
cckd_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
tv130 = 112
tv136 = 116
cckd$ = 120
tv84 = 128
tv90 = 136
dev$ = 160
sfx$ = 168
off$ = 176
cckd_ftruncate PROC

; 718  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 719  : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 720  : 
; 721  :     cckd = dev->cckd_ext;

  00015	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00024	48 89 44 24 78	 mov	 QWORD PTR cckd$[rsp], rax

; 722  : 
; 723  :     CCKD_TRACE( "file[%d] fd[%d] ftruncate, off 0x%16.16"PRIx64,

  00029	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00031	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00039	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00043	8b 84 81 f0 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+240]
  0004a	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0004e	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  00055	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00059	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169846
  00060	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00068	ba d4 02 00 00	 mov	 edx, 724		; 000002d4H
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169847
  00074	e8 00 00 00 00	 call	 cckd_trace

; 724  :                 sfx, cckd->fd[sfx], off);
; 725  : 
; 726  :     /* Truncate the file */
; 727  :     if (ftruncate (cckd->fd[sfx], off) < 0)

  00079	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00081	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR off$[rsp]
  00089	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0008e	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__chsize_s
  0009b	85 c0		 test	 eax, eax
  0009d	0f 8d 1f 01 00
	00		 jge	 $LN2@cckd_ftrun

; 728  :     {
; 729  :         WRMSG (HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name (dev, sfx),

  000a3	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000ac	74 12		 je	 SHORT $LN4@cckd_ftrun
  000ae	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000ba	89 44 24 70	 mov	 DWORD PTR tv130[rsp], eax
  000be	eb 08		 jmp	 SHORT $LN5@cckd_ftrun
$LN4@cckd_ftrun:
  000c0	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN5@cckd_ftrun:
  000c8	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000d1	74 14		 je	 SHORT $LN6@cckd_ftrun
  000d3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000db	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000df	d1 f8		 sar	 eax, 1
  000e1	89 44 24 74	 mov	 DWORD PTR tv136[rsp], eax
  000e5	eb 08		 jmp	 SHORT $LN7@cckd_ftrun
$LN6@cckd_ftrun:
  000e7	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN7@cckd_ftrun:
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000f5	8b 08		 mov	 ecx, DWORD PTR [rax]
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000fd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
  00105	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  0010c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00114	e8 00 00 00 00	 call	 cckd_sf_name
  00119	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  00121	b9 01 00 00 00	 mov	 ecx, 1
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv84[rsp]
  00134	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00139	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00141	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169849
  0014d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00152	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv90[rsp]
  0015a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0015f	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  00166	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0016a	8b 4c 24 70	 mov	 ecx, DWORD PTR tv130[rsp]
  0016e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00172	8b 4c 24 74	 mov	 ecx, DWORD PTR tv136[rsp]
  00176	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169850
  00181	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169851
  0018d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00192	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00197	41 b9 03 00 00
	00		 mov	 r9d, 3
  0019d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169852
  001a4	ba da 02 00 00	 mov	 edx, 730		; 000002daH
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169853
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 730  :                     "ftruncate()", off, strerror(errno));
; 731  :         cckd_print_itrace ();

  001b6	e8 00 00 00 00	 call	 cckd_print_itrace

; 732  :         return -1;

  001bb	b8 ff ff ff ff	 mov	 eax, -1
  001c0	eb 02		 jmp	 SHORT $LN1@cckd_ftrun
$LN2@cckd_ftrun:

; 733  :     }
; 734  : 
; 735  :     return 0;

  001c2	33 c0		 xor	 eax, eax
$LN1@cckd_ftrun:

; 736  : 
; 737  : } /* end function cckd_ftruncate */

  001c4	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001cb	c3		 ret	 0
cckd_ftruncate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
rc$ = 112
tv132 = 116
tv138 = 120
tv173 = 124
tv179 = 128
tv206 = 132
tv212 = 136
cckd$ = 144
tv86 = 152
tv92 = 160
tv159 = 168
tv165 = 176
tv198 = 184
buf$1 = 192
__$ArrayPad$ = 320
dev$ = 352
sfx$ = 360
off$ = 368
buf$ = 376
len$ = 384
cckd_write PROC

; 671  : {

$LN19:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 672  : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 673  : int             rc = 0;                 /* Return code               */

  0002c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 674  : 
; 675  :     cckd = dev->cckd_ext;

  00034	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00043	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 676  : 
; 677  :     CCKD_TRACE( "file[%d] fd[%d] write, off 0x%16.16"PRIx64" len %d",

  0004b	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00053	8b 8c 24 80 01
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  0005a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0005e	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00066	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00073	8b 84 81 f0 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+240]
  0007a	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0007e	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  00085	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00089	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169816
  00090	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00098	ba a6 02 00 00	 mov	 edx, 678		; 000002a6H
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169817
  000a4	e8 00 00 00 00	 call	 cckd_trace

; 678  :                 sfx, cckd->fd[ sfx ], off, len );
; 679  : 
; 680  :     /* Seek to specified offset */
; 681  :     if (lseek( cckd->fd[ sfx ], off, SEEK_SET ) < 0)

  000a9	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000b1	45 33 c0	 xor	 r8d, r8d
  000b4	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR off$[rsp]
  000bc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  000c4	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  000d1	48 85 c0	 test	 rax, rax
  000d4	0f 8d 22 01 00
	00		 jge	 $LN2@cckd_write

; 682  :     {
; 683  :         // "%1d:%04X CCKD file[%d] %s: error in function %s at offset 0x%16.16"PRIX64": %s"
; 684  :         WRMSG( HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name( dev, sfx ),

  000da	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000e3	74 12		 je	 SHORT $LN7@cckd_write
  000e5	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ed	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000f1	89 44 24 74	 mov	 DWORD PTR tv132[rsp], eax
  000f5	eb 08		 jmp	 SHORT $LN8@cckd_write
$LN7@cckd_write:
  000f7	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv132[rsp], 0
$LN8@cckd_write:
  000ff	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00108	74 14		 je	 SHORT $LN9@cckd_write
  0010a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00112	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00116	d1 f8		 sar	 eax, 1
  00118	89 44 24 78	 mov	 DWORD PTR tv138[rsp], eax
  0011c	eb 08		 jmp	 SHORT $LN10@cckd_write
$LN9@cckd_write:
  0011e	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN10@cckd_write:
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0012c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00134	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv86[rsp], rax
  0013c	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  00143	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0014b	e8 00 00 00 00	 call	 cckd_sf_name
  00150	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv92[rsp], rax
  00158	b9 01 00 00 00	 mov	 ecx, 1
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00163	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv86[rsp]
  0016b	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00170	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00178	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0017d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169819
  00184	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00189	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv92[rsp]
  00191	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00196	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  0019d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001a1	8b 4c 24 74	 mov	 ecx, DWORD PTR tv132[rsp]
  001a5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001a9	8b 4c 24 78	 mov	 ecx, DWORD PTR tv138[rsp]
  001ad	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169820
  001b8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169821
  001c4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ce	41 b9 03 00 00
	00		 mov	 r9d, 3
  001d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169822
  001db	ba ad 02 00 00	 mov	 edx, 685		; 000002adH
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169823
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 685  :             "lseek()", off, strerror( errno ));
; 686  :         cckd_print_itrace();

  001ed	e8 00 00 00 00	 call	 cckd_print_itrace

; 687  :         return -1;

  001f2	b8 ff ff ff ff	 mov	 eax, -1
  001f7	e9 b7 02 00 00	 jmp	 $LN1@cckd_write
$LN2@cckd_write:

; 688  :     }
; 689  : 
; 690  :     /* Write the data */
; 691  :     rc = write( cckd->fd[ sfx ], buf, len );

  001fc	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00204	44 8b 84 24 80
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0020c	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00214	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0021c	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  00223	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00229	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 692  :     if (rc < (int)len)

  0022d	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00234	39 44 24 70	 cmp	 DWORD PTR rc$[rsp], eax
  00238	0f 8d 71 02 00
	00		 jge	 $LN3@cckd_write

; 693  :     {
; 694  :         if (rc < 0)

  0023e	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00243	0f 8d 21 01 00
	00		 jge	 $LN4@cckd_write

; 695  :             // "%1d:%04X CCKD file[%d] %s: error in function %s at offset 0x%16.16"PRIX64": %s"
; 696  :             WRMSG( HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name( dev, sfx ),

  00249	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00252	74 12		 je	 SHORT $LN11@cckd_write
  00254	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0025c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00260	89 44 24 7c	 mov	 DWORD PTR tv173[rsp], eax
  00264	eb 08		 jmp	 SHORT $LN12@cckd_write
$LN11@cckd_write:
  00266	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv173[rsp], 0
$LN12@cckd_write:
  0026e	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00277	74 17		 je	 SHORT $LN13@cckd_write
  00279	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00281	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00285	d1 f8		 sar	 eax, 1
  00287	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv179[rsp], eax
  0028e	eb 0b		 jmp	 SHORT $LN14@cckd_write
$LN13@cckd_write:
  00290	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv179[rsp], 0
$LN14@cckd_write:
  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002a1	8b 08		 mov	 ecx, DWORD PTR [rax]
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002a9	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv159[rsp], rax
  002b1	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  002b8	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002c0	e8 00 00 00 00	 call	 cckd_sf_name
  002c5	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv165[rsp], rax
  002cd	b9 01 00 00 00	 mov	 ecx, 1
  002d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002d8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv159[rsp]
  002e0	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  002e5	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  002ed	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  002f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169827
  002f9	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002fe	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv165[rsp]
  00306	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0030b	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  00312	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00316	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv173[rsp]
  0031a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0031e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv179[rsp]
  00325	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00329	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169828
  00330	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00335	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169829
  0033c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00341	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00346	41 b9 03 00 00
	00		 mov	 r9d, 3
  0034c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169830
  00353	ba b9 02 00 00	 mov	 edx, 697		; 000002b9H
  00358	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169831
  0035f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00365	e9 39 01 00 00	 jmp	 $LN5@cckd_write
$LN4@cckd_write:

; 697  :                 "write()", off, strerror( errno ));
; 698  :         else
; 699  :         {
; 700  :             char buf[128];
; 701  :             MSGBUF( buf, "write incomplete: write %d, expected %d", rc, len );

  0036a	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00371	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00375	44 8b 4c 24 70	 mov	 r9d, DWORD PTR rc$[rsp]
  0037a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169832
  00381	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00386	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0038e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 702  :             // "%1d:%04X CCKD file[%d] %s: error in function %s at offset 0x%16.16"PRIX64": %s"
; 703  :             WRMSG( HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name( dev, sfx ),

  00394	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0039d	74 15		 je	 SHORT $LN15@cckd_write
  0039f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003a7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003ab	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv206[rsp], eax
  003b2	eb 0b		 jmp	 SHORT $LN16@cckd_write
$LN15@cckd_write:
  003b4	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv206[rsp], 0
$LN16@cckd_write:
  003bf	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003c8	74 17		 je	 SHORT $LN17@cckd_write
  003ca	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d2	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003d6	d1 f8		 sar	 eax, 1
  003d8	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv212[rsp], eax
  003df	eb 0b		 jmp	 SHORT $LN18@cckd_write
$LN17@cckd_write:
  003e1	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
$LN18@cckd_write:
  003ec	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  003f3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003fb	e8 00 00 00 00	 call	 cckd_sf_name
  00400	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv198[rsp], rax
  00408	b9 01 00 00 00	 mov	 ecx, 1
  0040d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00413	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0041b	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00420	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00428	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0042d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169833
  00434	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00439	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv198[rsp]
  00441	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00446	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  0044d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00451	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv206[rsp]
  00458	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0045c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv212[rsp]
  00463	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00467	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169834
  0046e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00473	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169835
  0047a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0047f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00484	41 b9 03 00 00
	00		 mov	 r9d, 3
  0048a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169836
  00491	ba c0 02 00 00	 mov	 edx, 704		; 000002c0H
  00496	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169837
  0049d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@cckd_write:

; 704  :                 "write()", off, buf );
; 705  :         }
; 706  :         cckd_print_itrace();

  004a3	e8 00 00 00 00	 call	 cckd_print_itrace

; 707  :         return -1;

  004a8	b8 ff ff ff ff	 mov	 eax, -1
  004ad	eb 04		 jmp	 SHORT $LN1@cckd_write
$LN3@cckd_write:

; 708  :     }
; 709  : 
; 710  :     return rc;

  004af	8b 44 24 70	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cckd_write:

; 711  : 
; 712  : } /* end function cckd_write */

  004b3	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004bb	48 33 cc	 xor	 rcx, rsp
  004be	e8 00 00 00 00	 call	 __security_check_cookie
  004c3	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  004ca	c3		 ret	 0
cckd_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
rc$ = 112
tv132 = 116
tv138 = 120
tv173 = 124
tv179 = 128
tv206 = 132
tv212 = 136
cckd$ = 144
tv86 = 152
tv92 = 160
tv159 = 168
tv165 = 176
tv198 = 184
buf$1 = 192
__$ArrayPad$ = 320
dev$ = 352
sfx$ = 360
off$ = 368
buf$ = 376
len$ = 384
cckd_read PROC

; 624  : {

$LN19:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 625  : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 626  : int             rc;                     /* Return code               */
; 627  : 
; 628  :     cckd = dev->cckd_ext;

  0002c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00034	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0003b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 629  : 
; 630  :     CCKD_TRACE( "file[%d] fd[%d] read, off 0x%16.16"PRIx64" len %d",

  00043	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0004b	8b 8c 24 80 01
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00052	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00056	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  0005e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00063	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0006b	8b 84 81 f0 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+240]
  00072	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00076	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  0007d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00081	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169779
  00088	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00090	ba 77 02 00 00	 mov	 edx, 631		; 00000277H
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169780
  0009c	e8 00 00 00 00	 call	 cckd_trace

; 631  :                 sfx, cckd->fd[ sfx ], off, len );
; 632  : 
; 633  :     /* Seek to specified offset */
; 634  :     if (lseek( cckd->fd[ sfx ], off, SEEK_SET ) < 0)

  000a1	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000a9	45 33 c0	 xor	 r8d, r8d
  000ac	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR off$[rsp]
  000b4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  000bc	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  000c9	48 85 c0	 test	 rax, rax
  000cc	0f 8d 22 01 00
	00		 jge	 $LN2@cckd_read

; 635  :     {
; 636  :         // "%1d:%04X CCKD file[%d] %s: error in function %s at offset 0x%16.16"PRIX64": %s"
; 637  :         WRMSG( HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name( dev, sfx ),

  000d2	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000db	74 12		 je	 SHORT $LN7@cckd_read
  000dd	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000e9	89 44 24 74	 mov	 DWORD PTR tv132[rsp], eax
  000ed	eb 08		 jmp	 SHORT $LN8@cckd_read
$LN7@cckd_read:
  000ef	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv132[rsp], 0
$LN8@cckd_read:
  000f7	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00100	74 14		 je	 SHORT $LN9@cckd_read
  00102	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0010e	d1 f8		 sar	 eax, 1
  00110	89 44 24 78	 mov	 DWORD PTR tv138[rsp], eax
  00114	eb 08		 jmp	 SHORT $LN10@cckd_read
$LN9@cckd_read:
  00116	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN10@cckd_read:
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00124	8b 08		 mov	 ecx, DWORD PTR [rax]
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0012c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv86[rsp], rax
  00134	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  0013b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00143	e8 00 00 00 00	 call	 cckd_sf_name
  00148	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv92[rsp], rax
  00150	b9 01 00 00 00	 mov	 ecx, 1
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0015b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv86[rsp]
  00163	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00168	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00170	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169782
  0017c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00181	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv92[rsp]
  00189	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0018e	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  00195	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00199	8b 4c 24 74	 mov	 ecx, DWORD PTR tv132[rsp]
  0019d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001a1	8b 4c 24 78	 mov	 ecx, DWORD PTR tv138[rsp]
  001a5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169783
  001b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169784
  001bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169785
  001d3	ba 7e 02 00 00	 mov	 edx, 638		; 0000027eH
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169786
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 638  :             "lseek()", off, strerror( errno ));
; 639  :         cckd_print_itrace();

  001e5	e8 00 00 00 00	 call	 cckd_print_itrace

; 640  :         return -1;

  001ea	b8 ff ff ff ff	 mov	 eax, -1
  001ef	e9 b7 02 00 00	 jmp	 $LN1@cckd_read
$LN2@cckd_read:

; 641  :     }
; 642  : 
; 643  :     /* Read the data */
; 644  :     rc = read( cckd->fd[ sfx ], buf, len );

  001f4	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001fc	44 8b 84 24 80
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00204	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0020c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00214	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00221	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 645  :     if (rc < (int)len)

  00225	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0022c	39 44 24 70	 cmp	 DWORD PTR rc$[rsp], eax
  00230	0f 8d 71 02 00
	00		 jge	 $LN3@cckd_read

; 646  :     {
; 647  :         if (rc < 0)

  00236	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  0023b	0f 8d 21 01 00
	00		 jge	 $LN4@cckd_read

; 648  :             // "%1d:%04X CCKD file[%d] %s: error in function %s at offset 0x%16.16"PRIX64": %s"
; 649  :             WRMSG (HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name (dev, sfx),

  00241	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0024a	74 12		 je	 SHORT $LN11@cckd_read
  0024c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00254	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00258	89 44 24 7c	 mov	 DWORD PTR tv173[rsp], eax
  0025c	eb 08		 jmp	 SHORT $LN12@cckd_read
$LN11@cckd_read:
  0025e	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv173[rsp], 0
$LN12@cckd_read:
  00266	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0026f	74 17		 je	 SHORT $LN13@cckd_read
  00271	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00279	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0027d	d1 f8		 sar	 eax, 1
  0027f	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv179[rsp], eax
  00286	eb 0b		 jmp	 SHORT $LN14@cckd_read
$LN13@cckd_read:
  00288	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv179[rsp], 0
$LN14@cckd_read:
  00293	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00299	8b 08		 mov	 ecx, DWORD PTR [rax]
  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002a1	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv159[rsp], rax
  002a9	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  002b0	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002b8	e8 00 00 00 00	 call	 cckd_sf_name
  002bd	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv165[rsp], rax
  002c5	b9 01 00 00 00	 mov	 ecx, 1
  002ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002d0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv159[rsp]
  002d8	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  002dd	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  002e5	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  002ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169790
  002f1	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002f6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv165[rsp]
  002fe	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00303	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  0030a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0030e	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv173[rsp]
  00312	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00316	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv179[rsp]
  0031d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00321	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169791
  00328	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0032d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169792
  00334	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00339	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0033e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00344	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169793
  0034b	ba 8a 02 00 00	 mov	 edx, 650		; 0000028aH
  00350	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169794
  00357	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  0035d	e9 39 01 00 00	 jmp	 $LN5@cckd_read
$LN4@cckd_read:

; 650  :                 "read()", off, strerror(errno));
; 651  :         else
; 652  :         {
; 653  :             char buf[128];
; 654  :             MSGBUF( buf, "read incomplete: read %d, expected %d", rc, len );

  00362	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00369	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0036d	44 8b 4c 24 70	 mov	 r9d, DWORD PTR rc$[rsp]
  00372	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169795
  00379	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0037e	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00386	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 655  :             // "%1d:%04X CCKD file[%d] %s: error in function %s at offset 0x%16.16"PRIX64": %s"
; 656  :             WRMSG( HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name( dev, sfx ),

  0038c	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00395	74 15		 je	 SHORT $LN15@cckd_read
  00397	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0039f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003a3	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv206[rsp], eax
  003aa	eb 0b		 jmp	 SHORT $LN16@cckd_read
$LN15@cckd_read:
  003ac	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv206[rsp], 0
$LN16@cckd_read:
  003b7	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003c0	74 17		 je	 SHORT $LN17@cckd_read
  003c2	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003ca	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003ce	d1 f8		 sar	 eax, 1
  003d0	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv212[rsp], eax
  003d7	eb 0b		 jmp	 SHORT $LN18@cckd_read
$LN17@cckd_read:
  003d9	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
$LN18@cckd_read:
  003e4	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  003eb	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003f3	e8 00 00 00 00	 call	 cckd_sf_name
  003f8	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv198[rsp], rax
  00400	b9 01 00 00 00	 mov	 ecx, 1
  00405	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0040b	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00413	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00418	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00420	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00425	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169796
  0042c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00431	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv198[rsp]
  00439	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0043e	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  00445	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00449	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv206[rsp]
  00450	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00454	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv212[rsp]
  0045b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0045f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169797
  00466	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0046b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169798
  00472	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00477	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0047c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00482	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169799
  00489	ba 91 02 00 00	 mov	 edx, 657		; 00000291H
  0048e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169800
  00495	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@cckd_read:

; 657  :                 "read()", off, buf);
; 658  :         }
; 659  :         cckd_print_itrace ();

  0049b	e8 00 00 00 00	 call	 cckd_print_itrace

; 660  :         return -1;

  004a0	b8 ff ff ff ff	 mov	 eax, -1
  004a5	eb 04		 jmp	 SHORT $LN1@cckd_read
$LN3@cckd_read:

; 661  :     }
; 662  : 
; 663  :     return rc;

  004a7	8b 44 24 70	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cckd_read:

; 664  : 
; 665  : } /* end function cckd_read */

  004ab	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004b3	48 33 cc	 xor	 rcx, rsp
  004b6	e8 00 00 00 00	 call	 __security_check_cookie
  004bb	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  004c2	c3		 ret	 0
cckd_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
rc$ = 112
tv136 = 116
tv142 = 120
cckd$ = 128
tv91 = 136
tv128 = 144
dev$ = 176
sfx$ = 184
cckd_close PROC

; 594  : {

$LN10:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 595  : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 596  : int             rc = 0;                 /* Return code               */

  00010	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 597  : 
; 598  :     cckd = dev->cckd_ext;

  00018	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00020	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00027	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 599  : 
; 600  :     CCKD_TRACE( "file[%d] fd[%d] close %s",

  0002f	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  00036	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0003e	e8 00 00 00 00	 call	 cckd_sf_name
  00043	48 63 8c 24 b8
	00 00 00	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0004b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00050	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00058	8b 84 88 f0 00
	00 00		 mov	 eax, DWORD PTR [rax+rcx*4+240]
  0005f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00063	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  0006a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0006e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169754
  00075	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0007d	ba 59 02 00 00	 mov	 edx, 601		; 00000259H
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169755
  00089	e8 00 00 00 00	 call	 cckd_trace

; 601  :                 sfx, cckd->fd[sfx], cckd_sf_name(dev, sfx));
; 602  : 
; 603  :     if (cckd->fd[sfx] >= 0)

  0008e	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00096	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0009e	83 bc 81 f0 00
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+240], 0
  000a6	7c 21		 jl	 SHORT $LN2@cckd_close

; 604  :         rc = close (cckd->fd[sfx]);

  000a8	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000b0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  000b8	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  000c5	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
$LN2@cckd_close:

; 605  : 
; 606  :     if (rc < 0)

  000c9	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  000ce	0f 8d 0b 01 00
	00		 jge	 $LN3@cckd_close

; 607  :     {
; 608  :         WRMSG (HHC00301, "E", LCSS_DEVNUM, sfx, cckd_sf_name (dev, sfx),

  000d4	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000dd	74 12		 je	 SHORT $LN6@cckd_close
  000df	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000eb	89 44 24 74	 mov	 DWORD PTR tv136[rsp], eax
  000ef	eb 08		 jmp	 SHORT $LN7@cckd_close
$LN6@cckd_close:
  000f1	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN7@cckd_close:
  000f9	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00102	74 14		 je	 SHORT $LN8@cckd_close
  00104	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00110	d1 f8		 sar	 eax, 1
  00112	89 44 24 78	 mov	 DWORD PTR tv142[rsp], eax
  00116	eb 08		 jmp	 SHORT $LN9@cckd_close
$LN8@cckd_close:
  00118	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN9@cckd_close:
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00126	8b 08		 mov	 ecx, DWORD PTR [rax]
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0012e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv91[rsp], rax
  00136	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  0013d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00145	e8 00 00 00 00	 call	 cckd_sf_name
  0014a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv128[rsp], rax
  00152	b9 01 00 00 00	 mov	 ecx, 1
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0015d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv91[rsp]
  00165	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169758
  00171	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00176	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv128[rsp]
  0017e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00183	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  0018a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0018e	8b 4c 24 74	 mov	 ecx, DWORD PTR tv136[rsp]
  00192	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00196	8b 4c 24 78	 mov	 ecx, DWORD PTR tv142[rsp]
  0019a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0019e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169759
  001a5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169760
  001b1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bb	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169761
  001c8	ba 61 02 00 00	 mov	 edx, 609		; 00000261H
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169762
  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 609  :                               "close()", strerror(errno));
; 610  :         cckd_print_itrace ();

  001da	e8 00 00 00 00	 call	 cckd_print_itrace
$LN3@cckd_close:

; 611  :     }
; 612  : 
; 613  :     cckd->fd[sfx] = -1;

  001df	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001e7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ef	c7 84 81 f0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+240], -1

; 614  :     if (sfx == 0) dev->fd = -1;

  001fa	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR sfx$[rsp], 0
  00202	75 12		 jne	 SHORT $LN4@cckd_close
  00204	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020c	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1
$LN4@cckd_close:

; 615  : 
; 616  :     return rc;

  00216	8b 44 24 70	 mov	 eax, DWORD PTR rc$[rsp]

; 617  : 
; 618  : } /* end function cckd_close */

  0021a	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00221	c3		 ret	 0
cckd_close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
cckd$ = 112
tv68 = 120
tv144 = 124
tv146 = 128
tv162 = 132
tv168 = 136
err$ = 140
tv149 = 144
tv154 = 152
pathname$ = 160
__$ArrayPad$ = 432
dev$ = 464
sfx$ = 472
flags$ = 480
mode$ = 488
cckd_open PROC

; 550  : {

$LN18:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 551  : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 552  : int             err;                    /* 1 = issue error message   */
; 553  : char            pathname[MAX_PATH];     /* file path in host format  */
; 554  : 
; 555  :     cckd = dev->cckd_ext;

  0002c	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00034	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0003b	48 89 44 24 70	 mov	 QWORD PTR cckd$[rsp], rax

; 556  : 
; 557  :     err = !((flags & O_CREAT) == 0 && mode != 0);

  00040	8b 84 24 e0 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00047	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0004c	85 c0		 test	 eax, eax
  0004e	75 14		 jne	 SHORT $LN8@cckd_open
  00050	83 bc 24 e8 01
	00 00 00	 cmp	 DWORD PTR mode$[rsp], 0
  00058	74 0a		 je	 SHORT $LN8@cckd_open
  0005a	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
  00062	eb 08		 jmp	 SHORT $LN9@cckd_open
$LN8@cckd_open:
  00064	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
$LN9@cckd_open:
  0006c	8b 44 24 78	 mov	 eax, DWORD PTR tv68[rsp]
  00070	89 84 24 8c 00
	00 00		 mov	 DWORD PTR err$[rsp], eax

; 558  : 
; 559  :     if (cckd->fd[sfx] >= 0)

  00077	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0007f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00084	83 bc 81 f0 00
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+240], 0
  0008c	7c 14		 jl	 SHORT $LN2@cckd_open

; 560  :         cckd_close (dev, sfx);

  0008e	8b 94 24 d8 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  00095	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0009d	e8 00 00 00 00	 call	 cckd_close
$LN2@cckd_open:

; 561  : 
; 562  :     hostpath(pathname, cckd_sf_name (dev, sfx), sizeof(pathname));

  000a2	8b 94 24 d8 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  000a9	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000b1	e8 00 00 00 00	 call	 cckd_sf_name
  000b6	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000bc	48 8b d0	 mov	 rdx, rax
  000bf	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 563  :     cckd->fd[sfx] = HOPEN (pathname, flags, mode);

  000cd	44 8b 84 24 e8
	01 00 00	 mov	 r8d, DWORD PTR mode$[rsp]
  000d5	8b 94 24 e0 01
	00 00		 mov	 edx, DWORD PTR flags$[rsp]
  000dc	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  000ea	48 63 8c 24 d8
	01 00 00	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  000f2	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  000f7	89 84 8a f0 00
	00 00		 mov	 DWORD PTR [rdx+rcx*4+240], eax

; 564  :     if (sfx == 0) dev->fd = cckd->fd[sfx];

  000fe	83 bc 24 d8 01
	00 00 00	 cmp	 DWORD PTR sfx$[rsp], 0
  00106	75 22		 jne	 SHORT $LN3@cckd_open
  00108	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00110	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00118	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  0011d	8b 84 82 f0 00
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+240]
  00124	89 81 ac 01 00
	00		 mov	 DWORD PTR [rcx+428], eax
$LN3@cckd_open:

; 565  : 
; 566  :     if (cckd->fd[sfx] >= 0)

  0012a	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00132	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00137	83 bc 81 f0 00
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+240], 0
  0013f	7c 73		 jl	 SHORT $LN4@cckd_open

; 567  :         cckd->open[sfx] = flags & O_RDWR ? CCKD_OPEN_RW :

  00141	8b 84 24 e0 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00148	83 e0 02	 and	 eax, 2
  0014b	85 c0		 test	 eax, eax
  0014d	74 0d		 je	 SHORT $LN12@cckd_open
  0014f	c7 84 24 80 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv146[rsp], 3
  0015a	eb 37		 jmp	 SHORT $LN13@cckd_open
$LN12@cckd_open:
  0015c	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00164	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00169	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  00171	83 f8 03	 cmp	 eax, 3
  00174	75 0a		 jne	 SHORT $LN10@cckd_open
  00176	c7 44 24 7c 02
	00 00 00	 mov	 DWORD PTR tv144[rsp], 2
  0017e	eb 08		 jmp	 SHORT $LN11@cckd_open
$LN10@cckd_open:
  00180	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv144[rsp], 1
$LN11@cckd_open:
  00188	8b 44 24 7c	 mov	 eax, DWORD PTR tv144[rsp]
  0018c	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv146[rsp], eax
$LN13@cckd_open:
  00193	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0019b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  001a0	0f b6 94 24 80
	00 00 00	 movzx	 edx, BYTE PTR tv146[rsp]
  001a8	88 94 01 1d 01
	00 00		 mov	 BYTE PTR [rcx+rax+285], dl
  001af	e9 b2 01 00 00	 jmp	 $LN5@cckd_open
$LN4@cckd_open:

; 568  :                           cckd->open[sfx] == CCKD_OPEN_RW ?
; 569  :                           CCKD_OPEN_RD : CCKD_OPEN_RO;
; 570  :     else
; 571  :     {
; 572  :         if (err)

  001b4	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR err$[rsp], 0
  001bc	0f 84 8f 01 00
	00		 je	 $LN6@cckd_open

; 573  :         {
; 574  :             WRMSG (HHC00301, "E", LCSS_DEVNUM, sfx, cckd_sf_name (dev, sfx),

  001c2	48 83 bc 24 d0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001cb	74 15		 je	 SHORT $LN14@cckd_open
  001cd	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001d9	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv162[rsp], eax
  001e0	eb 0b		 jmp	 SHORT $LN15@cckd_open
$LN14@cckd_open:
  001e2	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv162[rsp], 0
$LN15@cckd_open:
  001ed	48 83 bc 24 d0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001f6	74 17		 je	 SHORT $LN16@cckd_open
  001f8	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00200	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00204	d1 f8		 sar	 eax, 1
  00206	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv168[rsp], eax
  0020d	eb 0b		 jmp	 SHORT $LN17@cckd_open
$LN16@cckd_open:
  0020f	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv168[rsp], 0
$LN17@cckd_open:
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00220	8b 08		 mov	 ecx, DWORD PTR [rax]
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00228	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv149[rsp], rax
  00230	8b 94 24 d8 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  00237	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0023f	e8 00 00 00 00	 call	 cckd_sf_name
  00244	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv154[rsp], rax
  0024c	b9 01 00 00 00	 mov	 ecx, 1
  00251	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00257	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv149[rsp]
  0025f	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169738
  0026b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00270	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv154[rsp]
  00278	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0027d	8b 8c 24 d8 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  00284	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00288	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv162[rsp]
  0028f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00293	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv168[rsp]
  0029a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0029e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169739
  002a5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169740
  002b1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002bb	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169741
  002c8	ba 3f 02 00 00	 mov	 edx, 575		; 0000023fH
  002cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169742
  002d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 575  :                     "open()", strerror(errno));
; 576  :             CCKD_TRACE( "file[%d] fd[%d] open %s error flags %8.8x mode %8.8x",

  002da	8b 94 24 d8 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  002e1	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e9	e8 00 00 00 00	 call	 cckd_sf_name
  002ee	48 63 8c 24 d8
	01 00 00	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  002f6	8b 94 24 e8 01
	00 00		 mov	 edx, DWORD PTR mode$[rsp]
  002fd	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  00301	8b 94 24 e0 01
	00 00		 mov	 edx, DWORD PTR flags$[rsp]
  00308	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  0030c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00311	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00316	8b 84 88 f0 00
	00 00		 mov	 eax, DWORD PTR [rax+rcx*4+240]
  0031d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00321	8b 84 24 d8 01
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  00328	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0032c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169743
  00333	4c 8b 84 24 d0
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0033b	ba 41 02 00 00	 mov	 edx, 577		; 00000241H
  00340	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169744
  00347	e8 00 00 00 00	 call	 cckd_trace

; 577  :                         sfx, cckd->fd[sfx], cckd_sf_name (dev, sfx), flags, mode);
; 578  :             cckd_print_itrace ();

  0034c	e8 00 00 00 00	 call	 cckd_print_itrace
$LN6@cckd_open:

; 579  :         }
; 580  :         cckd->open[sfx] = CCKD_OPEN_NONE;

  00351	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00359	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  0035e	c6 84 01 1d 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+285], 0
$LN5@cckd_open:

; 581  :     }
; 582  : 
; 583  :     CCKD_TRACE( "file[%d] fd[%d] open %s, flags %8.8x mode %8.8x",

  00366	8b 94 24 d8 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  0036d	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00375	e8 00 00 00 00	 call	 cckd_sf_name
  0037a	48 63 8c 24 d8
	01 00 00	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00382	8b 94 24 e8 01
	00 00		 mov	 edx, DWORD PTR mode$[rsp]
  00389	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  0038d	8b 94 24 e0 01
	00 00		 mov	 edx, DWORD PTR flags$[rsp]
  00394	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  00398	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0039d	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  003a2	8b 84 88 f0 00
	00 00		 mov	 eax, DWORD PTR [rax+rcx*4+240]
  003a9	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003ad	8b 84 24 d8 01
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  003b4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003b8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169745
  003bf	4c 8b 84 24 d0
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  003c7	ba 48 02 00 00	 mov	 edx, 584		; 00000248H
  003cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169746
  003d3	e8 00 00 00 00	 call	 cckd_trace

; 584  :                 sfx, cckd->fd[sfx], cckd_sf_name (dev, sfx), flags, mode);
; 585  : 
; 586  :     return cckd->fd[sfx];

  003d8	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  003e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  003e5	8b 84 81 f0 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+240]

; 587  : 
; 588  : } /* end function cckd_open */

  003ec	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003f4	48 33 cc	 xor	 rcx, rsp
  003f7	e8 00 00 00 00	 call	 __security_check_cookie
  003fc	48 81 c4 c8 01
	00 00		 add	 rsp, 456		; 000001c8H
  00403	c3		 ret	 0
cckd_open ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
cckd$ = 64
dev$ = 96
cckd_dasd_end PROC

; 498  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 499  : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 500  : 
; 501  :     if (dev->cckd64)

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	74 0f		 je	 SHORT $LN2@cckd_dasd_

; 502  :     {
; 503  :         cckd64_dasd_end( dev );

  0001e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd64_dasd_end

; 504  :         return;

  00028	e9 a2 01 00 00	 jmp	 $LN1@cckd_dasd_
$LN2@cckd_dasd_:

; 505  :     }
; 506  : 
; 507  :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 40	 mov	 QWORD PTR cckd$[rsp], rax

; 508  : 
; 509  :     /* Update length if previous image was updated */
; 510  :     if (dev->bufupd && dev->bufcur >= 0 && dev->cache >= 0)

  0003e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00043	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  0004a	74 5b		 je	 SHORT $LN3@cckd_dasd_
  0004c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00051	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [rax+448], 0
  00058	7c 4d		 jl	 SHORT $LN3@cckd_dasd_
  0005a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0005f	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  00066	7c 3f		 jl	 SHORT $LN3@cckd_dasd_

; 511  :     {
; 512  :         dev->buflen = cckd_trklen (dev, dev->buf);

  00068	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0006d	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00074	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00079	e8 00 00 00 00	 call	 cckd_trklen
  0007e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00083	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 513  :         cache_setval (CACHE_DEVBUF, dev->cache, dev->buflen);

  00089	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0008e	44 8b 80 dc 01
	00 00		 mov	 r8d, DWORD PTR [rax+476]
  00095	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0009a	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  000a0	33 c9		 xor	 ecx, ecx
  000a2	e8 00 00 00 00	 call	 cache_setval
$LN3@cckd_dasd_:

; 514  :     }
; 515  : 
; 516  :     dev->bufupd = 0;

  000a7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000ac	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 517  : 
; 518  :     CCKD_TRACE( "end i/o bufcur %d cache[%d] waiters %d",

  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  000bb	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000be	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000c2	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000c7	8b 80 f8 01 00
	00		 mov	 eax, DWORD PTR [rax+504]
  000cd	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000d1	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000d6	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  000dc	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000e0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169711
  000e7	4c 8b 44 24 60	 mov	 r8, QWORD PTR dev$[rsp]
  000ec	ba 07 02 00 00	 mov	 edx, 519		; 00000207H
  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169712
  000f8	e8 00 00 00 00	 call	 cckd_trace

; 519  :                 dev->bufcur, dev->cache, cckd->cckdwaiters);
; 520  : 
; 521  :     obtain_lock (&cckd->cckdiolock);

  000fd	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00102	48 83 c0 18	 add	 rax, 24
  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169713
  0010d	48 8b c8	 mov	 rcx, rax
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 522  : 
; 523  :     cckd->cckdioact = 0;

  00116	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  0011b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0011e	83 e0 fb	 and	 eax, -5			; fffffffbH
  00121	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00126	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 524  : 
; 525  :     /* Make the current entry inactive */
; 526  :     if (dev->cache >= 0)

  00129	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0012e	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  00135	7c 29		 jl	 SHORT $LN4@cckd_dasd_

; 527  :     {
; 528  :         cache_lock (CACHE_DEVBUF);

  00137	33 c9		 xor	 ecx, ecx
  00139	e8 00 00 00 00	 call	 cache_lock

; 529  :         cache_setflag (CACHE_DEVBUF, dev->cache, ~CCKD_CACHE_ACTIVE, 0);

  0013e	45 33 c9	 xor	 r9d, r9d
  00141	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  00147	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0014c	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00152	33 c9		 xor	 ecx, ecx
  00154	e8 00 00 00 00	 call	 cache_setflag

; 530  :         cache_unlock (CACHE_DEVBUF);

  00159	33 c9		 xor	 ecx, ecx
  0015b	e8 00 00 00 00	 call	 cache_unlock
$LN4@cckd_dasd_:

; 531  :     }
; 532  : 
; 533  :     /* Cause writers to start after first update */
; 534  :     if (cckd->updated && (cckdblk.wrs == 0 || cckd->cckdwaiters != 0))

  00160	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00165	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00168	c1 e8 04	 shr	 eax, 4
  0016b	83 e0 01	 and	 eax, 1
  0016e	85 c0		 test	 eax, eax
  00170	74 20		 je	 SHORT $LN5@cckd_dasd_
  00172	83 3d 68 00 00
	00 00		 cmp	 DWORD PTR cckdblk+104, 0
  00179	74 0b		 je	 SHORT $LN7@cckd_dasd_
  0017b	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00180	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00184	74 0c		 je	 SHORT $LN5@cckd_dasd_
$LN7@cckd_dasd_:

; 535  :         cckd_flush_cache (dev);

  00186	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0018b	e8 00 00 00 00	 call	 cckd_flush_cache
  00190	eb 24		 jmp	 SHORT $LN6@cckd_dasd_
$LN5@cckd_dasd_:

; 536  :     else if (cckd->cckdwaiters)

  00192	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00197	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0019b	74 19		 je	 SHORT $LN8@cckd_dasd_

; 537  :         broadcast_condition (&cckd->cckdiocond);

  0019d	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  001a2	48 83 c0 20	 add	 rax, 32			; 00000020H
  001a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169719
  001ad	48 8b c8	 mov	 rcx, rax
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN8@cckd_dasd_:
$LN6@cckd_dasd_:

; 538  : 
; 539  :     release_lock (&cckd->cckdiolock);

  001b6	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  001bb	48 83 c0 18	 add	 rax, 24
  001bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169720
  001c6	48 8b c8	 mov	 rcx, rax
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@cckd_dasd_:

; 540  : 
; 541  : } /* end function cckd_dasd_end */

  001cf	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d3	c3		 ret	 0
cckd_dasd_end ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
devnum$ = 64
tv86 = 68
trk$ = 72
cckd$ = 80
dev$ = 112
cckd_dasd_start PROC

; 427  : {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 428  : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 429  : U16             devnum = 0;             /* Last active device number */

  00009	33 c0		 xor	 eax, eax
  0000b	66 89 44 24 40	 mov	 WORD PTR devnum$[rsp], ax

; 430  : int             trk = 0;                /* Last active track         */

  00010	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR trk$[rsp], 0

; 431  : 
; 432  :     if (dev->cckd64)

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00024	24 01		 and	 al, 1
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	74 0f		 je	 SHORT $LN7@cckd_dasd_

; 433  :     {
; 434  :         cckd64_dasd_start( dev );

  0002d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00032	e8 00 00 00 00	 call	 cckd64_dasd_start

; 435  :         return;

  00037	e9 0f 03 00 00	 jmp	 $LN1@cckd_dasd_
$LN7@cckd_dasd_:

; 436  :     }
; 437  : 
; 438  :     cckd = dev->cckd_ext;

  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00041	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00048	48 89 44 24 50	 mov	 QWORD PTR cckd$[rsp], rax

; 439  : 
; 440  :     CCKD_TRACE( "start i/o file[%d] bufcur %d cache[%d]",

  0004d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00052	8b 80 f8 01 00
	00		 mov	 eax, DWORD PTR [rax+504]
  00058	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0005c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00061	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  00067	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0006b	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00070	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00073	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00077	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169690
  0007e	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00083	ba b9 01 00 00	 mov	 edx, 441		; 000001b9H
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169691
  0008f	e8 00 00 00 00	 call	 cckd_trace

; 441  :                 cckd->sfn, dev->bufcur, dev->cache);
; 442  : 
; 443  :     /* Reset buffer offsets */
; 444  :     dev->bufoff = 0;

  00094	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00099	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 445  :     dev->bufoffhi = cckd->ckddasd ? dev->ckdtrksz : CFBA_BLKGRP_SIZE;

  000a3	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  000a8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000ab	83 e0 01	 and	 eax, 1
  000ae	85 c0		 test	 eax, eax
  000b0	74 11		 je	 SHORT $LN15@cckd_dasd_
  000b2	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000b7	8b 80 c4 12 00
	00		 mov	 eax, DWORD PTR [rax+4804]
  000bd	89 44 24 44	 mov	 DWORD PTR tv86[rsp], eax
  000c1	eb 08		 jmp	 SHORT $LN16@cckd_dasd_
$LN15@cckd_dasd_:
  000c3	c7 44 24 44 00
	f0 00 00	 mov	 DWORD PTR tv86[rsp], 61440 ; 0000f000H
$LN16@cckd_dasd_:
  000cb	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000d0	8b 4c 24 44	 mov	 ecx, DWORD PTR tv86[rsp]
  000d4	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 446  : 
; 447  :     /* Check for merge */
; 448  :     obtain_lock(&cckd->cckdiolock);

  000da	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  000df	48 83 c0 18	 add	 rax, 24
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169692
  000ea	48 8b c8	 mov	 rcx, rax
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 449  :     if (cckd->merging)

  000f3	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  000f8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000fb	c1 e8 05	 shr	 eax, 5
  000fe	83 e0 01	 and	 eax, 1
  00101	85 c0		 test	 eax, eax
  00103	0f 84 a1 00 00
	00		 je	 $LN8@cckd_dasd_

; 450  :     {
; 451  :         CCKD_TRACE( "start i/o waiting for merge%s","");

  00109	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169694
  00110	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169695
  0011c	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00121	ba c3 01 00 00	 mov	 edx, 451		; 000001c3H
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169696
  0012d	e8 00 00 00 00	 call	 cckd_trace
$LN2@cckd_dasd_:

; 452  :         while (cckd->merging)

  00132	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00137	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0013a	c1 e8 05	 shr	 eax, 5
  0013d	83 e0 01	 and	 eax, 1
  00140	85 c0		 test	 eax, eax
  00142	74 48		 je	 SHORT $LN3@cckd_dasd_

; 453  :         {
; 454  :             cckd->cckdwaiters++;

  00144	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00149	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0014c	ff c0		 inc	 eax
  0014e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00153	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 455  :             wait_condition (&cckd->cckdiocond, &cckd->cckdiolock);

  00156	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0015b	48 83 c0 18	 add	 rax, 24
  0015f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00164	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00168	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169697
  0016f	48 8b d0	 mov	 rdx, rax
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 456  :             cckd->cckdwaiters--;

  00178	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0017d	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00180	ff c8		 dec	 eax
  00182	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00187	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 457  :         }

  0018a	eb a6		 jmp	 SHORT $LN2@cckd_dasd_
$LN3@cckd_dasd_:

; 458  :         dev->bufcur = dev->cache = -1;

  0018c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00191	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0019b	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001a0	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1
$LN8@cckd_dasd_:

; 459  :     }
; 460  :     cckd->cckdioact = 1;

  001aa	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  001af	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001b2	83 c8 04	 or	 eax, 4
  001b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ba	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 461  : 
; 462  :     cache_lock(CACHE_DEVBUF);

  001bd	33 c9		 xor	 ecx, ecx
  001bf	e8 00 00 00 00	 call	 cache_lock

; 463  : 
; 464  :     if (dev->cache >= 0)

  001c4	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001c9	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  001d0	7c 45		 jl	 SHORT $LN9@cckd_dasd_
$LN6@cckd_dasd_:

; 465  :         CCKD_CACHE_GETKEY(dev->cache, devnum, trk);

  001d2	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001d7	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  001dd	33 c9		 xor	 ecx, ecx
  001df	e8 00 00 00 00	 call	 cache_getkey
  001e4	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  001e8	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  001ee	66 89 44 24 40	 mov	 WORD PTR devnum$[rsp], ax
  001f3	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001f8	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  001fe	33 c9		 xor	 ecx, ecx
  00200	e8 00 00 00 00	 call	 cache_getkey
  00205	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0020a	48 23 c1	 and	 rax, rcx
  0020d	89 44 24 48	 mov	 DWORD PTR trk$[rsp], eax
  00211	33 c0		 xor	 eax, eax
  00213	85 c0		 test	 eax, eax
  00215	75 bb		 jne	 SHORT $LN6@cckd_dasd_
$LN9@cckd_dasd_:

; 466  : 
; 467  :     /* Check if previous active entry is still valid and not busy */
; 468  :     if (dev->cache >= 0 && dev->devnum == devnum && dev->bufcur == trk
; 469  :      && !(cache_getflag(CACHE_DEVBUF, dev->cache) & CCKD_CACHE_IOBUSY))

  00217	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0021c	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  00223	0f 8c e4 00 00
	00		 jl	 $LN10@cckd_dasd_
  00229	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0022e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00232	0f b7 4c 24 40	 movzx	 ecx, WORD PTR devnum$[rsp]
  00237	3b c1		 cmp	 eax, ecx
  00239	0f 85 ce 00 00
	00		 jne	 $LN10@cckd_dasd_
  0023f	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00244	8b 4c 24 48	 mov	 ecx, DWORD PTR trk$[rsp]
  00248	39 88 c0 01 00
	00		 cmp	 DWORD PTR [rax+448], ecx
  0024e	0f 85 b9 00 00
	00		 jne	 $LN10@cckd_dasd_
  00254	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00259	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0025f	33 c9		 xor	 ecx, ecx
  00261	e8 00 00 00 00	 call	 cache_getflag
  00266	25 00 00 00 60	 and	 eax, 1610612736		; 60000000H
  0026b	85 c0		 test	 eax, eax
  0026d	0f 85 9a 00 00
	00		 jne	 $LN10@cckd_dasd_

; 470  :     {
; 471  :         /* Make the entry active again */
; 472  :         cache_setflag (CACHE_DEVBUF, dev->cache, ~0, CCKD_CACHE_ACTIVE);

  00273	41 b9 00 00 00
	80		 mov	 r9d, -2147483648	; 80000000H
  00279	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  0027f	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00284	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0028a	33 c9		 xor	 ecx, ecx
  0028c	e8 00 00 00 00	 call	 cache_setflag

; 473  : 
; 474  :         /* If the entry is pending write then change it to `updated' */
; 475  :         if (cache_getflag(CACHE_DEVBUF, dev->cache) & CCKD_CACHE_WRITE)

  00291	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00296	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0029c	33 c9		 xor	 ecx, ecx
  0029e	e8 00 00 00 00	 call	 cache_getflag
  002a3	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  002a8	85 c0		 test	 eax, eax
  002aa	74 5f		 je	 SHORT $LN12@cckd_dasd_

; 476  :         {
; 477  :             cache_setflag (CACHE_DEVBUF, dev->cache, ~CCKD_CACHE_WRITE, CCKD_CACHE_UPDATED);

  002ac	41 b9 00 00 00
	08		 mov	 r9d, 134217728		; 08000000H
  002b2	41 b8 ff ff ff
	fb		 mov	 r8d, -67108865		; fbffffffH
  002b8	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002bd	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  002c3	33 c9		 xor	 ecx, ecx
  002c5	e8 00 00 00 00	 call	 cache_setflag

; 478  :             cckd->wrpending--;

  002ca	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  002cf	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  002d2	ff c8		 dec	 eax
  002d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  002d9	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 479  :             if (cckd->cckdwaiters && !cckd->wrpending)

  002dc	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  002e1	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  002e5	74 24		 je	 SHORT $LN13@cckd_dasd_
  002e7	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  002ec	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  002f0	75 19		 jne	 SHORT $LN13@cckd_dasd_

; 480  :                 broadcast_condition (&cckd->cckdiocond);

  002f2	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  002f7	48 83 c0 20	 add	 rax, 32			; 00000020H
  002fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169703
  00302	48 8b c8	 mov	 rcx, rax
  00305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN13@cckd_dasd_:
$LN12@cckd_dasd_:

; 481  :         }
; 482  :     }

  0030b	eb 1e		 jmp	 SHORT $LN11@cckd_dasd_
$LN10@cckd_dasd_:

; 483  :     else
; 484  :         dev->bufcur = dev->cache = -1;

  0030d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00312	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0031c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00321	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1
$LN11@cckd_dasd_:

; 485  : 
; 486  :     cache_unlock (CACHE_DEVBUF);

  0032b	33 c9		 xor	 ecx, ecx
  0032d	e8 00 00 00 00	 call	 cache_unlock

; 487  : 
; 488  :     release_lock (&cckd->cckdiolock);

  00332	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00337	48 83 c0 18	 add	 rax, 24
  0033b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169704
  00342	48 8b c8	 mov	 rcx, rax
  00345	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@cckd_dasd_:

; 489  : 
; 490  :     return;
; 491  : 
; 492  : } /* end function cckd_dasd_start */

  0034b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0034f	c3		 ret	 0
cckd_dasd_start ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
cckd_dasd_term_if_appropriate PROC

; 148  : {

$LN10:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 149  :     /* Check if it's time to terminate yet */
; 150  :     obtain_lock( &cckdblk.devlock );

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169547
  0000b	48 8d 0d 30 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+560
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 151  :     {
; 152  :         if (cckdblk.dev1st)

  00018	48 83 3d 08 00
	00 00 00	 cmp	 QWORD PTR cckdblk+8, 0
  00020	74 19		 je	 SHORT $LN8@cckd_dasd_

; 153  :         {
; 154  :             /* Not time yet; return without doing anything */
; 155  :             release_lock( &cckdblk.devlock );

  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169549
  00029	48 8d 0d 30 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+560
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 156  :             return;

  00036	e9 58 01 00 00	 jmp	 $LN1@cckd_dasd_
$LN8@cckd_dasd_:

; 157  :         }
; 158  :         /* cckdblk.dev1st == NULL: time to globally terminate */
; 159  :     }
; 160  :     release_lock( &cckdblk.devlock );

  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169550
  00042	48 8d 0d 30 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+560
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 161  : 
; 162  :     /* Terminate all readahead threads... */
; 163  :     obtain_lock( &cckdblk.ralock );

  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169551
  00056	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 164  :     {
; 165  :         cckdblk.ramax = 0;      /* signal   all threads to terminate */

  00063	c7 05 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+144, 0
$LN2@cckd_dasd_:

; 166  :         while (cckdblk.ras)     /* wait for all threads to terminate */

  0006d	83 3d 88 00 00
	00 00		 cmp	 DWORD PTR cckdblk+136, 0
  00074	74 31		 je	 SHORT $LN3@cckd_dasd_

; 167  :         {
; 168  :             broadcast_condition( &cckdblk.racond );

  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169552
  0007d	48 8d 0d 80 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+128
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition

; 169  :             wait_condition( &cckdblk.termcond, &cckdblk.ralock );

  0008a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169553
  00091	48 8d 15 78 00
	00 00		 lea	 rdx, OFFSET FLAT:cckdblk+120
  00098	48 8d 0d 60 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+608
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 170  :         }

  000a5	eb c6		 jmp	 SHORT $LN2@cckd_dasd_
$LN3@cckd_dasd_:

; 171  :     }
; 172  :     release_lock( &cckdblk.ralock );

  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169554
  000ae	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 173  : 
; 174  :     /* Terminate all garbage collection threads... */
; 175  :     obtain_lock( &cckdblk.gclock );

  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169555
  000c2	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 176  :     {
; 177  :         cckdblk.gcmax = 0;      /* signal   all threads to terminate */

  000cf	c7 05 40 00 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+64, 0
$LN4@cckd_dasd_:

; 178  :         while (cckdblk.gcs)     /* wait for all threads to terminate */

  000d9	83 3d 38 00 00
	00 00		 cmp	 DWORD PTR cckdblk+56, 0
  000e0	74 31		 je	 SHORT $LN5@cckd_dasd_

; 179  :         {
; 180  :             broadcast_condition( &cckdblk.gccond );

  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169556
  000e9	48 8d 0d 30 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+48
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition

; 181  :             wait_condition( &cckdblk.termcond, &cckdblk.gclock );

  000f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169557
  000fd	48 8d 15 28 00
	00 00		 lea	 rdx, OFFSET FLAT:cckdblk+40
  00104	48 8d 0d 60 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+608
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 182  :         }

  00111	eb c6		 jmp	 SHORT $LN4@cckd_dasd_
$LN5@cckd_dasd_:

; 183  :     }
; 184  :     release_lock( &cckdblk.gclock );

  00113	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169558
  0011a	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 185  : 
; 186  :     /* Terminate all writer threads... */
; 187  :     obtain_lock( &cckdblk.wrlock );

  00127	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169559
  0012e	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 188  :     {
; 189  :         cckdblk.wrmax = 0;      /* signal   all threads to terminate */

  0013b	c7 05 70 00 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+112, 0
$LN6@cckd_dasd_:

; 190  :         while (cckdblk.wrs)     /* wait for all threads to terminate */

  00145	83 3d 68 00 00
	00 00		 cmp	 DWORD PTR cckdblk+104, 0
  0014c	74 31		 je	 SHORT $LN7@cckd_dasd_

; 191  :         {
; 192  :             broadcast_condition( &cckdblk.wrcond );

  0014e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169560
  00155	48 8d 0d 58 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+88
  0015c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition

; 193  :             wait_condition( &cckdblk.termcond, &cckdblk.wrlock );

  00162	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169561
  00169	48 8d 15 50 00
	00 00		 lea	 rdx, OFFSET FLAT:cckdblk+80
  00170	48 8d 0d 60 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+608
  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 194  :         }

  0017d	eb c6		 jmp	 SHORT $LN6@cckd_dasd_
$LN7@cckd_dasd_:

; 195  :     }
; 196  :     release_lock( &cckdblk.wrlock );

  0017f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169562
  00186	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@cckd_dasd_:

; 197  : 
; 198  : } /* end function cckd_dasd_term */

  00193	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00197	c3		 ret	 0
cckd_dasd_term_if_appropriate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
i$ = 32
j$ = 36
argc$ = 64
argv$ = 72
cckd_dasd_init PROC

; 53   : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
$LN4@cckd_dasd_:

; 54   :     int  i, j;                          /* Loop indexes              */
; 55   : 
; 56   :     UNREFERENCED(argc);

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@cckd_dasd_
$LN7@cckd_dasd_:

; 57   :     UNREFERENCED(argv);

  00014	33 c0		 xor	 eax, eax
  00016	85 c0		 test	 eax, eax
  00018	75 fa		 jne	 SHORT $LN7@cckd_dasd_

; 58   : 
; 59   :     if (memcmp( &cckdblk.id, CCKDBLK_ID, sizeof( cckdblk.id )) == 0)

  0001a	41 b8 08 00 00
	00		 mov	 r8d, 8
  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169523
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk
  0002e	e8 00 00 00 00	 call	 memcmp
  00033	85 c0		 test	 eax, eax
  00035	75 07		 jne	 SHORT $LN17@cckd_dasd_

; 60   :         return 0;

  00037	33 c0		 xor	 eax, eax
  00039	e9 8a 03 00 00	 jmp	 $LN1@cckd_dasd_
$LN17@cckd_dasd_:

; 61   : 
; 62   :     /* Clear the cckdblk */
; 63   : 
; 64   :     memset( &cckdblk, 0, sizeof( cckdblk ));

  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cckdblk
  00045	48 8b f8	 mov	 rdi, rax
  00048	33 c0		 xor	 eax, eax
  0004a	b9 20 03 00 00	 mov	 ecx, 800		; 00000320H
  0004f	f3 aa		 rep stosb

; 65   : 
; 66   :     /* Initialize locks and conditions */
; 67   : 
; 68   :     memcpy( &cckdblk.id, CCKDBLK_ID, sizeof( cckdblk.id ));

  00051	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR $SG169524
  00058	48 89 05 00 00
	00 00		 mov	 QWORD PTR cckdblk, rax

; 69   : 
; 70   :     initialize_lock( &cckdblk.gclock  );

  0005f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169525
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169526
  0006d	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 71   :     initialize_lock( &cckdblk.ralock  );

  0007a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169527
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169528
  00088	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 72   :     initialize_lock( &cckdblk.wrlock  );

  00095	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169529
  0009c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169530
  000a3	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 73   :     initialize_lock( &cckdblk.devlock );

  000b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169531
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169532
  000be	48 8d 0d 30 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+560
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 74   :     initialize_lock( &cckdblk.trclock );

  000cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169533
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169534
  000d9	48 8d 0d f0 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+752
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 75   : 
; 76   :     initialize_condition( &cckdblk.gccond   );

  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169535
  000ed	48 8d 0d 30 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+48
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 77   :     initialize_condition( &cckdblk.racond   );

  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169536
  00101	48 8d 0d 80 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+128
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 78   :     initialize_condition( &cckdblk.wrcond   );

  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169537
  00115	48 8d 0d 58 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+88
  0011c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 79   :     initialize_condition( &cckdblk.devcond  );

  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169538
  00129	48 8d 0d 38 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+568
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 80   :     initialize_condition( &cckdblk.termcond );

  00136	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169539
  0013d	48 8d 0d 60 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+608
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 81   : 
; 82   :     /* Initialize trace table */
; 83   : 
; 84   :     cckdblk.itrace     = calloc( CCKD_DEF_NUM_TRACE, sizeof( CCKD_ITRACE ));

  0014a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0014f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0015a	48 89 05 f8 02
	00 00		 mov	 QWORD PTR cckdblk+760, rax

; 85   :     cckdblk.itracep    = cckdblk.itrace;

  00161	48 8b 05 f8 02
	00 00		 mov	 rax, QWORD PTR cckdblk+760
  00168	48 89 05 00 03
	00 00		 mov	 QWORD PTR cckdblk+768, rax

; 86   :     cckdblk.itracex    = cckdblk.itrace + CCKD_DEF_NUM_TRACE;

  0016f	48 8b 05 f8 02
	00 00		 mov	 rax, QWORD PTR cckdblk+760
  00176	48 05 00 40 00
	00		 add	 rax, 16384		; 00004000H
  0017c	48 89 05 08 03
	00 00		 mov	 QWORD PTR cckdblk+776, rax

; 87   :     cckdblk.itracen    = CCKD_DEF_NUM_TRACE;

  00183	c7 05 10 03 00
	00 40 00 00 00	 mov	 DWORD PTR cckdblk+784, 64 ; 00000040H

; 88   :     cckdblk.itracec    = 0;

  0018d	c7 05 14 03 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+788, 0

; 89   : 
; 90   :     /* Initialize some other variables */
; 91   : 
; 92   :     cckdblk.ranbr      = CCKD_DEF_RA_SIZE;

  00197	c7 05 98 00 00
	00 04 00 00 00	 mov	 DWORD PTR cckdblk+152, 4

; 93   :     cckdblk.ramax      = CCKD_DEF_RA;

  001a1	c7 05 90 00 00
	00 02 00 00 00	 mov	 DWORD PTR cckdblk+144, 2

; 94   :     cckdblk.wrmax      = CCKD_DEF_WRITER;

  001ab	c7 05 70 00 00
	00 02 00 00 00	 mov	 DWORD PTR cckdblk+112, 2

; 95   :     cckdblk.gcmax      = CCKD_DEF_GCOL;

  001b5	c7 05 40 00 00
	00 01 00 00 00	 mov	 DWORD PTR cckdblk+64, 1

; 96   :     cckdblk.gcint      = CCKD_DEF_GCINT;

  001bf	c7 05 44 00 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+68, 0

; 97   :     cckdblk.gcparm     = CCKD_DEF_GCPARM;

  001c9	c7 05 48 00 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+72, 0

; 98   :     cckdblk.readaheads = CCKD_DEF_READAHEADS;

  001d3	c7 05 9c 00 00
	00 02 00 00 00	 mov	 DWORD PTR cckdblk+156, 2

; 99   :     cckdblk.freepend   = CCKD_DEF_FREEPEND;

  001dd	c7 05 48 02 00
	00 ff ff ff ff	 mov	 DWORD PTR cckdblk+584, -1

; 100  : 
; 101  : #if defined( HAVE_ZLIB )
; 102  :     cckdblk.comps     |= CCKD_COMPRESS_ZLIB;
; 103  : #endif
; 104  : #if defined( CCKD_BZIP2 )
; 105  :     cckdblk.comps     |= CCKD_COMPRESS_BZIP2;
; 106  : #endif
; 107  :     cckdblk.comp       = 0xff;

  001e7	c6 05 1d 00 00
	00 ff		 mov	 BYTE PTR cckdblk+29, 255 ; 000000ffH

; 108  :     cckdblk.compparm   = -1;

  001ee	c7 05 20 00 00
	00 ff ff ff ff	 mov	 DWORD PTR cckdblk+32, -1

; 109  : 
; 110  :     /* Set the writer thread's priority just BELOW the CPU threads'
; 111  :        in order to minimize any potential impact from compression.
; 112  :     */
; 113  :     cckdblk.wrprio = sysblk.cpuprio - 1;

  001f8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ff	8b 80 6c 13 00
	00		 mov	 eax, DWORD PTR [rax+4972]
  00205	ff c8		 dec	 eax
  00207	89 05 74 00 00
	00		 mov	 DWORD PTR cckdblk+116, eax

; 114  : 
; 115  :     /* Initialize the readahead queue */
; 116  : 
; 117  :     cckdblk.ra1st  = -1;

  0020d	c7 05 20 02 00
	00 ff ff ff ff	 mov	 DWORD PTR cckdblk+544, -1

; 118  :     cckdblk.ralast = -1;

  00217	c7 05 24 02 00
	00 ff ff ff ff	 mov	 DWORD PTR cckdblk+548, -1

; 119  :     cckdblk.rafree =  0;

  00221	c7 05 28 02 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+552, 0

; 120  : 
; 121  :     for (i=0; i < cckdblk.ranbr; i++)

  0022b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00233	eb 0a		 jmp	 SHORT $LN10@cckd_dasd_
$LN8@cckd_dasd_:
  00235	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00239	ff c0		 inc	 eax
  0023b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@cckd_dasd_:
  0023f	8b 05 98 00 00
	00		 mov	 eax, DWORD PTR cckdblk+152
  00245	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00249	7d 1c		 jge	 SHORT $LN9@cckd_dasd_

; 122  :         cckdblk.ra[i].ra_idxnxt = i + 1;

  0024b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0024f	ff c0		 inc	 eax
  00251	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00256	48 6b c9 18	 imul	 rcx, rcx, 24
  0025a	48 8d 15 a0 00
	00 00		 lea	 rdx, OFFSET FLAT:cckdblk+160
  00261	89 44 0a 10	 mov	 DWORD PTR [rdx+rcx+16], eax
  00265	eb ce		 jmp	 SHORT $LN8@cckd_dasd_
$LN9@cckd_dasd_:

; 123  : 
; 124  :     cckdblk.ra[cckdblk.ranbr - 1].ra_idxnxt = -1;

  00267	8b 05 98 00 00
	00		 mov	 eax, DWORD PTR cckdblk+152
  0026d	ff c8		 dec	 eax
  0026f	48 98		 cdqe
  00271	48 6b c0 18	 imul	 rax, rax, 24
  00275	48 8d 0d a0 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+160
  0027c	c7 44 01 10 ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+16], -1

; 125  : 
; 126  :     /* Clear the empty L2 tables */
; 127  : 
; 128  :     for (i=0; i <= CKD_NULLTRK_FMTMAX; i++)

  00284	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0028c	eb 0a		 jmp	 SHORT $LN13@cckd_dasd_
$LN11@cckd_dasd_:
  0028e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00292	ff c0		 inc	 eax
  00294	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@cckd_dasd_:
  00298	83 7c 24 20 02	 cmp	 DWORD PTR i$[rsp], 2
  0029d	0f 8f 23 01 00
	00		 jg	 $LN12@cckd_dasd_

; 129  :         for (j=0; j < 256; j++)

  002a3	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  002ab	eb 0a		 jmp	 SHORT $LN16@cckd_dasd_
$LN14@cckd_dasd_:
  002ad	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  002b1	ff c0		 inc	 eax
  002b3	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN16@cckd_dasd_:
  002b7	81 7c 24 24 00
	01 00 00	 cmp	 DWORD PTR j$[rsp], 256	; 00000100H
  002bf	0f 8d fc 00 00
	00		 jge	 $LN15@cckd_dasd_

; 130  :         {
; 131  :             empty_l2   [i][j] . L2_trkoff = 0;

  002c5	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002ca	48 69 c0 00 08
	00 00		 imul	 rax, rax, 2048		; 00000800H
  002d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:empty_l2
  002d8	48 03 c8	 add	 rcx, rax
  002db	48 8b c1	 mov	 rax, rcx
  002de	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  002e3	c7 04 c8 00 00
	00 00		 mov	 DWORD PTR [rax+rcx*8], 0

; 132  :             empty_l2   [i][j] . L2_len    = i;

  002ea	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002ef	48 69 c0 00 08
	00 00		 imul	 rax, rax, 2048		; 00000800H
  002f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:empty_l2
  002fd	48 03 c8	 add	 rcx, rax
  00300	48 8b c1	 mov	 rax, rcx
  00303	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00308	0f b7 54 24 20	 movzx	 edx, WORD PTR i$[rsp]
  0030d	66 89 54 c8 04	 mov	 WORD PTR [rax+rcx*8+4], dx

; 133  :             empty_l2   [i][j] . L2_size   = i;

  00312	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00317	48 69 c0 00 08
	00 00		 imul	 rax, rax, 2048		; 00000800H
  0031e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:empty_l2
  00325	48 03 c8	 add	 rcx, rax
  00328	48 8b c1	 mov	 rax, rcx
  0032b	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00330	0f b7 54 24 20	 movzx	 edx, WORD PTR i$[rsp]
  00335	66 89 54 c8 06	 mov	 WORD PTR [rax+rcx*8+6], dx

; 134  : 
; 135  :             empty64_l2 [i][j] . L2_trkoff = 0;

  0033a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0033f	48 69 c0 00 10
	00 00		 imul	 rax, rax, 4096		; 00001000H
  00346	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:empty64_l2
  0034d	48 03 c8	 add	 rcx, rax
  00350	48 8b c1	 mov	 rax, rcx
  00353	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00358	48 6b c9 10	 imul	 rcx, rcx, 16
  0035c	48 c7 04 08 00
	00 00 00	 mov	 QWORD PTR [rax+rcx], 0

; 136  :             empty64_l2 [i][j] . L2_len    = i;

  00364	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00369	48 69 c0 00 10
	00 00		 imul	 rax, rax, 4096		; 00001000H
  00370	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:empty64_l2
  00377	48 03 c8	 add	 rcx, rax
  0037a	48 8b c1	 mov	 rax, rcx
  0037d	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00382	48 6b c9 10	 imul	 rcx, rcx, 16
  00386	0f b7 54 24 20	 movzx	 edx, WORD PTR i$[rsp]
  0038b	66 89 54 08 08	 mov	 WORD PTR [rax+rcx+8], dx

; 137  :             empty64_l2 [i][j] . L2_size   = i;

  00390	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00395	48 69 c0 00 10
	00 00		 imul	 rax, rax, 4096		; 00001000H
  0039c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:empty64_l2
  003a3	48 03 c8	 add	 rcx, rax
  003a6	48 8b c1	 mov	 rax, rcx
  003a9	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  003ae	48 6b c9 10	 imul	 rcx, rcx, 16
  003b2	0f b7 54 24 20	 movzx	 edx, WORD PTR i$[rsp]
  003b7	66 89 54 08 0a	 mov	 WORD PTR [rax+rcx+10], dx

; 138  :         }

  003bc	e9 ec fe ff ff	 jmp	 $LN14@cckd_dasd_
$LN15@cckd_dasd_:
  003c1	e9 c8 fe ff ff	 jmp	 $LN11@cckd_dasd_
$LN12@cckd_dasd_:

; 139  : 
; 140  :     return 0;

  003c6	33 c0		 xor	 eax, eax
$LN1@cckd_dasd_:

; 141  : 
; 142  : } /* end function cckd_dasd_init */

  003c8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  003cc	5f		 pop	 rdi
  003cd	c3		 ret	 0
cckd_dasd_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
rc$ = 32
cbuf$ = 40
cckd$ = 48
dev$ = 96
blkgrp$ = 104
off$ = 112
buf$ = 120
len$ = 128
unitstat$ = 136
cfba_write_block PROC

; 1096 : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1097 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 1098 : int             rc;                     /* Return code               */
; 1099 : BYTE           *cbuf;                   /* -> cache buffer           */
; 1100 : 
; 1101 :     cckd = dev->cckd_ext;

  00019	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00025	48 89 44 24 30	 mov	 QWORD PTR cckd$[rsp], rax

; 1102 : 
; 1103 :     if (dev->cache >= 0)

  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  00036	7c 1c		 jl	 SHORT $LN2@cfba_write

; 1104 :         cbuf = cache_getbuf (CACHE_DEVBUF, dev->cache, 0);

  00038	45 33 c0	 xor	 r8d, r8d
  0003b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00040	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00046	33 c9		 xor	 ecx, ecx
  00048	e8 00 00 00 00	 call	 cache_getbuf
  0004d	48 89 44 24 28	 mov	 QWORD PTR cbuf$[rsp], rax
  00052	eb 09		 jmp	 SHORT $LN3@cfba_write
$LN2@cfba_write:

; 1105 :     else
; 1106 :         cbuf = NULL;

  00054	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR cbuf$[rsp], 0
$LN3@cfba_write:

; 1107 : 
; 1108 :     /* Read the block group if it's not current or compressed.
; 1109 :        `dev->comps' is set to zero forcing the read routine to
; 1110 :        uncompress the image.                                   */
; 1111 :     if (blkgrp != dev->bufcur || (cbuf[0] & CCKD_COMPRESS_MASK) != 0)

  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00062	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  00068	39 44 24 68	 cmp	 DWORD PTR blkgrp$[rsp], eax
  0006c	75 19		 jne	 SHORT $LN5@cfba_write
  0006e	b8 01 00 00 00	 mov	 eax, 1
  00073	48 6b c0 00	 imul	 rax, rax, 0
  00077	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cbuf$[rsp]
  0007c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00080	83 e0 03	 and	 eax, 3
  00083	85 c0		 test	 eax, eax
  00085	74 62		 je	 SHORT $LN4@cfba_write
$LN5@cfba_write:

; 1112 :     {
; 1113 :         dev->comps = 0;

  00087	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0008c	c7 80 08 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+520], 0

; 1114 :         rc = (dev->hnd->read) (dev, blkgrp, unitstat);

  00096	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0009b	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  000a2	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  000aa	8b 54 24 68	 mov	 edx, DWORD PTR blkgrp$[rsp]
  000ae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000b3	ff 50 50	 call	 QWORD PTR [rax+80]
  000b6	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1115 :         if (rc < 0)

  000ba	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bf	7d 28		 jge	 SHORT $LN6@cfba_write

; 1116 :         {
; 1117 :             dev->bufcur = dev->cache = -1;

  000c1	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000c6	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  000d0	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000d5	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 1118 :             return -1;

  000df	b8 ff ff ff ff	 mov	 eax, -1
  000e4	e9 91 00 00 00	 jmp	 $LN1@cfba_write
$LN6@cfba_write:
$LN4@cfba_write:

; 1119 :         }
; 1120 :     }
; 1121 : 
; 1122 :     /* Copy the data into the buffer */
; 1123 :     if (buf) memcpy (dev->buf + off, buf, len);

  000e9	48 83 7c 24 78
	00		 cmp	 QWORD PTR buf$[rsp], 0
  000ef	74 26		 je	 SHORT $LN7@cfba_write
  000f1	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000f9	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR off$[rsp]
  000fe	48 8b 54 24 60	 mov	 rdx, QWORD PTR dev$[rsp]
  00103	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  0010a	48 8b f9	 mov	 rdi, rcx
  0010d	48 8b 74 24 78	 mov	 rsi, QWORD PTR buf$[rsp]
  00112	48 8b c8	 mov	 rcx, rax
  00115	f3 a4		 rep movsb
$LN7@cfba_write:

; 1124 : 
; 1125 :     /* Update the cache entry */
; 1126 :     cache_setflag (CACHE_DEVBUF, dev->cache, ~0, CCKD_CACHE_UPDATED|CCKD_CACHE_USED);

  00117	41 b9 00 00 80
	08		 mov	 r9d, 142606336		; 08800000H
  0011d	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  00123	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00128	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0012e	33 c9		 xor	 ecx, ecx
  00130	e8 00 00 00 00	 call	 cache_setflag

; 1127 :     cckd->updated = 1;

  00135	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  0013a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0013d	83 c8 10	 or	 eax, 16
  00140	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00145	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 1128 : 
; 1129 :     /* Notify the shared server of the update */
; 1130 :     if (!dev->bufupd)

  00148	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0014d	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  00154	75 1d		 jne	 SHORT $LN8@cfba_write

; 1131 :     {
; 1132 :         dev->bufupd = 1;

  00156	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0015b	c7 80 f4 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+500], 1

; 1133 :         shared_update_notify (dev, blkgrp);

  00165	8b 54 24 68	 mov	 edx, DWORD PTR blkgrp$[rsp]
  00169	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0016e	e8 00 00 00 00	 call	 shared_update_notify
$LN8@cfba_write:

; 1134 :     }
; 1135 : 
; 1136 :     return len;

  00173	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
$LN1@cfba_write:

; 1137 : 
; 1138 : } /* end function cfba_write_block */

  0017a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017e	5f		 pop	 rdi
  0017f	5e		 pop	 rsi
  00180	c3		 ret	 0
cfba_write_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
maxlen$ = 48
cache$ = 52
rc$ = 56
len$ = 60
cbuf$ = 64
newbuf$ = 72
cckd$ = 80
dev$ = 112
blkgrp$ = 120
unitstat$ = 128
cfba_read_block PROC

; 1011 : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1012 : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 1013 : int             rc;                     /* Return code               */
; 1014 : int             cache;                  /* New active cache entry    */
; 1015 : BYTE           *cbuf;                   /* -> cache buffer           */
; 1016 : BYTE           *newbuf;                 /* Uncompressed buffer       */
; 1017 : int             len;                    /* Compressed length         */
; 1018 : int             maxlen;                 /* Size for cache entry      */
; 1019 : 
; 1020 :     cckd = dev->cckd_ext;

  00012	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00017	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0001e	48 89 44 24 50	 mov	 QWORD PTR cckd$[rsp], rax

; 1021 : 
; 1022 :     if (dev->cache >= 0)

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00028	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  0002f	7c 1c		 jl	 SHORT $LN2@cfba_read_

; 1023 :         cbuf = cache_getbuf (CACHE_DEVBUF, dev->cache, 0);

  00031	45 33 c0	 xor	 r8d, r8d
  00034	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00039	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0003f	33 c9		 xor	 ecx, ecx
  00041	e8 00 00 00 00	 call	 cache_getbuf
  00046	48 89 44 24 40	 mov	 QWORD PTR cbuf$[rsp], rax
  0004b	eb 09		 jmp	 SHORT $LN3@cfba_read_
$LN2@cfba_read_:

; 1024 :     else
; 1025 :         cbuf = NULL;

  0004d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR cbuf$[rsp], 0
$LN3@cfba_read_:

; 1026 :     maxlen = CFBA_BLKGRP_SIZE + CKD_TRKHDR_SIZE;

  00056	c7 44 24 30 05
	f0 00 00	 mov	 DWORD PTR maxlen$[rsp], 61445 ; 0000f005H

; 1027 : 
; 1028 :     /* Return if reading the same track image */
; 1029 :     if (blkgrp == dev->bufcur && dev->cache >= 0)

  0005e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00063	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  00069	39 44 24 78	 cmp	 DWORD PTR blkgrp$[rsp], eax
  0006d	0f 85 d6 01 00
	00		 jne	 $LN4@cfba_read_
  00073	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00078	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  0007f	0f 8c c4 01 00
	00		 jl	 $LN4@cfba_read_

; 1030 :     {
; 1031 :         /* Block group image may be compressed */
; 1032 :         if ((cbuf[0] & CCKD_COMPRESS_MASK) != 0
; 1033 :          && (cbuf[0] & dev->comps) == 0)

  00085	b8 01 00 00 00	 mov	 eax, 1
  0008a	48 6b c0 00	 imul	 rax, rax, 0
  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cbuf$[rsp]
  00093	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00097	83 e0 03	 and	 eax, 3
  0009a	85 c0		 test	 eax, eax
  0009c	0f 84 80 01 00
	00		 je	 $LN5@cfba_read_
  000a2	b8 01 00 00 00	 mov	 eax, 1
  000a7	48 6b c0 00	 imul	 rax, rax, 0
  000ab	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cbuf$[rsp]
  000b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000b9	23 81 08 02 00
	00		 and	 eax, DWORD PTR [rcx+520]
  000bf	85 c0		 test	 eax, eax
  000c1	0f 85 5b 01 00
	00		 jne	 $LN5@cfba_read_

; 1034 :         {
; 1035 :             len = cache_getval(CACHE_DEVBUF, dev->cache) + CKD_TRKHDR_SIZE;

  000c7	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000cc	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  000d2	33 c9		 xor	 ecx, ecx
  000d4	e8 00 00 00 00	 call	 cache_getval
  000d9	48 98		 cdqe
  000db	48 83 c0 05	 add	 rax, 5
  000df	89 44 24 3c	 mov	 DWORD PTR len$[rsp], eax

; 1036 :             newbuf = cckd_uncompress (dev, cbuf, len, maxlen, blkgrp);

  000e3	8b 44 24 78	 mov	 eax, DWORD PTR blkgrp$[rsp]
  000e7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000eb	44 8b 4c 24 30	 mov	 r9d, DWORD PTR maxlen$[rsp]
  000f0	44 8b 44 24 3c	 mov	 r8d, DWORD PTR len$[rsp]
  000f5	48 8b 54 24 40	 mov	 rdx, QWORD PTR cbuf$[rsp]
  000fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000ff	e8 00 00 00 00	 call	 cckd_uncompress
  00104	48 89 44 24 48	 mov	 QWORD PTR newbuf$[rsp], rax

; 1037 :             if (newbuf == NULL) {

  00109	48 83 7c 24 48
	00		 cmp	 QWORD PTR newbuf$[rsp], 0
  0010f	75 49		 jne	 SHORT $LN6@cfba_read_

; 1038 :                 dev->sense[0] = SENSE_EC;

  00111	b8 01 00 00 00	 mov	 eax, 1
  00116	48 6b c0 00	 imul	 rax, rax, 0
  0011a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0011f	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 1039 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00127	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0012f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1040 :                 dev->bufcur = dev->cache = -1;

  00132	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00137	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00141	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00146	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 1041 :                 return -1;

  00150	b8 ff ff ff ff	 mov	 eax, -1
  00155	e9 a2 02 00 00	 jmp	 $LN1@cfba_read_
$LN6@cfba_read_:

; 1042 :             }
; 1043 :             cache_setbuf (CACHE_DEVBUF, dev->cache, newbuf, maxlen);

  0015a	44 8b 4c 24 30	 mov	 r9d, DWORD PTR maxlen$[rsp]
  0015f	4c 8b 44 24 48	 mov	 r8, QWORD PTR newbuf$[rsp]
  00164	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00169	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0016f	33 c9		 xor	 ecx, ecx
  00171	e8 00 00 00 00	 call	 cache_setbuf

; 1044 :             cbuf = newbuf;

  00176	48 8b 44 24 48	 mov	 rax, QWORD PTR newbuf$[rsp]
  0017b	48 89 44 24 40	 mov	 QWORD PTR cbuf$[rsp], rax

; 1045 :             dev->buf     = newbuf + CKD_TRKHDR_SIZE;

  00180	48 8b 44 24 48	 mov	 rax, QWORD PTR newbuf$[rsp]
  00185	48 83 c0 05	 add	 rax, 5
  00189	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0018e	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 1046 :             dev->buflen  = CFBA_BLKGRP_SIZE;

  00195	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0019a	c7 80 dc 01 00
	00 00 f0 00 00	 mov	 DWORD PTR [rax+476], 61440 ; 0000f000H

; 1047 :             cache_setval (CACHE_DEVBUF, dev->cache, dev->buflen);

  001a4	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001a9	44 8b 80 dc 01
	00 00		 mov	 r8d, DWORD PTR [rax+476]
  001b0	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001b5	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  001bb	33 c9		 xor	 ecx, ecx
  001bd	e8 00 00 00 00	 call	 cache_setval

; 1048 :             dev->bufsize = cache_getlen (CACHE_DEVBUF, dev->cache);

  001c2	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001c7	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  001cd	33 c9		 xor	 ecx, ecx
  001cf	e8 00 00 00 00	 call	 cache_getlen
  001d4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001d9	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 1049 :             dev->bufupd  = 0;

  001df	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001e4	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 1050 :             CCKD_TRACE( "read bkgrp  %d uncompressed len %d",

  001ee	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001f3	8b 80 dc 01 00
	00		 mov	 eax, DWORD PTR [rax+476]
  001f9	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001fd	8b 44 24 78	 mov	 eax, DWORD PTR blkgrp$[rsp]
  00201	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00205	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170043
  0020c	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00211	ba 1b 04 00 00	 mov	 edx, 1051		; 0000041bH
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170044
  0021d	e8 00 00 00 00	 call	 cckd_trace
$LN5@cfba_read_:

; 1051 :                         blkgrp, dev->buflen);
; 1052 :         }
; 1053 : 
; 1054 :         dev->comp = cbuf[0] & CCKD_COMPRESS_MASK;

  00222	b8 01 00 00 00	 mov	 eax, 1
  00227	48 6b c0 00	 imul	 rax, rax, 0
  0022b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cbuf$[rsp]
  00230	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00234	83 e0 03	 and	 eax, 3
  00237	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0023c	89 81 0c 02 00
	00		 mov	 DWORD PTR [rcx+524], eax

; 1055 : 
; 1056 :         return 0;

  00242	33 c0		 xor	 eax, eax
  00244	e9 b3 01 00 00	 jmp	 $LN1@cfba_read_
$LN4@cfba_read_:

; 1057 :     }
; 1058 : 
; 1059 :     CCKD_TRACE( "read blkgrp  %d (%s)", blkgrp, "asynchronous");

  00249	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170045
  00250	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00255	8b 44 24 78	 mov	 eax, DWORD PTR blkgrp$[rsp]
  00259	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0025d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170046
  00264	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00269	ba 23 04 00 00	 mov	 edx, 1059		; 00000423H
  0026e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170047
  00275	e8 00 00 00 00	 call	 cckd_trace

; 1060 : 
; 1061 :     /* Read the new blkgrp */
; 1062 :     dev->bufupd = 0;

  0027a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0027f	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 1063 :     cache = cckd_read_trk (dev, blkgrp, 0, unitstat);

  00289	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  00291	45 33 c0	 xor	 r8d, r8d
  00294	8b 54 24 78	 mov	 edx, DWORD PTR blkgrp$[rsp]
  00298	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0029d	e8 00 00 00 00	 call	 cckd_read_trk
  002a2	89 44 24 34	 mov	 DWORD PTR cache$[rsp], eax

; 1064 :     if (cache < 0)

  002a6	83 7c 24 34 00	 cmp	 DWORD PTR cache$[rsp], 0
  002ab	7d 28		 jge	 SHORT $LN7@cfba_read_

; 1065 :     {
; 1066 :         dev->bufcur = dev->cache = -1;

  002ad	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002b2	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  002bc	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002c1	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 1067 :         return -1;

  002cb	b8 ff ff ff ff	 mov	 eax, -1
  002d0	e9 27 01 00 00	 jmp	 $LN1@cfba_read_
$LN7@cfba_read_:

; 1068 :     }
; 1069 :     dev->cache    = cache;

  002d5	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002da	8b 4c 24 34	 mov	 ecx, DWORD PTR cache$[rsp]
  002de	89 88 f8 01 00
	00		 mov	 DWORD PTR [rax+504], ecx

; 1070 :     cbuf          = cache_getbuf (CACHE_DEVBUF, dev->cache, 0);

  002e4	45 33 c0	 xor	 r8d, r8d
  002e7	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002ec	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  002f2	33 c9		 xor	 ecx, ecx
  002f4	e8 00 00 00 00	 call	 cache_getbuf
  002f9	48 89 44 24 40	 mov	 QWORD PTR cbuf$[rsp], rax

; 1071 :     dev->buf      = cbuf + CKD_TRKHDR_SIZE;

  002fe	48 8b 44 24 40	 mov	 rax, QWORD PTR cbuf$[rsp]
  00303	48 83 c0 05	 add	 rax, 5
  00307	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0030c	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 1072 :     dev->bufcur   = blkgrp;

  00313	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00318	8b 4c 24 78	 mov	 ecx, DWORD PTR blkgrp$[rsp]
  0031c	89 88 c0 01 00
	00		 mov	 DWORD PTR [rax+448], ecx

; 1073 :     dev->bufoff   = 0;

  00322	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00327	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 1074 :     dev->bufoffhi = CFBA_BLKGRP_SIZE;

  00331	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00336	c7 80 e8 01 00
	00 00 f0 00 00	 mov	 DWORD PTR [rax+488], 61440 ; 0000f000H

; 1075 :     dev->buflen   = CFBA_BLKGRP_SIZE;

  00340	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00345	c7 80 dc 01 00
	00 00 f0 00 00	 mov	 DWORD PTR [rax+476], 61440 ; 0000f000H

; 1076 :     cache_setval  (CACHE_DEVBUF, dev->cache, dev->buflen);

  0034f	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00354	44 8b 80 dc 01
	00 00		 mov	 r8d, DWORD PTR [rax+476]
  0035b	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00360	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00366	33 c9		 xor	 ecx, ecx
  00368	e8 00 00 00 00	 call	 cache_setval

; 1077 :     dev->bufsize  = cache_getlen (CACHE_DEVBUF, dev->cache);

  0036d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00372	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00378	33 c9		 xor	 ecx, ecx
  0037a	e8 00 00 00 00	 call	 cache_getlen
  0037f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00384	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 1078 :     dev->comp     = cbuf[0] & CCKD_COMPRESS_MASK;

  0038a	b8 01 00 00 00	 mov	 eax, 1
  0038f	48 6b c0 00	 imul	 rax, rax, 0
  00393	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cbuf$[rsp]
  00398	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0039c	83 e0 03	 and	 eax, 3
  0039f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  003a4	89 81 0c 02 00
	00		 mov	 DWORD PTR [rcx+524], eax

; 1079 : 
; 1080 :     /* If the image is compressed then call ourself recursively
; 1081 :        to cause the image to get uncompressed.  This is because
; 1082 :       `bufcur' will match blkgrp and `comps' won't match `comp' */
; 1083 :     if (dev->comp != 0 && (dev->comp & dev->comps) == 0)

  003aa	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  003af	83 b8 0c 02 00
	00 00		 cmp	 DWORD PTR [rax+524], 0
  003b6	74 38		 je	 SHORT $LN8@cfba_read_
  003b8	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  003bd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  003c2	8b 89 08 02 00
	00		 mov	 ecx, DWORD PTR [rcx+520]
  003c8	8b 80 0c 02 00
	00		 mov	 eax, DWORD PTR [rax+524]
  003ce	23 c1		 and	 eax, ecx
  003d0	85 c0		 test	 eax, eax
  003d2	75 1c		 jne	 SHORT $LN8@cfba_read_

; 1084 :         rc = cfba_read_block (dev, blkgrp, unitstat);

  003d4	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  003dc	8b 54 24 78	 mov	 edx, DWORD PTR blkgrp$[rsp]
  003e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  003e5	e8 00 00 00 00	 call	 cfba_read_block
  003ea	89 44 24 38	 mov	 DWORD PTR rc$[rsp], eax
  003ee	eb 08		 jmp	 SHORT $LN9@cfba_read_
$LN8@cfba_read_:

; 1085 :     else
; 1086 :         rc = 0;

  003f0	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN9@cfba_read_:

; 1087 : 
; 1088 :     return rc;

  003f8	8b 44 24 38	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cfba_read_:

; 1089 : } /* end function cfba_read_block */

  003fc	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00400	c3		 ret	 0
cfba_read_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
rc$ = 64
cckd$ = 72
dev$ = 112
trk$ = 120
off$ = 128
buf$ = 136
len$ = 144
unitstat$ = 152
cckd_update_track PROC

; 910  : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 911  : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 912  : int             rc;                     /* Return code               */
; 913  : 
; 914  :     cckd = dev->cckd_ext;

  00019	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00025	48 89 44 24 48	 mov	 QWORD PTR cckd$[rsp], rax

; 915  : 
; 916  :     /* Error if opened read-only */
; 917  :     if (dev->ckdrdonly && cckd->sfn == 0)

  0002a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00035	c1 e8 12	 shr	 eax, 18
  00038	83 e0 01	 and	 eax, 1
  0003b	85 c0		 test	 eax, eax
  0003d	74 5a		 je	 SHORT $LN2@cckd_updat
  0003f	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  00044	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00048	75 4f		 jne	 SHORT $LN2@cckd_updat

; 918  :     {
; 919  :         ckd_build_sense (dev, SENSE_EC, SENSE1_WRI, 0,FORMAT_1, MESSAGE_0);

  0004a	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0004f	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00054	45 33 c9	 xor	 r9d, r9d
  00057	41 b0 02	 mov	 r8b, 2
  0005a	b2 10		 mov	 dl, 16
  0005c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00061	e8 00 00 00 00	 call	 ckd_build_sense

; 920  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00066	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0006e	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 921  :         dev->bufcur = dev->cache = -1;

  00071	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00076	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00080	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00085	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 922  :         return -1;

  0008f	b8 ff ff ff ff	 mov	 eax, -1
  00094	e9 e0 01 00 00	 jmp	 $LN1@cckd_updat
$LN2@cckd_updat:

; 923  :     }
; 924  : 
; 925  :     /* If the track is not current or compressed then read it.
; 926  :        `dev->comps' is set to zero forcing the read routine to
; 927  :        uncompress the image.                                     */
; 928  :     if (trk != dev->bufcur || (dev->buf[0] & CCKD_COMPRESS_MASK) != 0)

  00099	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0009e	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  000a4	39 44 24 78	 cmp	 DWORD PTR trk$[rsp], eax
  000a8	75 20		 jne	 SHORT $LN4@cckd_updat
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 00	 imul	 rax, rax, 0
  000b3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000b8	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  000bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c3	83 e0 03	 and	 eax, 3
  000c6	85 c0		 test	 eax, eax
  000c8	74 62		 je	 SHORT $LN3@cckd_updat
$LN4@cckd_updat:

; 929  :     {
; 930  :         dev->comps = 0;

  000ca	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000cf	c7 80 08 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+520], 0

; 931  :         rc = (dev->hnd->read) (dev, trk, unitstat);

  000d9	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000de	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  000e5	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  000ed	8b 54 24 78	 mov	 edx, DWORD PTR trk$[rsp]
  000f1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000f6	ff 50 50	 call	 QWORD PTR [rax+80]
  000f9	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 932  :         if (rc < 0)

  000fd	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00102	7d 28		 jge	 SHORT $LN5@cckd_updat

; 933  :         {
; 934  :             dev->bufcur = dev->cache = -1;

  00104	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00109	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00113	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00118	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 935  :             return -1;

  00122	b8 ff ff ff ff	 mov	 eax, -1
  00127	e9 4d 01 00 00	 jmp	 $LN1@cckd_updat
$LN5@cckd_updat:
$LN3@cckd_updat:

; 936  :         }
; 937  :     }
; 938  : 
; 939  :     /* Invalid track format if going past buffer end */
; 940  :     if (off + len > dev->ckdtrksz)

  0012c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00133	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR off$[rsp]
  0013a	03 c8		 add	 ecx, eax
  0013c	8b c1		 mov	 eax, ecx
  0013e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00143	3b 81 c4 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4804]
  00149	7e 4f		 jle	 SHORT $LN6@cckd_updat

; 941  :     {
; 942  :         ckd_build_sense (dev, 0, SENSE1_ITF, 0, 0, 0);

  0014b	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00150	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00155	45 33 c9	 xor	 r9d, r9d
  00158	41 b0 40	 mov	 r8b, 64			; 00000040H
  0015b	33 d2		 xor	 edx, edx
  0015d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00162	e8 00 00 00 00	 call	 ckd_build_sense

; 943  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00167	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0016f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 944  :         dev->bufcur = dev->cache = -1;

  00172	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00177	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00181	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00186	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 945  :         return -1;

  00190	b8 ff ff ff ff	 mov	 eax, -1
  00195	e9 df 00 00 00	 jmp	 $LN1@cckd_updat
$LN6@cckd_updat:

; 946  :     }
; 947  : 
; 948  :     /* Copy the data into the buffer */
; 949  :     if (buf && len > 0) memcpy (dev->buf + off, buf, len);

  0019a	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  001a3	74 36		 je	 SHORT $LN7@cckd_updat
  001a5	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  001ad	7e 2c		 jle	 SHORT $LN7@cckd_updat
  001af	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  001b7	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR off$[rsp]
  001bf	48 8b 54 24 70	 mov	 rdx, QWORD PTR dev$[rsp]
  001c4	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  001cb	48 8b f9	 mov	 rdi, rcx
  001ce	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR buf$[rsp]
  001d6	48 8b c8	 mov	 rcx, rax
  001d9	f3 a4		 rep movsb
$LN7@cckd_updat:

; 950  : 
; 951  :     CCKD_TRACE( "updt  trk   %d offset %d length %d",

  001db	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001e2	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001e6	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR off$[rsp]
  001ed	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001f1	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  001f5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001f9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169986
  00200	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00205	ba b8 03 00 00	 mov	 edx, 952		; 000003b8H
  0020a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169987
  00211	e8 00 00 00 00	 call	 cckd_trace

; 952  :                 trk, off, len);
; 953  : 
; 954  :     /* Update the cache entry */
; 955  :     cache_setflag (CACHE_DEVBUF, dev->cache, ~0, CCKD_CACHE_UPDATED | CCKD_CACHE_USED);

  00216	41 b9 00 00 80
	08		 mov	 r9d, 142606336		; 08800000H
  0021c	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  00222	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00227	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0022d	33 c9		 xor	 ecx, ecx
  0022f	e8 00 00 00 00	 call	 cache_setflag

; 956  :     cckd->updated = 1;

  00234	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  00239	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0023c	83 c8 10	 or	 eax, 16
  0023f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cckd$[rsp]
  00244	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 957  : 
; 958  :     /* Notify the shared server of the update */
; 959  :     if (!dev->bufupd)

  00247	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0024c	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  00253	75 1d		 jne	 SHORT $LN8@cckd_updat

; 960  :     {
; 961  :         dev->bufupd = 1;

  00255	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0025a	c7 80 f4 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+500], 1

; 962  :         shared_update_notify (dev, trk);

  00264	8b 54 24 78	 mov	 edx, DWORD PTR trk$[rsp]
  00268	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0026d	e8 00 00 00 00	 call	 shared_update_notify
$LN8@cckd_updat:

; 963  :     }
; 964  : 
; 965  :     return len;

  00272	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
$LN1@cckd_updat:

; 966  : 
; 967  : } /* end function cckd_update_track */

  00279	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0027d	5f		 pop	 rdi
  0027e	5e		 pop	 rsi
  0027f	c3		 ret	 0
cckd_update_track ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
cache$ = 48
rc$ = 52
len$ = 56
newbuf$ = 64
cckd$ = 72
dev$ = 96
trk$ = 104
unitstat$ = 112
cckd_read_track PROC

; 822  : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 823  : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 824  : int             rc;                     /* Return code               */
; 825  : int             len;                    /* Compressed length         */
; 826  : BYTE           *newbuf;                 /* Uncompressed buffer       */
; 827  : int             cache;                  /* New active cache entry    */
; 828  : 
; 829  :     cckd = dev->cckd_ext;

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00017	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0001e	48 89 44 24 48	 mov	 QWORD PTR cckd$[rsp], rax

; 830  : 
; 831  :     /* Update length if previous image was updated */
; 832  :     if (dev->bufupd && dev->bufcur >= 0 && dev->cache >= 0)

  00023	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00028	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  0002f	74 5b		 je	 SHORT $LN2@cckd_read_
  00031	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00036	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [rax+448], 0
  0003d	7c 4d		 jl	 SHORT $LN2@cckd_read_
  0003f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00044	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  0004b	7c 3f		 jl	 SHORT $LN2@cckd_read_

; 833  :     {
; 834  :         dev->buflen = cckd_trklen (dev, dev->buf);

  0004d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00059	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0005e	e8 00 00 00 00	 call	 cckd_trklen
  00063	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00068	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 835  :         cache_setval (CACHE_DEVBUF, dev->cache, dev->buflen);

  0006e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00073	44 8b 80 dc 01
	00 00		 mov	 r8d, DWORD PTR [rax+476]
  0007a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0007f	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00085	33 c9		 xor	 ecx, ecx
  00087	e8 00 00 00 00	 call	 cache_setval
$LN2@cckd_read_:

; 836  :     }
; 837  : 
; 838  :     /* Reset buffer offsets */
; 839  :     dev->bufoff = 0;

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00091	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 840  :     dev->bufoffhi = dev->ckdtrksz;

  0009b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000a5	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  000ab	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 841  : 
; 842  :     /* Check if reading the same track image */
; 843  :     if (trk == dev->bufcur && dev->cache >= 0)

  000b1	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000b6	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  000bc	39 44 24 68	 cmp	 DWORD PTR trk$[rsp], eax
  000c0	0f 85 17 02 00
	00		 jne	 $LN3@cckd_read_
  000c6	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000cb	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  000d2	0f 8c 05 02 00
	00		 jl	 $LN3@cckd_read_

; 844  :     {
; 845  :         /* Track image may be compressed */
; 846  :         if ((dev->buf[0] & CCKD_COMPRESS_MASK) != 0
; 847  :          && (dev->buf[0] & dev->comps) == 0)

  000d8	b8 01 00 00 00	 mov	 eax, 1
  000dd	48 6b c0 00	 imul	 rax, rax, 0
  000e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000e6	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  000ed	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f1	83 e0 03	 and	 eax, 3
  000f4	85 c0		 test	 eax, eax
  000f6	0f 84 96 01 00
	00		 je	 $LN4@cckd_read_
  000fc	b8 01 00 00 00	 mov	 eax, 1
  00101	48 6b c0 00	 imul	 rax, rax, 0
  00105	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0010a	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  00111	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00115	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0011a	23 81 08 02 00
	00		 and	 eax, DWORD PTR [rcx+520]
  00120	85 c0		 test	 eax, eax
  00122	0f 85 6a 01 00
	00		 jne	 $LN4@cckd_read_

; 848  :         {
; 849  :             len = cache_getval(CACHE_DEVBUF, dev->cache);

  00128	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0012d	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00133	33 c9		 xor	 ecx, ecx
  00135	e8 00 00 00 00	 call	 cache_getval
  0013a	89 44 24 38	 mov	 DWORD PTR len$[rsp], eax

; 850  :             newbuf = cckd_uncompress (dev, dev->buf, len, dev->ckdtrksz, trk);

  0013e	8b 44 24 68	 mov	 eax, DWORD PTR trk$[rsp]
  00142	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00146	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0014b	44 8b 88 c4 12
	00 00		 mov	 r9d, DWORD PTR [rax+4804]
  00152	44 8b 44 24 38	 mov	 r8d, DWORD PTR len$[rsp]
  00157	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0015c	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00163	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00168	e8 00 00 00 00	 call	 cckd_uncompress
  0016d	48 89 44 24 40	 mov	 QWORD PTR newbuf$[rsp], rax

; 851  :             if (newbuf == NULL) {

  00172	48 83 7c 24 40
	00		 cmp	 QWORD PTR newbuf$[rsp], 0
  00178	75 4c		 jne	 SHORT $LN5@cckd_read_

; 852  :                 ckd_build_sense (dev, SENSE_EC, 0, 0, FORMAT_1, MESSAGE_0);

  0017a	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0017f	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00184	45 33 c9	 xor	 r9d, r9d
  00187	45 33 c0	 xor	 r8d, r8d
  0018a	b2 10		 mov	 dl, 16
  0018c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00191	e8 00 00 00 00	 call	 ckd_build_sense

; 853  :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00196	48 8b 44 24 70	 mov	 rax, QWORD PTR unitstat$[rsp]
  0019b	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 854  :                 dev->bufcur = dev->cache = -1;

  0019e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001a3	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  001ad	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001b2	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 855  :                 return -1;

  001bc	b8 ff ff ff ff	 mov	 eax, -1
  001c1	e9 d1 02 00 00	 jmp	 $LN1@cckd_read_
$LN5@cckd_read_:

; 856  :             }
; 857  :             cache_setbuf (CACHE_DEVBUF, dev->cache, newbuf, dev->ckdtrksz);

  001c6	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001cb	44 8b 88 c4 12
	00 00		 mov	 r9d, DWORD PTR [rax+4804]
  001d2	4c 8b 44 24 40	 mov	 r8, QWORD PTR newbuf$[rsp]
  001d7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001dc	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  001e2	33 c9		 xor	 ecx, ecx
  001e4	e8 00 00 00 00	 call	 cache_setbuf

; 858  :             dev->buf     = newbuf;

  001e9	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newbuf$[rsp]
  001f3	48 89 88 c8 01
	00 00		 mov	 QWORD PTR [rax+456], rcx

; 859  :             dev->buflen  = cckd_trklen (dev, newbuf);

  001fa	48 8b 54 24 40	 mov	 rdx, QWORD PTR newbuf$[rsp]
  001ff	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00204	e8 00 00 00 00	 call	 cckd_trklen
  00209	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0020e	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 860  :             cache_setval (CACHE_DEVBUF, dev->cache, dev->buflen);

  00214	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00219	44 8b 80 dc 01
	00 00		 mov	 r8d, DWORD PTR [rax+476]
  00220	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00225	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0022b	33 c9		 xor	 ecx, ecx
  0022d	e8 00 00 00 00	 call	 cache_setval

; 861  :             dev->bufsize = cache_getlen (CACHE_DEVBUF, dev->cache);

  00232	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00237	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0023d	33 c9		 xor	 ecx, ecx
  0023f	e8 00 00 00 00	 call	 cache_getlen
  00244	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00249	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 862  :             dev->bufupd  = 0;

  0024f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00254	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 863  :             CCKD_TRACE( "read  trk   %d uncompressed len %d",

  0025e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00263	8b 80 dc 01 00
	00		 mov	 eax, DWORD PTR [rax+476]
  00269	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0026d	8b 44 24 68	 mov	 eax, DWORD PTR trk$[rsp]
  00271	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00275	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169955
  0027c	4c 8b 44 24 60	 mov	 r8, QWORD PTR dev$[rsp]
  00281	ba 60 03 00 00	 mov	 edx, 864		; 00000360H
  00286	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169956
  0028d	e8 00 00 00 00	 call	 cckd_trace
$LN4@cckd_read_:

; 864  :                         trk, dev->buflen);
; 865  :         }
; 866  : 
; 867  :         dev->comp = dev->buf[0] & CCKD_COMPRESS_MASK;

  00292	b8 01 00 00 00	 mov	 eax, 1
  00297	48 6b c0 00	 imul	 rax, rax, 0
  0029b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002a0	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  002a7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ab	83 e0 03	 and	 eax, 3
  002ae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002b3	89 81 0c 02 00
	00		 mov	 DWORD PTR [rcx+524], eax

; 868  :         if (dev->comp != 0) dev->compoff = CKD_TRKHDR_SIZE;

  002b9	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002be	83 b8 0c 02 00
	00 00		 cmp	 DWORD PTR [rax+524], 0
  002c5	74 0f		 je	 SHORT $LN6@cckd_read_
  002c7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002cc	c7 80 10 02 00
	00 05 00 00 00	 mov	 DWORD PTR [rax+528], 5
$LN6@cckd_read_:

; 869  : 
; 870  :         return 0;

  002d6	33 c0		 xor	 eax, eax
  002d8	e9 ba 01 00 00	 jmp	 $LN1@cckd_read_
$LN3@cckd_read_:

; 871  :     }
; 872  : 
; 873  :     CCKD_TRACE( "read  trk   %d (%s)", trk, "asynchronous");

  002dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169958
  002e4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002e9	8b 44 24 68	 mov	 eax, DWORD PTR trk$[rsp]
  002ed	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002f1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169959
  002f8	4c 8b 44 24 60	 mov	 r8, QWORD PTR dev$[rsp]
  002fd	ba 69 03 00 00	 mov	 edx, 873		; 00000369H
  00302	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169960
  00309	e8 00 00 00 00	 call	 cckd_trace

; 874  : 
; 875  :     /* read the new track */
; 876  :     dev->bufupd = 0;

  0030e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00313	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 877  :     cache = cckd_read_trk (dev, trk, 0, unitstat);

  0031d	4c 8b 4c 24 70	 mov	 r9, QWORD PTR unitstat$[rsp]
  00322	45 33 c0	 xor	 r8d, r8d
  00325	8b 54 24 68	 mov	 edx, DWORD PTR trk$[rsp]
  00329	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0032e	e8 00 00 00 00	 call	 cckd_read_trk
  00333	89 44 24 30	 mov	 DWORD PTR cache$[rsp], eax

; 878  :     if (cache < 0)

  00337	83 7c 24 30 00	 cmp	 DWORD PTR cache$[rsp], 0
  0033c	7d 28		 jge	 SHORT $LN7@cckd_read_

; 879  :     {
; 880  :         dev->bufcur = dev->cache = -1;

  0033e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00343	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0034d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00352	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 881  :         return -1;

  0035c	b8 ff ff ff ff	 mov	 eax, -1
  00361	e9 31 01 00 00	 jmp	 $LN1@cckd_read_
$LN7@cckd_read_:

; 882  :     }
; 883  : 
; 884  :     dev->cache    = cache;

  00366	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0036b	8b 4c 24 30	 mov	 ecx, DWORD PTR cache$[rsp]
  0036f	89 88 f8 01 00
	00		 mov	 DWORD PTR [rax+504], ecx

; 885  :     dev->buf      = cache_getbuf (CACHE_DEVBUF, dev->cache, 0);

  00375	45 33 c0	 xor	 r8d, r8d
  00378	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0037d	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00383	33 c9		 xor	 ecx, ecx
  00385	e8 00 00 00 00	 call	 cache_getbuf
  0038a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0038f	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 886  :     dev->bufcur   = trk;

  00396	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0039b	8b 4c 24 68	 mov	 ecx, DWORD PTR trk$[rsp]
  0039f	89 88 c0 01 00
	00		 mov	 DWORD PTR [rax+448], ecx

; 887  :     dev->bufoff   = 0;

  003a5	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003aa	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 888  :     dev->bufoffhi = dev->ckdtrksz;

  003b4	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003be	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  003c4	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 889  :     dev->buflen   = cache_getval (CACHE_DEVBUF, dev->cache);

  003ca	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003cf	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  003d5	33 c9		 xor	 ecx, ecx
  003d7	e8 00 00 00 00	 call	 cache_getval
  003dc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003e1	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 890  :     dev->bufsize  = cache_getlen (CACHE_DEVBUF, dev->cache);

  003e7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003ec	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  003f2	33 c9		 xor	 ecx, ecx
  003f4	e8 00 00 00 00	 call	 cache_getlen
  003f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003fe	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 891  : 
; 892  :     dev->comp = dev->buf[0] & CCKD_COMPRESS_MASK;

  00404	b8 01 00 00 00	 mov	 eax, 1
  00409	48 6b c0 00	 imul	 rax, rax, 0
  0040d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00412	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  00419	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0041d	83 e0 03	 and	 eax, 3
  00420	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00425	89 81 0c 02 00
	00		 mov	 DWORD PTR [rcx+524], eax

; 893  :     if (dev->comp != 0) dev->compoff = CKD_TRKHDR_SIZE;

  0042b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00430	83 b8 0c 02 00
	00 00		 cmp	 DWORD PTR [rax+524], 0
  00437	74 0f		 je	 SHORT $LN8@cckd_read_
  00439	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0043e	c7 80 10 02 00
	00 05 00 00 00	 mov	 DWORD PTR [rax+528], 5
$LN8@cckd_read_:

; 894  : 
; 895  :     /* If the image is compressed then call ourself recursively
; 896  :        to cause the image to get uncompressed */
; 897  :     if (dev->comp != 0 && (dev->comp & dev->comps) == 0)

  00448	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0044d	83 b8 0c 02 00
	00 00		 cmp	 DWORD PTR [rax+524], 0
  00454	74 35		 je	 SHORT $LN9@cckd_read_
  00456	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0045b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00460	8b 89 08 02 00
	00		 mov	 ecx, DWORD PTR [rcx+520]
  00466	8b 80 0c 02 00
	00		 mov	 eax, DWORD PTR [rax+524]
  0046c	23 c1		 and	 eax, ecx
  0046e	85 c0		 test	 eax, eax
  00470	75 19		 jne	 SHORT $LN9@cckd_read_

; 898  :         rc = cckd_read_track (dev, trk, unitstat);

  00472	4c 8b 44 24 70	 mov	 r8, QWORD PTR unitstat$[rsp]
  00477	8b 54 24 68	 mov	 edx, DWORD PTR trk$[rsp]
  0047b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00480	e8 00 00 00 00	 call	 cckd_read_track
  00485	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
  00489	eb 08		 jmp	 SHORT $LN10@cckd_read_
$LN9@cckd_read_:

; 899  :     else
; 900  :         rc = 0;

  0048b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN10@cckd_read_:

; 901  : 
; 902  :     return rc;

  00493	8b 44 24 34	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cckd_read_:

; 903  : } /* end function cckd_read_track */

  00497	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0049b	c3		 ret	 0
cckd_read_track ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
cckd$ = 96
i$ = 104
rc$ = 108
tv181 = 112
tv187 = 116
cckd2$1 = 120
tv172 = 128
dev2$2 = 136
tv176 = 144
dev$ = 176
cckd_dasd_close_device PROC

; 298  : {

$LN32:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 299  : CCKD_EXT       *cckd;                   /* -> cckd extension         */
; 300  : int             rc, i;                  /* Return code, Loop index   */
; 301  : 
; 302  :     if (dev->cckd64)

  0000c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00014	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0001b	24 01		 and	 al, 1
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 12		 je	 SHORT $LN14@cckd_dasd_

; 303  :         return cckd64_dasd_close_device( dev );

  00024	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 cckd64_dasd_close_device
  00031	e9 61 06 00 00	 jmp	 $LN1@cckd_dasd_
$LN14@cckd_dasd_:

; 304  : 
; 305  :     cckd = dev->cckd_ext;

  00036	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003e	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00045	48 89 44 24 60	 mov	 QWORD PTR cckd$[rsp], rax

; 306  : 
; 307  :     /* Wait for readaheads to finish */
; 308  :     obtain_lock(&cckdblk.ralock);

  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169644
  00051	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 309  :     cckd->stopping = 1;

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00063	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00066	83 c8 40	 or	 eax, 64			; 00000040H
  00069	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0006e	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN2@cckd_dasd_:

; 310  :     while (cckd->ras)

  00071	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00076	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  0007a	74 35		 je	 SHORT $LN3@cckd_dasd_

; 311  :     {
; 312  :         release_lock(&cckdblk.ralock);

  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169645
  00083	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 313  :         usleep(1);

  00090	b9 01 00 00 00	 mov	 ecx, 1
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 314  :         obtain_lock(&cckdblk.ralock);

  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169646
  000a2	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 315  :     }

  000af	eb c0		 jmp	 SHORT $LN2@cckd_dasd_
$LN3@cckd_dasd_:

; 316  :     release_lock(&cckdblk.ralock);

  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169647
  000b8	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 317  : 
; 318  :     /* Flush the cache and wait for the writes to complete */
; 319  :     obtain_lock( &cckd->cckdiolock );

  000c5	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  000ca	48 83 c0 18	 add	 rax, 24
  000ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169648
  000d5	48 8b c8	 mov	 rcx, rax
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 320  :     {
; 321  :         cckd->stopping = 1;

  000de	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  000e3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000e6	83 c8 40	 or	 eax, 64			; 00000040H
  000e9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  000ee	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 322  :         cckd_flush_cache( dev );

  000f1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000f9	e8 00 00 00 00	 call	 cckd_flush_cache
$LN31@cckd_dasd_:
$LN4@cckd_dasd_:

; 323  :         while (cckd->wrpending || cckd->cckdioact)

  000fe	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00103	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  00107	75 16		 jne	 SHORT $LN15@cckd_dasd_
  00109	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0010e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00111	c1 e8 02	 shr	 eax, 2
  00114	83 e0 01	 and	 eax, 1
  00117	85 c0		 test	 eax, eax
  00119	0f 84 fe 01 00
	00		 je	 $LN5@cckd_dasd_
$LN15@cckd_dasd_:

; 324  :         {
; 325  :             cckd->cckdwaiters++;

  0011f	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00124	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00127	ff c0		 inc	 eax
  00129	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0012e	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 326  :             rc = timed_wait_condition_relative_usecs(

  00131	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00136	48 83 c0 18	 add	 rax, 24
  0013a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0013f	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169650
  0014a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0014f	45 33 c9	 xor	 r9d, r9d
  00152	41 b8 40 42 0f
	00		 mov	 r8d, 1000000		; 000f4240H
  00158	48 8b d0	 mov	 rdx, rax
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timed_wait_condition_relative_usecs_impl
  00161	89 44 24 6c	 mov	 DWORD PTR rc$[rsp], eax

; 327  :                 &cckd->cckdiocond, &cckd->cckdiolock, 1000000, NULL );
; 328  :             cckd->cckdwaiters--;

  00165	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0016a	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0016d	ff c8		 dec	 eax
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00174	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 329  :             cckd_flush_cache( dev );

  00177	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0017f	e8 00 00 00 00	 call	 cckd_flush_cache

; 330  :             if (EINTR == rc)

  00184	83 7c 24 6c 04	 cmp	 DWORD PTR rc$[rsp], 4
  00189	75 05		 jne	 SHORT $LN16@cckd_dasd_

; 331  :                 continue;

  0018b	e9 6e ff ff ff	 jmp	 $LN4@cckd_dasd_
$LN16@cckd_dasd_:

; 332  :             /* Prevent rare but possible hang at shutdown */
; 333  :             if (1
; 334  :                 && ETIMEDOUT == rc
; 335  :                 && (cckd->wrpending || cckd->cckdioact)
; 336  :                 && sysblk.shutdown

  00190	33 c0		 xor	 eax, eax
  00192	83 f8 01	 cmp	 eax, 1
  00195	0f 84 7d 01 00
	00		 je	 $LN17@cckd_dasd_
  0019b	81 7c 24 6c 8a
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 138	; 0000008aH
  001a3	0f 85 6f 01 00
	00		 jne	 $LN17@cckd_dasd_
  001a9	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  001ae	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  001b2	75 16		 jne	 SHORT $LN18@cckd_dasd_
  001b4	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  001b9	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001bc	c1 e8 02	 shr	 eax, 2
  001bf	83 e0 01	 and	 eax, 1
  001c2	85 c0		 test	 eax, eax
  001c4	0f 84 4e 01 00
	00		 je	 $LN17@cckd_dasd_
$LN18@cckd_dasd_:
  001ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001d1	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  001d7	c1 e8 0b	 shr	 eax, 11
  001da	83 e0 01	 and	 eax, 1
  001dd	85 c0		 test	 eax, eax
  001df	0f 84 33 01 00
	00		 je	 $LN17@cckd_dasd_

; 337  :             )
; 338  :             {
; 339  :                 CCKD_TRACE( "closing device while wrpending=%d cckdioact=%d",

  001e5	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  001ea	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001ed	c1 e8 02	 shr	 eax, 2
  001f0	83 e0 01	 and	 eax, 1
  001f3	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001f7	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  001fc	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  001ff	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00203	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169654
  0020a	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00212	ba 54 01 00 00	 mov	 edx, 340		; 00000154H
  00217	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169655
  0021e	e8 00 00 00 00	 call	 cckd_trace

; 340  :                     cckd->wrpending, cckd->cckdioact );
; 341  :                 // "%1d:%04X CCKD file %s: closing device while wrpending=%d cckdioact=%d"
; 342  :                 WRMSG( HHC00381, "W", LCSS_DEVNUM, dev->filename,

  00223	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0022c	74 12		 je	 SHORT $LN27@cckd_dasd_
  0022e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00236	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0023a	89 44 24 70	 mov	 DWORD PTR tv181[rsp], eax
  0023e	eb 08		 jmp	 SHORT $LN28@cckd_dasd_
$LN27@cckd_dasd_:
  00240	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
$LN28@cckd_dasd_:
  00248	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00251	74 14		 je	 SHORT $LN29@cckd_dasd_
  00253	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0025b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0025f	d1 f8		 sar	 eax, 1
  00261	89 44 24 74	 mov	 DWORD PTR tv187[rsp], eax
  00265	eb 08		 jmp	 SHORT $LN30@cckd_dasd_
$LN29@cckd_dasd_:
  00267	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN30@cckd_dasd_:
  0026f	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00274	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00277	c1 e8 02	 shr	 eax, 2
  0027a	83 e0 01	 and	 eax, 1
  0027d	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv172[rsp], eax
  00284	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0028c	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00293	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv176[rsp], rcx
  0029b	b9 01 00 00 00	 mov	 ecx, 1
  002a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a6	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv172[rsp]
  002ad	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  002b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  002b6	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  002b9	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002bd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv176[rsp]
  002c5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002ca	8b 4c 24 70	 mov	 ecx, DWORD PTR tv181[rsp]
  002ce	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002d2	8b 4c 24 74	 mov	 ecx, DWORD PTR tv187[rsp]
  002d6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169656
  002e1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169657
  002ed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f7	41 b9 03 00 00
	00		 mov	 r9d, 3
  002fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169658
  00304	ba 57 01 00 00	 mov	 edx, 343		; 00000157H
  00309	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169659
  00310	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 343  :                     cckd->wrpending, cckd->cckdioact );
; 344  :                 break;

  00316	eb 05		 jmp	 SHORT $LN5@cckd_dasd_
$LN17@cckd_dasd_:

; 345  :             }
; 346  :         }

  00318	e9 e1 fd ff ff	 jmp	 $LN31@cckd_dasd_
$LN5@cckd_dasd_:

; 347  :         broadcast_condition( &cckd->cckdiocond );

  0031d	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00322	48 83 c0 20	 add	 rax, 32			; 00000020H
  00326	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169660
  0032d	48 8b c8	 mov	 rcx, rax
  00330	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition

; 348  :         cckd_purge_cache( dev );

  00336	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0033e	e8 00 00 00 00	 call	 cckd_purge_cache

; 349  :         cckd_purge_l2( dev );

  00343	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0034b	e8 00 00 00 00	 call	 cckd_purge_l2

; 350  :         dev->bufcur = -1;

  00350	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00358	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 351  :         dev->cache  = -1;

  00362	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0036a	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1

; 352  :         if (cckd->newbuf)

  00374	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00379	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0037e	74 1d		 je	 SHORT $LN19@cckd_dasd_

; 353  :             cckd_free( dev, "newbuf", cckd->newbuf );

  00380	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00385	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00389	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169662
  00390	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00398	e8 00 00 00 00	 call	 cckd_free
$LN19@cckd_dasd_:

; 354  :     }
; 355  :     release_lock( &cckd->cckdiolock );

  0039d	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  003a2	48 83 c0 18	 add	 rax, 24
  003a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169663
  003ad	48 8b c8	 mov	 rcx, rax
  003b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 356  : 
; 357  :     /* Remove the device from the cckd queue */
; 358  :     cckd_lock_devchain(1);

  003b6	b9 01 00 00 00	 mov	 ecx, 1
  003bb	e8 00 00 00 00	 call	 cckd_lock_devchain

; 359  :     if (dev == cckdblk.dev1st) cckdblk.dev1st = cckd->devnext;

  003c0	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  003c7	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR dev$[rsp], rax
  003cf	75 11		 jne	 SHORT $LN20@cckd_dasd_
  003d1	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  003d6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003d9	48 89 05 08 00
	00 00		 mov	 QWORD PTR cckdblk+8, rax
  003e0	eb 6b		 jmp	 SHORT $LN21@cckd_dasd_
$LN20@cckd_dasd_:

; 360  :     else
; 361  :     {
; 362  :         DEVBLK *dev2 = cckdblk.dev1st;

  003e2	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  003e9	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dev2$2[rsp], rax

; 363  :         CCKD_EXT *cckd2 = dev2->cckd_ext;

  003f1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev2$2[rsp]
  003f9	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00400	48 89 44 24 78	 mov	 QWORD PTR cckd2$1[rsp], rax
$LN6@cckd_dasd_:

; 364  :         while (cckd2->devnext != dev)

  00405	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd2$1[rsp]
  0040a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00412	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00415	74 26		 je	 SHORT $LN7@cckd_dasd_

; 365  :         {
; 366  :            dev2 = cckd2->devnext; cckd2 = dev2->cckd_ext;

  00417	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd2$1[rsp]
  0041c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0041f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dev2$2[rsp], rax
  00427	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev2$2[rsp]
  0042f	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00436	48 89 44 24 78	 mov	 QWORD PTR cckd2$1[rsp], rax

; 367  :         }

  0043b	eb c8		 jmp	 SHORT $LN6@cckd_dasd_
$LN7@cckd_dasd_:

; 368  :         cckd2->devnext = cckd->devnext;

  0043d	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd2$1[rsp]
  00442	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00447	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0044a	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN21@cckd_dasd_:

; 369  :     }
; 370  :     cckd_unlock_devchain();

  0044d	e8 00 00 00 00	 call	 cckd_unlock_devchain

; 371  : 
; 372  :     /* harden the file */
; 373  :     obtain_lock( &cckd->filelock );

  00452	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00457	48 83 c0 10	 add	 rax, 16
  0045b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169666
  00462	48 8b c8	 mov	 rcx, rax
  00465	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 374  :     {
; 375  :         cckd_harden (dev);

  0046b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00473	e8 00 00 00 00	 call	 cckd_harden

; 376  : 
; 377  :         /* close the shadow files */
; 378  :         for (i = 1; i <= cckd->sfn; i++)

  00478	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00480	eb 0a		 jmp	 SHORT $LN10@cckd_dasd_
$LN8@cckd_dasd_:
  00482	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00486	ff c0		 inc	 eax
  00488	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN10@cckd_dasd_:
  0048c	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00491	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00494	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  00498	7f 25		 jg	 SHORT $LN9@cckd_dasd_

; 379  :         {
; 380  :             cckd_close (dev, i);

  0049a	8b 54 24 68	 mov	 edx, DWORD PTR i$[rsp]
  0049e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004a6	e8 00 00 00 00	 call	 cckd_close

; 381  :             cckd->open[i] = 0;

  004ab	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  004b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  004b5	c6 84 01 1d 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+285], 0

; 382  :         }

  004bd	eb c3		 jmp	 SHORT $LN8@cckd_dasd_
$LN9@cckd_dasd_:

; 383  : 
; 384  :         /* free the level 1 tables */
; 385  :         for (i = 0; i <= cckd->sfn; i++)

  004bf	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004c7	eb 0a		 jmp	 SHORT $LN13@cckd_dasd_
$LN11@cckd_dasd_:
  004c9	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  004cd	ff c0		 inc	 eax
  004cf	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN13@cckd_dasd_:
  004d3	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  004d8	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  004db	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  004df	7f 3a		 jg	 SHORT $LN12@cckd_dasd_

; 386  :             cckd->L1tab[i] = cckd_free (dev, "l1", cckd->L1tab[i]);

  004e1	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  004e6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  004eb	4c 8b 84 c1 98
	01 00 00	 mov	 r8, QWORD PTR [rcx+rax*8+408]
  004f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169667
  004fa	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00502	e8 00 00 00 00	 call	 cckd_free
  00507	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR i$[rsp]
  0050c	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00511	48 89 84 ca 98
	01 00 00	 mov	 QWORD PTR [rdx+rcx*8+408], rax
  00519	eb ae		 jmp	 SHORT $LN11@cckd_dasd_
$LN12@cckd_dasd_:

; 387  : 
; 388  :         /* reset the device handler */
; 389  :         if (cckd->ckddasd)

  0051b	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00520	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00523	83 e0 01	 and	 eax, 1
  00526	85 c0		 test	 eax, eax
  00528	74 18		 je	 SHORT $LN22@cckd_dasd_

; 390  :             dev->hnd = &ckd_dasd_device_hndinfo;

  0052a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00532	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ckd_dasd_device_hndinfo
  00539	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx
  00540	eb 16		 jmp	 SHORT $LN23@cckd_dasd_
$LN22@cckd_dasd_:

; 391  :         else
; 392  :             dev->hnd = &fba_dasd_device_hndinfo;

  00542	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0054a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fba_dasd_device_hndinfo
  00551	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx
$LN23@cckd_dasd_:

; 393  : 
; 394  :         /* write some statistics */
; 395  :         if (!dev->batch && !cckdblk.nosfd)

  00558	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00560	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00566	c1 e8 0a	 shr	 eax, 10
  00569	83 e0 01	 and	 eax, 1
  0056c	85 c0		 test	 eax, eax
  0056e	75 16		 jne	 SHORT $LN24@cckd_dasd_
  00570	83 3d 50 02 00
	00 00		 cmp	 DWORD PTR cckdblk+592, 0
  00577	75 0d		 jne	 SHORT $LN24@cckd_dasd_

; 396  :             cckd_sf_stats (dev);

  00579	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00581	e8 00 00 00 00	 call	 cckd_sf_stats
$LN24@cckd_dasd_:

; 397  :     }
; 398  :     release_lock( &cckd->filelock );

  00586	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0058b	48 83 c0 10	 add	 rax, 16
  0058f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169671
  00596	48 8b c8	 mov	 rcx, rax
  00599	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 399  : 
; 400  :     /* Destroy the cckd extension's locks and conditions */
; 401  :     destroy_lock( &cckd->cckdiolock );

  0059f	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  005a4	48 83 c0 18	 add	 rax, 24
  005a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169672
  005af	48 8b c8	 mov	 rcx, rax
  005b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_lock

; 402  :     destroy_lock( &cckd->filelock );

  005b8	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  005bd	48 83 c0 10	 add	 rax, 16
  005c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169673
  005c8	48 8b c8	 mov	 rcx, rax
  005cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_lock

; 403  :     destroy_condition( &cckd->cckdiocond );

  005d1	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  005d6	48 83 c0 20	 add	 rax, 32			; 00000020H
  005da	48 8b c8	 mov	 rcx, rax
  005dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_condition

; 404  : 
; 405  :     /* free the cckd extension itself */
; 406  :     dev->cckd_ext= cckd_free (dev, "ext", cckd);

  005e3	4c 8b 44 24 60	 mov	 r8, QWORD PTR cckd$[rsp]
  005e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169674
  005ef	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005f7	e8 00 00 00 00	 call	 cckd_free
  005fc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00604	48 89 81 08 13
	00 00		 mov	 QWORD PTR [rcx+4872], rax

; 407  : 
; 408  :     if (dev->dasdsfn) free (dev->dasdsfn);

  0060b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00613	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  0061b	74 15		 je	 SHORT $LN25@cckd_dasd_
  0061d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00625	48 8b 88 70 11
	00 00		 mov	 rcx, QWORD PTR [rax+4464]
  0062c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN25@cckd_dasd_:

; 409  :     dev->dasdsfn = NULL;

  00632	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0063a	48 c7 80 70 11
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4464], 0

; 410  : 
; 411  :     close (dev->fd);

  00645	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0064d	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00653	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 412  :     dev->fd = -1;

  00659	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00661	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 413  : 
; 414  :     /* If no more devices then perform global termination */
; 415  :     cckd_dasd_term_if_appropriate();

  0066b	e8 00 00 00 00	 call	 cckd_dasd_term_if_appropriate

; 416  : 
; 417  :     dev->buf = NULL;

  00670	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00678	48 c7 80 c8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+456], 0

; 418  :     dev->bufsize = 0;

  00683	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0068b	c7 80 d8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+472], 0

; 419  : 
; 420  :     return 0;

  00695	33 c0		 xor	 eax, eax
$LN1@cckd_dasd_:

; 421  : } /* end function cckd_dasd_close_device */

  00697	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0069e	c3		 ret	 0
cckd_dasd_close_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd.c
_TEXT	SEGMENT
cckd$ = 80
i$ = 88
tv90 = 92
tv128 = 96
tv143 = 100
tv149 = 104
tv179 = 108
tv210 = 112
tv216 = 116
fdflags$ = 120
dev2$ = 128
buf$ = 136
__$ArrayPad$ = 168
dev$ = 192
argc$ = 200
argv$ = 208
cckd_dasd_init_handler PROC

; 204  : {

$LN40:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@cckd_dasd_:

; 205  : CCKD_EXT    *cckd;                      /* -> cckd extension         */
; 206  : DEVBLK      *dev2;                      /* -> device in cckd queue   */
; 207  : int          i;                         /* Counter                   */
; 208  : int          fdflags;                   /* File flags                */
; 209  : char         buf[32];                   /* Work buffer                      */
; 210  : 
; 211  :     UNREFERENCED( argc );

  00027	33 c0		 xor	 eax, eax
  00029	85 c0		 test	 eax, eax
  0002b	75 fa		 jne	 SHORT $LN4@cckd_dasd_
$LN7@cckd_dasd_:

; 212  :     UNREFERENCED( argv );

  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 fa		 jne	 SHORT $LN7@cckd_dasd_

; 213  : 
; 214  :     /* Initialize the global cckd block if necessary */
; 215  :     if (memcmp( &cckdblk.id, CCKDBLK_ID, sizeof( cckdblk.id )))

  00033	41 b8 08 00 00
	00		 mov	 r8d, 8
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169594
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk
  00047	e8 00 00 00 00	 call	 memcmp
  0004c	85 c0		 test	 eax, eax
  0004e	74 09		 je	 SHORT $LN14@cckd_dasd_

; 216  :         cckd_dasd_init( 0, NULL );

  00050	33 d2		 xor	 edx, edx
  00052	33 c9		 xor	 ecx, ecx
  00054	e8 00 00 00 00	 call	 cckd_dasd_init
$LN14@cckd_dasd_:

; 217  : 
; 218  :     /* Obtain area for cckd extension */
; 219  :     dev->cckd_ext = cckd = cckd_calloc( dev, "ext", 1, sizeof( CCKD_EXT ));

  00059	41 b9 e0 13 00
	00		 mov	 r9d, 5088		; 000013e0H
  0005f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169595
  0006c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00074	e8 00 00 00 00	 call	 cckd_calloc
  00079	48 89 44 24 50	 mov	 QWORD PTR cckd$[rsp], rax
  0007e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00086	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0008b	48 89 88 08 13
	00 00		 mov	 QWORD PTR [rax+4872], rcx

; 220  :     if (cckd == NULL)

  00092	48 83 7c 24 50
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  00098	75 0a		 jne	 SHORT $LN15@cckd_dasd_

; 221  :         return -1;

  0009a	b8 ff ff ff ff	 mov	 eax, -1
  0009f	e9 df 04 00 00	 jmp	 $LN1@cckd_dasd_
$LN15@cckd_dasd_:

; 222  : 
; 223  :     /* Initialize locks and conditions */
; 224  : 
; 225  :     initialize_lock( &cckd->cckdiolock );

  000a4	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  000a9	48 83 c0 18	 add	 rax, 24
  000ad	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169597
  000b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169598
  000bb	48 8b c8	 mov	 rcx, rax
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 226  :     MSGBUF( buf,    "&cckd->cckdiolock %1d:%04X", LCSS_DEVNUM );

  000c4	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000cd	74 12		 je	 SHORT $LN26@cckd_dasd_
  000cf	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000db	89 44 24 5c	 mov	 DWORD PTR tv90[rsp], eax
  000df	eb 08		 jmp	 SHORT $LN27@cckd_dasd_
$LN26@cckd_dasd_:
  000e1	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN27@cckd_dasd_:
  000e9	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000f2	74 14		 je	 SHORT $LN28@cckd_dasd_
  000f4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000fc	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00100	d1 f8		 sar	 eax, 1
  00102	89 44 24 60	 mov	 DWORD PTR tv128[rsp], eax
  00106	eb 08		 jmp	 SHORT $LN29@cckd_dasd_
$LN28@cckd_dasd_:
  00108	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN29@cckd_dasd_:
  00110	8b 44 24 5c	 mov	 eax, DWORD PTR tv90[rsp]
  00114	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00118	44 8b 4c 24 60	 mov	 r9d, DWORD PTR tv128[rsp]
  0011d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169599
  00124	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00129	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 227  :     set_lock_name(   &cckd->cckdiolock, buf );

  00137	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0013c	48 83 c0 18	 add	 rax, 24
  00140	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00148	48 8b c8	 mov	 rcx, rax
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_lock_name

; 228  : 
; 229  :     initialize_lock( &cckd->filelock );

  00151	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00156	48 83 c0 10	 add	 rax, 16
  0015a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169600
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169601
  00168	48 8b c8	 mov	 rcx, rax
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 230  :     MSGBUF( buf,    "&cckd->filelock %1d:%04X", LCSS_DEVNUM );

  00171	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0017a	74 12		 je	 SHORT $LN30@cckd_dasd_
  0017c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00184	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00188	89 44 24 64	 mov	 DWORD PTR tv143[rsp], eax
  0018c	eb 08		 jmp	 SHORT $LN31@cckd_dasd_
$LN30@cckd_dasd_:
  0018e	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN31@cckd_dasd_:
  00196	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0019f	74 14		 je	 SHORT $LN32@cckd_dasd_
  001a1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a9	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001ad	d1 f8		 sar	 eax, 1
  001af	89 44 24 68	 mov	 DWORD PTR tv149[rsp], eax
  001b3	eb 08		 jmp	 SHORT $LN33@cckd_dasd_
$LN32@cckd_dasd_:
  001b5	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN33@cckd_dasd_:
  001bd	8b 44 24 64	 mov	 eax, DWORD PTR tv143[rsp]
  001c1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001c5	44 8b 4c 24 68	 mov	 r9d, DWORD PTR tv149[rsp]
  001ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169602
  001d1	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001d6	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  001de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 231  :     set_lock_name(   &cckd->filelock, buf );

  001e4	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  001e9	48 83 c0 10	 add	 rax, 16
  001ed	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  001f5	48 8b c8	 mov	 rcx, rax
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_lock_name

; 232  : 
; 233  :     initialize_condition( &cckd->cckdiocond );

  001fe	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00203	48 83 c0 20	 add	 rax, 32			; 00000020H
  00207	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169603
  0020e	48 8b c8	 mov	 rcx, rax
  00211	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 234  : 
; 235  :     /* Initialize some variables */
; 236  :     obtain_lock( &cckd->filelock );

  00217	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0021c	48 83 c0 10	 add	 rax, 16
  00220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169604
  00227	48 8b c8	 mov	 rcx, rax
  0022a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 237  :     {
; 238  :         cckd->L1idx = cckd->sfx = cckd->L2_active = -1;

  00230	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00235	c7 40 50 ff ff
	ff ff		 mov	 DWORD PTR [rax+80], -1
  0023c	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00241	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
  00248	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0024d	c7 40 44 ff ff
	ff ff		 mov	 DWORD PTR [rax+68], -1

; 239  :         dev->cache = cckd->free_idx1st = -1;

  00254	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00259	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1
  00260	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00268	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1

; 240  :         cckd->fd[0] = dev->fd;

  00272	b8 04 00 00 00	 mov	 eax, 4
  00277	48 6b c0 00	 imul	 rax, rax, 0
  0027b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00280	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00288	8b 92 ac 01 00
	00		 mov	 edx, DWORD PTR [rdx+428]
  0028e	89 94 01 f0 00
	00 00		 mov	 DWORD PTR [rcx+rax+240], edx

; 241  :         fdflags = get_file_accmode_flags( dev->fd );

  00295	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0029d	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_get_file_accmode_flags
  002a9	89 44 24 78	 mov	 DWORD PTR fdflags$[rsp], eax

; 242  :         cckd->open[0] = (fdflags & O_RDWR) ? CCKD_OPEN_RW : CCKD_OPEN_RO;

  002ad	8b 44 24 78	 mov	 eax, DWORD PTR fdflags$[rsp]
  002b1	83 e0 02	 and	 eax, 2
  002b4	85 c0		 test	 eax, eax
  002b6	74 0a		 je	 SHORT $LN34@cckd_dasd_
  002b8	c7 44 24 6c 03
	00 00 00	 mov	 DWORD PTR tv179[rsp], 3
  002c0	eb 08		 jmp	 SHORT $LN35@cckd_dasd_
$LN34@cckd_dasd_:
  002c2	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
$LN35@cckd_dasd_:
  002ca	b8 01 00 00 00	 mov	 eax, 1
  002cf	48 6b c0 00	 imul	 rax, rax, 0
  002d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  002d8	0f b6 54 24 6c	 movzx	 edx, BYTE PTR tv179[rsp]
  002dd	88 94 01 1d 01
	00 00		 mov	 BYTE PTR [rcx+rax+285], dl

; 243  :         for (i = 1; i <= CCKD_MAX_SF; i++)

  002e4	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  002ec	eb 0a		 jmp	 SHORT $LN10@cckd_dasd_
$LN8@cckd_dasd_:
  002ee	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  002f2	ff c0		 inc	 eax
  002f4	89 44 24 58	 mov	 DWORD PTR i$[rsp], eax
$LN10@cckd_dasd_:
  002f8	83 7c 24 58 08	 cmp	 DWORD PTR i$[rsp], 8
  002fd	7f 29		 jg	 SHORT $LN9@cckd_dasd_

; 244  :         {
; 245  :             cckd->fd[i] = -1;

  002ff	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  00304	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00309	c7 84 81 f0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+240], -1

; 246  :             cckd->open[i] = CCKD_OPEN_NONE;

  00314	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  00319	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0031e	c6 84 01 1d 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+285], 0

; 247  :         }

  00326	eb c6		 jmp	 SHORT $LN8@cckd_dasd_
$LN9@cckd_dasd_:

; 248  :         cckd->cckd_maxsize = CCKD_MAXSIZE;

  00328	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0032d	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00332	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 249  : 
; 250  :         /* call the chkdsk function */
; 251  :         if (cckd_chkdsk (dev, 0) < 0)

  00336	33 d2		 xor	 edx, edx
  00338	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00340	e8 00 00 00 00	 call	 cckd_chkdsk
  00345	85 c0		 test	 eax, eax
  00347	7d 0a		 jge	 SHORT $LN16@cckd_dasd_

; 252  :             return -1;

  00349	b8 ff ff ff ff	 mov	 eax, -1
  0034e	e9 30 02 00 00	 jmp	 $LN1@cckd_dasd_
$LN16@cckd_dasd_:

; 253  : 
; 254  :         /* Perform initial read */
; 255  :         if (cckd_read_init (dev) < 0)

  00353	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0035b	e8 00 00 00 00	 call	 cckd_read_init
  00360	85 c0		 test	 eax, eax
  00362	7d 0a		 jge	 SHORT $LN17@cckd_dasd_

; 256  :             return -1;

  00364	b8 ff ff ff ff	 mov	 eax, -1
  00369	e9 15 02 00 00	 jmp	 $LN1@cckd_dasd_
$LN17@cckd_dasd_:

; 257  :         if (cckd->fbadasd) dev->ckdtrksz = CFBA_BLKGRP_SIZE;

  0036e	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00373	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00376	d1 e8		 shr	 eax, 1
  00378	83 e0 01	 and	 eax, 1
  0037b	85 c0		 test	 eax, eax
  0037d	74 12		 je	 SHORT $LN18@cckd_dasd_
  0037f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00387	c7 80 c4 12 00
	00 00 f0 00 00	 mov	 DWORD PTR [rax+4804], 61440 ; 0000f000H
$LN18@cckd_dasd_:

; 258  : 
; 259  :         /* open the shadow files */
; 260  :         if (cckd_sf_init (dev) < 0)

  00391	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00399	e8 00 00 00 00	 call	 cckd_sf_init
  0039e	85 c0		 test	 eax, eax
  003a0	0f 8d ad 00 00
	00		 jge	 $LN19@cckd_dasd_

; 261  :         {
; 262  :             WRMSG (HHC00300, "E", LCSS_DEVNUM);

  003a6	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003af	74 12		 je	 SHORT $LN36@cckd_dasd_
  003b1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003bd	89 44 24 70	 mov	 DWORD PTR tv210[rsp], eax
  003c1	eb 08		 jmp	 SHORT $LN37@cckd_dasd_
$LN36@cckd_dasd_:
  003c3	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN37@cckd_dasd_:
  003cb	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003d4	74 14		 je	 SHORT $LN38@cckd_dasd_
  003d6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003de	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003e2	d1 f8		 sar	 eax, 1
  003e4	89 44 24 74	 mov	 DWORD PTR tv216[rsp], eax
  003e8	eb 08		 jmp	 SHORT $LN39@cckd_dasd_
$LN38@cckd_dasd_:
  003ea	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv216[rsp], 0
$LN39@cckd_dasd_:
  003f2	b9 01 00 00 00	 mov	 ecx, 1
  003f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003fd	8b 4c 24 70	 mov	 ecx, DWORD PTR tv210[rsp]
  00401	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00405	8b 4c 24 74	 mov	 ecx, DWORD PTR tv216[rsp]
  00409	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0040d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169609
  00414	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00419	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169610
  00420	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00425	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0042a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00430	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169611
  00437	ba 06 01 00 00	 mov	 edx, 262		; 00000106H
  0043c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169612
  00443	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 263  :             return -1;

  00449	b8 ff ff ff ff	 mov	 eax, -1
  0044e	e9 30 01 00 00	 jmp	 $LN1@cckd_dasd_
$LN19@cckd_dasd_:

; 264  :         }
; 265  : 
; 266  :         /* Update the device handler routines */
; 267  :         if (cckd->ckddasd)

  00453	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00458	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0045b	83 e0 01	 and	 eax, 1
  0045e	85 c0		 test	 eax, eax
  00460	74 18		 je	 SHORT $LN20@cckd_dasd_

; 268  :             dev->hnd = &cckd_dasd_device_hndinfo;

  00462	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0046a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cckd_dasd_device_hndinfo
  00471	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx
  00478	eb 16		 jmp	 SHORT $LN21@cckd_dasd_
$LN20@cckd_dasd_:

; 269  :         else
; 270  :             dev->hnd = &cfba_dasd_device_hndinfo;

  0047a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00482	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfba_dasd_device_hndinfo
  00489	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx
$LN21@cckd_dasd_:

; 271  :     }
; 272  :     release_lock( &cckd->filelock );

  00490	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00495	48 83 c0 10	 add	 rax, 16
  00499	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169615
  004a0	48 8b c8	 mov	 rcx, rax
  004a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 273  : 
; 274  :     /* Insert the device into the cckd device queue */
; 275  :     cckd_lock_devchain(1);

  004a9	b9 01 00 00 00	 mov	 ecx, 1
  004ae	e8 00 00 00 00	 call	 cckd_lock_devchain

; 276  :     for (cckd = NULL, dev2 = cckdblk.dev1st; dev2; dev2 = cckd->devnext)

  004b3	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR cckd$[rsp], 0
  004bc	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  004c3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dev2$[rsp], rax
  004cb	eb 10		 jmp	 SHORT $LN13@cckd_dasd_
$LN11@cckd_dasd_:
  004cd	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  004d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004d5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dev2$[rsp], rax
$LN13@cckd_dasd_:
  004dd	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev2$[rsp], 0
  004e6	74 16		 je	 SHORT $LN12@cckd_dasd_

; 277  :         cckd = dev2->cckd_ext;

  004e8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev2$[rsp]
  004f0	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  004f7	48 89 44 24 50	 mov	 QWORD PTR cckd$[rsp], rax
  004fc	eb cf		 jmp	 SHORT $LN11@cckd_dasd_
$LN12@cckd_dasd_:

; 278  :     if (cckd) cckd->devnext = dev;

  004fe	48 83 7c 24 50
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  00504	74 12		 je	 SHORT $LN22@cckd_dasd_
  00506	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0050b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00513	48 89 08	 mov	 QWORD PTR [rax], rcx
  00516	eb 0f		 jmp	 SHORT $LN23@cckd_dasd_
$LN22@cckd_dasd_:

; 279  :     else cckdblk.dev1st = dev;

  00518	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00520	48 89 05 08 00
	00 00		 mov	 QWORD PTR cckdblk+8, rax
$LN23@cckd_dasd_:

; 280  :     cckd_unlock_devchain();

  00527	e8 00 00 00 00	 call	 cckd_unlock_devchain

; 281  : 
; 282  :     cckdblk.batch = dev->batch;

  0052c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00534	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0053a	c1 e8 0a	 shr	 eax, 10
  0053d	83 e0 01	 and	 eax, 1
  00540	83 e0 01	 and	 eax, 1
  00543	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+16
  00549	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0054c	0b c8		 or	 ecx, eax
  0054e	8b c1		 mov	 eax, ecx
  00550	89 05 10 00 00
	00		 mov	 DWORD PTR cckdblk+16, eax

; 283  : 
; 284  :     if (cckdblk.batch)

  00556	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  0055c	83 e0 01	 and	 eax, 1
  0055f	85 c0		 test	 eax, eax
  00561	74 1e		 je	 SHORT $LN24@cckd_dasd_

; 285  :     {
; 286  :         cckdblk.nostress = 1;

  00563	c7 05 54 02 00
	00 01 00 00 00	 mov	 DWORD PTR cckdblk+596, 1

; 287  :         cckdblk.freepend = 0;

  0056d	c7 05 48 02 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+584, 0

; 288  :         cckdblk.linuxnull = 1;

  00577	c7 05 58 02 00
	00 01 00 00 00	 mov	 DWORD PTR cckdblk+600, 1
$LN24@cckd_dasd_:

; 289  :     }
; 290  : 
; 291  :     return 0;

  00581	33 c0		 xor	 eax, eax
$LN1@cckd_dasd_:

; 292  : } /* end function cckd_dasd_init_handler */

  00583	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0058b	48 33 cc	 xor	 rcx, rsp
  0058e	e8 00 00 00 00	 call	 __security_check_cookie
  00593	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0059a	c3		 ret	 0
cckd_dasd_init_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
tv84 = 32
tv73 = 36
tv93 = 40
a$ = 48
s$ = 56
string$ = 80
abbrev$ = 88
n$ = 96
strcaseabbrev PROC

; 91   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 92   :     register const char *s = string;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00018	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 93   :     register const char *a = abbrev;

  0001d	48 8b 44 24 58	 mov	 rax, QWORD PTR abbrev$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 94   :     if (*a &&
; 95   :         *s &&

  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0002c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002f	85 c0		 test	 eax, eax
  00031	0f 84 02 01 00
	00		 je	 $LN5@strcaseabb
  00037	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  0003c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0003f	85 c0		 test	 eax, eax
  00041	0f 84 f2 00 00
	00		 je	 $LN5@strcaseabb
  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0004c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0004f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00054	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00057	3b c1		 cmp	 eax, ecx
  00059	74 30		 je	 SHORT $LN6@strcaseabb
  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00060	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00063	e8 00 00 00 00	 call	 asciitoupper
  00068	0f be c0	 movsx	 eax, al
  0006b	89 44 24 24	 mov	 DWORD PTR tv73[rsp], eax
  0006f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00074	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00077	e8 00 00 00 00	 call	 asciitoupper
  0007c	0f be c0	 movsx	 eax, al
  0007f	8b 4c 24 24	 mov	 ecx, DWORD PTR tv73[rsp]
  00083	3b c8		 cmp	 ecx, eax
  00085	0f 85 ae 00 00
	00		 jne	 $LN5@strcaseabb
$LN6@strcaseabb:
$LN2@strcaseabb:

; 96   :         (*a == *s ||
; 97   :         asciitoupper(*a) == asciitoupper(*s)))
; 98   :     {
; 99   :         for (;;)
; 100  :         {
; 101  :             a++;

  0008b	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 102  :             if (!*a)

  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0009d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a0	85 c0		 test	 eax, eax
  000a2	75 31		 jne	 SHORT $LN7@strcaseabb

; 103  :                 return (((uintptr_t)a - (uintptr_t)abbrev) >= n);

  000a4	48 8b 44 24 58	 mov	 rax, QWORD PTR abbrev$[rsp]
  000a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  000ae	48 2b c8	 sub	 rcx, rax
  000b1	48 8b c1	 mov	 rax, rcx
  000b4	8b 4c 24 60	 mov	 ecx, DWORD PTR n$[rsp]
  000b8	48 3b c1	 cmp	 rax, rcx
  000bb	72 0a		 jb	 SHORT $LN12@strcaseabb
  000bd	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  000c5	eb 08		 jmp	 SHORT $LN13@strcaseabb
$LN12@strcaseabb:
  000c7	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN13@strcaseabb:
  000cf	8b 44 24 20	 mov	 eax, DWORD PTR tv84[rsp]
  000d3	eb 66		 jmp	 SHORT $LN1@strcaseabb
$LN7@strcaseabb:

; 104  :             s++;

  000d5	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000da	48 ff c0	 inc	 rax
  000dd	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 105  :             if (!*s)

  000e2	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  000e7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ea	85 c0		 test	 eax, eax
  000ec	75 02		 jne	 SHORT $LN8@strcaseabb

; 106  :                 break;

  000ee	eb 49		 jmp	 SHORT $LN3@strcaseabb
$LN8@strcaseabb:

; 107  :             if (*a == *s)

  000f0	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  000f5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000f8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  000fd	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00100	3b c1		 cmp	 eax, ecx
  00102	75 02		 jne	 SHORT $LN9@strcaseabb

; 108  :                 continue;

  00104	eb 85		 jmp	 SHORT $LN2@strcaseabb
$LN9@strcaseabb:

; 109  :             if (asciitoupper(*a) != asciitoupper(*s))

  00106	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0010b	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0010e	e8 00 00 00 00	 call	 asciitoupper
  00113	0f be c0	 movsx	 eax, al
  00116	89 44 24 28	 mov	 DWORD PTR tv93[rsp], eax
  0011a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0011f	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00122	e8 00 00 00 00	 call	 asciitoupper
  00127	0f be c0	 movsx	 eax, al
  0012a	8b 4c 24 28	 mov	 ecx, DWORD PTR tv93[rsp]
  0012e	3b c8		 cmp	 ecx, eax
  00130	74 02		 je	 SHORT $LN10@strcaseabb

; 110  :                 break;

  00132	eb 05		 jmp	 SHORT $LN3@strcaseabb
$LN10@strcaseabb:

; 111  :         }

  00134	e9 52 ff ff ff	 jmp	 $LN2@strcaseabb
$LN3@strcaseabb:
$LN5@strcaseabb:

; 112  :     }
; 113  :     return 0;

  00139	33 c0		 xor	 eax, eax
$LN1@strcaseabb:

; 114  : }

  0013b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013f	c3		 ret	 0
strcaseabbrev ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
c$ = 8
asciitoupper PROC

; 29   : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 30   :   if (c < 'a' || c > 'z')

  00004	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00009	83 f8 61	 cmp	 eax, 97			; 00000061H
  0000c	7c 0a		 jl	 SHORT $LN3@asciitoupp
  0000e	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00013	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00016	7e 07		 jle	 SHORT $LN2@asciitoupp
$LN3@asciitoupp:

; 31   :       return c;

  00018	0f b6 44 24 08	 movzx	 eax, BYTE PTR c$[rsp]
  0001d	eb 08		 jmp	 SHORT $LN1@asciitoupp
$LN2@asciitoupp:

; 32   :   return (c - 32);

  0001f	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00024	83 e8 20	 sub	 eax, 32			; 00000020H
$LN1@asciitoupp:

; 33   : }

  00027	c3		 ret	 0
asciitoupper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
ctime	PROC

; 474  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 475  :             return _ctime64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ctime64

; 476  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
ctime	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
END
