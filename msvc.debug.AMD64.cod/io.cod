; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+8
?msbn@?1??s390_store_channel_path_status@@9@9 DB 08H	; `s390_store_channel_path_status'::`2'::msbn
	DB	07H
	DB	06H
	DB	06H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
?msbn@?1??z900_store_channel_path_status@@9@9 DB 08H	; `z900_store_channel_path_status'::`2'::msbn
	DB	07H
	DB	06H
	DB	06H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
PUBLIC	s370_connect_channel_set
PUBLIC	s370_disconnect_channel_set
PUBLIC	s370_start_io
PUBLIC	s370_test_io
PUBLIC	s370_halt_io
PUBLIC	s370_test_channel
PUBLIC	s370_store_channel_id
PUBLIC	fetch_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	store_dw_noswap
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s390_cancel_subchannel
PUBLIC	s390_clear_subchannel
PUBLIC	s390_halt_subchannel
PUBLIC	s390_modify_subchannel
PUBLIC	s390_resume_subchannel
PUBLIC	s390_set_address_limit
PUBLIC	s390_set_channel_monitor
PUBLIC	s390_reset_channel_path
PUBLIC	s390_start_subchannel
PUBLIC	s390_store_channel_path_status
PUBLIC	s390_store_channel_report_word
PUBLIC	s390_store_subchannel
PUBLIC	s390_test_pending_interruption
PUBLIC	s390_test_subchannel
PUBLIC	s390__or_storage_key
PUBLIC	s390_get_ptr_to_4K_storekey
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_or_storage_key
PUBLIC	s390_get_ptr_to_storekey
PUBLIC	s390_maddr_l
PUBLIC	s390_vstore4_full
PUBLIC	s390_vstore8_full
PUBLIC	s390_vstorec
PUBLIC	s390_vstore4
PUBLIC	s390_vstore8
PUBLIC	s390_vfetchc
PUBLIC	s390_validate_operand
PUBLIC	z900_cancel_subchannel
PUBLIC	z900_clear_subchannel
PUBLIC	z900_halt_subchannel
PUBLIC	z900_modify_subchannel
PUBLIC	z900_resume_subchannel
PUBLIC	z900_set_address_limit
PUBLIC	z900_set_channel_monitor
PUBLIC	z900_reset_channel_path
PUBLIC	z900_start_subchannel
PUBLIC	z900_store_channel_path_status
PUBLIC	z900_store_channel_report_word
PUBLIC	z900_store_subchannel
PUBLIC	z900_test_pending_interruption
PUBLIC	z900_test_subchannel
PUBLIC	z900__or_storage_key
PUBLIC	z900_get_ptr_to_4K_storekey
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_or_storage_key
PUBLIC	z900_get_ptr_to_storekey
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_xcheck
PUBLIC	z900_maddr_l
PUBLIC	z900_vstore4_full
PUBLIC	z900_vstore8_full
PUBLIC	z900_vstorec
PUBLIC	z900_vstore4
PUBLIC	z900_vstore8
PUBLIC	z900_vfetchc
PUBLIC	z900_validate_operand
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	longjmp:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_sched_yield:PROC
EXTRN	s370_startio:PROC
EXTRN	stchan_id:PROC
EXTRN	testch:PROC
EXTRN	testio:PROC
EXTRN	test_subchan:PROC
EXTRN	cancel_subchan:PROC
EXTRN	clear_subchan:PROC
EXTRN	halt_subchan:PROC
EXTRN	haltio:PROC
EXTRN	resume_subchan:PROC
EXTRN	chp_reset:PROC
EXTRN	get_next_channel_report_word:PROC
EXTRN	find_device_by_devnum:PROC
EXTRN	find_device_by_subchan:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	z900_abort_transaction:PROC
EXTRN	ecpsvm_dosio:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	s390_startio:PROC
EXTRN	s390_present_io_interrupt:PROC
EXTRN	z900_startio:PROC
EXTRN	z900_present_io_interrupt:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$s370_connect_channel_set DD imagerel $LN37
	DD	imagerel $LN37+1055
	DD	imagerel $unwind$s370_connect_channel_set
$pdata$s370_disconnect_channel_set DD imagerel $LN33
	DD	imagerel $LN33+866
	DD	imagerel $unwind$s370_disconnect_channel_set
$pdata$s370_start_io DD imagerel $LN39
	DD	imagerel $LN39+1366
	DD	imagerel $unwind$s370_start_io
$pdata$s370_test_io DD imagerel $LN29
	DD	imagerel $LN29+665
	DD	imagerel $unwind$s370_test_io
$pdata$s370_halt_io DD imagerel $LN28
	DD	imagerel $LN28+645
	DD	imagerel $unwind$s370_halt_io
$pdata$s370_test_channel DD imagerel $LN23
	DD	imagerel $LN23+582
	DD	imagerel $unwind$s370_test_channel
$pdata$s370_store_channel_id DD imagerel $LN22
	DD	imagerel $LN22+475
	DD	imagerel $unwind$s370_store_channel_id
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$wakeup_cpu DD imagerel wakeup_cpu
	DD	imagerel wakeup_cpu+44
	DD	imagerel $unwind$wakeup_cpu
$pdata$wakeup_cpu_mask DD imagerel wakeup_cpu_mask
	DD	imagerel wakeup_cpu_mask+251
	DD	imagerel $unwind$wakeup_cpu_mask
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
pdata	SEGMENT
$pdata$s390_cancel_subchannel DD imagerel $LN48
	DD	imagerel $LN48+1274
	DD	imagerel $unwind$s390_cancel_subchannel
$pdata$s390_clear_subchannel DD imagerel $LN43
	DD	imagerel $LN43+1147
	DD	imagerel $unwind$s390_clear_subchannel
$pdata$s390_halt_subchannel DD imagerel $LN48
	DD	imagerel $LN48+1279
	DD	imagerel $unwind$s390_halt_subchannel
$pdata$s390_modify_subchannel DD imagerel $LN58
	DD	imagerel $LN58+2467
	DD	imagerel $unwind$s390_modify_subchannel
$pdata$s390_resume_subchannel DD imagerel $LN48
	DD	imagerel $LN48+1303
	DD	imagerel $unwind$s390_resume_subchannel
$pdata$s390_set_address_limit DD imagerel $LN19
	DD	imagerel $LN19+456
	DD	imagerel $unwind$s390_set_address_limit
$pdata$s390_set_channel_monitor DD imagerel $LN35
	DD	imagerel $LN35+1273
	DD	imagerel $unwind$s390_set_channel_monitor
$pdata$s390_reset_channel_path DD imagerel $LN23
	DD	imagerel $LN23+630
	DD	imagerel $unwind$s390_reset_channel_path
$pdata$s390_start_subchannel DD imagerel $LN56
	DD	imagerel $LN56+1696
	DD	imagerel $unwind$s390_start_subchannel
$pdata$s390_store_channel_path_status DD imagerel $LN22
	DD	imagerel $LN22+876
	DD	imagerel $unwind$s390_store_channel_path_status
$pdata$s390_store_channel_report_word DD imagerel $LN29
	DD	imagerel $LN29+734
	DD	imagerel $unwind$s390_store_channel_report_word
$pdata$s390_store_subchannel DD imagerel $LN39
	DD	imagerel $LN39+1211
	DD	imagerel $unwind$s390_store_subchannel
$pdata$s390_test_pending_interruption DD imagerel $LN49
	DD	imagerel $LN49+1551
	DD	imagerel $unwind$s390_test_pending_interruption
$pdata$s390_test_subchannel DD imagerel $LN52
	DD	imagerel $LN52+1553
	DD	imagerel $unwind$s390_test_subchannel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_ptr_to_4K_storekey DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$s390_get_ptr_to_4K_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_ptr_to_storekey DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$s390_get_ptr_to_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+321
	DD	imagerel $unwind$s390_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore8_full DD imagerel $LN3
	DD	imagerel $LN3+364
	DD	imagerel $unwind$s390_vstore8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstorec DD imagerel $LN9
	DD	imagerel $LN9+498
	DD	imagerel $unwind$s390_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore4 DD imagerel $LN12
	DD	imagerel $LN12+200
	DD	imagerel $unwind$s390_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore8 DD imagerel $LN9
	DD	imagerel $LN9+168
	DD	imagerel $unwind$s390_vstore8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+432
	DD	imagerel $unwind$s390_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+185
	DD	imagerel $unwind$s390_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$z900_cancel_subchannel DD imagerel $LN52
	DD	imagerel $LN52+1433
	DD	imagerel $unwind$z900_cancel_subchannel
$pdata$z900_clear_subchannel DD imagerel $LN47
	DD	imagerel $LN47+1292
	DD	imagerel $unwind$z900_clear_subchannel
$pdata$z900_halt_subchannel DD imagerel $LN52
	DD	imagerel $LN52+1438
	DD	imagerel $unwind$z900_halt_subchannel
$pdata$z900_modify_subchannel DD imagerel $LN62
	DD	imagerel $LN62+2705
	DD	imagerel $unwind$z900_modify_subchannel
$pdata$z900_resume_subchannel DD imagerel $LN52
	DD	imagerel $LN52+1462
	DD	imagerel $unwind$z900_resume_subchannel
$pdata$z900_set_address_limit DD imagerel $LN23
	DD	imagerel $LN23+559
	DD	imagerel $unwind$z900_set_address_limit
$pdata$z900_set_channel_monitor DD imagerel $LN39
	DD	imagerel $LN39+1376
	DD	imagerel $unwind$z900_set_channel_monitor
$pdata$z900_reset_channel_path DD imagerel $LN27
	DD	imagerel $LN27+747
	DD	imagerel $unwind$z900_reset_channel_path
$pdata$z900_start_subchannel DD imagerel $LN59
	DD	imagerel $LN59+1880
	DD	imagerel $unwind$z900_start_subchannel
$pdata$z900_store_channel_path_status DD imagerel $LN26
	DD	imagerel $LN26+1011
	DD	imagerel $unwind$z900_store_channel_path_status
$pdata$z900_store_channel_report_word DD imagerel $LN33
	DD	imagerel $LN33+884
	DD	imagerel $unwind$z900_store_channel_report_word
$pdata$z900_store_subchannel DD imagerel $LN43
	DD	imagerel $LN43+1386
	DD	imagerel $unwind$z900_store_subchannel
$pdata$z900_test_pending_interruption DD imagerel $LN51
	DD	imagerel $LN51+1595
	DD	imagerel $unwind$z900_test_pending_interruption
$pdata$z900_test_subchannel DD imagerel $LN56
	DD	imagerel $LN56+1769
	DD	imagerel $unwind$z900_test_subchannel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_ptr_to_4K_storekey DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$z900_get_ptr_to_4K_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_ptr_to_storekey DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$z900_get_ptr_to_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck DD imagerel $LN6
	DD	imagerel $LN6+108
	DD	imagerel $unwind$z900_per3_zero_xcheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+332
	DD	imagerel $unwind$z900_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8_full DD imagerel $LN3
	DD	imagerel $LN3+375
	DD	imagerel $unwind$z900_vstore8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore4 DD imagerel $LN12
	DD	imagerel $LN12+209
	DD	imagerel $unwind$z900_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8 DD imagerel $LN9
	DD	imagerel $LN9+174
	DD	imagerel $unwind$z900_vstore8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+445
	DD	imagerel $unwind$z900_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+195
	DD	imagerel $unwind$z900_validate_operand
pdata	ENDS
_DATA	SEGMENT
$SG169840 DB	'io.c:1098', 00H
	ORG $+2
$SG169841 DB	'SIO', 00H
$SG169845 DB	'io.c:1104', 00H
	ORG $+2
$SG169846 DB	'*SIO', 00H
	ORG $+3
$SG169908 DB	'TIO', 00H
$SG169854 DB	'io.c:1148', 00H
	ORG $+2
$SG169855 DB	'*SIO', 00H
	ORG $+3
$SG169971 DB	'HIO', 00H
$SG169907 DB	'io.c:1169', 00H
	ORG $+2
$SG170021 DB	'TCH', 00H
$SG169912 DB	'io.c:1175', 00H
	ORG $+2
$SG169913 DB	'*TIO', 00H
	ORG $+3
$SG170072 DB	'STIDC', 00H
	ORG $+2
$SG170076 DB	'*STIDC', 00H
	ORG $+1
$SG180770 DB	'SAL', 00H
$SG169916 DB	'io.c:1184', 00H
	ORG $+2
$SG169917 DB	'*TIO', 00H
	ORG $+3
$SG170139 DB	'CONCS', 00H
	ORG $+2
$SG170143 DB	'*CONCS', 00H
	ORG $+1
$SG181195 DB	'TPI', 00H
$SG169970 DB	'io.c:1210', 00H
	ORG $+2
$SG170214 DB	'*DISCS', 00H
	ORG $+1
$SG194891 DB	'SAL', 00H
$SG169975 DB	'io.c:1216', 00H
	ORG $+2
$SG169976 DB	'*HIO', 00H
	ORG $+3
$SG170210 DB	'DISCS', 00H
	ORG $+2
$SG170222 DB	'*DISCS', 00H
	ORG $+1
$SG195345 DB	'TPI', 00H
$SG169979 DB	'io.c:1225', 00H
	ORG $+2
$SG169980 DB	'*HIO', 00H
	ORG $+3
$SG180333 DB	'*CSCH', 00H
	ORG $+2
$SG181045 DB	'*STCRW', 00H
	ORG $+5
$SG170020 DB	'io.c:1245', 00H
	ORG $+6
$SG170029 DB	'io.c:1268', 00H
	ORG $+2
$SG170030 DB	'*TCH', 00H
	ORG $+7
$SG170071 DB	'io.c:1285', 00H
	ORG $+6
$SG170075 DB	'io.c:1292', 00H
	ORG $+6
$SG170138 DB	'io.c:1311', 00H
	ORG $+6
$SG170142 DB	'io.c:1318', 00H
	ORG $+6
$SG170145 DB	'io.c:1334', 00H
	ORG $+6
$SG170147 DB	'io.c:1343', 00H
	ORG $+6
$SG170152 DB	'io.c:1353', 00H
	ORG $+6
$SG170153 DB	'io.c:1355', 00H
	ORG $+6
$SG170209 DB	'io.c:1376', 00H
	ORG $+6
$SG170213 DB	'io.c:1381', 00H
	ORG $+6
$SG170216 DB	'io.c:1395', 00H
	ORG $+6
$SG170221 DB	'io.c:1412', 00H
	ORG $+6
$SG170223 DB	'io.c:1414', 00H
	ORG $+6
$SG170224 DB	'io.c:1419', 00H
	ORG $+6
$SG180316 DB	'C:\papa\MyGit\hyperion-zvector\io.c:79', 00H
	ORG $+1
$SG180317 DB	'CSCH', 00H
	ORG $+3
$SG180320 DB	'C:\papa\MyGit\hyperion-zvector\io.c:85', 00H
	ORG $+1
$SG180321 DB	'CSCH (sie)', 00H
	ORG $+5
$SG180327 DB	'C:\papa\MyGit\hyperion-zvector\io.c:96', 00H
	ORG $+1
$SG180328 DB	'CSCH (dev)', 00H
	ORG $+5
$SG180332 DB	'C:\papa\MyGit\hyperion-zvector\io.c:106', 00H
$SG180335 DB	'C:\papa\MyGit\hyperion-zvector\io.c:108', 00H
$SG180336 DB	'*CSCH (sie)', 00H
	ORG $+4
$SG180420 DB	'C:\papa\MyGit\hyperion-zvector\io.c:136', 00H
$SG180421 DB	'HSCH', 00H
	ORG $+3
$SG180424 DB	'C:\papa\MyGit\hyperion-zvector\io.c:142', 00H
$SG180425 DB	'HSCH (sie)', 00H
	ORG $+5
$SG180431 DB	'C:\papa\MyGit\hyperion-zvector\io.c:153', 00H
$SG180432 DB	'HSCH (dev)', 00H
	ORG $+5
$SG180436 DB	'C:\papa\MyGit\hyperion-zvector\io.c:163', 00H
$SG180437 DB	'*HSCH', 00H
	ORG $+2
$SG180439 DB	'C:\papa\MyGit\hyperion-zvector\io.c:165', 00H
$SG180440 DB	'*HSCH (sie)', 00H
	ORG $+4
$SG180444 DB	'C:\papa\MyGit\hyperion-zvector\io.c:174', 00H
$SG180445 DB	'*HSCH', 00H
	ORG $+2
$SG180544 DB	'C:\papa\MyGit\hyperion-zvector\io.c:194', 00H
$SG180545 DB	'MSCH', 00H
	ORG $+3
$SG180547 DB	'C:\papa\MyGit\hyperion-zvector\io.c:196', 00H
$SG180548 DB	'MSCH (sie)', 00H
	ORG $+5
$SG180557 DB	'C:\papa\MyGit\hyperion-zvector\io.c:226', 00H
$SG180558 DB	'MSCH (dev)', 00H
	ORG $+5
$SG180561 DB	'C:\papa\MyGit\hyperion-zvector\io.c:231', 00H
$SG180562 DB	'*MSCH', 00H
	ORG $+2
$SG180565 DB	'C:\papa\MyGit\hyperion-zvector\io.c:239', 00H
$SG180566 DB	'*MSCH', 00H
	ORG $+2
$SG180567 DB	'C:\papa\MyGit\hyperion-zvector\io.c:249', 00H
$SG180570 DB	'C:\papa\MyGit\hyperion-zvector\io.c:258', 00H
$SG180571 DB	'*MSCH', 00H
	ORG $+2
$SG180572 DB	'C:\papa\MyGit\hyperion-zvector\io.c:260', 00H
$SG180577 DB	'C:\papa\MyGit\hyperion-zvector\io.c:267', 00H
$SG180578 DB	'*MSCH', 00H
	ORG $+2
$SG180579 DB	'C:\papa\MyGit\hyperion-zvector\io.c:269', 00H
$SG180582 DB	'C:\papa\MyGit\hyperion-zvector\io.c:330', 00H
$SG180624 DB	'C:\papa\MyGit\hyperion-zvector\io.c:352', 00H
$SG180625 DB	'RCHP', 00H
	ORG $+3
$SG180629 DB	'C:\papa\MyGit\hyperion-zvector\io.c:362', 00H
$SG180630 DB	'*RCHP', 00H
	ORG $+2
$SG180713 DB	'C:\papa\MyGit\hyperion-zvector\io.c:382', 00H
$SG180714 DB	'RSCH', 00H
	ORG $+3
$SG180717 DB	'C:\papa\MyGit\hyperion-zvector\io.c:388', 00H
$SG180718 DB	'RSCH (sie)', 00H
	ORG $+5
$SG180724 DB	'C:\papa\MyGit\hyperion-zvector\io.c:399', 00H
$SG180725 DB	'RSCH (dev)', 00H
	ORG $+5
$SG180729 DB	'C:\papa\MyGit\hyperion-zvector\io.c:409', 00H
$SG180730 DB	'*RSCH', 00H
	ORG $+2
$SG180732 DB	'C:\papa\MyGit\hyperion-zvector\io.c:411', 00H
$SG180733 DB	'*RSCH (sie)', 00H
	ORG $+4
$SG180737 DB	'C:\papa\MyGit\hyperion-zvector\io.c:420', 00H
$SG180738 DB	'*RSCH', 00H
	ORG $+2
$SG180769 DB	'C:\papa\MyGit\hyperion-zvector\io.c:440', 00H
$SG180808 DB	'C:\papa\MyGit\hyperion-zvector\io.c:467', 00H
$SG180809 DB	'SCHM', 00H
	ORG $+3
$SG180909 DB	'C:\papa\MyGit\hyperion-zvector\io.c:546', 00H
$SG180910 DB	'SSCH', 00H
	ORG $+3
$SG180913 DB	'C:\papa\MyGit\hyperion-zvector\io.c:552', 00H
$SG180914 DB	'SSCH (sie)', 00H
	ORG $+5
$SG180924 DB	'C:\papa\MyGit\hyperion-zvector\io.c:588', 00H
$SG180925 DB	'SSCH (dev)', 00H
	ORG $+5
$SG180929 DB	'C:\papa\MyGit\hyperion-zvector\io.c:599', 00H
$SG180930 DB	'*SSCH', 00H
	ORG $+2
$SG180932 DB	'C:\papa\MyGit\hyperion-zvector\io.c:601', 00H
$SG180933 DB	'*SSCH (sie)', 00H
	ORG $+4
$SG180938 DB	'C:\papa\MyGit\hyperion-zvector\io.c:627', 00H
$SG180939 DB	'*SSCH', 00H
	ORG $+2
$SG180979 DB	'C:\papa\MyGit\hyperion-zvector\io.c:668', 00H
$SG180980 DB	'STCPS', 00H
	ORG $+2
$SG180982 DB	'C:\papa\MyGit\hyperion-zvector\io.c:680', 00H
$SG180984 DB	'C:\papa\MyGit\hyperion-zvector\io.c:698', 00H
$SG181034 DB	'C:\papa\MyGit\hyperion-zvector\io.c:719', 00H
$SG181035 DB	'STCRW', 00H
	ORG $+2
$SG181040 DB	'C:\papa\MyGit\hyperion-zvector\io.c:731', 00H
$SG181041 DB	'STCRW crw', 00H
	ORG $+6
$SG181044 DB	'C:\papa\MyGit\hyperion-zvector\io.c:740', 00H
$SG181110 DB	'C:\papa\MyGit\hyperion-zvector\io.c:759', 00H
$SG181111 DB	'STSCH', 00H
	ORG $+2
$SG181113 DB	'C:\papa\MyGit\hyperion-zvector\io.c:760', 00H
$SG181114 DB	'STSCH (sie)', 00H
	ORG $+4
$SG181120 DB	'C:\papa\MyGit\hyperion-zvector\io.c:770', 00H
$SG181121 DB	'STSCH (dev)', 00H
	ORG $+4
$SG181124 DB	'C:\papa\MyGit\hyperion-zvector\io.c:775', 00H
$SG181125 DB	'*STSCH', 00H
	ORG $+1
$SG181127 DB	'C:\papa\MyGit\hyperion-zvector\io.c:789', 00H
$SG181130 DB	'C:\papa\MyGit\hyperion-zvector\io.c:796', 00H
$SG181194 DB	'C:\papa\MyGit\hyperion-zvector\io.c:835', 00H
$SG181200 DB	'C:\papa\MyGit\hyperion-zvector\io.c:850', 00H
$SG181201 DB	'C:\papa\MyGit\hyperion-zvector\io.c:858', 00H
$SG181213 DB	'C:\papa\MyGit\hyperion-zvector\io.c:922', 00H
$SG181214 DB	'*TPI', 00H
	ORG $+3
$SG181304 DB	'C:\papa\MyGit\hyperion-zvector\io.c:942', 00H
$SG181305 DB	'TSCH', 00H
	ORG $+3
$SG181308 DB	'C:\papa\MyGit\hyperion-zvector\io.c:948', 00H
$SG181309 DB	'TSCH (sie)', 00H
	ORG $+5
$SG181316 DB	'C:\papa\MyGit\hyperion-zvector\io.c:961', 00H
$SG181317 DB	'TSCH (dev)', 00H
	ORG $+5
$SG181321 DB	'C:\papa\MyGit\hyperion-zvector\io.c:971', 00H
$SG181322 DB	'*TSCH', 00H
	ORG $+2
$SG181324 DB	'C:\papa\MyGit\hyperion-zvector\io.c:973', 00H
$SG181325 DB	'*TSCH (sie)', 00H
	ORG $+4
$SG181329 DB	'C:\papa\MyGit\hyperion-zvector\io.c:997', 00H
$SG181330 DB	'*TSCH', 00H
	ORG $+2
$SG181413 DB	'C:\papa\MyGit\hyperion-zvector\io.c:1016', 00H
	ORG $+3
$SG181414 DB	'XSCH', 00H
	ORG $+7
$SG181417 DB	'C:\papa\MyGit\hyperion-zvector\io.c:1022', 00H
	ORG $+7
$SG181418 DB	'XSCH (sie)', 00H
	ORG $+5
$SG181424 DB	'C:\papa\MyGit\hyperion-zvector\io.c:1033', 00H
	ORG $+7
$SG181425 DB	'XSCH (dev)', 00H
	ORG $+5
$SG181429 DB	'C:\papa\MyGit\hyperion-zvector\io.c:1043', 00H
	ORG $+3
$SG181430 DB	'*XSCH', 00H
	ORG $+6
$SG181432 DB	'C:\papa\MyGit\hyperion-zvector\io.c:1045', 00H
	ORG $+7
$SG181433 DB	'*XSCH (sie)', 00H
	ORG $+4
$SG181437 DB	'C:\papa\MyGit\hyperion-zvector\io.c:1056', 00H
	ORG $+3
$SG181438 DB	'*XSCH', 00H
	ORG $+6
$SG194409 DB	'C:\papa\MyGit\hyperion-zvector\io.c:76', 00H
	ORG $+1
$SG194412 DB	'C:\papa\MyGit\hyperion-zvector\io.c:79', 00H
	ORG $+1
$SG194413 DB	'CSCH', 00H
	ORG $+3
$SG194416 DB	'C:\papa\MyGit\hyperion-zvector\io.c:85', 00H
	ORG $+1
$SG194417 DB	'CSCH (sie)', 00H
	ORG $+5
$SG194423 DB	'C:\papa\MyGit\hyperion-zvector\io.c:96', 00H
	ORG $+1
$SG194424 DB	'CSCH (dev)', 00H
	ORG $+5
$SG194428 DB	'C:\papa\MyGit\hyperion-zvector\io.c:106', 00H
$SG194429 DB	'*CSCH', 00H
	ORG $+2
$SG194431 DB	'C:\papa\MyGit\hyperion-zvector\io.c:108', 00H
$SG194432 DB	'*CSCH (sie)', 00H
	ORG $+4
$SG194518 DB	'C:\papa\MyGit\hyperion-zvector\io.c:133', 00H
$SG194521 DB	'C:\papa\MyGit\hyperion-zvector\io.c:136', 00H
$SG194522 DB	'HSCH', 00H
	ORG $+3
$SG194525 DB	'C:\papa\MyGit\hyperion-zvector\io.c:142', 00H
$SG194526 DB	'HSCH (sie)', 00H
	ORG $+5
$SG194532 DB	'C:\papa\MyGit\hyperion-zvector\io.c:153', 00H
$SG194533 DB	'HSCH (dev)', 00H
	ORG $+5
$SG194537 DB	'C:\papa\MyGit\hyperion-zvector\io.c:163', 00H
$SG194538 DB	'*HSCH', 00H
	ORG $+2
$SG194540 DB	'C:\papa\MyGit\hyperion-zvector\io.c:165', 00H
$SG194541 DB	'*HSCH (sie)', 00H
	ORG $+4
$SG194545 DB	'C:\papa\MyGit\hyperion-zvector\io.c:174', 00H
$SG194546 DB	'*HSCH', 00H
	ORG $+2
$SG194647 DB	'C:\papa\MyGit\hyperion-zvector\io.c:191', 00H
$SG194650 DB	'C:\papa\MyGit\hyperion-zvector\io.c:194', 00H
$SG194651 DB	'MSCH', 00H
	ORG $+3
$SG194653 DB	'C:\papa\MyGit\hyperion-zvector\io.c:196', 00H
$SG194654 DB	'MSCH (sie)', 00H
	ORG $+5
$SG194663 DB	'C:\papa\MyGit\hyperion-zvector\io.c:226', 00H
$SG194664 DB	'MSCH (dev)', 00H
	ORG $+5
$SG194667 DB	'C:\papa\MyGit\hyperion-zvector\io.c:231', 00H
$SG194668 DB	'*MSCH', 00H
	ORG $+2
$SG194671 DB	'C:\papa\MyGit\hyperion-zvector\io.c:239', 00H
$SG194672 DB	'*MSCH', 00H
	ORG $+2
$SG194673 DB	'C:\papa\MyGit\hyperion-zvector\io.c:249', 00H
$SG194676 DB	'C:\papa\MyGit\hyperion-zvector\io.c:258', 00H
$SG194677 DB	'*MSCH', 00H
	ORG $+2
$SG194678 DB	'C:\papa\MyGit\hyperion-zvector\io.c:260', 00H
$SG194683 DB	'C:\papa\MyGit\hyperion-zvector\io.c:267', 00H
$SG194684 DB	'*MSCH', 00H
	ORG $+2
$SG194685 DB	'C:\papa\MyGit\hyperion-zvector\io.c:269', 00H
$SG194688 DB	'C:\papa\MyGit\hyperion-zvector\io.c:330', 00H
$SG194731 DB	'C:\papa\MyGit\hyperion-zvector\io.c:348', 00H
$SG194735 DB	'C:\papa\MyGit\hyperion-zvector\io.c:352', 00H
$SG194736 DB	'RCHP', 00H
	ORG $+3
$SG194740 DB	'C:\papa\MyGit\hyperion-zvector\io.c:362', 00H
$SG194741 DB	'*RCHP', 00H
	ORG $+2
$SG194826 DB	'C:\papa\MyGit\hyperion-zvector\io.c:379', 00H
$SG194829 DB	'C:\papa\MyGit\hyperion-zvector\io.c:382', 00H
$SG194830 DB	'RSCH', 00H
	ORG $+3
$SG194833 DB	'C:\papa\MyGit\hyperion-zvector\io.c:388', 00H
$SG194834 DB	'RSCH (sie)', 00H
	ORG $+5
$SG194840 DB	'C:\papa\MyGit\hyperion-zvector\io.c:399', 00H
$SG194841 DB	'RSCH (dev)', 00H
	ORG $+5
$SG194845 DB	'C:\papa\MyGit\hyperion-zvector\io.c:409', 00H
$SG194846 DB	'*RSCH', 00H
	ORG $+2
$SG194848 DB	'C:\papa\MyGit\hyperion-zvector\io.c:411', 00H
$SG194849 DB	'*RSCH (sie)', 00H
	ORG $+4
$SG194853 DB	'C:\papa\MyGit\hyperion-zvector\io.c:420', 00H
$SG194854 DB	'*RSCH', 00H
	ORG $+2
$SG194886 DB	'C:\papa\MyGit\hyperion-zvector\io.c:436', 00H
$SG194890 DB	'C:\papa\MyGit\hyperion-zvector\io.c:440', 00H
$SG194929 DB	'C:\papa\MyGit\hyperion-zvector\io.c:459', 00H
$SG194934 DB	'C:\papa\MyGit\hyperion-zvector\io.c:467', 00H
$SG194935 DB	'SCHM', 00H
	ORG $+3
$SG195037 DB	'C:\papa\MyGit\hyperion-zvector\io.c:543', 00H
$SG195040 DB	'C:\papa\MyGit\hyperion-zvector\io.c:546', 00H
$SG195041 DB	'SSCH', 00H
	ORG $+3
$SG195044 DB	'C:\papa\MyGit\hyperion-zvector\io.c:552', 00H
$SG195045 DB	'SSCH (sie)', 00H
	ORG $+5
$SG195054 DB	'C:\papa\MyGit\hyperion-zvector\io.c:588', 00H
$SG195055 DB	'SSCH (dev)', 00H
	ORG $+5
$SG195059 DB	'C:\papa\MyGit\hyperion-zvector\io.c:599', 00H
$SG195060 DB	'*SSCH', 00H
	ORG $+2
$SG195062 DB	'C:\papa\MyGit\hyperion-zvector\io.c:601', 00H
$SG195063 DB	'*SSCH (sie)', 00H
	ORG $+4
$SG195068 DB	'C:\papa\MyGit\hyperion-zvector\io.c:627', 00H
$SG195069 DB	'*SSCH', 00H
	ORG $+2
$SG195110 DB	'C:\papa\MyGit\hyperion-zvector\io.c:664', 00H
$SG195114 DB	'C:\papa\MyGit\hyperion-zvector\io.c:668', 00H
$SG195115 DB	'STCPS', 00H
	ORG $+2
$SG195117 DB	'C:\papa\MyGit\hyperion-zvector\io.c:680', 00H
$SG195119 DB	'C:\papa\MyGit\hyperion-zvector\io.c:698', 00H
$SG195172 DB	'C:\papa\MyGit\hyperion-zvector\io.c:718', 00H
$SG195174 DB	'C:\papa\MyGit\hyperion-zvector\io.c:719', 00H
$SG195175 DB	'STCRW', 00H
	ORG $+2
$SG195180 DB	'C:\papa\MyGit\hyperion-zvector\io.c:731', 00H
$SG195181 DB	'STCRW crw', 00H
	ORG $+6
$SG195184 DB	'C:\papa\MyGit\hyperion-zvector\io.c:740', 00H
$SG195185 DB	'*STCRW', 00H
	ORG $+1
$SG195252 DB	'C:\papa\MyGit\hyperion-zvector\io.c:757', 00H
$SG195255 DB	'C:\papa\MyGit\hyperion-zvector\io.c:759', 00H
$SG195256 DB	'STSCH', 00H
	ORG $+2
$SG195258 DB	'C:\papa\MyGit\hyperion-zvector\io.c:760', 00H
$SG195259 DB	'STSCH (sie)', 00H
	ORG $+4
$SG195265 DB	'C:\papa\MyGit\hyperion-zvector\io.c:770', 00H
$SG195266 DB	'STSCH (dev)', 00H
	ORG $+4
$SG195269 DB	'C:\papa\MyGit\hyperion-zvector\io.c:775', 00H
$SG195270 DB	'*STSCH', 00H
	ORG $+1
$SG195272 DB	'C:\papa\MyGit\hyperion-zvector\io.c:789', 00H
$SG195275 DB	'C:\papa\MyGit\hyperion-zvector\io.c:796', 00H
$SG195339 DB	'C:\papa\MyGit\hyperion-zvector\io.c:827', 00H
$SG195344 DB	'C:\papa\MyGit\hyperion-zvector\io.c:835', 00H
$SG195350 DB	'C:\papa\MyGit\hyperion-zvector\io.c:850', 00H
$SG195351 DB	'C:\papa\MyGit\hyperion-zvector\io.c:858', 00H
$SG195363 DB	'C:\papa\MyGit\hyperion-zvector\io.c:922', 00H
$SG195364 DB	'*TPI', 00H
	ORG $+3
$SG195456 DB	'C:\papa\MyGit\hyperion-zvector\io.c:940', 00H
$SG195459 DB	'C:\papa\MyGit\hyperion-zvector\io.c:942', 00H
$SG195460 DB	'TSCH', 00H
	ORG $+3
$SG195463 DB	'C:\papa\MyGit\hyperion-zvector\io.c:948', 00H
$SG195464 DB	'TSCH (sie)', 00H
	ORG $+5
$SG195471 DB	'C:\papa\MyGit\hyperion-zvector\io.c:961', 00H
$SG195472 DB	'TSCH (dev)', 00H
	ORG $+5
$SG195476 DB	'C:\papa\MyGit\hyperion-zvector\io.c:971', 00H
$SG195477 DB	'*TSCH', 00H
	ORG $+2
$SG195479 DB	'C:\papa\MyGit\hyperion-zvector\io.c:973', 00H
$SG195480 DB	'*TSCH (sie)', 00H
	ORG $+4
$SG195484 DB	'C:\papa\MyGit\hyperion-zvector\io.c:997', 00H
$SG195485 DB	'*TSCH', 00H
	ORG $+2
$SG195570 DB	'C:\papa\MyGit\hyperion-zvector\io.c:1013', 00H
	ORG $+7
$SG195573 DB	'C:\papa\MyGit\hyperion-zvector\io.c:1016', 00H
	ORG $+3
$SG195574 DB	'XSCH', 00H
	ORG $+7
$SG195577 DB	'C:\papa\MyGit\hyperion-zvector\io.c:1022', 00H
	ORG $+7
$SG195578 DB	'XSCH (sie)', 00H
	ORG $+5
$SG195584 DB	'C:\papa\MyGit\hyperion-zvector\io.c:1033', 00H
	ORG $+7
$SG195585 DB	'XSCH (dev)', 00H
	ORG $+5
$SG195589 DB	'C:\papa\MyGit\hyperion-zvector\io.c:1043', 00H
	ORG $+3
$SG195590 DB	'*XSCH', 00H
	ORG $+6
$SG195592 DB	'C:\papa\MyGit\hyperion-zvector\io.c:1045', 00H
	ORG $+7
$SG195593 DB	'*XSCH (sie)', 00H
	ORG $+4
$SG195597 DB	'C:\papa\MyGit\hyperion-zvector\io.c:1056', 00H
	ORG $+3
$SG195598 DB	'*XSCH', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_validate_operand DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8 DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore4 DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	0163H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8_full DD 032919H
	DD	07016c21aH
	DD	06015H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore4_full DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_ptr_to_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_ptr_to_4K_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_validate_operand DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore8 DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore4 DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0158H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore8_full DD 032819H
	DD	07015c219H
	DD	06014H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore4_full DD 031801H
	DD	07014a218H
	DD	06013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_ptr_to_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_ptr_to_4K_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_test_subchannel
	DD	01bH
	DD	06d1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_store_subchannel
	DD	01dH
	DD	0550H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_store_channel_path_status
	DD	01cH
	DD	03daH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_start_subchannel
	DD	01bH
	DD	0743H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_modify_subchannel
	DD	01bH
	DD	0a79H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_test_subchannel
	DD	01bH
	DD	05f9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_store_subchannel
	DD	01dH
	DD	04a1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_store_channel_path_status
	DD	01cH
	DD	0353H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_start_subchannel
	DD	01bH
	DD	068bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_modify_subchannel
	DD	01bH
	DD	098bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_start_io
	DD	01cH
	DD	053dH
voltbl	ENDS
xdata	SEGMENT
$unwind$s370_connect_channel_set DD 010e01H
	DD	0e20eH
$unwind$s370_disconnect_channel_set DD 010e01H
	DD	0a20eH
$unwind$s370_start_io DD 032419H
	DD	0140112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s370_test_io DD 010e01H
	DD	0c20eH
$unwind$s370_halt_io DD 010e01H
	DD	0c20eH
$unwind$s370_test_channel DD 010e01H
	DD	0c20eH
$unwind$s370_store_channel_id DD 010e01H
	DD	0a20eH
$unwind$wakeup_cpu DD 010e01H
	DD	0420eH
$unwind$wakeup_cpu_mask DD 010e01H
	DD	0a20eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$s390_cancel_subchannel DD 010e01H
	DD	0c20eH
$unwind$s390_clear_subchannel DD 010e01H
	DD	0c20eH
$unwind$s390_halt_subchannel DD 010e01H
	DD	0c20eH
$unwind$s390_modify_subchannel DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s390_resume_subchannel DD 010e01H
	DD	0c20eH
$unwind$s390_set_address_limit DD 010e01H
	DD	0a20eH
$unwind$s390_set_channel_monitor DD 010e01H
	DD	0c20eH
$unwind$s390_reset_channel_path DD 010e01H
	DD	0c20eH
$unwind$s390_start_subchannel DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$s390_store_channel_path_status DD 032419H
	DD	0120112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$s390_store_channel_report_word DD 010e01H
	DD	0c20eH
$unwind$s390_store_subchannel DD 042519H
	DD	0150113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$s390_test_pending_interruption DD 021101H
	DD	0130111H
$unwind$s390_test_subchannel DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$z900_cancel_subchannel DD 010e01H
	DD	0c20eH
$unwind$z900_clear_subchannel DD 010e01H
	DD	0c20eH
$unwind$z900_halt_subchannel DD 010e01H
	DD	0c20eH
$unwind$z900_modify_subchannel DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_resume_subchannel DD 010e01H
	DD	0c20eH
$unwind$z900_set_address_limit DD 010e01H
	DD	0a20eH
$unwind$z900_set_channel_monitor DD 010e01H
	DD	0c20eH
$unwind$z900_reset_channel_path DD 010e01H
	DD	0c20eH
$unwind$z900_start_subchannel DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$z900_store_channel_path_status DD 032419H
	DD	0140112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_store_channel_report_word DD 010e01H
	DD	0c20eH
$unwind$z900_store_subchannel DD 042519H
	DD	0150113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_test_pending_interruption DD 021101H
	DD	0130111H
$unwind$z900_test_subchannel DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_validate_operand
_TEXT	SEGMENT
tv81 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
z900_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00028	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  0004a	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00050	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00055	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00059	3b c1		 cmp	 eax, ecx
  0005b	7e 0a		 jle	 SHORT $LN6@z900_valid
  0005d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00065	eb 08		 jmp	 SHORT $LN7@z900_valid
$LN6@z900_valid:
  00067	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN7@z900_valid:
  0006f	83 7c 24 30 00	 cmp	 DWORD PTR tv81[rsp], 0
  00074	74 48		 je	 SHORT $LN2@z900_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00076	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00092	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0009b	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0009f	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  000a3	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000a7	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000ac	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000b1	ba 01 00 00 00	 mov	 edx, 1
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 z900_maddr_l
$LN2@z900_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002c	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00031	2b d1		 sub	 edx, ecx
  00033	8b ca		 mov	 ecx, edx
  00035	3b c1		 cmp	 eax, ecx
  00037	7f 0a		 jg	 SHORT $LN7@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN8@z900_vfetc
$LN7@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00050	74 63		 je	 SHORT $LN2@z900_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00052	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 98		 cdqe
  0005b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00098	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	48 98		 cdqe
  000a1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a6	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	f3 a4		 rep movsb

; 640  :     }

  000b0	e9 01 01 00 00	 jmp	 $LN3@z900_vfetc
$LN2@z900_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000bd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000c3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c8	48 2b c8	 sub	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000e3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000ef	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f7	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0010a	e8 00 00 00 00	 call	 z900_maddr_l
  0010f	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00114	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00119	ff c0		 inc	 eax
  0011b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0011f	48 98		 cdqe
  00121	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00126	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  0012e	48 03 d1	 add	 rdx, rcx
  00131	48 8b ca	 mov	 rcx, rdx
  00134	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00143	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0014b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0014f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00153	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0015b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00163	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0016b	48 8b d0	 mov	 rdx, rax
  0016e	e8 00 00 00 00	 call	 z900_maddr_l
  00173	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  00178	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0017d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00182	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  00187	48 8b c8	 mov	 rcx, rax
  0018a	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0018c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00191	ff c0		 inc	 eax
  00193	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00197	48 98		 cdqe
  00199	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0019e	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001a3	48 03 d1	 add	 rdx, rcx
  001a6	48 8b ca	 mov	 rcx, rdx
  001a9	48 8b f9	 mov	 rdi, rcx
  001ac	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	f3 a4		 rep movsb
$LN3@z900_vfetc:

; 649  :     }
; 650  : }

  001b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	c3		 ret	 0
z900_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore8 PROC					; COMDAT

; 577  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 578  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 579  :     /* Check alignement. If aligned then we are guaranteed
; 580  :        not to cross a page boundary */
; 581  :     if (likely(!((VADR_L)addr & 0x07)))
; 582  :     {
; 583  :         /* Most common case : Aligned */
; 584  :         U64 *mn;
; 585  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );
; 586  :         if (regs->cpubit == regs->sysblk->started_mask)
; 587  :             *mn = CSWAP64( value );
; 588  :         else
; 589  :             STORE_DW( mn, value );
; 590  :     }
; 591  :     else
; 592  : #endif
; 593  :     {
; 594  :         /* We're not aligned. So we have to check whether we are
; 595  :            crossing a page boundary. This cannot be the same
; 596  :            code as above because casting U64* to a non aligned
; 597  :            pointer may break on those architectures mandating
; 598  :            strict alignement */
; 599  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00023	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00029	77 0a		 ja	 SHORT $LN7@z900_vstor
  0002b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00033	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00035	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN8@z900_vstor:
  0003d	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00042	74 4c		 je	 SHORT $LN2@z900_vstor

; 600  :         {
; 601  :             /* Non aligned but not crossing page boundary */
; 602  :             BYTE *mn;
; 603  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00044	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00049	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0004d	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00051	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00059	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0005e	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00063	ba 08 00 00 00	 mov	 edx, 8
  00068	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  0006d	e8 00 00 00 00	 call	 z900_maddr_l
  00072	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 604  :             /* invoking STORE_DW ensures endianness correctness */
; 605  :             STORE_DW( mn, value );

  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  0007c	e8 00 00 00 00	 call	 _byteswap_uint64
  00081	48 8b d0	 mov	 rdx, rax
  00084	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00089	e8 00 00 00 00	 call	 store_dw_noswap

; 606  :         }

  0008e	eb 19		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 607  :         else
; 608  :             /* Crossing page boundary */
; 609  :             ARCH_DEP( vstore8_full )( value, addr, arn, regs );

  00090	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  0009a	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  000a4	e8 00 00 00 00	 call	 z900_vstore8_full
$LN3@z900_vstor:

; 610  :     }
; 611  :     ITIMER_UPDATE( addr, 8-1, regs );
; 612  : }

  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
z900_vstore8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore4 PROC					; COMDAT

; 559  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001c	48 83 e0 03	 and	 rax, 3
  00020	48 85 c0	 test	 rax, rax
  00023	75 0a		 jne	 SHORT $LN6@z900_vstor
  00025	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  0002d	eb 08		 jmp	 SHORT $LN7@z900_vstor
$LN6@z900_vstor:
  0002f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN7@z900_vstor:
  00037	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  0003c	74 0a		 je	 SHORT $LN10@z900_vstor
  0003e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00046	eb 08		 jmp	 SHORT $LN11@z900_vstor
$LN10@z900_vstor:
  00048	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN11@z900_vstor:
  00050	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00055	75 13		 jne	 SHORT $LN4@z900_vstor
  00057	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0005c	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00062	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00068	77 4a		 ja	 SHORT $LN2@z900_vstor
$LN4@z900_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00073	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00077	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007f	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00084	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00089	ba 04 00 00 00	 mov	 edx, 4
  0008e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00093	e8 00 00 00 00	 call	 z900_maddr_l
  00098	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  0009d	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000a1	e8 00 00 00 00	 call	 _byteswap_ulong
  000a6	8b d0		 mov	 edx, eax
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ad	e8 00 00 00 00	 call	 store_fw_noswap

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );
; 568  :     }

  000b2	eb 18		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  000b4	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000b9	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000be	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  000c3	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000c7	e8 00 00 00 00	 call	 z900_vstore4_full
$LN3@z900_vstor:

; 571  : }

  000cc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d0	c3		 ret	 0
z900_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8_full
_TEXT	SEGMENT
len$ = 48
sk$ = 56
main1$ = 64
main2$ = 72
temp$ = 80
__$ArrayPad$ = 88
value$ = 128
addr$ = 136
arn$ = 144
regs$ = 152
z900_vstore8_full PROC					; COMDAT

; 369  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 371  : BYTE   *sk;                             /* Storage key addresses     */
; 372  : int     len;                            /* Length to end of page     */
; 373  : BYTE    temp[8];                        /* Copied value              */
; 374  : 
; 375  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00029	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00031	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00037	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0003c	48 2b c8	 sub	 rcx, rax
  0003f	48 8b c1	 mov	 rax, rcx
  00042	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 376  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00046	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0004b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00057	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0005b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00063	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0006b	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00073	48 8b d0	 mov	 rdx, rax
  00076	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0007e	e8 00 00 00 00	 call	 z900_maddr_l
  00083	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 377  :     sk = regs->dat.storkey;

  00088	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00097	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 378  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8-len, arn, regs,

  0009c	b8 08 00 00 00	 mov	 eax, 8
  000a1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000a5	48 98		 cdqe
  000a7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000ac	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000b4	48 03 d1	 add	 rdx, rcx
  000b7	48 8b ca	 mov	 rcx, rdx
  000ba	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000c9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000d1	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000d5	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000d9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000e1	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e9	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f1	48 8b d0	 mov	 rdx, rax
  000f4	e8 00 00 00 00	 call	 z900_maddr_l
  000f9	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 379  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 380  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000fe	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00103	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00106	83 c8 06	 or	 eax, 6
  00109	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  0010e	88 01		 mov	 BYTE PTR [rcx], al

; 381  :     STORE_DW( temp, value );

  00110	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  00118	e8 00 00 00 00	 call	 _byteswap_uint64
  0011d	48 8b d0	 mov	 rdx, rax
  00120	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00125	e8 00 00 00 00	 call	 store_dw_noswap

; 382  :     memcpy( main1, temp,       len );

  0012a	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0012f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00134	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00139	48 8b f1	 mov	 rsi, rcx
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	f3 a4		 rep movsb

; 383  :     memcpy( main2, temp+len, 8-len );

  00141	b8 08 00 00 00	 mov	 eax, 8
  00146	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0014a	48 98		 cdqe
  0014c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00151	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00156	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0015b	48 8b f1	 mov	 rsi, rcx
  0015e	48 8b c8	 mov	 rcx, rax
  00161	f3 a4		 rep movsb

; 384  : }

  00163	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00168	48 33 cc	 xor	 rcx, rsp
  0016b	e8 00 00 00 00	 call	 __security_check_cookie
  00170	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00174	5f		 pop	 rdi
  00175	5e		 pop	 rsi
  00176	c3		 ret	 0
z900_vstore8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
z900_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00019	48 8b 44 24 78	 mov	 rax, QWORD PTR addr$[rsp]
  0001e	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00024	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00029	48 2b c8	 sub	 rcx, rax
  0002c	48 8b c1	 mov	 rax, rcx
  0002f	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00033	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00038	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00040	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00044	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00048	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00050	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00058	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00060	48 8b d0	 mov	 rdx, rax
  00063	48 8b 4c 24 78	 mov	 rcx, QWORD PTR addr$[rsp]
  00068	e8 00 00 00 00	 call	 z900_maddr_l
  0006d	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  00072	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00081	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00086	b8 04 00 00 00	 mov	 eax, 4
  0008b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0008f	48 98		 cdqe
  00091	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00096	48 8b 54 24 78	 mov	 rdx, QWORD PTR addr$[rsp]
  0009b	48 03 d1	 add	 rdx, rcx
  0009e	48 8b ca	 mov	 rcx, rdx
  000a1	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a9	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000b0	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000c0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000c8	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000d0	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000d8	48 8b d0	 mov	 rdx, rax
  000db	e8 00 00 00 00	 call	 z900_maddr_l
  000e0	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000e5	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000ea	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ed	83 c8 06	 or	 eax, 6
  000f0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000f5	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000f7	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000fb	e8 00 00 00 00	 call	 _byteswap_ulong
  00100	8b d0		 mov	 edx, eax
  00102	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00107	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  0010c	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00111	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00116	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  0011b	48 8b f1	 mov	 rsi, rcx
  0011e	48 8b c8	 mov	 rcx, rax
  00121	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00123	b8 04 00 00 00	 mov	 eax, 4
  00128	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0012c	48 98		 cdqe
  0012e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00133	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00138	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0013d	48 8b f1	 mov	 rsi, rcx
  00140	48 8b c8	 mov	 rcx, rax
  00143	f3 a4		 rep movsb

; 350  : }

  00145	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00149	5f		 pop	 rdi
  0014a	5e		 pop	 rsi
  0014b	c3		 ret	 0
z900_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck
_TEXT	SEGMENT
tv79 = 32
regs$ = 64
b1$ = 72
z900_per3_zero_xcheck PROC				; COMDAT

; 754  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 755  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 756  :     if (b1 && GR_A( b1, regs ) == 0)

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  00012	74 53		 je	 SHORT $LN2@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 19		 je	 SHORT $LN4@z900_per3_
  00026	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00030	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00038	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  0003d	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  0003f	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00050	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN5@z900_per3_:
  00055	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  0005b	75 0a		 jne	 SHORT $LN2@z900_per3_

; 757  :         ARCH_DEP( per3_zero )( regs );

  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 758  : #else
; 759  :     UNREFERENCED( regs );
; 760  :     UNREFERENCED( b1 );
; 761  : #endif
; 762  : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
z900_per3_zero_xcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_ptr_to_storekey
_TEXT	SEGMENT
abs$ = 48
z900_get_ptr_to_storekey PROC				; COMDAT

; 308  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 309  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 310  :     return ARCH_DEP( get_ptr_to_2K_storekey )( abs );
; 311  : #else
; 312  :     return ARCH_DEP( get_ptr_to_4K_storekey )( abs );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0000e	e8 00 00 00 00	 call	 z900_get_ptr_to_4K_storekey

; 313  : #endif
; 314  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
z900_get_ptr_to_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_ptr_to_4K_storekey
_TEXT	SEGMENT
abs$ = 48
z900_get_ptr_to_4K_storekey PROC			; COMDAT

; 238  :   inline BYTE* ARCH_DEP( get_ptr_to_4K_storekey ) (              U64 abs            ) { return           _get_storekey_ptr     (      abs, 4 );                         }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 04		 mov	 dl, 4
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 _get_storekey_ptr
  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
z900_get_ptr_to_4K_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
b2$ = 72
dev$ = 80
temp$1 = 88
cc$ = 92
irb$ = 96
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
z900_test_subchannel PROC

; 930  : {

$LN56:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 931  : int     b2;                             /* Effective addr base       */
; 932  : VADR    effective_addr2;                /* Effective address         */
; 933  : DEVBLK* dev;                            /* -> device block           */
; 934  : IRB     irb;                            /* Interruption response blk */
; 935  : int     cc;                             /* Condition Code            */
; 936  : 
; 937  :     S( inst, regs, b2, effective_addr2 );

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 58	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	8b c0		 mov	 eax, eax
  00046	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004b	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  0004f	c1 e8 0c	 shr	 eax, 12
  00052	83 e0 0f	 and	 eax, 15
  00055	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  00059	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005e	74 44		 je	 SHORT $LN35@z900_test_
  00060	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  00065	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007a	48 03 c8	 add	 rcx, rax
  0007d	48 8b c1	 mov	 rax, rcx
  00080	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00085	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00094	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00099	48 23 c8	 and	 rcx, rax
  0009c	48 8b c1	 mov	 rax, rcx
  0009f	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN35@z900_test_:
$LN4@z900_test_:
  000a4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b0	48 83 c0 04	 add	 rax, 4
  000b4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bc	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c0	33 c0		 xor	 eax, eax
  000c2	83 f8 04	 cmp	 eax, 4
  000c5	74 0f		 je	 SHORT $LN36@z900_test_
  000c7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cf	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN36@z900_test_:
  000d6	33 c0		 xor	 eax, eax
  000d8	85 c0		 test	 eax, eax
  000da	75 c8		 jne	 SHORT $LN4@z900_test_

; 938  :     PER_ZEROADDR_XCHECK( regs, b2 );

  000dc	8b 54 24 48	 mov	 edx, DWORD PTR b2$[rsp]
  000e0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_test_:

; 939  : 
; 940  :     TXF_INSTR_CHECK( regs );

  000ed	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000fc	85 c0		 test	 eax, eax
  000fe	74 3f		 je	 SHORT $LN37@z900_test_
  00100	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00108	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0010e	0f ba e8 0c	 bts	 eax, 12
  00112	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011a	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00120	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195456
  00127	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0012d	ba 02 00 00 00	 mov	 edx, 2
  00132	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013a	e8 00 00 00 00	 call	 z900_abort_transaction
$LN37@z900_test_:
  0013f	33 c0		 xor	 eax, eax
  00141	85 c0		 test	 eax, eax
  00143	75 a8		 jne	 SHORT $LN7@z900_test_

; 941  :     PRIV_CHECK( regs );

  00145	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014d	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00151	83 e0 01	 and	 eax, 1
  00154	85 c0		 test	 eax, eax
  00156	74 1b		 je	 SHORT $LN38@z900_test_
  00158	ba 02 00 00 00	 mov	 edx, 2
  0015d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN38@z900_test_:
$LN10@z900_test_:

; 942  :     PTIO( IO, "TSCH" );

  00173	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0017a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017d	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00183	48 85 c0	 test	 rax, rax
  00186	74 6b		 je	 SHORT $LN39@z900_test_
  00188	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00190	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00196	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0019b	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001a0	48 23 d1	 and	 rdx, rcx
  001a3	48 8b ca	 mov	 rcx, rdx
  001a6	8b c9		 mov	 ecx, ecx
  001a8	ba 08 00 00 00	 mov	 edx, 8
  001ad	48 6b d2 01	 imul	 rdx, rdx, 1
  001b1	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001b9	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001c1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001ca	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195459
  001d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001db	44 8b c9	 mov	 r9d, ecx
  001de	44 8b c2	 mov	 r8d, edx
  001e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195460
  001e8	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@z900_test_:
  001f3	33 c0		 xor	 eax, eax
  001f5	85 c0		 test	 eax, eax
  001f7	0f 85 76 ff ff
	ff		 jne	 $LN10@z900_test_

; 943  : 
; 944  : #if defined( _FEATURE_IO_ASSIST )
; 945  :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  001fd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00205	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0020b	d1 e8		 shr	 eax, 1
  0020d	83 e0 01	 and	 eax, 1
  00210	85 c0		 test	 eax, eax
  00212	0f 84 06 01 00
	00		 je	 $LN40@z900_test_
  00218	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00220	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00227	b9 01 00 00 00	 mov	 ecx, 1
  0022c	48 6b c9 00	 imul	 rcx, rcx, 0
  00230	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00235	83 e0 04	 and	 eax, 4
  00238	85 c0		 test	 eax, eax
  0023a	0f 85 de 00 00
	00		 jne	 $LN40@z900_test_
  00240	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00248	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0024e	c1 e8 02	 shr	 eax, 2
  00251	83 e0 01	 and	 eax, 1
  00254	85 c0		 test	 eax, eax
  00256	0f 85 c2 00 00
	00		 jne	 $LN40@z900_test_
$LN13@z900_test_:

; 946  : #endif
; 947  :     {
; 948  :         PTIO( IO, "TSCH (sie)" );

  0025c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00263	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00266	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0026c	48 85 c0	 test	 rax, rax
  0026f	74 6b		 je	 SHORT $LN41@z900_test_
  00271	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00279	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0027f	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00284	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00289	48 23 d1	 and	 rdx, rcx
  0028c	48 8b ca	 mov	 rcx, rdx
  0028f	8b c9		 mov	 ecx, ecx
  00291	ba 08 00 00 00	 mov	 edx, 8
  00296	48 6b d2 01	 imul	 rdx, rdx, 1
  0029a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002a2	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  002aa	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002b3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195463
  002bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c4	44 8b c9	 mov	 r9d, ecx
  002c7	44 8b c2	 mov	 r8d, edx
  002ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195464
  002d1	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  002d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN41@z900_test_:
  002dc	33 c0		 xor	 eax, eax
  002de	85 c0		 test	 eax, eax
  002e0	0f 85 76 ff ff
	ff		 jne	 $LN13@z900_test_
$LN16@z900_test_:

; 949  :         SIE_INTERCEPT( regs );

  002e6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ee	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  002f4	d1 e8		 shr	 eax, 1
  002f6	83 e0 01	 and	 eax, 1
  002f9	85 c0		 test	 eax, eax
  002fb	74 1b		 je	 SHORT $LN42@z900_test_
  002fd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00305	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0030b	ba fc ff ff ff	 mov	 edx, -4
  00310	48 8b c8	 mov	 rcx, rax
  00313	e8 00 00 00 00	 call	 longjmp
$LN42@z900_test_:
  00318	33 c0		 xor	 eax, eax
  0031a	85 c0		 test	 eax, eax
  0031c	75 c8		 jne	 SHORT $LN16@z900_test_
$LN40@z900_test_:

; 950  :     }
; 951  : 
; 952  :     FW_CHECK( effective_addr2, regs );

  0031e	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00323	48 83 e0 03	 and	 rax, 3
  00327	48 85 c0	 test	 rax, rax
  0032a	74 1b		 je	 SHORT $LN43@z900_test_
  0032c	ba 06 00 00 00	 mov	 edx, 6
  00331	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00339	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00341	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN43@z900_test_:

; 953  : 
; 954  :     /* Program check if the ssid including lcss is invalid */
; 955  :     SSID_CHECK( regs );

  00347	b8 08 00 00 00	 mov	 eax, 8
  0034c	48 6b c0 01	 imul	 rax, rax, 1
  00350	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00358	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  00360	83 e0 01	 and	 eax, 1
  00363	85 c0		 test	 eax, eax
  00365	74 1e		 je	 SHORT $LN45@z900_test_
  00367	b8 08 00 00 00	 mov	 eax, 8
  0036c	48 6b c0 01	 imul	 rax, rax, 1
  00370	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00378	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  00380	83 f8 03	 cmp	 eax, 3
  00383	7e 1b		 jle	 SHORT $LN44@z900_test_
$LN45@z900_test_:
  00385	ba 15 00 00 00	 mov	 edx, 21
  0038a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00392	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN44@z900_test_:

; 956  : 
; 957  :     /* Locate the device block for this subchannel */
; 958  :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  003a0	b8 08 00 00 00	 mov	 eax, 8
  003a5	48 6b c0 01	 imul	 rax, rax, 1
  003a9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b1	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  003b8	e8 00 00 00 00	 call	 find_device_by_subchan
  003bd	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax

; 959  : 
; 960  :     if (dev)

  003c2	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  003c8	74 5a		 je	 SHORT $LN46@z900_test_
$LN19@z900_test_:

; 961  :         PTT( PTT_CL_IO, "TSCH (dev)", dev->devnum, 0, 0 );

  003ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003d1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003d4	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  003da	48 85 c0	 test	 rax, rax
  003dd	74 3f		 je	 SHORT $LN47@z900_test_
  003df	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  003e4	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003e8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003f1	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  003fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195471
  00401	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00406	45 33 c9	 xor	 r9d, r9d
  00409	44 8b c0	 mov	 r8d, eax
  0040c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195472
  00413	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00418	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN47@z900_test_:
  0041e	33 c0		 xor	 eax, eax
  00420	85 c0		 test	 eax, eax
  00422	75 a6		 jne	 SHORT $LN19@z900_test_
$LN46@z900_test_:

; 962  : 
; 963  :     /* Condition code 3 if subchannel does not exist,
; 964  :        is not valid, or is not enabled */
; 965  :     if (0
; 966  :         || !dev
; 967  :         || !(dev->pmcw.flag5 & PMCW5_V)
; 968  :         || !(dev->pmcw.flag5 & PMCW5_E)

  00424	33 c0		 xor	 eax, eax
  00426	85 c0		 test	 eax, eax
  00428	75 34		 jne	 SHORT $LN49@z900_test_
  0042a	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00430	74 2c		 je	 SHORT $LN49@z900_test_
  00432	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00437	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0043e	83 e0 01	 and	 eax, 1
  00441	85 c0		 test	 eax, eax
  00443	74 19		 je	 SHORT $LN49@z900_test_
  00445	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0044a	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00451	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00456	85 c0		 test	 eax, eax
  00458	0f 85 59 01 00
	00		 jne	 $LN48@z900_test_
$LN49@z900_test_:
$LN22@z900_test_:

; 969  :     )
; 970  :     {
; 971  :         PTIO( ERR, "*TSCH" );

  0045e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00465	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00468	48 83 e0 10	 and	 rax, 16
  0046c	48 85 c0	 test	 rax, rax
  0046f	74 6b		 je	 SHORT $LN50@z900_test_
  00471	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00479	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0047f	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00484	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00489	48 23 d1	 and	 rdx, rcx
  0048c	48 8b ca	 mov	 rcx, rdx
  0048f	8b c9		 mov	 ecx, ecx
  00491	ba 08 00 00 00	 mov	 edx, 8
  00496	48 6b d2 01	 imul	 rdx, rdx, 1
  0049a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004a2	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  004aa	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004b3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195476
  004bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c4	44 8b c9	 mov	 r9d, ecx
  004c7	44 8b c2	 mov	 r8d, edx
  004ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195477
  004d1	b9 10 00 00 00	 mov	 ecx, 16
  004d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN50@z900_test_:
  004dc	33 c0		 xor	 eax, eax
  004de	85 c0		 test	 eax, eax
  004e0	0f 85 78 ff ff
	ff		 jne	 $LN22@z900_test_
$LN25@z900_test_:

; 972  : #if defined( _FEATURE_IO_ASSIST )
; 973  :         PTIO( ERR, "*TSCH (sie)" );

  004e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004ed	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004f0	48 83 e0 10	 and	 rax, 16
  004f4	48 85 c0	 test	 rax, rax
  004f7	74 6b		 je	 SHORT $LN51@z900_test_
  004f9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00501	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00507	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0050c	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00511	48 23 d1	 and	 rdx, rcx
  00514	48 8b ca	 mov	 rcx, rdx
  00517	8b c9		 mov	 ecx, ecx
  00519	ba 08 00 00 00	 mov	 edx, 8
  0051e	48 6b d2 01	 imul	 rdx, rdx, 1
  00522	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0052a	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00532	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0053b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00540	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195479
  00547	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0054c	44 8b c9	 mov	 r9d, ecx
  0054f	44 8b c2	 mov	 r8d, edx
  00552	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195480
  00559	b9 10 00 00 00	 mov	 ecx, 16
  0055e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN51@z900_test_:
  00564	33 c0		 xor	 eax, eax
  00566	85 c0		 test	 eax, eax
  00568	0f 85 78 ff ff
	ff		 jne	 $LN25@z900_test_
$LN28@z900_test_:

; 974  :         SIE_INTERCEPT( regs );

  0056e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00576	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0057c	d1 e8		 shr	 eax, 1
  0057e	83 e0 01	 and	 eax, 1
  00581	85 c0		 test	 eax, eax
  00583	74 1b		 je	 SHORT $LN52@z900_test_
  00585	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058d	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00593	ba fc ff ff ff	 mov	 edx, -4
  00598	48 8b c8	 mov	 rcx, rax
  0059b	e8 00 00 00 00	 call	 longjmp
$LN52@z900_test_:
  005a0	33 c0		 xor	 eax, eax
  005a2	85 c0		 test	 eax, eax
  005a4	75 c8		 jne	 SHORT $LN28@z900_test_

; 975  : #endif
; 976  :         regs->psw.cc = 3;

  005a6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ae	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 977  :         return;

  005b2	e9 1a 01 00 00	 jmp	 $LN1@z900_test_
$LN48@z900_test_:

; 978  :     }
; 979  : 
; 980  :     /* validate operand before taking any action */
; 981  :     ARCH_DEP( validate_operand )( effective_addr2, b2, sizeof( IRB ) - 1,

  005b7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005c4	41 b9 01 00 00
	00		 mov	 r9d, 1
  005ca	41 b8 3f 00 00
	00		 mov	 r8d, 63			; 0000003fH
  005d0	8b 54 24 48	 mov	 edx, DWORD PTR b2$[rsp]
  005d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  005d9	e8 00 00 00 00	 call	 z900_validate_operand

; 982  :                                   ACCTYPE_WRITE_SKP, regs );
; 983  : 
; 984  :     /* Perform serialization and checkpoint-synchronization */
; 985  :     PERFORM_SERIALIZATION( regs );

  005de	0f ae f0	 mfence
$LN31@z900_test_:

; 986  :     PERFORM_CHKPT_SYNC( regs );

  005e1	33 c0		 xor	 eax, eax
  005e3	85 c0		 test	 eax, eax
  005e5	75 fa		 jne	 SHORT $LN31@z900_test_

; 987  : 
; 988  :     /* Test and clear pending status, set condition code */
; 989  :     cc = test_subchan( regs, dev, &irb );

  005e7	4c 8d 44 24 60	 lea	 r8, QWORD PTR irb$[rsp]
  005ec	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  005f1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f9	e8 00 00 00 00	 call	 test_subchan
  005fe	89 44 24 5c	 mov	 DWORD PTR cc$[rsp], eax

; 990  : 
; 991  :     /* Store the interruption response block */
; 992  :     ARCH_DEP( vstorec )( &irb, sizeof(IRB)-1, effective_addr2, b2, regs );

  00602	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0060a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0060f	44 8b 4c 24 48	 mov	 r9d, DWORD PTR b2$[rsp]
  00614	4c 8b 44 24 40	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  00619	b2 3f		 mov	 dl, 63			; 0000003fH
  0061b	48 8d 4c 24 60	 lea	 rcx, QWORD PTR irb$[rsp]
  00620	e8 00 00 00 00	 call	 z900_vstorec

; 993  : 
; 994  :     regs->psw.cc = cc;

  00625	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062d	0f b6 4c 24 5c	 movzx	 ecx, BYTE PTR cc$[rsp]
  00632	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 995  : 
; 996  :     if (regs->psw.cc != 0)

  00635	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0063d	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00641	85 c0		 test	 eax, eax
  00643	0f 84 88 00 00
	00		 je	 $LN53@z900_test_
$LN34@z900_test_:

; 997  :         PTIO( ERR, "*TSCH" );

  00649	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00650	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00653	48 83 e0 10	 and	 rax, 16
  00657	48 85 c0	 test	 rax, rax
  0065a	74 6b		 je	 SHORT $LN54@z900_test_
  0065c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00664	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0066a	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0066f	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00674	48 23 d1	 and	 rdx, rcx
  00677	48 8b ca	 mov	 rcx, rdx
  0067a	8b c9		 mov	 ecx, ecx
  0067c	ba 08 00 00 00	 mov	 edx, 8
  00681	48 6b d2 01	 imul	 rdx, rdx, 1
  00685	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0068d	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00695	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0069e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195484
  006aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006af	44 8b c9	 mov	 r9d, ecx
  006b2	44 8b c2	 mov	 r8d, edx
  006b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195485
  006bc	b9 10 00 00 00	 mov	 ecx, 16
  006c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN54@z900_test_:
  006c7	33 c0		 xor	 eax, eax
  006c9	85 c0		 test	 eax, eax
  006cb	0f 85 78 ff ff
	ff		 jne	 $LN34@z900_test_
$LN53@z900_test_:
$LN1@z900_test_:
$LN55@z900_test_:

; 998  : }

  006d1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006d9	48 33 cc	 xor	 rcx, rsp
  006dc	e8 00 00 00 00	 call	 __security_check_cookie
  006e1	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  006e8	c3		 ret	 0
z900_test_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
icode$ = 64
effective_addr2$ = 72
b2$ = 80
temp$1 = 84
ioid$ = 88
ioparm$ = 92
tv281 = 96
pfx$ = 104
psa$ = 112
iointid$ = 120
dreg$ = 128
dev$ = 136
inst$ = 160
regs$ = 168
z900_test_pending_interruption PROC

; 813  : {

$LN51:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 814  : int     b2;                             /* Effective addr base       */
; 815  : VADR    effective_addr2;                /* Effective address         */
; 816  : PSA    *psa;                            /* -> Prefixed storage area  */
; 817  : U64     dreg;                           /* Double register work area */
; 818  : U32     ioid;                           /* I/O interruption address  */
; 819  : U32     ioparm;                         /* I/O interruption parameter*/
; 820  : U32     iointid;                        /* I/O interruption ident    */
; 821  : int     icode;                          /* Intercept code            */
; 822  : RADR    pfx;                            /* Prefix                    */
; 823  : DEVBLK *dev;                            /* dev presenting interrupt  */
; 824  : 
; 825  :     S( inst, regs, b2, effective_addr2 );

  00011	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 54	 mov	 DWORD PTR temp$1[rsp], eax
  00029	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  0002d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00032	8b c0		 mov	 eax, eax
  00034	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00039	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  0003d	c1 e8 0c	 shr	 eax, 12
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00047	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  0004c	74 44		 je	 SHORT $LN26@z900_test_
  0004e	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  00053	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00063	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00068	48 03 c8	 add	 rcx, rax
  0006b	48 8b c1	 mov	 rax, rcx
  0006e	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00073	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00082	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00087	48 23 c8	 and	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN26@z900_test_:
$LN4@z900_test_:
  00092	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0009e	48 83 c0 04	 add	 rax, 4
  000a2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000aa	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000ae	33 c0		 xor	 eax, eax
  000b0	83 f8 04	 cmp	 eax, 4
  000b3	74 0f		 je	 SHORT $LN27@z900_test_
  000b5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN27@z900_test_:
  000c4	33 c0		 xor	 eax, eax
  000c6	85 c0		 test	 eax, eax
  000c8	75 c8		 jne	 SHORT $LN4@z900_test_
$LN7@z900_test_:

; 826  : 
; 827  :     TXF_INSTR_CHECK( regs );

  000ca	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000d9	85 c0		 test	 eax, eax
  000db	74 3f		 je	 SHORT $LN28@z900_test_
  000dd	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e5	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000eb	0f ba e8 0c	 bts	 eax, 12
  000ef	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f7	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000fd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195339
  00104	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0010a	ba 02 00 00 00	 mov	 edx, 2
  0010f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00117	e8 00 00 00 00	 call	 z900_abort_transaction
$LN28@z900_test_:
  0011c	33 c0		 xor	 eax, eax
  0011e	85 c0		 test	 eax, eax
  00120	75 a8		 jne	 SHORT $LN7@z900_test_

; 828  :     PRIV_CHECK( regs );

  00122	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0012e	83 e0 01	 and	 eax, 1
  00131	85 c0		 test	 eax, eax
  00133	74 1b		 je	 SHORT $LN29@z900_test_
  00135	ba 02 00 00 00	 mov	 edx, 2
  0013a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00142	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN29@z900_test_:

; 829  : 
; 830  : #if defined( _FEATURE_IO_ASSIST )
; 831  :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  00150	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00158	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015e	d1 e8		 shr	 eax, 1
  00160	83 e0 01	 and	 eax, 1
  00163	85 c0		 test	 eax, eax
  00165	74 74		 je	 SHORT $LN30@z900_test_
  00167	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00176	b9 01 00 00 00	 mov	 ecx, 1
  0017b	48 6b c9 00	 imul	 rcx, rcx, 0
  0017f	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00184	83 e0 04	 and	 eax, 4
  00187	85 c0		 test	 eax, eax
  00189	75 50		 jne	 SHORT $LN30@z900_test_
  0018b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00193	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00199	c1 e8 02	 shr	 eax, 2
  0019c	83 e0 01	 and	 eax, 1
  0019f	85 c0		 test	 eax, eax
  001a1	75 38		 jne	 SHORT $LN30@z900_test_
$LN10@z900_test_:

; 832  : #endif
; 833  :        SIE_INTERCEPT( regs );

  001a3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ab	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001b1	d1 e8		 shr	 eax, 1
  001b3	83 e0 01	 and	 eax, 1
  001b6	85 c0		 test	 eax, eax
  001b8	74 1b		 je	 SHORT $LN31@z900_test_
  001ba	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c2	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  001c8	ba fc ff ff ff	 mov	 edx, -4
  001cd	48 8b c8	 mov	 rcx, rax
  001d0	e8 00 00 00 00	 call	 longjmp
$LN31@z900_test_:
  001d5	33 c0		 xor	 eax, eax
  001d7	85 c0		 test	 eax, eax
  001d9	75 c8		 jne	 SHORT $LN10@z900_test_
$LN30@z900_test_:
$LN13@z900_test_:

; 834  : 
; 835  :     PTIO( IO,"TPI" );

  001db	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001e2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e5	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001eb	48 85 c0	 test	 rax, rax
  001ee	74 6b		 je	 SHORT $LN32@z900_test_
  001f0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f8	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001fe	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00203	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00208	48 23 d1	 and	 rdx, rcx
  0020b	48 8b ca	 mov	 rcx, rdx
  0020e	8b c9		 mov	 ecx, ecx
  00210	ba 08 00 00 00	 mov	 edx, 8
  00215	48 6b d2 01	 imul	 rdx, rdx, 1
  00219	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00221	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00229	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00232	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00237	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195344
  0023e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00243	44 8b c9	 mov	 r9d, ecx
  00246	44 8b c2	 mov	 r8d, edx
  00249	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195345
  00250	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN32@z900_test_:
  0025b	33 c0		 xor	 eax, eax
  0025d	85 c0		 test	 eax, eax
  0025f	0f 85 76 ff ff
	ff		 jne	 $LN13@z900_test_

; 836  : 
; 837  :     FW_CHECK( effective_addr2, regs );

  00265	48 8b 44 24 48	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0026a	48 83 e0 03	 and	 rax, 3
  0026e	48 85 c0	 test	 rax, rax
  00271	74 1b		 je	 SHORT $LN33@z900_test_
  00273	ba 06 00 00 00	 mov	 edx, 6
  00278	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00280	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00288	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN33@z900_test_:

; 838  : 
; 839  :     /* validate operand before taking any action */
; 840  :     if (effective_addr2 != 0)

  0028e	48 83 7c 24 48
	00		 cmp	 QWORD PTR effective_addr2$[rsp], 0
  00294	74 27		 je	 SHORT $LN34@z900_test_

; 841  :         ARCH_DEP( validate_operand )( effective_addr2, b2, 8-1,

  00296	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0029e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a3	41 b9 02 00 00
	00		 mov	 r9d, 2
  002a9	41 b8 07 00 00
	00		 mov	 r8d, 7
  002af	8b 54 24 50	 mov	 edx, DWORD PTR b2$[rsp]
  002b3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  002b8	e8 00 00 00 00	 call	 z900_validate_operand
$LN34@z900_test_:

; 842  :                                       ACCTYPE_WRITE, regs );
; 843  : 
; 844  :     /* Perform serialization and checkpoint-synchronization */
; 845  :     PERFORM_SERIALIZATION( regs );

  002bd	0f ae f0	 mfence
$LN16@z900_test_:

; 846  :     PERFORM_CHKPT_SYNC( regs );

  002c0	33 c0		 xor	 eax, eax
  002c2	85 c0		 test	 eax, eax
  002c4	75 fa		 jne	 SHORT $LN16@z900_test_

; 847  : 
; 848  :     if (IS_IC_IOPENDING)

  002c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002cd	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  002d3	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  002d8	85 c0		 test	 eax, eax
  002da	0f 84 4e 02 00
	00		 je	 $LN35@z900_test_

; 849  :     {
; 850  :         OBTAIN_INTLOCK( regs );

  002e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195350
  002e7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ef	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 851  :         {
; 852  :             /* Test and clear pending interrupt
; 853  :                and set the condition code
; 854  :             */
; 855  :             icode = ARCH_DEP( present_io_interrupt )( regs, &ioid, &ioparm,

  002f4	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR dev$[rsp]
  002fc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00301	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0030a	4c 8d 4c 24 78	 lea	 r9, QWORD PTR iointid$[rsp]
  0030f	4c 8d 44 24 5c	 lea	 r8, QWORD PTR ioparm$[rsp]
  00314	48 8d 54 24 58	 lea	 rdx, QWORD PTR ioid$[rsp]
  00319	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00321	e8 00 00 00 00	 call	 z900_present_io_interrupt
  00326	89 44 24 40	 mov	 DWORD PTR icode$[rsp], eax

; 856  :                                                       &iointid, NULL, &dev );
; 857  :         }
; 858  :         RELEASE_INTLOCK( regs );

  0032a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195351
  00331	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00339	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 859  : 
; 860  :         /* Store the SSID word and I/O parameter
; 861  :            if an interrupt was pending
; 862  :         */
; 863  :         if (icode)

  0033e	83 7c 24 40 00	 cmp	 DWORD PTR icode$[rsp], 0
  00343	0f 84 e3 01 00
	00		 je	 $LN37@z900_test_

; 864  :         {
; 865  :             if (0
; 866  :                 || effective_addr2 == 0
; 867  : #if defined( _FEATURE_IO_ASSIST )
; 868  :                 || icode != SIE_NO_INTERCEPT

  00349	33 c0		 xor	 eax, eax
  0034b	85 c0		 test	 eax, eax
  0034d	75 13		 jne	 SHORT $LN40@z900_test_
  0034f	48 83 7c 24 48
	00		 cmp	 QWORD PTR effective_addr2$[rsp], 0
  00355	74 0b		 je	 SHORT $LN40@z900_test_
  00357	83 7c 24 40 ff	 cmp	 DWORD PTR icode$[rsp], -1
  0035c	0f 84 94 01 00
	00		 je	 $LN38@z900_test_
$LN40@z900_test_:

; 869  : #endif
; 870  :             )
; 871  :             {
; 872  : #if defined( _FEATURE_IO_ASSIST )
; 873  :                 if (icode != SIE_NO_INTERCEPT)

  00362	83 7c 24 40 ff	 cmp	 DWORD PTR icode$[rsp], -1
  00367	74 4a		 je	 SHORT $LN41@z900_test_

; 874  :                 {
; 875  :                     /* Point to SIE copy of PSA in state descriptor */
; 876  :                     psa = (void*)(HOSTREGS->mainstor + SIE_STATE(regs) + SIE_II_PSA_OFFSET);

  00369	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00371	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00378	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0037f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00387	48 8b 89 80 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2176]
  0038e	48 8d 44 08 30	 lea	 rax, QWORD PTR [rax+rcx+48]
  00393	48 89 44 24 70	 mov	 QWORD PTR psa$[rsp], rax

; 877  :                     ARCH_DEP( or_storage_key )( SIE_STATE( regs ), (STORKEY_REF | STORKEY_CHANGE) );

  00398	b2 06		 mov	 dl, 6
  0039a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a2	48 8b 88 80 08
	00 00		 mov	 rcx, QWORD PTR [rax+2176]
  003a9	e8 00 00 00 00	 call	 z900_or_storage_key

; 878  :                 }

  003ae	e9 cb 00 00 00	 jmp	 $LN42@z900_test_
$LN41@z900_test_:

; 879  :                 else
; 880  : #endif
; 881  :                 {
; 882  :                     /* Point to PSA in main storage */
; 883  :                     pfx = regs->PX;

  003b3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003bb	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  003bf	48 89 44 24 68	 mov	 QWORD PTR pfx$[rsp], rax
$LN19@z900_test_:

; 884  :                     SIE_TRANSLATE( &pfx, ACCTYPE_SIE, regs );

  003c4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003cc	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  003d2	d1 e8		 shr	 eax, 1
  003d4	83 e0 01	 and	 eax, 1
  003d7	85 c0		 test	 eax, eax
  003d9	74 74		 je	 SHORT $LN43@z900_test_
  003db	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  003e9	c1 e8 02	 shr	 eax, 2
  003ec	83 e0 01	 and	 eax, 1
  003ef	85 c0		 test	 eax, eax
  003f1	75 5c		 jne	 SHORT $LN43@z900_test_
  003f3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003fb	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00402	48 03 44 24 68	 add	 rax, QWORD PTR pfx$[rsp]
  00407	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00410	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00415	45 33 c9	 xor	 r9d, r9d
  00418	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00420	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00427	ba fd ff ff ff	 mov	 edx, -3
  0042c	48 8b c8	 mov	 rcx, rax
  0042f	e8 00 00 00 00	 call	 z900_logical_to_main_l
  00434	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0043c	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00443	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  0044a	48 89 44 24 68	 mov	 QWORD PTR pfx$[rsp], rax
$LN43@z900_test_:
  0044f	33 c0		 xor	 eax, eax
  00451	85 c0		 test	 eax, eax
  00453	0f 85 6b ff ff
	ff		 jne	 $LN19@z900_test_

; 885  :                     psa = (void*)(regs->mainstor + pfx);

  00459	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00461	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00468	48 03 44 24 68	 add	 rax, QWORD PTR pfx$[rsp]
  0046d	48 89 44 24 70	 mov	 QWORD PTR psa$[rsp], rax

; 886  :                     ARCH_DEP( or_storage_key )( pfx, (STORKEY_REF | STORKEY_CHANGE) );

  00472	b2 06		 mov	 dl, 6
  00474	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pfx$[rsp]
  00479	e8 00 00 00 00	 call	 z900_or_storage_key
$LN42@z900_test_:

; 887  :                 }
; 888  : 
; 889  :                 /* If operand address is zero, store in PSA */
; 890  :                 STORE_FW( psa->ioid,ioid );

  0047e	8b 4c 24 58	 mov	 ecx, DWORD PTR ioid$[rsp]
  00482	e8 00 00 00 00	 call	 _byteswap_ulong
  00487	48 8b 4c 24 70	 mov	 rcx, QWORD PTR psa$[rsp]
  0048c	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00493	8b d0		 mov	 edx, eax
  00495	e8 00 00 00 00	 call	 store_fw_noswap

; 891  :                 STORE_FW( psa->ioparm,ioparm );

  0049a	8b 4c 24 5c	 mov	 ecx, DWORD PTR ioparm$[rsp]
  0049e	e8 00 00 00 00	 call	 _byteswap_ulong
  004a3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR psa$[rsp]
  004a8	48 81 c1 bc 00
	00 00		 add	 rcx, 188		; 000000bcH
  004af	8b d0		 mov	 edx, eax
  004b1	e8 00 00 00 00	 call	 store_fw_noswap

; 892  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) || defined( _FEATURE_IO_ASSIST )
; 893  :                 STORE_FW( psa->iointid,iointid );

  004b6	8b 4c 24 78	 mov	 ecx, DWORD PTR iointid$[rsp]
  004ba	e8 00 00 00 00	 call	 _byteswap_ulong
  004bf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR psa$[rsp]
  004c4	48 81 c1 c0 00
	00 00		 add	 rcx, 192		; 000000c0H
  004cb	8b d0		 mov	 edx, eax
  004cd	e8 00 00 00 00	 call	 store_fw_noswap

; 894  : #endif
; 895  :                 /* Do SIE intercept if needed */
; 896  : #if defined( _FEATURE_IO_ASSIST )
; 897  :                 if (icode != SIE_NO_INTERCEPT)

  004d2	83 7c 24 40 ff	 cmp	 DWORD PTR icode$[rsp], -1
  004d7	74 1b		 je	 SHORT $LN44@z900_test_

; 898  :                     longjmp( regs->progjmp, SIE_INTERCEPT_IOINST );

  004d9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e1	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  004e7	ba ef ff ff ff	 mov	 edx, -17
  004ec	48 8b c8	 mov	 rcx, rax
  004ef	e8 00 00 00 00	 call	 longjmp
$LN44@z900_test_:

; 899  : #endif
; 900  :             }

  004f4	eb 36		 jmp	 SHORT $LN39@z900_test_
$LN38@z900_test_:

; 901  :             else
; 902  :             {
; 903  :                 /* Otherwise store at operand location */
; 904  :                 dreg = ((U64)ioid << 32) | ioparm;

  004f6	8b 44 24 58	 mov	 eax, DWORD PTR ioid$[rsp]
  004fa	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  004fe	8b 4c 24 5c	 mov	 ecx, DWORD PTR ioparm$[rsp]
  00502	48 0b c1	 or	 rax, rcx
  00505	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dreg$[rsp], rax

; 905  :                 ARCH_DEP( vstore8 )( dreg, effective_addr2, b2, regs );

  0050d	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00515	44 8b 44 24 50	 mov	 r8d, DWORD PTR b2$[rsp]
  0051a	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0051f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dreg$[rsp]
  00527	e8 00 00 00 00	 call	 z900_vstore8
$LN39@z900_test_:
$LN37@z900_test_:

; 906  :             }
; 907  :         }
; 908  :     }

  0052c	eb 40		 jmp	 SHORT $LN36@z900_test_
$LN35@z900_test_:
$LN22@z900_test_:

; 909  :     else
; 910  :     {
; 911  : #if defined( _FEATURE_IO_ASSIST )
; 912  :         /* If no I/O assisted devices have pending interrupts
; 913  :            then we must intercept */
; 914  :         SIE_INTERCEPT( regs );

  0052e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00536	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0053c	d1 e8		 shr	 eax, 1
  0053e	83 e0 01	 and	 eax, 1
  00541	85 c0		 test	 eax, eax
  00543	74 1b		 je	 SHORT $LN45@z900_test_
  00545	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0054d	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00553	ba fc ff ff ff	 mov	 edx, -4
  00558	48 8b c8	 mov	 rcx, rax
  0055b	e8 00 00 00 00	 call	 longjmp
$LN45@z900_test_:
  00560	33 c0		 xor	 eax, eax
  00562	85 c0		 test	 eax, eax
  00564	75 c8		 jne	 SHORT $LN22@z900_test_

; 915  : #endif
; 916  :         icode = 0;

  00566	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR icode$[rsp], 0
$LN36@z900_test_:

; 917  :     }
; 918  : 
; 919  :     regs->psw.cc = (icode == 0) ? 0 : 1;

  0056e	83 7c 24 40 00	 cmp	 DWORD PTR icode$[rsp], 0
  00573	75 0a		 jne	 SHORT $LN49@z900_test_
  00575	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv281[rsp], 0
  0057d	eb 08		 jmp	 SHORT $LN50@z900_test_
$LN49@z900_test_:
  0057f	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv281[rsp], 1
$LN50@z900_test_:
  00587	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058f	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR tv281[rsp]
  00594	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 920  : 
; 921  :     if (regs->psw.cc != 0)

  00597	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0059f	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  005a3	85 c0		 test	 eax, eax
  005a5	0f 84 88 00 00
	00		 je	 $LN46@z900_test_
$LN25@z900_test_:

; 922  :         PTIO(ERR,"*TPI");

  005ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005b2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005b5	48 83 e0 10	 and	 rax, 16
  005b9	48 85 c0	 test	 rax, rax
  005bc	74 6b		 je	 SHORT $LN47@z900_test_
  005be	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c6	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  005cc	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  005d1	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  005d6	48 23 d1	 and	 rdx, rcx
  005d9	48 8b ca	 mov	 rcx, rdx
  005dc	8b c9		 mov	 ecx, ecx
  005de	ba 08 00 00 00	 mov	 edx, 8
  005e3	48 6b d2 01	 imul	 rdx, rdx, 1
  005e7	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005ef	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  005f7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00600	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00605	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195363
  0060c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00611	44 8b c9	 mov	 r9d, ecx
  00614	44 8b c2	 mov	 r8d, edx
  00617	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195364
  0061e	b9 10 00 00 00	 mov	 ecx, 16
  00623	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN47@z900_test_:
  00629	33 c0		 xor	 eax, eax
  0062b	85 c0		 test	 eax, eax
  0062d	0f 85 78 ff ff
	ff		 jne	 $LN25@z900_test_
$LN46@z900_test_:
$LN48@z900_test_:

; 923  : }

  00633	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0063a	c3		 ret	 0
z900_test_pending_interruption ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
b2$ = 64
dev$ = 72
effective_addr2$ = 80
temp$1 = 88
schib$ = 96
__$ArrayPad$ = 152
inst$ = 192
regs$ = 200
z900_store_subchannel PROC

; 748  : {

$LN43:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 749  : int     b2;                             /* Effective addr base       */
; 750  : VADR    effective_addr2;                /* Effective address         */
; 751  : DEVBLK* dev;                            /* -> device block           */
; 752  : SCHIB   schib;                          /* Subchannel information blk*/
; 753  : 
; 754  :     S( inst, regs, b2, effective_addr2 );

  00025	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 _byteswap_ulong
  00039	89 44 24 58	 mov	 DWORD PTR temp$1[rsp], eax
  0003d	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  00041	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00046	8b c0		 mov	 eax, eax
  00048	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004d	8b 44 24 58	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 0c	 shr	 eax, 12
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 40	 mov	 DWORD PTR b2$[rsp], eax
  0005b	83 7c 24 40 00	 cmp	 DWORD PTR b2$[rsp], 0
  00060	74 44		 je	 SHORT $LN26@z900_store
  00062	48 63 44 24 40	 movsxd	 rax, DWORD PTR b2$[rsp]
  00067	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007c	48 03 c8	 add	 rcx, rax
  0007f	48 8b c1	 mov	 rax, rcx
  00082	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00087	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00096	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0009b	48 23 c8	 and	 rcx, rax
  0009e	48 8b c1	 mov	 rax, rcx
  000a1	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN26@z900_store:
$LN4@z900_store:
  000a6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ae	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b2	48 83 c0 04	 add	 rax, 4
  000b6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000be	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c2	33 c0		 xor	 eax, eax
  000c4	83 f8 04	 cmp	 eax, 4
  000c7	74 0f		 je	 SHORT $LN27@z900_store
  000c9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN27@z900_store:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 c8		 jne	 SHORT $LN4@z900_store

; 755  :     PER_ZEROADDR_XCHECK( regs, b2 );

  000de	8b 54 24 40	 mov	 edx, DWORD PTR b2$[rsp]
  000e2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ea	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_store:

; 756  : 
; 757  :     TXF_INSTR_CHECK( regs );

  000ef	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000fe	85 c0		 test	 eax, eax
  00100	74 3f		 je	 SHORT $LN28@z900_store
  00102	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010a	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00110	0f ba e8 0c	 bts	 eax, 12
  00114	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011c	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00122	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195252
  00129	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0012f	ba 02 00 00 00	 mov	 edx, 2
  00134	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013c	e8 00 00 00 00	 call	 z900_abort_transaction
$LN28@z900_store:
  00141	33 c0		 xor	 eax, eax
  00143	85 c0		 test	 eax, eax
  00145	75 a8		 jne	 SHORT $LN7@z900_store

; 758  :     PRIV_CHECK( regs );

  00147	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00153	83 e0 01	 and	 eax, 1
  00156	85 c0		 test	 eax, eax
  00158	74 1b		 je	 SHORT $LN29@z900_store
  0015a	ba 02 00 00 00	 mov	 edx, 2
  0015f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00167	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN29@z900_store:
$LN10@z900_store:

; 759  :     PTIO( IO, "STSCH" );

  00175	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0017c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017f	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00185	48 85 c0	 test	 rax, rax
  00188	74 6b		 je	 SHORT $LN30@z900_store
  0018a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00192	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00198	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0019d	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001a2	48 23 d1	 and	 rdx, rcx
  001a5	48 8b ca	 mov	 rcx, rdx
  001a8	8b c9		 mov	 ecx, ecx
  001aa	ba 08 00 00 00	 mov	 edx, 8
  001af	48 6b d2 01	 imul	 rdx, rdx, 1
  001b3	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001bb	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001c3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001cc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195255
  001d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001dd	44 8b c9	 mov	 r9d, ecx
  001e0	44 8b c2	 mov	 r8d, edx
  001e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195256
  001ea	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN30@z900_store:
  001f5	33 c0		 xor	 eax, eax
  001f7	85 c0		 test	 eax, eax
  001f9	0f 85 76 ff ff
	ff		 jne	 $LN10@z900_store
$LN13@z900_store:

; 760  :     PTIO( IO, "STSCH (sie)" );

  001ff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00206	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00209	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0020f	48 85 c0	 test	 rax, rax
  00212	74 6b		 je	 SHORT $LN31@z900_store
  00214	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021c	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00222	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00227	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0022c	48 23 d1	 and	 rdx, rcx
  0022f	48 8b ca	 mov	 rcx, rdx
  00232	8b c9		 mov	 ecx, ecx
  00234	ba 08 00 00 00	 mov	 edx, 8
  00239	48 6b d2 01	 imul	 rdx, rdx, 1
  0023d	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00245	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0024d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00256	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195258
  00262	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00267	44 8b c9	 mov	 r9d, ecx
  0026a	44 8b c2	 mov	 r8d, edx
  0026d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195259
  00274	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00279	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN31@z900_store:
  0027f	33 c0		 xor	 eax, eax
  00281	85 c0		 test	 eax, eax
  00283	0f 85 76 ff ff
	ff		 jne	 $LN13@z900_store
$LN16@z900_store:

; 761  :     SIE_INTERCEPT( regs );

  00289	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00291	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00297	d1 e8		 shr	 eax, 1
  00299	83 e0 01	 and	 eax, 1
  0029c	85 c0		 test	 eax, eax
  0029e	74 1b		 je	 SHORT $LN32@z900_store
  002a0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a8	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  002ae	ba fc ff ff ff	 mov	 edx, -4
  002b3	48 8b c8	 mov	 rcx, rax
  002b6	e8 00 00 00 00	 call	 longjmp
$LN32@z900_store:
  002bb	33 c0		 xor	 eax, eax
  002bd	85 c0		 test	 eax, eax
  002bf	75 c8		 jne	 SHORT $LN16@z900_store

; 762  : 
; 763  :     /* Program check if the ssid including lcss is invalid */
; 764  :     SSID_CHECK( regs );

  002c1	b8 08 00 00 00	 mov	 eax, 8
  002c6	48 6b c0 01	 imul	 rax, rax, 1
  002ca	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d2	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002da	83 e0 01	 and	 eax, 1
  002dd	85 c0		 test	 eax, eax
  002df	74 1e		 je	 SHORT $LN34@z900_store
  002e1	b8 08 00 00 00	 mov	 eax, 8
  002e6	48 6b c0 01	 imul	 rax, rax, 1
  002ea	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002fa	83 f8 03	 cmp	 eax, 3
  002fd	7e 1b		 jle	 SHORT $LN33@z900_store
$LN34@z900_store:
  002ff	ba 15 00 00 00	 mov	 edx, 21
  00304	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00314	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN33@z900_store:

; 765  : 
; 766  :     /* Locate the device block for this subchannel */
; 767  :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  0031a	b8 08 00 00 00	 mov	 eax, 8
  0031f	48 6b c0 01	 imul	 rax, rax, 1
  00323	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032b	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  00332	e8 00 00 00 00	 call	 find_device_by_subchan
  00337	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax

; 768  : 
; 769  :     if (dev)

  0033c	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00342	74 5a		 je	 SHORT $LN35@z900_store
$LN19@z900_store:

; 770  :         PTT( PTT_CL_IO, "STSCH (dev)", dev->devnum, 0, 0 );

  00344	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0034b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0034e	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00354	48 85 c0	 test	 rax, rax
  00357	74 3f		 je	 SHORT $LN36@z900_store
  00359	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0035e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00362	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0036b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00374	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195265
  0037b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00380	45 33 c9	 xor	 r9d, r9d
  00383	44 8b c0	 mov	 r8d, eax
  00386	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195266
  0038d	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00392	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@z900_store:
  00398	33 c0		 xor	 eax, eax
  0039a	85 c0		 test	 eax, eax
  0039c	75 a6		 jne	 SHORT $LN19@z900_store
$LN35@z900_store:

; 771  : 
; 772  :     /* Set condition code 3 if subchannel does not exist */
; 773  :     if (!dev)

  0039e	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  003a4	0f 85 99 00 00
	00		 jne	 $LN37@z900_store
$LN22@z900_store:

; 774  :     {
; 775  :         PTIO( ERR, "*STSCH" );

  003aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003b1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003b4	48 83 e0 10	 and	 rax, 16
  003b8	48 85 c0	 test	 rax, rax
  003bb	74 6b		 je	 SHORT $LN38@z900_store
  003bd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c5	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003cb	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  003d0	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  003d5	48 23 d1	 and	 rdx, rcx
  003d8	48 8b ca	 mov	 rcx, rdx
  003db	8b c9		 mov	 ecx, ecx
  003dd	ba 08 00 00 00	 mov	 edx, 8
  003e2	48 6b d2 01	 imul	 rdx, rdx, 1
  003e6	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003ee	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  003f6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003ff	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00404	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195269
  0040b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00410	44 8b c9	 mov	 r9d, ecx
  00413	44 8b c2	 mov	 r8d, edx
  00416	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195270
  0041d	b9 10 00 00 00	 mov	 ecx, 16
  00422	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN38@z900_store:
  00428	33 c0		 xor	 eax, eax
  0042a	85 c0		 test	 eax, eax
  0042c	0f 85 78 ff ff
	ff		 jne	 $LN22@z900_store

; 776  :         regs->psw.cc = 3;

  00432	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0043a	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 777  :         return;

  0043e	e9 0d 01 00 00	 jmp	 $LN1@z900_store
$LN37@z900_store:

; 778  :     }
; 779  : 
; 780  :     FW_CHECK( effective_addr2, regs );

  00443	48 8b 44 24 50	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00448	48 83 e0 03	 and	 rax, 3
  0044c	48 85 c0	 test	 rax, rax
  0044f	74 1b		 je	 SHORT $LN39@z900_store
  00451	ba 06 00 00 00	 mov	 edx, 6
  00456	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00466	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN39@z900_store:

; 781  : 
; 782  :     /* Perform serialization and checkpoint-synchronization */
; 783  :     PERFORM_SERIALIZATION( regs );

  0046c	0f ae f0	 mfence
$LN25@z900_store:

; 784  :     PERFORM_CHKPT_SYNC( regs );

  0046f	33 c0		 xor	 eax, eax
  00471	85 c0		 test	 eax, eax
  00473	75 fa		 jne	 SHORT $LN25@z900_store

; 785  : 
; 786  :     /* Build the subchannel information block */
; 787  :     schib.pmcw = dev->pmcw;

  00475	48 8d 44 24 60	 lea	 rax, QWORD PTR schib$[rsp]
  0047a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  0047f	48 8b f8	 mov	 rdi, rax
  00482	48 8d b1 ec 02
	00 00		 lea	 rsi, QWORD PTR [rcx+748]
  00489	b9 1c 00 00 00	 mov	 ecx, 28
  0048e	f3 a4		 rep movsb

; 788  : 
; 789  :     obtain_lock( &dev->lock );

  00490	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00495	48 83 c0 38	 add	 rax, 56			; 00000038H
  00499	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195272
  004a0	48 8b c8	 mov	 rcx, rax
  004a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 790  :     {
; 791  :         if (dev->pciscsw.flag3 & SCSW3_SC_PEND)

  004a9	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  004ae	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  004b5	83 e0 01	 and	 eax, 1
  004b8	85 c0		 test	 eax, eax
  004ba	74 1d		 je	 SHORT $LN40@z900_store

; 792  :             schib.scsw = dev->pciscsw;

  004bc	48 8d 44 24 7c	 lea	 rax, QWORD PTR schib$[rsp+28]
  004c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  004c6	48 8b f8	 mov	 rdi, rax
  004c9	48 8d b1 14 03
	00 00		 lea	 rsi, QWORD PTR [rcx+788]
  004d0	b9 0c 00 00 00	 mov	 ecx, 12
  004d5	f3 a4		 rep movsb
  004d7	eb 1b		 jmp	 SHORT $LN41@z900_store
$LN40@z900_store:

; 793  :         else
; 794  :             schib.scsw = dev->scsw;

  004d9	48 8d 44 24 7c	 lea	 rax, QWORD PTR schib$[rsp+28]
  004de	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  004e3	48 8b f8	 mov	 rdi, rax
  004e6	48 8d b1 08 03
	00 00		 lea	 rsi, QWORD PTR [rcx+776]
  004ed	b9 0c 00 00 00	 mov	 ecx, 12
  004f2	f3 a4		 rep movsb
$LN41@z900_store:

; 795  :     }
; 796  :     release_lock( &dev->lock );

  004f4	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  004f9	48 83 c0 38	 add	 rax, 56			; 00000038H
  004fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195275
  00504	48 8b c8	 mov	 rcx, rax
  00507	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 797  : 
; 798  :     memset( schib.moddep, 0, sizeof( schib.moddep ));

  0050d	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR schib$[rsp+40]
  00515	48 8b f8	 mov	 rdi, rax
  00518	33 c0		 xor	 eax, eax
  0051a	b9 0c 00 00 00	 mov	 ecx, 12
  0051f	f3 aa		 rep stosb

; 799  : 
; 800  :     /* Store the subchannel information block */
; 801  :     ARCH_DEP( vstorec )( &schib, sizeof(SCHIB)-1, effective_addr2,

  00521	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00529	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0052e	44 8b 4c 24 40	 mov	 r9d, DWORD PTR b2$[rsp]
  00533	4c 8b 44 24 50	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  00538	b2 33		 mov	 dl, 51			; 00000033H
  0053a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR schib$[rsp]
  0053f	e8 00 00 00 00	 call	 z900_vstorec

; 802  :                 b2, regs );
; 803  : 
; 804  :     /* Set condition code 0 */
; 805  :     regs->psw.cc = 0;

  00544	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0054c	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@z900_store:
$LN42@z900_store:

; 806  : }

  00550	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00558	48 33 cc	 xor	 rcx, rsp
  0055b	e8 00 00 00 00	 call	 __security_check_cookie
  00560	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00567	5f		 pop	 rdi
  00568	5e		 pop	 rsi
  00569	c3		 ret	 0
z900_store_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
b2$ = 64
crw$ = 68
temp$1 = 72
tv201 = 76
effective_addr2$ = 80
inst$ = 112
regs$ = 120
z900_store_channel_report_word PROC

; 710  : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 711  : int     b2;                             /* Effective addr base       */
; 712  : VADR    effective_addr2;                /* Effective address         */
; 713  : U32     crw;                            /* Channel Report Word       */
; 714  : 
; 715  :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 0c	 shr	 eax, 12
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 40	 mov	 DWORD PTR b2$[rsp], eax
  00041	83 7c 24 40 00	 cmp	 DWORD PTR b2$[rsp], 0
  00046	74 3e		 je	 SHORT $LN20@z900_store
  00048	48 63 44 24 40	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0005f	48 03 c8	 add	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0006a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00076	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 23 c8	 and	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN20@z900_store:
$LN4@z900_store:
  00086	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008f	48 83 c0 04	 add	 rax, 4
  00093	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0009c	33 c0		 xor	 eax, eax
  0009e	83 f8 04	 cmp	 eax, 4
  000a1	74 0c		 je	 SHORT $LN21@z900_store
  000a3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN21@z900_store:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 d1		 jne	 SHORT $LN4@z900_store

; 716  :     PER_ZEROADDR_XCHECK( regs, b2 );

  000b5	8b 54 24 40	 mov	 edx, DWORD PTR b2$[rsp]
  000b9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000be	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_store:

; 717  : 
; 718  :     TXF_INSTR_CHECK( regs );

  000c3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000cf	85 c0		 test	 eax, eax
  000d1	74 36		 je	 SHORT $LN22@z900_store
  000d3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000de	0f ba e8 0c	 bts	 eax, 12
  000e2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000ed	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195172
  000f4	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000fa	ba 02 00 00 00	 mov	 edx, 2
  000ff	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00104	e8 00 00 00 00	 call	 z900_abort_transaction
$LN22@z900_store:
  00109	33 c0		 xor	 eax, eax
  0010b	85 c0		 test	 eax, eax
  0010d	75 b4		 jne	 SHORT $LN7@z900_store
$LN10@z900_store:

; 719  :     PTIO(IO,"STCRW");

  0010f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00116	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00119	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0011f	48 85 c0	 test	 rax, rax
  00122	74 65		 je	 SHORT $LN23@z900_store
  00124	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00129	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0012f	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00134	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00139	48 23 d1	 and	 rdx, rcx
  0013c	48 8b ca	 mov	 rcx, rdx
  0013f	8b c9		 mov	 ecx, ecx
  00141	ba 08 00 00 00	 mov	 edx, 8
  00146	48 6b d2 01	 imul	 rdx, rdx, 1
  0014a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0014f	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00157	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00160	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00165	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195174
  0016c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00171	44 8b c9	 mov	 r9d, ecx
  00174	44 8b c2	 mov	 r8d, edx
  00177	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195175
  0017e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN23@z900_store:
  00189	33 c0		 xor	 eax, eax
  0018b	85 c0		 test	 eax, eax
  0018d	75 80		 jne	 SHORT $LN10@z900_store

; 720  :     PRIV_CHECK(regs);

  0018f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00194	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00198	83 e0 01	 and	 eax, 1
  0019b	85 c0		 test	 eax, eax
  0019d	74 15		 je	 SHORT $LN24@z900_store
  0019f	ba 02 00 00 00	 mov	 edx, 2
  001a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001ae	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN24@z900_store:
$LN13@z900_store:

; 721  :     SIE_INTERCEPT(regs);

  001b4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001b9	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001bf	d1 e8		 shr	 eax, 1
  001c1	83 e0 01	 and	 eax, 1
  001c4	85 c0		 test	 eax, eax
  001c6	74 18		 je	 SHORT $LN25@z900_store
  001c8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001cd	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  001d3	ba fc ff ff ff	 mov	 edx, -4
  001d8	48 8b c8	 mov	 rcx, rax
  001db	e8 00 00 00 00	 call	 longjmp
$LN25@z900_store:
  001e0	33 c0		 xor	 eax, eax
  001e2	85 c0		 test	 eax, eax
  001e4	75 ce		 jne	 SHORT $LN13@z900_store

; 722  :     FW_CHECK(effective_addr2, regs);

  001e6	48 8b 44 24 50	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001eb	48 83 e0 03	 and	 rax, 3
  001ef	48 85 c0	 test	 rax, rax
  001f2	74 15		 je	 SHORT $LN26@z900_store
  001f4	ba 06 00 00 00	 mov	 edx, 6
  001f9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001fe	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00203	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN26@z900_store:

; 723  : 
; 724  :     /* Validate write access to operand before taking any
; 725  :        pending channel report word off the queue */
; 726  :     ARCH_DEP(validate_operand) (effective_addr2, b2, 0, ACCTYPE_WRITE, regs);

  00209	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00213	41 b9 02 00 00
	00		 mov	 r9d, 2
  00219	45 33 c0	 xor	 r8d, r8d
  0021c	8b 54 24 40	 mov	 edx, DWORD PTR b2$[rsp]
  00220	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00225	e8 00 00 00 00	 call	 z900_validate_operand

; 727  : 
; 728  :     /* Obtain any pending channel report */
; 729  :     crw = get_next_channel_report_word(regs);

  0022a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0022f	e8 00 00 00 00	 call	 get_next_channel_report_word
  00234	89 44 24 44	 mov	 DWORD PTR crw$[rsp], eax
$LN16@z900_store:

; 730  : 
; 731  :     PTIO_CH( IO, "STCRW crw", crw );

  00238	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0023f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00242	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00248	48 85 c0	 test	 rax, rax
  0024b	74 53		 je	 SHORT $LN27@z900_store
  0024d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00252	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00258	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0025d	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00262	48 23 d1	 and	 rdx, rcx
  00265	48 8b ca	 mov	 rcx, rdx
  00268	8b c9		 mov	 ecx, ecx
  0026a	8b 54 24 44	 mov	 edx, DWORD PTR crw$[rsp]
  0026e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00277	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0027c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195180
  00283	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00288	44 8b c9	 mov	 r9d, ecx
  0028b	44 8b c2	 mov	 r8d, edx
  0028e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195181
  00295	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0029a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN27@z900_store:
  002a0	33 c0		 xor	 eax, eax
  002a2	85 c0		 test	 eax, eax
  002a4	75 92		 jne	 SHORT $LN16@z900_store

; 732  : 
; 733  :     /* Store channel report word at operand address */
; 734  :     ARCH_DEP(vstore4) ( crw, effective_addr2, b2, regs );

  002a6	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  002ab	44 8b 44 24 40	 mov	 r8d, DWORD PTR b2$[rsp]
  002b0	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  002b5	8b 4c 24 44	 mov	 ecx, DWORD PTR crw$[rsp]
  002b9	e8 00 00 00 00	 call	 z900_vstore4

; 735  : 
; 736  :     /* Indicate if channel report or zeros were stored */
; 737  :     regs->psw.cc = (crw == 0) ? 1 : 0;

  002be	83 7c 24 44 00	 cmp	 DWORD PTR crw$[rsp], 0
  002c3	75 0a		 jne	 SHORT $LN31@z900_store
  002c5	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv201[rsp], 1
  002cd	eb 08		 jmp	 SHORT $LN32@z900_store
$LN31@z900_store:
  002cf	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv201[rsp], 0
$LN32@z900_store:
  002d7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002dc	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR tv201[rsp]
  002e1	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 738  : 
; 739  :     if (regs->psw.cc != 0)

  002e4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002e9	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  002ed	85 c0		 test	 eax, eax
  002ef	74 7e		 je	 SHORT $LN28@z900_store
$LN19@z900_store:

; 740  :         PTIO(ERR,"*STCRW");

  002f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002f8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002fb	48 83 e0 10	 and	 rax, 16
  002ff	48 85 c0	 test	 rax, rax
  00302	74 65		 je	 SHORT $LN29@z900_store
  00304	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00309	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0030f	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00314	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00319	48 23 d1	 and	 rdx, rcx
  0031c	48 8b ca	 mov	 rcx, rdx
  0031f	8b c9		 mov	 ecx, ecx
  00321	ba 08 00 00 00	 mov	 edx, 8
  00326	48 6b d2 01	 imul	 rdx, rdx, 1
  0032a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0032f	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00337	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00340	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00345	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195184
  0034c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00351	44 8b c9	 mov	 r9d, ecx
  00354	44 8b c2	 mov	 r8d, edx
  00357	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195185
  0035e	b9 10 00 00 00	 mov	 ecx, 16
  00363	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@z900_store:
  00369	33 c0		 xor	 eax, eax
  0036b	85 c0		 test	 eax, eax
  0036d	75 82		 jne	 SHORT $LN19@z900_store
$LN28@z900_store:
$LN30@z900_store:

; 741  : }

  0036f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00373	c3		 ret	 0
z900_store_channel_report_word ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
chpid$ = 64
dev$ = 72
b2$ = 80
effective_addr2$ = 88
temp$1 = 96
tv302 = 100
tv217 = 104
tv205 = 112
work$ = 120
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
z900_store_channel_path_status PROC

; 635  : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 636  : int     b2;                             /* Effective addr base       */
; 637  : VADR    effective_addr2;                /* Effective address         */
; 638  : DEVBLK *dev;                            /* -> device block           */
; 639  : BYTE    chpid;                          /* CHPID associated w/lpum   */
; 640  : BYTE    work[32];                       /* Work area                 */
; 641  : static const BYTE msbn[256] = {         /* Most signif. bit# (0 - 7) */
; 642  : /*  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  */
; 643  :     8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, /* 0x00 */
; 644  :     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, /* 0x10 */
; 645  :     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /* 0x20 */
; 646  :     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /* 0x30 */
; 647  :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x40 */
; 648  :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x50 */
; 649  :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x60 */
; 650  :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x70 */
; 651  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x80 */
; 652  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x90 */
; 653  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xA0 */
; 654  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xB0 */
; 655  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xC0 */
; 656  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xD0 */
; 657  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xE0 */
; 658  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xF0 */
; 659  : };
; 660  : 
; 661  :     S(inst, regs, b2, effective_addr2);

  00024	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00031	8b c8		 mov	 ecx, eax
  00033	e8 00 00 00 00	 call	 _byteswap_ulong
  00038	89 44 24 60	 mov	 DWORD PTR temp$1[rsp], eax
  0003c	8b 44 24 60	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00045	8b c0		 mov	 eax, eax
  00047	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004c	8b 44 24 60	 mov	 eax, DWORD PTR temp$1[rsp]
  00050	c1 e8 0c	 shr	 eax, 12
  00053	83 e0 0f	 and	 eax, 15
  00056	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  0005a	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005f	74 44		 je	 SHORT $LN17@z900_store
  00061	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  00066	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00076	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 03 c8	 add	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00086	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00095	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0009a	48 23 c8	 and	 rcx, rax
  0009d	48 8b c1	 mov	 rax, rcx
  000a0	48 89 44 24 58	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN17@z900_store:
$LN4@z900_store:
  000a5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b1	48 83 c0 04	 add	 rax, 4
  000b5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c1	33 c0		 xor	 eax, eax
  000c3	83 f8 04	 cmp	 eax, 4
  000c6	74 0f		 je	 SHORT $LN18@z900_store
  000c8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN18@z900_store:
  000d7	33 c0		 xor	 eax, eax
  000d9	85 c0		 test	 eax, eax
  000db	75 c8		 jne	 SHORT $LN4@z900_store

; 662  :     PER_ZEROADDR_XCHECK( regs, b2 );

  000dd	8b 54 24 50	 mov	 edx, DWORD PTR b2$[rsp]
  000e1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e9	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_store:

; 663  : 
; 664  :     TXF_INSTR_CHECK( regs );

  000ee	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000fd	85 c0		 test	 eax, eax
  000ff	74 3f		 je	 SHORT $LN19@z900_store
  00101	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00109	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0010f	0f ba e8 0c	 bts	 eax, 12
  00113	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00121	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195110
  00128	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0012e	ba 02 00 00 00	 mov	 edx, 2
  00133	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013b	e8 00 00 00 00	 call	 z900_abort_transaction
$LN19@z900_store:
  00140	33 c0		 xor	 eax, eax
  00142	85 c0		 test	 eax, eax
  00144	75 a8		 jne	 SHORT $LN7@z900_store

; 665  :     PRIV_CHECK(regs);

  00146	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014e	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00152	83 e0 01	 and	 eax, 1
  00155	85 c0		 test	 eax, eax
  00157	74 1b		 je	 SHORT $LN20@z900_store
  00159	ba 02 00 00 00	 mov	 edx, 2
  0015e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN20@z900_store:
$LN10@z900_store:

; 666  :     SIE_INTERCEPT(regs);

  00174	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00182	d1 e8		 shr	 eax, 1
  00184	83 e0 01	 and	 eax, 1
  00187	85 c0		 test	 eax, eax
  00189	74 1b		 je	 SHORT $LN21@z900_store
  0018b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00193	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00199	ba fc ff ff ff	 mov	 edx, -4
  0019e	48 8b c8	 mov	 rcx, rax
  001a1	e8 00 00 00 00	 call	 longjmp
$LN21@z900_store:
  001a6	33 c0		 xor	 eax, eax
  001a8	85 c0		 test	 eax, eax
  001aa	75 c8		 jne	 SHORT $LN10@z900_store
$LN13@z900_store:

; 667  : 
; 668  :     PTIO_CH( IO, "STCPS", 0 );

  001ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001b3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b6	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001bc	48 85 c0	 test	 rax, rax
  001bf	74 52		 je	 SHORT $LN22@z900_store
  001c1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001cf	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  001d4	48 8b 54 24 58	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001d9	48 23 d1	 and	 rdx, rcx
  001dc	48 8b ca	 mov	 rcx, rdx
  001df	8b c9		 mov	 ecx, ecx
  001e1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001ea	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195114
  001f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fb	44 8b c9	 mov	 r9d, ecx
  001fe	45 33 c0	 xor	 r8d, r8d
  00201	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195115
  00208	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@z900_store:
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	75 93		 jne	 SHORT $LN13@z900_store

; 669  : 
; 670  :     /* Program check if operand not on 32 byte boundary */
; 671  :     if ( effective_addr2 & 0x0000001F )

  00219	48 8b 44 24 58	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0021e	48 83 e0 1f	 and	 rax, 31
  00222	48 85 c0	 test	 rax, rax
  00225	74 12		 je	 SHORT $LN23@z900_store

; 672  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00227	ba 06 00 00 00	 mov	 edx, 6
  0022c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00234	e8 00 00 00 00	 call	 z900_program_interrupt
$LN23@z900_store:

; 673  : 
; 674  :     memset(work, 0, 32);

  00239	48 8d 44 24 78	 lea	 rax, QWORD PTR work$[rsp]
  0023e	48 8b f8	 mov	 rdi, rax
  00241	33 c0		 xor	 eax, eax
  00243	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00248	f3 aa		 rep stosb

; 675  : 
; 676  :     /* Scan DEVBLK chain for busy devices */
; 677  :     for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  0024a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00251	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00258	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax
  0025d	eb 0e		 jmp	 SHORT $LN16@z900_store
$LN14@z900_store:
  0025f	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00264	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00268	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax
$LN16@z900_store:
  0026d	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00273	0f 84 3e 01 00
	00		 je	 $LN15@z900_store

; 678  :     {
; 679  :         /* Obtain the device lock */
; 680  :         obtain_lock(&dev->lock);

  00279	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0027e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00282	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195117
  00289	48 8b c8	 mov	 rcx, rax
  0028c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 681  : 
; 682  :         if (1
; 683  :             &&  dev->allocated                     /* Valid DEVBLK   */
; 684  :             && (dev->pmcw.flag5 & PMCW5_V)         /* Valid device   */
; 685  :             && (dev->pmcw.flag5 & PMCW5_E)         /* Device enabled */
; 686  :             && (dev->scsw.flag3 & SCSW3_AC_SCHAC)  /* Subchan active */
; 687  :             && (dev->scsw.flag3 & SCSW3_AC_DEVAC)  /* Device active  */

  00292	33 c0		 xor	 eax, eax
  00294	83 f8 01	 cmp	 eax, 1
  00297	0f 84 fc 00 00
	00		 je	 $LN24@z900_store
  0029d	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  002a2	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  002a6	0f 84 ed 00 00
	00		 je	 $LN24@z900_store
  002ac	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  002b1	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  002b8	83 e0 01	 and	 eax, 1
  002bb	85 c0		 test	 eax, eax
  002bd	0f 84 d6 00 00
	00		 je	 $LN24@z900_store
  002c3	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  002c8	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  002cf	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002d4	85 c0		 test	 eax, eax
  002d6	0f 84 bd 00 00
	00		 je	 $LN24@z900_store
  002dc	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  002e1	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  002e8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002ed	85 c0		 test	 eax, eax
  002ef	0f 84 a4 00 00
	00		 je	 $LN24@z900_store
  002f5	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  002fa	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00301	83 e0 40	 and	 eax, 64			; 00000040H
  00304	85 c0		 test	 eax, eax
  00306	0f 84 8d 00 00
	00		 je	 $LN24@z900_store

; 688  :            )
; 689  :         {
; 690  :             /* Retrieve active CHPID */
; 691  :             chpid = dev->pmcw.chpid[msbn[dev->pmcw.lpum]];

  0030c	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00311	0f b6 80 f6 02
	00 00		 movzx	 eax, BYTE PTR [rax+758]
  00318	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?msbn@?1??z900_store_channel_path_status@@9@9
  0031f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00323	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00328	0f b6 84 01 fc
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+764]
  00330	88 44 24 40	 mov	 BYTE PTR chpid$[rsp], al

; 692  : 
; 693  :             /* Update channel path status work area */
; 694  :             work[chpid/8] |= 0x80 >> (chpid % 8);

  00334	0f b6 44 24 40	 movzx	 eax, BYTE PTR chpid$[rsp]
  00339	99		 cdq
  0033a	83 e2 07	 and	 edx, 7
  0033d	03 c2		 add	 eax, edx
  0033f	c1 f8 03	 sar	 eax, 3
  00342	48 98		 cdqe
  00344	48 89 44 24 70	 mov	 QWORD PTR tv205[rsp], rax
  00349	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR chpid$[rsp]
  0034e	8b c1		 mov	 eax, ecx
  00350	99		 cdq
  00351	83 e2 07	 and	 edx, 7
  00354	03 c2		 add	 eax, edx
  00356	83 e0 07	 and	 eax, 7
  00359	2b c2		 sub	 eax, edx
  0035b	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00360	89 4c 24 64	 mov	 DWORD PTR tv302[rsp], ecx
  00364	0f b6 c8	 movzx	 ecx, al
  00367	8b 44 24 64	 mov	 eax, DWORD PTR tv302[rsp]
  0036b	d3 f8		 sar	 eax, cl
  0036d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv205[rsp]
  00372	0f b6 4c 0c 78	 movzx	 ecx, BYTE PTR work$[rsp+rcx]
  00377	0b c8		 or	 ecx, eax
  00379	8b c1		 mov	 eax, ecx
  0037b	89 44 24 68	 mov	 DWORD PTR tv217[rsp], eax
  0037f	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR chpid$[rsp]
  00384	8b c1		 mov	 eax, ecx
  00386	99		 cdq
  00387	83 e2 07	 and	 edx, 7
  0038a	03 c2		 add	 eax, edx
  0038c	c1 f8 03	 sar	 eax, 3
  0038f	48 98		 cdqe
  00391	8b 4c 24 68	 mov	 ecx, DWORD PTR tv217[rsp]
  00395	88 4c 04 78	 mov	 BYTE PTR work$[rsp+rax], cl
$LN24@z900_store:

; 695  :         }
; 696  : 
; 697  :         /* Release the device lock */
; 698  :         release_lock(&dev->lock);

  00399	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0039e	48 83 c0 38	 add	 rax, 56			; 00000038H
  003a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195119
  003a9	48 8b c8	 mov	 rcx, rax
  003ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 699  :     }

  003b2	e9 a8 fe ff ff	 jmp	 $LN14@z900_store
$LN15@z900_store:

; 700  : 
; 701  :     /* Store channel path status word at operand address */
; 702  :     ARCH_DEP(vstorec) ( work, 32-1, effective_addr2, b2, regs );

  003b7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003c4	44 8b 4c 24 50	 mov	 r9d, DWORD PTR b2$[rsp]
  003c9	4c 8b 44 24 58	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  003ce	b2 1f		 mov	 dl, 31
  003d0	48 8d 4c 24 78	 lea	 rcx, QWORD PTR work$[rsp]
  003d5	e8 00 00 00 00	 call	 z900_vstorec
$LN25@z900_store:

; 703  : }

  003da	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003e2	48 33 cc	 xor	 rcx, rsp
  003e5	e8 00 00 00 00	 call	 __security_check_cookie
  003ea	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  003f1	5f		 pop	 rdi
  003f2	c3		 ret	 0
z900_store_channel_path_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
dev$ = 72
b2$ = 80
temp$1 = 84
orb$ = 88
__$ArrayPad$ = 120
inst$ = 144
regs$ = 152
z900_start_subchannel PROC

; 534  : {

$LN59:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 535  : int     b2;                             /* Effective addr base       */
; 536  : VADR    effective_addr2;                /* Effective address         */
; 537  : DEVBLK* dev;                            /* -> device block           */
; 538  : ORB     orb;                            /* Operation request block   */
; 539  : 
; 540  :     S( inst, regs, b2, effective_addr2 );

  00020	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00028	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 _byteswap_ulong
  00034	89 44 24 54	 mov	 DWORD PTR temp$1[rsp], eax
  00038	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00041	8b c0		 mov	 eax, eax
  00043	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00048	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 0c	 shr	 eax, 12
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00056	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005b	74 44		 je	 SHORT $LN35@z900_start
  0005d	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  00062	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00077	48 03 c8	 add	 rcx, rax
  0007a	48 8b c1	 mov	 rax, rcx
  0007d	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00082	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00096	48 23 c8	 and	 rcx, rax
  00099	48 8b c1	 mov	 rax, rcx
  0009c	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN35@z900_start:
$LN4@z900_start:
  000a1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a9	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ad	48 83 c0 04	 add	 rax, 4
  000b1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bd	33 c0		 xor	 eax, eax
  000bf	83 f8 04	 cmp	 eax, 4
  000c2	74 0f		 je	 SHORT $LN36@z900_start
  000c4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN36@z900_start:
  000d3	33 c0		 xor	 eax, eax
  000d5	85 c0		 test	 eax, eax
  000d7	75 c8		 jne	 SHORT $LN4@z900_start

; 541  :     PER_ZEROADDR_XCHECK( regs, b2 );

  000d9	8b 54 24 50	 mov	 edx, DWORD PTR b2$[rsp]
  000dd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e5	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_start:

; 542  : 
; 543  :     TXF_INSTR_CHECK( regs );

  000ea	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000f9	85 c0		 test	 eax, eax
  000fb	74 3f		 je	 SHORT $LN37@z900_start
  000fd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00105	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0010b	0f ba e8 0c	 bts	 eax, 12
  0010f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00117	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0011d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195037
  00124	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0012a	ba 02 00 00 00	 mov	 edx, 2
  0012f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00137	e8 00 00 00 00	 call	 z900_abort_transaction
$LN37@z900_start:
  0013c	33 c0		 xor	 eax, eax
  0013e	85 c0		 test	 eax, eax
  00140	75 a8		 jne	 SHORT $LN7@z900_start

; 544  :     PRIV_CHECK( regs );

  00142	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0014e	83 e0 01	 and	 eax, 1
  00151	85 c0		 test	 eax, eax
  00153	74 1b		 je	 SHORT $LN38@z900_start
  00155	ba 02 00 00 00	 mov	 edx, 2
  0015a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00162	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN38@z900_start:
$LN10@z900_start:

; 545  : 
; 546  :     PTIO( IO, "SSCH" );

  00170	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00177	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017a	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00180	48 85 c0	 test	 rax, rax
  00183	74 6b		 je	 SHORT $LN39@z900_start
  00185	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018d	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00193	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00198	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0019d	48 23 d1	 and	 rdx, rcx
  001a0	48 8b ca	 mov	 rcx, rdx
  001a3	8b c9		 mov	 ecx, ecx
  001a5	ba 08 00 00 00	 mov	 edx, 8
  001aa	48 6b d2 01	 imul	 rdx, rdx, 1
  001ae	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001b6	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001be	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001c7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195040
  001d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d8	44 8b c9	 mov	 r9d, ecx
  001db	44 8b c2	 mov	 r8d, edx
  001de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195041
  001e5	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@z900_start:
  001f0	33 c0		 xor	 eax, eax
  001f2	85 c0		 test	 eax, eax
  001f4	0f 85 76 ff ff
	ff		 jne	 $LN10@z900_start

; 547  : 
; 548  : #if defined( _FEATURE_IO_ASSIST )
; 549  :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  001fa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00202	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00208	d1 e8		 shr	 eax, 1
  0020a	83 e0 01	 and	 eax, 1
  0020d	85 c0		 test	 eax, eax
  0020f	0f 84 06 01 00
	00		 je	 $LN40@z900_start
  00215	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00224	b9 01 00 00 00	 mov	 ecx, 1
  00229	48 6b c9 00	 imul	 rcx, rcx, 0
  0022d	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00232	83 e0 04	 and	 eax, 4
  00235	85 c0		 test	 eax, eax
  00237	0f 85 de 00 00
	00		 jne	 $LN40@z900_start
  0023d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00245	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0024b	c1 e8 02	 shr	 eax, 2
  0024e	83 e0 01	 and	 eax, 1
  00251	85 c0		 test	 eax, eax
  00253	0f 85 c2 00 00
	00		 jne	 $LN40@z900_start
$LN13@z900_start:

; 550  : #endif
; 551  :     {
; 552  :         PTIO( IO, "SSCH (sie)" );

  00259	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00260	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00263	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00269	48 85 c0	 test	 rax, rax
  0026c	74 6b		 je	 SHORT $LN41@z900_start
  0026e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00276	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0027c	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00281	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00286	48 23 d1	 and	 rdx, rcx
  00289	48 8b ca	 mov	 rcx, rdx
  0028c	8b c9		 mov	 ecx, ecx
  0028e	ba 08 00 00 00	 mov	 edx, 8
  00293	48 6b d2 01	 imul	 rdx, rdx, 1
  00297	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0029f	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  002a7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002b0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195044
  002bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c1	44 8b c9	 mov	 r9d, ecx
  002c4	44 8b c2	 mov	 r8d, edx
  002c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195045
  002ce	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN41@z900_start:
  002d9	33 c0		 xor	 eax, eax
  002db	85 c0		 test	 eax, eax
  002dd	0f 85 76 ff ff
	ff		 jne	 $LN13@z900_start
$LN16@z900_start:

; 553  :         SIE_INTERCEPT( regs );

  002e3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002eb	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  002f1	d1 e8		 shr	 eax, 1
  002f3	83 e0 01	 and	 eax, 1
  002f6	85 c0		 test	 eax, eax
  002f8	74 1b		 je	 SHORT $LN42@z900_start
  002fa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00302	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00308	ba fc ff ff ff	 mov	 edx, -4
  0030d	48 8b c8	 mov	 rcx, rax
  00310	e8 00 00 00 00	 call	 longjmp
$LN42@z900_start:
  00315	33 c0		 xor	 eax, eax
  00317	85 c0		 test	 eax, eax
  00319	75 c8		 jne	 SHORT $LN16@z900_start
$LN40@z900_start:

; 554  :     }
; 555  : 
; 556  :     FW_CHECK( effective_addr2, regs );

  0031b	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00320	48 83 e0 03	 and	 rax, 3
  00324	48 85 c0	 test	 rax, rax
  00327	74 1b		 je	 SHORT $LN43@z900_start
  00329	ba 06 00 00 00	 mov	 edx, 6
  0032e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00336	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0033e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN43@z900_start:

; 557  : 
; 558  :     /* Fetch the operation request block */
; 559  :     ARCH_DEP( vfetchc )( &orb, sizeof( ORB )-1, effective_addr2, b2, regs );

  00344	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00351	44 8b 4c 24 50	 mov	 r9d, DWORD PTR b2$[rsp]
  00356	4c 8b 44 24 40	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  0035b	b2 1f		 mov	 dl, 31
  0035d	48 8d 4c 24 58	 lea	 rcx, QWORD PTR orb$[rsp]
  00362	e8 00 00 00 00	 call	 z900_vfetchc

; 560  : 
; 561  :     /* Program check if reserved bits are not zero */
; 562  :     if (0
; 563  :         || orb.flag5 & ORB5_B /* Fiber Channel Extension (FCX) unsupported */
; 564  :         || orb.flag7 & ORB7_RESV
; 565  :         || orb.ccwaddr[0] & 0x80

  00367	33 c0		 xor	 eax, eax
  00369	85 c0		 test	 eax, eax
  0036b	75 2f		 jne	 SHORT $LN45@z900_start
  0036d	0f b6 44 24 5d	 movzx	 eax, BYTE PTR orb$[rsp+5]
  00372	83 e0 04	 and	 eax, 4
  00375	85 c0		 test	 eax, eax
  00377	75 23		 jne	 SHORT $LN45@z900_start
  00379	0f b6 44 24 5f	 movzx	 eax, BYTE PTR orb$[rsp+7]
  0037e	83 e0 3e	 and	 eax, 62			; 0000003eH
  00381	85 c0		 test	 eax, eax
  00383	75 17		 jne	 SHORT $LN45@z900_start
  00385	b8 01 00 00 00	 mov	 eax, 1
  0038a	48 6b c0 00	 imul	 rax, rax, 0
  0038e	0f b6 44 04 60	 movzx	 eax, BYTE PTR orb$[rsp+rax+8]
  00393	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00398	85 c0		 test	 eax, eax
  0039a	74 12		 je	 SHORT $LN44@z900_start
$LN45@z900_start:

; 566  :     )
; 567  :         ARCH_DEP( program_interrupt )( regs, PGM_OPERAND_EXCEPTION );

  0039c	ba 15 00 00 00	 mov	 edx, 21
  003a1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a9	e8 00 00 00 00	 call	 z900_program_interrupt
$LN44@z900_start:

; 568  : 
; 569  : #if !defined( FEATURE_INCORRECT_LENGTH_INDICATION_SUPPRESSION )
; 570  :     /* Program check if incorrect length suppression */
; 571  :     if (orb.flag7 & ORB7_L)
; 572  :         ARCH_DEP( program_interrupt )( regs, PGM_OPERAND_EXCEPTION );
; 573  : #endif
; 574  : 
; 575  : #if !defined( FEATURE_MIDAW_FACILITY )
; 576  :     /* Program check if modified indirect data addressing requested */
; 577  :     if (orb.flag7 & ORB7_D)
; 578  :         ARCH_DEP( program_interrupt )( regs, PGM_OPERAND_EXCEPTION );
; 579  : #endif
; 580  : 
; 581  :     /* Program check if the ssid including lcss is invalid */
; 582  :     SSID_CHECK( regs );

  003ae	b8 08 00 00 00	 mov	 eax, 8
  003b3	48 6b c0 01	 imul	 rax, rax, 1
  003b7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003bf	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  003c7	83 e0 01	 and	 eax, 1
  003ca	85 c0		 test	 eax, eax
  003cc	74 1e		 je	 SHORT $LN47@z900_start
  003ce	b8 08 00 00 00	 mov	 eax, 8
  003d3	48 6b c0 01	 imul	 rax, rax, 1
  003d7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003df	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  003e7	83 f8 03	 cmp	 eax, 3
  003ea	7e 1b		 jle	 SHORT $LN46@z900_start
$LN47@z900_start:
  003ec	ba 15 00 00 00	 mov	 edx, 21
  003f1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00401	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN46@z900_start:

; 583  : 
; 584  :     /* Locate the device block for this subchannel */
; 585  :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  00407	b8 08 00 00 00	 mov	 eax, 8
  0040c	48 6b c0 01	 imul	 rax, rax, 1
  00410	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00418	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  0041f	e8 00 00 00 00	 call	 find_device_by_subchan
  00424	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax

; 586  : 
; 587  :     if (dev)

  00429	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0042f	74 5a		 je	 SHORT $LN48@z900_start
$LN19@z900_start:

; 588  :         PTT( PTT_CL_IO, "SSCH (dev)", dev->devnum, 0, 0 );

  00431	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00438	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0043b	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00441	48 85 c0	 test	 rax, rax
  00444	74 3f		 je	 SHORT $LN49@z900_start
  00446	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0044b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0044f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00458	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00461	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195054
  00468	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0046d	45 33 c9	 xor	 r9d, r9d
  00470	44 8b c0	 mov	 r8d, eax
  00473	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195055
  0047a	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0047f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN49@z900_start:
  00485	33 c0		 xor	 eax, eax
  00487	85 c0		 test	 eax, eax
  00489	75 a6		 jne	 SHORT $LN19@z900_start
$LN48@z900_start:

; 589  : 
; 590  :     /* Condition code 3 if subchannel does not exist,
; 591  :        is not valid, is not enabled, or no path available */
; 592  :     if (0
; 593  :         || !dev
; 594  :         || !(dev->pmcw.flag5 & PMCW5_V)
; 595  :         || !(dev->pmcw.flag5 & PMCW5_E)
; 596  :         || !(orb.lpm & dev->pmcw.pam)

  0048b	33 c0		 xor	 eax, eax
  0048d	85 c0		 test	 eax, eax
  0048f	75 4b		 jne	 SHORT $LN51@z900_start
  00491	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00497	74 43		 je	 SHORT $LN51@z900_start
  00499	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0049e	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  004a5	83 e0 01	 and	 eax, 1
  004a8	85 c0		 test	 eax, eax
  004aa	74 30		 je	 SHORT $LN51@z900_start
  004ac	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  004b1	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  004b8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  004bd	85 c0		 test	 eax, eax
  004bf	74 1b		 je	 SHORT $LN51@z900_start
  004c1	0f b6 44 24 5e	 movzx	 eax, BYTE PTR orb$[rsp+6]
  004c6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  004cb	0f b6 89 fb 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+763]
  004d2	23 c1		 and	 eax, ecx
  004d4	85 c0		 test	 eax, eax
  004d6	0f 85 59 01 00
	00		 jne	 $LN50@z900_start
$LN51@z900_start:
$LN22@z900_start:

; 597  :     )
; 598  :     {
; 599  :         PTIO( ERR, "*SSCH" );

  004dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004e3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004e6	48 83 e0 10	 and	 rax, 16
  004ea	48 85 c0	 test	 rax, rax
  004ed	74 6b		 je	 SHORT $LN52@z900_start
  004ef	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f7	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  004fd	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00502	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00507	48 23 d1	 and	 rdx, rcx
  0050a	48 8b ca	 mov	 rcx, rdx
  0050d	8b c9		 mov	 ecx, ecx
  0050f	ba 08 00 00 00	 mov	 edx, 8
  00514	48 6b d2 01	 imul	 rdx, rdx, 1
  00518	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00520	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00528	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00531	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00536	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195059
  0053d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00542	44 8b c9	 mov	 r9d, ecx
  00545	44 8b c2	 mov	 r8d, edx
  00548	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195060
  0054f	b9 10 00 00 00	 mov	 ecx, 16
  00554	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN52@z900_start:
  0055a	33 c0		 xor	 eax, eax
  0055c	85 c0		 test	 eax, eax
  0055e	0f 85 78 ff ff
	ff		 jne	 $LN22@z900_start
$LN25@z900_start:

; 600  : #if defined( _FEATURE_IO_ASSIST )
; 601  :         PTIO( ERR, "*SSCH (sie)" );

  00564	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0056b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0056e	48 83 e0 10	 and	 rax, 16
  00572	48 85 c0	 test	 rax, rax
  00575	74 6b		 je	 SHORT $LN53@z900_start
  00577	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00585	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0058a	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0058f	48 23 d1	 and	 rdx, rcx
  00592	48 8b ca	 mov	 rcx, rdx
  00595	8b c9		 mov	 ecx, ecx
  00597	ba 08 00 00 00	 mov	 edx, 8
  0059c	48 6b d2 01	 imul	 rdx, rdx, 1
  005a0	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005a8	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  005b0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  005b9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195062
  005c5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005ca	44 8b c9	 mov	 r9d, ecx
  005cd	44 8b c2	 mov	 r8d, edx
  005d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195063
  005d7	b9 10 00 00 00	 mov	 ecx, 16
  005dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN53@z900_start:
  005e2	33 c0		 xor	 eax, eax
  005e4	85 c0		 test	 eax, eax
  005e6	0f 85 78 ff ff
	ff		 jne	 $LN25@z900_start
$LN28@z900_start:

; 602  :         SIE_INTERCEPT( regs );

  005ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005f4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  005fa	d1 e8		 shr	 eax, 1
  005fc	83 e0 01	 and	 eax, 1
  005ff	85 c0		 test	 eax, eax
  00601	74 1b		 je	 SHORT $LN54@z900_start
  00603	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0060b	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00611	ba fc ff ff ff	 mov	 edx, -4
  00616	48 8b c8	 mov	 rcx, rax
  00619	e8 00 00 00 00	 call	 longjmp
$LN54@z900_start:
  0061e	33 c0		 xor	 eax, eax
  00620	85 c0		 test	 eax, eax
  00622	75 c8		 jne	 SHORT $LN28@z900_start

; 603  : #endif
; 604  :         regs->psw.cc = 3;

  00624	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062c	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 605  :         return;

  00630	e9 0e 01 00 00	 jmp	 $LN1@z900_start
$LN50@z900_start:

; 606  :     }
; 607  : 
; 608  :     /* Perform serialization and checkpoint-synchronization */
; 609  :     PERFORM_SERIALIZATION( regs );

  00635	0f ae f0	 mfence
$LN31@z900_start:

; 610  :     PERFORM_CHKPT_SYNC( regs );

  00638	33 c0		 xor	 eax, eax
  0063a	85 c0		 test	 eax, eax
  0063c	75 fa		 jne	 SHORT $LN31@z900_start

; 611  : 
; 612  :     /* Clear the path not operational mask */
; 613  :     dev->pmcw.pnom = 0;

  0063e	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00643	c6 80 f5 02 00
	00 00		 mov	 BYTE PTR [rax+757], 0

; 614  : 
; 615  :     /* Copy the logical path mask */
; 616  :     dev->pmcw.lpm = orb.lpm;

  0064a	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0064f	0f b6 4c 24 5e	 movzx	 ecx, BYTE PTR orb$[rsp+6]
  00654	88 88 f4 02 00
	00		 mov	 BYTE PTR [rax+756], cl

; 617  : 
; 618  :     /* Start the channel program and set the condition code */
; 619  :     regs->psw.cc = ARCH_DEP( startio )( regs, dev, &orb );

  0065a	4c 8d 44 24 58	 lea	 r8, QWORD PTR orb$[rsp]
  0065f	48 8b 54 24 48	 mov	 rdx, QWORD PTR dev$[rsp]
  00664	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0066c	e8 00 00 00 00	 call	 z900_startio
  00671	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00679	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 620  : 
; 621  :     regs->siocount++;

  0067c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00684	8b 80 a0 07 00
	00		 mov	 eax, DWORD PTR [rax+1952]
  0068a	ff c0		 inc	 eax
  0068c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00694	89 81 a0 07 00
	00		 mov	 DWORD PTR [rcx+1952], eax

; 622  : 
; 623  :     /* Set the last path used mask */
; 624  :     if (regs->psw.cc == 0)

  0069a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006a2	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  006a6	85 c0		 test	 eax, eax
  006a8	75 11		 jne	 SHORT $LN55@z900_start

; 625  :         dev->pmcw.lpum = 0x80;

  006aa	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  006af	c6 80 f6 02 00
	00 80		 mov	 BYTE PTR [rax+758], 128	; 00000080H
  006b6	e9 88 00 00 00	 jmp	 $LN56@z900_start
$LN55@z900_start:
$LN34@z900_start:

; 626  :     else
; 627  :         PTIO( ERR, "*SSCH" );

  006bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  006c2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006c5	48 83 e0 10	 and	 rax, 16
  006c9	48 85 c0	 test	 rax, rax
  006cc	74 6b		 je	 SHORT $LN57@z900_start
  006ce	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006d6	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  006dc	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  006e1	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  006e6	48 23 d1	 and	 rdx, rcx
  006e9	48 8b ca	 mov	 rcx, rdx
  006ec	8b c9		 mov	 ecx, ecx
  006ee	ba 08 00 00 00	 mov	 edx, 8
  006f3	48 6b d2 01	 imul	 rdx, rdx, 1
  006f7	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  006ff	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00707	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00710	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00715	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195068
  0071c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00721	44 8b c9	 mov	 r9d, ecx
  00724	44 8b c2	 mov	 r8d, edx
  00727	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195069
  0072e	b9 10 00 00 00	 mov	 ecx, 16
  00733	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN57@z900_start:
  00739	33 c0		 xor	 eax, eax
  0073b	85 c0		 test	 eax, eax
  0073d	0f 85 78 ff ff
	ff		 jne	 $LN34@z900_start
$LN56@z900_start:
$LN1@z900_start:
$LN58@z900_start:

; 628  : }

  00743	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00748	48 33 cc	 xor	 rcx, rsp
  0074b	e8 00 00 00 00	 call	 __security_check_cookie
  00750	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00757	c3		 ret	 0
z900_start_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
chpid$ = 64
temp$1 = 68
b2$ = 72
tv180 = 76
effective_addr2$ = 80
inst$ = 112
regs$ = 120
z900_reset_channel_path PROC

; 341  : {

$LN27:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 342  : int     b2;                             /* Base of effective addr    */
; 343  : VADR    effective_addr2;                /* Effective address         */
; 344  : BYTE    chpid;
; 345  : 
; 346  :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 0c	 shr	 eax, 12
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  00041	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  00046	74 3e		 je	 SHORT $LN17@z900_reset
  00048	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0005f	48 03 c8	 add	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0006a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00076	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 23 c8	 and	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN17@z900_reset:
$LN4@z900_reset:
  00086	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008f	48 83 c0 04	 add	 rax, 4
  00093	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0009c	33 c0		 xor	 eax, eax
  0009e	83 f8 04	 cmp	 eax, 4
  000a1	74 0c		 je	 SHORT $LN18@z900_reset
  000a3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN18@z900_reset:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 d1		 jne	 SHORT $LN4@z900_reset
$LN7@z900_reset:

; 347  : 
; 348  :     TXF_INSTR_CHECK( regs );

  000b5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c1	85 c0		 test	 eax, eax
  000c3	74 36		 je	 SHORT $LN19@z900_reset
  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000d0	0f ba e8 0c	 bts	 eax, 12
  000d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d9	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000df	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194731
  000e6	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000ec	ba 02 00 00 00	 mov	 edx, 2
  000f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	e8 00 00 00 00	 call	 z900_abort_transaction
$LN19@z900_reset:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 b4		 jne	 SHORT $LN7@z900_reset

; 349  :     PRIV_CHECK(regs);

  00101	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00106	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0010a	83 e0 01	 and	 eax, 1
  0010d	85 c0		 test	 eax, eax
  0010f	74 15		 je	 SHORT $LN20@z900_reset
  00111	ba 02 00 00 00	 mov	 edx, 2
  00116	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00120	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN20@z900_reset:
$LN10@z900_reset:

; 350  :     SIE_INTERCEPT(regs);

  00126	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00131	d1 e8		 shr	 eax, 1
  00133	83 e0 01	 and	 eax, 1
  00136	85 c0		 test	 eax, eax
  00138	74 18		 je	 SHORT $LN21@z900_reset
  0013a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00145	ba fc ff ff ff	 mov	 edx, -4
  0014a	48 8b c8	 mov	 rcx, rax
  0014d	e8 00 00 00 00	 call	 longjmp
$LN21@z900_reset:
  00152	33 c0		 xor	 eax, eax
  00154	85 c0		 test	 eax, eax
  00156	75 ce		 jne	 SHORT $LN10@z900_reset
$LN13@z900_reset:

; 351  : 
; 352  :     PTIO(IO,"RCHP");

  00158	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0015f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00162	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00168	48 85 c0	 test	 rax, rax
  0016b	74 65		 je	 SHORT $LN22@z900_reset
  0016d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00172	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00178	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0017d	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00182	48 23 d1	 and	 rdx, rcx
  00185	48 8b ca	 mov	 rcx, rdx
  00188	8b c9		 mov	 ecx, ecx
  0018a	ba 08 00 00 00	 mov	 edx, 8
  0018f	48 6b d2 01	 imul	 rdx, rdx, 1
  00193	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00198	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001a0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001a9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194735
  001b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ba	44 8b c9	 mov	 r9d, ecx
  001bd	44 8b c2	 mov	 r8d, edx
  001c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194736
  001c7	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@z900_reset:
  001d2	33 c0		 xor	 eax, eax
  001d4	85 c0		 test	 eax, eax
  001d6	75 80		 jne	 SHORT $LN13@z900_reset

; 353  : 
; 354  :     /* Program check if reg 1 bits 0-23 not zero */
; 355  :     if(regs->GR_L(1) & 0xFFFFFF00)

  001d8	b8 08 00 00 00	 mov	 eax, 8
  001dd	48 6b c0 01	 imul	 rax, rax, 1
  001e1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001e6	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001ed	25 00 ff ff ff	 and	 eax, -256		; ffffff00H
  001f2	85 c0		 test	 eax, eax
  001f4	74 0f		 je	 SHORT $LN23@z900_reset

; 356  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  001f6	ba 15 00 00 00	 mov	 edx, 21
  001fb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00200	e8 00 00 00 00	 call	 z900_program_interrupt
$LN23@z900_reset:

; 357  : 
; 358  :     chpid = regs->GR_L(1) & 0xFF;

  00205	b8 08 00 00 00	 mov	 eax, 8
  0020a	48 6b c0 01	 imul	 rax, rax, 1
  0020e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00213	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0021a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0021f	88 44 24 40	 mov	 BYTE PTR chpid$[rsp], al

; 359  : 
; 360  :     if((regs->psw.cc = chp_reset(chpid, 1)) != 0)

  00223	ba 01 00 00 00	 mov	 edx, 1
  00228	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR chpid$[rsp]
  0022d	e8 00 00 00 00	 call	 chp_reset
  00232	89 44 24 4c	 mov	 DWORD PTR tv180[rsp], eax
  00236	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0023b	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR tv180[rsp]
  00240	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00243	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv180[rsp]
  00248	85 c0		 test	 eax, eax
  0024a	0f 84 96 00 00
	00		 je	 $LN24@z900_reset
$LN16@z900_reset:

; 361  :     {
; 362  :         PTIO(ERR,"*RCHP");

  00250	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00257	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0025a	48 83 e0 10	 and	 rax, 16
  0025e	48 85 c0	 test	 rax, rax
  00261	74 65		 je	 SHORT $LN25@z900_reset
  00263	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00268	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0026e	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00273	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00278	48 23 d1	 and	 rdx, rcx
  0027b	48 8b ca	 mov	 rcx, rdx
  0027e	8b c9		 mov	 ecx, ecx
  00280	ba 08 00 00 00	 mov	 edx, 8
  00285	48 6b d2 01	 imul	 rdx, rdx, 1
  00289	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0028e	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00296	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0029f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194740
  002ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b0	44 8b c9	 mov	 r9d, ecx
  002b3	44 8b c2	 mov	 r8d, edx
  002b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194741
  002bd	b9 10 00 00 00	 mov	 ecx, 16
  002c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN25@z900_reset:
  002c8	33 c0		 xor	 eax, eax
  002ca	85 c0		 test	 eax, eax
  002cc	75 82		 jne	 SHORT $LN16@z900_reset

; 363  :         RETURN_INTCHECK(regs);

  002ce	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002d3	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  002d9	ba ff ff ff ff	 mov	 edx, -1
  002de	48 8b c8	 mov	 rcx, rax
  002e1	e8 00 00 00 00	 call	 longjmp
$LN24@z900_reset:
$LN26@z900_reset:

; 364  :     }
; 365  : }

  002e6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002ea	c3		 ret	 0
z900_reset_channel_path ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
zone$1 = 64
temp$2 = 68
b2$ = 72
tv281 = 76
effective_addr2$ = 80
inst$ = 112
regs$ = 120
z900_set_channel_monitor PROC

; 453  : {

$LN39:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 454  : int     b2;                             /* Effective addr base       */
; 455  : VADR    effective_addr2;                /* Effective address         */
; 456  : 
; 457  :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 44	 mov	 DWORD PTR temp$2[rsp], eax
  00023	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 44	 mov	 eax, DWORD PTR temp$2[rsp]
  00037	c1 e8 0c	 shr	 eax, 12
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  00041	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  00046	74 3e		 je	 SHORT $LN17@z900_set_c
  00048	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0005f	48 03 c8	 add	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0006a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00076	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 23 c8	 and	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN17@z900_set_c:
$LN4@z900_set_c:
  00086	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008f	48 83 c0 04	 add	 rax, 4
  00093	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0009c	33 c0		 xor	 eax, eax
  0009e	83 f8 04	 cmp	 eax, 4
  000a1	74 0c		 je	 SHORT $LN18@z900_set_c
  000a3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN18@z900_set_c:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 d1		 jne	 SHORT $LN4@z900_set_c
$LN7@z900_set_c:

; 458  : 
; 459  :     TXF_INSTR_CHECK( regs );

  000b5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c1	85 c0		 test	 eax, eax
  000c3	74 36		 je	 SHORT $LN19@z900_set_c
  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000d0	0f ba e8 0c	 bts	 eax, 12
  000d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d9	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000df	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194929
  000e6	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000ec	ba 02 00 00 00	 mov	 edx, 2
  000f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	e8 00 00 00 00	 call	 z900_abort_transaction
$LN19@z900_set_c:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 b4		 jne	 SHORT $LN7@z900_set_c

; 460  :     PRIV_CHECK(regs);

  00101	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00106	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0010a	83 e0 01	 and	 eax, 1
  0010d	85 c0		 test	 eax, eax
  0010f	74 15		 je	 SHORT $LN20@z900_set_c
  00111	ba 02 00 00 00	 mov	 edx, 2
  00116	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00120	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN20@z900_set_c:

; 461  : 
; 462  : #if defined(_FEATURE_IO_ASSIST)
; 463  :     if(SIE_STATE_BIT_OFF(regs, EC0, IOA) && !regs->sie_pref)

  00126	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00131	d1 e8		 shr	 eax, 1
  00133	83 e0 01	 and	 eax, 1
  00136	85 c0		 test	 eax, eax
  00138	74 68		 je	 SHORT $LN21@z900_set_c
  0013a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00146	b9 01 00 00 00	 mov	 ecx, 1
  0014b	48 6b c9 00	 imul	 rcx, rcx, 0
  0014f	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00154	83 e0 04	 and	 eax, 4
  00157	85 c0		 test	 eax, eax
  00159	75 47		 jne	 SHORT $LN21@z900_set_c
  0015b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00160	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00166	c1 e8 02	 shr	 eax, 2
  00169	83 e0 01	 and	 eax, 1
  0016c	85 c0		 test	 eax, eax
  0016e	75 32		 jne	 SHORT $LN21@z900_set_c
$LN10@z900_set_c:

; 464  : #endif
; 465  :         SIE_INTERCEPT(regs);

  00170	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00175	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0017b	d1 e8		 shr	 eax, 1
  0017d	83 e0 01	 and	 eax, 1
  00180	85 c0		 test	 eax, eax
  00182	74 18		 je	 SHORT $LN22@z900_set_c
  00184	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00189	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0018f	ba fc ff ff ff	 mov	 edx, -4
  00194	48 8b c8	 mov	 rcx, rax
  00197	e8 00 00 00 00	 call	 longjmp
$LN22@z900_set_c:
  0019c	33 c0		 xor	 eax, eax
  0019e	85 c0		 test	 eax, eax
  001a0	75 ce		 jne	 SHORT $LN10@z900_set_c
$LN21@z900_set_c:
$LN13@z900_set_c:

; 466  : 
; 467  :     PTIO(IO,"SCHM");

  001a2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001a9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001ac	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001b2	48 85 c0	 test	 rax, rax
  001b5	74 65		 je	 SHORT $LN23@z900_set_c
  001b7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001c2	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  001c7	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001cc	48 23 d1	 and	 rdx, rcx
  001cf	48 8b ca	 mov	 rcx, rdx
  001d2	8b c9		 mov	 ecx, ecx
  001d4	ba 08 00 00 00	 mov	 edx, 8
  001d9	48 6b d2 01	 imul	 rdx, rdx, 1
  001dd	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001e2	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001ea	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001f3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194934
  001ff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00204	44 8b c9	 mov	 r9d, ecx
  00207	44 8b c2	 mov	 r8d, edx
  0020a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194935
  00211	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN23@z900_set_c:
  0021c	33 c0		 xor	 eax, eax
  0021e	85 c0		 test	 eax, eax
  00220	75 80		 jne	 SHORT $LN13@z900_set_c

; 468  : 
; 469  :     /* Reserved bits in gpr1 must be zero */
; 470  :     if (regs->GR_L(1) & CHM_GPR1_RESV)

  00222	b8 08 00 00 00	 mov	 eax, 8
  00227	48 6b c0 01	 imul	 rax, rax, 1
  0022b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00230	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00237	25 fc ff 00 0e	 and	 eax, 234946556		; 0e00fffcH
  0023c	85 c0		 test	 eax, eax
  0023e	74 0f		 je	 SHORT $LN24@z900_set_c

; 471  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  00240	ba 15 00 00 00	 mov	 edx, 21
  00245	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0024a	e8 00 00 00 00	 call	 z900_program_interrupt
$LN24@z900_set_c:

; 472  : 
; 473  :     /* Program check if M bit one and gpr2 address not on
; 474  :        a 32 byte boundary or highorder bit set in ESA/390 mode */
; 475  :     if ((regs->GR_L(1) & CHM_GPR1_M)
; 476  :      && (regs->GR_L(2) & CHM_GPR2_RESV))

  0024f	b8 08 00 00 00	 mov	 eax, 8
  00254	48 6b c0 01	 imul	 rax, rax, 1
  00258	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00264	83 e0 02	 and	 eax, 2
  00267	85 c0		 test	 eax, eax
  00269	74 2b		 je	 SHORT $LN25@z900_set_c
  0026b	b8 08 00 00 00	 mov	 eax, 8
  00270	48 6b c0 02	 imul	 rax, rax, 2
  00274	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00279	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00280	83 e0 1f	 and	 eax, 31
  00283	85 c0		 test	 eax, eax
  00285	74 0f		 je	 SHORT $LN25@z900_set_c

; 477  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  00287	ba 15 00 00 00	 mov	 edx, 21
  0028c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00291	e8 00 00 00 00	 call	 z900_program_interrupt
$LN25@z900_set_c:

; 478  : 
; 479  : #if defined(_FEATURE_IO_ASSIST)
; 480  :     /* Virtual use of I/O Assist features must be intercepted */
; 481  :     if(SIE_MODE(regs)
; 482  :       && ( (regs->GR_L(1) & CHM_GPR1_ZONE)

  00296	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0029b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  002a1	d1 e8		 shr	 eax, 1
  002a3	83 e0 01	 and	 eax, 1
  002a6	85 c0		 test	 eax, eax
  002a8	74 6e		 je	 SHORT $LN26@z900_set_c
  002aa	b8 08 00 00 00	 mov	 eax, 8
  002af	48 6b c0 01	 imul	 rax, rax, 1
  002b3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002b8	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002bf	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  002c4	85 c0		 test	 eax, eax
  002c6	75 1e		 jne	 SHORT $LN27@z900_set_c
  002c8	b8 08 00 00 00	 mov	 eax, 8
  002cd	48 6b c0 01	 imul	 rax, rax, 1
  002d1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002dd	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  002e2	85 c0		 test	 eax, eax
  002e4	74 32		 je	 SHORT $LN26@z900_set_c
$LN27@z900_set_c:
$LN16@z900_set_c:

; 483  :         || (regs->GR_L(1) & CHM_GPR1_A) ))
; 484  :         SIE_INTERCEPT(regs);

  002e6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002eb	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  002f1	d1 e8		 shr	 eax, 1
  002f3	83 e0 01	 and	 eax, 1
  002f6	85 c0		 test	 eax, eax
  002f8	74 18		 je	 SHORT $LN28@z900_set_c
  002fa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002ff	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00305	ba fc ff ff ff	 mov	 edx, -4
  0030a	48 8b c8	 mov	 rcx, rax
  0030d	e8 00 00 00 00	 call	 longjmp
$LN28@z900_set_c:
  00312	33 c0		 xor	 eax, eax
  00314	85 c0		 test	 eax, eax
  00316	75 ce		 jne	 SHORT $LN16@z900_set_c
$LN26@z900_set_c:

; 485  : 
; 486  :     /* Zone must be a valid zone number */
; 487  :     if (((regs->GR_L(1) & CHM_GPR1_ZONE) >> 16) >= FEATURE_SIE_MAXZONES)

  00318	b8 08 00 00 00	 mov	 eax, 8
  0031d	48 6b c0 01	 imul	 rax, rax, 1
  00321	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00326	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0032d	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00332	c1 e8 10	 shr	 eax, 16
  00335	83 f8 08	 cmp	 eax, 8
  00338	72 0f		 jb	 SHORT $LN29@z900_set_c

; 488  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  0033a	ba 15 00 00 00	 mov	 edx, 21
  0033f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00344	e8 00 00 00 00	 call	 z900_program_interrupt
$LN29@z900_set_c:

; 489  : 
; 490  :     if(regs->GR_L(1) & CHM_GPR1_A)

  00349	b8 08 00 00 00	 mov	 eax, 8
  0034e	48 6b c0 01	 imul	 rax, rax, 1
  00352	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00357	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0035e	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00363	85 c0		 test	 eax, eax
  00365	0f 84 b8 00 00
	00		 je	 $LN30@z900_set_c

; 491  : #endif /*defined(_FEATURE_IO_ASSIST)*/
; 492  :     {
; 493  :         /* Set the measurement block origin address */
; 494  :         if (regs->GR_L(1) & CHM_GPR1_M)

  0036b	b8 08 00 00 00	 mov	 eax, 8
  00370	48 6b c0 01	 imul	 rax, rax, 1
  00374	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00379	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00380	83 e0 02	 and	 eax, 2
  00383	85 c0		 test	 eax, eax
  00385	74 61		 je	 SHORT $LN32@z900_set_c

; 495  :         {
; 496  :             sysblk.mbo = regs->GR(2);

  00387	b8 08 00 00 00	 mov	 eax, 8
  0038c	48 6b c0 02	 imul	 rax, rax, 2
  00390	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00397	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0039c	48 8b 84 02 80
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax+640]
  003a4	48 89 81 f0 10
	00 00		 mov	 QWORD PTR [rcx+4336], rax

; 497  :             sysblk.mbk = (regs->GR_L(1) & CHM_GPR1_MBK) >> 24;

  003ab	b8 08 00 00 00	 mov	 eax, 8
  003b0	48 6b c0 01	 imul	 rax, rax, 1
  003b4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003b9	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  003c0	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  003c5	c1 e8 18	 shr	 eax, 24
  003c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003cf	88 81 f8 10 00
	00		 mov	 BYTE PTR [rcx+4344], al

; 498  :             sysblk.mbm = 1;

  003d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003dc	c7 80 fc 10 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4348], 1

; 499  :         }

  003e6	eb 11		 jmp	 SHORT $LN33@z900_set_c
$LN32@z900_set_c:

; 500  :         else
; 501  :             sysblk.mbm = 0;

  003e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003ef	c7 80 fc 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4348], 0
$LN33@z900_set_c:

; 502  : 
; 503  :         sysblk.mbd = regs->GR_L(1) & CHM_GPR1_D;

  003f9	b8 08 00 00 00	 mov	 eax, 8
  003fe	48 6b c0 01	 imul	 rax, rax, 1
  00402	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00407	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0040e	83 e0 01	 and	 eax, 1
  00411	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00418	89 81 00 11 00
	00		 mov	 DWORD PTR [rcx+4352], eax

; 504  : 
; 505  :     }

  0041e	e9 38 01 00 00	 jmp	 $LN31@z900_set_c
$LN30@z900_set_c:

; 506  : #if defined(_FEATURE_IO_ASSIST)
; 507  :     else
; 508  :     {
; 509  :     int zone = SIE_MODE(regs) ? regs->siebk->zone :

  00423	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00428	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0042e	d1 e8		 shr	 eax, 1
  00430	83 e0 01	 and	 eax, 1
  00433	85 c0		 test	 eax, eax
  00435	74 16		 je	 SHORT $LN37@z900_set_c
  00437	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0043c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00443	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00447	89 44 24 4c	 mov	 DWORD PTR tv281[rsp], eax
  0044b	eb 21		 jmp	 SHORT $LN38@z900_set_c
$LN37@z900_set_c:
  0044d	b8 08 00 00 00	 mov	 eax, 8
  00452	48 6b c0 01	 imul	 rax, rax, 1
  00456	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0045b	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00462	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00467	c1 e8 10	 shr	 eax, 16
  0046a	89 44 24 4c	 mov	 DWORD PTR tv281[rsp], eax
$LN38@z900_set_c:
  0046e	8b 44 24 4c	 mov	 eax, DWORD PTR tv281[rsp]
  00472	89 44 24 40	 mov	 DWORD PTR zone$1[rsp], eax

; 510  :                                ((regs->GR_L(1) & CHM_GPR1_ZONE) >> 16);
; 511  : 
; 512  :         /* Set the measurement block origin address */
; 513  :         if (regs->GR_L(1) & CHM_GPR1_M)

  00476	b8 08 00 00 00	 mov	 eax, 8
  0047b	48 6b c0 01	 imul	 rax, rax, 1
  0047f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00484	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0048b	83 e0 02	 and	 eax, 2
  0048e	85 c0		 test	 eax, eax
  00490	74 7f		 je	 SHORT $LN34@z900_set_c

; 514  :         {
; 515  :             sysblk.zpb[zone].mbo = regs->GR(2);

  00492	b8 08 00 00 00	 mov	 eax, 8
  00497	48 6b c0 02	 imul	 rax, rax, 2
  0049b	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR zone$1[rsp]
  004a0	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  004a4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004ab	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  004b0	49 8b 84 00 80
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+640]
  004b8	48 89 84 0a c0
	0e 00 00	 mov	 QWORD PTR [rdx+rcx+3776], rax

; 516  :             sysblk.zpb[zone].mbk = (regs->GR_L(1) & CHM_GPR1_MBK) >> 24;

  004c0	b8 08 00 00 00	 mov	 eax, 8
  004c5	48 6b c0 01	 imul	 rax, rax, 1
  004c9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  004ce	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  004d5	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  004da	c1 e8 18	 shr	 eax, 24
  004dd	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR zone$1[rsp]
  004e2	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  004e6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004ed	88 84 0a c8 0e
	00 00		 mov	 BYTE PTR [rdx+rcx+3784], al

; 517  :             sysblk.zpb[zone].mbm = 1;

  004f4	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$1[rsp]
  004f9	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  004fd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00504	c7 84 01 cc 0e
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+3788], 1

; 518  :         }

  0050f	eb 1b		 jmp	 SHORT $LN35@z900_set_c
$LN34@z900_set_c:

; 519  :         else
; 520  :             sysblk.zpb[zone].mbm = 0;

  00511	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$1[rsp]
  00516	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0051a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00521	c7 84 01 cc 0e
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+3788], 0
$LN35@z900_set_c:

; 521  : 
; 522  :         sysblk.zpb[zone].mbd = regs->GR_L(1) & CHM_GPR1_D;

  0052c	b8 08 00 00 00	 mov	 eax, 8
  00531	48 6b c0 01	 imul	 rax, rax, 1
  00535	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0053a	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00541	83 e0 01	 and	 eax, 1
  00544	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR zone$1[rsp]
  00549	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  0054d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00554	89 84 0a d0 0e
	00 00		 mov	 DWORD PTR [rdx+rcx+3792], eax
$LN31@z900_set_c:
$LN36@z900_set_c:

; 523  : 
; 524  :     }
; 525  : #endif /*defined(_FEATURE_IO_ASSIST)*/
; 526  : 
; 527  : }

  0055b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0055f	c3		 ret	 0
z900_set_channel_monitor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
temp$1 = 64
b2$ = 68
effective_addr2$ = 72
inst$ = 96
regs$ = 104
z900_set_address_limit PROC

; 430  : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 431  : int     b2;                             /* Effective addr base       */
; 432  : VADR    effective_addr2;                /* Effective address         */
; 433  : 
; 434  :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 0c	 shr	 eax, 12
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  00041	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  00046	74 3e		 je	 SHORT $LN14@z900_set_a
  00048	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0005f	48 03 c8	 add	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00076	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 23 c8	 and	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN14@z900_set_a:
$LN4@z900_set_a:
  00086	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008f	48 83 c0 04	 add	 rax, 4
  00093	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0009c	33 c0		 xor	 eax, eax
  0009e	83 f8 04	 cmp	 eax, 4
  000a1	74 0c		 je	 SHORT $LN15@z900_set_a
  000a3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN15@z900_set_a:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 d1		 jne	 SHORT $LN4@z900_set_a
$LN7@z900_set_a:

; 435  : 
; 436  :     TXF_INSTR_CHECK( regs );

  000b5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c1	85 c0		 test	 eax, eax
  000c3	74 36		 je	 SHORT $LN16@z900_set_a
  000c5	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000d0	0f ba e8 0c	 bts	 eax, 12
  000d4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000d9	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000df	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194886
  000e6	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000ec	ba 02 00 00 00	 mov	 edx, 2
  000f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	e8 00 00 00 00	 call	 z900_abort_transaction
$LN16@z900_set_a:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 b4		 jne	 SHORT $LN7@z900_set_a

; 437  :     PRIV_CHECK(regs);

  00101	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00106	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0010a	83 e0 01	 and	 eax, 1
  0010d	85 c0		 test	 eax, eax
  0010f	74 15		 je	 SHORT $LN17@z900_set_a
  00111	ba 02 00 00 00	 mov	 edx, 2
  00116	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00120	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_set_a:
$LN10@z900_set_a:

; 438  :     SIE_INTERCEPT(regs);

  00126	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00131	d1 e8		 shr	 eax, 1
  00133	83 e0 01	 and	 eax, 1
  00136	85 c0		 test	 eax, eax
  00138	74 18		 je	 SHORT $LN18@z900_set_a
  0013a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00145	ba fc ff ff ff	 mov	 edx, -4
  0014a	48 8b c8	 mov	 rcx, rax
  0014d	e8 00 00 00 00	 call	 longjmp
$LN18@z900_set_a:
  00152	33 c0		 xor	 eax, eax
  00154	85 c0		 test	 eax, eax
  00156	75 ce		 jne	 SHORT $LN10@z900_set_a
$LN13@z900_set_a:

; 439  : 
; 440  :     PTIO(IO,"SAL");

  00158	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0015f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00162	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00168	48 85 c0	 test	 rax, rax
  0016b	74 65		 je	 SHORT $LN19@z900_set_a
  0016d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00172	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00178	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0017d	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00182	48 23 d1	 and	 rdx, rcx
  00185	48 8b ca	 mov	 rcx, rdx
  00188	8b c9		 mov	 ecx, ecx
  0018a	ba 08 00 00 00	 mov	 edx, 8
  0018f	48 6b d2 01	 imul	 rdx, rdx, 1
  00193	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00198	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001a0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001a9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194890
  001b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ba	44 8b c9	 mov	 r9d, ecx
  001bd	44 8b c2	 mov	 r8d, edx
  001c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194891
  001c7	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN19@z900_set_a:
  001d2	33 c0		 xor	 eax, eax
  001d4	85 c0		 test	 eax, eax
  001d6	75 80		 jne	 SHORT $LN13@z900_set_a

; 441  : 
; 442  :     if(regs->GR_L(1) & 0x8000FFFF)

  001d8	b8 08 00 00 00	 mov	 eax, 8
  001dd	48 6b c0 01	 imul	 rax, rax, 1
  001e1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001e6	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001ed	25 ff ff 00 80	 and	 eax, -2147418113	; 8000ffffH
  001f2	85 c0		 test	 eax, eax
  001f4	74 11		 je	 SHORT $LN20@z900_set_a

; 443  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  001f6	ba 15 00 00 00	 mov	 edx, 21
  001fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00200	e8 00 00 00 00	 call	 z900_program_interrupt
  00205	eb 23		 jmp	 SHORT $LN21@z900_set_a
$LN20@z900_set_a:

; 444  :     else
; 445  :         sysblk.addrlimval = regs->GR_L(1);

  00207	b8 08 00 00 00	 mov	 eax, 8
  0020c	48 6b c0 01	 imul	 rax, rax, 1
  00210	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00215	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0021c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00223	48 89 81 60 12
	00 00		 mov	 QWORD PTR [rcx+4704], rax
$LN21@z900_set_a:
$LN22@z900_set_a:

; 446  : }

  0022a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0022e	c3		 ret	 0
z900_set_address_limit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
temp$1 = 64
b2$ = 68
tv295 = 72
effective_addr2$ = 80
dev$ = 88
inst$ = 112
regs$ = 120
z900_resume_subchannel PROC

; 372  : {

$LN52:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 373  : int     b2;                             /* Effective addr base       */
; 374  : VADR    effective_addr2;                /* Effective address         */
; 375  : DEVBLK* dev;                            /* -> device block           */
; 376  : 
; 377  :     S( inst, regs, b2, effective_addr2 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 0c	 shr	 eax, 12
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  00041	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  00046	74 3e		 je	 SHORT $LN32@z900_resum
  00048	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0005f	48 03 c8	 add	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0006a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00076	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 23 c8	 and	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN32@z900_resum:
$LN4@z900_resum:
  00086	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008f	48 83 c0 04	 add	 rax, 4
  00093	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0009c	33 c0		 xor	 eax, eax
  0009e	83 f8 04	 cmp	 eax, 4
  000a1	74 0c		 je	 SHORT $LN33@z900_resum
  000a3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN33@z900_resum:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 d1		 jne	 SHORT $LN4@z900_resum
$LN7@z900_resum:

; 378  : 
; 379  :     TXF_INSTR_CHECK( regs );

  000b5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c1	85 c0		 test	 eax, eax
  000c3	74 36		 je	 SHORT $LN34@z900_resum
  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000d0	0f ba e8 0c	 bts	 eax, 12
  000d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d9	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000df	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194826
  000e6	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000ec	ba 02 00 00 00	 mov	 edx, 2
  000f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	e8 00 00 00 00	 call	 z900_abort_transaction
$LN34@z900_resum:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 b4		 jne	 SHORT $LN7@z900_resum

; 380  :     PRIV_CHECK( regs );

  00101	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00106	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0010a	83 e0 01	 and	 eax, 1
  0010d	85 c0		 test	 eax, eax
  0010f	74 15		 je	 SHORT $LN35@z900_resum
  00111	ba 02 00 00 00	 mov	 edx, 2
  00116	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00120	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN35@z900_resum:
$LN10@z900_resum:

; 381  : 
; 382  :     PTIO( IO, "RSCH" );

  00126	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0012d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00130	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00136	48 85 c0	 test	 rax, rax
  00139	74 65		 je	 SHORT $LN36@z900_resum
  0013b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00140	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00146	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0014b	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00150	48 23 d1	 and	 rdx, rcx
  00153	48 8b ca	 mov	 rcx, rdx
  00156	8b c9		 mov	 ecx, ecx
  00158	ba 08 00 00 00	 mov	 edx, 8
  0015d	48 6b d2 01	 imul	 rdx, rdx, 1
  00161	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00166	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0016e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00177	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0017c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194829
  00183	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00188	44 8b c9	 mov	 r9d, ecx
  0018b	44 8b c2	 mov	 r8d, edx
  0018e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194830
  00195	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@z900_resum:
  001a0	33 c0		 xor	 eax, eax
  001a2	85 c0		 test	 eax, eax
  001a4	75 80		 jne	 SHORT $LN10@z900_resum

; 383  : 
; 384  : #if defined( _FEATURE_IO_ASSIST )
; 385  :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  001a6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001ab	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001b1	d1 e8		 shr	 eax, 1
  001b3	83 e0 01	 and	 eax, 1
  001b6	85 c0		 test	 eax, eax
  001b8	0f 84 f0 00 00
	00		 je	 $LN37@z900_resum
  001be	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c3	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  001ca	b9 01 00 00 00	 mov	 ecx, 1
  001cf	48 6b c9 00	 imul	 rcx, rcx, 0
  001d3	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  001d8	83 e0 04	 and	 eax, 4
  001db	85 c0		 test	 eax, eax
  001dd	0f 85 cb 00 00
	00		 jne	 $LN37@z900_resum
  001e3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001ee	c1 e8 02	 shr	 eax, 2
  001f1	83 e0 01	 and	 eax, 1
  001f4	85 c0		 test	 eax, eax
  001f6	0f 85 b2 00 00
	00		 jne	 $LN37@z900_resum
$LN13@z900_resum:

; 386  : #endif
; 387  :     {
; 388  :         PTIO( IO, "RSCH (sie)" );

  001fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00203	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00206	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0020c	48 85 c0	 test	 rax, rax
  0020f	74 65		 je	 SHORT $LN38@z900_resum
  00211	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00216	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0021c	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00221	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00226	48 23 d1	 and	 rdx, rcx
  00229	48 8b ca	 mov	 rcx, rdx
  0022c	8b c9		 mov	 ecx, ecx
  0022e	ba 08 00 00 00	 mov	 edx, 8
  00233	48 6b d2 01	 imul	 rdx, rdx, 1
  00237	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0023c	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00244	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0024d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00252	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194833
  00259	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025e	44 8b c9	 mov	 r9d, ecx
  00261	44 8b c2	 mov	 r8d, edx
  00264	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194834
  0026b	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00270	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN38@z900_resum:
  00276	33 c0		 xor	 eax, eax
  00278	85 c0		 test	 eax, eax
  0027a	75 80		 jne	 SHORT $LN13@z900_resum
$LN16@z900_resum:

; 389  :         SIE_INTERCEPT( regs );

  0027c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00281	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00287	d1 e8		 shr	 eax, 1
  00289	83 e0 01	 and	 eax, 1
  0028c	85 c0		 test	 eax, eax
  0028e	74 18		 je	 SHORT $LN39@z900_resum
  00290	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00295	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0029b	ba fc ff ff ff	 mov	 edx, -4
  002a0	48 8b c8	 mov	 rcx, rax
  002a3	e8 00 00 00 00	 call	 longjmp
$LN39@z900_resum:
  002a8	33 c0		 xor	 eax, eax
  002aa	85 c0		 test	 eax, eax
  002ac	75 ce		 jne	 SHORT $LN16@z900_resum
$LN37@z900_resum:

; 390  :     }
; 391  : 
; 392  :     /* Program check if the ssid including lcss is invalid */
; 393  :     SSID_CHECK( regs );

  002ae	b8 08 00 00 00	 mov	 eax, 8
  002b3	48 6b c0 01	 imul	 rax, rax, 1
  002b7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002bc	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002c4	83 e0 01	 and	 eax, 1
  002c7	85 c0		 test	 eax, eax
  002c9	74 1b		 je	 SHORT $LN41@z900_resum
  002cb	b8 08 00 00 00	 mov	 eax, 8
  002d0	48 6b c0 01	 imul	 rax, rax, 1
  002d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002d9	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002e1	83 f8 03	 cmp	 eax, 3
  002e4	7e 15		 jle	 SHORT $LN40@z900_resum
$LN41@z900_resum:
  002e6	ba 15 00 00 00	 mov	 edx, 21
  002eb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002f0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN40@z900_resum:

; 394  : 
; 395  :     /* Locate the device block for this subchannel */
; 396  :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  002fb	b8 08 00 00 00	 mov	 eax, 8
  00300	48 6b c0 01	 imul	 rax, rax, 1
  00304	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  00310	e8 00 00 00 00	 call	 find_device_by_subchan
  00315	48 89 44 24 58	 mov	 QWORD PTR dev$[rsp], rax

; 397  : 
; 398  :     if (dev)

  0031a	48 83 7c 24 58
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00320	74 5a		 je	 SHORT $LN42@z900_resum
$LN19@z900_resum:

; 399  :         PTT( PTT_CL_IO, "RSCH (dev)", dev->devnum, 0, 0 );

  00322	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00329	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0032c	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00332	48 85 c0	 test	 rax, rax
  00335	74 3f		 je	 SHORT $LN43@z900_resum
  00337	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  0033c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00340	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00349	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00352	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194840
  00359	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0035e	45 33 c9	 xor	 r9d, r9d
  00361	44 8b c0	 mov	 r8d, eax
  00364	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194841
  0036b	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00370	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN43@z900_resum:
  00376	33 c0		 xor	 eax, eax
  00378	85 c0		 test	 eax, eax
  0037a	75 a6		 jne	 SHORT $LN19@z900_resum
$LN42@z900_resum:

; 400  : 
; 401  :     /* Condition code 3 if subchannel does not exist,
; 402  :        is not valid, or is not enabled */
; 403  :     if (0
; 404  :         || !dev
; 405  :         || !(dev->pmcw.flag5 & PMCW5_V)
; 406  :         || !(dev->pmcw.flag5 & PMCW5_E)

  0037c	33 c0		 xor	 eax, eax
  0037e	85 c0		 test	 eax, eax
  00380	75 34		 jne	 SHORT $LN45@z900_resum
  00382	48 83 7c 24 58
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00388	74 2c		 je	 SHORT $LN45@z900_resum
  0038a	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  0038f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00396	83 e0 01	 and	 eax, 1
  00399	85 c0		 test	 eax, eax
  0039b	74 19		 je	 SHORT $LN45@z900_resum
  0039d	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  003a2	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  003a9	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003ae	85 c0		 test	 eax, eax
  003b0	0f 85 3c 01 00
	00		 jne	 $LN44@z900_resum
$LN45@z900_resum:
$LN22@z900_resum:

; 407  :     )
; 408  :     {
; 409  :         PTIO( ERR, "*RSCH" );

  003b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003c0	48 83 e0 10	 and	 rax, 16
  003c4	48 85 c0	 test	 rax, rax
  003c7	74 65		 je	 SHORT $LN46@z900_resum
  003c9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003ce	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003d4	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  003d9	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  003de	48 23 d1	 and	 rdx, rcx
  003e1	48 8b ca	 mov	 rcx, rdx
  003e4	8b c9		 mov	 ecx, ecx
  003e6	ba 08 00 00 00	 mov	 edx, 8
  003eb	48 6b d2 01	 imul	 rdx, rdx, 1
  003ef	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  003f4	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  003fc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00405	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0040a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194845
  00411	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00416	44 8b c9	 mov	 r9d, ecx
  00419	44 8b c2	 mov	 r8d, edx
  0041c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194846
  00423	b9 10 00 00 00	 mov	 ecx, 16
  00428	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN46@z900_resum:
  0042e	33 c0		 xor	 eax, eax
  00430	85 c0		 test	 eax, eax
  00432	75 82		 jne	 SHORT $LN22@z900_resum
$LN25@z900_resum:

; 410  : #if defined( _FEATURE_IO_ASSIST )
; 411  :         PTIO( ERR, "*RSCH (sie)" );

  00434	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0043b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0043e	48 83 e0 10	 and	 rax, 16
  00442	48 85 c0	 test	 rax, rax
  00445	74 65		 je	 SHORT $LN47@z900_resum
  00447	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0044c	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00452	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00457	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0045c	48 23 d1	 and	 rdx, rcx
  0045f	48 8b ca	 mov	 rcx, rdx
  00462	8b c9		 mov	 ecx, ecx
  00464	ba 08 00 00 00	 mov	 edx, 8
  00469	48 6b d2 01	 imul	 rdx, rdx, 1
  0046d	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00472	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0047a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00483	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00488	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194848
  0048f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00494	44 8b c9	 mov	 r9d, ecx
  00497	44 8b c2	 mov	 r8d, edx
  0049a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194849
  004a1	b9 10 00 00 00	 mov	 ecx, 16
  004a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN47@z900_resum:
  004ac	33 c0		 xor	 eax, eax
  004ae	85 c0		 test	 eax, eax
  004b0	75 82		 jne	 SHORT $LN25@z900_resum
$LN28@z900_resum:

; 412  :         SIE_INTERCEPT( regs );

  004b2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  004bd	d1 e8		 shr	 eax, 1
  004bf	83 e0 01	 and	 eax, 1
  004c2	85 c0		 test	 eax, eax
  004c4	74 18		 je	 SHORT $LN48@z900_resum
  004c6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004cb	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  004d1	ba fc ff ff ff	 mov	 edx, -4
  004d6	48 8b c8	 mov	 rcx, rax
  004d9	e8 00 00 00 00	 call	 longjmp
$LN48@z900_resum:
  004de	33 c0		 xor	 eax, eax
  004e0	85 c0		 test	 eax, eax
  004e2	75 ce		 jne	 SHORT $LN28@z900_resum

; 413  : #endif
; 414  :         regs->psw.cc = 3;

  004e4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004e9	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 415  :         return;

  004ed	e9 bf 00 00 00	 jmp	 $LN1@z900_resum
$LN44@z900_resum:

; 416  :     }
; 417  : 
; 418  :     /* Perform resume subchannel and set condition code */
; 419  :     if ((regs->psw.cc = resume_subchan( regs, dev )) != 0)

  004f2	48 8b 54 24 58	 mov	 rdx, QWORD PTR dev$[rsp]
  004f7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  004fc	e8 00 00 00 00	 call	 resume_subchan
  00501	89 44 24 48	 mov	 DWORD PTR tv295[rsp], eax
  00505	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0050a	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv295[rsp]
  0050f	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00512	0f b6 44 24 48	 movzx	 eax, BYTE PTR tv295[rsp]
  00517	85 c0		 test	 eax, eax
  00519	74 7e		 je	 SHORT $LN49@z900_resum
$LN31@z900_resum:

; 420  :         PTIO( ERR, "*RSCH" );

  0051b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00522	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00525	48 83 e0 10	 and	 rax, 16
  00529	48 85 c0	 test	 rax, rax
  0052c	74 65		 je	 SHORT $LN50@z900_resum
  0052e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00533	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00539	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0053e	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00543	48 23 d1	 and	 rdx, rcx
  00546	48 8b ca	 mov	 rcx, rdx
  00549	8b c9		 mov	 ecx, ecx
  0054b	ba 08 00 00 00	 mov	 edx, 8
  00550	48 6b d2 01	 imul	 rdx, rdx, 1
  00554	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00559	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00561	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0056a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0056f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194853
  00576	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0057b	44 8b c9	 mov	 r9d, ecx
  0057e	44 8b c2	 mov	 r8d, edx
  00581	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194854
  00588	b9 10 00 00 00	 mov	 ecx, 16
  0058d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN50@z900_resum:
  00593	33 c0		 xor	 eax, eax
  00595	85 c0		 test	 eax, eax
  00597	75 82		 jne	 SHORT $LN31@z900_resum
$LN49@z900_resum:

; 421  : 
; 422  :     regs->siocount++;

  00599	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0059e	8b 80 a0 07 00
	00		 mov	 eax, DWORD PTR [rax+1952]
  005a4	ff c0		 inc	 eax
  005a6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  005ab	89 81 a0 07 00
	00		 mov	 DWORD PTR [rcx+1952], eax
$LN1@z900_resum:
$LN51@z900_resum:

; 423  : }

  005b1	48 83 c4 68	 add	 rsp, 104		; 00000068H
  005b5	c3		 ret	 0
z900_resume_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
dev$ = 64
effective_addr2$ = 72
b2$ = 80
mso$1 = 88
temp$2 = 96
msl$3 = 104
tv690 = 112
pmcw$ = 120
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
z900_modify_subchannel PROC

; 182  : {

$LN62:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 183  : int     b2;                             /* Effective addr base       */
; 184  : VADR    effective_addr2;                /* Effective address         */
; 185  : DEVBLK* dev;                            /* -> device block           */
; 186  : PMCW    pmcw;                           /* Path management ctl word  */
; 187  : 
; 188  :     S( inst, regs, b2, effective_addr2 );

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 60	 mov	 DWORD PTR temp$2[rsp], eax
  0003b	8b 44 24 60	 mov	 eax, DWORD PTR temp$2[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	8b c0		 mov	 eax, eax
  00046	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004b	8b 44 24 60	 mov	 eax, DWORD PTR temp$2[rsp]
  0004f	c1 e8 0c	 shr	 eax, 12
  00052	83 e0 0f	 and	 eax, 15
  00055	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00059	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005e	74 44		 je	 SHORT $LN35@z900_modif
  00060	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  00065	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00075	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007a	48 03 c8	 add	 rcx, rax
  0007d	48 8b c1	 mov	 rax, rcx
  00080	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00085	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00094	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00099	48 23 c8	 and	 rcx, rax
  0009c	48 8b c1	 mov	 rax, rcx
  0009f	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN35@z900_modif:
$LN4@z900_modif:
  000a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b0	48 83 c0 04	 add	 rax, 4
  000b4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bc	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c0	33 c0		 xor	 eax, eax
  000c2	83 f8 04	 cmp	 eax, 4
  000c5	74 0f		 je	 SHORT $LN36@z900_modif
  000c7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cf	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN36@z900_modif:
  000d6	33 c0		 xor	 eax, eax
  000d8	85 c0		 test	 eax, eax
  000da	75 c8		 jne	 SHORT $LN4@z900_modif

; 189  :     PER_ZEROADDR_XCHECK( regs, b2 );

  000dc	8b 54 24 50	 mov	 edx, DWORD PTR b2$[rsp]
  000e0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_modif:

; 190  : 
; 191  :     TXF_INSTR_CHECK( regs );

  000ed	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000fc	85 c0		 test	 eax, eax
  000fe	74 3f		 je	 SHORT $LN37@z900_modif
  00100	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00108	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0010e	0f ba e8 0c	 bts	 eax, 12
  00112	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011a	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00120	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194647
  00127	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0012d	ba 02 00 00 00	 mov	 edx, 2
  00132	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013a	e8 00 00 00 00	 call	 z900_abort_transaction
$LN37@z900_modif:
  0013f	33 c0		 xor	 eax, eax
  00141	85 c0		 test	 eax, eax
  00143	75 a8		 jne	 SHORT $LN7@z900_modif

; 192  :     PRIV_CHECK( regs );

  00145	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014d	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00151	83 e0 01	 and	 eax, 1
  00154	85 c0		 test	 eax, eax
  00156	74 1b		 je	 SHORT $LN38@z900_modif
  00158	ba 02 00 00 00	 mov	 edx, 2
  0015d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00165	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN38@z900_modif:
$LN10@z900_modif:

; 193  : 
; 194  :     PTIO( IO, "MSCH" );

  00173	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0017a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017d	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00183	48 85 c0	 test	 rax, rax
  00186	74 6b		 je	 SHORT $LN39@z900_modif
  00188	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00190	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00196	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0019b	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001a0	48 23 d1	 and	 rdx, rcx
  001a3	48 8b ca	 mov	 rcx, rdx
  001a6	8b c9		 mov	 ecx, ecx
  001a8	ba 08 00 00 00	 mov	 edx, 8
  001ad	48 6b d2 01	 imul	 rdx, rdx, 1
  001b1	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001b9	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001c1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001ca	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194650
  001d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001db	44 8b c9	 mov	 r9d, ecx
  001de	44 8b c2	 mov	 r8d, edx
  001e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194651
  001e8	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@z900_modif:
  001f3	33 c0		 xor	 eax, eax
  001f5	85 c0		 test	 eax, eax
  001f7	0f 85 76 ff ff
	ff		 jne	 $LN10@z900_modif
$LN13@z900_modif:

; 195  : 
; 196  :     PTIO( IO, "MSCH (sie)" );

  001fd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00204	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00207	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0020d	48 85 c0	 test	 rax, rax
  00210	74 6b		 je	 SHORT $LN40@z900_modif
  00212	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021a	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00220	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00225	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0022a	48 23 d1	 and	 rdx, rcx
  0022d	48 8b ca	 mov	 rcx, rdx
  00230	8b c9		 mov	 ecx, ecx
  00232	ba 08 00 00 00	 mov	 edx, 8
  00237	48 6b d2 01	 imul	 rdx, rdx, 1
  0023b	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00243	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0024b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00254	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00259	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194653
  00260	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00265	44 8b c9	 mov	 r9d, ecx
  00268	44 8b c2	 mov	 r8d, edx
  0026b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194654
  00272	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00277	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN40@z900_modif:
  0027d	33 c0		 xor	 eax, eax
  0027f	85 c0		 test	 eax, eax
  00281	0f 85 76 ff ff
	ff		 jne	 $LN13@z900_modif
$LN16@z900_modif:

; 197  :     SIE_INTERCEPT( regs );

  00287	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00295	d1 e8		 shr	 eax, 1
  00297	83 e0 01	 and	 eax, 1
  0029a	85 c0		 test	 eax, eax
  0029c	74 1b		 je	 SHORT $LN41@z900_modif
  0029e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a6	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  002ac	ba fc ff ff ff	 mov	 edx, -4
  002b1	48 8b c8	 mov	 rcx, rax
  002b4	e8 00 00 00 00	 call	 longjmp
$LN41@z900_modif:
  002b9	33 c0		 xor	 eax, eax
  002bb	85 c0		 test	 eax, eax
  002bd	75 c8		 jne	 SHORT $LN16@z900_modif

; 198  : 
; 199  :     FW_CHECK( effective_addr2, regs );

  002bf	48 8b 44 24 48	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  002c4	48 83 e0 03	 and	 rax, 3
  002c8	48 85 c0	 test	 rax, rax
  002cb	74 1b		 je	 SHORT $LN42@z900_modif
  002cd	ba 06 00 00 00	 mov	 edx, 6
  002d2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002da	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN42@z900_modif:

; 200  : 
; 201  :     /* Fetch the updated path management control word */
; 202  :     ARCH_DEP( vfetchc )( &pmcw, sizeof(PMCW)-1, effective_addr2, b2, regs );

  002e8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f5	44 8b 4c 24 50	 mov	 r9d, DWORD PTR b2$[rsp]
  002fa	4c 8b 44 24 48	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  002ff	b2 1b		 mov	 dl, 27
  00301	48 8d 4c 24 78	 lea	 rcx, QWORD PTR pmcw$[rsp]
  00306	e8 00 00 00 00	 call	 z900_vfetchc

; 203  : 
; 204  :     /* Program check if reserved bits are not zero */
; 205  :     if (0
; 206  :         || (pmcw.flag4 & PMCW4_RESV)
; 207  :         || (pmcw.flag5 & PMCW5_LM) == PMCW5_LM_RESV
; 208  : #if !defined( _FEATURE_IO_ASSIST )
; 209  :         || (pmcw.flag4 & PMCW4_A)
; 210  :         || (pmcw.zone != 0)
; 211  :         || (pmcw.flag25 & PMCW25_VISC)
; 212  :         || (pmcw.flag27 & PMCW27_I)
; 213  : #endif
; 214  :         || (pmcw.flag26 != 0)
; 215  :         || (pmcw.flag27 & PMCW27_RESV)

  0030b	33 c0		 xor	 eax, eax
  0030d	85 c0		 test	 eax, eax
  0030f	75 34		 jne	 SHORT $LN44@z900_modif
  00311	0f b6 44 24 7c	 movzx	 eax, BYTE PTR pmcw$[rsp+4]
  00316	83 e0 46	 and	 eax, 70			; 00000046H
  00319	85 c0		 test	 eax, eax
  0031b	75 28		 jne	 SHORT $LN44@z900_modif
  0031d	0f b6 44 24 7d	 movzx	 eax, BYTE PTR pmcw$[rsp+5]
  00322	83 e0 60	 and	 eax, 96			; 00000060H
  00325	83 f8 60	 cmp	 eax, 96			; 00000060H
  00328	74 1b		 je	 SHORT $LN44@z900_modif
  0032a	0f b6 84 24 92
	00 00 00	 movzx	 eax, BYTE PTR pmcw$[rsp+26]
  00332	85 c0		 test	 eax, eax
  00334	75 0f		 jne	 SHORT $LN44@z900_modif
  00336	0f b6 84 24 93
	00 00 00	 movzx	 eax, BYTE PTR pmcw$[rsp+27]
  0033e	83 e0 7e	 and	 eax, 126		; 0000007eH
  00341	85 c0		 test	 eax, eax
  00343	74 12		 je	 SHORT $LN43@z900_modif
$LN44@z900_modif:

; 216  :     )
; 217  :         ARCH_DEP( program_interrupt )( regs, PGM_OPERAND_EXCEPTION );

  00345	ba 15 00 00 00	 mov	 edx, 21
  0034a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00352	e8 00 00 00 00	 call	 z900_program_interrupt
$LN43@z900_modif:

; 218  : 
; 219  :     /* Program check if the ssid including lcss is invalid */
; 220  :     SSID_CHECK( regs );

  00357	b8 08 00 00 00	 mov	 eax, 8
  0035c	48 6b c0 01	 imul	 rax, rax, 1
  00360	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00368	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  00370	83 e0 01	 and	 eax, 1
  00373	85 c0		 test	 eax, eax
  00375	74 1e		 je	 SHORT $LN46@z900_modif
  00377	b8 08 00 00 00	 mov	 eax, 8
  0037c	48 6b c0 01	 imul	 rax, rax, 1
  00380	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00388	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  00390	83 f8 03	 cmp	 eax, 3
  00393	7e 1b		 jle	 SHORT $LN45@z900_modif
$LN46@z900_modif:
  00395	ba 15 00 00 00	 mov	 edx, 21
  0039a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003aa	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN45@z900_modif:

; 221  : 
; 222  :     /* Locate the device block for this subchannel */
; 223  :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  003b0	b8 08 00 00 00	 mov	 eax, 8
  003b5	48 6b c0 01	 imul	 rax, rax, 1
  003b9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c1	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  003c8	e8 00 00 00 00	 call	 find_device_by_subchan
  003cd	48 89 44 24 40	 mov	 QWORD PTR dev$[rsp], rax

; 224  : 
; 225  :     if (dev)

  003d2	48 83 7c 24 40
	00		 cmp	 QWORD PTR dev$[rsp], 0
  003d8	74 5a		 je	 SHORT $LN47@z900_modif
$LN19@z900_modif:

; 226  :         PTT( PTT_CL_IO, "MSCH (dev)", dev->devnum, 0, 0 );

  003da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003e1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003e4	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  003ea	48 85 c0	 test	 rax, rax
  003ed	74 3f		 je	 SHORT $LN48@z900_modif
  003ef	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  003f4	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003f8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00401	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0040a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194663
  00411	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00416	45 33 c9	 xor	 r9d, r9d
  00419	44 8b c0	 mov	 r8d, eax
  0041c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194664
  00423	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00428	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN48@z900_modif:
  0042e	33 c0		 xor	 eax, eax
  00430	85 c0		 test	 eax, eax
  00432	75 a6		 jne	 SHORT $LN19@z900_modif
$LN47@z900_modif:

; 227  : 
; 228  :     /* Condition code 3 if subchannel does not exist */
; 229  :     if (!dev)

  00434	48 83 7c 24 40
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0043a	0f 85 99 00 00
	00		 jne	 $LN49@z900_modif
$LN22@z900_modif:

; 230  :     {
; 231  :         PTIO( ERR, "*MSCH" );

  00440	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00447	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0044a	48 83 e0 10	 and	 rax, 16
  0044e	48 85 c0	 test	 rax, rax
  00451	74 6b		 je	 SHORT $LN50@z900_modif
  00453	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045b	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00461	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00466	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0046b	48 23 d1	 and	 rdx, rcx
  0046e	48 8b ca	 mov	 rcx, rdx
  00471	8b c9		 mov	 ecx, ecx
  00473	ba 08 00 00 00	 mov	 edx, 8
  00478	48 6b d2 01	 imul	 rdx, rdx, 1
  0047c	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00484	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0048c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00495	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0049a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194667
  004a1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004a6	44 8b c9	 mov	 r9d, ecx
  004a9	44 8b c2	 mov	 r8d, edx
  004ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194668
  004b3	b9 10 00 00 00	 mov	 ecx, 16
  004b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN50@z900_modif:
  004be	33 c0		 xor	 eax, eax
  004c0	85 c0		 test	 eax, eax
  004c2	0f 85 78 ff ff
	ff		 jne	 $LN22@z900_modif

; 232  :         regs->psw.cc = 3;

  004c8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d0	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 233  :         return;

  004d4	e9 a0 05 00 00	 jmp	 $LN1@z900_modif
$LN49@z900_modif:

; 234  :     }
; 235  : 
; 236  :     /* If the subchannel is invalid then return cc0 */
; 237  :     if (!(dev->pmcw.flag5 & PMCW5_V))

  004d9	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  004de	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  004e5	83 e0 01	 and	 eax, 1
  004e8	85 c0		 test	 eax, eax
  004ea	0f 85 99 00 00
	00		 jne	 $LN51@z900_modif
$LN25@z900_modif:

; 238  :     {
; 239  :         PTIO( ERR, "*MSCH" );

  004f0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004f7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004fa	48 83 e0 10	 and	 rax, 16
  004fe	48 85 c0	 test	 rax, rax
  00501	74 6b		 je	 SHORT $LN52@z900_modif
  00503	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050b	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00511	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00516	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0051b	48 23 d1	 and	 rdx, rcx
  0051e	48 8b ca	 mov	 rcx, rdx
  00521	8b c9		 mov	 ecx, ecx
  00523	ba 08 00 00 00	 mov	 edx, 8
  00528	48 6b d2 01	 imul	 rdx, rdx, 1
  0052c	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00534	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0053c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00545	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0054a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194671
  00551	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00556	44 8b c9	 mov	 r9d, ecx
  00559	44 8b c2	 mov	 r8d, edx
  0055c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194672
  00563	b9 10 00 00 00	 mov	 ecx, 16
  00568	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN52@z900_modif:
  0056e	33 c0		 xor	 eax, eax
  00570	85 c0		 test	 eax, eax
  00572	0f 85 78 ff ff
	ff		 jne	 $LN25@z900_modif

; 240  :         regs->psw.cc = 0;

  00578	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00580	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 241  :         return;

  00584	e9 f0 04 00 00	 jmp	 $LN1@z900_modif
$LN51@z900_modif:

; 242  :     }
; 243  : 
; 244  :     /* Perform serialization and checkpoint-synchronization */
; 245  :     PERFORM_SERIALIZATION( regs );

  00589	0f ae f0	 mfence
$LN28@z900_modif:

; 246  :     PERFORM_CHKPT_SYNC( regs );

  0058c	33 c0		 xor	 eax, eax
  0058e	85 c0		 test	 eax, eax
  00590	75 fa		 jne	 SHORT $LN28@z900_modif

; 247  : 
; 248  :     /* Obtain the device lock */
; 249  :     obtain_lock( &dev->lock );

  00592	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00597	48 83 c0 38	 add	 rax, 56			; 00000038H
  0059b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194673
  005a2	48 8b c8	 mov	 rcx, rax
  005a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 250  :     {
; 251  :         /* Condition code 1 if subchannel is status pending
; 252  :            with other than intermediate status */
; 253  :         if (1
; 254  :             &&  (dev->scsw.flag3 & SCSW3_SC_PEND)
; 255  :             && !(dev->scsw.flag3 & SCSW3_SC_INTER)

  005ab	33 c0		 xor	 eax, eax
  005ad	83 f8 01	 cmp	 eax, 1
  005b0	0f 84 e0 00 00
	00		 je	 $LN53@z900_modif
  005b6	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  005bb	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  005c2	83 e0 01	 and	 eax, 1
  005c5	85 c0		 test	 eax, eax
  005c7	0f 84 c9 00 00
	00		 je	 $LN53@z900_modif
  005cd	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  005d2	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  005d9	83 e0 08	 and	 eax, 8
  005dc	85 c0		 test	 eax, eax
  005de	0f 85 b2 00 00
	00		 jne	 $LN53@z900_modif
$LN31@z900_modif:

; 256  :         )
; 257  :         {
; 258  :             PTIO( ERR, "*MSCH" );

  005e4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005eb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005ee	48 83 e0 10	 and	 rax, 16
  005f2	48 85 c0	 test	 rax, rax
  005f5	74 6b		 je	 SHORT $LN54@z900_modif
  005f7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ff	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00605	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0060a	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0060f	48 23 d1	 and	 rdx, rcx
  00612	48 8b ca	 mov	 rcx, rdx
  00615	8b c9		 mov	 ecx, ecx
  00617	ba 08 00 00 00	 mov	 edx, 8
  0061c	48 6b d2 01	 imul	 rdx, rdx, 1
  00620	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00628	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00630	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00639	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0063e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194676
  00645	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0064a	44 8b c9	 mov	 r9d, ecx
  0064d	44 8b c2	 mov	 r8d, edx
  00650	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194677
  00657	b9 10 00 00 00	 mov	 ecx, 16
  0065c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN54@z900_modif:
  00662	33 c0		 xor	 eax, eax
  00664	85 c0		 test	 eax, eax
  00666	0f 85 78 ff ff
	ff		 jne	 $LN31@z900_modif

; 259  :             regs->psw.cc = 1;

  0066c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00674	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 260  :             release_lock( &dev->lock );

  00678	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0067d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00681	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194678
  00688	48 8b c8	 mov	 rcx, rax
  0068b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 261  :             return;

  00691	e9 e3 03 00 00	 jmp	 $LN1@z900_modif
$LN53@z900_modif:

; 262  :         }
; 263  : 
; 264  :         /* Condition code 2 if subchannel is busy */
; 265  :         if (dev->busy || IOPENDING( dev ))

  00696	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0069b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  006a1	c1 e8 13	 shr	 eax, 19
  006a4	83 e0 01	 and	 eax, 1
  006a7	85 c0		 test	 eax, eax
  006a9	75 58		 jne	 SHORT $LN56@z900_modif
  006ab	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  006b0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  006b6	c1 e8 16	 shr	 eax, 22
  006b9	83 e0 01	 and	 eax, 1
  006bc	85 c0		 test	 eax, eax
  006be	75 43		 jne	 SHORT $LN57@z900_modif
  006c0	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  006c5	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  006cb	c1 e8 17	 shr	 eax, 23
  006ce	83 e0 01	 and	 eax, 1
  006d1	85 c0		 test	 eax, eax
  006d3	75 2e		 jne	 SHORT $LN57@z900_modif
  006d5	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  006da	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  006e0	c1 e8 18	 shr	 eax, 24
  006e3	83 e0 01	 and	 eax, 1
  006e6	85 c0		 test	 eax, eax
  006e8	75 19		 jne	 SHORT $LN57@z900_modif
  006ea	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  006ef	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  006f5	c1 e8 1b	 shr	 eax, 27
  006f8	83 e0 01	 and	 eax, 1
  006fb	85 c0		 test	 eax, eax
  006fd	0f 84 b2 00 00
	00		 je	 $LN55@z900_modif
$LN57@z900_modif:
$LN56@z900_modif:
$LN34@z900_modif:

; 266  :         {
; 267  :             PTIO( ERR, "*MSCH" );

  00703	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0070a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0070d	48 83 e0 10	 and	 rax, 16
  00711	48 85 c0	 test	 rax, rax
  00714	74 6b		 je	 SHORT $LN58@z900_modif
  00716	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0071e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00724	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00729	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0072e	48 23 d1	 and	 rdx, rcx
  00731	48 8b ca	 mov	 rcx, rdx
  00734	8b c9		 mov	 ecx, ecx
  00736	ba 08 00 00 00	 mov	 edx, 8
  0073b	48 6b d2 01	 imul	 rdx, rdx, 1
  0073f	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00747	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0074f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00758	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0075d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194683
  00764	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00769	44 8b c9	 mov	 r9d, ecx
  0076c	44 8b c2	 mov	 r8d, edx
  0076f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194684
  00776	b9 10 00 00 00	 mov	 ecx, 16
  0077b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN58@z900_modif:
  00781	33 c0		 xor	 eax, eax
  00783	85 c0		 test	 eax, eax
  00785	0f 85 78 ff ff
	ff		 jne	 $LN34@z900_modif

; 268  :             regs->psw.cc = 2;

  0078b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00793	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 269  :             release_lock( &dev->lock );

  00797	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0079c	48 83 c0 38	 add	 rax, 56			; 00000038H
  007a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194685
  007a7	48 8b c8	 mov	 rcx, rax
  007aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 270  :             return;

  007b0	e9 c4 02 00 00	 jmp	 $LN1@z900_modif
$LN55@z900_modif:

; 271  :         }
; 272  : 
; 273  :         /* Update the enabled (E), limit mode (LM), and
; 274  :            measurement mode (MM), and multipath (D) bits */
; 275  :         dev->pmcw.flag5 &=              ~(PMCW5_E | PMCW5_LM | PMCW5_MM | PMCW5_D);

  007b5	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  007ba	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  007c1	25 03 ff ff ff	 and	 eax, -253		; ffffffffffffff03H
  007c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  007cb	88 81 f1 02 00
	00		 mov	 BYTE PTR [rcx+753], al

; 276  :         dev->pmcw.flag5 |= (pmcw.flag5 & (PMCW5_E | PMCW5_LM | PMCW5_MM | PMCW5_D));

  007d1	0f b6 44 24 7d	 movzx	 eax, BYTE PTR pmcw$[rsp+5]
  007d6	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  007db	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  007e0	0f b6 89 f1 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+753]
  007e7	0b c8		 or	 ecx, eax
  007e9	8b c1		 mov	 eax, ecx
  007eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  007f0	88 81 f1 02 00
	00		 mov	 BYTE PTR [rcx+753], al

; 277  : 
; 278  :         /* Update the measurement block index */
; 279  :         memcpy( dev->pmcw.mbi, pmcw.mbi, sizeof( HWORD ));

  007f6	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  007fb	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR pmcw$[rsp+12]
  00803	66 89 88 f8 02
	00 00		 mov	 WORD PTR [rax+760], cx

; 280  : 
; 281  :         /* Update the interruption parameter */
; 282  :         memcpy( dev->pmcw.intparm, pmcw.intparm, sizeof( FWORD ));

  0080a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0080f	8b 4c 24 78	 mov	 ecx, DWORD PTR pmcw$[rsp]
  00813	89 88 ec 02 00
	00		 mov	 DWORD PTR [rax+748], ecx

; 283  : 
; 284  :         /* Update the ISC and A fields */
; 285  :         dev->pmcw.flag4 &=              ~(PMCW4_ISC | PMCW4_A);

  00819	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0081e	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  00825	83 e0 c6	 and	 eax, -58		; ffffffffffffffc6H
  00828	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0082d	88 81 f0 02 00
	00		 mov	 BYTE PTR [rcx+752], al

; 286  :         dev->pmcw.flag4 |= (pmcw.flag4 & (PMCW4_ISC | PMCW4_A));

  00833	0f b6 44 24 7c	 movzx	 eax, BYTE PTR pmcw$[rsp+4]
  00838	83 e0 39	 and	 eax, 57			; 00000039H
  0083b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00840	0f b6 89 f0 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+752]
  00847	0b c8		 or	 ecx, eax
  00849	8b c1		 mov	 eax, ecx
  0084b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00850	88 81 f0 02 00
	00		 mov	 BYTE PTR [rcx+752], al

; 287  : 
; 288  :         /* Update the path management (LPM and POM) fields */
; 289  :         dev->pmcw.lpm = pmcw.lpm;

  00856	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0085b	0f b6 8c 24 80
	00 00 00	 movzx	 ecx, BYTE PTR pmcw$[rsp+8]
  00863	88 88 f4 02 00
	00		 mov	 BYTE PTR [rax+756], cl

; 290  :         dev->pmcw.pom = pmcw.pom;

  00869	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0086e	0f b6 8c 24 86
	00 00 00	 movzx	 ecx, BYTE PTR pmcw$[rsp+14]
  00876	88 88 fa 02 00
	00		 mov	 BYTE PTR [rax+762], cl

; 291  : 
; 292  :         /* Update zone, VISC, I and S bit */
; 293  :         dev->pmcw.zone    =  pmcw.zone;

  0087c	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00881	0f b6 8c 24 90
	00 00 00	 movzx	 ecx, BYTE PTR pmcw$[rsp+24]
  00889	88 88 04 03 00
	00		 mov	 BYTE PTR [rax+772], cl

; 294  :         dev->pmcw.flag25 &=              ~(PMCW25_VISC);

  0088f	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00894	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  0089b	83 e0 f8	 and	 eax, -8
  0089e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  008a3	88 81 05 03 00
	00		 mov	 BYTE PTR [rcx+773], al

; 295  :         dev->pmcw.flag25 |= (pmcw.flag25 & PMCW25_VISC);

  008a9	0f b6 84 24 91
	00 00 00	 movzx	 eax, BYTE PTR pmcw$[rsp+25]
  008b1	83 e0 07	 and	 eax, 7
  008b4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  008b9	0f b6 89 05 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+773]
  008c0	0b c8		 or	 ecx, eax
  008c2	8b c1		 mov	 eax, ecx
  008c4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  008c9	88 81 05 03 00
	00		 mov	 BYTE PTR [rcx+773], al

; 296  :         dev->pmcw.flag26  =  pmcw.flag26;

  008cf	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  008d4	0f b6 8c 24 92
	00 00 00	 movzx	 ecx, BYTE PTR pmcw$[rsp+26]
  008dc	88 88 06 03 00
	00		 mov	 BYTE PTR [rax+774], cl

; 297  :         dev->pmcw.flag27  =  pmcw.flag27;

  008e2	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  008e7	0f b6 8c 24 93
	00 00 00	 movzx	 ecx, BYTE PTR pmcw$[rsp+27]
  008ef	88 88 07 03 00
	00		 mov	 BYTE PTR [rax+775], cl

; 298  : 
; 299  : #if defined( _FEATURE_IO_ASSIST )
; 300  :         /* Relate the device storage view to the requested zone */
; 301  :         {
; 302  :             RADR  mso, msl;
; 303  : 
; 304  :             mso =  sysblk.zpb[ dev->pmcw.zone ].mso << 20;

  008f5	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  008fa	0f b6 80 04 03
	00 00		 movzx	 eax, BYTE PTR [rax+772]
  00901	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00905	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0090c	48 8b 84 01 a0
	0e 00 00	 mov	 rax, QWORD PTR [rcx+rax+3744]
  00914	48 c1 e0 14	 shl	 rax, 20
  00918	48 89 44 24 58	 mov	 QWORD PTR mso$1[rsp], rax

; 305  :             msl = (sysblk.zpb[ dev->pmcw.zone ].msl << 20) | 0xFFFFF;

  0091d	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00922	0f b6 80 04 03
	00 00		 movzx	 eax, BYTE PTR [rax+772]
  00929	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0092d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00934	48 8b 84 01 a8
	0e 00 00	 mov	 rax, QWORD PTR [rcx+rax+3752]
  0093c	48 c1 e0 14	 shl	 rax, 20
  00940	48 0d ff ff 0f
	00		 or	 rax, 1048575		; 000fffffH
  00946	48 89 44 24 68	 mov	 QWORD PTR msl$3[rsp], rax

; 306  : 
; 307  :             /* Ensure channel program checks on incorrect zone defs */
; 308  :             if (0
; 309  :                 || mso > (sysblk.mainsize - 1)
; 310  :                 || msl > (sysblk.mainsize - 1)
; 311  :                 || mso > msl

  0094b	33 c0		 xor	 eax, eax
  0094d	85 c0		 test	 eax, eax
  0094f	75 3c		 jne	 SHORT $LN60@z900_modif
  00951	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00958	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0095f	48 ff c8	 dec	 rax
  00962	48 39 44 24 58	 cmp	 QWORD PTR mso$1[rsp], rax
  00967	77 24		 ja	 SHORT $LN60@z900_modif
  00969	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00970	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00977	48 ff c8	 dec	 rax
  0097a	48 39 44 24 68	 cmp	 QWORD PTR msl$3[rsp], rax
  0097f	77 0c		 ja	 SHORT $LN60@z900_modif
  00981	48 8b 44 24 68	 mov	 rax, QWORD PTR msl$3[rsp]
  00986	48 39 44 24 58	 cmp	 QWORD PTR mso$1[rsp], rax
  0098b	76 13		 jbe	 SHORT $LN59@z900_modif
$LN60@z900_modif:

; 312  :             )
; 313  :                 mso = msl = 0;

  0098d	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR msl$3[rsp], 0
  00996	48 8b 44 24 68	 mov	 rax, QWORD PTR msl$3[rsp]
  0099b	48 89 44 24 58	 mov	 QWORD PTR mso$1[rsp], rax
$LN59@z900_modif:

; 314  : 
; 315  :             dev->mainstor = &(sysblk.mainstor[ mso ]);

  009a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009a7	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  009ae	48 03 44 24 58	 add	 rax, QWORD PTR mso$1[rsp]
  009b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  009b8	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 316  :             dev->mainlim  = msl - mso;

  009bf	48 8b 44 24 58	 mov	 rax, QWORD PTR mso$1[rsp]
  009c4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR msl$3[rsp]
  009c9	48 2b c8	 sub	 rcx, rax
  009cc	48 8b c1	 mov	 rax, rcx
  009cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  009d4	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 317  :             dev->storkeys = ARCH_DEP( get_ptr_to_storekey )( mso );

  009db	48 8b 4c 24 58	 mov	 rcx, QWORD PTR mso$1[rsp]
  009e0	e8 00 00 00 00	 call	 z900_get_ptr_to_storekey
  009e5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  009ea	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 318  :         }
; 319  : #endif
; 320  : 
; 321  :         /* Set device priority from the interruption subclass bits.
; 322  :          * Note: PMCW priorities range from 0 to 7 with 0 having a higher
; 323  :          *       priority than 7. Consequently, we'll set the device
; 324  :          *       priority bits accordingly.
; 325  :          */
; 326  :         dev->priority &= 0xFF00FFFFULL;

  009f1	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  009f6	48 63 80 18 02
	00 00		 movsxd	 rax, DWORD PTR [rax+536]
  009fd	b9 ff ff 00 ff	 mov	 ecx, -16711681		; ff00ffffH
  00a02	48 23 c1	 and	 rax, rcx
  00a05	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00a0a	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 327  :         dev->priority |= 0x00800000ULL >> ((dev->pmcw.flag4 & PMCW4_ISC) >> 3);

  00a10	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00a15	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  00a1c	83 e0 38	 and	 eax, 56			; 00000038H
  00a1f	c1 f8 03	 sar	 eax, 3
  00a22	b9 00 00 80 00	 mov	 ecx, 8388608		; 00800000H
  00a27	48 89 4c 24 70	 mov	 QWORD PTR tv690[rsp], rcx
  00a2c	0f b6 c8	 movzx	 ecx, al
  00a2f	48 8b 44 24 70	 mov	 rax, QWORD PTR tv690[rsp]
  00a34	48 d3 e8	 shr	 rax, cl
  00a37	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00a3c	48 63 89 18 02
	00 00		 movsxd	 rcx, DWORD PTR [rcx+536]
  00a43	48 0b c8	 or	 rcx, rax
  00a46	48 8b c1	 mov	 rax, rcx
  00a49	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00a4e	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 328  : 
; 329  :     }
; 330  :     release_lock( &dev->lock );

  00a54	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00a59	48 83 c0 38	 add	 rax, 56			; 00000038H
  00a5d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194688
  00a64	48 8b c8	 mov	 rcx, rax
  00a67	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 331  : 
; 332  :     /* Set condition code 0 */
; 333  :     regs->psw.cc = 0;

  00a6d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a75	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@z900_modif:
$LN61@z900_modif:

; 334  : }

  00a79	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a81	48 33 cc	 xor	 rcx, rsp
  00a84	e8 00 00 00 00	 call	 __security_check_cookie
  00a89	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00a90	c3		 ret	 0
z900_modify_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
temp$1 = 64
b2$ = 68
tv295 = 72
effective_addr2$ = 80
dev$ = 88
inst$ = 112
regs$ = 120
z900_halt_subchannel PROC

; 126  : {

$LN52:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 127  : int     b2;                             /* Effective addr base       */
; 128  : VADR    effective_addr2;                /* Effective address         */
; 129  : DEVBLK* dev;                            /* -> device block           */
; 130  : 
; 131  :     S( inst, regs, b2, effective_addr2 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 0c	 shr	 eax, 12
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  00041	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  00046	74 3e		 je	 SHORT $LN32@z900_halt_
  00048	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0005f	48 03 c8	 add	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0006a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00076	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 23 c8	 and	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN32@z900_halt_:
$LN4@z900_halt_:
  00086	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008f	48 83 c0 04	 add	 rax, 4
  00093	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0009c	33 c0		 xor	 eax, eax
  0009e	83 f8 04	 cmp	 eax, 4
  000a1	74 0c		 je	 SHORT $LN33@z900_halt_
  000a3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN33@z900_halt_:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 d1		 jne	 SHORT $LN4@z900_halt_
$LN7@z900_halt_:

; 132  : 
; 133  :     TXF_INSTR_CHECK( regs );

  000b5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c1	85 c0		 test	 eax, eax
  000c3	74 36		 je	 SHORT $LN34@z900_halt_
  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000d0	0f ba e8 0c	 bts	 eax, 12
  000d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d9	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000df	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194518
  000e6	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000ec	ba 02 00 00 00	 mov	 edx, 2
  000f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	e8 00 00 00 00	 call	 z900_abort_transaction
$LN34@z900_halt_:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 b4		 jne	 SHORT $LN7@z900_halt_

; 134  :     PRIV_CHECK( regs );

  00101	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00106	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0010a	83 e0 01	 and	 eax, 1
  0010d	85 c0		 test	 eax, eax
  0010f	74 15		 je	 SHORT $LN35@z900_halt_
  00111	ba 02 00 00 00	 mov	 edx, 2
  00116	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00120	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN35@z900_halt_:
$LN10@z900_halt_:

; 135  : 
; 136  :     PTIO( IO, "HSCH" );

  00126	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0012d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00130	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00136	48 85 c0	 test	 rax, rax
  00139	74 65		 je	 SHORT $LN36@z900_halt_
  0013b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00140	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00146	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0014b	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00150	48 23 d1	 and	 rdx, rcx
  00153	48 8b ca	 mov	 rcx, rdx
  00156	8b c9		 mov	 ecx, ecx
  00158	ba 08 00 00 00	 mov	 edx, 8
  0015d	48 6b d2 01	 imul	 rdx, rdx, 1
  00161	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00166	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0016e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00177	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0017c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194521
  00183	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00188	44 8b c9	 mov	 r9d, ecx
  0018b	44 8b c2	 mov	 r8d, edx
  0018e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194522
  00195	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@z900_halt_:
  001a0	33 c0		 xor	 eax, eax
  001a2	85 c0		 test	 eax, eax
  001a4	75 80		 jne	 SHORT $LN10@z900_halt_

; 137  : 
; 138  : #if defined( _FEATURE_IO_ASSIST )
; 139  :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  001a6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001ab	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001b1	d1 e8		 shr	 eax, 1
  001b3	83 e0 01	 and	 eax, 1
  001b6	85 c0		 test	 eax, eax
  001b8	0f 84 f0 00 00
	00		 je	 $LN37@z900_halt_
  001be	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c3	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  001ca	b9 01 00 00 00	 mov	 ecx, 1
  001cf	48 6b c9 00	 imul	 rcx, rcx, 0
  001d3	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  001d8	83 e0 04	 and	 eax, 4
  001db	85 c0		 test	 eax, eax
  001dd	0f 85 cb 00 00
	00		 jne	 $LN37@z900_halt_
  001e3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001ee	c1 e8 02	 shr	 eax, 2
  001f1	83 e0 01	 and	 eax, 1
  001f4	85 c0		 test	 eax, eax
  001f6	0f 85 b2 00 00
	00		 jne	 $LN37@z900_halt_
$LN13@z900_halt_:

; 140  : #endif
; 141  :     {
; 142  :         PTIO( IO, "HSCH (sie)" );

  001fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00203	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00206	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0020c	48 85 c0	 test	 rax, rax
  0020f	74 65		 je	 SHORT $LN38@z900_halt_
  00211	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00216	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0021c	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00221	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00226	48 23 d1	 and	 rdx, rcx
  00229	48 8b ca	 mov	 rcx, rdx
  0022c	8b c9		 mov	 ecx, ecx
  0022e	ba 08 00 00 00	 mov	 edx, 8
  00233	48 6b d2 01	 imul	 rdx, rdx, 1
  00237	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0023c	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00244	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0024d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00252	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194525
  00259	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025e	44 8b c9	 mov	 r9d, ecx
  00261	44 8b c2	 mov	 r8d, edx
  00264	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194526
  0026b	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00270	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN38@z900_halt_:
  00276	33 c0		 xor	 eax, eax
  00278	85 c0		 test	 eax, eax
  0027a	75 80		 jne	 SHORT $LN13@z900_halt_
$LN16@z900_halt_:

; 143  :         SIE_INTERCEPT( regs );

  0027c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00281	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00287	d1 e8		 shr	 eax, 1
  00289	83 e0 01	 and	 eax, 1
  0028c	85 c0		 test	 eax, eax
  0028e	74 18		 je	 SHORT $LN39@z900_halt_
  00290	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00295	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0029b	ba fc ff ff ff	 mov	 edx, -4
  002a0	48 8b c8	 mov	 rcx, rax
  002a3	e8 00 00 00 00	 call	 longjmp
$LN39@z900_halt_:
  002a8	33 c0		 xor	 eax, eax
  002aa	85 c0		 test	 eax, eax
  002ac	75 ce		 jne	 SHORT $LN16@z900_halt_
$LN37@z900_halt_:

; 144  :     }
; 145  : 
; 146  :     /* Program check if the ssid including lcss is invalid */
; 147  :     SSID_CHECK( regs );

  002ae	b8 08 00 00 00	 mov	 eax, 8
  002b3	48 6b c0 01	 imul	 rax, rax, 1
  002b7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002bc	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002c4	83 e0 01	 and	 eax, 1
  002c7	85 c0		 test	 eax, eax
  002c9	74 1b		 je	 SHORT $LN41@z900_halt_
  002cb	b8 08 00 00 00	 mov	 eax, 8
  002d0	48 6b c0 01	 imul	 rax, rax, 1
  002d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002d9	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002e1	83 f8 03	 cmp	 eax, 3
  002e4	7e 15		 jle	 SHORT $LN40@z900_halt_
$LN41@z900_halt_:
  002e6	ba 15 00 00 00	 mov	 edx, 21
  002eb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002f0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN40@z900_halt_:

; 148  : 
; 149  :     /* Locate the device block for this subchannel */
; 150  :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  002fb	b8 08 00 00 00	 mov	 eax, 8
  00300	48 6b c0 01	 imul	 rax, rax, 1
  00304	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  00310	e8 00 00 00 00	 call	 find_device_by_subchan
  00315	48 89 44 24 58	 mov	 QWORD PTR dev$[rsp], rax

; 151  : 
; 152  :     if (dev)

  0031a	48 83 7c 24 58
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00320	74 5a		 je	 SHORT $LN42@z900_halt_
$LN19@z900_halt_:

; 153  :         PTT( PTT_CL_IO, "HSCH (dev)", dev->devnum, 0, 0 );

  00322	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00329	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0032c	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00332	48 85 c0	 test	 rax, rax
  00335	74 3f		 je	 SHORT $LN43@z900_halt_
  00337	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  0033c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00340	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00349	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00352	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194532
  00359	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0035e	45 33 c9	 xor	 r9d, r9d
  00361	44 8b c0	 mov	 r8d, eax
  00364	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194533
  0036b	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00370	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN43@z900_halt_:
  00376	33 c0		 xor	 eax, eax
  00378	85 c0		 test	 eax, eax
  0037a	75 a6		 jne	 SHORT $LN19@z900_halt_
$LN42@z900_halt_:

; 154  : 
; 155  :     /* Condition code 3 if subchannel does not exist,
; 156  :        is not valid, or is not enabled */
; 157  :     if (0
; 158  :         || !dev
; 159  :         || !(dev->pmcw.flag5 & PMCW5_V)
; 160  :         || !(dev->pmcw.flag5 & PMCW5_E)

  0037c	33 c0		 xor	 eax, eax
  0037e	85 c0		 test	 eax, eax
  00380	75 34		 jne	 SHORT $LN45@z900_halt_
  00382	48 83 7c 24 58
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00388	74 2c		 je	 SHORT $LN45@z900_halt_
  0038a	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  0038f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00396	83 e0 01	 and	 eax, 1
  00399	85 c0		 test	 eax, eax
  0039b	74 19		 je	 SHORT $LN45@z900_halt_
  0039d	48 8b 44 24 58	 mov	 rax, QWORD PTR dev$[rsp]
  003a2	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  003a9	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003ae	85 c0		 test	 eax, eax
  003b0	0f 85 3c 01 00
	00		 jne	 $LN44@z900_halt_
$LN45@z900_halt_:
$LN22@z900_halt_:

; 161  :     )
; 162  :     {
; 163  :         PTIO( ERR, "*HSCH" );

  003b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003c0	48 83 e0 10	 and	 rax, 16
  003c4	48 85 c0	 test	 rax, rax
  003c7	74 65		 je	 SHORT $LN46@z900_halt_
  003c9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003ce	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003d4	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  003d9	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  003de	48 23 d1	 and	 rdx, rcx
  003e1	48 8b ca	 mov	 rcx, rdx
  003e4	8b c9		 mov	 ecx, ecx
  003e6	ba 08 00 00 00	 mov	 edx, 8
  003eb	48 6b d2 01	 imul	 rdx, rdx, 1
  003ef	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  003f4	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  003fc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00405	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0040a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194537
  00411	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00416	44 8b c9	 mov	 r9d, ecx
  00419	44 8b c2	 mov	 r8d, edx
  0041c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194538
  00423	b9 10 00 00 00	 mov	 ecx, 16
  00428	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN46@z900_halt_:
  0042e	33 c0		 xor	 eax, eax
  00430	85 c0		 test	 eax, eax
  00432	75 82		 jne	 SHORT $LN22@z900_halt_
$LN25@z900_halt_:

; 164  : #if defined( _FEATURE_IO_ASSIST )
; 165  :         PTIO( ERR, "*HSCH (sie)" );

  00434	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0043b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0043e	48 83 e0 10	 and	 rax, 16
  00442	48 85 c0	 test	 rax, rax
  00445	74 65		 je	 SHORT $LN47@z900_halt_
  00447	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0044c	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00452	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00457	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0045c	48 23 d1	 and	 rdx, rcx
  0045f	48 8b ca	 mov	 rcx, rdx
  00462	8b c9		 mov	 ecx, ecx
  00464	ba 08 00 00 00	 mov	 edx, 8
  00469	48 6b d2 01	 imul	 rdx, rdx, 1
  0046d	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00472	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0047a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00483	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00488	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194540
  0048f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00494	44 8b c9	 mov	 r9d, ecx
  00497	44 8b c2	 mov	 r8d, edx
  0049a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194541
  004a1	b9 10 00 00 00	 mov	 ecx, 16
  004a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN47@z900_halt_:
  004ac	33 c0		 xor	 eax, eax
  004ae	85 c0		 test	 eax, eax
  004b0	75 82		 jne	 SHORT $LN25@z900_halt_
$LN28@z900_halt_:

; 166  :         SIE_INTERCEPT( regs );

  004b2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  004bd	d1 e8		 shr	 eax, 1
  004bf	83 e0 01	 and	 eax, 1
  004c2	85 c0		 test	 eax, eax
  004c4	74 18		 je	 SHORT $LN48@z900_halt_
  004c6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004cb	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  004d1	ba fc ff ff ff	 mov	 edx, -4
  004d6	48 8b c8	 mov	 rcx, rax
  004d9	e8 00 00 00 00	 call	 longjmp
$LN48@z900_halt_:
  004de	33 c0		 xor	 eax, eax
  004e0	85 c0		 test	 eax, eax
  004e2	75 ce		 jne	 SHORT $LN28@z900_halt_

; 167  : #endif
; 168  :         regs->psw.cc = 3;

  004e4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004e9	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 169  :         return;

  004ed	e9 a7 00 00 00	 jmp	 $LN1@z900_halt_
$LN44@z900_halt_:

; 170  :     }
; 171  : 
; 172  :     /* Perform halt subchannel and set condition code */
; 173  :     if ((regs->psw.cc = halt_subchan( regs, dev )) != 0)

  004f2	48 8b 54 24 58	 mov	 rdx, QWORD PTR dev$[rsp]
  004f7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  004fc	e8 00 00 00 00	 call	 halt_subchan
  00501	89 44 24 48	 mov	 DWORD PTR tv295[rsp], eax
  00505	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0050a	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR tv295[rsp]
  0050f	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00512	0f b6 44 24 48	 movzx	 eax, BYTE PTR tv295[rsp]
  00517	85 c0		 test	 eax, eax
  00519	74 7e		 je	 SHORT $LN49@z900_halt_
$LN31@z900_halt_:

; 174  :         PTIO( ERR, "*HSCH" );

  0051b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00522	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00525	48 83 e0 10	 and	 rax, 16
  00529	48 85 c0	 test	 rax, rax
  0052c	74 65		 je	 SHORT $LN50@z900_halt_
  0052e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00533	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00539	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0053e	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00543	48 23 d1	 and	 rdx, rcx
  00546	48 8b ca	 mov	 rcx, rdx
  00549	8b c9		 mov	 ecx, ecx
  0054b	ba 08 00 00 00	 mov	 edx, 8
  00550	48 6b d2 01	 imul	 rdx, rdx, 1
  00554	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00559	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00561	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0056a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0056f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194545
  00576	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0057b	44 8b c9	 mov	 r9d, ecx
  0057e	44 8b c2	 mov	 r8d, edx
  00581	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194546
  00588	b9 10 00 00 00	 mov	 ecx, 16
  0058d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN50@z900_halt_:
  00593	33 c0		 xor	 eax, eax
  00595	85 c0		 test	 eax, eax
  00597	75 82		 jne	 SHORT $LN31@z900_halt_
$LN49@z900_halt_:
$LN1@z900_halt_:
$LN51@z900_halt_:

; 175  : }

  00599	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0059d	c3		 ret	 0
z900_halt_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
temp$1 = 64
b2$ = 68
effective_addr2$ = 72
dev$ = 80
inst$ = 112
regs$ = 120
z900_clear_subchannel PROC

; 69   : {

$LN47:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 70   : int     b2;                             /* Effective addr base       */
; 71   : VADR    effective_addr2;                /* Effective address         */
; 72   : DEVBLK* dev;                            /* -> device block           */
; 73   : 
; 74   :     S( inst, regs, b2, effective_addr2 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 0c	 shr	 eax, 12
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  00041	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  00046	74 3e		 je	 SHORT $LN29@z900_clear
  00048	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0005f	48 03 c8	 add	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0006a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00076	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 23 c8	 and	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN29@z900_clear:
$LN4@z900_clear:
  00086	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008f	48 83 c0 04	 add	 rax, 4
  00093	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0009c	33 c0		 xor	 eax, eax
  0009e	83 f8 04	 cmp	 eax, 4
  000a1	74 0c		 je	 SHORT $LN30@z900_clear
  000a3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN30@z900_clear:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 d1		 jne	 SHORT $LN4@z900_clear
$LN7@z900_clear:

; 75   : 
; 76   :     TXF_INSTR_CHECK( regs );

  000b5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c1	85 c0		 test	 eax, eax
  000c3	74 36		 je	 SHORT $LN31@z900_clear
  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000d0	0f ba e8 0c	 bts	 eax, 12
  000d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d9	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000df	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194409
  000e6	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000ec	ba 02 00 00 00	 mov	 edx, 2
  000f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	e8 00 00 00 00	 call	 z900_abort_transaction
$LN31@z900_clear:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 b4		 jne	 SHORT $LN7@z900_clear

; 77   :     PRIV_CHECK( regs );

  00101	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00106	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0010a	83 e0 01	 and	 eax, 1
  0010d	85 c0		 test	 eax, eax
  0010f	74 15		 je	 SHORT $LN32@z900_clear
  00111	ba 02 00 00 00	 mov	 edx, 2
  00116	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00120	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN32@z900_clear:
$LN10@z900_clear:

; 78   : 
; 79   :     PTIO( IO, "CSCH" );

  00126	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0012d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00130	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00136	48 85 c0	 test	 rax, rax
  00139	74 65		 je	 SHORT $LN33@z900_clear
  0013b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00140	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00146	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0014b	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00150	48 23 d1	 and	 rdx, rcx
  00153	48 8b ca	 mov	 rcx, rdx
  00156	8b c9		 mov	 ecx, ecx
  00158	ba 08 00 00 00	 mov	 edx, 8
  0015d	48 6b d2 01	 imul	 rdx, rdx, 1
  00161	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00166	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0016e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00177	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0017c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194412
  00183	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00188	44 8b c9	 mov	 r9d, ecx
  0018b	44 8b c2	 mov	 r8d, edx
  0018e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194413
  00195	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN33@z900_clear:
  001a0	33 c0		 xor	 eax, eax
  001a2	85 c0		 test	 eax, eax
  001a4	75 80		 jne	 SHORT $LN10@z900_clear

; 80   : 
; 81   : #if defined( _FEATURE_IO_ASSIST )
; 82   :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  001a6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001ab	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001b1	d1 e8		 shr	 eax, 1
  001b3	83 e0 01	 and	 eax, 1
  001b6	85 c0		 test	 eax, eax
  001b8	0f 84 f0 00 00
	00		 je	 $LN34@z900_clear
  001be	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c3	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  001ca	b9 01 00 00 00	 mov	 ecx, 1
  001cf	48 6b c9 00	 imul	 rcx, rcx, 0
  001d3	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  001d8	83 e0 04	 and	 eax, 4
  001db	85 c0		 test	 eax, eax
  001dd	0f 85 cb 00 00
	00		 jne	 $LN34@z900_clear
  001e3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001ee	c1 e8 02	 shr	 eax, 2
  001f1	83 e0 01	 and	 eax, 1
  001f4	85 c0		 test	 eax, eax
  001f6	0f 85 b2 00 00
	00		 jne	 $LN34@z900_clear
$LN13@z900_clear:

; 83   : #endif
; 84   :     {
; 85   :         PTIO( IO, "CSCH (sie)" );

  001fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00203	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00206	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0020c	48 85 c0	 test	 rax, rax
  0020f	74 65		 je	 SHORT $LN35@z900_clear
  00211	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00216	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0021c	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00221	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00226	48 23 d1	 and	 rdx, rcx
  00229	48 8b ca	 mov	 rcx, rdx
  0022c	8b c9		 mov	 ecx, ecx
  0022e	ba 08 00 00 00	 mov	 edx, 8
  00233	48 6b d2 01	 imul	 rdx, rdx, 1
  00237	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0023c	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00244	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0024d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00252	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194416
  00259	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025e	44 8b c9	 mov	 r9d, ecx
  00261	44 8b c2	 mov	 r8d, edx
  00264	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194417
  0026b	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00270	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN35@z900_clear:
  00276	33 c0		 xor	 eax, eax
  00278	85 c0		 test	 eax, eax
  0027a	75 80		 jne	 SHORT $LN13@z900_clear
$LN16@z900_clear:

; 86   :         SIE_INTERCEPT( regs );

  0027c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00281	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00287	d1 e8		 shr	 eax, 1
  00289	83 e0 01	 and	 eax, 1
  0028c	85 c0		 test	 eax, eax
  0028e	74 18		 je	 SHORT $LN36@z900_clear
  00290	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00295	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0029b	ba fc ff ff ff	 mov	 edx, -4
  002a0	48 8b c8	 mov	 rcx, rax
  002a3	e8 00 00 00 00	 call	 longjmp
$LN36@z900_clear:
  002a8	33 c0		 xor	 eax, eax
  002aa	85 c0		 test	 eax, eax
  002ac	75 ce		 jne	 SHORT $LN16@z900_clear
$LN34@z900_clear:

; 87   :     }
; 88   : 
; 89   :     /* Program check if the ssid including lcss is invalid */
; 90   :     SSID_CHECK( regs );

  002ae	b8 08 00 00 00	 mov	 eax, 8
  002b3	48 6b c0 01	 imul	 rax, rax, 1
  002b7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002bc	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002c4	83 e0 01	 and	 eax, 1
  002c7	85 c0		 test	 eax, eax
  002c9	74 1b		 je	 SHORT $LN38@z900_clear
  002cb	b8 08 00 00 00	 mov	 eax, 8
  002d0	48 6b c0 01	 imul	 rax, rax, 1
  002d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002d9	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002e1	83 f8 03	 cmp	 eax, 3
  002e4	7e 15		 jle	 SHORT $LN37@z900_clear
$LN38@z900_clear:
  002e6	ba 15 00 00 00	 mov	 edx, 21
  002eb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002f0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN37@z900_clear:

; 91   : 
; 92   :     /* Locate the device block for this subchannel */
; 93   :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  002fb	b8 08 00 00 00	 mov	 eax, 8
  00300	48 6b c0 01	 imul	 rax, rax, 1
  00304	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  00310	e8 00 00 00 00	 call	 find_device_by_subchan
  00315	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax

; 94   : 
; 95   :     if (dev)

  0031a	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00320	74 5a		 je	 SHORT $LN39@z900_clear
$LN19@z900_clear:

; 96   :         PTT( PTT_CL_IO, "CSCH (dev)", dev->devnum, 0, 0 );

  00322	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00329	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0032c	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00332	48 85 c0	 test	 rax, rax
  00335	74 3f		 je	 SHORT $LN40@z900_clear
  00337	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0033c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00340	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00349	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00352	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194423
  00359	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0035e	45 33 c9	 xor	 r9d, r9d
  00361	44 8b c0	 mov	 r8d, eax
  00364	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194424
  0036b	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00370	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN40@z900_clear:
  00376	33 c0		 xor	 eax, eax
  00378	85 c0		 test	 eax, eax
  0037a	75 a6		 jne	 SHORT $LN19@z900_clear
$LN39@z900_clear:

; 97   : 
; 98   :     /* Condition code 3 if subchannel does not exist,
; 99   :        is not valid, or is not enabled */
; 100  :     if (0
; 101  :         || !dev
; 102  :         || !(dev->pmcw.flag5 & PMCW5_V)
; 103  :         || !(dev->pmcw.flag5 & PMCW5_E)

  0037c	33 c0		 xor	 eax, eax
  0037e	85 c0		 test	 eax, eax
  00380	75 34		 jne	 SHORT $LN42@z900_clear
  00382	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00388	74 2c		 je	 SHORT $LN42@z900_clear
  0038a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0038f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00396	83 e0 01	 and	 eax, 1
  00399	85 c0		 test	 eax, eax
  0039b	74 19		 je	 SHORT $LN42@z900_clear
  0039d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  003a2	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  003a9	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003ae	85 c0		 test	 eax, eax
  003b0	0f 85 39 01 00
	00		 jne	 $LN41@z900_clear
$LN42@z900_clear:
$LN22@z900_clear:

; 104  :     )
; 105  :     {
; 106  :         PTIO( ERR, "*CSCH" );

  003b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003c0	48 83 e0 10	 and	 rax, 16
  003c4	48 85 c0	 test	 rax, rax
  003c7	74 65		 je	 SHORT $LN43@z900_clear
  003c9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003ce	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003d4	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  003d9	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  003de	48 23 d1	 and	 rdx, rcx
  003e1	48 8b ca	 mov	 rcx, rdx
  003e4	8b c9		 mov	 ecx, ecx
  003e6	ba 08 00 00 00	 mov	 edx, 8
  003eb	48 6b d2 01	 imul	 rdx, rdx, 1
  003ef	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  003f4	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  003fc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00405	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0040a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194428
  00411	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00416	44 8b c9	 mov	 r9d, ecx
  00419	44 8b c2	 mov	 r8d, edx
  0041c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194429
  00423	b9 10 00 00 00	 mov	 ecx, 16
  00428	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN43@z900_clear:
  0042e	33 c0		 xor	 eax, eax
  00430	85 c0		 test	 eax, eax
  00432	75 82		 jne	 SHORT $LN22@z900_clear
$LN25@z900_clear:

; 107  : #if defined( _FEATURE_IO_ASSIST )
; 108  :         PTIO( ERR, "*CSCH (sie)" );

  00434	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0043b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0043e	48 83 e0 10	 and	 rax, 16
  00442	48 85 c0	 test	 rax, rax
  00445	74 65		 je	 SHORT $LN44@z900_clear
  00447	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0044c	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00452	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00457	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0045c	48 23 d1	 and	 rdx, rcx
  0045f	48 8b ca	 mov	 rcx, rdx
  00462	8b c9		 mov	 ecx, ecx
  00464	ba 08 00 00 00	 mov	 edx, 8
  00469	48 6b d2 01	 imul	 rdx, rdx, 1
  0046d	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00472	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0047a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00483	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00488	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194431
  0048f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00494	44 8b c9	 mov	 r9d, ecx
  00497	44 8b c2	 mov	 r8d, edx
  0049a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194432
  004a1	b9 10 00 00 00	 mov	 ecx, 16
  004a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN44@z900_clear:
  004ac	33 c0		 xor	 eax, eax
  004ae	85 c0		 test	 eax, eax
  004b0	75 82		 jne	 SHORT $LN25@z900_clear
$LN28@z900_clear:

; 109  :         SIE_INTERCEPT( regs );

  004b2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  004bd	d1 e8		 shr	 eax, 1
  004bf	83 e0 01	 and	 eax, 1
  004c2	85 c0		 test	 eax, eax
  004c4	74 18		 je	 SHORT $LN45@z900_clear
  004c6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004cb	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  004d1	ba fc ff ff ff	 mov	 edx, -4
  004d6	48 8b c8	 mov	 rcx, rax
  004d9	e8 00 00 00 00	 call	 longjmp
$LN45@z900_clear:
  004de	33 c0		 xor	 eax, eax
  004e0	85 c0		 test	 eax, eax
  004e2	75 ce		 jne	 SHORT $LN28@z900_clear

; 110  : #endif
; 111  :         regs->psw.cc = 3;

  004e4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004e9	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 112  :         return;

  004ed	eb 18		 jmp	 SHORT $LN1@z900_clear
$LN41@z900_clear:

; 113  :     }
; 114  : 
; 115  :     /* Perform clear subchannel and set condition code zero */
; 116  :     clear_subchan( regs, dev );

  004ef	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  004f4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  004f9	e8 00 00 00 00	 call	 clear_subchan

; 117  : 
; 118  :     regs->psw.cc = 0;

  004fe	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00503	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@z900_clear:
$LN46@z900_clear:

; 119  : }

  00507	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0050b	c3		 ret	 0
z900_clear_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
temp$1 = 64
b2$ = 68
effective_addr2$ = 72
dev$ = 80
inst$ = 112
regs$ = 120
z900_cancel_subchannel PROC

; 1006 : {

$LN52:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1007 : int     b2;                             /* Base of effective addr    */
; 1008 : VADR    effective_addr2;                /* Effective address         */
; 1009 : DEVBLK* dev;                            /* -> device block           */
; 1010 : 
; 1011 :     S( inst, regs, b2, effective_addr2 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	8b c0		 mov	 eax, eax
  0002e	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00033	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00037	c1 e8 0c	 shr	 eax, 12
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  00041	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  00046	74 3e		 je	 SHORT $LN32@z900_cance
  00048	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0005f	48 03 c8	 add	 rcx, rax
  00062	48 8b c1	 mov	 rax, rcx
  00065	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0006a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00076	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007b	48 23 c8	 and	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN32@z900_cance:
$LN4@z900_cance:
  00086	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008f	48 83 c0 04	 add	 rax, 4
  00093	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0009c	33 c0		 xor	 eax, eax
  0009e	83 f8 04	 cmp	 eax, 4
  000a1	74 0c		 je	 SHORT $LN33@z900_cance
  000a3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN33@z900_cance:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 d1		 jne	 SHORT $LN4@z900_cance
$LN7@z900_cance:

; 1012 : 
; 1013 :     TXF_INSTR_CHECK( regs );

  000b5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000c1	85 c0		 test	 eax, eax
  000c3	74 36		 je	 SHORT $LN34@z900_cance
  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000d0	0f ba e8 0c	 bts	 eax, 12
  000d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d9	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  000df	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195570
  000e6	41 b8 0b 00 00
	00		 mov	 r8d, 11
  000ec	ba 02 00 00 00	 mov	 edx, 2
  000f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	e8 00 00 00 00	 call	 z900_abort_transaction
$LN34@z900_cance:
  000fb	33 c0		 xor	 eax, eax
  000fd	85 c0		 test	 eax, eax
  000ff	75 b4		 jne	 SHORT $LN7@z900_cance

; 1014 :     PRIV_CHECK( regs );

  00101	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00106	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0010a	83 e0 01	 and	 eax, 1
  0010d	85 c0		 test	 eax, eax
  0010f	74 15		 je	 SHORT $LN35@z900_cance
  00111	ba 02 00 00 00	 mov	 edx, 2
  00116	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00120	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN35@z900_cance:
$LN10@z900_cance:

; 1015 : 
; 1016 :     PTIO( IO, "XSCH" );

  00126	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0012d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00130	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00136	48 85 c0	 test	 rax, rax
  00139	74 65		 je	 SHORT $LN36@z900_cance
  0013b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00140	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00146	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0014b	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00150	48 23 d1	 and	 rdx, rcx
  00153	48 8b ca	 mov	 rcx, rdx
  00156	8b c9		 mov	 ecx, ecx
  00158	ba 08 00 00 00	 mov	 edx, 8
  0015d	48 6b d2 01	 imul	 rdx, rdx, 1
  00161	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00166	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0016e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00177	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0017c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195573
  00183	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00188	44 8b c9	 mov	 r9d, ecx
  0018b	44 8b c2	 mov	 r8d, edx
  0018e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195574
  00195	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@z900_cance:
  001a0	33 c0		 xor	 eax, eax
  001a2	85 c0		 test	 eax, eax
  001a4	75 80		 jne	 SHORT $LN10@z900_cance

; 1017 : 
; 1018 : #if defined( _FEATURE_IO_ASSIST )
; 1019 :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  001a6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001ab	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001b1	d1 e8		 shr	 eax, 1
  001b3	83 e0 01	 and	 eax, 1
  001b6	85 c0		 test	 eax, eax
  001b8	0f 84 f0 00 00
	00		 je	 $LN37@z900_cance
  001be	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c3	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  001ca	b9 01 00 00 00	 mov	 ecx, 1
  001cf	48 6b c9 00	 imul	 rcx, rcx, 0
  001d3	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  001d8	83 e0 04	 and	 eax, 4
  001db	85 c0		 test	 eax, eax
  001dd	0f 85 cb 00 00
	00		 jne	 $LN37@z900_cance
  001e3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001ee	c1 e8 02	 shr	 eax, 2
  001f1	83 e0 01	 and	 eax, 1
  001f4	85 c0		 test	 eax, eax
  001f6	0f 85 b2 00 00
	00		 jne	 $LN37@z900_cance
$LN13@z900_cance:

; 1020 : #endif
; 1021 :     {
; 1022 :         PTIO( IO, "XSCH (sie)" );

  001fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00203	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00206	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0020c	48 85 c0	 test	 rax, rax
  0020f	74 65		 je	 SHORT $LN38@z900_cance
  00211	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00216	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0021c	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00221	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00226	48 23 d1	 and	 rdx, rcx
  00229	48 8b ca	 mov	 rcx, rdx
  0022c	8b c9		 mov	 ecx, ecx
  0022e	ba 08 00 00 00	 mov	 edx, 8
  00233	48 6b d2 01	 imul	 rdx, rdx, 1
  00237	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0023c	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00244	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0024d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00252	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195577
  00259	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025e	44 8b c9	 mov	 r9d, ecx
  00261	44 8b c2	 mov	 r8d, edx
  00264	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195578
  0026b	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00270	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN38@z900_cance:
  00276	33 c0		 xor	 eax, eax
  00278	85 c0		 test	 eax, eax
  0027a	75 80		 jne	 SHORT $LN13@z900_cance
$LN16@z900_cance:

; 1023 :         SIE_INTERCEPT( regs );

  0027c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00281	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00287	d1 e8		 shr	 eax, 1
  00289	83 e0 01	 and	 eax, 1
  0028c	85 c0		 test	 eax, eax
  0028e	74 18		 je	 SHORT $LN39@z900_cance
  00290	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00295	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0029b	ba fc ff ff ff	 mov	 edx, -4
  002a0	48 8b c8	 mov	 rcx, rax
  002a3	e8 00 00 00 00	 call	 longjmp
$LN39@z900_cance:
  002a8	33 c0		 xor	 eax, eax
  002aa	85 c0		 test	 eax, eax
  002ac	75 ce		 jne	 SHORT $LN16@z900_cance
$LN37@z900_cance:

; 1024 :     }
; 1025 : 
; 1026 :     /* Program check if the ssid including lcss is invalid */
; 1027 :     SSID_CHECK( regs );

  002ae	b8 08 00 00 00	 mov	 eax, 8
  002b3	48 6b c0 01	 imul	 rax, rax, 1
  002b7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002bc	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002c4	83 e0 01	 and	 eax, 1
  002c7	85 c0		 test	 eax, eax
  002c9	74 1b		 je	 SHORT $LN41@z900_cance
  002cb	b8 08 00 00 00	 mov	 eax, 8
  002d0	48 6b c0 01	 imul	 rax, rax, 1
  002d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002d9	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002e1	83 f8 03	 cmp	 eax, 3
  002e4	7e 15		 jle	 SHORT $LN40@z900_cance
$LN41@z900_cance:
  002e6	ba 15 00 00 00	 mov	 edx, 21
  002eb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002f0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002f5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN40@z900_cance:

; 1028 : 
; 1029 :     /* Locate the device block for this subchannel */
; 1030 :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  002fb	b8 08 00 00 00	 mov	 eax, 8
  00300	48 6b c0 01	 imul	 rax, rax, 1
  00304	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  00310	e8 00 00 00 00	 call	 find_device_by_subchan
  00315	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax

; 1031 : 
; 1032 :     if (dev)

  0031a	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00320	74 5a		 je	 SHORT $LN42@z900_cance
$LN19@z900_cance:

; 1033 :         PTT( PTT_CL_IO, "XSCH (dev)", dev->devnum, 0, 0 );

  00322	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00329	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0032c	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00332	48 85 c0	 test	 rax, rax
  00335	74 3f		 je	 SHORT $LN43@z900_cance
  00337	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0033c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00340	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00349	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00352	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195584
  00359	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0035e	45 33 c9	 xor	 r9d, r9d
  00361	44 8b c0	 mov	 r8d, eax
  00364	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195585
  0036b	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00370	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN43@z900_cance:
  00376	33 c0		 xor	 eax, eax
  00378	85 c0		 test	 eax, eax
  0037a	75 a6		 jne	 SHORT $LN19@z900_cance
$LN42@z900_cance:

; 1034 : 
; 1035 :     /* Condition code 3 if subchannel does not exist,
; 1036 :        is not valid, or is not enabled */
; 1037 :     if (0
; 1038 :         || !dev
; 1039 :         || !(dev->pmcw.flag5 & PMCW5_V)
; 1040 :         || !(dev->pmcw.flag5 & PMCW5_E)

  0037c	33 c0		 xor	 eax, eax
  0037e	85 c0		 test	 eax, eax
  00380	75 34		 jne	 SHORT $LN45@z900_cance
  00382	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00388	74 2c		 je	 SHORT $LN45@z900_cance
  0038a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0038f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00396	83 e0 01	 and	 eax, 1
  00399	85 c0		 test	 eax, eax
  0039b	74 19		 je	 SHORT $LN45@z900_cance
  0039d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  003a2	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  003a9	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003ae	85 c0		 test	 eax, eax
  003b0	0f 85 3c 01 00
	00		 jne	 $LN44@z900_cance
$LN45@z900_cance:
$LN22@z900_cance:

; 1041 :     )
; 1042 :     {
; 1043 :         PTIO( ERR, "*XSCH" );

  003b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003c0	48 83 e0 10	 and	 rax, 16
  003c4	48 85 c0	 test	 rax, rax
  003c7	74 65		 je	 SHORT $LN46@z900_cance
  003c9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003ce	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003d4	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  003d9	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  003de	48 23 d1	 and	 rdx, rcx
  003e1	48 8b ca	 mov	 rcx, rdx
  003e4	8b c9		 mov	 ecx, ecx
  003e6	ba 08 00 00 00	 mov	 edx, 8
  003eb	48 6b d2 01	 imul	 rdx, rdx, 1
  003ef	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  003f4	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  003fc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00405	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0040a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195589
  00411	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00416	44 8b c9	 mov	 r9d, ecx
  00419	44 8b c2	 mov	 r8d, edx
  0041c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195590
  00423	b9 10 00 00 00	 mov	 ecx, 16
  00428	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN46@z900_cance:
  0042e	33 c0		 xor	 eax, eax
  00430	85 c0		 test	 eax, eax
  00432	75 82		 jne	 SHORT $LN22@z900_cance
$LN25@z900_cance:

; 1044 : #if defined( _FEATURE_IO_ASSIST )
; 1045 :         PTIO( ERR, "*XSCH (sie)" );

  00434	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0043b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0043e	48 83 e0 10	 and	 rax, 16
  00442	48 85 c0	 test	 rax, rax
  00445	74 65		 je	 SHORT $LN47@z900_cance
  00447	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0044c	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00452	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00457	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0045c	48 23 d1	 and	 rdx, rcx
  0045f	48 8b ca	 mov	 rcx, rdx
  00462	8b c9		 mov	 ecx, ecx
  00464	ba 08 00 00 00	 mov	 edx, 8
  00469	48 6b d2 01	 imul	 rdx, rdx, 1
  0046d	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00472	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0047a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00483	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00488	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195592
  0048f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00494	44 8b c9	 mov	 r9d, ecx
  00497	44 8b c2	 mov	 r8d, edx
  0049a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195593
  004a1	b9 10 00 00 00	 mov	 ecx, 16
  004a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN47@z900_cance:
  004ac	33 c0		 xor	 eax, eax
  004ae	85 c0		 test	 eax, eax
  004b0	75 82		 jne	 SHORT $LN25@z900_cance
$LN28@z900_cance:

; 1046 :         SIE_INTERCEPT( regs );

  004b2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004b7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  004bd	d1 e8		 shr	 eax, 1
  004bf	83 e0 01	 and	 eax, 1
  004c2	85 c0		 test	 eax, eax
  004c4	74 18		 je	 SHORT $LN48@z900_cance
  004c6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004cb	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  004d1	ba fc ff ff ff	 mov	 edx, -4
  004d6	48 8b c8	 mov	 rcx, rax
  004d9	e8 00 00 00 00	 call	 longjmp
$LN48@z900_cance:
  004de	33 c0		 xor	 eax, eax
  004e0	85 c0		 test	 eax, eax
  004e2	75 ce		 jne	 SHORT $LN28@z900_cance

; 1047 : #endif
; 1048 :         regs->psw.cc = 3;

  004e4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004e9	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 1049 :         return;

  004ed	e9 a2 00 00 00	 jmp	 $LN1@z900_cance
$LN44@z900_cance:

; 1050 :     }
; 1051 : 
; 1052 :     /* Perform cancel subchannel and set condition code */
; 1053 :     regs->psw.cc = cancel_subchan( regs, dev );

  004f2	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  004f7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  004fc	e8 00 00 00 00	 call	 cancel_subchan
  00501	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00506	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1054 : 
; 1055 :     if (regs->psw.cc != 0)

  00509	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0050e	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00512	85 c0		 test	 eax, eax
  00514	74 7e		 je	 SHORT $LN49@z900_cance
$LN31@z900_cance:

; 1056 :         PTIO( ERR, "*XSCH" );

  00516	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0051d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00520	48 83 e0 10	 and	 rax, 16
  00524	48 85 c0	 test	 rax, rax
  00527	74 65		 je	 SHORT $LN50@z900_cance
  00529	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0052e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00534	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00539	48 8b 54 24 48	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0053e	48 23 d1	 and	 rdx, rcx
  00541	48 8b ca	 mov	 rcx, rdx
  00544	8b c9		 mov	 ecx, ecx
  00546	ba 08 00 00 00	 mov	 edx, 8
  0054b	48 6b d2 01	 imul	 rdx, rdx, 1
  0054f	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00554	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0055c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00565	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0056a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195597
  00571	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00576	44 8b c9	 mov	 r9d, ecx
  00579	44 8b c2	 mov	 r8d, edx
  0057c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195598
  00583	b9 10 00 00 00	 mov	 ecx, 16
  00588	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN50@z900_cance:
  0058e	33 c0		 xor	 eax, eax
  00590	85 c0		 test	 eax, eax
  00592	75 82		 jne	 SHORT $LN31@z900_cance
$LN49@z900_cance:
$LN1@z900_cance:
$LN51@z900_cance:

; 1057 : }

  00594	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00598	c3		 ret	 0
z900_cancel_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_validate_operand
_TEXT	SEGMENT
tv79 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
s390_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s390_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00043	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00047	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004c	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00051	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00055	3b c1		 cmp	 eax, ecx
  00057	7e 0a		 jle	 SHORT $LN6@s390_valid
  00059	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN7@s390_valid
$LN6@s390_valid:
  00063	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN7@s390_valid:
  0006b	83 7c 24 30 00	 cmp	 DWORD PTR tv79[rsp], 0
  00070	74 42		 je	 SHORT $LN2@s390_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00072	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00076	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00089	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00092	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00096	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  0009a	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0009e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000a8	ba 01 00 00 00	 mov	 edx, 1
  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 s390_maddr_l
$LN2@s390_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
s390_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s390_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN7@s390_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN8@s390_vfetc
$LN7@s390_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	74 62		 je	 SHORT $LN2@s390_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00050	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00055	ff c0		 inc	 eax
  00057	48 98		 cdqe
  00059	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00065	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00069	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00071	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00079	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00081	48 8b d0	 mov	 rdx, rax
  00084	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00095	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009a	ff c0		 inc	 eax
  0009c	48 98		 cdqe
  0009e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a3	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	f3 a4		 rep movsb

; 640  :     }

  000ad	e9 f7 00 00 00	 jmp	 $LN3@s390_vfetc
$LN2@s390_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000b9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000be	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c3	2b c8		 sub	 ecx, eax
  000c5	8b c1		 mov	 eax, ecx
  000c7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000dc	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e0	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000e8	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f0	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f8	48 8b d0	 mov	 rdx, rax
  000fb	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00102	e8 00 00 00 00	 call	 s390_maddr_l
  00107	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  0010c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00111	ff c0		 inc	 eax
  00113	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00117	48 98		 cdqe
  00119	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  0011d	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  00124	03 d1		 add	 edx, ecx
  00126	8b ca		 mov	 ecx, edx
  00128	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00130	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00136	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00142	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00146	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0014e	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00156	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0015e	48 8b d0	 mov	 rdx, rax
  00161	e8 00 00 00 00	 call	 s390_maddr_l
  00166	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  0016b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00170	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00175	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  0017a	48 8b c8	 mov	 rcx, rax
  0017d	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0017f	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00184	ff c0		 inc	 eax
  00186	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0018a	48 98		 cdqe
  0018c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00191	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  00196	48 03 d1	 add	 rdx, rcx
  00199	48 8b ca	 mov	 rcx, rdx
  0019c	48 8b f9	 mov	 rdi, rcx
  0019f	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001a4	48 8b c8	 mov	 rcx, rax
  001a7	f3 a4		 rep movsb
$LN3@s390_vfetc:

; 649  :     }
; 650  : }

  001a9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ad	5f		 pop	 rdi
  001ae	5e		 pop	 rsi
  001af	c3		 ret	 0
s390_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstore8 PROC					; COMDAT

; 577  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 578  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 579  :     /* Check alignement. If aligned then we are guaranteed
; 580  :        not to cross a page boundary */
; 581  :     if (likely(!((VADR_L)addr & 0x07)))
; 582  :     {
; 583  :         /* Most common case : Aligned */
; 584  :         U64 *mn;
; 585  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );
; 586  :         if (regs->cpubit == regs->sysblk->started_mask)
; 587  :             *mn = CSWAP64( value );
; 588  :         else
; 589  :             STORE_DW( mn, value );
; 590  :     }
; 591  :     else
; 592  : #endif
; 593  :     {
; 594  :         /* We're not aligned. So we have to check whether we are
; 595  :            crossing a page boundary. This cannot be the same
; 596  :            code as above because casting U64* to a non aligned
; 597  :            pointer may break on those architectures mandating
; 598  :            strict alignement */
; 599  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00017	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  0001b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00020	3d f8 0f 00 00	 cmp	 eax, 4088		; 00000ff8H
  00025	77 0a		 ja	 SHORT $LN7@s390_vstor
  00027	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0002f	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00031	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN8@s390_vstor:
  00039	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  0003e	74 4b		 je	 SHORT $LN2@s390_vstor

; 600  :         {
; 601  :             /* Non aligned but not crossing page boundary */
; 602  :             BYTE *mn;
; 603  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00040	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00045	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00049	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0004d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00055	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0005a	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  0005f	ba 08 00 00 00	 mov	 edx, 8
  00064	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  00068	e8 00 00 00 00	 call	 s390_maddr_l
  0006d	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 604  :             /* invoking STORE_DW ensures endianness correctness */
; 605  :             STORE_DW( mn, value );

  00072	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  00077	e8 00 00 00 00	 call	 _byteswap_uint64
  0007c	48 8b d0	 mov	 rdx, rax
  0007f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00084	e8 00 00 00 00	 call	 store_dw_noswap

; 606  :         }

  00089	eb 18		 jmp	 SHORT $LN3@s390_vstor
$LN2@s390_vstor:

; 607  :         else
; 608  :             /* Crossing page boundary */
; 609  :             ARCH_DEP( vstore8_full )( value, addr, arn, regs );

  0008b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00090	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00095	8b 54 24 58	 mov	 edx, DWORD PTR addr$[rsp]
  00099	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  0009e	e8 00 00 00 00	 call	 s390_vstore8_full
$LN3@s390_vstor:

; 610  :     }
; 611  :     ITIMER_UPDATE( addr, 8-1, regs );
; 612  : }

  000a3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a7	c3		 ret	 0
s390_vstore8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstore4 PROC					; COMDAT

; 559  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00016	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  0001a	83 e0 03	 and	 eax, 3
  0001d	85 c0		 test	 eax, eax
  0001f	75 0a		 jne	 SHORT $LN6@s390_vstor
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN7@s390_vstor
$LN6@s390_vstor:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN7@s390_vstor:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00038	74 0a		 je	 SHORT $LN10@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN11@s390_vstor
$LN10@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN11@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00051	75 10		 jne	 SHORT $LN4@s390_vstor
  00053	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  00057	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0005c	3d fc 0f 00 00	 cmp	 eax, 4092		; 00000ffcH
  00061	77 49		 ja	 SHORT $LN2@s390_vstor
$LN4@s390_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00063	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00068	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006c	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00070	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00078	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0007d	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00082	ba 04 00 00 00	 mov	 edx, 4
  00087	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  00095	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  00099	e8 00 00 00 00	 call	 _byteswap_ulong
  0009e	8b d0		 mov	 edx, eax
  000a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  000a5	e8 00 00 00 00	 call	 store_fw_noswap

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );
; 568  :     }

  000aa	eb 17		 jmp	 SHORT $LN3@s390_vstor
$LN2@s390_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  000ac	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000b1	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000b6	8b 54 24 58	 mov	 edx, DWORD PTR addr$[rsp]
  000ba	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000be	e8 00 00 00 00	 call	 s390_vstore4_full
$LN3@s390_vstor:

; 571  : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
s390_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
sk$ = 56
tv81 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s390_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN7@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	74 6f		 je	 SHORT $LN2@s390_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00053	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	48 98		 cdqe
  0005f	48 89 44 24 40	 mov	 QWORD PTR tv81[rsp], rax
  00064	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006c	ff c1		 inc	 ecx
  0006e	48 63 c9	 movsxd	 rcx, ecx
  00071	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00079	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007d	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00081	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00089	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00091	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00099	48 8b d1	 mov	 rdx, rcx
  0009c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a3	e8 00 00 00 00	 call	 s390_maddr_l
  000a8	48 8b f8	 mov	 rdi, rax
  000ab	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000bd	e9 29 01 00 00	 jmp	 $LN3@s390_vstor
$LN2@s390_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000c9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000ce	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d3	2b c8		 sub	 ecx, eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000db	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000ec	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00100	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00108	48 8b d0	 mov	 rdx, rax
  0010b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00112	e8 00 00 00 00	 call	 s390_maddr_l
  00117	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0012b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00130	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00138	ff c0		 inc	 eax
  0013a	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0013e	48 98		 cdqe
  00140	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00144	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0014b	03 d1		 add	 edx, ecx
  0014d	8b ca		 mov	 ecx, edx
  0014f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  0015d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00165	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00169	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0016d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00175	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017d	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00185	48 8b d0	 mov	 rdx, rax
  00188	e8 00 00 00 00	 call	 s390_maddr_l
  0018d	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00192	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00197	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019a	83 c8 06	 or	 eax, 6
  0019d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001a2	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001a9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001bb	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001c9	48 98		 cdqe
  001cb	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001d0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001d8	48 03 d1	 add	 rdx, rcx
  001db	48 8b ca	 mov	 rcx, rdx
  001de	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001e3	48 8b f1	 mov	 rsi, rcx
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	f3 a4		 rep movsb
$LN3@s390_vstor:

; 512  :     }
; 513  : }

  001eb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ef	5f		 pop	 rdi
  001f0	5e		 pop	 rsi
  001f1	c3		 ret	 0
s390_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore8_full
_TEXT	SEGMENT
len$ = 48
sk$ = 56
main1$ = 64
main2$ = 72
temp$ = 80
__$ArrayPad$ = 88
value$ = 128
addr$ = 136
arn$ = 144
regs$ = 152
s390_vstore8_full PROC					; COMDAT

; 369  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 371  : BYTE   *sk;                             /* Storage key addresses     */
; 372  : int     len;                            /* Length to end of page     */
; 373  : BYTE    temp[8];                        /* Copied value              */
; 374  : 
; 375  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00028	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00039	2b c8		 sub	 ecx, eax
  0003b	8b c1		 mov	 eax, ecx
  0003d	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 376  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00041	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00046	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00052	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00056	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0005e	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00066	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0006e	48 8b d0	 mov	 rdx, rax
  00071	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00078	e8 00 00 00 00	 call	 s390_maddr_l
  0007d	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 377  :     sk = regs->dat.storkey;

  00082	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00091	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 378  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8-len, arn, regs,

  00096	b8 08 00 00 00	 mov	 eax, 8
  0009b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0009f	48 98		 cdqe
  000a1	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000a5	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  000ac	03 d1		 add	 edx, ecx
  000ae	8b ca		 mov	 ecx, edx
  000b0	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b8	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000be	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c6	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000ca	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ce	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d6	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000de	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000e6	48 8b d0	 mov	 rdx, rax
  000e9	e8 00 00 00 00	 call	 s390_maddr_l
  000ee	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 379  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 380  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000f3	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000f8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000fb	83 c8 06	 or	 eax, 6
  000fe	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  00103	88 01		 mov	 BYTE PTR [rcx], al

; 381  :     STORE_DW( temp, value );

  00105	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  0010d	e8 00 00 00 00	 call	 _byteswap_uint64
  00112	48 8b d0	 mov	 rdx, rax
  00115	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  0011a	e8 00 00 00 00	 call	 store_dw_noswap

; 382  :     memcpy( main1, temp,       len );

  0011f	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00124	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00129	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  0012e	48 8b f1	 mov	 rsi, rcx
  00131	48 8b c8	 mov	 rcx, rax
  00134	f3 a4		 rep movsb

; 383  :     memcpy( main2, temp+len, 8-len );

  00136	b8 08 00 00 00	 mov	 eax, 8
  0013b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0013f	48 98		 cdqe
  00141	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00146	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  0014b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  00150	48 8b f1	 mov	 rsi, rcx
  00153	48 8b c8	 mov	 rcx, rax
  00156	f3 a4		 rep movsb

; 384  : }

  00158	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0015d	48 33 cc	 xor	 rcx, rsp
  00160	e8 00 00 00 00	 call	 __security_check_cookie
  00165	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00169	5f		 pop	 rdi
  0016a	5e		 pop	 rsi
  0016b	c3		 ret	 0
s390_vstore8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
s390_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00018	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  0001c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00021	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00026	2b c8		 sub	 ecx, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  0002e	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00033	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0003f	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00043	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0004b	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00053	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	8b 4c 24 78	 mov	 ecx, DWORD PTR addr$[rsp]
  00062	e8 00 00 00 00	 call	 s390_maddr_l
  00067	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  0006c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0007b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00089	48 98		 cdqe
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  0008f	8b 54 24 78	 mov	 edx, DWORD PTR addr$[rsp]
  00093	03 d1		 add	 edx, ecx
  00095	8b ca		 mov	 ecx, edx
  00097	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0009f	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000a5	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ad	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000b1	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000b5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000bd	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c5	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000cd	48 8b d0	 mov	 rdx, rax
  000d0	e8 00 00 00 00	 call	 s390_maddr_l
  000d5	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000da	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000df	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e2	83 c8 06	 or	 eax, 6
  000e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000ea	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000ec	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000f0	e8 00 00 00 00	 call	 _byteswap_ulong
  000f5	8b d0		 mov	 edx, eax
  000f7	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  000fc	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  00101	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00106	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  0010b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00110	48 8b f1	 mov	 rsi, rcx
  00113	48 8b c8	 mov	 rcx, rax
  00116	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00118	b8 04 00 00 00	 mov	 eax, 4
  0011d	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00121	48 98		 cdqe
  00123	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00128	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  0012d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  00132	48 8b f1	 mov	 rsi, rcx
  00135	48 8b c8	 mov	 rcx, rax
  00138	f3 a4		 rep movsb

; 350  : }

  0013a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0013e	5f		 pop	 rdi
  0013f	5e		 pop	 rsi
  00140	c3		 ret	 0
s390_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_ptr_to_storekey
_TEXT	SEGMENT
abs$ = 48
s390_get_ptr_to_storekey PROC				; COMDAT

; 308  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 309  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 310  :     return ARCH_DEP( get_ptr_to_2K_storekey )( abs );
; 311  : #else
; 312  :     return ARCH_DEP( get_ptr_to_4K_storekey )( abs );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0000e	e8 00 00 00 00	 call	 s390_get_ptr_to_4K_storekey

; 313  : #endif
; 314  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
s390_get_ptr_to_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_ptr_to_4K_storekey
_TEXT	SEGMENT
abs$ = 48
s390_get_ptr_to_4K_storekey PROC			; COMDAT

; 238  :   inline BYTE* ARCH_DEP( get_ptr_to_4K_storekey ) (              U64 abs            ) { return           _get_storekey_ptr     (      abs, 4 );                         }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 04		 mov	 dl, 4
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 _get_storekey_ptr
  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
s390_get_ptr_to_4K_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
b2$ = 68
dev$ = 72
temp$1 = 80
cc$ = 84
irb$ = 96
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s390_test_subchannel PROC

; 930  : {

$LN52:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 931  : int     b2;                             /* Effective addr base       */
; 932  : VADR    effective_addr2;                /* Effective address         */
; 933  : DEVBLK* dev;                            /* -> device block           */
; 934  : IRB     irb;                            /* Interruption response blk */
; 935  : int     cc;                             /* Condition Code            */
; 936  : 
; 937  :     S( inst, regs, b2, effective_addr2 );

  00023	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 50	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00048	8b 44 24 50	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 0c	 shr	 eax, 12
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  00056	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005b	74 3a		 je	 SHORT $LN32@s390_test_
  0005d	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  00062	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00071	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00075	03 c8		 add	 ecx, eax
  00077	8b c1		 mov	 eax, ecx
  00079	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0007d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00085	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0008b	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0008f	23 c8		 and	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN32@s390_test_:
$LN4@s390_test_:
  00097	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000a3	48 83 c0 04	 add	 rax, 4
  000a7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000af	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000b3	33 c0		 xor	 eax, eax
  000b5	83 f8 04	 cmp	 eax, 4
  000b8	74 0f		 je	 SHORT $LN33@s390_test_
  000ba	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c2	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN33@s390_test_:
  000c9	33 c0		 xor	 eax, eax
  000cb	85 c0		 test	 eax, eax
  000cd	75 c8		 jne	 SHORT $LN4@s390_test_

; 938  :     PER_ZEROADDR_XCHECK( regs, b2 );
; 939  : 
; 940  :     TXF_INSTR_CHECK( regs );
; 941  :     PRIV_CHECK( regs );

  000cf	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000db	83 e0 01	 and	 eax, 1
  000de	85 c0		 test	 eax, eax
  000e0	74 1b		 je	 SHORT $LN34@s390_test_
  000e2	ba 02 00 00 00	 mov	 edx, 2
  000e7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN34@s390_test_:
$LN7@s390_test_:

; 942  :     PTIO( IO, "TSCH" );

  000fd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00104	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00107	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0010d	48 85 c0	 test	 rax, rax
  00110	74 5d		 je	 SHORT $LN35@s390_test_
  00112	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00120	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00124	ba 08 00 00 00	 mov	 edx, 8
  00129	48 6b d2 01	 imul	 rdx, rdx, 1
  0012d	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00135	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0013d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00146	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0014b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181304
  00152	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00157	44 8b c9	 mov	 r9d, ecx
  0015a	44 8b c2	 mov	 r8d, edx
  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181305
  00164	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN35@s390_test_:
  0016f	33 c0		 xor	 eax, eax
  00171	85 c0		 test	 eax, eax
  00173	75 88		 jne	 SHORT $LN7@s390_test_

; 943  : 
; 944  : #if defined( _FEATURE_IO_ASSIST )
; 945  :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  00175	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00183	d1 e8		 shr	 eax, 1
  00185	83 e0 01	 and	 eax, 1
  00188	85 c0		 test	 eax, eax
  0018a	0f 84 f4 00 00
	00		 je	 $LN36@s390_test_
  00190	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00198	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0019f	b9 01 00 00 00	 mov	 ecx, 1
  001a4	48 6b c9 00	 imul	 rcx, rcx, 0
  001a8	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  001ad	83 e0 04	 and	 eax, 4
  001b0	85 c0		 test	 eax, eax
  001b2	0f 85 cc 00 00
	00		 jne	 $LN36@s390_test_
  001b8	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001c6	c1 e8 02	 shr	 eax, 2
  001c9	83 e0 01	 and	 eax, 1
  001cc	85 c0		 test	 eax, eax
  001ce	0f 85 b0 00 00
	00		 jne	 $LN36@s390_test_
$LN10@s390_test_:

; 946  : #endif
; 947  :     {
; 948  :         PTIO( IO, "TSCH (sie)" );

  001d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001db	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001de	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001e4	48 85 c0	 test	 rax, rax
  001e7	74 5d		 je	 SHORT $LN37@s390_test_
  001e9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001f7	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001fb	ba 08 00 00 00	 mov	 edx, 8
  00200	48 6b d2 01	 imul	 rdx, rdx, 1
  00204	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020c	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00214	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0021d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00222	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181308
  00229	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022e	44 8b c9	 mov	 r9d, ecx
  00231	44 8b c2	 mov	 r8d, edx
  00234	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181309
  0023b	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN37@s390_test_:
  00246	33 c0		 xor	 eax, eax
  00248	85 c0		 test	 eax, eax
  0024a	75 88		 jne	 SHORT $LN10@s390_test_
$LN13@s390_test_:

; 949  :         SIE_INTERCEPT( regs );

  0024c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00254	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0025a	d1 e8		 shr	 eax, 1
  0025c	83 e0 01	 and	 eax, 1
  0025f	85 c0		 test	 eax, eax
  00261	74 1b		 je	 SHORT $LN38@s390_test_
  00263	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026b	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00271	ba fc ff ff ff	 mov	 edx, -4
  00276	48 8b c8	 mov	 rcx, rax
  00279	e8 00 00 00 00	 call	 longjmp
$LN38@s390_test_:
  0027e	33 c0		 xor	 eax, eax
  00280	85 c0		 test	 eax, eax
  00282	75 c8		 jne	 SHORT $LN13@s390_test_
$LN36@s390_test_:

; 950  :     }
; 951  : 
; 952  :     FW_CHECK( effective_addr2, regs );

  00284	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00288	83 e0 03	 and	 eax, 3
  0028b	85 c0		 test	 eax, eax
  0028d	74 1b		 je	 SHORT $LN39@s390_test_
  0028f	ba 06 00 00 00	 mov	 edx, 6
  00294	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a4	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN39@s390_test_:

; 953  : 
; 954  :     /* Program check if the ssid including lcss is invalid */
; 955  :     SSID_CHECK( regs );

  002aa	b8 08 00 00 00	 mov	 eax, 8
  002af	48 6b c0 01	 imul	 rax, rax, 1
  002b3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bb	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002c3	83 e0 01	 and	 eax, 1
  002c6	85 c0		 test	 eax, eax
  002c8	74 1e		 je	 SHORT $LN41@s390_test_
  002ca	b8 08 00 00 00	 mov	 eax, 8
  002cf	48 6b c0 01	 imul	 rax, rax, 1
  002d3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002db	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002e3	83 f8 03	 cmp	 eax, 3
  002e6	7e 1b		 jle	 SHORT $LN40@s390_test_
$LN41@s390_test_:
  002e8	ba 15 00 00 00	 mov	 edx, 21
  002ed	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002fd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN40@s390_test_:

; 956  : 
; 957  :     /* Locate the device block for this subchannel */
; 958  :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  00303	b8 08 00 00 00	 mov	 eax, 8
  00308	48 6b c0 01	 imul	 rax, rax, 1
  0030c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00314	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  0031b	e8 00 00 00 00	 call	 find_device_by_subchan
  00320	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax

; 959  : 
; 960  :     if (dev)

  00325	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0032b	74 5a		 je	 SHORT $LN42@s390_test_
$LN16@s390_test_:

; 961  :         PTT( PTT_CL_IO, "TSCH (dev)", dev->devnum, 0, 0 );

  0032d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00334	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00337	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0033d	48 85 c0	 test	 rax, rax
  00340	74 3f		 je	 SHORT $LN43@s390_test_
  00342	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00347	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0034b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00354	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0035d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181316
  00364	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00369	45 33 c9	 xor	 r9d, r9d
  0036c	44 8b c0	 mov	 r8d, eax
  0036f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181317
  00376	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0037b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN43@s390_test_:
  00381	33 c0		 xor	 eax, eax
  00383	85 c0		 test	 eax, eax
  00385	75 a6		 jne	 SHORT $LN16@s390_test_
$LN42@s390_test_:

; 962  : 
; 963  :     /* Condition code 3 if subchannel does not exist,
; 964  :        is not valid, or is not enabled */
; 965  :     if (0
; 966  :         || !dev
; 967  :         || !(dev->pmcw.flag5 & PMCW5_V)
; 968  :         || !(dev->pmcw.flag5 & PMCW5_E)

  00387	33 c0		 xor	 eax, eax
  00389	85 c0		 test	 eax, eax
  0038b	75 34		 jne	 SHORT $LN45@s390_test_
  0038d	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00393	74 2c		 je	 SHORT $LN45@s390_test_
  00395	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0039a	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  003a1	83 e0 01	 and	 eax, 1
  003a4	85 c0		 test	 eax, eax
  003a6	74 19		 je	 SHORT $LN45@s390_test_
  003a8	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  003ad	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  003b4	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003b9	85 c0		 test	 eax, eax
  003bb	0f 85 35 01 00
	00		 jne	 $LN44@s390_test_
$LN45@s390_test_:
$LN19@s390_test_:

; 969  :     )
; 970  :     {
; 971  :         PTIO( ERR, "*TSCH" );

  003c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003c8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003cb	48 83 e0 10	 and	 rax, 16
  003cf	48 85 c0	 test	 rax, rax
  003d2	74 5d		 je	 SHORT $LN46@s390_test_
  003d4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003dc	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003e2	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  003e6	ba 08 00 00 00	 mov	 edx, 8
  003eb	48 6b d2 01	 imul	 rdx, rdx, 1
  003ef	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003f7	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  003ff	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00408	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0040d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181321
  00414	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00419	44 8b c9	 mov	 r9d, ecx
  0041c	44 8b c2	 mov	 r8d, edx
  0041f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181322
  00426	b9 10 00 00 00	 mov	 ecx, 16
  0042b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN46@s390_test_:
  00431	33 c0		 xor	 eax, eax
  00433	85 c0		 test	 eax, eax
  00435	75 8a		 jne	 SHORT $LN19@s390_test_
$LN22@s390_test_:

; 972  : #if defined( _FEATURE_IO_ASSIST )
; 973  :         PTIO( ERR, "*TSCH (sie)" );

  00437	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0043e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00441	48 83 e0 10	 and	 rax, 16
  00445	48 85 c0	 test	 rax, rax
  00448	74 5d		 je	 SHORT $LN47@s390_test_
  0044a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00452	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00458	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0045c	ba 08 00 00 00	 mov	 edx, 8
  00461	48 6b d2 01	 imul	 rdx, rdx, 1
  00465	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0046d	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00475	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0047e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00483	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181324
  0048a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0048f	44 8b c9	 mov	 r9d, ecx
  00492	44 8b c2	 mov	 r8d, edx
  00495	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181325
  0049c	b9 10 00 00 00	 mov	 ecx, 16
  004a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN47@s390_test_:
  004a7	33 c0		 xor	 eax, eax
  004a9	85 c0		 test	 eax, eax
  004ab	75 8a		 jne	 SHORT $LN22@s390_test_
$LN25@s390_test_:

; 974  :         SIE_INTERCEPT( regs );

  004ad	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  004bb	d1 e8		 shr	 eax, 1
  004bd	83 e0 01	 and	 eax, 1
  004c0	85 c0		 test	 eax, eax
  004c2	74 1b		 je	 SHORT $LN48@s390_test_
  004c4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004cc	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  004d2	ba fc ff ff ff	 mov	 edx, -4
  004d7	48 8b c8	 mov	 rcx, rax
  004da	e8 00 00 00 00	 call	 longjmp
$LN48@s390_test_:
  004df	33 c0		 xor	 eax, eax
  004e1	85 c0		 test	 eax, eax
  004e3	75 c8		 jne	 SHORT $LN25@s390_test_

; 975  : #endif
; 976  :         regs->psw.cc = 3;

  004e5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ed	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 977  :         return;

  004f1	e9 03 01 00 00	 jmp	 $LN1@s390_test_
$LN44@s390_test_:

; 978  :     }
; 979  : 
; 980  :     /* validate operand before taking any action */
; 981  :     ARCH_DEP( validate_operand )( effective_addr2, b2, sizeof( IRB ) - 1,

  004f6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00503	41 b9 01 00 00
	00		 mov	 r9d, 1
  00509	41 b8 3f 00 00
	00		 mov	 r8d, 63			; 0000003fH
  0050f	8b 54 24 44	 mov	 edx, DWORD PTR b2$[rsp]
  00513	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00517	e8 00 00 00 00	 call	 s390_validate_operand

; 982  :                                   ACCTYPE_WRITE_SKP, regs );
; 983  : 
; 984  :     /* Perform serialization and checkpoint-synchronization */
; 985  :     PERFORM_SERIALIZATION( regs );

  0051c	0f ae f0	 mfence
$LN28@s390_test_:

; 986  :     PERFORM_CHKPT_SYNC( regs );

  0051f	33 c0		 xor	 eax, eax
  00521	85 c0		 test	 eax, eax
  00523	75 fa		 jne	 SHORT $LN28@s390_test_

; 987  : 
; 988  :     /* Test and clear pending status, set condition code */
; 989  :     cc = test_subchan( regs, dev, &irb );

  00525	4c 8d 44 24 60	 lea	 r8, QWORD PTR irb$[rsp]
  0052a	48 8b 54 24 48	 mov	 rdx, QWORD PTR dev$[rsp]
  0052f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00537	e8 00 00 00 00	 call	 test_subchan
  0053c	89 44 24 54	 mov	 DWORD PTR cc$[rsp], eax

; 990  : 
; 991  :     /* Store the interruption response block */
; 992  :     ARCH_DEP( vstorec )( &irb, sizeof(IRB)-1, effective_addr2, b2, regs );

  00540	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00548	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0054d	44 8b 4c 24 44	 mov	 r9d, DWORD PTR b2$[rsp]
  00552	44 8b 44 24 40	 mov	 r8d, DWORD PTR effective_addr2$[rsp]
  00557	b2 3f		 mov	 dl, 63			; 0000003fH
  00559	48 8d 4c 24 60	 lea	 rcx, QWORD PTR irb$[rsp]
  0055e	e8 00 00 00 00	 call	 s390_vstorec

; 993  : 
; 994  :     regs->psw.cc = cc;

  00563	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0056b	0f b6 4c 24 54	 movzx	 ecx, BYTE PTR cc$[rsp]
  00570	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 995  : 
; 996  :     if (regs->psw.cc != 0)

  00573	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057b	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  0057f	85 c0		 test	 eax, eax
  00581	74 76		 je	 SHORT $LN49@s390_test_
$LN31@s390_test_:

; 997  :         PTIO( ERR, "*TSCH" );

  00583	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0058a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0058d	48 83 e0 10	 and	 rax, 16
  00591	48 85 c0	 test	 rax, rax
  00594	74 5d		 je	 SHORT $LN50@s390_test_
  00596	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0059e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  005a4	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  005a8	ba 08 00 00 00	 mov	 edx, 8
  005ad	48 6b d2 01	 imul	 rdx, rdx, 1
  005b1	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005b9	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  005c1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  005ca	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181329
  005d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005db	44 8b c9	 mov	 r9d, ecx
  005de	44 8b c2	 mov	 r8d, edx
  005e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181330
  005e8	b9 10 00 00 00	 mov	 ecx, 16
  005ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN50@s390_test_:
  005f3	33 c0		 xor	 eax, eax
  005f5	85 c0		 test	 eax, eax
  005f7	75 8a		 jne	 SHORT $LN31@s390_test_
$LN49@s390_test_:
$LN1@s390_test_:
$LN51@s390_test_:

; 998  : }

  005f9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00601	48 33 cc	 xor	 rcx, rsp
  00604	e8 00 00 00 00	 call	 __security_check_cookie
  00609	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00610	c3		 ret	 0
s390_test_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
icode$ = 68
b2$ = 72
temp$1 = 76
ioid$ = 80
ioparm$ = 84
tv284 = 88
pfx$ = 96
psa$ = 104
iointid$ = 112
tv239 = 120
dreg$ = 128
dev$ = 136
inst$ = 160
regs$ = 168
s390_test_pending_interruption PROC

; 813  : {

$LN49:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 814  : int     b2;                             /* Effective addr base       */
; 815  : VADR    effective_addr2;                /* Effective address         */
; 816  : PSA    *psa;                            /* -> Prefixed storage area  */
; 817  : U64     dreg;                           /* Double register work area */
; 818  : U32     ioid;                           /* I/O interruption address  */
; 819  : U32     ioparm;                         /* I/O interruption parameter*/
; 820  : U32     iointid;                        /* I/O interruption ident    */
; 821  : int     icode;                          /* Intercept code            */
; 822  : RADR    pfx;                            /* Prefix                    */
; 823  : DEVBLK *dev;                            /* dev presenting interrupt  */
; 824  : 
; 825  :     S( inst, regs, b2, effective_addr2 );

  00011	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 4c	 mov	 DWORD PTR temp$1[rsp], eax
  00029	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  0002d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00032	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00036	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  0003a	c1 e8 0c	 shr	 eax, 12
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  00044	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  00049	74 3a		 je	 SHORT $LN23@s390_test_
  0004b	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  00050	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00058	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0005f	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00063	03 c8		 add	 ecx, eax
  00065	8b c1		 mov	 eax, ecx
  00067	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0006b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00073	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00079	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0007d	23 c8		 and	 ecx, eax
  0007f	8b c1		 mov	 eax, ecx
  00081	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN23@s390_test_:
$LN4@s390_test_:
  00085	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00091	48 83 c0 04	 add	 rax, 4
  00095	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000a1	33 c0		 xor	 eax, eax
  000a3	83 f8 04	 cmp	 eax, 4
  000a6	74 0f		 je	 SHORT $LN24@s390_test_
  000a8	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b0	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN24@s390_test_:
  000b7	33 c0		 xor	 eax, eax
  000b9	85 c0		 test	 eax, eax
  000bb	75 c8		 jne	 SHORT $LN4@s390_test_

; 826  : 
; 827  :     TXF_INSTR_CHECK( regs );
; 828  :     PRIV_CHECK( regs );

  000bd	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c5	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000c9	83 e0 01	 and	 eax, 1
  000cc	85 c0		 test	 eax, eax
  000ce	74 1b		 je	 SHORT $LN25@s390_test_
  000d0	ba 02 00 00 00	 mov	 edx, 2
  000d5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN25@s390_test_:

; 829  : 
; 830  : #if defined( _FEATURE_IO_ASSIST )
; 831  :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  000eb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000f9	d1 e8		 shr	 eax, 1
  000fb	83 e0 01	 and	 eax, 1
  000fe	85 c0		 test	 eax, eax
  00100	74 74		 je	 SHORT $LN26@s390_test_
  00102	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00111	b9 01 00 00 00	 mov	 ecx, 1
  00116	48 6b c9 00	 imul	 rcx, rcx, 0
  0011a	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  0011f	83 e0 04	 and	 eax, 4
  00122	85 c0		 test	 eax, eax
  00124	75 50		 jne	 SHORT $LN26@s390_test_
  00126	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00134	c1 e8 02	 shr	 eax, 2
  00137	83 e0 01	 and	 eax, 1
  0013a	85 c0		 test	 eax, eax
  0013c	75 38		 jne	 SHORT $LN26@s390_test_
$LN7@s390_test_:

; 832  : #endif
; 833  :        SIE_INTERCEPT( regs );

  0013e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00146	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0014c	d1 e8		 shr	 eax, 1
  0014e	83 e0 01	 and	 eax, 1
  00151	85 c0		 test	 eax, eax
  00153	74 1b		 je	 SHORT $LN27@s390_test_
  00155	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00163	ba fc ff ff ff	 mov	 edx, -4
  00168	48 8b c8	 mov	 rcx, rax
  0016b	e8 00 00 00 00	 call	 longjmp
$LN27@s390_test_:
  00170	33 c0		 xor	 eax, eax
  00172	85 c0		 test	 eax, eax
  00174	75 c8		 jne	 SHORT $LN7@s390_test_
$LN26@s390_test_:
$LN10@s390_test_:

; 834  : 
; 835  :     PTIO( IO,"TPI" );

  00176	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0017d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00180	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00186	48 85 c0	 test	 rax, rax
  00189	74 5d		 je	 SHORT $LN28@s390_test_
  0018b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00193	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00199	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0019d	ba 08 00 00 00	 mov	 edx, 8
  001a2	48 6b d2 01	 imul	 rdx, rdx, 1
  001a6	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001ae	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001b6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001bf	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001c4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181194
  001cb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d0	44 8b c9	 mov	 r9d, ecx
  001d3	44 8b c2	 mov	 r8d, edx
  001d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181195
  001dd	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN28@s390_test_:
  001e8	33 c0		 xor	 eax, eax
  001ea	85 c0		 test	 eax, eax
  001ec	75 88		 jne	 SHORT $LN10@s390_test_

; 836  : 
; 837  :     FW_CHECK( effective_addr2, regs );

  001ee	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001f2	83 e0 03	 and	 eax, 3
  001f5	85 c0		 test	 eax, eax
  001f7	74 1b		 je	 SHORT $LN29@s390_test_
  001f9	ba 06 00 00 00	 mov	 edx, 6
  001fe	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00206	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN29@s390_test_:

; 838  : 
; 839  :     /* validate operand before taking any action */
; 840  :     if (effective_addr2 != 0)

  00214	83 7c 24 40 00	 cmp	 DWORD PTR effective_addr2$[rsp], 0
  00219	74 26		 je	 SHORT $LN30@s390_test_

; 841  :         ARCH_DEP( validate_operand )( effective_addr2, b2, 8-1,

  0021b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00223	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00228	41 b9 02 00 00
	00		 mov	 r9d, 2
  0022e	41 b8 07 00 00
	00		 mov	 r8d, 7
  00234	8b 54 24 48	 mov	 edx, DWORD PTR b2$[rsp]
  00238	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0023c	e8 00 00 00 00	 call	 s390_validate_operand
$LN30@s390_test_:

; 842  :                                       ACCTYPE_WRITE, regs );
; 843  : 
; 844  :     /* Perform serialization and checkpoint-synchronization */
; 845  :     PERFORM_SERIALIZATION( regs );

  00241	0f ae f0	 mfence
$LN13@s390_test_:

; 846  :     PERFORM_CHKPT_SYNC( regs );

  00244	33 c0		 xor	 eax, eax
  00246	85 c0		 test	 eax, eax
  00248	75 fa		 jne	 SHORT $LN13@s390_test_

; 847  : 
; 848  :     if (IS_IC_IOPENDING)

  0024a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00251	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00257	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0025c	85 c0		 test	 eax, eax
  0025e	0f 84 b4 02 00
	00		 je	 $LN31@s390_test_

; 849  :     {
; 850  :         OBTAIN_INTLOCK( regs );

  00264	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181200
  0026b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00273	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 851  :         {
; 852  :             /* Test and clear pending interrupt
; 853  :                and set the condition code
; 854  :             */
; 855  :             icode = ARCH_DEP( present_io_interrupt )( regs, &ioid, &ioparm,

  00278	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR dev$[rsp]
  00280	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00285	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0028e	4c 8d 4c 24 70	 lea	 r9, QWORD PTR iointid$[rsp]
  00293	4c 8d 44 24 54	 lea	 r8, QWORD PTR ioparm$[rsp]
  00298	48 8d 54 24 50	 lea	 rdx, QWORD PTR ioid$[rsp]
  0029d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a5	e8 00 00 00 00	 call	 s390_present_io_interrupt
  002aa	89 44 24 44	 mov	 DWORD PTR icode$[rsp], eax

; 856  :                                                       &iointid, NULL, &dev );
; 857  :         }
; 858  :         RELEASE_INTLOCK( regs );

  002ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181201
  002b5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bd	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 859  : 
; 860  :         /* Store the SSID word and I/O parameter
; 861  :            if an interrupt was pending
; 862  :         */
; 863  :         if (icode)

  002c2	83 7c 24 44 00	 cmp	 DWORD PTR icode$[rsp], 0
  002c7	0f 84 49 02 00
	00		 je	 $LN33@s390_test_

; 864  :         {
; 865  :             if (0
; 866  :                 || effective_addr2 == 0
; 867  : #if defined( _FEATURE_IO_ASSIST )
; 868  :                 || icode != SIE_NO_INTERCEPT

  002cd	33 c0		 xor	 eax, eax
  002cf	85 c0		 test	 eax, eax
  002d1	75 12		 jne	 SHORT $LN36@s390_test_
  002d3	83 7c 24 40 00	 cmp	 DWORD PTR effective_addr2$[rsp], 0
  002d8	74 0b		 je	 SHORT $LN36@s390_test_
  002da	83 7c 24 44 ff	 cmp	 DWORD PTR icode$[rsp], -1
  002df	0f 84 fc 01 00
	00		 je	 $LN34@s390_test_
$LN36@s390_test_:

; 869  : #endif
; 870  :             )
; 871  :             {
; 872  : #if defined( _FEATURE_IO_ASSIST )
; 873  :                 if (icode != SIE_NO_INTERCEPT)

  002e5	83 7c 24 44 ff	 cmp	 DWORD PTR icode$[rsp], -1
  002ea	74 4a		 je	 SHORT $LN37@s390_test_

; 874  :                 {
; 875  :                     /* Point to SIE copy of PSA in state descriptor */
; 876  :                     psa = (void*)(HOSTREGS->mainstor + SIE_STATE(regs) + SIE_II_PSA_OFFSET);

  002ec	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002f4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  002fb	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00302	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030a	48 8b 89 80 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2176]
  00311	48 8d 44 08 30	 lea	 rax, QWORD PTR [rax+rcx+48]
  00316	48 89 44 24 68	 mov	 QWORD PTR psa$[rsp], rax

; 877  :                     ARCH_DEP( or_storage_key )( SIE_STATE( regs ), (STORKEY_REF | STORKEY_CHANGE) );

  0031b	b2 06		 mov	 dl, 6
  0031d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00325	48 8b 88 80 08
	00 00		 mov	 rcx, QWORD PTR [rax+2176]
  0032c	e8 00 00 00 00	 call	 s390_or_storage_key

; 878  :                 }

  00331	e9 33 01 00 00	 jmp	 $LN38@s390_test_
$LN37@s390_test_:

; 879  :                 else
; 880  : #endif
; 881  :                 {
; 882  :                     /* Point to PSA in main storage */
; 883  :                     pfx = regs->PX;

  00336	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0033e	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00341	48 89 44 24 60	 mov	 QWORD PTR pfx$[rsp], rax
$LN16@s390_test_:

; 884  :                     SIE_TRANSLATE( &pfx, ACCTYPE_SIE, regs );

  00346	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00354	d1 e8		 shr	 eax, 1
  00356	83 e0 01	 and	 eax, 1
  00359	85 c0		 test	 eax, eax
  0035b	0f 84 d9 00 00
	00		 je	 $LN39@s390_test_
  00361	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00369	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0036f	c1 e8 02	 shr	 eax, 2
  00372	83 e0 01	 and	 eax, 1
  00375	85 c0		 test	 eax, eax
  00377	0f 85 bd 00 00
	00		 jne	 $LN39@s390_test_
  0037d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00385	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0038c	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  00390	75 47		 jne	 SHORT $LN45@s390_test_
  00392	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039a	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  003a1	48 03 44 24 60	 add	 rax, QWORD PTR pfx$[rsp]
  003a6	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  003af	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  003b4	45 33 c9	 xor	 r9d, r9d
  003b7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003bf	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  003c6	ba fd ff ff ff	 mov	 edx, -3
  003cb	8b c8		 mov	 ecx, eax
  003cd	e8 00 00 00 00	 call	 s390_logical_to_main_l
  003d2	48 89 44 24 78	 mov	 QWORD PTR tv239[rsp], rax
  003d7	eb 46		 jmp	 SHORT $LN46@s390_test_
$LN45@s390_test_:
  003d9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e1	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  003e8	48 03 44 24 60	 add	 rax, QWORD PTR pfx$[rsp]
  003ed	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  003f6	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  003fb	45 33 c9	 xor	 r9d, r9d
  003fe	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00406	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  0040d	ba fd ff ff ff	 mov	 edx, -3
  00412	48 8b c8	 mov	 rcx, rax
  00415	e8 00 00 00 00	 call	 z900_logical_to_main_l
  0041a	48 89 44 24 78	 mov	 QWORD PTR tv239[rsp], rax
$LN46@s390_test_:
  0041f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00427	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0042e	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  00435	48 89 44 24 60	 mov	 QWORD PTR pfx$[rsp], rax
$LN39@s390_test_:
  0043a	33 c0		 xor	 eax, eax
  0043c	85 c0		 test	 eax, eax
  0043e	0f 85 02 ff ff
	ff		 jne	 $LN16@s390_test_

; 885  :                     psa = (void*)(regs->mainstor + pfx);

  00444	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044c	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00453	48 03 44 24 60	 add	 rax, QWORD PTR pfx$[rsp]
  00458	48 89 44 24 68	 mov	 QWORD PTR psa$[rsp], rax

; 886  :                     ARCH_DEP( or_storage_key )( pfx, (STORKEY_REF | STORKEY_CHANGE) );

  0045d	b2 06		 mov	 dl, 6
  0045f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pfx$[rsp]
  00464	e8 00 00 00 00	 call	 s390_or_storage_key
$LN38@s390_test_:

; 887  :                 }
; 888  : 
; 889  :                 /* If operand address is zero, store in PSA */
; 890  :                 STORE_FW( psa->ioid,ioid );

  00469	8b 4c 24 50	 mov	 ecx, DWORD PTR ioid$[rsp]
  0046d	e8 00 00 00 00	 call	 _byteswap_ulong
  00472	48 8b 4c 24 68	 mov	 rcx, QWORD PTR psa$[rsp]
  00477	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  0047e	8b d0		 mov	 edx, eax
  00480	e8 00 00 00 00	 call	 store_fw_noswap

; 891  :                 STORE_FW( psa->ioparm,ioparm );

  00485	8b 4c 24 54	 mov	 ecx, DWORD PTR ioparm$[rsp]
  00489	e8 00 00 00 00	 call	 _byteswap_ulong
  0048e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR psa$[rsp]
  00493	48 81 c1 bc 00
	00 00		 add	 rcx, 188		; 000000bcH
  0049a	8b d0		 mov	 edx, eax
  0049c	e8 00 00 00 00	 call	 store_fw_noswap

; 892  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) || defined( _FEATURE_IO_ASSIST )
; 893  :                 STORE_FW( psa->iointid,iointid );

  004a1	8b 4c 24 70	 mov	 ecx, DWORD PTR iointid$[rsp]
  004a5	e8 00 00 00 00	 call	 _byteswap_ulong
  004aa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR psa$[rsp]
  004af	48 81 c1 c0 00
	00 00		 add	 rcx, 192		; 000000c0H
  004b6	8b d0		 mov	 edx, eax
  004b8	e8 00 00 00 00	 call	 store_fw_noswap

; 894  : #endif
; 895  :                 /* Do SIE intercept if needed */
; 896  : #if defined( _FEATURE_IO_ASSIST )
; 897  :                 if (icode != SIE_NO_INTERCEPT)

  004bd	83 7c 24 44 ff	 cmp	 DWORD PTR icode$[rsp], -1
  004c2	74 1b		 je	 SHORT $LN40@s390_test_

; 898  :                     longjmp( regs->progjmp, SIE_INTERCEPT_IOINST );

  004c4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004cc	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  004d2	ba ef ff ff ff	 mov	 edx, -17
  004d7	48 8b c8	 mov	 rcx, rax
  004da	e8 00 00 00 00	 call	 longjmp
$LN40@s390_test_:

; 899  : #endif
; 900  :             }

  004df	eb 35		 jmp	 SHORT $LN35@s390_test_
$LN34@s390_test_:

; 901  :             else
; 902  :             {
; 903  :                 /* Otherwise store at operand location */
; 904  :                 dreg = ((U64)ioid << 32) | ioparm;

  004e1	8b 44 24 50	 mov	 eax, DWORD PTR ioid$[rsp]
  004e5	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  004e9	8b 4c 24 54	 mov	 ecx, DWORD PTR ioparm$[rsp]
  004ed	48 0b c1	 or	 rax, rcx
  004f0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dreg$[rsp], rax

; 905  :                 ARCH_DEP( vstore8 )( dreg, effective_addr2, b2, regs );

  004f8	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00500	44 8b 44 24 48	 mov	 r8d, DWORD PTR b2$[rsp]
  00505	8b 54 24 40	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  00509	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dreg$[rsp]
  00511	e8 00 00 00 00	 call	 s390_vstore8
$LN35@s390_test_:
$LN33@s390_test_:

; 906  :             }
; 907  :         }
; 908  :     }

  00516	eb 40		 jmp	 SHORT $LN32@s390_test_
$LN31@s390_test_:
$LN19@s390_test_:

; 909  :     else
; 910  :     {
; 911  : #if defined( _FEATURE_IO_ASSIST )
; 912  :         /* If no I/O assisted devices have pending interrupts
; 913  :            then we must intercept */
; 914  :         SIE_INTERCEPT( regs );

  00518	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00520	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00526	d1 e8		 shr	 eax, 1
  00528	83 e0 01	 and	 eax, 1
  0052b	85 c0		 test	 eax, eax
  0052d	74 1b		 je	 SHORT $LN41@s390_test_
  0052f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00537	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0053d	ba fc ff ff ff	 mov	 edx, -4
  00542	48 8b c8	 mov	 rcx, rax
  00545	e8 00 00 00 00	 call	 longjmp
$LN41@s390_test_:
  0054a	33 c0		 xor	 eax, eax
  0054c	85 c0		 test	 eax, eax
  0054e	75 c8		 jne	 SHORT $LN19@s390_test_

; 915  : #endif
; 916  :         icode = 0;

  00550	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR icode$[rsp], 0
$LN32@s390_test_:

; 917  :     }
; 918  : 
; 919  :     regs->psw.cc = (icode == 0) ? 0 : 1;

  00558	83 7c 24 44 00	 cmp	 DWORD PTR icode$[rsp], 0
  0055d	75 0a		 jne	 SHORT $LN47@s390_test_
  0055f	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv284[rsp], 0
  00567	eb 08		 jmp	 SHORT $LN48@s390_test_
$LN47@s390_test_:
  00569	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv284[rsp], 1
$LN48@s390_test_:
  00571	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00579	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR tv284[rsp]
  0057e	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 920  : 
; 921  :     if (regs->psw.cc != 0)

  00581	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00589	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  0058d	85 c0		 test	 eax, eax
  0058f	74 76		 je	 SHORT $LN42@s390_test_
$LN22@s390_test_:

; 922  :         PTIO(ERR,"*TPI");

  00591	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00598	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0059b	48 83 e0 10	 and	 rax, 16
  0059f	48 85 c0	 test	 rax, rax
  005a2	74 5d		 je	 SHORT $LN43@s390_test_
  005a4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ac	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  005b2	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  005b6	ba 08 00 00 00	 mov	 edx, 8
  005bb	48 6b d2 01	 imul	 rdx, rdx, 1
  005bf	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005c7	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  005cf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  005d8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181213
  005e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005e9	44 8b c9	 mov	 r9d, ecx
  005ec	44 8b c2	 mov	 r8d, edx
  005ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181214
  005f6	b9 10 00 00 00	 mov	 ecx, 16
  005fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN43@s390_test_:
  00601	33 c0		 xor	 eax, eax
  00603	85 c0		 test	 eax, eax
  00605	75 8a		 jne	 SHORT $LN22@s390_test_
$LN42@s390_test_:
$LN44@s390_test_:

; 923  : }

  00607	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0060e	c3		 ret	 0
s390_test_pending_interruption ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
dev$ = 72
b2$ = 80
temp$1 = 84
schib$ = 88
__$ArrayPad$ = 144
inst$ = 192
regs$ = 200
s390_store_subchannel PROC

; 748  : {

$LN39:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 749  : int     b2;                             /* Effective addr base       */
; 750  : VADR    effective_addr2;                /* Effective address         */
; 751  : DEVBLK* dev;                            /* -> device block           */
; 752  : SCHIB   schib;                          /* Subchannel information blk*/
; 753  : 
; 754  :     S( inst, regs, b2, effective_addr2 );

  00025	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 _byteswap_ulong
  00039	89 44 24 54	 mov	 DWORD PTR temp$1[rsp], eax
  0003d	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  00041	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00046	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004a	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  0004e	c1 e8 0c	 shr	 eax, 12
  00051	83 e0 0f	 and	 eax, 15
  00054	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00058	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005d	74 3a		 je	 SHORT $LN23@s390_store
  0005f	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  00064	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00073	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00077	03 c8		 add	 ecx, eax
  00079	8b c1		 mov	 eax, ecx
  0007b	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0007f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00087	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0008d	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00091	23 c8		 and	 ecx, eax
  00093	8b c1		 mov	 eax, ecx
  00095	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN23@s390_store:
$LN4@s390_store:
  00099	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a1	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000a5	48 83 c0 04	 add	 rax, 4
  000a9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b1	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000b5	33 c0		 xor	 eax, eax
  000b7	83 f8 04	 cmp	 eax, 4
  000ba	74 0f		 je	 SHORT $LN24@s390_store
  000bc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN24@s390_store:
  000cb	33 c0		 xor	 eax, eax
  000cd	85 c0		 test	 eax, eax
  000cf	75 c8		 jne	 SHORT $LN4@s390_store

; 755  :     PER_ZEROADDR_XCHECK( regs, b2 );
; 756  : 
; 757  :     TXF_INSTR_CHECK( regs );
; 758  :     PRIV_CHECK( regs );

  000d1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000dd	83 e0 01	 and	 eax, 1
  000e0	85 c0		 test	 eax, eax
  000e2	74 1b		 je	 SHORT $LN25@s390_store
  000e4	ba 02 00 00 00	 mov	 edx, 2
  000e9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN25@s390_store:
$LN7@s390_store:

; 759  :     PTIO( IO, "STSCH" );

  000ff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00106	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00109	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0010f	48 85 c0	 test	 rax, rax
  00112	74 5d		 je	 SHORT $LN26@s390_store
  00114	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00122	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00126	ba 08 00 00 00	 mov	 edx, 8
  0012b	48 6b d2 01	 imul	 rdx, rdx, 1
  0012f	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00137	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0013f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00148	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0014d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181110
  00154	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00159	44 8b c9	 mov	 r9d, ecx
  0015c	44 8b c2	 mov	 r8d, edx
  0015f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181111
  00166	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN26@s390_store:
  00171	33 c0		 xor	 eax, eax
  00173	85 c0		 test	 eax, eax
  00175	75 88		 jne	 SHORT $LN7@s390_store
$LN10@s390_store:

; 760  :     PTIO( IO, "STSCH (sie)" );

  00177	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0017e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00181	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00187	48 85 c0	 test	 rax, rax
  0018a	74 5d		 je	 SHORT $LN27@s390_store
  0018c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00194	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0019a	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0019e	ba 08 00 00 00	 mov	 edx, 8
  001a3	48 6b d2 01	 imul	 rdx, rdx, 1
  001a7	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001af	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001b7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001c0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001c5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181113
  001cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d1	44 8b c9	 mov	 r9d, ecx
  001d4	44 8b c2	 mov	 r8d, edx
  001d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181114
  001de	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN27@s390_store:
  001e9	33 c0		 xor	 eax, eax
  001eb	85 c0		 test	 eax, eax
  001ed	75 88		 jne	 SHORT $LN10@s390_store
$LN13@s390_store:

; 761  :     SIE_INTERCEPT( regs );

  001ef	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001fd	d1 e8		 shr	 eax, 1
  001ff	83 e0 01	 and	 eax, 1
  00202	85 c0		 test	 eax, eax
  00204	74 1b		 je	 SHORT $LN28@s390_store
  00206	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020e	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00214	ba fc ff ff ff	 mov	 edx, -4
  00219	48 8b c8	 mov	 rcx, rax
  0021c	e8 00 00 00 00	 call	 longjmp
$LN28@s390_store:
  00221	33 c0		 xor	 eax, eax
  00223	85 c0		 test	 eax, eax
  00225	75 c8		 jne	 SHORT $LN13@s390_store

; 762  : 
; 763  :     /* Program check if the ssid including lcss is invalid */
; 764  :     SSID_CHECK( regs );

  00227	b8 08 00 00 00	 mov	 eax, 8
  0022c	48 6b c0 01	 imul	 rax, rax, 1
  00230	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00238	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  00240	83 e0 01	 and	 eax, 1
  00243	85 c0		 test	 eax, eax
  00245	74 1e		 je	 SHORT $LN30@s390_store
  00247	b8 08 00 00 00	 mov	 eax, 8
  0024c	48 6b c0 01	 imul	 rax, rax, 1
  00250	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00258	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  00260	83 f8 03	 cmp	 eax, 3
  00263	7e 1b		 jle	 SHORT $LN29@s390_store
$LN30@s390_store:
  00265	ba 15 00 00 00	 mov	 edx, 21
  0026a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00272	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0027a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN29@s390_store:

; 765  : 
; 766  :     /* Locate the device block for this subchannel */
; 767  :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  00280	b8 08 00 00 00	 mov	 eax, 8
  00285	48 6b c0 01	 imul	 rax, rax, 1
  00289	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00291	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  00298	e8 00 00 00 00	 call	 find_device_by_subchan
  0029d	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax

; 768  : 
; 769  :     if (dev)

  002a2	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002a8	74 5a		 je	 SHORT $LN31@s390_store
$LN16@s390_store:

; 770  :         PTT( PTT_CL_IO, "STSCH (dev)", dev->devnum, 0, 0 );

  002aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002b1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002b4	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  002ba	48 85 c0	 test	 rax, rax
  002bd	74 3f		 je	 SHORT $LN32@s390_store
  002bf	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  002c4	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002c8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002d1	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  002da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181120
  002e1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002e6	45 33 c9	 xor	 r9d, r9d
  002e9	44 8b c0	 mov	 r8d, eax
  002ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181121
  002f3	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN32@s390_store:
  002fe	33 c0		 xor	 eax, eax
  00300	85 c0		 test	 eax, eax
  00302	75 a6		 jne	 SHORT $LN16@s390_store
$LN31@s390_store:

; 771  : 
; 772  :     /* Set condition code 3 if subchannel does not exist */
; 773  :     if (!dev)

  00304	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0030a	0f 85 87 00 00
	00		 jne	 $LN33@s390_store
$LN19@s390_store:

; 774  :     {
; 775  :         PTIO( ERR, "*STSCH" );

  00310	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00317	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0031a	48 83 e0 10	 and	 rax, 16
  0031e	48 85 c0	 test	 rax, rax
  00321	74 5d		 je	 SHORT $LN34@s390_store
  00323	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0032b	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00331	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00335	ba 08 00 00 00	 mov	 edx, 8
  0033a	48 6b d2 01	 imul	 rdx, rdx, 1
  0033e	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00346	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0034e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00357	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0035c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181124
  00363	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00368	44 8b c9	 mov	 r9d, ecx
  0036b	44 8b c2	 mov	 r8d, edx
  0036e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181125
  00375	b9 10 00 00 00	 mov	 ecx, 16
  0037a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN34@s390_store:
  00380	33 c0		 xor	 eax, eax
  00382	85 c0		 test	 eax, eax
  00384	75 8a		 jne	 SHORT $LN19@s390_store

; 776  :         regs->psw.cc = 3;

  00386	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038e	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 777  :         return;

  00392	e9 0a 01 00 00	 jmp	 $LN1@s390_store
$LN33@s390_store:

; 778  :     }
; 779  : 
; 780  :     FW_CHECK( effective_addr2, regs );

  00397	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0039b	83 e0 03	 and	 eax, 3
  0039e	85 c0		 test	 eax, eax
  003a0	74 1b		 je	 SHORT $LN35@s390_store
  003a2	ba 06 00 00 00	 mov	 edx, 6
  003a7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003af	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN35@s390_store:

; 781  : 
; 782  :     /* Perform serialization and checkpoint-synchronization */
; 783  :     PERFORM_SERIALIZATION( regs );

  003bd	0f ae f0	 mfence
$LN22@s390_store:

; 784  :     PERFORM_CHKPT_SYNC( regs );

  003c0	33 c0		 xor	 eax, eax
  003c2	85 c0		 test	 eax, eax
  003c4	75 fa		 jne	 SHORT $LN22@s390_store

; 785  : 
; 786  :     /* Build the subchannel information block */
; 787  :     schib.pmcw = dev->pmcw;

  003c6	48 8d 44 24 58	 lea	 rax, QWORD PTR schib$[rsp]
  003cb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  003d0	48 8b f8	 mov	 rdi, rax
  003d3	48 8d b1 ec 02
	00 00		 lea	 rsi, QWORD PTR [rcx+748]
  003da	b9 1c 00 00 00	 mov	 ecx, 28
  003df	f3 a4		 rep movsb

; 788  : 
; 789  :     obtain_lock( &dev->lock );

  003e1	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  003e6	48 83 c0 38	 add	 rax, 56			; 00000038H
  003ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181127
  003f1	48 8b c8	 mov	 rcx, rax
  003f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 790  :     {
; 791  :         if (dev->pciscsw.flag3 & SCSW3_SC_PEND)

  003fa	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  003ff	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  00406	83 e0 01	 and	 eax, 1
  00409	85 c0		 test	 eax, eax
  0040b	74 1d		 je	 SHORT $LN36@s390_store

; 792  :             schib.scsw = dev->pciscsw;

  0040d	48 8d 44 24 74	 lea	 rax, QWORD PTR schib$[rsp+28]
  00412	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00417	48 8b f8	 mov	 rdi, rax
  0041a	48 8d b1 14 03
	00 00		 lea	 rsi, QWORD PTR [rcx+788]
  00421	b9 0c 00 00 00	 mov	 ecx, 12
  00426	f3 a4		 rep movsb
  00428	eb 1b		 jmp	 SHORT $LN37@s390_store
$LN36@s390_store:

; 793  :         else
; 794  :             schib.scsw = dev->scsw;

  0042a	48 8d 44 24 74	 lea	 rax, QWORD PTR schib$[rsp+28]
  0042f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00434	48 8b f8	 mov	 rdi, rax
  00437	48 8d b1 08 03
	00 00		 lea	 rsi, QWORD PTR [rcx+776]
  0043e	b9 0c 00 00 00	 mov	 ecx, 12
  00443	f3 a4		 rep movsb
$LN37@s390_store:

; 795  :     }
; 796  :     release_lock( &dev->lock );

  00445	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0044a	48 83 c0 38	 add	 rax, 56			; 00000038H
  0044e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181130
  00455	48 8b c8	 mov	 rcx, rax
  00458	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 797  : 
; 798  :     memset( schib.moddep, 0, sizeof( schib.moddep ));

  0045e	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR schib$[rsp+40]
  00466	48 8b f8	 mov	 rdi, rax
  00469	33 c0		 xor	 eax, eax
  0046b	b9 0c 00 00 00	 mov	 ecx, 12
  00470	f3 aa		 rep stosb

; 799  : 
; 800  :     /* Store the subchannel information block */
; 801  :     ARCH_DEP( vstorec )( &schib, sizeof(SCHIB)-1, effective_addr2,

  00472	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0047f	44 8b 4c 24 50	 mov	 r9d, DWORD PTR b2$[rsp]
  00484	44 8b 44 24 40	 mov	 r8d, DWORD PTR effective_addr2$[rsp]
  00489	b2 33		 mov	 dl, 51			; 00000033H
  0048b	48 8d 4c 24 58	 lea	 rcx, QWORD PTR schib$[rsp]
  00490	e8 00 00 00 00	 call	 s390_vstorec

; 802  :                 b2, regs );
; 803  : 
; 804  :     /* Set condition code 0 */
; 805  :     regs->psw.cc = 0;

  00495	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0049d	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s390_store:
$LN38@s390_store:

; 806  : }

  004a1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004a9	48 33 cc	 xor	 rcx, rsp
  004ac	e8 00 00 00 00	 call	 __security_check_cookie
  004b1	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  004b8	5f		 pop	 rdi
  004b9	5e		 pop	 rsi
  004ba	c3		 ret	 0
s390_store_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
b2$ = 68
crw$ = 72
temp$1 = 76
tv183 = 80
inst$ = 112
regs$ = 120
s390_store_channel_report_word PROC

; 710  : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 711  : int     b2;                             /* Effective addr base       */
; 712  : VADR    effective_addr2;                /* Effective address         */
; 713  : U32     crw;                            /* Channel Report Word       */
; 714  : 
; 715  :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 4c	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 34		 je	 SHORT $LN17@s390_store
  00045	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0006d	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00071	23 c8		 and	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN17@s390_store:
$LN4@s390_store:
  00079	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	48 83 c0 04	 add	 rax, 4
  00086	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 04	 cmp	 eax, 4
  00094	74 0c		 je	 SHORT $LN18@s390_store
  00096	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN18@s390_store:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 d1		 jne	 SHORT $LN4@s390_store
$LN7@s390_store:

; 716  :     PER_ZEROADDR_XCHECK( regs, b2 );
; 717  : 
; 718  :     TXF_INSTR_CHECK( regs );
; 719  :     PTIO(IO,"STCRW");

  000a8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b2	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  000b8	48 85 c0	 test	 rax, rax
  000bb	74 57		 je	 SHORT $LN19@s390_store
  000bd	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c2	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  000c8	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000cc	ba 08 00 00 00	 mov	 edx, 8
  000d1	48 6b d2 01	 imul	 rdx, rdx, 1
  000d5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  000da	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  000e2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000eb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181034
  000f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fc	44 8b c9	 mov	 r9d, ecx
  000ff	44 8b c2	 mov	 r8d, edx
  00102	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181035
  00109	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN19@s390_store:
  00114	33 c0		 xor	 eax, eax
  00116	85 c0		 test	 eax, eax
  00118	75 8e		 jne	 SHORT $LN7@s390_store

; 720  :     PRIV_CHECK(regs);

  0011a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011f	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00123	83 e0 01	 and	 eax, 1
  00126	85 c0		 test	 eax, eax
  00128	74 15		 je	 SHORT $LN20@s390_store
  0012a	ba 02 00 00 00	 mov	 edx, 2
  0012f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00139	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN20@s390_store:
$LN10@s390_store:

; 721  :     SIE_INTERCEPT(regs);

  0013f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00144	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0014a	d1 e8		 shr	 eax, 1
  0014c	83 e0 01	 and	 eax, 1
  0014f	85 c0		 test	 eax, eax
  00151	74 18		 je	 SHORT $LN21@s390_store
  00153	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00158	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0015e	ba fc ff ff ff	 mov	 edx, -4
  00163	48 8b c8	 mov	 rcx, rax
  00166	e8 00 00 00 00	 call	 longjmp
$LN21@s390_store:
  0016b	33 c0		 xor	 eax, eax
  0016d	85 c0		 test	 eax, eax
  0016f	75 ce		 jne	 SHORT $LN10@s390_store

; 722  :     FW_CHECK(effective_addr2, regs);

  00171	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00175	83 e0 03	 and	 eax, 3
  00178	85 c0		 test	 eax, eax
  0017a	74 15		 je	 SHORT $LN22@s390_store
  0017c	ba 06 00 00 00	 mov	 edx, 6
  00181	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0018b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN22@s390_store:

; 723  : 
; 724  :     /* Validate write access to operand before taking any
; 725  :        pending channel report word off the queue */
; 726  :     ARCH_DEP(validate_operand) (effective_addr2, b2, 0, ACCTYPE_WRITE, regs);

  00191	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00196	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019b	41 b9 02 00 00
	00		 mov	 r9d, 2
  001a1	45 33 c0	 xor	 r8d, r8d
  001a4	8b 54 24 44	 mov	 edx, DWORD PTR b2$[rsp]
  001a8	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001ac	e8 00 00 00 00	 call	 s390_validate_operand

; 727  : 
; 728  :     /* Obtain any pending channel report */
; 729  :     crw = get_next_channel_report_word(regs);

  001b1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001b6	e8 00 00 00 00	 call	 get_next_channel_report_word
  001bb	89 44 24 48	 mov	 DWORD PTR crw$[rsp], eax
$LN13@s390_store:

; 730  : 
; 731  :     PTIO_CH( IO, "STCRW crw", crw );

  001bf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001c6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001c9	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001cf	48 85 c0	 test	 rax, rax
  001d2	74 45		 je	 SHORT $LN23@s390_store
  001d4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001d9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001df	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001e3	8b 54 24 48	 mov	 edx, DWORD PTR crw$[rsp]
  001e7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001f0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181040
  001fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00201	44 8b c9	 mov	 r9d, ecx
  00204	44 8b c2	 mov	 r8d, edx
  00207	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181041
  0020e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN23@s390_store:
  00219	33 c0		 xor	 eax, eax
  0021b	85 c0		 test	 eax, eax
  0021d	75 a0		 jne	 SHORT $LN13@s390_store

; 732  : 
; 733  :     /* Store channel report word at operand address */
; 734  :     ARCH_DEP(vstore4) ( crw, effective_addr2, b2, regs );

  0021f	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00224	44 8b 44 24 44	 mov	 r8d, DWORD PTR b2$[rsp]
  00229	8b 54 24 40	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  0022d	8b 4c 24 48	 mov	 ecx, DWORD PTR crw$[rsp]
  00231	e8 00 00 00 00	 call	 s390_vstore4

; 735  : 
; 736  :     /* Indicate if channel report or zeros were stored */
; 737  :     regs->psw.cc = (crw == 0) ? 1 : 0;

  00236	83 7c 24 48 00	 cmp	 DWORD PTR crw$[rsp], 0
  0023b	75 0a		 jne	 SHORT $LN27@s390_store
  0023d	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv183[rsp], 1
  00245	eb 08		 jmp	 SHORT $LN28@s390_store
$LN27@s390_store:
  00247	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv183[rsp], 0
$LN28@s390_store:
  0024f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00254	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR tv183[rsp]
  00259	88 48 7c	 mov	 BYTE PTR [rax+124], cl

; 738  : 
; 739  :     if (regs->psw.cc != 0)

  0025c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00261	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00265	85 c0		 test	 eax, eax
  00267	74 70		 je	 SHORT $LN24@s390_store
$LN16@s390_store:

; 740  :         PTIO(ERR,"*STCRW");

  00269	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00270	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00273	48 83 e0 10	 and	 rax, 16
  00277	48 85 c0	 test	 rax, rax
  0027a	74 57		 je	 SHORT $LN25@s390_store
  0027c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00281	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00287	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0028b	ba 08 00 00 00	 mov	 edx, 8
  00290	48 6b d2 01	 imul	 rdx, rdx, 1
  00294	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00299	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  002a1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002aa	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181044
  002b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002bb	44 8b c9	 mov	 r9d, ecx
  002be	44 8b c2	 mov	 r8d, edx
  002c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181045
  002c8	b9 10 00 00 00	 mov	 ecx, 16
  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN25@s390_store:
  002d3	33 c0		 xor	 eax, eax
  002d5	85 c0		 test	 eax, eax
  002d7	75 90		 jne	 SHORT $LN16@s390_store
$LN24@s390_store:
$LN26@s390_store:

; 741  : }

  002d9	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002dd	c3		 ret	 0
s390_store_channel_report_word ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
chpid$ = 64
effective_addr2$ = 68
dev$ = 72
b2$ = 80
temp$1 = 84
tv279 = 88
tv201 = 92
tv189 = 96
work$ = 104
__$ArrayPad$ = 136
inst$ = 160
regs$ = 168
s390_store_channel_path_status PROC

; 635  : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 636  : int     b2;                             /* Effective addr base       */
; 637  : VADR    effective_addr2;                /* Effective address         */
; 638  : DEVBLK *dev;                            /* -> device block           */
; 639  : BYTE    chpid;                          /* CHPID associated w/lpum   */
; 640  : BYTE    work[32];                       /* Work area                 */
; 641  : static const BYTE msbn[256] = {         /* Most signif. bit# (0 - 7) */
; 642  : /*  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  */
; 643  :     8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, /* 0x00 */
; 644  :     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, /* 0x10 */
; 645  :     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /* 0x20 */
; 646  :     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, /* 0x30 */
; 647  :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x40 */
; 648  :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x50 */
; 649  :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x60 */
; 650  :     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* 0x70 */
; 651  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x80 */
; 652  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0x90 */
; 653  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xA0 */
; 654  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xB0 */
; 655  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xC0 */
; 656  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xD0 */
; 657  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xE0 */
; 658  :     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 0xF0 */
; 659  : };
; 660  : 
; 661  :     S(inst, regs, b2, effective_addr2);

  00024	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00031	8b c8		 mov	 ecx, eax
  00033	e8 00 00 00 00	 call	 _byteswap_ulong
  00038	89 44 24 54	 mov	 DWORD PTR temp$1[rsp], eax
  0003c	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00045	89 44 24 44	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00049	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00057	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005c	74 3a		 je	 SHORT $LN14@s390_store
  0005e	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  00063	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00072	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00076	03 c8		 add	 ecx, eax
  00078	8b c1		 mov	 eax, ecx
  0007a	89 44 24 44	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0007e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00086	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0008c	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00090	23 c8		 and	 ecx, eax
  00092	8b c1		 mov	 eax, ecx
  00094	89 44 24 44	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN14@s390_store:
$LN4@s390_store:
  00098	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000a4	48 83 c0 04	 add	 rax, 4
  000a8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b0	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000b4	33 c0		 xor	 eax, eax
  000b6	83 f8 04	 cmp	 eax, 4
  000b9	74 0f		 je	 SHORT $LN15@s390_store
  000bb	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN15@s390_store:
  000ca	33 c0		 xor	 eax, eax
  000cc	85 c0		 test	 eax, eax
  000ce	75 c8		 jne	 SHORT $LN4@s390_store

; 662  :     PER_ZEROADDR_XCHECK( regs, b2 );
; 663  : 
; 664  :     TXF_INSTR_CHECK( regs );
; 665  :     PRIV_CHECK(regs);

  000d0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000dc	83 e0 01	 and	 eax, 1
  000df	85 c0		 test	 eax, eax
  000e1	74 1b		 je	 SHORT $LN16@s390_store
  000e3	ba 02 00 00 00	 mov	 edx, 2
  000e8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@s390_store:
$LN7@s390_store:

; 666  :     SIE_INTERCEPT(regs);

  000fe	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00106	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010c	d1 e8		 shr	 eax, 1
  0010e	83 e0 01	 and	 eax, 1
  00111	85 c0		 test	 eax, eax
  00113	74 1b		 je	 SHORT $LN17@s390_store
  00115	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00123	ba fc ff ff ff	 mov	 edx, -4
  00128	48 8b c8	 mov	 rcx, rax
  0012b	e8 00 00 00 00	 call	 longjmp
$LN17@s390_store:
  00130	33 c0		 xor	 eax, eax
  00132	85 c0		 test	 eax, eax
  00134	75 c8		 jne	 SHORT $LN7@s390_store
$LN10@s390_store:

; 667  : 
; 668  :     PTIO_CH( IO, "STCPS", 0 );

  00136	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0013d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00140	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00146	48 85 c0	 test	 rax, rax
  00149	74 44		 je	 SHORT $LN18@s390_store
  0014b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00153	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00159	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0015d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00166	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0016b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180979
  00172	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00177	44 8b c9	 mov	 r9d, ecx
  0017a	45 33 c0	 xor	 r8d, r8d
  0017d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180980
  00184	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@s390_store:
  0018f	33 c0		 xor	 eax, eax
  00191	85 c0		 test	 eax, eax
  00193	75 a1		 jne	 SHORT $LN10@s390_store

; 669  : 
; 670  :     /* Program check if operand not on 32 byte boundary */
; 671  :     if ( effective_addr2 & 0x0000001F )

  00195	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00199	83 e0 1f	 and	 eax, 31
  0019c	85 c0		 test	 eax, eax
  0019e	74 12		 je	 SHORT $LN19@s390_store

; 672  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  001a0	ba 06 00 00 00	 mov	 edx, 6
  001a5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ad	e8 00 00 00 00	 call	 s390_program_interrupt
$LN19@s390_store:

; 673  : 
; 674  :     memset(work, 0, 32);

  001b2	48 8d 44 24 68	 lea	 rax, QWORD PTR work$[rsp]
  001b7	48 8b f8	 mov	 rdi, rax
  001ba	33 c0		 xor	 eax, eax
  001bc	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001c1	f3 aa		 rep stosb

; 675  : 
; 676  :     /* Scan DEVBLK chain for busy devices */
; 677  :     for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  001c3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ca	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  001d1	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax
  001d6	eb 0e		 jmp	 SHORT $LN13@s390_store
$LN11@s390_store:
  001d8	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  001dd	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  001e1	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax
$LN13@s390_store:
  001e6	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001ec	0f 84 3e 01 00
	00		 je	 $LN12@s390_store

; 678  :     {
; 679  :         /* Obtain the device lock */
; 680  :         obtain_lock(&dev->lock);

  001f2	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  001f7	48 83 c0 38	 add	 rax, 56			; 00000038H
  001fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180982
  00202	48 8b c8	 mov	 rcx, rax
  00205	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 681  : 
; 682  :         if (1
; 683  :             &&  dev->allocated                     /* Valid DEVBLK   */
; 684  :             && (dev->pmcw.flag5 & PMCW5_V)         /* Valid device   */
; 685  :             && (dev->pmcw.flag5 & PMCW5_E)         /* Device enabled */
; 686  :             && (dev->scsw.flag3 & SCSW3_AC_SCHAC)  /* Subchan active */
; 687  :             && (dev->scsw.flag3 & SCSW3_AC_DEVAC)  /* Device active  */

  0020b	33 c0		 xor	 eax, eax
  0020d	83 f8 01	 cmp	 eax, 1
  00210	0f 84 fc 00 00
	00		 je	 $LN20@s390_store
  00216	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0021b	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  0021f	0f 84 ed 00 00
	00		 je	 $LN20@s390_store
  00225	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0022a	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00231	83 e0 01	 and	 eax, 1
  00234	85 c0		 test	 eax, eax
  00236	0f 84 d6 00 00
	00		 je	 $LN20@s390_store
  0023c	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00241	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00248	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0024d	85 c0		 test	 eax, eax
  0024f	0f 84 bd 00 00
	00		 je	 $LN20@s390_store
  00255	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0025a	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00261	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00266	85 c0		 test	 eax, eax
  00268	0f 84 a4 00 00
	00		 je	 $LN20@s390_store
  0026e	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00273	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0027a	83 e0 40	 and	 eax, 64			; 00000040H
  0027d	85 c0		 test	 eax, eax
  0027f	0f 84 8d 00 00
	00		 je	 $LN20@s390_store

; 688  :            )
; 689  :         {
; 690  :             /* Retrieve active CHPID */
; 691  :             chpid = dev->pmcw.chpid[msbn[dev->pmcw.lpum]];

  00285	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0028a	0f b6 80 f6 02
	00 00		 movzx	 eax, BYTE PTR [rax+758]
  00291	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?msbn@?1??s390_store_channel_path_status@@9@9
  00298	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0029c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  002a1	0f b6 84 01 fc
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+764]
  002a9	88 44 24 40	 mov	 BYTE PTR chpid$[rsp], al

; 692  : 
; 693  :             /* Update channel path status work area */
; 694  :             work[chpid/8] |= 0x80 >> (chpid % 8);

  002ad	0f b6 44 24 40	 movzx	 eax, BYTE PTR chpid$[rsp]
  002b2	99		 cdq
  002b3	83 e2 07	 and	 edx, 7
  002b6	03 c2		 add	 eax, edx
  002b8	c1 f8 03	 sar	 eax, 3
  002bb	48 98		 cdqe
  002bd	48 89 44 24 60	 mov	 QWORD PTR tv189[rsp], rax
  002c2	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR chpid$[rsp]
  002c7	8b c1		 mov	 eax, ecx
  002c9	99		 cdq
  002ca	83 e2 07	 and	 edx, 7
  002cd	03 c2		 add	 eax, edx
  002cf	83 e0 07	 and	 eax, 7
  002d2	2b c2		 sub	 eax, edx
  002d4	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  002d9	89 4c 24 58	 mov	 DWORD PTR tv279[rsp], ecx
  002dd	0f b6 c8	 movzx	 ecx, al
  002e0	8b 44 24 58	 mov	 eax, DWORD PTR tv279[rsp]
  002e4	d3 f8		 sar	 eax, cl
  002e6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv189[rsp]
  002eb	0f b6 4c 0c 68	 movzx	 ecx, BYTE PTR work$[rsp+rcx]
  002f0	0b c8		 or	 ecx, eax
  002f2	8b c1		 mov	 eax, ecx
  002f4	89 44 24 5c	 mov	 DWORD PTR tv201[rsp], eax
  002f8	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR chpid$[rsp]
  002fd	8b c1		 mov	 eax, ecx
  002ff	99		 cdq
  00300	83 e2 07	 and	 edx, 7
  00303	03 c2		 add	 eax, edx
  00305	c1 f8 03	 sar	 eax, 3
  00308	48 98		 cdqe
  0030a	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv201[rsp]
  0030e	88 4c 04 68	 mov	 BYTE PTR work$[rsp+rax], cl
$LN20@s390_store:

; 695  :         }
; 696  : 
; 697  :         /* Release the device lock */
; 698  :         release_lock(&dev->lock);

  00312	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00317	48 83 c0 38	 add	 rax, 56			; 00000038H
  0031b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180984
  00322	48 8b c8	 mov	 rcx, rax
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 699  :     }

  0032b	e9 a8 fe ff ff	 jmp	 $LN11@s390_store
$LN12@s390_store:

; 700  : 
; 701  :     /* Store channel path status word at operand address */
; 702  :     ARCH_DEP(vstorec) ( work, 32-1, effective_addr2, b2, regs );

  00330	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00338	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0033d	44 8b 4c 24 50	 mov	 r9d, DWORD PTR b2$[rsp]
  00342	44 8b 44 24 44	 mov	 r8d, DWORD PTR effective_addr2$[rsp]
  00347	b2 1f		 mov	 dl, 31
  00349	48 8d 4c 24 68	 lea	 rcx, QWORD PTR work$[rsp]
  0034e	e8 00 00 00 00	 call	 s390_vstorec
$LN21@s390_store:

; 703  : }

  00353	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0035b	48 33 cc	 xor	 rcx, rsp
  0035e	e8 00 00 00 00	 call	 __security_check_cookie
  00363	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  0036a	5f		 pop	 rdi
  0036b	c3		 ret	 0
s390_store_channel_path_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
dev$ = 72
b2$ = 80
temp$1 = 84
orb$ = 88
__$ArrayPad$ = 120
inst$ = 144
regs$ = 152
s390_start_subchannel PROC

; 534  : {

$LN56:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 535  : int     b2;                             /* Effective addr base       */
; 536  : VADR    effective_addr2;                /* Effective address         */
; 537  : DEVBLK* dev;                            /* -> device block           */
; 538  : ORB     orb;                            /* Operation request block   */
; 539  : 
; 540  :     S( inst, regs, b2, effective_addr2 );

  00020	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00028	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 _byteswap_ulong
  00034	89 44 24 54	 mov	 DWORD PTR temp$1[rsp], eax
  00038	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00041	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00045	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	c1 e8 0c	 shr	 eax, 12
  0004c	83 e0 0f	 and	 eax, 15
  0004f	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00053	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  00058	74 3a		 je	 SHORT $LN32@s390_start
  0005a	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  0005f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00067	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006e	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00072	03 c8		 add	 ecx, eax
  00074	8b c1		 mov	 eax, ecx
  00076	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0007a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00088	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0008c	23 c8		 and	 ecx, eax
  0008e	8b c1		 mov	 eax, ecx
  00090	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN32@s390_start:
$LN4@s390_start:
  00094	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000a0	48 83 c0 04	 add	 rax, 4
  000a4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000b0	33 c0		 xor	 eax, eax
  000b2	83 f8 04	 cmp	 eax, 4
  000b5	74 0f		 je	 SHORT $LN33@s390_start
  000b7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN33@s390_start:
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 c8		 jne	 SHORT $LN4@s390_start

; 541  :     PER_ZEROADDR_XCHECK( regs, b2 );
; 542  : 
; 543  :     TXF_INSTR_CHECK( regs );
; 544  :     PRIV_CHECK( regs );

  000cc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000d8	83 e0 01	 and	 eax, 1
  000db	85 c0		 test	 eax, eax
  000dd	74 1b		 je	 SHORT $LN34@s390_start
  000df	ba 02 00 00 00	 mov	 edx, 2
  000e4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN34@s390_start:
$LN7@s390_start:

; 545  : 
; 546  :     PTIO( IO, "SSCH" );

  000fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00101	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00104	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0010a	48 85 c0	 test	 rax, rax
  0010d	74 5d		 je	 SHORT $LN35@s390_start
  0010f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00117	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0011d	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00121	ba 08 00 00 00	 mov	 edx, 8
  00126	48 6b d2 01	 imul	 rdx, rdx, 1
  0012a	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00132	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0013a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00143	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00148	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180909
  0014f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00154	44 8b c9	 mov	 r9d, ecx
  00157	44 8b c2	 mov	 r8d, edx
  0015a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180910
  00161	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN35@s390_start:
  0016c	33 c0		 xor	 eax, eax
  0016e	85 c0		 test	 eax, eax
  00170	75 88		 jne	 SHORT $LN7@s390_start

; 547  : 
; 548  : #if defined( _FEATURE_IO_ASSIST )
; 549  :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  00172	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00180	d1 e8		 shr	 eax, 1
  00182	83 e0 01	 and	 eax, 1
  00185	85 c0		 test	 eax, eax
  00187	0f 84 f4 00 00
	00		 je	 $LN36@s390_start
  0018d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00195	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0019c	b9 01 00 00 00	 mov	 ecx, 1
  001a1	48 6b c9 00	 imul	 rcx, rcx, 0
  001a5	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  001aa	83 e0 04	 and	 eax, 4
  001ad	85 c0		 test	 eax, eax
  001af	0f 85 cc 00 00
	00		 jne	 $LN36@s390_start
  001b5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001c3	c1 e8 02	 shr	 eax, 2
  001c6	83 e0 01	 and	 eax, 1
  001c9	85 c0		 test	 eax, eax
  001cb	0f 85 b0 00 00
	00		 jne	 $LN36@s390_start
$LN10@s390_start:

; 550  : #endif
; 551  :     {
; 552  :         PTIO( IO, "SSCH (sie)" );

  001d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001d8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001db	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001e1	48 85 c0	 test	 rax, rax
  001e4	74 5d		 je	 SHORT $LN37@s390_start
  001e6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ee	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001f4	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001f8	ba 08 00 00 00	 mov	 edx, 8
  001fd	48 6b d2 01	 imul	 rdx, rdx, 1
  00201	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00209	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00211	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0021a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0021f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180913
  00226	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022b	44 8b c9	 mov	 r9d, ecx
  0022e	44 8b c2	 mov	 r8d, edx
  00231	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180914
  00238	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0023d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN37@s390_start:
  00243	33 c0		 xor	 eax, eax
  00245	85 c0		 test	 eax, eax
  00247	75 88		 jne	 SHORT $LN10@s390_start
$LN13@s390_start:

; 553  :         SIE_INTERCEPT( regs );

  00249	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00251	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00257	d1 e8		 shr	 eax, 1
  00259	83 e0 01	 and	 eax, 1
  0025c	85 c0		 test	 eax, eax
  0025e	74 1b		 je	 SHORT $LN38@s390_start
  00260	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00268	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0026e	ba fc ff ff ff	 mov	 edx, -4
  00273	48 8b c8	 mov	 rcx, rax
  00276	e8 00 00 00 00	 call	 longjmp
$LN38@s390_start:
  0027b	33 c0		 xor	 eax, eax
  0027d	85 c0		 test	 eax, eax
  0027f	75 c8		 jne	 SHORT $LN13@s390_start
$LN36@s390_start:

; 554  :     }
; 555  : 
; 556  :     FW_CHECK( effective_addr2, regs );

  00281	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00285	83 e0 03	 and	 eax, 3
  00288	85 c0		 test	 eax, eax
  0028a	74 1b		 je	 SHORT $LN39@s390_start
  0028c	ba 06 00 00 00	 mov	 edx, 6
  00291	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00299	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN39@s390_start:

; 557  : 
; 558  :     /* Fetch the operation request block */
; 559  :     ARCH_DEP( vfetchc )( &orb, sizeof( ORB )-1, effective_addr2, b2, regs );

  002a7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b4	44 8b 4c 24 50	 mov	 r9d, DWORD PTR b2$[rsp]
  002b9	44 8b 44 24 40	 mov	 r8d, DWORD PTR effective_addr2$[rsp]
  002be	b2 1f		 mov	 dl, 31
  002c0	48 8d 4c 24 58	 lea	 rcx, QWORD PTR orb$[rsp]
  002c5	e8 00 00 00 00	 call	 s390_vfetchc

; 560  : 
; 561  :     /* Program check if reserved bits are not zero */
; 562  :     if (0
; 563  :         || orb.flag5 & ORB5_B /* Fiber Channel Extension (FCX) unsupported */
; 564  :         || orb.flag7 & ORB7_RESV
; 565  :         || orb.ccwaddr[0] & 0x80

  002ca	33 c0		 xor	 eax, eax
  002cc	85 c0		 test	 eax, eax
  002ce	75 2f		 jne	 SHORT $LN41@s390_start
  002d0	0f b6 44 24 5d	 movzx	 eax, BYTE PTR orb$[rsp+5]
  002d5	83 e0 04	 and	 eax, 4
  002d8	85 c0		 test	 eax, eax
  002da	75 23		 jne	 SHORT $LN41@s390_start
  002dc	0f b6 44 24 5f	 movzx	 eax, BYTE PTR orb$[rsp+7]
  002e1	83 e0 3e	 and	 eax, 62			; 0000003eH
  002e4	85 c0		 test	 eax, eax
  002e6	75 17		 jne	 SHORT $LN41@s390_start
  002e8	b8 01 00 00 00	 mov	 eax, 1
  002ed	48 6b c0 00	 imul	 rax, rax, 0
  002f1	0f b6 44 04 60	 movzx	 eax, BYTE PTR orb$[rsp+rax+8]
  002f6	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002fb	85 c0		 test	 eax, eax
  002fd	74 12		 je	 SHORT $LN40@s390_start
$LN41@s390_start:

; 566  :     )
; 567  :         ARCH_DEP( program_interrupt )( regs, PGM_OPERAND_EXCEPTION );

  002ff	ba 15 00 00 00	 mov	 edx, 21
  00304	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030c	e8 00 00 00 00	 call	 s390_program_interrupt
$LN40@s390_start:

; 568  : 
; 569  : #if !defined( FEATURE_INCORRECT_LENGTH_INDICATION_SUPPRESSION )
; 570  :     /* Program check if incorrect length suppression */
; 571  :     if (orb.flag7 & ORB7_L)
; 572  :         ARCH_DEP( program_interrupt )( regs, PGM_OPERAND_EXCEPTION );
; 573  : #endif
; 574  : 
; 575  : #if !defined( FEATURE_MIDAW_FACILITY )
; 576  :     /* Program check if modified indirect data addressing requested */
; 577  :     if (orb.flag7 & ORB7_D)

  00311	0f b6 44 24 5f	 movzx	 eax, BYTE PTR orb$[rsp+7]
  00316	83 e0 40	 and	 eax, 64			; 00000040H
  00319	85 c0		 test	 eax, eax
  0031b	74 12		 je	 SHORT $LN42@s390_start

; 578  :         ARCH_DEP( program_interrupt )( regs, PGM_OPERAND_EXCEPTION );

  0031d	ba 15 00 00 00	 mov	 edx, 21
  00322	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032a	e8 00 00 00 00	 call	 s390_program_interrupt
$LN42@s390_start:

; 579  : #endif
; 580  : 
; 581  :     /* Program check if the ssid including lcss is invalid */
; 582  :     SSID_CHECK( regs );

  0032f	b8 08 00 00 00	 mov	 eax, 8
  00334	48 6b c0 01	 imul	 rax, rax, 1
  00338	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00340	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  00348	83 e0 01	 and	 eax, 1
  0034b	85 c0		 test	 eax, eax
  0034d	74 1e		 je	 SHORT $LN44@s390_start
  0034f	b8 08 00 00 00	 mov	 eax, 8
  00354	48 6b c0 01	 imul	 rax, rax, 1
  00358	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00360	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  00368	83 f8 03	 cmp	 eax, 3
  0036b	7e 1b		 jle	 SHORT $LN43@s390_start
$LN44@s390_start:
  0036d	ba 15 00 00 00	 mov	 edx, 21
  00372	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00382	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN43@s390_start:

; 583  : 
; 584  :     /* Locate the device block for this subchannel */
; 585  :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  00388	b8 08 00 00 00	 mov	 eax, 8
  0038d	48 6b c0 01	 imul	 rax, rax, 1
  00391	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00399	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  003a0	e8 00 00 00 00	 call	 find_device_by_subchan
  003a5	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax

; 586  : 
; 587  :     if (dev)

  003aa	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  003b0	74 5a		 je	 SHORT $LN45@s390_start
$LN16@s390_start:

; 588  :         PTT( PTT_CL_IO, "SSCH (dev)", dev->devnum, 0, 0 );

  003b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003bc	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  003c2	48 85 c0	 test	 rax, rax
  003c5	74 3f		 je	 SHORT $LN46@s390_start
  003c7	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  003cc	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003d0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003d9	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  003e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180924
  003e9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003ee	45 33 c9	 xor	 r9d, r9d
  003f1	44 8b c0	 mov	 r8d, eax
  003f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180925
  003fb	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00400	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN46@s390_start:
  00406	33 c0		 xor	 eax, eax
  00408	85 c0		 test	 eax, eax
  0040a	75 a6		 jne	 SHORT $LN16@s390_start
$LN45@s390_start:

; 589  : 
; 590  :     /* Condition code 3 if subchannel does not exist,
; 591  :        is not valid, is not enabled, or no path available */
; 592  :     if (0
; 593  :         || !dev
; 594  :         || !(dev->pmcw.flag5 & PMCW5_V)
; 595  :         || !(dev->pmcw.flag5 & PMCW5_E)
; 596  :         || !(orb.lpm & dev->pmcw.pam)

  0040c	33 c0		 xor	 eax, eax
  0040e	85 c0		 test	 eax, eax
  00410	75 4b		 jne	 SHORT $LN48@s390_start
  00412	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00418	74 43		 je	 SHORT $LN48@s390_start
  0041a	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0041f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00426	83 e0 01	 and	 eax, 1
  00429	85 c0		 test	 eax, eax
  0042b	74 30		 je	 SHORT $LN48@s390_start
  0042d	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00432	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00439	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0043e	85 c0		 test	 eax, eax
  00440	74 1b		 je	 SHORT $LN48@s390_start
  00442	0f b6 44 24 5e	 movzx	 eax, BYTE PTR orb$[rsp+6]
  00447	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  0044c	0f b6 89 fb 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+763]
  00453	23 c1		 and	 eax, ecx
  00455	85 c0		 test	 eax, eax
  00457	0f 85 35 01 00
	00		 jne	 $LN47@s390_start
$LN48@s390_start:
$LN19@s390_start:

; 597  :     )
; 598  :     {
; 599  :         PTIO( ERR, "*SSCH" );

  0045d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00464	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00467	48 83 e0 10	 and	 rax, 16
  0046b	48 85 c0	 test	 rax, rax
  0046e	74 5d		 je	 SHORT $LN49@s390_start
  00470	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00478	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0047e	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00482	ba 08 00 00 00	 mov	 edx, 8
  00487	48 6b d2 01	 imul	 rdx, rdx, 1
  0048b	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00493	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0049b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004a4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180929
  004b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004b5	44 8b c9	 mov	 r9d, ecx
  004b8	44 8b c2	 mov	 r8d, edx
  004bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180930
  004c2	b9 10 00 00 00	 mov	 ecx, 16
  004c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN49@s390_start:
  004cd	33 c0		 xor	 eax, eax
  004cf	85 c0		 test	 eax, eax
  004d1	75 8a		 jne	 SHORT $LN19@s390_start
$LN22@s390_start:

; 600  : #if defined( _FEATURE_IO_ASSIST )
; 601  :         PTIO( ERR, "*SSCH (sie)" );

  004d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004da	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004dd	48 83 e0 10	 and	 rax, 16
  004e1	48 85 c0	 test	 rax, rax
  004e4	74 5d		 je	 SHORT $LN50@s390_start
  004e6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ee	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  004f4	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  004f8	ba 08 00 00 00	 mov	 edx, 8
  004fd	48 6b d2 01	 imul	 rdx, rdx, 1
  00501	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00509	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00511	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0051a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0051f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180932
  00526	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0052b	44 8b c9	 mov	 r9d, ecx
  0052e	44 8b c2	 mov	 r8d, edx
  00531	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180933
  00538	b9 10 00 00 00	 mov	 ecx, 16
  0053d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN50@s390_start:
  00543	33 c0		 xor	 eax, eax
  00545	85 c0		 test	 eax, eax
  00547	75 8a		 jne	 SHORT $LN22@s390_start
$LN25@s390_start:

; 602  :         SIE_INTERCEPT( regs );

  00549	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00551	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00557	d1 e8		 shr	 eax, 1
  00559	83 e0 01	 and	 eax, 1
  0055c	85 c0		 test	 eax, eax
  0055e	74 1b		 je	 SHORT $LN51@s390_start
  00560	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00568	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0056e	ba fc ff ff ff	 mov	 edx, -4
  00573	48 8b c8	 mov	 rcx, rax
  00576	e8 00 00 00 00	 call	 longjmp
$LN51@s390_start:
  0057b	33 c0		 xor	 eax, eax
  0057d	85 c0		 test	 eax, eax
  0057f	75 c8		 jne	 SHORT $LN25@s390_start

; 603  : #endif
; 604  :         regs->psw.cc = 3;

  00581	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00589	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 605  :         return;

  0058d	e9 f9 00 00 00	 jmp	 $LN1@s390_start
$LN47@s390_start:

; 606  :     }
; 607  : 
; 608  :     /* Perform serialization and checkpoint-synchronization */
; 609  :     PERFORM_SERIALIZATION( regs );

  00592	0f ae f0	 mfence
$LN28@s390_start:

; 610  :     PERFORM_CHKPT_SYNC( regs );

  00595	33 c0		 xor	 eax, eax
  00597	85 c0		 test	 eax, eax
  00599	75 fa		 jne	 SHORT $LN28@s390_start

; 611  : 
; 612  :     /* Clear the path not operational mask */
; 613  :     dev->pmcw.pnom = 0;

  0059b	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  005a0	c6 80 f5 02 00
	00 00		 mov	 BYTE PTR [rax+757], 0

; 614  : 
; 615  :     /* Copy the logical path mask */
; 616  :     dev->pmcw.lpm = orb.lpm;

  005a7	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  005ac	0f b6 4c 24 5e	 movzx	 ecx, BYTE PTR orb$[rsp+6]
  005b1	88 88 f4 02 00
	00		 mov	 BYTE PTR [rax+756], cl

; 617  : 
; 618  :     /* Start the channel program and set the condition code */
; 619  :     regs->psw.cc = ARCH_DEP( startio )( regs, dev, &orb );

  005b7	4c 8d 44 24 58	 lea	 r8, QWORD PTR orb$[rsp]
  005bc	48 8b 54 24 48	 mov	 rdx, QWORD PTR dev$[rsp]
  005c1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c9	e8 00 00 00 00	 call	 s390_startio
  005ce	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005d6	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 620  : 
; 621  :     regs->siocount++;

  005d9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e1	8b 80 a0 07 00
	00		 mov	 eax, DWORD PTR [rax+1952]
  005e7	ff c0		 inc	 eax
  005e9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f1	89 81 a0 07 00
	00		 mov	 DWORD PTR [rcx+1952], eax

; 622  : 
; 623  :     /* Set the last path used mask */
; 624  :     if (regs->psw.cc == 0)

  005f7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ff	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00603	85 c0		 test	 eax, eax
  00605	75 0e		 jne	 SHORT $LN52@s390_start

; 625  :         dev->pmcw.lpum = 0x80;

  00607	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0060c	c6 80 f6 02 00
	00 80		 mov	 BYTE PTR [rax+758], 128	; 00000080H
  00613	eb 76		 jmp	 SHORT $LN53@s390_start
$LN52@s390_start:
$LN31@s390_start:

; 626  :     else
; 627  :         PTIO( ERR, "*SSCH" );

  00615	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0061c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0061f	48 83 e0 10	 and	 rax, 16
  00623	48 85 c0	 test	 rax, rax
  00626	74 5d		 je	 SHORT $LN54@s390_start
  00628	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00630	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00636	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0063a	ba 08 00 00 00	 mov	 edx, 8
  0063f	48 6b d2 01	 imul	 rdx, rdx, 1
  00643	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0064b	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00653	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0065c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00661	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180938
  00668	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0066d	44 8b c9	 mov	 r9d, ecx
  00670	44 8b c2	 mov	 r8d, edx
  00673	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180939
  0067a	b9 10 00 00 00	 mov	 ecx, 16
  0067f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN54@s390_start:
  00685	33 c0		 xor	 eax, eax
  00687	85 c0		 test	 eax, eax
  00689	75 8a		 jne	 SHORT $LN31@s390_start
$LN53@s390_start:
$LN1@s390_start:
$LN55@s390_start:

; 628  : }

  0068b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00690	48 33 cc	 xor	 rcx, rsp
  00693	e8 00 00 00 00	 call	 __security_check_cookie
  00698	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0069f	c3		 ret	 0
s390_start_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
chpid$ = 64
effective_addr2$ = 68
temp$1 = 72
b2$ = 76
tv166 = 80
inst$ = 112
regs$ = 120
s390_reset_channel_path PROC

; 341  : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 342  : int     b2;                             /* Base of effective addr    */
; 343  : VADR    effective_addr2;                /* Effective address         */
; 344  : BYTE    chpid;
; 345  : 
; 346  :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 44	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 4c	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 4c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 34		 je	 SHORT $LN14@s390_reset
  00045	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 44	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0006d	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00071	23 c8		 and	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 44 24 44	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN14@s390_reset:
$LN4@s390_reset:
  00079	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	48 83 c0 04	 add	 rax, 4
  00086	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 04	 cmp	 eax, 4
  00094	74 0c		 je	 SHORT $LN15@s390_reset
  00096	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN15@s390_reset:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 d1		 jne	 SHORT $LN4@s390_reset

; 347  : 
; 348  :     TXF_INSTR_CHECK( regs );
; 349  :     PRIV_CHECK(regs);

  000a8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000b1	83 e0 01	 and	 eax, 1
  000b4	85 c0		 test	 eax, eax
  000b6	74 15		 je	 SHORT $LN16@s390_reset
  000b8	ba 02 00 00 00	 mov	 edx, 2
  000bd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@s390_reset:
$LN7@s390_reset:

; 350  :     SIE_INTERCEPT(regs);

  000cd	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d8	d1 e8		 shr	 eax, 1
  000da	83 e0 01	 and	 eax, 1
  000dd	85 c0		 test	 eax, eax
  000df	74 18		 je	 SHORT $LN17@s390_reset
  000e1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e6	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000ec	ba fc ff ff ff	 mov	 edx, -4
  000f1	48 8b c8	 mov	 rcx, rax
  000f4	e8 00 00 00 00	 call	 longjmp
$LN17@s390_reset:
  000f9	33 c0		 xor	 eax, eax
  000fb	85 c0		 test	 eax, eax
  000fd	75 ce		 jne	 SHORT $LN7@s390_reset
$LN10@s390_reset:

; 351  : 
; 352  :     PTIO(IO,"RCHP");

  000ff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00106	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00109	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0010f	48 85 c0	 test	 rax, rax
  00112	74 57		 je	 SHORT $LN18@s390_reset
  00114	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00119	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0011f	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00123	ba 08 00 00 00	 mov	 edx, 8
  00128	48 6b d2 01	 imul	 rdx, rdx, 1
  0012c	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00131	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00139	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00142	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00147	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180624
  0014e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00153	44 8b c9	 mov	 r9d, ecx
  00156	44 8b c2	 mov	 r8d, edx
  00159	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180625
  00160	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@s390_reset:
  0016b	33 c0		 xor	 eax, eax
  0016d	85 c0		 test	 eax, eax
  0016f	75 8e		 jne	 SHORT $LN10@s390_reset

; 353  : 
; 354  :     /* Program check if reg 1 bits 0-23 not zero */
; 355  :     if(regs->GR_L(1) & 0xFFFFFF00)

  00171	b8 08 00 00 00	 mov	 eax, 8
  00176	48 6b c0 01	 imul	 rax, rax, 1
  0017a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00186	25 00 ff ff ff	 and	 eax, -256		; ffffff00H
  0018b	85 c0		 test	 eax, eax
  0018d	74 0f		 je	 SHORT $LN19@s390_reset

; 356  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  0018f	ba 15 00 00 00	 mov	 edx, 21
  00194	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00199	e8 00 00 00 00	 call	 s390_program_interrupt
$LN19@s390_reset:

; 357  : 
; 358  :     chpid = regs->GR_L(1) & 0xFF;

  0019e	b8 08 00 00 00	 mov	 eax, 8
  001a3	48 6b c0 01	 imul	 rax, rax, 1
  001a7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001ac	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001b3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001b8	88 44 24 40	 mov	 BYTE PTR chpid$[rsp], al

; 359  : 
; 360  :     if((regs->psw.cc = chp_reset(chpid, 1)) != 0)

  001bc	ba 01 00 00 00	 mov	 edx, 1
  001c1	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR chpid$[rsp]
  001c6	e8 00 00 00 00	 call	 chp_reset
  001cb	89 44 24 50	 mov	 DWORD PTR tv166[rsp], eax
  001cf	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001d4	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR tv166[rsp]
  001d9	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  001dc	0f b6 44 24 50	 movzx	 eax, BYTE PTR tv166[rsp]
  001e1	85 c0		 test	 eax, eax
  001e3	0f 84 88 00 00
	00		 je	 $LN20@s390_reset
$LN13@s390_reset:

; 361  :     {
; 362  :         PTIO(ERR,"*RCHP");

  001e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001f0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f3	48 83 e0 10	 and	 rax, 16
  001f7	48 85 c0	 test	 rax, rax
  001fa	74 57		 je	 SHORT $LN21@s390_reset
  001fc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00201	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00207	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0020b	ba 08 00 00 00	 mov	 edx, 8
  00210	48 6b d2 01	 imul	 rdx, rdx, 1
  00214	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00219	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00221	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0022a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0022f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180629
  00236	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023b	44 8b c9	 mov	 r9d, ecx
  0023e	44 8b c2	 mov	 r8d, edx
  00241	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180630
  00248	b9 10 00 00 00	 mov	 ecx, 16
  0024d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN21@s390_reset:
  00253	33 c0		 xor	 eax, eax
  00255	85 c0		 test	 eax, eax
  00257	75 90		 jne	 SHORT $LN13@s390_reset

; 363  :         RETURN_INTCHECK(regs);

  00259	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0025e	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00264	ba ff ff ff ff	 mov	 edx, -1
  00269	48 8b c8	 mov	 rcx, rax
  0026c	e8 00 00 00 00	 call	 longjmp
$LN20@s390_reset:
$LN22@s390_reset:

; 364  :     }
; 365  : }

  00271	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00275	c3		 ret	 0
s390_reset_channel_path ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
zone$1 = 68
temp$2 = 72
b2$ = 76
tv268 = 80
inst$ = 112
regs$ = 120
s390_set_channel_monitor PROC

; 453  : {

$LN35:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 454  : int     b2;                             /* Effective addr base       */
; 455  : VADR    effective_addr2;                /* Effective address         */
; 456  : 
; 457  :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 48	 mov	 DWORD PTR temp$2[rsp], eax
  00023	8b 44 24 48	 mov	 eax, DWORD PTR temp$2[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 48	 mov	 eax, DWORD PTR temp$2[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 4c	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 4c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 34		 je	 SHORT $LN14@s390_set_c
  00045	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0006d	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00071	23 c8		 and	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN14@s390_set_c:
$LN4@s390_set_c:
  00079	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	48 83 c0 04	 add	 rax, 4
  00086	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 04	 cmp	 eax, 4
  00094	74 0c		 je	 SHORT $LN15@s390_set_c
  00096	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN15@s390_set_c:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 d1		 jne	 SHORT $LN4@s390_set_c

; 458  : 
; 459  :     TXF_INSTR_CHECK( regs );
; 460  :     PRIV_CHECK(regs);

  000a8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000b1	83 e0 01	 and	 eax, 1
  000b4	85 c0		 test	 eax, eax
  000b6	74 15		 je	 SHORT $LN16@s390_set_c
  000b8	ba 02 00 00 00	 mov	 edx, 2
  000bd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@s390_set_c:

; 461  : 
; 462  : #if defined(_FEATURE_IO_ASSIST)
; 463  :     if(SIE_STATE_BIT_OFF(regs, EC0, IOA) && !regs->sie_pref)

  000cd	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d8	d1 e8		 shr	 eax, 1
  000da	83 e0 01	 and	 eax, 1
  000dd	85 c0		 test	 eax, eax
  000df	74 68		 je	 SHORT $LN17@s390_set_c
  000e1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e6	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000ed	b9 01 00 00 00	 mov	 ecx, 1
  000f2	48 6b c9 00	 imul	 rcx, rcx, 0
  000f6	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  000fb	83 e0 04	 and	 eax, 4
  000fe	85 c0		 test	 eax, eax
  00100	75 47		 jne	 SHORT $LN17@s390_set_c
  00102	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00107	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0010d	c1 e8 02	 shr	 eax, 2
  00110	83 e0 01	 and	 eax, 1
  00113	85 c0		 test	 eax, eax
  00115	75 32		 jne	 SHORT $LN17@s390_set_c
$LN7@s390_set_c:

; 464  : #endif
; 465  :         SIE_INTERCEPT(regs);

  00117	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00122	d1 e8		 shr	 eax, 1
  00124	83 e0 01	 and	 eax, 1
  00127	85 c0		 test	 eax, eax
  00129	74 18		 je	 SHORT $LN18@s390_set_c
  0012b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00130	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00136	ba fc ff ff ff	 mov	 edx, -4
  0013b	48 8b c8	 mov	 rcx, rax
  0013e	e8 00 00 00 00	 call	 longjmp
$LN18@s390_set_c:
  00143	33 c0		 xor	 eax, eax
  00145	85 c0		 test	 eax, eax
  00147	75 ce		 jne	 SHORT $LN7@s390_set_c
$LN17@s390_set_c:
$LN10@s390_set_c:

; 466  : 
; 467  :     PTIO(IO,"SCHM");

  00149	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00150	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00153	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00159	48 85 c0	 test	 rax, rax
  0015c	74 57		 je	 SHORT $LN19@s390_set_c
  0015e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00163	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00169	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0016d	ba 08 00 00 00	 mov	 edx, 8
  00172	48 6b d2 01	 imul	 rdx, rdx, 1
  00176	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0017b	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00183	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0018c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00191	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180808
  00198	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019d	44 8b c9	 mov	 r9d, ecx
  001a0	44 8b c2	 mov	 r8d, edx
  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180809
  001aa	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN19@s390_set_c:
  001b5	33 c0		 xor	 eax, eax
  001b7	85 c0		 test	 eax, eax
  001b9	75 8e		 jne	 SHORT $LN10@s390_set_c

; 468  : 
; 469  :     /* Reserved bits in gpr1 must be zero */
; 470  :     if (regs->GR_L(1) & CHM_GPR1_RESV)

  001bb	b8 08 00 00 00	 mov	 eax, 8
  001c0	48 6b c0 01	 imul	 rax, rax, 1
  001c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001c9	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001d0	25 fc ff 00 0e	 and	 eax, 234946556		; 0e00fffcH
  001d5	85 c0		 test	 eax, eax
  001d7	74 0f		 je	 SHORT $LN20@s390_set_c

; 471  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  001d9	ba 15 00 00 00	 mov	 edx, 21
  001de	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001e3	e8 00 00 00 00	 call	 s390_program_interrupt
$LN20@s390_set_c:

; 472  : 
; 473  :     /* Program check if M bit one and gpr2 address not on
; 474  :        a 32 byte boundary or highorder bit set in ESA/390 mode */
; 475  :     if ((regs->GR_L(1) & CHM_GPR1_M)
; 476  :      && (regs->GR_L(2) & CHM_GPR2_RESV))

  001e8	b8 08 00 00 00	 mov	 eax, 8
  001ed	48 6b c0 01	 imul	 rax, rax, 1
  001f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001f6	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001fd	83 e0 02	 and	 eax, 2
  00200	85 c0		 test	 eax, eax
  00202	74 2d		 je	 SHORT $LN21@s390_set_c
  00204	b8 08 00 00 00	 mov	 eax, 8
  00209	48 6b c0 02	 imul	 rax, rax, 2
  0020d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00219	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  0021e	85 c0		 test	 eax, eax
  00220	74 0f		 je	 SHORT $LN21@s390_set_c

; 477  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  00222	ba 15 00 00 00	 mov	 edx, 21
  00227	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0022c	e8 00 00 00 00	 call	 s390_program_interrupt
$LN21@s390_set_c:

; 478  : 
; 479  : #if defined(_FEATURE_IO_ASSIST)
; 480  :     /* Virtual use of I/O Assist features must be intercepted */
; 481  :     if(SIE_MODE(regs)
; 482  :       && ( (regs->GR_L(1) & CHM_GPR1_ZONE)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0023c	d1 e8		 shr	 eax, 1
  0023e	83 e0 01	 and	 eax, 1
  00241	85 c0		 test	 eax, eax
  00243	74 6e		 je	 SHORT $LN22@s390_set_c
  00245	b8 08 00 00 00	 mov	 eax, 8
  0024a	48 6b c0 01	 imul	 rax, rax, 1
  0024e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00253	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0025a	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  0025f	85 c0		 test	 eax, eax
  00261	75 1e		 jne	 SHORT $LN23@s390_set_c
  00263	b8 08 00 00 00	 mov	 eax, 8
  00268	48 6b c0 01	 imul	 rax, rax, 1
  0026c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00271	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00278	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  0027d	85 c0		 test	 eax, eax
  0027f	74 32		 je	 SHORT $LN22@s390_set_c
$LN23@s390_set_c:
$LN13@s390_set_c:

; 483  :         || (regs->GR_L(1) & CHM_GPR1_A) ))
; 484  :         SIE_INTERCEPT(regs);

  00281	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00286	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0028c	d1 e8		 shr	 eax, 1
  0028e	83 e0 01	 and	 eax, 1
  00291	85 c0		 test	 eax, eax
  00293	74 18		 je	 SHORT $LN24@s390_set_c
  00295	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0029a	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  002a0	ba fc ff ff ff	 mov	 edx, -4
  002a5	48 8b c8	 mov	 rcx, rax
  002a8	e8 00 00 00 00	 call	 longjmp
$LN24@s390_set_c:
  002ad	33 c0		 xor	 eax, eax
  002af	85 c0		 test	 eax, eax
  002b1	75 ce		 jne	 SHORT $LN13@s390_set_c
$LN22@s390_set_c:

; 485  : 
; 486  :     /* Zone must be a valid zone number */
; 487  :     if (((regs->GR_L(1) & CHM_GPR1_ZONE) >> 16) >= FEATURE_SIE_MAXZONES)

  002b3	b8 08 00 00 00	 mov	 eax, 8
  002b8	48 6b c0 01	 imul	 rax, rax, 1
  002bc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002c1	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002c8	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  002cd	c1 e8 10	 shr	 eax, 16
  002d0	83 f8 08	 cmp	 eax, 8
  002d3	72 0f		 jb	 SHORT $LN25@s390_set_c

; 488  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  002d5	ba 15 00 00 00	 mov	 edx, 21
  002da	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002df	e8 00 00 00 00	 call	 s390_program_interrupt
$LN25@s390_set_c:

; 489  : 
; 490  :     if(regs->GR_L(1) & CHM_GPR1_A)

  002e4	b8 08 00 00 00	 mov	 eax, 8
  002e9	48 6b c0 01	 imul	 rax, rax, 1
  002ed	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002f9	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  002fe	85 c0		 test	 eax, eax
  00300	0f 84 b7 00 00
	00		 je	 $LN26@s390_set_c

; 491  : #endif /*defined(_FEATURE_IO_ASSIST)*/
; 492  :     {
; 493  :         /* Set the measurement block origin address */
; 494  :         if (regs->GR_L(1) & CHM_GPR1_M)

  00306	b8 08 00 00 00	 mov	 eax, 8
  0030b	48 6b c0 01	 imul	 rax, rax, 1
  0030f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00314	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0031b	83 e0 02	 and	 eax, 2
  0031e	85 c0		 test	 eax, eax
  00320	74 60		 je	 SHORT $LN28@s390_set_c

; 495  :         {
; 496  :             sysblk.mbo = regs->GR(2);

  00322	b8 08 00 00 00	 mov	 eax, 8
  00327	48 6b c0 02	 imul	 rax, rax, 2
  0032b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00330	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00337	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0033e	48 89 81 f0 10
	00 00		 mov	 QWORD PTR [rcx+4336], rax

; 497  :             sysblk.mbk = (regs->GR_L(1) & CHM_GPR1_MBK) >> 24;

  00345	b8 08 00 00 00	 mov	 eax, 8
  0034a	48 6b c0 01	 imul	 rax, rax, 1
  0034e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00353	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0035a	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  0035f	c1 e8 18	 shr	 eax, 24
  00362	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00369	88 81 f8 10 00
	00		 mov	 BYTE PTR [rcx+4344], al

; 498  :             sysblk.mbm = 1;

  0036f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00376	c7 80 fc 10 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4348], 1

; 499  :         }

  00380	eb 11		 jmp	 SHORT $LN29@s390_set_c
$LN28@s390_set_c:

; 500  :         else
; 501  :             sysblk.mbm = 0;

  00382	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00389	c7 80 fc 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4348], 0
$LN29@s390_set_c:

; 502  : 
; 503  :         sysblk.mbd = regs->GR_L(1) & CHM_GPR1_D;

  00393	b8 08 00 00 00	 mov	 eax, 8
  00398	48 6b c0 01	 imul	 rax, rax, 1
  0039c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003a1	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  003a8	83 e0 01	 and	 eax, 1
  003ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003b2	89 81 00 11 00
	00		 mov	 DWORD PTR [rcx+4352], eax

; 504  : 
; 505  :     }

  003b8	e9 37 01 00 00	 jmp	 $LN27@s390_set_c
$LN26@s390_set_c:

; 506  : #if defined(_FEATURE_IO_ASSIST)
; 507  :     else
; 508  :     {
; 509  :     int zone = SIE_MODE(regs) ? regs->siebk->zone :

  003bd	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003c2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  003c8	d1 e8		 shr	 eax, 1
  003ca	83 e0 01	 and	 eax, 1
  003cd	85 c0		 test	 eax, eax
  003cf	74 16		 je	 SHORT $LN33@s390_set_c
  003d1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003d6	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  003dd	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  003e1	89 44 24 50	 mov	 DWORD PTR tv268[rsp], eax
  003e5	eb 21		 jmp	 SHORT $LN34@s390_set_c
$LN33@s390_set_c:
  003e7	b8 08 00 00 00	 mov	 eax, 8
  003ec	48 6b c0 01	 imul	 rax, rax, 1
  003f0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003f5	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  003fc	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00401	c1 e8 10	 shr	 eax, 16
  00404	89 44 24 50	 mov	 DWORD PTR tv268[rsp], eax
$LN34@s390_set_c:
  00408	8b 44 24 50	 mov	 eax, DWORD PTR tv268[rsp]
  0040c	89 44 24 44	 mov	 DWORD PTR zone$1[rsp], eax

; 510  :                                ((regs->GR_L(1) & CHM_GPR1_ZONE) >> 16);
; 511  : 
; 512  :         /* Set the measurement block origin address */
; 513  :         if (regs->GR_L(1) & CHM_GPR1_M)

  00410	b8 08 00 00 00	 mov	 eax, 8
  00415	48 6b c0 01	 imul	 rax, rax, 1
  00419	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0041e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00425	83 e0 02	 and	 eax, 2
  00428	85 c0		 test	 eax, eax
  0042a	74 7e		 je	 SHORT $LN30@s390_set_c

; 514  :         {
; 515  :             sysblk.zpb[zone].mbo = regs->GR(2);

  0042c	b8 08 00 00 00	 mov	 eax, 8
  00431	48 6b c0 02	 imul	 rax, rax, 2
  00435	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR zone$1[rsp]
  0043a	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  0043e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00443	8b 84 02 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax+640]
  0044a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00451	48 89 84 0a c0
	0e 00 00	 mov	 QWORD PTR [rdx+rcx+3776], rax

; 516  :             sysblk.zpb[zone].mbk = (regs->GR_L(1) & CHM_GPR1_MBK) >> 24;

  00459	b8 08 00 00 00	 mov	 eax, 8
  0045e	48 6b c0 01	 imul	 rax, rax, 1
  00462	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00467	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0046e	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  00473	c1 e8 18	 shr	 eax, 24
  00476	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR zone$1[rsp]
  0047b	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  0047f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00486	88 84 0a c8 0e
	00 00		 mov	 BYTE PTR [rdx+rcx+3784], al

; 517  :             sysblk.zpb[zone].mbm = 1;

  0048d	48 63 44 24 44	 movsxd	 rax, DWORD PTR zone$1[rsp]
  00492	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00496	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0049d	c7 84 01 cc 0e
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+3788], 1

; 518  :         }

  004a8	eb 1b		 jmp	 SHORT $LN31@s390_set_c
$LN30@s390_set_c:

; 519  :         else
; 520  :             sysblk.zpb[zone].mbm = 0;

  004aa	48 63 44 24 44	 movsxd	 rax, DWORD PTR zone$1[rsp]
  004af	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  004b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004ba	c7 84 01 cc 0e
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+3788], 0
$LN31@s390_set_c:

; 521  : 
; 522  :         sysblk.zpb[zone].mbd = regs->GR_L(1) & CHM_GPR1_D;

  004c5	b8 08 00 00 00	 mov	 eax, 8
  004ca	48 6b c0 01	 imul	 rax, rax, 1
  004ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  004d3	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  004da	83 e0 01	 and	 eax, 1
  004dd	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR zone$1[rsp]
  004e2	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  004e6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004ed	89 84 0a d0 0e
	00 00		 mov	 DWORD PTR [rdx+rcx+3792], eax
$LN27@s390_set_c:
$LN32@s390_set_c:

; 523  : 
; 524  :     }
; 525  : #endif /*defined(_FEATURE_IO_ASSIST)*/
; 526  : 
; 527  : }

  004f4	48 83 c4 68	 add	 rsp, 104		; 00000068H
  004f8	c3		 ret	 0
s390_set_channel_monitor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
temp$1 = 68
b2$ = 72
inst$ = 96
regs$ = 104
s390_set_address_limit PROC

; 430  : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 431  : int     b2;                             /* Effective addr base       */
; 432  : VADR    effective_addr2;                /* Effective address         */
; 433  : 
; 434  :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 34		 je	 SHORT $LN11@s390_set_a
  00045	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00067	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0006d	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00071	23 c8		 and	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN11@s390_set_a:
$LN4@s390_set_a:
  00079	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	48 83 c0 04	 add	 rax, 4
  00086	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 04	 cmp	 eax, 4
  00094	74 0c		 je	 SHORT $LN12@s390_set_a
  00096	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN12@s390_set_a:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 d1		 jne	 SHORT $LN4@s390_set_a

; 435  : 
; 436  :     TXF_INSTR_CHECK( regs );
; 437  :     PRIV_CHECK(regs);

  000a8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000b1	83 e0 01	 and	 eax, 1
  000b4	85 c0		 test	 eax, eax
  000b6	74 15		 je	 SHORT $LN13@s390_set_a
  000b8	ba 02 00 00 00	 mov	 edx, 2
  000bd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s390_set_a:
$LN7@s390_set_a:

; 438  :     SIE_INTERCEPT(regs);

  000cd	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d8	d1 e8		 shr	 eax, 1
  000da	83 e0 01	 and	 eax, 1
  000dd	85 c0		 test	 eax, eax
  000df	74 18		 je	 SHORT $LN14@s390_set_a
  000e1	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e6	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000ec	ba fc ff ff ff	 mov	 edx, -4
  000f1	48 8b c8	 mov	 rcx, rax
  000f4	e8 00 00 00 00	 call	 longjmp
$LN14@s390_set_a:
  000f9	33 c0		 xor	 eax, eax
  000fb	85 c0		 test	 eax, eax
  000fd	75 ce		 jne	 SHORT $LN7@s390_set_a
$LN10@s390_set_a:

; 439  : 
; 440  :     PTIO(IO,"SAL");

  000ff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00106	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00109	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0010f	48 85 c0	 test	 rax, rax
  00112	74 57		 je	 SHORT $LN15@s390_set_a
  00114	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00119	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0011f	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00123	ba 08 00 00 00	 mov	 edx, 8
  00128	48 6b d2 01	 imul	 rdx, rdx, 1
  0012c	4c 8b 44 24 68	 mov	 r8, QWORD PTR regs$[rsp]
  00131	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00139	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00142	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00147	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180769
  0014e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00153	44 8b c9	 mov	 r9d, ecx
  00156	44 8b c2	 mov	 r8d, edx
  00159	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180770
  00160	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN15@s390_set_a:
  0016b	33 c0		 xor	 eax, eax
  0016d	85 c0		 test	 eax, eax
  0016f	75 8e		 jne	 SHORT $LN10@s390_set_a

; 441  : 
; 442  :     if(regs->GR_L(1) & 0x8000FFFF)

  00171	b8 08 00 00 00	 mov	 eax, 8
  00176	48 6b c0 01	 imul	 rax, rax, 1
  0017a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00186	25 ff ff 00 80	 and	 eax, -2147418113	; 8000ffffH
  0018b	85 c0		 test	 eax, eax
  0018d	74 11		 je	 SHORT $LN16@s390_set_a

; 443  :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  0018f	ba 15 00 00 00	 mov	 edx, 21
  00194	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00199	e8 00 00 00 00	 call	 s390_program_interrupt
  0019e	eb 23		 jmp	 SHORT $LN17@s390_set_a
$LN16@s390_set_a:

; 444  :     else
; 445  :         sysblk.addrlimval = regs->GR_L(1);

  001a0	b8 08 00 00 00	 mov	 eax, 8
  001a5	48 6b c0 01	 imul	 rax, rax, 1
  001a9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ae	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001bc	48 89 81 60 12
	00 00		 mov	 QWORD PTR [rcx+4704], rax
$LN17@s390_set_a:
$LN18@s390_set_a:

; 446  : }

  001c3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c7	c3		 ret	 0
s390_set_address_limit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
temp$1 = 68
b2$ = 72
tv275 = 76
dev$ = 80
inst$ = 112
regs$ = 120
s390_resume_subchannel PROC

; 372  : {

$LN48:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 373  : int     b2;                             /* Effective addr base       */
; 374  : VADR    effective_addr2;                /* Effective address         */
; 375  : DEVBLK* dev;                            /* -> device block           */
; 376  : 
; 377  :     S( inst, regs, b2, effective_addr2 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 34		 je	 SHORT $LN29@s390_resum
  00045	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0006d	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00071	23 c8		 and	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN29@s390_resum:
$LN4@s390_resum:
  00079	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	48 83 c0 04	 add	 rax, 4
  00086	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 04	 cmp	 eax, 4
  00094	74 0c		 je	 SHORT $LN30@s390_resum
  00096	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN30@s390_resum:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 d1		 jne	 SHORT $LN4@s390_resum

; 378  : 
; 379  :     TXF_INSTR_CHECK( regs );
; 380  :     PRIV_CHECK( regs );

  000a8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000b1	83 e0 01	 and	 eax, 1
  000b4	85 c0		 test	 eax, eax
  000b6	74 15		 je	 SHORT $LN31@s390_resum
  000b8	ba 02 00 00 00	 mov	 edx, 2
  000bd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN31@s390_resum:
$LN7@s390_resum:

; 381  : 
; 382  :     PTIO( IO, "RSCH" );

  000cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000d4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d7	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  000dd	48 85 c0	 test	 rax, rax
  000e0	74 57		 je	 SHORT $LN32@s390_resum
  000e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  000ed	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000f1	ba 08 00 00 00	 mov	 edx, 8
  000f6	48 6b d2 01	 imul	 rdx, rdx, 1
  000fa	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  000ff	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00107	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00110	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00115	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180713
  0011c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00121	44 8b c9	 mov	 r9d, ecx
  00124	44 8b c2	 mov	 r8d, edx
  00127	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180714
  0012e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN32@s390_resum:
  00139	33 c0		 xor	 eax, eax
  0013b	85 c0		 test	 eax, eax
  0013d	75 8e		 jne	 SHORT $LN7@s390_resum

; 383  : 
; 384  : #if defined( _FEATURE_IO_ASSIST )
; 385  :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  0013f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00144	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0014a	d1 e8		 shr	 eax, 1
  0014c	83 e0 01	 and	 eax, 1
  0014f	85 c0		 test	 eax, eax
  00151	0f 84 e2 00 00
	00		 je	 $LN33@s390_resum
  00157	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00163	b9 01 00 00 00	 mov	 ecx, 1
  00168	48 6b c9 00	 imul	 rcx, rcx, 0
  0016c	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00171	83 e0 04	 and	 eax, 4
  00174	85 c0		 test	 eax, eax
  00176	0f 85 bd 00 00
	00		 jne	 $LN33@s390_resum
  0017c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00181	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00187	c1 e8 02	 shr	 eax, 2
  0018a	83 e0 01	 and	 eax, 1
  0018d	85 c0		 test	 eax, eax
  0018f	0f 85 a4 00 00
	00		 jne	 $LN33@s390_resum
$LN10@s390_resum:

; 386  : #endif
; 387  :     {
; 388  :         PTIO( IO, "RSCH (sie)" );

  00195	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0019c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0019f	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001a5	48 85 c0	 test	 rax, rax
  001a8	74 57		 je	 SHORT $LN34@s390_resum
  001aa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001af	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001b5	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001b9	ba 08 00 00 00	 mov	 edx, 8
  001be	48 6b d2 01	 imul	 rdx, rdx, 1
  001c2	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001c7	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001cf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001d8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180717
  001e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e9	44 8b c9	 mov	 r9d, ecx
  001ec	44 8b c2	 mov	 r8d, edx
  001ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180718
  001f6	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN34@s390_resum:
  00201	33 c0		 xor	 eax, eax
  00203	85 c0		 test	 eax, eax
  00205	75 8e		 jne	 SHORT $LN10@s390_resum
$LN13@s390_resum:

; 389  :         SIE_INTERCEPT( regs );

  00207	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00212	d1 e8		 shr	 eax, 1
  00214	83 e0 01	 and	 eax, 1
  00217	85 c0		 test	 eax, eax
  00219	74 18		 je	 SHORT $LN35@s390_resum
  0021b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00220	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00226	ba fc ff ff ff	 mov	 edx, -4
  0022b	48 8b c8	 mov	 rcx, rax
  0022e	e8 00 00 00 00	 call	 longjmp
$LN35@s390_resum:
  00233	33 c0		 xor	 eax, eax
  00235	85 c0		 test	 eax, eax
  00237	75 ce		 jne	 SHORT $LN13@s390_resum
$LN33@s390_resum:

; 390  :     }
; 391  : 
; 392  :     /* Program check if the ssid including lcss is invalid */
; 393  :     SSID_CHECK( regs );

  00239	b8 08 00 00 00	 mov	 eax, 8
  0023e	48 6b c0 01	 imul	 rax, rax, 1
  00242	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00247	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  0024f	83 e0 01	 and	 eax, 1
  00252	85 c0		 test	 eax, eax
  00254	74 1b		 je	 SHORT $LN37@s390_resum
  00256	b8 08 00 00 00	 mov	 eax, 8
  0025b	48 6b c0 01	 imul	 rax, rax, 1
  0025f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00264	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  0026c	83 f8 03	 cmp	 eax, 3
  0026f	7e 15		 jle	 SHORT $LN36@s390_resum
$LN37@s390_resum:
  00271	ba 15 00 00 00	 mov	 edx, 21
  00276	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0027b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00280	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN36@s390_resum:

; 394  : 
; 395  :     /* Locate the device block for this subchannel */
; 396  :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  00286	b8 08 00 00 00	 mov	 eax, 8
  0028b	48 6b c0 01	 imul	 rax, rax, 1
  0028f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00294	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  0029b	e8 00 00 00 00	 call	 find_device_by_subchan
  002a0	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax

; 397  : 
; 398  :     if (dev)

  002a5	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002ab	74 5a		 je	 SHORT $LN38@s390_resum
$LN16@s390_resum:

; 399  :         PTT( PTT_CL_IO, "RSCH (dev)", dev->devnum, 0, 0 );

  002ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002b4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002b7	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  002bd	48 85 c0	 test	 rax, rax
  002c0	74 3f		 je	 SHORT $LN39@s390_resum
  002c2	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002c7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002cb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002d4	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  002dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180724
  002e4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002e9	45 33 c9	 xor	 r9d, r9d
  002ec	44 8b c0	 mov	 r8d, eax
  002ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180725
  002f6	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@s390_resum:
  00301	33 c0		 xor	 eax, eax
  00303	85 c0		 test	 eax, eax
  00305	75 a6		 jne	 SHORT $LN16@s390_resum
$LN38@s390_resum:

; 400  : 
; 401  :     /* Condition code 3 if subchannel does not exist,
; 402  :        is not valid, or is not enabled */
; 403  :     if (0
; 404  :         || !dev
; 405  :         || !(dev->pmcw.flag5 & PMCW5_V)
; 406  :         || !(dev->pmcw.flag5 & PMCW5_E)

  00307	33 c0		 xor	 eax, eax
  00309	85 c0		 test	 eax, eax
  0030b	75 34		 jne	 SHORT $LN41@s390_resum
  0030d	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00313	74 2c		 je	 SHORT $LN41@s390_resum
  00315	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0031a	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00321	83 e0 01	 and	 eax, 1
  00324	85 c0		 test	 eax, eax
  00326	74 19		 je	 SHORT $LN41@s390_resum
  00328	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0032d	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00334	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00339	85 c0		 test	 eax, eax
  0033b	0f 85 20 01 00
	00		 jne	 $LN40@s390_resum
$LN41@s390_resum:
$LN19@s390_resum:

; 407  :     )
; 408  :     {
; 409  :         PTIO( ERR, "*RSCH" );

  00341	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00348	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0034b	48 83 e0 10	 and	 rax, 16
  0034f	48 85 c0	 test	 rax, rax
  00352	74 57		 je	 SHORT $LN42@s390_resum
  00354	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00359	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0035f	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00363	ba 08 00 00 00	 mov	 edx, 8
  00368	48 6b d2 01	 imul	 rdx, rdx, 1
  0036c	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00371	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00379	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00382	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00387	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180729
  0038e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00393	44 8b c9	 mov	 r9d, ecx
  00396	44 8b c2	 mov	 r8d, edx
  00399	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180730
  003a0	b9 10 00 00 00	 mov	 ecx, 16
  003a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN42@s390_resum:
  003ab	33 c0		 xor	 eax, eax
  003ad	85 c0		 test	 eax, eax
  003af	75 90		 jne	 SHORT $LN19@s390_resum
$LN22@s390_resum:

; 410  : #if defined( _FEATURE_IO_ASSIST )
; 411  :         PTIO( ERR, "*RSCH (sie)" );

  003b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003bb	48 83 e0 10	 and	 rax, 16
  003bf	48 85 c0	 test	 rax, rax
  003c2	74 57		 je	 SHORT $LN43@s390_resum
  003c4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003c9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003cf	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  003d3	ba 08 00 00 00	 mov	 edx, 8
  003d8	48 6b d2 01	 imul	 rdx, rdx, 1
  003dc	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  003e1	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  003e9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003f2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180732
  003fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00403	44 8b c9	 mov	 r9d, ecx
  00406	44 8b c2	 mov	 r8d, edx
  00409	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180733
  00410	b9 10 00 00 00	 mov	 ecx, 16
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN43@s390_resum:
  0041b	33 c0		 xor	 eax, eax
  0041d	85 c0		 test	 eax, eax
  0041f	75 90		 jne	 SHORT $LN22@s390_resum
$LN25@s390_resum:

; 412  :         SIE_INTERCEPT( regs );

  00421	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00426	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0042c	d1 e8		 shr	 eax, 1
  0042e	83 e0 01	 and	 eax, 1
  00431	85 c0		 test	 eax, eax
  00433	74 18		 je	 SHORT $LN44@s390_resum
  00435	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0043a	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00440	ba fc ff ff ff	 mov	 edx, -4
  00445	48 8b c8	 mov	 rcx, rax
  00448	e8 00 00 00 00	 call	 longjmp
$LN44@s390_resum:
  0044d	33 c0		 xor	 eax, eax
  0044f	85 c0		 test	 eax, eax
  00451	75 ce		 jne	 SHORT $LN25@s390_resum

; 413  : #endif
; 414  :         regs->psw.cc = 3;

  00453	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00458	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 415  :         return;

  0045c	e9 b1 00 00 00	 jmp	 $LN1@s390_resum
$LN40@s390_resum:

; 416  :     }
; 417  : 
; 418  :     /* Perform resume subchannel and set condition code */
; 419  :     if ((regs->psw.cc = resume_subchan( regs, dev )) != 0)

  00461	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00466	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0046b	e8 00 00 00 00	 call	 resume_subchan
  00470	89 44 24 4c	 mov	 DWORD PTR tv275[rsp], eax
  00474	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00479	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR tv275[rsp]
  0047e	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00481	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv275[rsp]
  00486	85 c0		 test	 eax, eax
  00488	74 70		 je	 SHORT $LN45@s390_resum
$LN28@s390_resum:

; 420  :         PTIO( ERR, "*RSCH" );

  0048a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00491	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00494	48 83 e0 10	 and	 rax, 16
  00498	48 85 c0	 test	 rax, rax
  0049b	74 57		 je	 SHORT $LN46@s390_resum
  0049d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004a2	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  004a8	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  004ac	ba 08 00 00 00	 mov	 edx, 8
  004b1	48 6b d2 01	 imul	 rdx, rdx, 1
  004b5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  004ba	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  004c2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004cb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180737
  004d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004dc	44 8b c9	 mov	 r9d, ecx
  004df	44 8b c2	 mov	 r8d, edx
  004e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180738
  004e9	b9 10 00 00 00	 mov	 ecx, 16
  004ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN46@s390_resum:
  004f4	33 c0		 xor	 eax, eax
  004f6	85 c0		 test	 eax, eax
  004f8	75 90		 jne	 SHORT $LN28@s390_resum
$LN45@s390_resum:

; 421  : 
; 422  :     regs->siocount++;

  004fa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004ff	8b 80 a0 07 00
	00		 mov	 eax, DWORD PTR [rax+1952]
  00505	ff c0		 inc	 eax
  00507	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0050c	89 81 a0 07 00
	00		 mov	 DWORD PTR [rcx+1952], eax
$LN1@s390_resum:
$LN47@s390_resum:

; 423  : }

  00512	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00516	c3		 ret	 0
s390_resume_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
dev$ = 64
effective_addr2$ = 72
b2$ = 76
mso$1 = 80
temp$2 = 88
msl$3 = 96
tv647 = 104
pmcw$ = 112
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s390_modify_subchannel PROC

; 182  : {

$LN58:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 183  : int     b2;                             /* Effective addr base       */
; 184  : VADR    effective_addr2;                /* Effective address         */
; 185  : DEVBLK* dev;                            /* -> device block           */
; 186  : PMCW    pmcw;                           /* Path management ctl word  */
; 187  : 
; 188  :     S( inst, regs, b2, effective_addr2 );

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 58	 mov	 DWORD PTR temp$2[rsp], eax
  0003b	8b 44 24 58	 mov	 eax, DWORD PTR temp$2[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00048	8b 44 24 58	 mov	 eax, DWORD PTR temp$2[rsp]
  0004c	c1 e8 0c	 shr	 eax, 12
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 4c	 mov	 DWORD PTR b2$[rsp], eax
  00056	83 7c 24 4c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005b	74 3a		 je	 SHORT $LN32@s390_modif
  0005d	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00062	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00071	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00075	03 c8		 add	 ecx, eax
  00077	8b c1		 mov	 eax, ecx
  00079	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0007d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00085	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0008b	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0008f	23 c8		 and	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN32@s390_modif:
$LN4@s390_modif:
  00097	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000a3	48 83 c0 04	 add	 rax, 4
  000a7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000af	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000b3	33 c0		 xor	 eax, eax
  000b5	83 f8 04	 cmp	 eax, 4
  000b8	74 0f		 je	 SHORT $LN33@s390_modif
  000ba	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c2	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN33@s390_modif:
  000c9	33 c0		 xor	 eax, eax
  000cb	85 c0		 test	 eax, eax
  000cd	75 c8		 jne	 SHORT $LN4@s390_modif

; 189  :     PER_ZEROADDR_XCHECK( regs, b2 );
; 190  : 
; 191  :     TXF_INSTR_CHECK( regs );
; 192  :     PRIV_CHECK( regs );

  000cf	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000db	83 e0 01	 and	 eax, 1
  000de	85 c0		 test	 eax, eax
  000e0	74 1b		 je	 SHORT $LN34@s390_modif
  000e2	ba 02 00 00 00	 mov	 edx, 2
  000e7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN34@s390_modif:
$LN7@s390_modif:

; 193  : 
; 194  :     PTIO( IO, "MSCH" );

  000fd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00104	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00107	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0010d	48 85 c0	 test	 rax, rax
  00110	74 5d		 je	 SHORT $LN35@s390_modif
  00112	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00120	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00124	ba 08 00 00 00	 mov	 edx, 8
  00129	48 6b d2 01	 imul	 rdx, rdx, 1
  0012d	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00135	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0013d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00146	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0014b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180544
  00152	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00157	44 8b c9	 mov	 r9d, ecx
  0015a	44 8b c2	 mov	 r8d, edx
  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180545
  00164	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN35@s390_modif:
  0016f	33 c0		 xor	 eax, eax
  00171	85 c0		 test	 eax, eax
  00173	75 88		 jne	 SHORT $LN7@s390_modif
$LN10@s390_modif:

; 195  : 
; 196  :     PTIO( IO, "MSCH (sie)" );

  00175	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0017c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017f	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00185	48 85 c0	 test	 rax, rax
  00188	74 5d		 je	 SHORT $LN36@s390_modif
  0018a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00192	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00198	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0019c	ba 08 00 00 00	 mov	 edx, 8
  001a1	48 6b d2 01	 imul	 rdx, rdx, 1
  001a5	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001ad	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001b5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001be	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180547
  001ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001cf	44 8b c9	 mov	 r9d, ecx
  001d2	44 8b c2	 mov	 r8d, edx
  001d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180548
  001dc	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@s390_modif:
  001e7	33 c0		 xor	 eax, eax
  001e9	85 c0		 test	 eax, eax
  001eb	75 88		 jne	 SHORT $LN10@s390_modif
$LN13@s390_modif:

; 197  :     SIE_INTERCEPT( regs );

  001ed	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001fb	d1 e8		 shr	 eax, 1
  001fd	83 e0 01	 and	 eax, 1
  00200	85 c0		 test	 eax, eax
  00202	74 1b		 je	 SHORT $LN37@s390_modif
  00204	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00212	ba fc ff ff ff	 mov	 edx, -4
  00217	48 8b c8	 mov	 rcx, rax
  0021a	e8 00 00 00 00	 call	 longjmp
$LN37@s390_modif:
  0021f	33 c0		 xor	 eax, eax
  00221	85 c0		 test	 eax, eax
  00223	75 c8		 jne	 SHORT $LN13@s390_modif

; 198  : 
; 199  :     FW_CHECK( effective_addr2, regs );

  00225	8b 44 24 48	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00229	83 e0 03	 and	 eax, 3
  0022c	85 c0		 test	 eax, eax
  0022e	74 1b		 je	 SHORT $LN38@s390_modif
  00230	ba 06 00 00 00	 mov	 edx, 6
  00235	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00245	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN38@s390_modif:

; 200  : 
; 201  :     /* Fetch the updated path management control word */
; 202  :     ARCH_DEP( vfetchc )( &pmcw, sizeof(PMCW)-1, effective_addr2, b2, regs );

  0024b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00253	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00258	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR b2$[rsp]
  0025d	44 8b 44 24 48	 mov	 r8d, DWORD PTR effective_addr2$[rsp]
  00262	b2 1b		 mov	 dl, 27
  00264	48 8d 4c 24 70	 lea	 rcx, QWORD PTR pmcw$[rsp]
  00269	e8 00 00 00 00	 call	 s390_vfetchc

; 203  : 
; 204  :     /* Program check if reserved bits are not zero */
; 205  :     if (0
; 206  :         || (pmcw.flag4 & PMCW4_RESV)
; 207  :         || (pmcw.flag5 & PMCW5_LM) == PMCW5_LM_RESV
; 208  : #if !defined( _FEATURE_IO_ASSIST )
; 209  :         || (pmcw.flag4 & PMCW4_A)
; 210  :         || (pmcw.zone != 0)
; 211  :         || (pmcw.flag25 & PMCW25_VISC)
; 212  :         || (pmcw.flag27 & PMCW27_I)
; 213  : #endif
; 214  :         || (pmcw.flag26 != 0)
; 215  :         || (pmcw.flag27 & PMCW27_RESV)

  0026e	33 c0		 xor	 eax, eax
  00270	85 c0		 test	 eax, eax
  00272	75 34		 jne	 SHORT $LN40@s390_modif
  00274	0f b6 44 24 74	 movzx	 eax, BYTE PTR pmcw$[rsp+4]
  00279	83 e0 46	 and	 eax, 70			; 00000046H
  0027c	85 c0		 test	 eax, eax
  0027e	75 28		 jne	 SHORT $LN40@s390_modif
  00280	0f b6 44 24 75	 movzx	 eax, BYTE PTR pmcw$[rsp+5]
  00285	83 e0 60	 and	 eax, 96			; 00000060H
  00288	83 f8 60	 cmp	 eax, 96			; 00000060H
  0028b	74 1b		 je	 SHORT $LN40@s390_modif
  0028d	0f b6 84 24 8a
	00 00 00	 movzx	 eax, BYTE PTR pmcw$[rsp+26]
  00295	85 c0		 test	 eax, eax
  00297	75 0f		 jne	 SHORT $LN40@s390_modif
  00299	0f b6 84 24 8b
	00 00 00	 movzx	 eax, BYTE PTR pmcw$[rsp+27]
  002a1	83 e0 7e	 and	 eax, 126		; 0000007eH
  002a4	85 c0		 test	 eax, eax
  002a6	74 12		 je	 SHORT $LN39@s390_modif
$LN40@s390_modif:

; 216  :     )
; 217  :         ARCH_DEP( program_interrupt )( regs, PGM_OPERAND_EXCEPTION );

  002a8	ba 15 00 00 00	 mov	 edx, 21
  002ad	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b5	e8 00 00 00 00	 call	 s390_program_interrupt
$LN39@s390_modif:

; 218  : 
; 219  :     /* Program check if the ssid including lcss is invalid */
; 220  :     SSID_CHECK( regs );

  002ba	b8 08 00 00 00	 mov	 eax, 8
  002bf	48 6b c0 01	 imul	 rax, rax, 1
  002c3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cb	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002d3	83 e0 01	 and	 eax, 1
  002d6	85 c0		 test	 eax, eax
  002d8	74 1e		 je	 SHORT $LN42@s390_modif
  002da	b8 08 00 00 00	 mov	 eax, 8
  002df	48 6b c0 01	 imul	 rax, rax, 1
  002e3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002eb	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  002f3	83 f8 03	 cmp	 eax, 3
  002f6	7e 1b		 jle	 SHORT $LN41@s390_modif
$LN42@s390_modif:
  002f8	ba 15 00 00 00	 mov	 edx, 21
  002fd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00305	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN41@s390_modif:

; 221  : 
; 222  :     /* Locate the device block for this subchannel */
; 223  :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  00313	b8 08 00 00 00	 mov	 eax, 8
  00318	48 6b c0 01	 imul	 rax, rax, 1
  0031c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00324	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  0032b	e8 00 00 00 00	 call	 find_device_by_subchan
  00330	48 89 44 24 40	 mov	 QWORD PTR dev$[rsp], rax

; 224  : 
; 225  :     if (dev)

  00335	48 83 7c 24 40
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0033b	74 5a		 je	 SHORT $LN43@s390_modif
$LN16@s390_modif:

; 226  :         PTT( PTT_CL_IO, "MSCH (dev)", dev->devnum, 0, 0 );

  0033d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00344	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00347	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0034d	48 85 c0	 test	 rax, rax
  00350	74 3f		 je	 SHORT $LN44@s390_modif
  00352	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00357	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0035b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00364	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0036d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180557
  00374	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00379	45 33 c9	 xor	 r9d, r9d
  0037c	44 8b c0	 mov	 r8d, eax
  0037f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180558
  00386	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0038b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN44@s390_modif:
  00391	33 c0		 xor	 eax, eax
  00393	85 c0		 test	 eax, eax
  00395	75 a6		 jne	 SHORT $LN16@s390_modif
$LN43@s390_modif:

; 227  : 
; 228  :     /* Condition code 3 if subchannel does not exist */
; 229  :     if (!dev)

  00397	48 83 7c 24 40
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0039d	0f 85 87 00 00
	00		 jne	 $LN45@s390_modif
$LN19@s390_modif:

; 230  :     {
; 231  :         PTIO( ERR, "*MSCH" );

  003a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003aa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003ad	48 83 e0 10	 and	 rax, 16
  003b1	48 85 c0	 test	 rax, rax
  003b4	74 5d		 je	 SHORT $LN46@s390_modif
  003b6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003be	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003c4	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  003c8	ba 08 00 00 00	 mov	 edx, 8
  003cd	48 6b d2 01	 imul	 rdx, rdx, 1
  003d1	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003d9	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  003e1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003ea	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180561
  003f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003fb	44 8b c9	 mov	 r9d, ecx
  003fe	44 8b c2	 mov	 r8d, edx
  00401	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180562
  00408	b9 10 00 00 00	 mov	 ecx, 16
  0040d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN46@s390_modif:
  00413	33 c0		 xor	 eax, eax
  00415	85 c0		 test	 eax, eax
  00417	75 8a		 jne	 SHORT $LN19@s390_modif

; 232  :         regs->psw.cc = 3;

  00419	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00421	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 233  :         return;

  00425	e9 61 05 00 00	 jmp	 $LN1@s390_modif
$LN45@s390_modif:

; 234  :     }
; 235  : 
; 236  :     /* If the subchannel is invalid then return cc0 */
; 237  :     if (!(dev->pmcw.flag5 & PMCW5_V))

  0042a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0042f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00436	83 e0 01	 and	 eax, 1
  00439	85 c0		 test	 eax, eax
  0043b	0f 85 87 00 00
	00		 jne	 $LN47@s390_modif
$LN22@s390_modif:

; 238  :     {
; 239  :         PTIO( ERR, "*MSCH" );

  00441	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00448	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0044b	48 83 e0 10	 and	 rax, 16
  0044f	48 85 c0	 test	 rax, rax
  00452	74 5d		 je	 SHORT $LN48@s390_modif
  00454	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045c	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00462	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00466	ba 08 00 00 00	 mov	 edx, 8
  0046b	48 6b d2 01	 imul	 rdx, rdx, 1
  0046f	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00477	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0047f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00488	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0048d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180565
  00494	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00499	44 8b c9	 mov	 r9d, ecx
  0049c	44 8b c2	 mov	 r8d, edx
  0049f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180566
  004a6	b9 10 00 00 00	 mov	 ecx, 16
  004ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN48@s390_modif:
  004b1	33 c0		 xor	 eax, eax
  004b3	85 c0		 test	 eax, eax
  004b5	75 8a		 jne	 SHORT $LN22@s390_modif

; 240  :         regs->psw.cc = 0;

  004b7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004bf	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 241  :         return;

  004c3	e9 c3 04 00 00	 jmp	 $LN1@s390_modif
$LN47@s390_modif:

; 242  :     }
; 243  : 
; 244  :     /* Perform serialization and checkpoint-synchronization */
; 245  :     PERFORM_SERIALIZATION( regs );

  004c8	0f ae f0	 mfence
$LN25@s390_modif:

; 246  :     PERFORM_CHKPT_SYNC( regs );

  004cb	33 c0		 xor	 eax, eax
  004cd	85 c0		 test	 eax, eax
  004cf	75 fa		 jne	 SHORT $LN25@s390_modif

; 247  : 
; 248  :     /* Obtain the device lock */
; 249  :     obtain_lock( &dev->lock );

  004d1	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  004d6	48 83 c0 38	 add	 rax, 56			; 00000038H
  004da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180567
  004e1	48 8b c8	 mov	 rcx, rax
  004e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 250  :     {
; 251  :         /* Condition code 1 if subchannel is status pending
; 252  :            with other than intermediate status */
; 253  :         if (1
; 254  :             &&  (dev->scsw.flag3 & SCSW3_SC_PEND)
; 255  :             && !(dev->scsw.flag3 & SCSW3_SC_INTER)

  004ea	33 c0		 xor	 eax, eax
  004ec	83 f8 01	 cmp	 eax, 1
  004ef	0f 84 ce 00 00
	00		 je	 $LN49@s390_modif
  004f5	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  004fa	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00501	83 e0 01	 and	 eax, 1
  00504	85 c0		 test	 eax, eax
  00506	0f 84 b7 00 00
	00		 je	 $LN49@s390_modif
  0050c	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00511	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00518	83 e0 08	 and	 eax, 8
  0051b	85 c0		 test	 eax, eax
  0051d	0f 85 a0 00 00
	00		 jne	 $LN49@s390_modif
$LN28@s390_modif:

; 256  :         )
; 257  :         {
; 258  :             PTIO( ERR, "*MSCH" );

  00523	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0052a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0052d	48 83 e0 10	 and	 rax, 16
  00531	48 85 c0	 test	 rax, rax
  00534	74 5d		 je	 SHORT $LN50@s390_modif
  00536	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0053e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00544	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00548	ba 08 00 00 00	 mov	 edx, 8
  0054d	48 6b d2 01	 imul	 rdx, rdx, 1
  00551	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00559	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00561	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0056a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0056f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180570
  00576	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0057b	44 8b c9	 mov	 r9d, ecx
  0057e	44 8b c2	 mov	 r8d, edx
  00581	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180571
  00588	b9 10 00 00 00	 mov	 ecx, 16
  0058d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN50@s390_modif:
  00593	33 c0		 xor	 eax, eax
  00595	85 c0		 test	 eax, eax
  00597	75 8a		 jne	 SHORT $LN28@s390_modif

; 259  :             regs->psw.cc = 1;

  00599	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a1	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 260  :             release_lock( &dev->lock );

  005a5	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  005aa	48 83 c0 38	 add	 rax, 56			; 00000038H
  005ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180572
  005b5	48 8b c8	 mov	 rcx, rax
  005b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 261  :             return;

  005be	e9 c8 03 00 00	 jmp	 $LN1@s390_modif
$LN49@s390_modif:

; 262  :         }
; 263  : 
; 264  :         /* Condition code 2 if subchannel is busy */
; 265  :         if (dev->busy || IOPENDING( dev ))

  005c3	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  005c8	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005ce	c1 e8 13	 shr	 eax, 19
  005d1	83 e0 01	 and	 eax, 1
  005d4	85 c0		 test	 eax, eax
  005d6	75 58		 jne	 SHORT $LN52@s390_modif
  005d8	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  005dd	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005e3	c1 e8 16	 shr	 eax, 22
  005e6	83 e0 01	 and	 eax, 1
  005e9	85 c0		 test	 eax, eax
  005eb	75 43		 jne	 SHORT $LN53@s390_modif
  005ed	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  005f2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005f8	c1 e8 17	 shr	 eax, 23
  005fb	83 e0 01	 and	 eax, 1
  005fe	85 c0		 test	 eax, eax
  00600	75 2e		 jne	 SHORT $LN53@s390_modif
  00602	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00607	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0060d	c1 e8 18	 shr	 eax, 24
  00610	83 e0 01	 and	 eax, 1
  00613	85 c0		 test	 eax, eax
  00615	75 19		 jne	 SHORT $LN53@s390_modif
  00617	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0061c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00622	c1 e8 1b	 shr	 eax, 27
  00625	83 e0 01	 and	 eax, 1
  00628	85 c0		 test	 eax, eax
  0062a	0f 84 a0 00 00
	00		 je	 $LN51@s390_modif
$LN53@s390_modif:
$LN52@s390_modif:
$LN31@s390_modif:

; 266  :         {
; 267  :             PTIO( ERR, "*MSCH" );

  00630	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00637	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0063a	48 83 e0 10	 and	 rax, 16
  0063e	48 85 c0	 test	 rax, rax
  00641	74 5d		 je	 SHORT $LN54@s390_modif
  00643	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0064b	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00651	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00655	ba 08 00 00 00	 mov	 edx, 8
  0065a	48 6b d2 01	 imul	 rdx, rdx, 1
  0065e	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00666	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0066e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00677	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0067c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180577
  00683	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00688	44 8b c9	 mov	 r9d, ecx
  0068b	44 8b c2	 mov	 r8d, edx
  0068e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180578
  00695	b9 10 00 00 00	 mov	 ecx, 16
  0069a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN54@s390_modif:
  006a0	33 c0		 xor	 eax, eax
  006a2	85 c0		 test	 eax, eax
  006a4	75 8a		 jne	 SHORT $LN31@s390_modif

; 268  :             regs->psw.cc = 2;

  006a6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ae	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 269  :             release_lock( &dev->lock );

  006b2	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  006b7	48 83 c0 38	 add	 rax, 56			; 00000038H
  006bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180579
  006c2	48 8b c8	 mov	 rcx, rax
  006c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 270  :             return;

  006cb	e9 bb 02 00 00	 jmp	 $LN1@s390_modif
$LN51@s390_modif:

; 271  :         }
; 272  : 
; 273  :         /* Update the enabled (E), limit mode (LM), and
; 274  :            measurement mode (MM), and multipath (D) bits */
; 275  :         dev->pmcw.flag5 &=              ~(PMCW5_E | PMCW5_LM | PMCW5_MM | PMCW5_D);

  006d0	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  006d5	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  006dc	25 03 ff ff ff	 and	 eax, -253		; ffffffffffffff03H
  006e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  006e6	88 81 f1 02 00
	00		 mov	 BYTE PTR [rcx+753], al

; 276  :         dev->pmcw.flag5 |= (pmcw.flag5 & (PMCW5_E | PMCW5_LM | PMCW5_MM | PMCW5_D));

  006ec	0f b6 44 24 75	 movzx	 eax, BYTE PTR pmcw$[rsp+5]
  006f1	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  006f6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  006fb	0f b6 89 f1 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+753]
  00702	0b c8		 or	 ecx, eax
  00704	8b c1		 mov	 eax, ecx
  00706	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0070b	88 81 f1 02 00
	00		 mov	 BYTE PTR [rcx+753], al

; 277  : 
; 278  :         /* Update the measurement block index */
; 279  :         memcpy( dev->pmcw.mbi, pmcw.mbi, sizeof( HWORD ));

  00711	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00716	0f b7 4c 24 7c	 movzx	 ecx, WORD PTR pmcw$[rsp+12]
  0071b	66 89 88 f8 02
	00 00		 mov	 WORD PTR [rax+760], cx

; 280  : 
; 281  :         /* Update the interruption parameter */
; 282  :         memcpy( dev->pmcw.intparm, pmcw.intparm, sizeof( FWORD ));

  00722	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00727	8b 4c 24 70	 mov	 ecx, DWORD PTR pmcw$[rsp]
  0072b	89 88 ec 02 00
	00		 mov	 DWORD PTR [rax+748], ecx

; 283  : 
; 284  :         /* Update the ISC and A fields */
; 285  :         dev->pmcw.flag4 &=              ~(PMCW4_ISC | PMCW4_A);

  00731	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00736	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  0073d	83 e0 c6	 and	 eax, -58		; ffffffffffffffc6H
  00740	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00745	88 81 f0 02 00
	00		 mov	 BYTE PTR [rcx+752], al

; 286  :         dev->pmcw.flag4 |= (pmcw.flag4 & (PMCW4_ISC | PMCW4_A));

  0074b	0f b6 44 24 74	 movzx	 eax, BYTE PTR pmcw$[rsp+4]
  00750	83 e0 39	 and	 eax, 57			; 00000039H
  00753	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00758	0f b6 89 f0 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+752]
  0075f	0b c8		 or	 ecx, eax
  00761	8b c1		 mov	 eax, ecx
  00763	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00768	88 81 f0 02 00
	00		 mov	 BYTE PTR [rcx+752], al

; 287  : 
; 288  :         /* Update the path management (LPM and POM) fields */
; 289  :         dev->pmcw.lpm = pmcw.lpm;

  0076e	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00773	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR pmcw$[rsp+8]
  00778	88 88 f4 02 00
	00		 mov	 BYTE PTR [rax+756], cl

; 290  :         dev->pmcw.pom = pmcw.pom;

  0077e	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00783	0f b6 4c 24 7e	 movzx	 ecx, BYTE PTR pmcw$[rsp+14]
  00788	88 88 fa 02 00
	00		 mov	 BYTE PTR [rax+762], cl

; 291  : 
; 292  :         /* Update zone, VISC, I and S bit */
; 293  :         dev->pmcw.zone    =  pmcw.zone;

  0078e	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00793	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR pmcw$[rsp+24]
  0079b	88 88 04 03 00
	00		 mov	 BYTE PTR [rax+772], cl

; 294  :         dev->pmcw.flag25 &=              ~(PMCW25_VISC);

  007a1	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  007a6	0f b6 80 05 03
	00 00		 movzx	 eax, BYTE PTR [rax+773]
  007ad	83 e0 f8	 and	 eax, -8
  007b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  007b5	88 81 05 03 00
	00		 mov	 BYTE PTR [rcx+773], al

; 295  :         dev->pmcw.flag25 |= (pmcw.flag25 & PMCW25_VISC);

  007bb	0f b6 84 24 89
	00 00 00	 movzx	 eax, BYTE PTR pmcw$[rsp+25]
  007c3	83 e0 07	 and	 eax, 7
  007c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  007cb	0f b6 89 05 03
	00 00		 movzx	 ecx, BYTE PTR [rcx+773]
  007d2	0b c8		 or	 ecx, eax
  007d4	8b c1		 mov	 eax, ecx
  007d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  007db	88 81 05 03 00
	00		 mov	 BYTE PTR [rcx+773], al

; 296  :         dev->pmcw.flag26  =  pmcw.flag26;

  007e1	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  007e6	0f b6 8c 24 8a
	00 00 00	 movzx	 ecx, BYTE PTR pmcw$[rsp+26]
  007ee	88 88 06 03 00
	00		 mov	 BYTE PTR [rax+774], cl

; 297  :         dev->pmcw.flag27  =  pmcw.flag27;

  007f4	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  007f9	0f b6 8c 24 8b
	00 00 00	 movzx	 ecx, BYTE PTR pmcw$[rsp+27]
  00801	88 88 07 03 00
	00		 mov	 BYTE PTR [rax+775], cl

; 298  : 
; 299  : #if defined( _FEATURE_IO_ASSIST )
; 300  :         /* Relate the device storage view to the requested zone */
; 301  :         {
; 302  :             RADR  mso, msl;
; 303  : 
; 304  :             mso =  sysblk.zpb[ dev->pmcw.zone ].mso << 20;

  00807	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0080c	0f b6 80 04 03
	00 00		 movzx	 eax, BYTE PTR [rax+772]
  00813	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00817	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0081e	48 8b 84 01 a0
	0e 00 00	 mov	 rax, QWORD PTR [rcx+rax+3744]
  00826	48 c1 e0 14	 shl	 rax, 20
  0082a	48 89 44 24 50	 mov	 QWORD PTR mso$1[rsp], rax

; 305  :             msl = (sysblk.zpb[ dev->pmcw.zone ].msl << 20) | 0xFFFFF;

  0082f	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00834	0f b6 80 04 03
	00 00		 movzx	 eax, BYTE PTR [rax+772]
  0083b	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0083f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00846	48 8b 84 01 a8
	0e 00 00	 mov	 rax, QWORD PTR [rcx+rax+3752]
  0084e	48 c1 e0 14	 shl	 rax, 20
  00852	48 0d ff ff 0f
	00		 or	 rax, 1048575		; 000fffffH
  00858	48 89 44 24 60	 mov	 QWORD PTR msl$3[rsp], rax

; 306  : 
; 307  :             /* Ensure channel program checks on incorrect zone defs */
; 308  :             if (0
; 309  :                 || mso > (sysblk.mainsize - 1)
; 310  :                 || msl > (sysblk.mainsize - 1)
; 311  :                 || mso > msl

  0085d	33 c0		 xor	 eax, eax
  0085f	85 c0		 test	 eax, eax
  00861	75 3c		 jne	 SHORT $LN56@s390_modif
  00863	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0086a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00871	48 ff c8	 dec	 rax
  00874	48 39 44 24 50	 cmp	 QWORD PTR mso$1[rsp], rax
  00879	77 24		 ja	 SHORT $LN56@s390_modif
  0087b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00882	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00889	48 ff c8	 dec	 rax
  0088c	48 39 44 24 60	 cmp	 QWORD PTR msl$3[rsp], rax
  00891	77 0c		 ja	 SHORT $LN56@s390_modif
  00893	48 8b 44 24 60	 mov	 rax, QWORD PTR msl$3[rsp]
  00898	48 39 44 24 50	 cmp	 QWORD PTR mso$1[rsp], rax
  0089d	76 13		 jbe	 SHORT $LN55@s390_modif
$LN56@s390_modif:

; 312  :             )
; 313  :                 mso = msl = 0;

  0089f	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR msl$3[rsp], 0
  008a8	48 8b 44 24 60	 mov	 rax, QWORD PTR msl$3[rsp]
  008ad	48 89 44 24 50	 mov	 QWORD PTR mso$1[rsp], rax
$LN55@s390_modif:

; 314  : 
; 315  :             dev->mainstor = &(sysblk.mainstor[ mso ]);

  008b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008b9	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  008c0	48 03 44 24 50	 add	 rax, QWORD PTR mso$1[rsp]
  008c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  008ca	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 316  :             dev->mainlim  = msl - mso;

  008d1	48 8b 44 24 50	 mov	 rax, QWORD PTR mso$1[rsp]
  008d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR msl$3[rsp]
  008db	48 2b c8	 sub	 rcx, rax
  008de	48 8b c1	 mov	 rax, rcx
  008e1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  008e6	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 317  :             dev->storkeys = ARCH_DEP( get_ptr_to_storekey )( mso );

  008ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mso$1[rsp]
  008f2	e8 00 00 00 00	 call	 s390_get_ptr_to_storekey
  008f7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  008fc	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 318  :         }
; 319  : #endif
; 320  : 
; 321  :         /* Set device priority from the interruption subclass bits.
; 322  :          * Note: PMCW priorities range from 0 to 7 with 0 having a higher
; 323  :          *       priority than 7. Consequently, we'll set the device
; 324  :          *       priority bits accordingly.
; 325  :          */
; 326  :         dev->priority &= 0xFF00FFFFULL;

  00903	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00908	48 63 80 18 02
	00 00		 movsxd	 rax, DWORD PTR [rax+536]
  0090f	b9 ff ff 00 ff	 mov	 ecx, -16711681		; ff00ffffH
  00914	48 23 c1	 and	 rax, rcx
  00917	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0091c	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 327  :         dev->priority |= 0x00800000ULL >> ((dev->pmcw.flag4 & PMCW4_ISC) >> 3);

  00922	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00927	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  0092e	83 e0 38	 and	 eax, 56			; 00000038H
  00931	c1 f8 03	 sar	 eax, 3
  00934	b9 00 00 80 00	 mov	 ecx, 8388608		; 00800000H
  00939	48 89 4c 24 68	 mov	 QWORD PTR tv647[rsp], rcx
  0093e	0f b6 c8	 movzx	 ecx, al
  00941	48 8b 44 24 68	 mov	 rax, QWORD PTR tv647[rsp]
  00946	48 d3 e8	 shr	 rax, cl
  00949	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0094e	48 63 89 18 02
	00 00		 movsxd	 rcx, DWORD PTR [rcx+536]
  00955	48 0b c8	 or	 rcx, rax
  00958	48 8b c1	 mov	 rax, rcx
  0095b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00960	89 81 18 02 00
	00		 mov	 DWORD PTR [rcx+536], eax

; 328  : 
; 329  :     }
; 330  :     release_lock( &dev->lock );

  00966	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0096b	48 83 c0 38	 add	 rax, 56			; 00000038H
  0096f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180582
  00976	48 8b c8	 mov	 rcx, rax
  00979	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 331  : 
; 332  :     /* Set condition code 0 */
; 333  :     regs->psw.cc = 0;

  0097f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00987	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s390_modif:
$LN57@s390_modif:

; 334  : }

  0098b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00993	48 33 cc	 xor	 rcx, rsp
  00996	e8 00 00 00 00	 call	 __security_check_cookie
  0099b	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  009a2	c3		 ret	 0
s390_modify_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
temp$1 = 68
b2$ = 72
tv275 = 76
dev$ = 80
inst$ = 112
regs$ = 120
s390_halt_subchannel PROC

; 126  : {

$LN48:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 127  : int     b2;                             /* Effective addr base       */
; 128  : VADR    effective_addr2;                /* Effective address         */
; 129  : DEVBLK* dev;                            /* -> device block           */
; 130  : 
; 131  :     S( inst, regs, b2, effective_addr2 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 34		 je	 SHORT $LN29@s390_halt_
  00045	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0006d	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00071	23 c8		 and	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN29@s390_halt_:
$LN4@s390_halt_:
  00079	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	48 83 c0 04	 add	 rax, 4
  00086	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 04	 cmp	 eax, 4
  00094	74 0c		 je	 SHORT $LN30@s390_halt_
  00096	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN30@s390_halt_:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 d1		 jne	 SHORT $LN4@s390_halt_

; 132  : 
; 133  :     TXF_INSTR_CHECK( regs );
; 134  :     PRIV_CHECK( regs );

  000a8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000b1	83 e0 01	 and	 eax, 1
  000b4	85 c0		 test	 eax, eax
  000b6	74 15		 je	 SHORT $LN31@s390_halt_
  000b8	ba 02 00 00 00	 mov	 edx, 2
  000bd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN31@s390_halt_:
$LN7@s390_halt_:

; 135  : 
; 136  :     PTIO( IO, "HSCH" );

  000cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000d4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d7	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  000dd	48 85 c0	 test	 rax, rax
  000e0	74 57		 je	 SHORT $LN32@s390_halt_
  000e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  000ed	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000f1	ba 08 00 00 00	 mov	 edx, 8
  000f6	48 6b d2 01	 imul	 rdx, rdx, 1
  000fa	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  000ff	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00107	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00110	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00115	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180420
  0011c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00121	44 8b c9	 mov	 r9d, ecx
  00124	44 8b c2	 mov	 r8d, edx
  00127	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180421
  0012e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN32@s390_halt_:
  00139	33 c0		 xor	 eax, eax
  0013b	85 c0		 test	 eax, eax
  0013d	75 8e		 jne	 SHORT $LN7@s390_halt_

; 137  : 
; 138  : #if defined( _FEATURE_IO_ASSIST )
; 139  :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  0013f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00144	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0014a	d1 e8		 shr	 eax, 1
  0014c	83 e0 01	 and	 eax, 1
  0014f	85 c0		 test	 eax, eax
  00151	0f 84 e2 00 00
	00		 je	 $LN33@s390_halt_
  00157	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00163	b9 01 00 00 00	 mov	 ecx, 1
  00168	48 6b c9 00	 imul	 rcx, rcx, 0
  0016c	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00171	83 e0 04	 and	 eax, 4
  00174	85 c0		 test	 eax, eax
  00176	0f 85 bd 00 00
	00		 jne	 $LN33@s390_halt_
  0017c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00181	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00187	c1 e8 02	 shr	 eax, 2
  0018a	83 e0 01	 and	 eax, 1
  0018d	85 c0		 test	 eax, eax
  0018f	0f 85 a4 00 00
	00		 jne	 $LN33@s390_halt_
$LN10@s390_halt_:

; 140  : #endif
; 141  :     {
; 142  :         PTIO( IO, "HSCH (sie)" );

  00195	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0019c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0019f	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001a5	48 85 c0	 test	 rax, rax
  001a8	74 57		 je	 SHORT $LN34@s390_halt_
  001aa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001af	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001b5	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001b9	ba 08 00 00 00	 mov	 edx, 8
  001be	48 6b d2 01	 imul	 rdx, rdx, 1
  001c2	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001c7	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001cf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001d8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180424
  001e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e9	44 8b c9	 mov	 r9d, ecx
  001ec	44 8b c2	 mov	 r8d, edx
  001ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180425
  001f6	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN34@s390_halt_:
  00201	33 c0		 xor	 eax, eax
  00203	85 c0		 test	 eax, eax
  00205	75 8e		 jne	 SHORT $LN10@s390_halt_
$LN13@s390_halt_:

; 143  :         SIE_INTERCEPT( regs );

  00207	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00212	d1 e8		 shr	 eax, 1
  00214	83 e0 01	 and	 eax, 1
  00217	85 c0		 test	 eax, eax
  00219	74 18		 je	 SHORT $LN35@s390_halt_
  0021b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00220	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00226	ba fc ff ff ff	 mov	 edx, -4
  0022b	48 8b c8	 mov	 rcx, rax
  0022e	e8 00 00 00 00	 call	 longjmp
$LN35@s390_halt_:
  00233	33 c0		 xor	 eax, eax
  00235	85 c0		 test	 eax, eax
  00237	75 ce		 jne	 SHORT $LN13@s390_halt_
$LN33@s390_halt_:

; 144  :     }
; 145  : 
; 146  :     /* Program check if the ssid including lcss is invalid */
; 147  :     SSID_CHECK( regs );

  00239	b8 08 00 00 00	 mov	 eax, 8
  0023e	48 6b c0 01	 imul	 rax, rax, 1
  00242	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00247	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  0024f	83 e0 01	 and	 eax, 1
  00252	85 c0		 test	 eax, eax
  00254	74 1b		 je	 SHORT $LN37@s390_halt_
  00256	b8 08 00 00 00	 mov	 eax, 8
  0025b	48 6b c0 01	 imul	 rax, rax, 1
  0025f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00264	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  0026c	83 f8 03	 cmp	 eax, 3
  0026f	7e 15		 jle	 SHORT $LN36@s390_halt_
$LN37@s390_halt_:
  00271	ba 15 00 00 00	 mov	 edx, 21
  00276	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0027b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00280	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN36@s390_halt_:

; 148  : 
; 149  :     /* Locate the device block for this subchannel */
; 150  :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  00286	b8 08 00 00 00	 mov	 eax, 8
  0028b	48 6b c0 01	 imul	 rax, rax, 1
  0028f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00294	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  0029b	e8 00 00 00 00	 call	 find_device_by_subchan
  002a0	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax

; 151  : 
; 152  :     if (dev)

  002a5	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002ab	74 5a		 je	 SHORT $LN38@s390_halt_
$LN16@s390_halt_:

; 153  :         PTT( PTT_CL_IO, "HSCH (dev)", dev->devnum, 0, 0 );

  002ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002b4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002b7	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  002bd	48 85 c0	 test	 rax, rax
  002c0	74 3f		 je	 SHORT $LN39@s390_halt_
  002c2	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002c7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002cb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002d4	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  002dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180431
  002e4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002e9	45 33 c9	 xor	 r9d, r9d
  002ec	44 8b c0	 mov	 r8d, eax
  002ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180432
  002f6	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@s390_halt_:
  00301	33 c0		 xor	 eax, eax
  00303	85 c0		 test	 eax, eax
  00305	75 a6		 jne	 SHORT $LN16@s390_halt_
$LN38@s390_halt_:

; 154  : 
; 155  :     /* Condition code 3 if subchannel does not exist,
; 156  :        is not valid, or is not enabled */
; 157  :     if (0
; 158  :         || !dev
; 159  :         || !(dev->pmcw.flag5 & PMCW5_V)
; 160  :         || !(dev->pmcw.flag5 & PMCW5_E)

  00307	33 c0		 xor	 eax, eax
  00309	85 c0		 test	 eax, eax
  0030b	75 34		 jne	 SHORT $LN41@s390_halt_
  0030d	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00313	74 2c		 je	 SHORT $LN41@s390_halt_
  00315	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0031a	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00321	83 e0 01	 and	 eax, 1
  00324	85 c0		 test	 eax, eax
  00326	74 19		 je	 SHORT $LN41@s390_halt_
  00328	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0032d	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00334	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00339	85 c0		 test	 eax, eax
  0033b	0f 85 20 01 00
	00		 jne	 $LN40@s390_halt_
$LN41@s390_halt_:
$LN19@s390_halt_:

; 161  :     )
; 162  :     {
; 163  :         PTIO( ERR, "*HSCH" );

  00341	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00348	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0034b	48 83 e0 10	 and	 rax, 16
  0034f	48 85 c0	 test	 rax, rax
  00352	74 57		 je	 SHORT $LN42@s390_halt_
  00354	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00359	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0035f	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00363	ba 08 00 00 00	 mov	 edx, 8
  00368	48 6b d2 01	 imul	 rdx, rdx, 1
  0036c	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00371	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00379	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00382	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00387	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180436
  0038e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00393	44 8b c9	 mov	 r9d, ecx
  00396	44 8b c2	 mov	 r8d, edx
  00399	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180437
  003a0	b9 10 00 00 00	 mov	 ecx, 16
  003a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN42@s390_halt_:
  003ab	33 c0		 xor	 eax, eax
  003ad	85 c0		 test	 eax, eax
  003af	75 90		 jne	 SHORT $LN19@s390_halt_
$LN22@s390_halt_:

; 164  : #if defined( _FEATURE_IO_ASSIST )
; 165  :         PTIO( ERR, "*HSCH (sie)" );

  003b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003bb	48 83 e0 10	 and	 rax, 16
  003bf	48 85 c0	 test	 rax, rax
  003c2	74 57		 je	 SHORT $LN43@s390_halt_
  003c4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003c9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003cf	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  003d3	ba 08 00 00 00	 mov	 edx, 8
  003d8	48 6b d2 01	 imul	 rdx, rdx, 1
  003dc	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  003e1	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  003e9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003f2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180439
  003fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00403	44 8b c9	 mov	 r9d, ecx
  00406	44 8b c2	 mov	 r8d, edx
  00409	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180440
  00410	b9 10 00 00 00	 mov	 ecx, 16
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN43@s390_halt_:
  0041b	33 c0		 xor	 eax, eax
  0041d	85 c0		 test	 eax, eax
  0041f	75 90		 jne	 SHORT $LN22@s390_halt_
$LN25@s390_halt_:

; 166  :         SIE_INTERCEPT( regs );

  00421	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00426	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0042c	d1 e8		 shr	 eax, 1
  0042e	83 e0 01	 and	 eax, 1
  00431	85 c0		 test	 eax, eax
  00433	74 18		 je	 SHORT $LN44@s390_halt_
  00435	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0043a	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00440	ba fc ff ff ff	 mov	 edx, -4
  00445	48 8b c8	 mov	 rcx, rax
  00448	e8 00 00 00 00	 call	 longjmp
$LN44@s390_halt_:
  0044d	33 c0		 xor	 eax, eax
  0044f	85 c0		 test	 eax, eax
  00451	75 ce		 jne	 SHORT $LN25@s390_halt_

; 167  : #endif
; 168  :         regs->psw.cc = 3;

  00453	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00458	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 169  :         return;

  0045c	e9 99 00 00 00	 jmp	 $LN1@s390_halt_
$LN40@s390_halt_:

; 170  :     }
; 171  : 
; 172  :     /* Perform halt subchannel and set condition code */
; 173  :     if ((regs->psw.cc = halt_subchan( regs, dev )) != 0)

  00461	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00466	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0046b	e8 00 00 00 00	 call	 halt_subchan
  00470	89 44 24 4c	 mov	 DWORD PTR tv275[rsp], eax
  00474	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00479	0f b6 4c 24 4c	 movzx	 ecx, BYTE PTR tv275[rsp]
  0047e	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  00481	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv275[rsp]
  00486	85 c0		 test	 eax, eax
  00488	74 70		 je	 SHORT $LN45@s390_halt_
$LN28@s390_halt_:

; 174  :         PTIO( ERR, "*HSCH" );

  0048a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00491	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00494	48 83 e0 10	 and	 rax, 16
  00498	48 85 c0	 test	 rax, rax
  0049b	74 57		 je	 SHORT $LN46@s390_halt_
  0049d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004a2	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  004a8	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  004ac	ba 08 00 00 00	 mov	 edx, 8
  004b1	48 6b d2 01	 imul	 rdx, rdx, 1
  004b5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  004ba	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  004c2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004cb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180444
  004d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004dc	44 8b c9	 mov	 r9d, ecx
  004df	44 8b c2	 mov	 r8d, edx
  004e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180445
  004e9	b9 10 00 00 00	 mov	 ecx, 16
  004ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN46@s390_halt_:
  004f4	33 c0		 xor	 eax, eax
  004f6	85 c0		 test	 eax, eax
  004f8	75 90		 jne	 SHORT $LN28@s390_halt_
$LN45@s390_halt_:
$LN1@s390_halt_:
$LN47@s390_halt_:

; 175  : }

  004fa	48 83 c4 68	 add	 rsp, 104		; 00000068H
  004fe	c3		 ret	 0
s390_halt_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
temp$1 = 68
b2$ = 72
dev$ = 80
inst$ = 112
regs$ = 120
s390_clear_subchannel PROC

; 69   : {

$LN43:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 70   : int     b2;                             /* Effective addr base       */
; 71   : VADR    effective_addr2;                /* Effective address         */
; 72   : DEVBLK* dev;                            /* -> device block           */
; 73   : 
; 74   :     S( inst, regs, b2, effective_addr2 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 34		 je	 SHORT $LN26@s390_clear
  00045	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0006d	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00071	23 c8		 and	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN26@s390_clear:
$LN4@s390_clear:
  00079	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	48 83 c0 04	 add	 rax, 4
  00086	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 04	 cmp	 eax, 4
  00094	74 0c		 je	 SHORT $LN27@s390_clear
  00096	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN27@s390_clear:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 d1		 jne	 SHORT $LN4@s390_clear

; 75   : 
; 76   :     TXF_INSTR_CHECK( regs );
; 77   :     PRIV_CHECK( regs );

  000a8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000b1	83 e0 01	 and	 eax, 1
  000b4	85 c0		 test	 eax, eax
  000b6	74 15		 je	 SHORT $LN28@s390_clear
  000b8	ba 02 00 00 00	 mov	 edx, 2
  000bd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN28@s390_clear:
$LN7@s390_clear:

; 78   : 
; 79   :     PTIO( IO, "CSCH" );

  000cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000d4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d7	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  000dd	48 85 c0	 test	 rax, rax
  000e0	74 57		 je	 SHORT $LN29@s390_clear
  000e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  000ed	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000f1	ba 08 00 00 00	 mov	 edx, 8
  000f6	48 6b d2 01	 imul	 rdx, rdx, 1
  000fa	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  000ff	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00107	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00110	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00115	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180316
  0011c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00121	44 8b c9	 mov	 r9d, ecx
  00124	44 8b c2	 mov	 r8d, edx
  00127	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180317
  0012e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@s390_clear:
  00139	33 c0		 xor	 eax, eax
  0013b	85 c0		 test	 eax, eax
  0013d	75 8e		 jne	 SHORT $LN7@s390_clear

; 80   : 
; 81   : #if defined( _FEATURE_IO_ASSIST )
; 82   :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  0013f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00144	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0014a	d1 e8		 shr	 eax, 1
  0014c	83 e0 01	 and	 eax, 1
  0014f	85 c0		 test	 eax, eax
  00151	0f 84 e2 00 00
	00		 je	 $LN30@s390_clear
  00157	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00163	b9 01 00 00 00	 mov	 ecx, 1
  00168	48 6b c9 00	 imul	 rcx, rcx, 0
  0016c	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00171	83 e0 04	 and	 eax, 4
  00174	85 c0		 test	 eax, eax
  00176	0f 85 bd 00 00
	00		 jne	 $LN30@s390_clear
  0017c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00181	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00187	c1 e8 02	 shr	 eax, 2
  0018a	83 e0 01	 and	 eax, 1
  0018d	85 c0		 test	 eax, eax
  0018f	0f 85 a4 00 00
	00		 jne	 $LN30@s390_clear
$LN10@s390_clear:

; 83   : #endif
; 84   :     {
; 85   :         PTIO( IO, "CSCH (sie)" );

  00195	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0019c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0019f	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001a5	48 85 c0	 test	 rax, rax
  001a8	74 57		 je	 SHORT $LN31@s390_clear
  001aa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001af	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001b5	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001b9	ba 08 00 00 00	 mov	 edx, 8
  001be	48 6b d2 01	 imul	 rdx, rdx, 1
  001c2	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001c7	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001cf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001d8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180320
  001e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e9	44 8b c9	 mov	 r9d, ecx
  001ec	44 8b c2	 mov	 r8d, edx
  001ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180321
  001f6	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN31@s390_clear:
  00201	33 c0		 xor	 eax, eax
  00203	85 c0		 test	 eax, eax
  00205	75 8e		 jne	 SHORT $LN10@s390_clear
$LN13@s390_clear:

; 86   :         SIE_INTERCEPT( regs );

  00207	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00212	d1 e8		 shr	 eax, 1
  00214	83 e0 01	 and	 eax, 1
  00217	85 c0		 test	 eax, eax
  00219	74 18		 je	 SHORT $LN32@s390_clear
  0021b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00220	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00226	ba fc ff ff ff	 mov	 edx, -4
  0022b	48 8b c8	 mov	 rcx, rax
  0022e	e8 00 00 00 00	 call	 longjmp
$LN32@s390_clear:
  00233	33 c0		 xor	 eax, eax
  00235	85 c0		 test	 eax, eax
  00237	75 ce		 jne	 SHORT $LN13@s390_clear
$LN30@s390_clear:

; 87   :     }
; 88   : 
; 89   :     /* Program check if the ssid including lcss is invalid */
; 90   :     SSID_CHECK( regs );

  00239	b8 08 00 00 00	 mov	 eax, 8
  0023e	48 6b c0 01	 imul	 rax, rax, 1
  00242	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00247	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  0024f	83 e0 01	 and	 eax, 1
  00252	85 c0		 test	 eax, eax
  00254	74 1b		 je	 SHORT $LN34@s390_clear
  00256	b8 08 00 00 00	 mov	 eax, 8
  0025b	48 6b c0 01	 imul	 rax, rax, 1
  0025f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00264	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  0026c	83 f8 03	 cmp	 eax, 3
  0026f	7e 15		 jle	 SHORT $LN33@s390_clear
$LN34@s390_clear:
  00271	ba 15 00 00 00	 mov	 edx, 21
  00276	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0027b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00280	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN33@s390_clear:

; 91   : 
; 92   :     /* Locate the device block for this subchannel */
; 93   :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  00286	b8 08 00 00 00	 mov	 eax, 8
  0028b	48 6b c0 01	 imul	 rax, rax, 1
  0028f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00294	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  0029b	e8 00 00 00 00	 call	 find_device_by_subchan
  002a0	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax

; 94   : 
; 95   :     if (dev)

  002a5	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002ab	74 5a		 je	 SHORT $LN35@s390_clear
$LN16@s390_clear:

; 96   :         PTT( PTT_CL_IO, "CSCH (dev)", dev->devnum, 0, 0 );

  002ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002b4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002b7	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  002bd	48 85 c0	 test	 rax, rax
  002c0	74 3f		 je	 SHORT $LN36@s390_clear
  002c2	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002c7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002cb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002d4	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  002dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180327
  002e4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002e9	45 33 c9	 xor	 r9d, r9d
  002ec	44 8b c0	 mov	 r8d, eax
  002ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180328
  002f6	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@s390_clear:
  00301	33 c0		 xor	 eax, eax
  00303	85 c0		 test	 eax, eax
  00305	75 a6		 jne	 SHORT $LN16@s390_clear
$LN35@s390_clear:

; 97   : 
; 98   :     /* Condition code 3 if subchannel does not exist,
; 99   :        is not valid, or is not enabled */
; 100  :     if (0
; 101  :         || !dev
; 102  :         || !(dev->pmcw.flag5 & PMCW5_V)
; 103  :         || !(dev->pmcw.flag5 & PMCW5_E)

  00307	33 c0		 xor	 eax, eax
  00309	85 c0		 test	 eax, eax
  0030b	75 34		 jne	 SHORT $LN38@s390_clear
  0030d	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00313	74 2c		 je	 SHORT $LN38@s390_clear
  00315	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0031a	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00321	83 e0 01	 and	 eax, 1
  00324	85 c0		 test	 eax, eax
  00326	74 19		 je	 SHORT $LN38@s390_clear
  00328	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0032d	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00334	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00339	85 c0		 test	 eax, eax
  0033b	0f 85 1d 01 00
	00		 jne	 $LN37@s390_clear
$LN38@s390_clear:
$LN19@s390_clear:

; 104  :     )
; 105  :     {
; 106  :         PTIO( ERR, "*CSCH" );

  00341	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00348	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0034b	48 83 e0 10	 and	 rax, 16
  0034f	48 85 c0	 test	 rax, rax
  00352	74 57		 je	 SHORT $LN39@s390_clear
  00354	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00359	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0035f	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00363	ba 08 00 00 00	 mov	 edx, 8
  00368	48 6b d2 01	 imul	 rdx, rdx, 1
  0036c	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00371	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00379	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00382	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00387	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180332
  0038e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00393	44 8b c9	 mov	 r9d, ecx
  00396	44 8b c2	 mov	 r8d, edx
  00399	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180333
  003a0	b9 10 00 00 00	 mov	 ecx, 16
  003a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@s390_clear:
  003ab	33 c0		 xor	 eax, eax
  003ad	85 c0		 test	 eax, eax
  003af	75 90		 jne	 SHORT $LN19@s390_clear
$LN22@s390_clear:

; 107  : #if defined( _FEATURE_IO_ASSIST )
; 108  :         PTIO( ERR, "*CSCH (sie)" );

  003b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003bb	48 83 e0 10	 and	 rax, 16
  003bf	48 85 c0	 test	 rax, rax
  003c2	74 57		 je	 SHORT $LN40@s390_clear
  003c4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003c9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003cf	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  003d3	ba 08 00 00 00	 mov	 edx, 8
  003d8	48 6b d2 01	 imul	 rdx, rdx, 1
  003dc	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  003e1	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  003e9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003f2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180335
  003fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00403	44 8b c9	 mov	 r9d, ecx
  00406	44 8b c2	 mov	 r8d, edx
  00409	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180336
  00410	b9 10 00 00 00	 mov	 ecx, 16
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN40@s390_clear:
  0041b	33 c0		 xor	 eax, eax
  0041d	85 c0		 test	 eax, eax
  0041f	75 90		 jne	 SHORT $LN22@s390_clear
$LN25@s390_clear:

; 109  :         SIE_INTERCEPT( regs );

  00421	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00426	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0042c	d1 e8		 shr	 eax, 1
  0042e	83 e0 01	 and	 eax, 1
  00431	85 c0		 test	 eax, eax
  00433	74 18		 je	 SHORT $LN41@s390_clear
  00435	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0043a	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00440	ba fc ff ff ff	 mov	 edx, -4
  00445	48 8b c8	 mov	 rcx, rax
  00448	e8 00 00 00 00	 call	 longjmp
$LN41@s390_clear:
  0044d	33 c0		 xor	 eax, eax
  0044f	85 c0		 test	 eax, eax
  00451	75 ce		 jne	 SHORT $LN25@s390_clear

; 110  : #endif
; 111  :         regs->psw.cc = 3;

  00453	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00458	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 112  :         return;

  0045c	eb 18		 jmp	 SHORT $LN1@s390_clear
$LN37@s390_clear:

; 113  :     }
; 114  : 
; 115  :     /* Perform clear subchannel and set condition code zero */
; 116  :     clear_subchan( regs, dev );

  0045e	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00463	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00468	e8 00 00 00 00	 call	 clear_subchan

; 117  : 
; 118  :     regs->psw.cc = 0;

  0046d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00472	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s390_clear:
$LN42@s390_clear:

; 119  : }

  00476	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0047a	c3		 ret	 0
s390_clear_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
temp$1 = 68
b2$ = 72
dev$ = 80
inst$ = 112
regs$ = 120
s390_cancel_subchannel PROC

; 1006 : {

$LN48:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1007 : int     b2;                             /* Base of effective addr    */
; 1008 : VADR    effective_addr2;                /* Effective address         */
; 1009 : DEVBLK* dev;                            /* -> device block           */
; 1010 : 
; 1011 :     S( inst, regs, b2, effective_addr2 );

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 34		 je	 SHORT $LN29@s390_cance
  00045	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00067	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0006d	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00071	23 c8		 and	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN29@s390_cance:
$LN4@s390_cance:
  00079	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	48 83 c0 04	 add	 rax, 4
  00086	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 04	 cmp	 eax, 4
  00094	74 0c		 je	 SHORT $LN30@s390_cance
  00096	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN30@s390_cance:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 d1		 jne	 SHORT $LN4@s390_cance

; 1012 : 
; 1013 :     TXF_INSTR_CHECK( regs );
; 1014 :     PRIV_CHECK( regs );

  000a8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000b1	83 e0 01	 and	 eax, 1
  000b4	85 c0		 test	 eax, eax
  000b6	74 15		 je	 SHORT $LN31@s390_cance
  000b8	ba 02 00 00 00	 mov	 edx, 2
  000bd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN31@s390_cance:
$LN7@s390_cance:

; 1015 : 
; 1016 :     PTIO( IO, "XSCH" );

  000cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000d4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d7	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  000dd	48 85 c0	 test	 rax, rax
  000e0	74 57		 je	 SHORT $LN32@s390_cance
  000e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  000ed	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000f1	ba 08 00 00 00	 mov	 edx, 8
  000f6	48 6b d2 01	 imul	 rdx, rdx, 1
  000fa	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  000ff	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00107	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00110	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00115	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181413
  0011c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00121	44 8b c9	 mov	 r9d, ecx
  00124	44 8b c2	 mov	 r8d, edx
  00127	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181414
  0012e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN32@s390_cance:
  00139	33 c0		 xor	 eax, eax
  0013b	85 c0		 test	 eax, eax
  0013d	75 8e		 jne	 SHORT $LN7@s390_cance

; 1017 : 
; 1018 : #if defined( _FEATURE_IO_ASSIST )
; 1019 :     if (SIE_STATE_BIT_OFF( regs, EC0, IOA ) && !regs->sie_pref)

  0013f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00144	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0014a	d1 e8		 shr	 eax, 1
  0014c	83 e0 01	 and	 eax, 1
  0014f	85 c0		 test	 eax, eax
  00151	0f 84 e2 00 00
	00		 je	 $LN33@s390_cance
  00157	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00163	b9 01 00 00 00	 mov	 ecx, 1
  00168	48 6b c9 00	 imul	 rcx, rcx, 0
  0016c	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00171	83 e0 04	 and	 eax, 4
  00174	85 c0		 test	 eax, eax
  00176	0f 85 bd 00 00
	00		 jne	 $LN33@s390_cance
  0017c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00181	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00187	c1 e8 02	 shr	 eax, 2
  0018a	83 e0 01	 and	 eax, 1
  0018d	85 c0		 test	 eax, eax
  0018f	0f 85 a4 00 00
	00		 jne	 $LN33@s390_cance
$LN10@s390_cance:

; 1020 : #endif
; 1021 :     {
; 1022 :         PTIO( IO, "XSCH (sie)" );

  00195	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0019c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0019f	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001a5	48 85 c0	 test	 rax, rax
  001a8	74 57		 je	 SHORT $LN34@s390_cance
  001aa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001af	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001b5	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001b9	ba 08 00 00 00	 mov	 edx, 8
  001be	48 6b d2 01	 imul	 rdx, rdx, 1
  001c2	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001c7	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001cf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001d8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181417
  001e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e9	44 8b c9	 mov	 r9d, ecx
  001ec	44 8b c2	 mov	 r8d, edx
  001ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181418
  001f6	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN34@s390_cance:
  00201	33 c0		 xor	 eax, eax
  00203	85 c0		 test	 eax, eax
  00205	75 8e		 jne	 SHORT $LN10@s390_cance
$LN13@s390_cance:

; 1023 :         SIE_INTERCEPT( regs );

  00207	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00212	d1 e8		 shr	 eax, 1
  00214	83 e0 01	 and	 eax, 1
  00217	85 c0		 test	 eax, eax
  00219	74 18		 je	 SHORT $LN35@s390_cance
  0021b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00220	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00226	ba fc ff ff ff	 mov	 edx, -4
  0022b	48 8b c8	 mov	 rcx, rax
  0022e	e8 00 00 00 00	 call	 longjmp
$LN35@s390_cance:
  00233	33 c0		 xor	 eax, eax
  00235	85 c0		 test	 eax, eax
  00237	75 ce		 jne	 SHORT $LN13@s390_cance
$LN33@s390_cance:

; 1024 :     }
; 1025 : 
; 1026 :     /* Program check if the ssid including lcss is invalid */
; 1027 :     SSID_CHECK( regs );

  00239	b8 08 00 00 00	 mov	 eax, 8
  0023e	48 6b c0 01	 imul	 rax, rax, 1
  00242	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00247	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  0024f	83 e0 01	 and	 eax, 1
  00252	85 c0		 test	 eax, eax
  00254	74 1b		 je	 SHORT $LN37@s390_cance
  00256	b8 08 00 00 00	 mov	 eax, 8
  0025b	48 6b c0 01	 imul	 rax, rax, 1
  0025f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00264	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  0026c	83 f8 03	 cmp	 eax, 3
  0026f	7e 15		 jle	 SHORT $LN36@s390_cance
$LN37@s390_cance:
  00271	ba 15 00 00 00	 mov	 edx, 21
  00276	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0027b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00280	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN36@s390_cance:

; 1028 : 
; 1029 :     /* Locate the device block for this subchannel */
; 1030 :     dev = find_device_by_subchan( regs->GR_L( 1 ));

  00286	b8 08 00 00 00	 mov	 eax, 8
  0028b	48 6b c0 01	 imul	 rax, rax, 1
  0028f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00294	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  0029b	e8 00 00 00 00	 call	 find_device_by_subchan
  002a0	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax

; 1031 : 
; 1032 :     if (dev)

  002a5	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002ab	74 5a		 je	 SHORT $LN38@s390_cance
$LN16@s390_cance:

; 1033 :         PTT( PTT_CL_IO, "XSCH (dev)", dev->devnum, 0, 0 );

  002ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002b4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002b7	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  002bd	48 85 c0	 test	 rax, rax
  002c0	74 3f		 je	 SHORT $LN39@s390_cance
  002c2	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002c7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002cb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002d4	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  002dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181424
  002e4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002e9	45 33 c9	 xor	 r9d, r9d
  002ec	44 8b c0	 mov	 r8d, eax
  002ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181425
  002f6	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@s390_cance:
  00301	33 c0		 xor	 eax, eax
  00303	85 c0		 test	 eax, eax
  00305	75 a6		 jne	 SHORT $LN16@s390_cance
$LN38@s390_cance:

; 1034 : 
; 1035 :     /* Condition code 3 if subchannel does not exist,
; 1036 :        is not valid, or is not enabled */
; 1037 :     if (0
; 1038 :         || !dev
; 1039 :         || !(dev->pmcw.flag5 & PMCW5_V)
; 1040 :         || !(dev->pmcw.flag5 & PMCW5_E)

  00307	33 c0		 xor	 eax, eax
  00309	85 c0		 test	 eax, eax
  0030b	75 34		 jne	 SHORT $LN41@s390_cance
  0030d	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00313	74 2c		 je	 SHORT $LN41@s390_cance
  00315	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0031a	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00321	83 e0 01	 and	 eax, 1
  00324	85 c0		 test	 eax, eax
  00326	74 19		 je	 SHORT $LN41@s390_cance
  00328	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0032d	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00334	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00339	85 c0		 test	 eax, eax
  0033b	0f 85 20 01 00
	00		 jne	 $LN40@s390_cance
$LN41@s390_cance:
$LN19@s390_cance:

; 1041 :     )
; 1042 :     {
; 1043 :         PTIO( ERR, "*XSCH" );

  00341	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00348	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0034b	48 83 e0 10	 and	 rax, 16
  0034f	48 85 c0	 test	 rax, rax
  00352	74 57		 je	 SHORT $LN42@s390_cance
  00354	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00359	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0035f	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00363	ba 08 00 00 00	 mov	 edx, 8
  00368	48 6b d2 01	 imul	 rdx, rdx, 1
  0036c	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00371	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00379	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00382	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00387	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181429
  0038e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00393	44 8b c9	 mov	 r9d, ecx
  00396	44 8b c2	 mov	 r8d, edx
  00399	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181430
  003a0	b9 10 00 00 00	 mov	 ecx, 16
  003a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN42@s390_cance:
  003ab	33 c0		 xor	 eax, eax
  003ad	85 c0		 test	 eax, eax
  003af	75 90		 jne	 SHORT $LN19@s390_cance
$LN22@s390_cance:

; 1044 : #if defined( _FEATURE_IO_ASSIST )
; 1045 :         PTIO( ERR, "*XSCH (sie)" );

  003b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003bb	48 83 e0 10	 and	 rax, 16
  003bf	48 85 c0	 test	 rax, rax
  003c2	74 57		 je	 SHORT $LN43@s390_cance
  003c4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003c9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003cf	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  003d3	ba 08 00 00 00	 mov	 edx, 8
  003d8	48 6b d2 01	 imul	 rdx, rdx, 1
  003dc	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  003e1	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  003e9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003f2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181432
  003fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00403	44 8b c9	 mov	 r9d, ecx
  00406	44 8b c2	 mov	 r8d, edx
  00409	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181433
  00410	b9 10 00 00 00	 mov	 ecx, 16
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN43@s390_cance:
  0041b	33 c0		 xor	 eax, eax
  0041d	85 c0		 test	 eax, eax
  0041f	75 90		 jne	 SHORT $LN22@s390_cance
$LN25@s390_cance:

; 1046 :         SIE_INTERCEPT( regs );

  00421	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00426	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0042c	d1 e8		 shr	 eax, 1
  0042e	83 e0 01	 and	 eax, 1
  00431	85 c0		 test	 eax, eax
  00433	74 18		 je	 SHORT $LN44@s390_cance
  00435	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0043a	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00440	ba fc ff ff ff	 mov	 edx, -4
  00445	48 8b c8	 mov	 rcx, rax
  00448	e8 00 00 00 00	 call	 longjmp
$LN44@s390_cance:
  0044d	33 c0		 xor	 eax, eax
  0044f	85 c0		 test	 eax, eax
  00451	75 ce		 jne	 SHORT $LN25@s390_cance

; 1047 : #endif
; 1048 :         regs->psw.cc = 3;

  00453	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00458	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 1049 :         return;

  0045c	e9 94 00 00 00	 jmp	 $LN1@s390_cance
$LN40@s390_cance:

; 1050 :     }
; 1051 : 
; 1052 :     /* Perform cancel subchannel and set condition code */
; 1053 :     regs->psw.cc = cancel_subchan( regs, dev );

  00461	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00466	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0046b	e8 00 00 00 00	 call	 cancel_subchan
  00470	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00475	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1054 : 
; 1055 :     if (regs->psw.cc != 0)

  00478	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0047d	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00481	85 c0		 test	 eax, eax
  00483	74 70		 je	 SHORT $LN45@s390_cance
$LN28@s390_cance:

; 1056 :         PTIO( ERR, "*XSCH" );

  00485	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0048c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0048f	48 83 e0 10	 and	 rax, 16
  00493	48 85 c0	 test	 rax, rax
  00496	74 57		 je	 SHORT $LN46@s390_cance
  00498	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0049d	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  004a3	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  004a7	ba 08 00 00 00	 mov	 edx, 8
  004ac	48 6b d2 01	 imul	 rdx, rdx, 1
  004b0	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  004b5	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  004bd	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004c6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181437
  004d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004d7	44 8b c9	 mov	 r9d, ecx
  004da	44 8b c2	 mov	 r8d, edx
  004dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181438
  004e4	b9 10 00 00 00	 mov	 ecx, 16
  004e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN46@s390_cance:
  004ef	33 c0		 xor	 eax, eax
  004f1	85 c0		 test	 eax, eax
  004f3	75 90		 jne	 SHORT $LN28@s390_cance
$LN45@s390_cance:
$LN1@s390_cance:
$LN47@s390_cance:

; 1057 : }

  004f5	48 83 c4 68	 add	 rsp, 104		; 00000068H
  004f9	c3		 ret	 0
s390_cancel_subchannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
i$ = 32
current_waittod$ = 40
lru_regs$ = 48
current_regs$ = 56
lru_waittod$ = 64
mask$ = 96
location$ = 104
wakeup_cpu_mask PROC

; 275  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 276  :     REGS*  current_regs;
; 277  :     REGS*  lru_regs = NULL;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR lru_regs$[rsp], 0

; 278  :     TOD    current_waittod;
; 279  :     TOD    lru_waittod;
; 280  :     int    i;
; 281  : 
; 282  :     if (mask)

  00017	48 83 7c 24 60
	00		 cmp	 QWORD PTR mask$[rsp], 0
  0001d	0f 84 d3 00 00
	00		 je	 $LN5@wakeup_cpu

; 283  :     {
; 284  :         for (i=0; mask; mask >>= 1, ++i)

  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002b	eb 17		 jmp	 SHORT $LN4@wakeup_cpu
$LN2@wakeup_cpu:
  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR mask$[rsp]
  00032	48 d1 e8	 shr	 rax, 1
  00035	48 89 44 24 60	 mov	 QWORD PTR mask$[rsp], rax
  0003a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0003e	ff c0		 inc	 eax
  00040	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@wakeup_cpu:
  00044	48 83 7c 24 60
	00		 cmp	 QWORD PTR mask$[rsp], 0
  0004a	0f 84 97 00 00
	00		 je	 $LN3@wakeup_cpu

; 285  :         {
; 286  :             if (mask & 1)

  00050	48 8b 44 24 60	 mov	 rax, QWORD PTR mask$[rsp]
  00055	48 83 e0 01	 and	 rax, 1
  00059	48 85 c0	 test	 rax, rax
  0005c	0f 84 80 00 00
	00		 je	 $LN6@wakeup_cpu

; 287  :             {
; 288  :                 current_regs = sysblk.regs[i];

  00062	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00067	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0006e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00076	48 89 44 24 38	 mov	 QWORD PTR current_regs$[rsp], rax

; 289  :                 current_waittod = current_regs->waittod;

  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR current_regs$[rsp]
  00080	48 8b 80 b8 07
	00 00		 mov	 rax, QWORD PTR [rax+1976]
  00087	48 89 44 24 28	 mov	 QWORD PTR current_waittod$[rsp], rax

; 290  : 
; 291  :                 /* Select least recently used CPU
; 292  :                  *
; 293  :                  * The LRU CPU is chosen to keep the CPU threads active
; 294  :                  * and to distribute the I/O load across the available
; 295  :                  * CPUs.
; 296  :                  *
; 297  :                  * The current_waittod should never be zero; however,
; 298  :                  * we check it in case the cache from another processor
; 299  :                  * has not yet been written back to memory, which can
; 300  :                  * happen once the lock structure is updated for
; 301  :                  * individual CPU locks. (OBTAIN/RELEASE_INTLOCK(regs)
; 302  :                  * at present locks ALL CPUs, despite the specification
; 303  :                  * of regs.)
; 304  :                  */
; 305  :                 if (lru_regs == NULL ||

  0008c	48 83 7c 24 30
	00		 cmp	 QWORD PTR lru_regs$[rsp], 0
  00092	74 3a		 je	 SHORT $LN8@wakeup_cpu
  00094	48 83 7c 24 28
	00		 cmp	 QWORD PTR current_waittod$[rsp], 0
  0009a	76 46		 jbe	 SHORT $LN7@wakeup_cpu
  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR lru_waittod$[rsp]
  000a1	48 39 44 24 28	 cmp	 QWORD PTR current_waittod$[rsp], rax
  000a6	72 26		 jb	 SHORT $LN9@wakeup_cpu
  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR lru_waittod$[rsp]
  000ad	48 39 44 24 28	 cmp	 QWORD PTR current_waittod$[rsp], rax
  000b2	75 2e		 jne	 SHORT $LN7@wakeup_cpu
  000b4	48 8b 44 24 38	 mov	 rax, QWORD PTR current_regs$[rsp]
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lru_regs$[rsp]
  000be	48 8b 89 c0 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1984]
  000c5	48 39 88 c0 07
	00 00		 cmp	 QWORD PTR [rax+1984], rcx
  000cc	72 14		 jb	 SHORT $LN7@wakeup_cpu
$LN9@wakeup_cpu:
$LN8@wakeup_cpu:

; 306  :                     (current_waittod > 0 &&
; 307  :                      (current_waittod < lru_waittod ||
; 308  :                       (current_waittod == lru_waittod &&
; 309  :                        current_regs->waittime >= lru_regs->waittime))))
; 310  :                 {
; 311  :                     lru_regs = current_regs;

  000ce	48 8b 44 24 38	 mov	 rax, QWORD PTR current_regs$[rsp]
  000d3	48 89 44 24 30	 mov	 QWORD PTR lru_regs$[rsp], rax

; 312  :                     lru_waittod = current_waittod;

  000d8	48 8b 44 24 28	 mov	 rax, QWORD PTR current_waittod$[rsp]
  000dd	48 89 44 24 40	 mov	 QWORD PTR lru_waittod$[rsp], rax
$LN7@wakeup_cpu:
$LN6@wakeup_cpu:

; 313  :                 }
; 314  :             }
; 315  :         }

  000e2	e9 46 ff ff ff	 jmp	 $LN2@wakeup_cpu
$LN3@wakeup_cpu:

; 316  : 
; 317  :         /* Wake up the least recently used CPU */
; 318  :         wakeup_cpu( lru_regs, location );

  000e7	48 8b 54 24 68	 mov	 rdx, QWORD PTR location$[rsp]
  000ec	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lru_regs$[rsp]
  000f1	e8 00 00 00 00	 call	 wakeup_cpu
$LN5@wakeup_cpu:

; 319  :     }
; 320  : }

  000f6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000fa	c3		 ret	 0
wakeup_cpu_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
wakeup_cpu PROC

; 268  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  :     hthread_signal_condition( &regs->intcond, location );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 270  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
wakeup_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
temp$1 = 68
b2$ = 72
inst$ = 96
regs$ = 104
s370_store_channel_id PROC

; 1276 : {

$LN22:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1277 : int     b2;                             /* Base of effective addr    */
; 1278 : VADR    effective_addr2;                /* Effective address         */
; 1279 : 
; 1280 :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 2a		 je	 SHORT $LN14@s370_store
  00045	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00066	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0006b	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN14@s370_store:
$LN4@s370_store:
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00085	33 c0		 xor	 eax, eax
  00087	83 f8 04	 cmp	 eax, 4
  0008a	74 0c		 je	 SHORT $LN15@s370_store
  0008c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00091	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN15@s370_store:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 d1		 jne	 SHORT $LN4@s370_store

; 1281 : 
; 1282 :     TXF_INSTR_CHECK( regs );
; 1283 :     PRIV_CHECK(regs);

  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000a7	83 e0 01	 and	 eax, 1
  000aa	85 c0		 test	 eax, eax
  000ac	74 15		 je	 SHORT $LN16@s370_store
  000ae	ba 02 00 00 00	 mov	 edx, 2
  000b3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@s370_store:
$LN7@s370_store:

; 1284 :     SIE_INTERCEPT(regs);

  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000ce	d1 e8		 shr	 eax, 1
  000d0	83 e0 01	 and	 eax, 1
  000d3	85 c0		 test	 eax, eax
  000d5	74 18		 je	 SHORT $LN17@s370_store
  000d7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000e2	ba fc ff ff ff	 mov	 edx, -4
  000e7	48 8b c8	 mov	 rcx, rax
  000ea	e8 00 00 00 00	 call	 longjmp
$LN17@s370_store:
  000ef	33 c0		 xor	 eax, eax
  000f1	85 c0		 test	 eax, eax
  000f3	75 ce		 jne	 SHORT $LN7@s370_store
$LN10@s370_store:

; 1285 :     PTIO(IO,"STIDC");

  000f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000fc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ff	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00105	48 85 c0	 test	 rax, rax
  00108	74 41		 je	 SHORT $LN18@s370_store
  0010a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00115	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00119	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00122	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00127	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170071
  0012e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00133	45 33 c9	 xor	 r9d, r9d
  00136	44 8b c1	 mov	 r8d, ecx
  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170072
  00140	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@s370_store:
  0014b	33 c0		 xor	 eax, eax
  0014d	85 c0		 test	 eax, eax
  0014f	75 a4		 jne	 SHORT $LN10@s370_store

; 1286 : 
; 1287 :     /* Store Channel ID and set condition code */
; 1288 :     regs->psw.cc =

  00151	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00155	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0015a	0f b7 d0	 movzx	 edx, ax
  0015d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00162	e8 00 00 00 00	 call	 stchan_id
  00167	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1289 :         stchan_id (regs, effective_addr2 & 0xFF00);
; 1290 : 
; 1291 :     if (regs->psw.cc != 0)

  0016f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00174	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00178	85 c0		 test	 eax, eax
  0017a	74 5a		 je	 SHORT $LN19@s370_store
$LN13@s370_store:

; 1292 :         PTIO(ERR,"*STIDC");

  0017c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00183	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00186	48 83 e0 10	 and	 rax, 16
  0018a	48 85 c0	 test	 rax, rax
  0018d	74 41		 je	 SHORT $LN20@s370_store
  0018f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00194	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0019a	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0019e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001a7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170075
  001b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b8	45 33 c9	 xor	 r9d, r9d
  001bb	44 8b c1	 mov	 r8d, ecx
  001be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170076
  001c5	b9 10 00 00 00	 mov	 ecx, 16
  001ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN20@s370_store:
  001d0	33 c0		 xor	 eax, eax
  001d2	85 c0		 test	 eax, eax
  001d4	75 a6		 jne	 SHORT $LN13@s370_store
$LN19@s370_store:
$LN21@s370_store:

; 1293 : }

  001d6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001da	c3		 ret	 0
s370_store_channel_id ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
channelid$ = 64
tch_ctl$ = 68
effective_addr2$ = 72
temp$1 = 76
b2$ = 80
tv229 = 84
inst$ = 112
regs$ = 120
s370_test_channel PROC

; 1233 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1234 : int     b2;                             /* Base of effective addr    */
; 1235 : VADR    effective_addr2;                /* Effective address         */
; 1236 : #if defined(_FEATURE_SIE)
; 1237 : BYTE    channelid;
; 1238 : U16     tch_ctl;
; 1239 : #endif /*defined(_FEATURE_SIE)*/
; 1240 : 
; 1241 :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 4c	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 4c	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 2a		 je	 SHORT $LN11@s370_test_
  00045	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	8b 44 24 48	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00066	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0006b	89 44 24 48	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN11@s370_test_:
$LN4@s370_test_:
  0006f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00085	33 c0		 xor	 eax, eax
  00087	83 f8 04	 cmp	 eax, 4
  0008a	74 0c		 je	 SHORT $LN12@s370_test_
  0008c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00091	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN12@s370_test_:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 d1		 jne	 SHORT $LN4@s370_test_

; 1242 : 
; 1243 :     TXF_INSTR_CHECK( regs );
; 1244 :     PRIV_CHECK(regs);

  0009e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000a7	83 e0 01	 and	 eax, 1
  000aa	85 c0		 test	 eax, eax
  000ac	74 15		 je	 SHORT $LN13@s370_test_
  000ae	ba 02 00 00 00	 mov	 edx, 2
  000b3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s370_test_:
$LN7@s370_test_:

; 1245 :     PTIO(IO,"TCH");

  000c3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000ca	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000cd	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  000d3	48 85 c0	 test	 rax, rax
  000d6	74 41		 je	 SHORT $LN14@s370_test_
  000d8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  000e3	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000e7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000f0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170020
  000fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00101	45 33 c9	 xor	 r9d, r9d
  00104	44 8b c1	 mov	 r8d, ecx
  00107	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170021
  0010e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN14@s370_test_:
  00119	33 c0		 xor	 eax, eax
  0011b	85 c0		 test	 eax, eax
  0011d	75 a4		 jne	 SHORT $LN7@s370_test_

; 1246 : 
; 1247 : #if defined(_FEATURE_SIE)
; 1248 :     if(!SIE_MODE(regs))

  0011f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00124	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0012a	d1 e8		 shr	 eax, 1
  0012c	83 e0 01	 and	 eax, 1
  0012f	85 c0		 test	 eax, eax
  00131	75 23		 jne	 SHORT $LN15@s370_test_

; 1249 :     {
; 1250 : #endif /*defined(_FEATURE_SIE)*/
; 1251 :         /* Test for pending interrupt and set condition code */
; 1252 :         regs->psw.cc = testch (regs, effective_addr2 & 0xFF00);

  00133	8b 44 24 48	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00137	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0013c	0f b7 d0	 movzx	 edx, ax
  0013f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	e8 00 00 00 00	 call	 testch
  00149	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0014e	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1253 : #if defined(_FEATURE_SIE)
; 1254 :     }

  00151	e9 84 00 00 00	 jmp	 $LN16@s370_test_
$LN15@s370_test_:

; 1255 :     else
; 1256 :     {
; 1257 :         channelid = (effective_addr2 >> 8) & 0xFF;

  00156	8b 44 24 48	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0015a	c1 e8 08	 shr	 eax, 8
  0015d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00162	88 44 24 40	 mov	 BYTE PTR channelid$[rsp], al

; 1258 :         FETCH_HW(tch_ctl,((SIEBK*)(regs->siebk))->tch_ctl);

  00166	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00172	48 83 c0 70	 add	 rax, 112		; 00000070H
  00176	48 8b c8	 mov	 rcx, rax
  00179	e8 00 00 00 00	 call	 fetch_hw_noswap
  0017e	0f b7 c8	 movzx	 ecx, ax
  00181	e8 00 00 00 00	 call	 _byteswap_ushort
  00186	66 89 44 24 44	 mov	 WORD PTR tch_ctl$[rsp], ax

; 1259 :         if((channelid > 15)
; 1260 :          || ((0x8000 >> channelid) & tch_ctl))

  0018b	0f b6 44 24 40	 movzx	 eax, BYTE PTR channelid$[rsp]
  00190	83 f8 0f	 cmp	 eax, 15
  00193	7f 22		 jg	 SHORT $LN19@s370_test_
  00195	0f b6 44 24 40	 movzx	 eax, BYTE PTR channelid$[rsp]
  0019a	b9 00 80 00 00	 mov	 ecx, 32768		; 00008000H
  0019f	89 4c 24 54	 mov	 DWORD PTR tv229[rsp], ecx
  001a3	0f b6 c8	 movzx	 ecx, al
  001a6	8b 44 24 54	 mov	 eax, DWORD PTR tv229[rsp]
  001aa	d3 f8		 sar	 eax, cl
  001ac	0f b7 4c 24 44	 movzx	 ecx, WORD PTR tch_ctl$[rsp]
  001b1	23 c1		 and	 eax, ecx
  001b3	85 c0		 test	 eax, eax
  001b5	74 1a		 je	 SHORT $LN17@s370_test_
$LN19@s370_test_:

; 1261 :             longjmp(regs->progjmp, SIE_INTERCEPT_INST);

  001b7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  001c2	ba fc ff ff ff	 mov	 edx, -4
  001c7	48 8b c8	 mov	 rcx, rax
  001ca	e8 00 00 00 00	 call	 longjmp
  001cf	eb 09		 jmp	 SHORT $LN18@s370_test_
$LN17@s370_test_:

; 1262 :         else
; 1263 :             regs->psw.cc = 0;

  001d1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001d6	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN18@s370_test_:
$LN16@s370_test_:

; 1264 :     }
; 1265 : #endif /*defined(_FEATURE_SIE)*/
; 1266 : 
; 1267 :     if (regs->psw.cc != 0)

  001da	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001df	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  001e3	85 c0		 test	 eax, eax
  001e5	74 5a		 je	 SHORT $LN20@s370_test_
$LN10@s370_test_:

; 1268 :         PTIO(ERR,"*TCH");

  001e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001ee	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f1	48 83 e0 10	 and	 rax, 16
  001f5	48 85 c0	 test	 rax, rax
  001f8	74 41		 je	 SHORT $LN21@s370_test_
  001fa	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001ff	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00205	8b 4c 24 48	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00209	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00212	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00217	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170029
  0021e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00223	45 33 c9	 xor	 r9d, r9d
  00226	44 8b c1	 mov	 r8d, ecx
  00229	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170030
  00230	b9 10 00 00 00	 mov	 ecx, 16
  00235	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN21@s370_test_:
  0023b	33 c0		 xor	 eax, eax
  0023d	85 c0		 test	 eax, eax
  0023f	75 a6		 jne	 SHORT $LN10@s370_test_
$LN20@s370_test_:
$LN22@s370_test_:

; 1269 : }

  00241	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00245	c3		 ret	 0
s370_test_channel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
temp$1 = 68
b2$ = 72
dev$ = 80
inst$ = 112
regs$ = 120
s370_halt_io PROC

; 1200 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1201 : int     b2;                             /* Base of effective addr    */
; 1202 : VADR    effective_addr2;                /* Effective address         */
; 1203 : DEVBLK *dev;                            /* -> device block for SIO   */
; 1204 : 
; 1205 :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 2a		 je	 SHORT $LN17@s370_halt_
  00045	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00066	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0006b	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN17@s370_halt_:
$LN4@s370_halt_:
  0006f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00085	33 c0		 xor	 eax, eax
  00087	83 f8 04	 cmp	 eax, 4
  0008a	74 0c		 je	 SHORT $LN18@s370_halt_
  0008c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00091	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN18@s370_halt_:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 d1		 jne	 SHORT $LN4@s370_halt_

; 1206 : 
; 1207 :     TXF_INSTR_CHECK( regs );
; 1208 :     PRIV_CHECK(regs);

  0009e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000a7	83 e0 01	 and	 eax, 1
  000aa	85 c0		 test	 eax, eax
  000ac	74 15		 je	 SHORT $LN19@s370_halt_
  000ae	ba 02 00 00 00	 mov	 edx, 2
  000b3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@s370_halt_:
$LN7@s370_halt_:

; 1209 :     SIE_INTERCEPT(regs);

  000c3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000ce	d1 e8		 shr	 eax, 1
  000d0	83 e0 01	 and	 eax, 1
  000d3	85 c0		 test	 eax, eax
  000d5	74 18		 je	 SHORT $LN20@s370_halt_
  000d7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000e2	ba fc ff ff ff	 mov	 edx, -4
  000e7	48 8b c8	 mov	 rcx, rax
  000ea	e8 00 00 00 00	 call	 longjmp
$LN20@s370_halt_:
  000ef	33 c0		 xor	 eax, eax
  000f1	85 c0		 test	 eax, eax
  000f3	75 ce		 jne	 SHORT $LN7@s370_halt_
$LN10@s370_halt_:

; 1210 :     PTIO(IO,"HIO");

  000f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000fc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ff	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00105	48 85 c0	 test	 rax, rax
  00108	74 41		 je	 SHORT $LN21@s370_halt_
  0010a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0010f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00115	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00119	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00122	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00127	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169970
  0012e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00133	45 33 c9	 xor	 r9d, r9d
  00136	44 8b c1	 mov	 r8d, ecx
  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169971
  00140	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN21@s370_halt_:
  0014b	33 c0		 xor	 eax, eax
  0014d	85 c0		 test	 eax, eax
  0014f	75 a4		 jne	 SHORT $LN10@s370_halt_

; 1211 : 
; 1212 :     /* Locate the device block */
; 1213 :     if(regs->chanset == 0xFFFF
; 1214 :       || !(dev = find_device_by_devnum (regs->chanset,effective_addr2)) )

  00151	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00156	0f b7 80 38 08
	00 00		 movzx	 eax, WORD PTR [rax+2104]
  0015d	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00162	74 23		 je	 SHORT $LN23@s370_halt_
  00164	0f b7 54 24 40	 movzx	 edx, WORD PTR effective_addr2$[rsp]
  00169	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	0f b7 88 38 08
	00 00		 movzx	 ecx, WORD PTR [rax+2104]
  00175	e8 00 00 00 00	 call	 find_device_by_devnum
  0017a	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
  0017f	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00185	75 68		 jne	 SHORT $LN22@s370_halt_
$LN23@s370_halt_:
$LN13@s370_halt_:

; 1215 :     {
; 1216 :         PTIO(ERR,"*HIO");

  00187	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0018e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00191	48 83 e0 10	 and	 rax, 16
  00195	48 85 c0	 test	 rax, rax
  00198	74 41		 je	 SHORT $LN24@s370_halt_
  0019a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0019f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001a5	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001a9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001b2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169975
  001be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c3	45 33 c9	 xor	 r9d, r9d
  001c6	44 8b c1	 mov	 r8d, ecx
  001c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169976
  001d0	b9 10 00 00 00	 mov	 ecx, 16
  001d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN24@s370_halt_:
  001db	33 c0		 xor	 eax, eax
  001dd	85 c0		 test	 eax, eax
  001df	75 a6		 jne	 SHORT $LN13@s370_halt_

; 1217 :         regs->psw.cc = 3;

  001e1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e6	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 1218 :         return;

  001ea	e9 91 00 00 00	 jmp	 $LN1@s370_halt_
$LN22@s370_halt_:

; 1219 :     }
; 1220 : 
; 1221 :     /* Test the device and set the condition code */
; 1222 :     regs->psw.cc = haltio (regs, dev, inst[1]);

  001ef	b8 01 00 00 00	 mov	 eax, 1
  001f4	48 6b c0 01	 imul	 rax, rax, 1
  001f8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  001fd	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  00202	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00207	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0020c	e8 00 00 00 00	 call	 haltio
  00211	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00216	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1223 : 
; 1224 :     if (regs->psw.cc != 0)

  00219	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0021e	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00222	85 c0		 test	 eax, eax
  00224	74 5a		 je	 SHORT $LN25@s370_halt_
$LN16@s370_halt_:

; 1225 :         PTIO(ERR,"*HIO");

  00226	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0022d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00230	48 83 e0 10	 and	 rax, 16
  00234	48 85 c0	 test	 rax, rax
  00237	74 41		 je	 SHORT $LN26@s370_halt_
  00239	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0023e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00244	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00248	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00251	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00256	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169979
  0025d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00262	45 33 c9	 xor	 r9d, r9d
  00265	44 8b c1	 mov	 r8d, ecx
  00268	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169980
  0026f	b9 10 00 00 00	 mov	 ecx, 16
  00274	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN26@s370_halt_:
  0027a	33 c0		 xor	 eax, eax
  0027c	85 c0		 test	 eax, eax
  0027e	75 a6		 jne	 SHORT $LN16@s370_halt_
$LN25@s370_halt_:
$LN1@s370_halt_:
$LN27@s370_halt_:

; 1226 : }

  00280	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00284	c3		 ret	 0
s370_halt_io ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
temp$1 = 68
b2$ = 72
dev$ = 80
inst$ = 112
regs$ = 120
s370_test_io PROC

; 1159 : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1160 : int     b2;                             /* Base of effective addr    */
; 1161 : VADR    effective_addr2;                /* Effective address         */
; 1162 : DEVBLK *dev;                            /* -> device block for SIO   */
; 1163 : 
; 1164 :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 2a		 je	 SHORT $LN17@s370_test_
  00045	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00066	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0006b	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN17@s370_test_:
$LN4@s370_test_:
  0006f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00085	33 c0		 xor	 eax, eax
  00087	83 f8 04	 cmp	 eax, 4
  0008a	74 0c		 je	 SHORT $LN18@s370_test_
  0008c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00091	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN18@s370_test_:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 d1		 jne	 SHORT $LN4@s370_test_

; 1165 : 
; 1166 :     TXF_INSTR_CHECK( regs );
; 1167 :     PRIV_CHECK(regs);

  0009e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000a7	83 e0 01	 and	 eax, 1
  000aa	85 c0		 test	 eax, eax
  000ac	74 15		 je	 SHORT $LN19@s370_test_
  000ae	ba 02 00 00 00	 mov	 edx, 2
  000b3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@s370_test_:
$LN7@s370_test_:

; 1168 :     SIE_INTERCEPT(regs);

  000c3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000ce	d1 e8		 shr	 eax, 1
  000d0	83 e0 01	 and	 eax, 1
  000d3	85 c0		 test	 eax, eax
  000d5	74 18		 je	 SHORT $LN20@s370_test_
  000d7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000e2	ba fc ff ff ff	 mov	 edx, -4
  000e7	48 8b c8	 mov	 rcx, rax
  000ea	e8 00 00 00 00	 call	 longjmp
$LN20@s370_test_:
  000ef	33 c0		 xor	 eax, eax
  000f1	85 c0		 test	 eax, eax
  000f3	75 ce		 jne	 SHORT $LN7@s370_test_
$LN10@s370_test_:

; 1169 :     PTIO(IO,"TIO");

  000f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000fc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ff	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00105	48 85 c0	 test	 rax, rax
  00108	74 41		 je	 SHORT $LN21@s370_test_
  0010a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0010f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00115	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00119	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00122	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00127	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169907
  0012e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00133	45 33 c9	 xor	 r9d, r9d
  00136	44 8b c1	 mov	 r8d, ecx
  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169908
  00140	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN21@s370_test_:
  0014b	33 c0		 xor	 eax, eax
  0014d	85 c0		 test	 eax, eax
  0014f	75 a4		 jne	 SHORT $LN10@s370_test_

; 1170 : 
; 1171 :     /* Locate the device block */
; 1172 :     if(regs->chanset == 0xFFFF
; 1173 :       || !(dev = find_device_by_devnum (regs->chanset,effective_addr2)) )

  00151	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00156	0f b7 80 38 08
	00 00		 movzx	 eax, WORD PTR [rax+2104]
  0015d	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00162	74 23		 je	 SHORT $LN23@s370_test_
  00164	0f b7 54 24 40	 movzx	 edx, WORD PTR effective_addr2$[rsp]
  00169	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	0f b7 88 38 08
	00 00		 movzx	 ecx, WORD PTR [rax+2104]
  00175	e8 00 00 00 00	 call	 find_device_by_devnum
  0017a	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
  0017f	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00185	75 68		 jne	 SHORT $LN22@s370_test_
$LN23@s370_test_:
$LN13@s370_test_:

; 1174 :     {
; 1175 :         PTIO(ERR,"*TIO");

  00187	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0018e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00191	48 83 e0 10	 and	 rax, 16
  00195	48 85 c0	 test	 rax, rax
  00198	74 41		 je	 SHORT $LN24@s370_test_
  0019a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0019f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001a5	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001a9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001b2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169912
  001be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c3	45 33 c9	 xor	 r9d, r9d
  001c6	44 8b c1	 mov	 r8d, ecx
  001c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169913
  001d0	b9 10 00 00 00	 mov	 ecx, 16
  001d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN24@s370_test_:
  001db	33 c0		 xor	 eax, eax
  001dd	85 c0		 test	 eax, eax
  001df	75 a6		 jne	 SHORT $LN13@s370_test_

; 1176 :         regs->psw.cc = 3;

  001e1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e6	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 1177 :         return;

  001ea	e9 a5 00 00 00	 jmp	 $LN1@s370_test_
$LN22@s370_test_:

; 1178 :     }
; 1179 : 
; 1180 :     /* Test the device and set the condition code */
; 1181 :     regs->psw.cc = testio (regs, dev, inst[1]);

  001ef	b8 01 00 00 00	 mov	 eax, 1
  001f4	48 6b c0 01	 imul	 rax, rax, 1
  001f8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  001fd	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  00202	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00207	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0020c	e8 00 00 00 00	 call	 testio
  00211	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00216	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 1182 : 
; 1183 :     if (regs->psw.cc != 0)

  00219	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0021e	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00222	85 c0		 test	 eax, eax
  00224	74 5a		 je	 SHORT $LN25@s370_test_
$LN16@s370_test_:

; 1184 :         PTIO(ERR,"*TIO");

  00226	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0022d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00230	48 83 e0 10	 and	 rax, 16
  00234	48 85 c0	 test	 rax, rax
  00237	74 41		 je	 SHORT $LN26@s370_test_
  00239	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0023e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00244	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00248	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00251	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00256	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169916
  0025d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00262	45 33 c9	 xor	 r9d, r9d
  00265	44 8b c1	 mov	 r8d, ecx
  00268	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169917
  0026f	b9 10 00 00 00	 mov	 ecx, 16
  00274	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN26@s370_test_:
  0027a	33 c0		 xor	 eax, eax
  0027c	85 c0		 test	 eax, eax
  0027e	75 a6		 jne	 SHORT $LN16@s370_test_
$LN25@s370_test_:

; 1185 : 
; 1186 :     /* Yield time slice so that device handler may get some time */
; 1187 :     /* to possibly complete an I/O - to prevent a TIO Busy Loop  */
; 1188 :     if(regs->psw.cc == 2)

  00280	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00285	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00289	83 f8 02	 cmp	 eax, 2
  0028c	75 06		 jne	 SHORT $LN27@s370_test_

; 1189 :     {
; 1190 :         sched_yield();

  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN27@s370_test_:
$LN1@s370_test_:
$LN28@s370_test_:

; 1191 :     }
; 1192 : }

  00294	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00298	c3		 ret	 0
s370_test_io ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
ccwkey$ = 68
dev$ = 72
b2$ = 80
temp$1 = 84
tv265 = 88
psa$ = 96
ccwaddr$ = 104
orb$ = 112
__$ArrayPad$ = 144
inst$ = 176
regs$ = 184
s370_start_io PROC

; 1070 : {

$LN39:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1071 : int     b2;                             /* Effective addr base       */
; 1072 : VADR    effective_addr2;                /* Effective address         */
; 1073 : DEVBLK *dev;                            /* -> device block for SIO   */
; 1074 : PSA    *psa;                            /* -> prefixed storage area  */
; 1075 : ORB     orb;                            /* Operation request blk     */
; 1076 : VADR    ccwaddr;                        /* CCW address for start I/O */
; 1077 : BYTE    ccwkey;                         /* Bits 0-3=key, 4=suspend   */
; 1078 :                                         /*      5-7=zero             */
; 1079 : 
; 1080 :     S(inst, regs, b2, effective_addr2);

  00024	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00031	8b c8		 mov	 ecx, eax
  00033	e8 00 00 00 00	 call	 _byteswap_ulong
  00038	89 44 24 54	 mov	 DWORD PTR temp$1[rsp], eax
  0003c	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00045	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00049	8b 44 24 54	 mov	 eax, DWORD PTR temp$1[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	83 e0 0f	 and	 eax, 15
  00053	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00057	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005c	74 2d		 je	 SHORT $LN17@s370_start
  0005e	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  00063	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00072	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00076	03 c8		 add	 ecx, eax
  00078	8b c1		 mov	 eax, ecx
  0007a	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0007e	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00082	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00087	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN17@s370_start:
$LN4@s370_start:
  0008b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00093	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00097	48 83 c0 04	 add	 rax, 4
  0009b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000a7	33 c0		 xor	 eax, eax
  000a9	83 f8 04	 cmp	 eax, 4
  000ac	74 0f		 je	 SHORT $LN18@s370_start
  000ae	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN18@s370_start:
  000bd	33 c0		 xor	 eax, eax
  000bf	85 c0		 test	 eax, eax
  000c1	75 c8		 jne	 SHORT $LN4@s370_start

; 1081 : 
; 1082 :     TXF_INSTR_CHECK( regs );
; 1083 : 
; 1084 : #if defined(FEATURE_ECPSVM)
; 1085 :     if((inst[1])!=0x02)

  000c3	b8 01 00 00 00	 mov	 eax, 1
  000c8	48 6b c0 01	 imul	 rax, rax, 1
  000cc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  000d4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d8	83 f8 02	 cmp	 eax, 2
  000db	74 1f		 je	 SHORT $LN19@s370_start

; 1086 :     {
; 1087 :         if(ecpsvm_dosio(regs,b2,effective_addr2)==0)

  000dd	44 8b 44 24 40	 mov	 r8d, DWORD PTR effective_addr2$[rsp]
  000e2	8b 54 24 50	 mov	 edx, DWORD PTR b2$[rsp]
  000e6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ee	e8 00 00 00 00	 call	 ecpsvm_dosio
  000f3	85 c0		 test	 eax, eax
  000f5	75 05		 jne	 SHORT $LN20@s370_start

; 1088 :         {
; 1089 :             return;

  000f7	e9 41 04 00 00	 jmp	 $LN1@s370_start
$LN20@s370_start:
$LN19@s370_start:

; 1090 :         }
; 1091 :     }
; 1092 : #endif
; 1093 : 
; 1094 :     PRIV_CHECK(regs);

  000fc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00104	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00108	83 e0 01	 and	 eax, 1
  0010b	85 c0		 test	 eax, eax
  0010d	74 1b		 je	 SHORT $LN21@s370_start
  0010f	ba 02 00 00 00	 mov	 edx, 2
  00114	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN21@s370_start:
$LN7@s370_start:

; 1095 : 
; 1096 :     SIE_INTERCEPT(regs);

  0012a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00132	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00138	d1 e8		 shr	 eax, 1
  0013a	83 e0 01	 and	 eax, 1
  0013d	85 c0		 test	 eax, eax
  0013f	74 1b		 je	 SHORT $LN22@s370_start
  00141	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00149	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0014f	ba fc ff ff ff	 mov	 edx, -4
  00154	48 8b c8	 mov	 rcx, rax
  00157	e8 00 00 00 00	 call	 longjmp
$LN22@s370_start:
  0015c	33 c0		 xor	 eax, eax
  0015e	85 c0		 test	 eax, eax
  00160	75 c8		 jne	 SHORT $LN7@s370_start
$LN10@s370_start:

; 1097 : 
; 1098 :     PTIO(IO,"SIO");

  00162	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00169	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0016c	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00172	48 85 c0	 test	 rax, rax
  00175	74 44		 je	 SHORT $LN23@s370_start
  00177	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00185	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00189	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00192	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00197	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169840
  0019e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a3	45 33 c9	 xor	 r9d, r9d
  001a6	44 8b c1	 mov	 r8d, ecx
  001a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169841
  001b0	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN23@s370_start:
  001bb	33 c0		 xor	 eax, eax
  001bd	85 c0		 test	 eax, eax
  001bf	75 a1		 jne	 SHORT $LN10@s370_start

; 1099 : 
; 1100 :     /* Locate the device block */
; 1101 :     if(regs->chanset == 0xFFFF ||

  001c1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c9	0f b7 80 38 08
	00 00		 movzx	 eax, WORD PTR [rax+2104]
  001d0	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  001d5	74 26		 je	 SHORT $LN25@s370_start
  001d7	0f b7 54 24 40	 movzx	 edx, WORD PTR effective_addr2$[rsp]
  001dc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e4	0f b7 88 38 08
	00 00		 movzx	 ecx, WORD PTR [rax+2104]
  001eb	e8 00 00 00 00	 call	 find_device_by_devnum
  001f0	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax
  001f5	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001fb	75 6e		 jne	 SHORT $LN24@s370_start
$LN25@s370_start:
$LN13@s370_start:

; 1102 :        !(dev = find_device_by_devnum (regs->chanset,effective_addr2)))
; 1103 :     {
; 1104 :         PTIO(ERR,"*SIO");

  001fd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00204	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00207	48 83 e0 10	 and	 rax, 16
  0020b	48 85 c0	 test	 rax, rax
  0020e	74 44		 je	 SHORT $LN26@s370_start
  00210	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00218	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0021e	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00222	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0022b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00230	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169845
  00237	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023c	45 33 c9	 xor	 r9d, r9d
  0023f	44 8b c1	 mov	 r8d, ecx
  00242	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169846
  00249	b9 10 00 00 00	 mov	 ecx, 16
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN26@s370_start:
  00254	33 c0		 xor	 eax, eax
  00256	85 c0		 test	 eax, eax
  00258	75 a3		 jne	 SHORT $LN13@s370_start

; 1105 :         regs->psw.cc = 3;

  0025a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00262	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 1106 :         return;

  00266	e9 d2 02 00 00	 jmp	 $LN1@s370_start
$LN24@s370_start:

; 1107 :     }
; 1108 : 
; 1109 :     /* If CSW pending, drain interrupt and present the CSW */
; 1110 :     if (IOPENDING(dev) &&

  0026b	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00270	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00276	c1 e8 16	 shr	 eax, 22
  00279	83 e0 01	 and	 eax, 1
  0027c	85 c0		 test	 eax, eax
  0027e	75 3f		 jne	 SHORT $LN29@s370_start
  00280	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00285	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0028b	c1 e8 17	 shr	 eax, 23
  0028e	83 e0 01	 and	 eax, 1
  00291	85 c0		 test	 eax, eax
  00293	75 2a		 jne	 SHORT $LN29@s370_start
  00295	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0029a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002a0	c1 e8 18	 shr	 eax, 24
  002a3	83 e0 01	 and	 eax, 1
  002a6	85 c0		 test	 eax, eax
  002a8	75 15		 jne	 SHORT $LN29@s370_start
  002aa	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  002af	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002b5	c1 e8 1b	 shr	 eax, 27
  002b8	83 e0 01	 and	 eax, 1
  002bb	85 c0		 test	 eax, eax
  002bd	74 3e		 je	 SHORT $LN27@s370_start
$LN29@s370_start:
  002bf	b8 01 00 00 00	 mov	 eax, 1
  002c4	48 6b c0 01	 imul	 rax, rax, 1
  002c8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  002d0	44 0f b6 04 01	 movzx	 r8d, BYTE PTR [rcx+rax]
  002d5	48 8b 54 24 48	 mov	 rdx, QWORD PTR dev$[rsp]
  002da	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	e8 00 00 00 00	 call	 testio
  002e7	83 f8 01	 cmp	 eax, 1
  002ea	75 11		 jne	 SHORT $LN27@s370_start

; 1111 :         testio(regs, dev, inst[1]) == 1)
; 1112 :         regs->psw.cc = 1;

  002ec	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002f4	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1
  002f8	e9 b4 01 00 00	 jmp	 $LN28@s370_start
$LN27@s370_start:

; 1113 : 
; 1114 :     /* Else, if RIO, resume the subchannel operation */
; 1115 :     else if (inst[1] == 0x02)

  002fd	b8 01 00 00 00	 mov	 eax, 1
  00302	48 6b c0 01	 imul	 rax, rax, 1
  00306	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0030e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00312	83 f8 02	 cmp	 eax, 2
  00315	75 22		 jne	 SHORT $LN30@s370_start

; 1116 :         regs->psw.cc = resume_subchan (regs, dev);

  00317	48 8b 54 24 48	 mov	 rdx, QWORD PTR dev$[rsp]
  0031c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00324	e8 00 00 00 00	 call	 resume_subchan
  00329	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00331	88 41 7c	 mov	 BYTE PTR [rcx+124], al
  00334	e9 78 01 00 00	 jmp	 $LN31@s370_start
$LN30@s370_start:

; 1117 : 
; 1118 :     /* Otherwise, start the channel program and set the condition code
; 1119 :      */
; 1120 :     else
; 1121 :     {
; 1122 :         /* Fetch key and CCW address from the CAW at PSA+X'48' */
; 1123 :         psa = (PSA*)(regs->mainstor + regs->PX);

  00339	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00341	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00344	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034c	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  00353	48 89 44 24 60	 mov	 QWORD PTR psa$[rsp], rax

; 1124 :         ccwkey = psa->caw[0] & 0xF0;

  00358	b8 01 00 00 00	 mov	 eax, 1
  0035d	48 6b c0 00	 imul	 rax, rax, 0
  00361	48 8b 4c 24 60	 mov	 rcx, QWORD PTR psa$[rsp]
  00366	0f b6 44 01 48	 movzx	 eax, BYTE PTR [rcx+rax+72]
  0036b	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00370	88 44 24 44	 mov	 BYTE PTR ccwkey$[rsp], al

; 1125 :         ccwaddr = (psa->caw[1] << 16) |

  00374	b8 01 00 00 00	 mov	 eax, 1
  00379	48 6b c0 01	 imul	 rax, rax, 1
  0037d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR psa$[rsp]
  00382	0f b6 44 01 48	 movzx	 eax, BYTE PTR [rcx+rax+72]
  00387	c1 e0 10	 shl	 eax, 16
  0038a	b9 01 00 00 00	 mov	 ecx, 1
  0038f	48 6b c9 02	 imul	 rcx, rcx, 2
  00393	48 8b 54 24 60	 mov	 rdx, QWORD PTR psa$[rsp]
  00398	0f b6 4c 0a 48	 movzx	 ecx, BYTE PTR [rdx+rcx+72]
  0039d	c1 e1 08	 shl	 ecx, 8
  003a0	0b c1		 or	 eax, ecx
  003a2	b9 01 00 00 00	 mov	 ecx, 1
  003a7	48 6b c9 03	 imul	 rcx, rcx, 3
  003ab	48 8b 54 24 60	 mov	 rdx, QWORD PTR psa$[rsp]
  003b0	0f b6 4c 0a 48	 movzx	 ecx, BYTE PTR [rdx+rcx+72]
  003b5	0b c1		 or	 eax, ecx
  003b7	89 44 24 68	 mov	 DWORD PTR ccwaddr$[rsp], eax

; 1126 :                   (psa->caw[2] <<  8) |
; 1127 :                    psa->caw[3];
; 1128 : 
; 1129 :         /* Build the I/O operation request block */
; 1130 :         memset (&orb, 0, sizeof(ORB));

  003bb	48 8d 44 24 70	 lea	 rax, QWORD PTR orb$[rsp]
  003c0	48 8b f8	 mov	 rdi, rax
  003c3	33 c0		 xor	 eax, eax
  003c5	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  003ca	f3 aa		 rep stosb

; 1131 :         orb.flag4 = ccwkey & (ORB4_KEY | ORB4_S);

  003cc	0f b6 44 24 44	 movzx	 eax, BYTE PTR ccwkey$[rsp]
  003d1	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  003d6	88 44 24 74	 mov	 BYTE PTR orb$[rsp+4], al

; 1132 :         STORE_FW(orb.ccwaddr,ccwaddr);

  003da	8b 4c 24 68	 mov	 ecx, DWORD PTR ccwaddr$[rsp]
  003de	e8 00 00 00 00	 call	 _byteswap_ulong
  003e3	8b d0		 mov	 edx, eax
  003e5	48 8d 4c 24 78	 lea	 rcx, QWORD PTR orb$[rsp+8]
  003ea	e8 00 00 00 00	 call	 store_fw_noswap

; 1133 : 
; 1134 :         /* Indicate if CPU is to begin execution in S/360 or S/370 SIO
; 1135 :          * mode, not releasing the CPU until the first CCW has been
; 1136 :          * validated
; 1137 :          */
; 1138 :         dev->s370start = (inst[1] == 0x00 ||

  003ef	b8 01 00 00 00	 mov	 eax, 1
  003f4	48 6b c0 01	 imul	 rax, rax, 1
  003f8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00400	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00404	85 c0		 test	 eax, eax
  00406	74 59		 je	 SHORT $LN37@s370_start
  00408	b8 01 00 00 00	 mov	 eax, 1
  0040d	48 6b c0 01	 imul	 rax, rax, 1
  00411	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00419	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0041d	83 f8 01	 cmp	 eax, 1
  00420	75 35		 jne	 SHORT $LN36@s370_start
  00422	b8 01 00 00 00	 mov	 eax, 1
  00427	48 6b c0 00	 imul	 rax, rax, 0
  0042b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00430	0f b6 84 01 cc
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1484]
  00438	85 c0		 test	 eax, eax
  0043a	74 25		 je	 SHORT $LN35@s370_start
  0043c	b8 01 00 00 00	 mov	 eax, 1
  00441	48 6b c0 00	 imul	 rax, rax, 0
  00445	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  0044a	0f b6 84 01 cc
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1484]
  00452	83 f8 02	 cmp	 eax, 2
  00455	74 0a		 je	 SHORT $LN37@s370_start
$LN36@s370_start:
  00457	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv265[rsp], 0
  0045f	eb 08		 jmp	 SHORT $LN38@s370_start
$LN37@s370_start:
$LN35@s370_start:
  00461	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv265[rsp], 1
$LN38@s370_start:
  00469	8b 44 24 58	 mov	 eax, DWORD PTR tv265[rsp]
  0046d	83 e0 01	 and	 eax, 1
  00470	d1 e0		 shl	 eax, 1
  00472	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00477	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  0047d	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00480	0b c8		 or	 ecx, eax
  00482	8b c1		 mov	 eax, ecx
  00484	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00489	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1139 :                           (inst[1] == 0x01 &&
; 1140 :                            (dev->chptype[0] == CHP_TYPE_UNDEF ||
; 1141 :                             dev->chptype[0] == CHP_TYPE_BYTE)));
; 1142 : 
; 1143 :         /* Go start the I/O operation */
; 1144 :         regs->psw.cc = ARCH_DEP(startio) (regs, dev, &orb);

  0048f	4c 8d 44 24 70	 lea	 r8, QWORD PTR orb$[rsp]
  00494	48 8b 54 24 48	 mov	 rdx, QWORD PTR dev$[rsp]
  00499	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a1	e8 00 00 00 00	 call	 s370_startio
  004a6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ae	88 41 7c	 mov	 BYTE PTR [rcx+124], al
$LN31@s370_start:
$LN28@s370_start:

; 1145 :     }
; 1146 : 
; 1147 :     if (regs->psw.cc > 1)

  004b1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b9	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  004bd	83 f8 01	 cmp	 eax, 1
  004c0	7e 5d		 jle	 SHORT $LN32@s370_start
$LN16@s370_start:

; 1148 :         PTIO(ERR,"*SIO");

  004c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004c9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004cc	48 83 e0 10	 and	 rax, 16
  004d0	48 85 c0	 test	 rax, rax
  004d3	74 44		 je	 SHORT $LN33@s370_start
  004d5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004dd	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  004e3	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  004e7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004f0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169854
  004fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00501	45 33 c9	 xor	 r9d, r9d
  00504	44 8b c1	 mov	 r8d, ecx
  00507	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169855
  0050e	b9 10 00 00 00	 mov	 ecx, 16
  00513	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN33@s370_start:
  00519	33 c0		 xor	 eax, eax
  0051b	85 c0		 test	 eax, eax
  0051d	75 a3		 jne	 SHORT $LN16@s370_start
$LN32@s370_start:

; 1149 : 
; 1150 :     regs->siocount++;

  0051f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00527	8b 80 a0 07 00
	00		 mov	 eax, DWORD PTR [rax+1952]
  0052d	ff c0		 inc	 eax
  0052f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00537	89 81 a0 07 00
	00		 mov	 DWORD PTR [rcx+1952], eax
$LN1@s370_start:
$LN34@s370_start:

; 1151 : }

  0053d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00545	48 33 cc	 xor	 rcx, rsp
  00548	e8 00 00 00 00	 call	 __security_check_cookie
  0054d	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  00554	5f		 pop	 rdi
  00555	c3		 ret	 0
s370_start_io ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
i$ = 68
temp$1 = 72
b2$ = 76
inst$ = 96
regs$ = 104
s370_disconnect_channel_set PROC

; 1366 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1367 : int     b2;                             /* Base of effective addr    */
; 1368 : VADR    effective_addr2;                /* Effective address         */
; 1369 : int     i;
; 1370 : 
; 1371 :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 0c	 shr	 eax, 12
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 4c	 mov	 DWORD PTR b2$[rsp], eax
  0003e	83 7c 24 4c 00	 cmp	 DWORD PTR b2$[rsp], 0
  00043	74 2a		 je	 SHORT $LN20@s370_disco
  00045	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00056	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0005a	03 c8		 add	 ecx, eax
  0005c	8b c1		 mov	 eax, ecx
  0005e	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00062	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00066	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0006b	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN20@s370_disco:
$LN4@s370_disco:
  0006f	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00078	48 83 c0 04	 add	 rax, 4
  0007c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00085	33 c0		 xor	 eax, eax
  00087	83 f8 04	 cmp	 eax, 4
  0008a	74 0c		 je	 SHORT $LN21@s370_disco
  0008c	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00091	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN21@s370_disco:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 d1		 jne	 SHORT $LN4@s370_disco

; 1372 : 
; 1373 :     TXF_INSTR_CHECK( regs );
; 1374 :     PRIV_CHECK(regs);

  0009e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000a7	83 e0 01	 and	 eax, 1
  000aa	85 c0		 test	 eax, eax
  000ac	74 15		 je	 SHORT $LN22@s370_disco
  000ae	ba 02 00 00 00	 mov	 edx, 2
  000b3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000b8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN22@s370_disco:
$LN7@s370_disco:

; 1375 :     SIE_INTERCEPT(regs);

  000c3	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000ce	d1 e8		 shr	 eax, 1
  000d0	83 e0 01	 and	 eax, 1
  000d3	85 c0		 test	 eax, eax
  000d5	74 18		 je	 SHORT $LN23@s370_disco
  000d7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000e2	ba fc ff ff ff	 mov	 edx, -4
  000e7	48 8b c8	 mov	 rcx, rax
  000ea	e8 00 00 00 00	 call	 longjmp
$LN23@s370_disco:
  000ef	33 c0		 xor	 eax, eax
  000f1	85 c0		 test	 eax, eax
  000f3	75 ce		 jne	 SHORT $LN7@s370_disco
$LN10@s370_disco:

; 1376 :     PTIO(IO,"DISCS");

  000f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000fc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ff	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00105	48 85 c0	 test	 rax, rax
  00108	74 41		 je	 SHORT $LN24@s370_disco
  0010a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0010f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00115	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00119	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00122	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00127	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170209
  0012e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00133	45 33 c9	 xor	 r9d, r9d
  00136	44 8b c1	 mov	 r8d, ecx
  00139	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170210
  00140	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN24@s370_disco:
  0014b	33 c0		 xor	 eax, eax
  0014d	85 c0		 test	 eax, eax
  0014f	75 a4		 jne	 SHORT $LN10@s370_disco

; 1377 : 
; 1378 :     /* Hercules has as many channelsets as CSS's */
; 1379 :     if(effective_addr2 >= FEATURE_LCSS_MAX)

  00151	83 7c 24 40 04	 cmp	 DWORD PTR effective_addr2$[rsp], 4
  00156	72 68		 jb	 SHORT $LN25@s370_disco
$LN13@s370_disco:

; 1380 :     {
; 1381 :         PTIO(ERR,"*DISCS");

  00158	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0015f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00162	48 83 e0 10	 and	 rax, 16
  00166	48 85 c0	 test	 rax, rax
  00169	74 41		 je	 SHORT $LN26@s370_disco
  0016b	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00170	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00176	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0017a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00183	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00188	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170213
  0018f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00194	45 33 c9	 xor	 r9d, r9d
  00197	44 8b c1	 mov	 r8d, ecx
  0019a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170214
  001a1	b9 10 00 00 00	 mov	 ecx, 16
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN26@s370_disco:
  001ac	33 c0		 xor	 eax, eax
  001ae	85 c0		 test	 eax, eax
  001b0	75 a6		 jne	 SHORT $LN13@s370_disco

; 1382 :         regs->psw.cc = 3;

  001b2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 1383 :         return;

  001bb	e9 9d 01 00 00	 jmp	 $LN1@s370_disco
$LN25@s370_disco:

; 1384 :     }
; 1385 : 
; 1386 :     /* If the addressed channel set is currently connected
; 1387 :        then disconect channel set and return with cc0 */
; 1388 :     if(regs->chanset == effective_addr2 && regs->chanset != 0xFFFF)

  001c0	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001c5	0f b7 80 38 08
	00 00		 movzx	 eax, WORD PTR [rax+2104]
  001cc	3b 44 24 40	 cmp	 eax, DWORD PTR effective_addr2$[rsp]
  001d0	75 32		 jne	 SHORT $LN27@s370_disco
  001d2	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001d7	0f b7 80 38 08
	00 00		 movzx	 eax, WORD PTR [rax+2104]
  001de	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  001e3	74 1f		 je	 SHORT $LN27@s370_disco

; 1389 :     {
; 1390 :         regs->chanset = 0xFFFF;

  001e5	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  001ea	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  001ef	66 89 81 38 08
	00 00		 mov	 WORD PTR [rcx+2104], ax

; 1391 :         regs->psw.cc = 0;

  001f6	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  001fb	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1392 :         return;

  001ff	e9 59 01 00 00	 jmp	 $LN1@s370_disco
$LN27@s370_disco:

; 1393 :     }
; 1394 : 
; 1395 :     OBTAIN_INTLOCK(regs);

  00204	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170216
  0020b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00210	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1396 : 
; 1397 :     /* If the addressed channelset is connected to another
; 1398 :        CPU then return with cc0 */
; 1399 :     for(i = 0; i < sysblk.maxcpu; i++)

  00215	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0021d	eb 0a		 jmp	 SHORT $LN16@s370_disco
$LN14@s370_disco:
  0021f	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  00223	ff c0		 inc	 eax
  00225	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
$LN16@s370_disco:
  00229	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00230	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00236	39 44 24 44	 cmp	 DWORD PTR i$[rsp], eax
  0023a	0f 8d 03 01 00
	00		 jge	 $LN15@s370_disco

; 1400 :     {
; 1401 :         if (IS_CPU_ONLINE(i)
; 1402 :          && sysblk.regs[i]->chanset == effective_addr2)

  00240	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  00245	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0024c	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00255	0f 84 e3 00 00
	00		 je	 $LN28@s370_disco
  0025b	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  00260	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00267	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0026f	0f b7 80 38 08
	00 00		 movzx	 eax, WORD PTR [rax+2104]
  00276	3b 44 24 40	 cmp	 eax, DWORD PTR effective_addr2$[rsp]
  0027a	0f 85 be 00 00
	00		 jne	 $LN28@s370_disco

; 1403 :         {
; 1404 :             if(sysblk.regs[i]->cpustate != CPUSTATE_STARTED)

  00280	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  00285	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0028c	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00294	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00298	83 f8 01	 cmp	 eax, 1
  0029b	74 2b		 je	 SHORT $LN29@s370_disco

; 1405 :             {
; 1406 :                 sysblk.regs[i]->chanset = 0xFFFF;

  0029d	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  002a2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002a9	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  002b1	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  002b6	66 89 88 38 08
	00 00		 mov	 WORD PTR [rax+2104], cx

; 1407 :                 regs->psw.cc = 0;

  002bd	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002c2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1408 :             }

  002c6	eb 63		 jmp	 SHORT $LN30@s370_disco
$LN29@s370_disco:

; 1409 :             else
; 1410 :             {
; 1411 :                 regs->psw.cc = 1;

  002c8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002cd	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1
$LN19@s370_disco:

; 1412 :                 PTIO(ERR,"*DISCS");

  002d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002d8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002db	48 83 e0 10	 and	 rax, 16
  002df	48 85 c0	 test	 rax, rax
  002e2	74 41		 je	 SHORT $LN31@s370_disco
  002e4	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  002e9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  002ef	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  002f3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002fc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00301	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170221
  00308	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0030d	45 33 c9	 xor	 r9d, r9d
  00310	44 8b c1	 mov	 r8d, ecx
  00313	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170222
  0031a	b9 10 00 00 00	 mov	 ecx, 16
  0031f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN31@s370_disco:
  00325	33 c0		 xor	 eax, eax
  00327	85 c0		 test	 eax, eax
  00329	75 a6		 jne	 SHORT $LN19@s370_disco
$LN30@s370_disco:

; 1413 :             }
; 1414 :             RELEASE_INTLOCK(regs);

  0032b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170223
  00332	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00337	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1415 :             return;

  0033c	eb 1f		 jmp	 SHORT $LN1@s370_disco
$LN28@s370_disco:

; 1416 :         }
; 1417 :     }

  0033e	e9 dc fe ff ff	 jmp	 $LN14@s370_disco
$LN15@s370_disco:

; 1418 : 
; 1419 :     RELEASE_INTLOCK(regs);

  00343	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170224
  0034a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0034f	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1420 : 
; 1421 :     /* The channel set is not connected, no operation
; 1422 :        is performed */
; 1423 :     regs->psw.cc = 0;

  00354	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00359	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s370_disco:
$LN32@s370_disco:

; 1424 : }

  0035d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00361	c3		 ret	 0
s370_disconnect_channel_set ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\io.c
_TEXT	SEGMENT
effective_addr2$ = 64
i$ = 68
i$1 = 72
temp$2 = 76
b2$ = 80
regs$3 = 88
mask$4 = 96
wake$5 = 104
inst$ = 128
regs$ = 136
s370_connect_channel_set PROC

; 1301 : {

$LN37:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1302 : int     b2;                             /* Base of effective addr    */
; 1303 : VADR    effective_addr2;                /* Effective address         */
; 1304 : int     i;
; 1305 : 
; 1306 :     S(inst, regs, b2, effective_addr2);

  0000e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00016	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001b	8b c8		 mov	 ecx, eax
  0001d	e8 00 00 00 00	 call	 _byteswap_ulong
  00022	89 44 24 4c	 mov	 DWORD PTR temp$2[rsp], eax
  00026	8b 44 24 4c	 mov	 eax, DWORD PTR temp$2[rsp]
  0002a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002f	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00033	8b 44 24 4c	 mov	 eax, DWORD PTR temp$2[rsp]
  00037	c1 e8 0c	 shr	 eax, 12
  0003a	83 e0 0f	 and	 eax, 15
  0003d	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00041	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  00046	74 2d		 je	 SHORT $LN23@s370_conne
  00048	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  0004d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00055	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0005c	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00060	03 c8		 add	 ecx, eax
  00062	8b c1		 mov	 eax, ecx
  00064	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00068	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0006c	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00071	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN23@s370_conne:
$LN4@s370_conne:
  00075	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00081	48 83 c0 04	 add	 rax, 4
  00085	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00091	33 c0		 xor	 eax, eax
  00093	83 f8 04	 cmp	 eax, 4
  00096	74 0f		 je	 SHORT $LN24@s370_conne
  00098	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN24@s370_conne:
  000a7	33 c0		 xor	 eax, eax
  000a9	85 c0		 test	 eax, eax
  000ab	75 c8		 jne	 SHORT $LN4@s370_conne

; 1307 : 
; 1308 :     TXF_INSTR_CHECK( regs );
; 1309 :     PRIV_CHECK(regs);

  000ad	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b5	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000b9	83 e0 01	 and	 eax, 1
  000bc	85 c0		 test	 eax, eax
  000be	74 1b		 je	 SHORT $LN25@s370_conne
  000c0	ba 02 00 00 00	 mov	 edx, 2
  000c5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN25@s370_conne:
$LN7@s370_conne:

; 1310 :     SIE_INTERCEPT(regs);

  000db	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e9	d1 e8		 shr	 eax, 1
  000eb	83 e0 01	 and	 eax, 1
  000ee	85 c0		 test	 eax, eax
  000f0	74 1b		 je	 SHORT $LN26@s370_conne
  000f2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fa	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00100	ba fc ff ff ff	 mov	 edx, -4
  00105	48 8b c8	 mov	 rcx, rax
  00108	e8 00 00 00 00	 call	 longjmp
$LN26@s370_conne:
  0010d	33 c0		 xor	 eax, eax
  0010f	85 c0		 test	 eax, eax
  00111	75 c8		 jne	 SHORT $LN7@s370_conne
$LN10@s370_conne:

; 1311 :     PTIO(IO,"CONCS");

  00113	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0011a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0011d	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00123	48 85 c0	 test	 rax, rax
  00126	74 44		 je	 SHORT $LN27@s370_conne
  00128	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00130	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00136	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0013a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00143	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00148	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170138
  0014f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00154	45 33 c9	 xor	 r9d, r9d
  00157	44 8b c1	 mov	 r8d, ecx
  0015a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170139
  00161	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN27@s370_conne:
  0016c	33 c0		 xor	 eax, eax
  0016e	85 c0		 test	 eax, eax
  00170	75 a1		 jne	 SHORT $LN10@s370_conne

; 1312 : 
; 1313 :     effective_addr2 &= 0xFFFF;

  00172	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00176	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0017b	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax

; 1314 : 
; 1315 :     /* Hercules has as many channelsets as CSS's */
; 1316 :     if(effective_addr2 >= FEATURE_LCSS_MAX)

  0017f	83 7c 24 40 04	 cmp	 DWORD PTR effective_addr2$[rsp], 4
  00184	72 6e		 jb	 SHORT $LN28@s370_conne
$LN13@s370_conne:

; 1317 :     {
; 1318 :         PTIO(ERR,"*CONCS");

  00186	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0018d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00190	48 83 e0 10	 and	 rax, 16
  00194	48 85 c0	 test	 rax, rax
  00197	74 44		 je	 SHORT $LN29@s370_conne
  00199	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a1	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001a7	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001ab	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001b4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170142
  001c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c5	45 33 c9	 xor	 r9d, r9d
  001c8	44 8b c1	 mov	 r8d, ecx
  001cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170143
  001d2	b9 10 00 00 00	 mov	 ecx, 16
  001d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@s370_conne:
  001dd	33 c0		 xor	 eax, eax
  001df	85 c0		 test	 eax, eax
  001e1	75 a3		 jne	 SHORT $LN13@s370_conne

; 1319 :         regs->psw.cc = 3;

  001e3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 1320 :         return;

  001ef	e9 26 02 00 00	 jmp	 $LN1@s370_conne
$LN28@s370_conne:

; 1321 :     }
; 1322 : 
; 1323 :     /* If the addressed channel set is currently connected
; 1324 :        then return with cc0 */
; 1325 :     if(regs->chanset == effective_addr2)

  001f4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	0f b7 80 38 08
	00 00		 movzx	 eax, WORD PTR [rax+2104]
  00203	3b 44 24 40	 cmp	 eax, DWORD PTR effective_addr2$[rsp]
  00207	75 11		 jne	 SHORT $LN30@s370_conne

; 1326 :     {
; 1327 :         regs->psw.cc = 0;

  00209	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00211	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1328 :         return;

  00215	e9 00 02 00 00	 jmp	 $LN1@s370_conne
$LN30@s370_conne:

; 1329 :     }
; 1330 : 
; 1331 :     /* Disconnect channel set */
; 1332 :     regs->chanset = 0xFFFF;

  0021a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0021f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00227	66 89 81 38 08
	00 00		 mov	 WORD PTR [rcx+2104], ax

; 1333 : 
; 1334 :     OBTAIN_INTLOCK(regs);

  0022e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170145
  00235	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1335 : 
; 1336 :     /* If the addressed channelset is connected to another
; 1337 :        CPU then return with cc1 */
; 1338 :     for (i = 0; i < sysblk.maxcpu; i++)

  00242	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0024a	eb 0a		 jmp	 SHORT $LN16@s370_conne
$LN14@s370_conne:
  0024c	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  00250	ff c0		 inc	 eax
  00252	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
$LN16@s370_conne:
  00256	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0025d	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00263	39 44 24 44	 cmp	 DWORD PTR i$[rsp], eax
  00267	7d 5f		 jge	 SHORT $LN15@s370_conne

; 1339 :     {
; 1340 :         if (IS_CPU_ONLINE(i)
; 1341 :          && sysblk.regs[i]->chanset == effective_addr2)

  00269	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  0026e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00275	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0027e	74 46		 je	 SHORT $LN31@s370_conne
  00280	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  00285	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0028c	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00294	0f b7 80 38 08
	00 00		 movzx	 eax, WORD PTR [rax+2104]
  0029b	3b 44 24 40	 cmp	 eax, DWORD PTR effective_addr2$[rsp]
  0029f	75 25		 jne	 SHORT $LN31@s370_conne

; 1342 :         {
; 1343 :             RELEASE_INTLOCK(regs);

  002a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170147
  002a8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b0	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1344 :             regs->psw.cc = 1;

  002b5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bd	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 1345 :             return;

  002c1	e9 54 01 00 00	 jmp	 $LN1@s370_conne
$LN31@s370_conne:

; 1346 :         }
; 1347 :     }

  002c6	eb 84		 jmp	 SHORT $LN14@s370_conne
$LN15@s370_conne:

; 1348 : 
; 1349 :     /* Set channel set connected to current CPU */
; 1350 :     regs->chanset = effective_addr2;

  002c8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d0	0f b7 4c 24 40	 movzx	 ecx, WORD PTR effective_addr2$[rsp]
  002d5	66 89 88 38 08
	00 00		 mov	 WORD PTR [rax+2104], cx
$LN19@s370_conne:

; 1351 : 
; 1352 :     /* Interrupts may be pending on this channelset */
; 1353 :     ON_IC_IOPENDING;

  002dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002e3	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  002ea	48 89 44 24 60	 mov	 QWORD PTR mask$4[rsp], rax
  002ef	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002f6	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  002fc	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00301	85 c0		 test	 eax, eax
  00303	0f 85 e7 00 00
	00		 jne	 $LN32@s370_conne
  00309	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00310	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00316	0f ba e8 1e	 bts	 eax, 30
  0031a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00321	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  00327	48 8b 44 24 60	 mov	 rax, QWORD PTR mask$4[rsp]
  0032c	48 89 44 24 68	 mov	 QWORD PTR wake$5[rsp], rax
  00331	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00339	eb 17		 jmp	 SHORT $LN22@s370_conne
$LN20@s370_conne:
  0033b	48 8b 44 24 60	 mov	 rax, QWORD PTR mask$4[rsp]
  00340	48 d1 e8	 shr	 rax, 1
  00343	48 89 44 24 60	 mov	 QWORD PTR mask$4[rsp], rax
  00348	8b 44 24 48	 mov	 eax, DWORD PTR i$1[rsp]
  0034c	ff c0		 inc	 eax
  0034e	89 44 24 48	 mov	 DWORD PTR i$1[rsp], eax
$LN22@s370_conne:
  00352	48 83 7c 24 60
	00		 cmp	 QWORD PTR mask$4[rsp], 0
  00358	0f 84 81 00 00
	00		 je	 $LN21@s370_conne
  0035e	48 8b 44 24 60	 mov	 rax, QWORD PTR mask$4[rsp]
  00363	48 83 e0 01	 and	 rax, 1
  00367	48 85 c0	 test	 rax, rax
  0036a	74 6e		 je	 SHORT $LN33@s370_conne
  0036c	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$1[rsp]
  00371	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00378	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00380	48 89 44 24 58	 mov	 QWORD PTR regs$3[rsp], rax
  00385	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$3[rsp]
  0038a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0038d	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00392	85 c0		 test	 eax, eax
  00394	74 17		 je	 SHORT $LN34@s370_conne
  00396	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$3[rsp]
  0039b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0039e	0d 00 00 00 c0	 or	 eax, -1073741824	; c0000000H
  003a3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$3[rsp]
  003a8	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  003ab	eb 2d		 jmp	 SHORT $LN35@s370_conne
$LN34@s370_conne:
  003ad	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$3[rsp]
  003b2	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003b5	0f ba e8 1e	 bts	 eax, 30
  003b9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$3[rsp]
  003be	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  003c1	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$3[rsp]
  003c6	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  003ca	48 8b 4c 24 68	 mov	 rcx, QWORD PTR wake$5[rsp]
  003cf	48 33 c8	 xor	 rcx, rax
  003d2	48 8b c1	 mov	 rax, rcx
  003d5	48 89 44 24 68	 mov	 QWORD PTR wake$5[rsp], rax
$LN35@s370_conne:
$LN33@s370_conne:
  003da	e9 5c ff ff ff	 jmp	 $LN20@s370_conne
$LN21@s370_conne:
  003df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170152
  003e6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR wake$5[rsp]
  003eb	e8 00 00 00 00	 call	 wakeup_cpu_mask
$LN32@s370_conne:
  003f0	33 c0		 xor	 eax, eax
  003f2	85 c0		 test	 eax, eax
  003f4	0f 85 e2 fe ff
	ff		 jne	 $LN19@s370_conne

; 1354 : 
; 1355 :     RELEASE_INTLOCK(regs);

  003fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170153
  00401	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00409	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1356 : 
; 1357 :     regs->psw.cc = 0;

  0040e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00416	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s370_conne:
$LN36@s370_conne:

; 1358 : 
; 1359 : }

  0041a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0041e	c3		 ret	 0
s370_connect_channel_set ENDP
_TEXT	ENDS
END
