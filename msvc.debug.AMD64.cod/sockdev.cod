; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	bind_device_ex
PUBLIC	unbind_device_ex
PUBLIC	unix_socket
PUBLIC	inet_socket
PUBLIC	add_socket_devices_to_fd_set
PUBLIC	socket_device_connection_handler
PUBLIC	check_socket_devices_for_connections
PUBLIC	socket_thread
EXTRN	__imp_isdigit:PROC
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_bind:PROC
EXTRN	__imp_getpeername:PROC
EXTRN	__imp_htons:PROC
EXTRN	__imp_inet_ntoa:PROC
EXTRN	__imp_listen:PROC
EXTRN	__imp_recv:PROC
EXTRN	__imp_send:PROC
EXTRN	__imp_setsockopt:PROC
EXTRN	__imp_gethostbyaddr:PROC
EXTRN	__imp_gethostbyname:PROC
EXTRN	__imp_getservbyname:PROC
EXTRN	__imp_WSASetLastError:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_join_thread:PROC
EXTRN	__imp_hthread_detach_thread:PROC
EXTRN	__imp_hthread_set_thread_prio:PROC
EXTRN	__imp_hthread_get_thread_prio:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_w32_socket:PROC
EXTRN	__imp_w32_accept:PROC
EXTRN	__imp_w32_close_socket:PROC
EXTRN	__imp_w32_FD_SET:PROC
EXTRN	__imp_w32_FD_ISSET:PROC
EXTRN	__imp_w32_select:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_hdl_addshut:PROC
EXTRN	__imp_device_attention:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
init_done DD	01H DUP (?)
bind_head DB	010H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$bind_device_ex DD imagerel $LN45
	DD	imagerel $LN45+2213
	DD	imagerel $unwind$bind_device_ex
$pdata$unbind_device_ex DD imagerel $LN40
	DD	imagerel $LN40+1688
	DD	imagerel $unwind$unbind_device_ex
$pdata$init_sockdev DD imagerel init_sockdev
	DD	imagerel init_sockdev+133
	DD	imagerel $unwind$init_sockdev
$pdata$term_sockdev DD imagerel term_sockdev
	DD	imagerel term_sockdev+377
	DD	imagerel $unwind$term_sockdev
$pdata$unix_socket DD imagerel $LN6
	DD	imagerel $LN6+96
	DD	imagerel $unwind$unix_socket
$pdata$inet_socket DD imagerel $LN14
	DD	imagerel $LN14+985
	DD	imagerel $unwind$inet_socket
$pdata$add_socket_devices_to_fd_set DD imagerel $LN7
	DD	imagerel $LN7+183
	DD	imagerel $unwind$add_socket_devices_to_fd_set
$pdata$socket_device_connection_handler DD imagerel $LN32
	DD	imagerel $LN32+1991
	DD	imagerel $unwind$socket_device_connection_handler
$pdata$check_socket_devices_for_connections DD imagerel $LN6
	DD	imagerel $LN6+192
	DD	imagerel $unwind$check_socket_devices_for_connections
$pdata$socket_thread DD imagerel $LN33
	DD	imagerel $LN33+1150
	DD	imagerel $unwind$socket_thread
pdata	ENDS
_DATA	SEGMENT
$SG168125 DB	'sockdev.c:49', 00H
	ORG $+3
$SG168127 DB	'term_sockdev', 00H
	ORG $+3
$SG168128 DB	'sockdev.c:58', 00H
	ORG $+3
$SG168151 DB	'sockdev.c:65', 00H
	ORG $+3
$SG168153 DB	'sockdev.c:65', 00H
	ORG $+3
$SG168156 DB	'term_sockdev', 00H
	ORG $+3
$SG168157 DB	'sockdev.c', 00H
	ORG $+6
$SG168158 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168160 DB	'term_sockdev', 00H
	ORG $+3
$SG168161 DB	'sockdev.c', 00H
	ORG $+6
$SG168164 DB	'sockdev.c:66', 00H
	ORG $+3
$SG168173 DB	'E', 00H
	ORG $+6
$SG168162 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168165 DB	'sockdev.c:67', 00H
	ORG $+3
$SG168203 DB	'E', 00H
	ORG $+6
$SG168174 DB	'HHC01032%s COMM: this Hercules build does not support Un'
	DB	'ix domain sockets', 0aH, 00H
	ORG $+1
$SG168209 DB	'tcp', 00H
$SG168175 DB	'unix_socket', 00H
$SG168211 DB	'E', 00H
	ORG $+2
$SG168176 DB	'sockdev.c', 00H
	ORG $+2
$SG168217 DB	'E', 00H
	ORG $+2
$SG168204 DB	'HHC01035%s COMM: failed to determine IP address from nod'
	DB	'e %s', 0aH, 00H
	ORG $+2
$SG168205 DB	'inet_socket', 00H
$SG168224 DB	'E', 00H
	ORG $+2
$SG168206 DB	'sockdev.c', 00H
	ORG $+6
$SG168212 DB	'HHC01036%s COMM: failed to determine port number from se'
	DB	'rvice %s', 0aH, 00H
	ORG $+2
$SG168223 DB	'bind()', 00H
	ORG $+1
$SG168271 DB	'E', 00H
	ORG $+2
$SG168213 DB	'inet_socket', 00H
$SG168282 DB	'E', 00H
	ORG $+2
$SG168214 DB	'sockdev.c', 00H
	ORG $+2
$SG168288 DB	'E', 00H
	ORG $+2
$SG168216 DB	'socket()', 00H
	ORG $+3
$SG168296 DB	'E', 00H
	ORG $+2
$SG168218 DB	'HHC01034%s COMM: error in function %s: %s', 0aH, 00H
	ORG $+1
$SG168301 DB	'I', 00H
	ORG $+2
$SG168219 DB	'inet_socket', 00H
$SG168364 DB	'I', 00H
	ORG $+2
$SG168220 DB	'sockdev.c', 00H
	ORG $+2
$SG168388 DB	'E', 00H
	ORG $+2
$SG168225 DB	'HHC01034%s COMM: error in function %s: %s', 0aH, 00H
	ORG $+1
$SG168394 DB	'I', 00H
	ORG $+2
$SG168226 DB	'inet_socket', 00H
$SG168443 DB	'E', 00H
	ORG $+2
$SG168227 DB	'sockdev.c', 00H
	ORG $+2
$SG168449 DB	'E', 00H
	ORG $+2
$SG168242 DB	'sockdev.c:225', 00H
	ORG $+2
$SG168245 DB	'sockdev.c:244', 00H
	ORG $+2
$SG168270 DB	'accept()', 00H
	ORG $+3
$SG168455 DB	'E', 00H
	ORG $+2
$SG168272 DB	'HHC01000%s %1d:%04X COMM: error in function %s: %s', 0aH
	DB	00H
$SG168467 DB	'E', 00H
	ORG $+2
$SG168273 DB	'socket_device_connection_handler', 00H
	ORG $+3
$SG168486 DB	'I', 00H
	ORG $+2
$SG168274 DB	'sockdev.c', 00H
	ORG $+2
$SG168522 DB	'E', 00H
	ORG $+2
$SG168275 DB	'<unknown>', 00H
	ORG $+2
$SG168529 DB	'I', 00H
	ORG $+2
$SG168278 DB	'<unknown>', 00H
	ORG $+2
$SG168533 DB	'E', 00H
	ORG $+2
$SG168279 DB	'sockdev.c:300', 00H
	ORG $+2
$SG168283 DB	'HHC01037%s %1d:%04X COMM: client %s, IP %s connection to'
	DB	' device %s rejected: device busy or interrupt pending', 0aH, 00H
	ORG $+1
$SG168284 DB	'socket_device_connection_handler', 00H
	ORG $+3
$SG168552 DB	'I', 00H
	ORG $+2
$SG168285 DB	'sockdev.c', 00H
	ORG $+6
$SG168286 DB	'sockdev.c:313', 00H
	ORG $+10
$SG168289 DB	'HHC01038%s %1d:%04X COMM: client %s, IP %s connection to'
	DB	' device %s rejected: client %s ip %s still connected', 0aH, 00H
	ORG $+2
$SG168290 DB	'socket_device_connection_handler', 00H
	ORG $+7
$SG168291 DB	'sockdev.c', 00H
	ORG $+6
$SG168292 DB	'sockdev.c:325', 00H
	ORG $+10
$SG168297 DB	'HHC01039%s %1d:%04X COMM: client %s, IP %s connection to'
	DB	' device %s rejected: by onconnect callback', 0aH, 00H
	ORG $+4
$SG168298 DB	'socket_device_connection_handler', 00H
	ORG $+7
$SG168299 DB	'sockdev.c', 00H
	ORG $+6
$SG168300 DB	'sockdev.c:348', 00H
	ORG $+2
$SG168302 DB	'HHC01040%s %1d:%04X COMM: client %s, IP %s connected to '
	DB	'device %s', 0aH, 00H
	ORG $+5
$SG168303 DB	'socket_device_connection_handler', 00H
	ORG $+7
$SG168304 DB	'sockdev.c', 00H
	ORG $+6
$SG168305 DB	'sockdev.c:355', 00H
	ORG $+2
$SG168318 DB	'sockdev.c:369', 00H
	ORG $+2
$SG168320 DB	'sockdev.c:383', 00H
	ORG $+2
$SG168321 DB	'sockdev.c:391', 00H
	ORG $+2
$SG168361 DB	'sockdev.c:407', 00H
	ORG $+2
$SG168362 DB	'socket_thread', 00H
	ORG $+2
$SG168363 DB	'sockdev.c:410', 00H
	ORG $+2
$SG168365 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG168366 DB	'socket_thread', 00H
	ORG $+2
$SG168367 DB	'sockdev.c', 00H
	ORG $+6
$SG168368 DB	'sockdev.c', 00H
	ORG $+6
$SG168369 DB	'sockdev.c:424', 00H
	ORG $+2
$SG168371 DB	'sockdev.c:424', 00H
	ORG $+2
$SG168374 DB	'socket_thread', 00H
	ORG $+2
$SG168375 DB	'sockdev.c', 00H
	ORG $+14
$SG168376 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168378 DB	'socket_thread', 00H
	ORG $+2
$SG168379 DB	'sockdev.c', 00H
	ORG $+14
$SG168380 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168382 DB	'sockdev.c:427', 00H
	ORG $+2
$SG168383 DB	'sockdev.c:431', 00H
	ORG $+2
$SG168387 DB	'select()', 00H
	ORG $+7
$SG168389 DB	'HHC01034%s COMM: error in function %s: %s', 0aH, 00H
	ORG $+5
$SG168390 DB	'socket_thread', 00H
	ORG $+2
$SG168391 DB	'sockdev.c', 00H
	ORG $+6
$SG168392 DB	'socket_thread', 00H
	ORG $+2
$SG168393 DB	'sockdev.c:449', 00H
	ORG $+2
$SG168395 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG168396 DB	'socket_thread', 00H
	ORG $+2
$SG168397 DB	'sockdev.c', 00H
	ORG $+6
$SG168444 DB	'HHC01041%s %1d:%04X COMM: error: device already bound to'
	DB	' socket %s', 0aH, 00H
	ORG $+4
$SG168445 DB	'bind_device_ex', 00H
	ORG $+1
$SG168446 DB	'sockdev.c', 00H
	ORG $+6
$SG168448 DB	'malloc(%d)', 00H
	ORG $+5
$SG168450 DB	'HHC01000%s %1d:%04X COMM: error in function %s: %s', 0aH
	DB	00H
	ORG $+4
$SG168451 DB	'bind_device_ex', 00H
	ORG $+1
$SG168452 DB	'sockdev.c', 00H
	ORG $+6
$SG168454 DB	'strdup()', 00H
	ORG $+7
$SG168456 DB	'HHC01000%s %1d:%04X COMM: error in function %s: %s', 0aH
	DB	00H
	ORG $+4
$SG168457 DB	'bind_device_ex', 00H
	ORG $+1
$SG168458 DB	'sockdev.c', 00H
	ORG $+6
$SG168462 DB	'sockdev.c:525', 00H
	ORG $+2
$SG168464 DB	'sockdev.c:534', 00H
	ORG $+2
$SG168465 DB	'socket_thread', 00H
	ORG $+2
$SG168468 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG168469 DB	'bind_device_ex', 00H
	ORG $+1
$SG168470 DB	'sockdev.c', 00H
	ORG $+6
$SG168471 DB	'sockdev.c:543', 00H
	ORG $+2
$SG168472 DB	'sockdev.c:548', 00H
	ORG $+2
$SG168474 DB	'sockdev.c:548', 00H
	ORG $+2
$SG168477 DB	'bind_device_ex', 00H
	ORG $+1
$SG168478 DB	'sockdev.c', 00H
	ORG $+6
$SG168479 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168481 DB	'bind_device_ex', 00H
	ORG $+1
$SG168482 DB	'sockdev.c', 00H
	ORG $+14
$SG168483 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168485 DB	'sockdev.c:550', 00H
	ORG $+2
$SG168487 DB	'HHC01042%s %1d:%04X COMM: device bound to socket %s', 0aH
	DB	00H
	ORG $+3
$SG168488 DB	'bind_device_ex', 00H
	ORG $+1
$SG168489 DB	'sockdev.c', 00H
	ORG $+6
$SG168523 DB	'HHC01043%s %1d:%04X COMM: device not bound to any socket'
	DB	0aH, 00H
	ORG $+6
$SG168524 DB	'unbind_device_ex', 00H
	ORG $+7
$SG168525 DB	'sockdev.c', 00H
	ORG $+14
$SG168530 DB	'HHC01044%s %1d:%04X COMM: client %s, IP %s disconnected '
	DB	'from device %s', 0aH, 00H
$SG168531 DB	'unbind_device_ex', 00H
	ORG $+7
$SG168532 DB	'sockdev.c', 00H
	ORG $+6
$SG168534 DB	'HHC01045%s %1d:%04X COMM: client %s, IP %s still connect'
	DB	'ed to device %s', 0aH, 00H
	ORG $+7
$SG168535 DB	'unbind_device_ex', 00H
	ORG $+7
$SG168536 DB	'sockdev.c', 00H
	ORG $+6
$SG168537 DB	'sockdev.c:601', 00H
	ORG $+2
$SG168538 DB	'sockdev.c:604', 00H
	ORG $+2
$SG168540 DB	'sockdev.c:604', 00H
	ORG $+2
$SG168543 DB	'unbind_device_ex', 00H
	ORG $+7
$SG168544 DB	'sockdev.c', 00H
	ORG $+6
$SG168545 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168547 DB	'unbind_device_ex', 00H
	ORG $+7
$SG168548 DB	'sockdev.c', 00H
	ORG $+6
$SG168549 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168551 DB	'sockdev.c:606', 00H
	ORG $+2
$SG168553 DB	'HHC01046%s %1d:%04X COMM: device unbound from socket %s', 0aH
	DB	00H
	ORG $+7
$SG168554 DB	'unbind_device_ex', 00H
	ORG $+7
$SG168555 DB	'sockdev.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:socket_thread
	DD	01cH
	DD	0466H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:socket_device_connection_handler
	DD	016H
	DD	07afH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:inet_socket
	DD	017H
	DD	03c0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:bind_device_ex
	DD	026H
	DD	088cH
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$bind_device_ex DD 032e19H
	DD	024011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0118H
$unwind$unbind_device_ex DD 021001H
	DD	01d0110H
$unwind$init_sockdev DD 010401H
	DD	04204H
$unwind$term_sockdev DD 010901H
	DD	06209H
$unwind$unix_socket DD 010901H
	DD	08209H
$unwind$inet_socket DD 031f19H
	DD	03a010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	01c0H
$unwind$add_socket_devices_to_fd_set DD 010d01H
	DD	0620dH
$unwind$socket_device_connection_handler DD 021e19H
	DD	01f010cH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$check_socket_devices_for_connections DD 010901H
	DD	06209H
$unwind$socket_thread DD 022419H
	DD	04170112H
	DD	imagerel __GSHandlerCheck
	DD	020a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sockdev.c
_TEXT	SEGMENT
c$1 = 80
maxfd$ = 84
tv128 = 88
f$2 = 92
tv183 = 96
select_errno$ = 100
tv71 = 104
tv76 = 108
saved_errno$3 = 112
exit_now$ = 116
rc$ = 120
tv205 = 124
tv210 = 128
tv190 = 136
sockset$ = 144
__$ArrayPad$ = 8352
arg$ = 8384
socket_thread PROC

; 398  : {

$LN33:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 b8 20 00 00	 mov	 eax, 8376		; 000020b8H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 a0
	20 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 399  :     int     rc;
; 400  :     fd_set  sockset;
; 401  :     int     maxfd = 0;

  00024	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR maxfd$[rsp], 0
$LN4@socket_thr:

; 402  :     int     select_errno;
; 403  :     int     exit_now;
; 404  : 
; 405  :     UNREFERENCED( arg );

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN4@socket_thr

; 406  : 
; 407  :     set_thread_priority( sysblk.srvprio );

  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00038	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168361
  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00046	8b 91 74 13 00
	00		 mov	 edx, DWORD PTR [rcx+4980]
  0004c	8b c8		 mov	 ecx, eax
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_prio

; 408  : 
; 409  :     /* Display thread started message on control panel */
; 410  :     LOG_THREAD_BEGIN( SOCKET_THREAD_NAME  );

  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168363
  00061	8b c8		 mov	 ecx, eax
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  00069	89 44 24 68	 mov	 DWORD PTR tv71[rsp], eax
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00073	89 44 24 6c	 mov	 DWORD PTR tv76[rsp], eax
  00077	b9 01 00 00 00	 mov	 ecx, 1
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168362
  00089	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0008e	8b 4c 24 68	 mov	 ecx, DWORD PTR tv71[rsp]
  00092	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00096	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv76[rsp]
  0009a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168364
  000a5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168365
  000b1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bb	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168366
  000c8	ba 9a 01 00 00	 mov	 edx, 410		; 0000019aH
  000cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168367
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@socket_thr:

; 411  : 
; 412  :     for (;;)
; 413  :     {
; 414  :         /* Set the file descriptors for select */
; 415  :         FD_ZERO( &sockset );

  000da	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sockset$[rsp], 0

; 416  :         maxfd = add_socket_devices_to_fd_set(     0,   &sockset );

  000e5	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR sockset$[rsp]
  000ed	33 c9		 xor	 ecx, ecx
  000ef	e8 00 00 00 00	 call	 add_socket_devices_to_fd_set
  000f4	89 44 24 54	 mov	 DWORD PTR maxfd$[rsp], eax
$LN10@socket_thr:

; 417  :         SUPPORT_WAKEUP_SOCKDEV_SELECT_VIA_PIPE( maxfd, &sockset );

  000f8	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR sockset$[rsp]
  00100	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00107	8b 88 e8 10 00
	00		 mov	 ecx, DWORD PTR [rax+4328]
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET
  00113	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011a	8b 80 e8 10 00
	00		 mov	 eax, DWORD PTR [rax+4328]
  00120	39 44 24 54	 cmp	 DWORD PTR maxfd$[rsp], eax
  00124	7e 0a		 jle	 SHORT $LN29@socket_thr
  00126	8b 44 24 54	 mov	 eax, DWORD PTR maxfd$[rsp]
  0012a	89 44 24 58	 mov	 DWORD PTR tv128[rsp], eax
  0012e	eb 11		 jmp	 SHORT $LN30@socket_thr
$LN29@socket_thr:
  00130	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00137	8b 80 e8 10 00
	00		 mov	 eax, DWORD PTR [rax+4328]
  0013d	89 44 24 58	 mov	 DWORD PTR tv128[rsp], eax
$LN30@socket_thr:
  00141	8b 44 24 58	 mov	 eax, DWORD PTR tv128[rsp]
  00145	89 44 24 54	 mov	 DWORD PTR maxfd$[rsp], eax
  00149	33 c0		 xor	 eax, eax
  0014b	85 c0		 test	 eax, eax
  0014d	75 a9		 jne	 SHORT $LN10@socket_thr

; 418  : 
; 419  :         /* Do the select and save results */
; 420  :         rc = select( maxfd+1, &sockset, NULL, NULL, NULL );

  0014f	8b 44 24 54	 mov	 eax, DWORD PTR maxfd$[rsp]
  00153	ff c0		 inc	 eax
  00155	c7 44 24 30 a4
	01 00 00	 mov	 DWORD PTR [rsp+48], 420	; 000001a4H
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168368
  00164	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00169	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00172	45 33 c9	 xor	 r9d, r9d
  00175	45 33 c0	 xor	 r8d, r8d
  00178	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR sockset$[rsp]
  00180	8b c8		 mov	 ecx, eax
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_select
  00188	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 421  :         select_errno = HSO_errno;

  0018c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00192	89 44 24 64	 mov	 DWORD PTR select_errno$[rsp], eax
$LN13@socket_thr:

; 422  : 
; 423  :         /* Clear the pipe signal if necessary */
; 424  :         RECV_SOCKDEV_THREAD_PIPE_SIGNAL();

  00196	c6 44 24 50 00	 mov	 BYTE PTR c$1[rsp], 0
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  001a1	89 44 24 70	 mov	 DWORD PTR saved_errno$3[rsp], eax
  001a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ac	48 05 d8 10 00
	00		 add	 rax, 4312		; 000010d8H
  001b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168369
  001b9	48 8b c8	 mov	 rcx, rax
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  001c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c9	8b 80 e0 10 00
	00		 mov	 eax, DWORD PTR [rax+4320]
  001cf	89 44 24 5c	 mov	 DWORD PTR f$2[rsp], eax
  001d3	83 7c 24 5c 01	 cmp	 DWORD PTR f$2[rsp], 1
  001d8	7c 11		 jl	 SHORT $LN20@socket_thr
  001da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001e1	c7 80 e0 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4320], 0
$LN20@socket_thr:
  001eb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001f2	48 05 d8 10 00
	00		 add	 rax, 4312		; 000010d8H
  001f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168371
  001ff	48 8b c8	 mov	 rcx, rax
  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
  00208	83 7c 24 5c 01	 cmp	 DWORD PTR f$2[rsp], 1
  0020d	0f 8c 90 00 00
	00		 jl	 $LN21@socket_thr
$LN16@socket_thr:
  00213	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0021a	48 63 80 e8 10
	00 00		 movsxd	 rax, DWORD PTR [rax+4328]
  00221	45 33 c9	 xor	 r9d, r9d
  00224	41 b8 01 00 00
	00		 mov	 r8d, 1
  0022a	48 8d 54 24 50	 lea	 rdx, QWORD PTR c$1[rsp]
  0022f	48 8b c8	 mov	 rcx, rax
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  00238	83 f8 01	 cmp	 eax, 1
  0023b	74 5c		 je	 SHORT $LN22@socket_thr
$LN19@socket_thr:
  0023d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168374
  00244	41 b8 a8 01 00
	00		 mov	 r8d, 424		; 000001a8H
  0024a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168375
  00251	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168376
  00258	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0025e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00264	85 c0		 test	 eax, eax
  00266	74 20		 je	 SHORT $LN23@socket_thr
  00268	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168378
  0026f	41 b8 a8 01 00
	00		 mov	 r8d, 424		; 000001a8H
  00275	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168379
  0027c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168380
  00283	e8 00 00 00 00	 call	 DebuggerTrace
$LN23@socket_thr:
  00288	33 c0		 xor	 eax, eax
  0028a	85 c0		 test	 eax, eax
  0028c	75 af		 jne	 SHORT $LN19@socket_thr
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00294	85 c0		 test	 eax, eax
  00296	74 01		 je	 SHORT $LN24@socket_thr
  00298	cc		 int	 3
$LN24@socket_thr:
$LN22@socket_thr:
  00299	33 c0		 xor	 eax, eax
  0029b	85 c0		 test	 eax, eax
  0029d	0f 85 70 ff ff
	ff		 jne	 $LN16@socket_thr
$LN21@socket_thr:
  002a3	8b 4c 24 70	 mov	 ecx, DWORD PTR saved_errno$3[rsp]
  002a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSASetLastError
  002ad	33 c0		 xor	 eax, eax
  002af	85 c0		 test	 eax, eax
  002b1	0f 85 df fe ff
	ff		 jne	 $LN13@socket_thr

; 425  : 
; 426  :         /* Check if it's time to exit yet */
; 427  :         obtain_lock( &sysblk.bindlock );

  002b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002be	48 83 c0 78	 add	 rax, 120		; 00000078H
  002c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168382
  002c9	48 8b c8	 mov	 rcx, rax
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 428  :         {
; 429  :             exit_now = (sysblk.shutdown || IsListEmpty( &bind_head ));

  002d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002d9	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  002df	c1 e8 0b	 shr	 eax, 11
  002e2	83 e0 01	 and	 eax, 1
  002e5	85 c0		 test	 eax, eax
  002e7	75 1a		 jne	 SHORT $LN31@socket_thr
  002e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:bind_head
  002f0	48 39 05 00 00
	00 00		 cmp	 QWORD PTR bind_head, rax
  002f7	74 0a		 je	 SHORT $LN31@socket_thr
  002f9	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv183[rsp], 0
  00301	eb 08		 jmp	 SHORT $LN32@socket_thr
$LN31@socket_thr:
  00303	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv183[rsp], 1
$LN32@socket_thr:
  0030b	8b 44 24 60	 mov	 eax, DWORD PTR tv183[rsp]
  0030f	89 44 24 74	 mov	 DWORD PTR exit_now$[rsp], eax

; 430  :         }
; 431  :         release_lock( &sysblk.bindlock );

  00313	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0031a	48 83 c0 78	 add	 rax, 120		; 00000078H
  0031e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168383
  00325	48 8b c8	 mov	 rcx, rax
  00328	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 432  : 
; 433  :         if (exit_now)

  0032e	83 7c 24 74 00	 cmp	 DWORD PTR exit_now$[rsp], 0
  00333	74 05		 je	 SHORT $LN25@socket_thr

; 434  :             break;

  00335	e9 9e 00 00 00	 jmp	 $LN6@socket_thr
$LN25@socket_thr:

; 435  : 
; 436  :         /* Log select errors */
; 437  :         if (rc < 0)

  0033a	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  0033f	0f 8d 81 00 00
	00		 jge	 $LN26@socket_thr

; 438  :         {
; 439  :             if (HSO_EINTR != select_errno)

  00345	81 7c 24 64 14
	27 00 00	 cmp	 DWORD PTR select_errno$[rsp], 10004 ; 00002714H
  0034d	74 72		 je	 SHORT $LN27@socket_thr

; 440  :                 // "COMM: error in function %s: %s"
; 441  :                 WRMSG( HHC01034, "E", "select()", strerror( select_errno ));

  0034f	8b 4c 24 64	 mov	 ecx, DWORD PTR select_errno$[rsp]
  00353	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00359	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv190[rsp], rax
  00361	b9 01 00 00 00	 mov	 ecx, 1
  00366	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0036c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv190[rsp]
  00374	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00379	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168387
  00380	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00385	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168388
  0038c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00391	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168389
  00398	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0039d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a2	41 b9 03 00 00
	00		 mov	 r9d, 3
  003a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168390
  003af	ba b9 01 00 00	 mov	 edx, 441		; 000001b9H
  003b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168391
  003bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN27@socket_thr:

; 442  :             continue;

  003c1	e9 14 fd ff ff	 jmp	 $LN5@socket_thr
$LN26@socket_thr:

; 443  :         }
; 444  : 
; 445  :         /* Check if any sockets have received new connections */
; 446  :         check_socket_devices_for_connections( &sockset );

  003c6	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR sockset$[rsp]
  003ce	e8 00 00 00 00	 call	 check_socket_devices_for_connections

; 447  :     }

  003d3	e9 02 fd ff ff	 jmp	 $LN5@socket_thr
$LN6@socket_thr:

; 448  : 
; 449  :     LOG_THREAD_END( SOCKET_THREAD_NAME  );

  003d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  003de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168393
  003e5	8b c8		 mov	 ecx, eax
  003e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  003ed	89 44 24 7c	 mov	 DWORD PTR tv205[rsp], eax
  003f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  003f7	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv210[rsp], eax
  003fe	b9 01 00 00 00	 mov	 ecx, 1
  00403	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00409	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168392
  00410	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00415	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv205[rsp]
  00419	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0041d	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv210[rsp]
  00424	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00428	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168394
  0042f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00434	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168395
  0043b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00440	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00445	41 b9 03 00 00
	00		 mov	 r9d, 3
  0044b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168396
  00452	ba c1 01 00 00	 mov	 edx, 449		; 000001c1H
  00457	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168397
  0045e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 450  : 
; 451  :     return NULL;

  00464	33 c0		 xor	 eax, eax

; 452  : }

  00466	48 8b 8c 24 a0
	20 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0046e	48 33 cc	 xor	 rcx, rsp
  00471	e8 00 00 00 00	 call	 __security_check_cookie
  00476	48 81 c4 b8 20
	00 00		 add	 rsp, 8376		; 000020b8H
  0047d	c3		 ret	 0
socket_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sockdev.c
_TEXT	SEGMENT
pListEntry$ = 32
bs$ = 40
readset$ = 64
check_socket_devices_for_connections PROC

; 365  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 366  :     bind_struct*  bs;
; 367  :     LIST_ENTRY*   pListEntry;
; 368  : 
; 369  :     obtain_lock( &sysblk.bindlock );

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 83 c0 78	 add	 rax, 120		; 00000078H
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168318
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 370  :     {
; 371  :         pListEntry = bind_head.Flink;

  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR bind_head
  0002b	48 89 44 24 20	 mov	 QWORD PTR pListEntry$[rsp], rax
$LN2@check_sock:

; 372  : 
; 373  :         while (pListEntry != &bind_head)

  00030	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:bind_head
  00037	48 39 44 24 20	 cmp	 QWORD PTR pListEntry$[rsp], rax
  0003c	74 62		 je	 SHORT $LN3@check_sock

; 374  :         {
; 375  :             bs = CONTAINING_RECORD( pListEntry, bind_struct, bind_link );

  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR pListEntry$[rsp]
  00043	48 89 44 24 28	 mov	 QWORD PTR bs$[rsp], rax

; 376  : 
; 377  :             if (bs->sd >= 0 && FD_ISSET( bs->sd, readset ))

  00048	48 8b 44 24 28	 mov	 rax, QWORD PTR bs$[rsp]
  0004d	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  00051	7c 3e		 jl	 SHORT $LN4@check_sock
  00053	48 8b 54 24 40	 mov	 rdx, QWORD PTR readset$[rsp]
  00058	48 8b 44 24 28	 mov	 rax, QWORD PTR bs$[rsp]
  0005d	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  00066	85 c0		 test	 eax, eax
  00068	74 27		 je	 SHORT $LN4@check_sock

; 378  :             {
; 379  :                 /* Note: there may be other connection requests
; 380  :                  * waiting to be serviced, but we'll catch them
; 381  :                  * the next time the panel thread calls us. */
; 382  : 
; 383  :                 release_lock( &sysblk.bindlock );

  0006a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00071	48 83 c0 78	 add	 rax, 120		; 00000078H
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168320
  0007c	48 8b c8	 mov	 rcx, rax
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 384  :                 socket_device_connection_handler( bs );

  00085	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bs$[rsp]
  0008a	e8 00 00 00 00	 call	 socket_device_connection_handler

; 385  :                 return;

  0008f	eb 2a		 jmp	 SHORT $LN1@check_sock
$LN4@check_sock:

; 386  :             }
; 387  : 
; 388  :             pListEntry = pListEntry->Flink;

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR pListEntry$[rsp]
  00096	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00099	48 89 44 24 20	 mov	 QWORD PTR pListEntry$[rsp], rax

; 389  :         }

  0009e	eb 90		 jmp	 SHORT $LN2@check_sock
$LN3@check_sock:

; 390  :     }
; 391  :     release_lock( &sysblk.bindlock );

  000a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a7	48 83 c0 78	 add	 rax, 120		; 00000078H
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168321
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@check_sock:

; 392  : }

  000bb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bf	c3		 ret	 0
check_socket_devices_for_connections ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sockdev.c
_TEXT	SEGMENT
dev$ = 112
csock$ = 120
clientip$ = 128
clientname$ = 136
tv79 = 144
tv85 = 148
tv187 = 152
tv193 = 156
tv221 = 160
tv227 = 164
tv273 = 168
tv279 = 172
tv300 = 176
tv306 = 180
pHE$ = 184
namelen$ = 192
tv71 = 200
client$ = 208
__$ArrayPad$ = 224
bs$ = 256
socket_device_connection_handler PROC

; 254  : {

$LN32:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 255  :     struct sockaddr_in  client;         /* Client address structure  */
; 256  :     struct hostent*     pHE;            /* Addr of hostent structure */
; 257  :     socklen_t           namelen;        /* Length of client structure*/
; 258  :     char*               clientip;       /* Addr of client ip address */
; 259  :     char*               clientname;     /* Addr of client hostname   */
; 260  :     DEVBLK*             dev;            /* Device Block pointer      */
; 261  :     int                 csock;          /* Client socket             */
; 262  : 
; 263  :     dev = bs->dev;

  0001e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR bs$[rsp]
  00026	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0002a	48 89 44 24 70	 mov	 QWORD PTR dev$[rsp], rax

; 264  : 
; 265  :     DEBUGMSG("socket_device_connection_handler(dev=%4.4X)\n",
; 266  :         dev->devnum);
; 267  : 
; 268  :     /* Accept the connection... */
; 269  : 
; 270  :     if ((csock = accept( bs->sd, NULL, NULL )) < 0)

  0002f	45 33 c0	 xor	 r8d, r8d
  00032	33 d2		 xor	 edx, edx
  00034	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR bs$[rsp]
  0003c	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_accept
  00045	89 44 24 78	 mov	 DWORD PTR csock$[rsp], eax
  00049	83 7c 24 78 00	 cmp	 DWORD PTR csock$[rsp], 0
  0004e	0f 8d dd 00 00
	00		 jge	 $LN2@socket_dev

; 271  :     {
; 272  :         // "%1d:%04X COMM: error in function %s: %s"
; 273  :         WRMSG( HHC01000, "E", LCSS_DEVNUM, "accept()", strerror( HSO_errno ));

  00054	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0005a	74 12		 je	 SHORT $LN12@socket_dev
  0005c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00061	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00065	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv79[rsp], eax
  0006c	eb 0b		 jmp	 SHORT $LN13@socket_dev
$LN12@socket_dev:
  0006e	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv79[rsp], 0
$LN13@socket_dev:
  00079	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0007f	74 14		 je	 SHORT $LN14@socket_dev
  00081	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00086	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0008a	d1 f8		 sar	 eax, 1
  0008c	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv85[rsp], eax
  00093	eb 0b		 jmp	 SHORT $LN15@socket_dev
$LN14@socket_dev:
  00095	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv85[rsp], 0
$LN15@socket_dev:
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000a6	8b c8		 mov	 ecx, eax
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000ae	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv71[rsp], rax
  000b6	b9 01 00 00 00	 mov	 ecx, 1
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv71[rsp]
  000c9	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168270
  000d5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000da	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv79[rsp]
  000e1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000e5	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv85[rsp]
  000ec	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168271
  000f7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168272
  00103	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00108	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00113	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168273
  0011a	ba 11 01 00 00	 mov	 edx, 273		; 00000111H
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168274
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 274  :         return;

  0012c	e9 7e 06 00 00	 jmp	 $LN1@socket_dev
$LN2@socket_dev:

; 275  :     }
; 276  : 
; 277  :     /* Determine the connected client's IP address and hostname */
; 278  : 
; 279  :     namelen    = sizeof( client );

  00131	c7 84 24 c0 00
	00 00 10 00 00
	00		 mov	 DWORD PTR namelen$[rsp], 16

; 280  :     clientip   = NULL;

  0013c	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR clientip$[rsp], 0

; 281  :     clientname = "<unknown>";

  00148	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168275
  0014f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR clientname$[rsp], rax

; 282  : 
; 283  :     if (1
; 284  :         && getpeername( csock, (struct sockaddr*) &client, &namelen ) == 0
; 285  :         && (clientip = inet_ntoa( client.sin_addr )) != NULL
; 286  :         && (pHE = gethostbyaddr( (unsigned char*)(&client.sin_addr),
; 287  :             sizeof( client.sin_addr ), AF_INET )) != NULL
; 288  :         &&  pHE->h_name
; 289  :         && *pHE->h_name

  00157	33 c0		 xor	 eax, eax
  00159	83 f8 01	 cmp	 eax, 1
  0015c	0f 84 a1 00 00
	00		 je	 $LN3@socket_dev
  00162	48 63 44 24 78	 movsxd	 rax, DWORD PTR csock$[rsp]
  00167	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR namelen$[rsp]
  0016f	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR client$[rsp]
  00177	48 8b c8	 mov	 rcx, rax
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpeername
  00180	85 c0		 test	 eax, eax
  00182	75 7f		 jne	 SHORT $LN3@socket_dev
  00184	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR client$[rsp+4]
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00191	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR clientip$[rsp], rax
  00199	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR clientip$[rsp], 0
  001a2	74 5f		 je	 SHORT $LN3@socket_dev
  001a4	41 b8 02 00 00
	00		 mov	 r8d, 2
  001aa	ba 04 00 00 00	 mov	 edx, 4
  001af	48 8d 8c 24 d4
	00 00 00	 lea	 rcx, QWORD PTR client$[rsp+4]
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gethostbyaddr
  001bd	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pHE$[rsp], rax
  001c5	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR pHE$[rsp], 0
  001ce	74 33		 je	 SHORT $LN3@socket_dev
  001d0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pHE$[rsp]
  001d8	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001dc	74 25		 je	 SHORT $LN3@socket_dev
  001de	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pHE$[rsp]
  001e6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001ec	85 c0		 test	 eax, eax
  001ee	74 13		 je	 SHORT $LN3@socket_dev

; 290  :         )
; 291  :     {
; 292  :         clientname = (char*) pHE->h_name;

  001f0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pHE$[rsp]
  001f8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001fb	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR clientname$[rsp], rax
$LN3@socket_dev:

; 293  :     }
; 294  : 
; 295  :     if (!clientip)

  00203	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR clientip$[rsp], 0
  0020c	75 0f		 jne	 SHORT $LN4@socket_dev

; 296  :         clientip = "<unknown>";

  0020e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168278
  00215	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR clientip$[rsp], rax
$LN4@socket_dev:

; 297  : 
; 298  :     /* Obtain the device lock */
; 299  : 
; 300  :     obtain_lock( &dev->lock );

  0021d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00222	48 83 c0 38	 add	 rax, 56			; 00000038H
  00226	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168279
  0022d	48 8b c8	 mov	 rcx, rax
  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 301  :     {
; 302  :         /* Reject if device is busy or interrupt pending */
; 303  : 
; 304  :         if (0
; 305  :             || dev->busy
; 306  :             || IOPENDING( dev )
; 307  :             || (dev->scsw.flag3 & SCSW3_SC_PEND)

  00236	33 c0		 xor	 eax, eax
  00238	85 c0		 test	 eax, eax
  0023a	0f 85 80 00 00
	00		 jne	 $LN6@socket_dev
  00240	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00245	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0024b	c1 e8 13	 shr	 eax, 19
  0024e	83 e0 01	 and	 eax, 1
  00251	85 c0		 test	 eax, eax
  00253	75 6b		 jne	 SHORT $LN6@socket_dev
  00255	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0025a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00260	c1 e8 16	 shr	 eax, 22
  00263	83 e0 01	 and	 eax, 1
  00266	85 c0		 test	 eax, eax
  00268	75 56		 jne	 SHORT $LN6@socket_dev
  0026a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0026f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00275	c1 e8 17	 shr	 eax, 23
  00278	83 e0 01	 and	 eax, 1
  0027b	85 c0		 test	 eax, eax
  0027d	75 41		 jne	 SHORT $LN6@socket_dev
  0027f	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00284	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0028a	c1 e8 18	 shr	 eax, 24
  0028d	83 e0 01	 and	 eax, 1
  00290	85 c0		 test	 eax, eax
  00292	75 2c		 jne	 SHORT $LN6@socket_dev
  00294	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00299	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0029f	c1 e8 1b	 shr	 eax, 27
  002a2	83 e0 01	 and	 eax, 1
  002a5	85 c0		 test	 eax, eax
  002a7	75 17		 jne	 SHORT $LN6@socket_dev
  002a9	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002ae	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  002b5	83 e0 01	 and	 eax, 1
  002b8	85 c0		 test	 eax, eax
  002ba	0f 84 fc 00 00
	00		 je	 $LN5@socket_dev
$LN6@socket_dev:

; 308  :         )
; 309  :         {
; 310  :             close_socket( csock );

  002c0	8b 4c 24 78	 mov	 ecx, DWORD PTR csock$[rsp]
  002c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 311  :             // "%1d:%04X COMM: client %s, IP %s connection to device %s rejected: device busy or interrupt pending"
; 312  :             WRMSG( HHC01037, "E", LCSS_DEVNUM, clientname, clientip, bs->spec );

  002ca	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002d0	74 12		 je	 SHORT $LN16@socket_dev
  002d2	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002d7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002db	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv187[rsp], eax
  002e2	eb 0b		 jmp	 SHORT $LN17@socket_dev
$LN16@socket_dev:
  002e4	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv187[rsp], 0
$LN17@socket_dev:
  002ef	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002f5	74 14		 je	 SHORT $LN18@socket_dev
  002f7	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002fc	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00300	d1 f8		 sar	 eax, 1
  00302	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv193[rsp], eax
  00309	eb 0b		 jmp	 SHORT $LN19@socket_dev
$LN18@socket_dev:
  0030b	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv193[rsp], 0
$LN19@socket_dev:
  00316	b9 01 00 00 00	 mov	 ecx, 1
  0031b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00321	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  00329	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0032d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00332	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR clientip$[rsp]
  0033a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0033f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR clientname$[rsp]
  00347	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0034c	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv187[rsp]
  00353	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00357	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv193[rsp]
  0035e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00362	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168282
  00369	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0036e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168283
  00375	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0037a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0037f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00385	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168284
  0038c	ba 38 01 00 00	 mov	 edx, 312		; 00000138H
  00391	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168285
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 313  :             release_lock( &dev->lock );

  0039e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  003a3	48 83 c0 38	 add	 rax, 56			; 00000038H
  003a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168286
  003ae	48 8b c8	 mov	 rcx, rax
  003b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 314  :             return;

  003b7	e9 f3 03 00 00	 jmp	 $LN1@socket_dev
$LN5@socket_dev:

; 315  :         }
; 316  : 
; 317  :         /* Reject new client if previous client still connected */
; 318  : 
; 319  :         if (dev->fd >= 0)

  003bc	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  003c1	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  003c8	0f 8c 1e 01 00
	00		 jl	 $LN7@socket_dev

; 320  :         {
; 321  :             close_socket( csock );

  003ce	8b 4c 24 78	 mov	 ecx, DWORD PTR csock$[rsp]
  003d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 322  :             // "%1d:%04X COMM: client %s, IP %s connection to device %s rejected: client %s ip %s still connected"
; 323  :             WRMSG( HHC01038, "E", LCSS_DEVNUM, clientname, clientip, bs->spec,

  003d8	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  003de	74 12		 je	 SHORT $LN20@socket_dev
  003e0	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  003e5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003e9	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv221[rsp], eax
  003f0	eb 0b		 jmp	 SHORT $LN21@socket_dev
$LN20@socket_dev:
  003f2	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv221[rsp], 0
$LN21@socket_dev:
  003fd	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00403	74 14		 je	 SHORT $LN22@socket_dev
  00405	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0040a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0040e	d1 f8		 sar	 eax, 1
  00410	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv227[rsp], eax
  00417	eb 0b		 jmp	 SHORT $LN23@socket_dev
$LN22@socket_dev:
  00419	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv227[rsp], 0
$LN23@socket_dev:
  00424	b9 01 00 00 00	 mov	 ecx, 1
  00429	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0042f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  00437	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  0043b	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00440	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  00448	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0044c	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00451	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  00459	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0045d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00462	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR clientip$[rsp]
  0046a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0046f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR clientname$[rsp]
  00477	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0047c	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv221[rsp]
  00483	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00487	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv227[rsp]
  0048e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00492	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168288
  00499	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0049e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168289
  004a5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004af	41 b9 03 00 00
	00		 mov	 r9d, 3
  004b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168290
  004bc	ba 44 01 00 00	 mov	 edx, 324		; 00000144H
  004c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168291
  004c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 324  :                 bs->clientname, bs->clientip );
; 325  :             release_lock( &dev->lock );

  004ce	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  004d3	48 83 c0 38	 add	 rax, 56			; 00000038H
  004d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168292
  004de	48 8b c8	 mov	 rcx, rax
  004e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 326  :             return;

  004e7	e9 c3 02 00 00	 jmp	 $LN1@socket_dev
$LN7@socket_dev:

; 327  :         }
; 328  : 
; 329  :         /* Indicate that a client is now connected to this device */
; 330  : 
; 331  :         dev->fd = csock;

  004ec	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  004f1	8b 4c 24 78	 mov	 ecx, DWORD PTR csock$[rsp]
  004f5	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx

; 332  : 
; 333  :         if (bs->clientip)   free( bs->clientip   );

  004fb	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR bs$[rsp]
  00503	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00508	74 12		 je	 SHORT $LN8@socket_dev
  0050a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR bs$[rsp]
  00512	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00516	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN8@socket_dev:

; 334  :         if (bs->clientname) free( bs->clientname );

  0051c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR bs$[rsp]
  00524	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00529	74 12		 je	 SHORT $LN9@socket_dev
  0052b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR bs$[rsp]
  00533	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00537	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN9@socket_dev:

; 335  : 
; 336  :         bs->clientip   = strdup( clientip   );

  0053d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR clientip$[rsp]
  00545	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0054b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  00553	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 337  :         bs->clientname = strdup( clientname );

  00557	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR clientname$[rsp]
  0055f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00565	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  0056d	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 338  : 
; 339  :         /* Call the boolean onconnect callback */
; 340  : 
; 341  :         if (bs->fn && !bs->fn( bs->arg ))

  00571	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR bs$[rsp]
  00579	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0057e	0f 84 31 01 00
	00		 je	 $LN10@socket_dev
  00584	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR bs$[rsp]
  0058c	48 8b 48 40	 mov	 rcx, QWORD PTR [rax+64]
  00590	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR bs$[rsp]
  00598	ff 50 38	 call	 QWORD PTR [rax+56]
  0059b	85 c0		 test	 eax, eax
  0059d	0f 85 12 01 00
	00		 jne	 $LN10@socket_dev

; 342  :         {
; 343  :             /* Callback says it can't accept it */
; 344  :             close_socket( dev->fd );

  005a3	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  005a8	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  005ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 345  :             dev->fd = -1;

  005b4	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  005b9	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 346  :             // "%1d:%04X COMM: client %s, IP %s connection to device %s rejected: by onconnect callback"
; 347  :             WRMSG( HHC01039, "E", LCSS_DEVNUM, clientname, clientip, bs->spec );

  005c3	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  005c9	74 12		 je	 SHORT $LN24@socket_dev
  005cb	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  005d0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005d4	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv273[rsp], eax
  005db	eb 0b		 jmp	 SHORT $LN25@socket_dev
$LN24@socket_dev:
  005dd	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv273[rsp], 0
$LN25@socket_dev:
  005e8	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  005ee	74 14		 je	 SHORT $LN26@socket_dev
  005f0	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  005f5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  005f9	d1 f8		 sar	 eax, 1
  005fb	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv279[rsp], eax
  00602	eb 0b		 jmp	 SHORT $LN27@socket_dev
$LN26@socket_dev:
  00604	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv279[rsp], 0
$LN27@socket_dev:
  0060f	b9 01 00 00 00	 mov	 ecx, 1
  00614	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0061a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  00622	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00626	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0062b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR clientip$[rsp]
  00633	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00638	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR clientname$[rsp]
  00640	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00645	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv273[rsp]
  0064c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00650	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv279[rsp]
  00657	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0065b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168296
  00662	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00667	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168297
  0066e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00673	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00678	41 b9 03 00 00
	00		 mov	 r9d, 3
  0067e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168298
  00685	ba 5b 01 00 00	 mov	 edx, 347		; 0000015bH
  0068a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168299
  00691	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 348  :             release_lock( &dev->lock );

  00697	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0069c	48 83 c0 38	 add	 rax, 56			; 00000038H
  006a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168300
  006a7	48 8b c8	 mov	 rcx, rax
  006aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 349  :             return;

  006b0	e9 fa 00 00 00	 jmp	 $LN1@socket_dev
$LN10@socket_dev:

; 350  :         }
; 351  : 
; 352  :         // "%1d:%04X COMM: client %s, IP %s connected to device %s"
; 353  :         WRMSG( HHC01040, "I", LCSS_DEVNUM, clientname, clientip, bs->spec );

  006b5	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  006bb	74 12		 je	 SHORT $LN28@socket_dev
  006bd	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  006c2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006c6	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv300[rsp], eax
  006cd	eb 0b		 jmp	 SHORT $LN29@socket_dev
$LN28@socket_dev:
  006cf	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv300[rsp], 0
$LN29@socket_dev:
  006da	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  006e0	74 14		 je	 SHORT $LN30@socket_dev
  006e2	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  006e7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  006eb	d1 f8		 sar	 eax, 1
  006ed	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv306[rsp], eax
  006f4	eb 0b		 jmp	 SHORT $LN31@socket_dev
$LN30@socket_dev:
  006f6	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv306[rsp], 0
$LN31@socket_dev:
  00701	b9 01 00 00 00	 mov	 ecx, 1
  00706	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0070c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR bs$[rsp]
  00714	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00718	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0071d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR clientip$[rsp]
  00725	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0072a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR clientname$[rsp]
  00732	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00737	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv300[rsp]
  0073e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00742	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv306[rsp]
  00749	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0074d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168301
  00754	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00759	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168302
  00760	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00765	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0076a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00770	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168303
  00777	ba 61 01 00 00	 mov	 edx, 353		; 00000161H
  0077c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168304
  00783	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 354  :     }
; 355  :     release_lock( &dev->lock );

  00789	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0078e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00792	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168305
  00799	48 8b c8	 mov	 rcx, rax
  0079c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 356  : 
; 357  :     device_attention( dev, CSW_DE );

  007a2	b2 04		 mov	 dl, 4
  007a4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  007a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_device_attention
$LN1@socket_dev:

; 358  : }

  007af	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007b7	48 33 cc	 xor	 rcx, rsp
  007ba	e8 00 00 00 00	 call	 __security_check_cookie
  007bf	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  007c6	c3		 ret	 0
socket_device_connection_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sockdev.c
_TEXT	SEGMENT
bs$ = 32
pListEntry$ = 40
maxfd$ = 64
readset$ = 72
add_socket_devices_to_fd_set PROC

; 221  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 222  :     bind_struct*  bs;
; 223  :     LIST_ENTRY*   pListEntry;
; 224  : 
; 225  :     obtain_lock( &sysblk.bindlock );

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00014	48 83 c0 78	 add	 rax, 120		; 00000078H
  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168242
  0001f	48 8b c8	 mov	 rcx, rax
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 226  :     {
; 227  :         pListEntry = bind_head.Flink;

  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR bind_head
  0002f	48 89 44 24 28	 mov	 QWORD PTR pListEntry$[rsp], rax
$LN2@add_socket:

; 228  : 
; 229  :         while (pListEntry != &bind_head)

  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:bind_head
  0003b	48 39 44 24 28	 cmp	 QWORD PTR pListEntry$[rsp], rax
  00040	74 51		 je	 SHORT $LN3@add_socket

; 230  :         {
; 231  :             bs = CONTAINING_RECORD( pListEntry, bind_struct, bind_link );

  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR pListEntry$[rsp]
  00047	48 89 44 24 20	 mov	 QWORD PTR bs$[rsp], rax

; 232  : 
; 233  :             if (bs->sd != -1)      /* if listening for connections, */

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR bs$[rsp]
  00051	83 78 20 ff	 cmp	 DWORD PTR [rax+32], -1
  00055	74 2d		 je	 SHORT $LN4@add_socket

; 234  :             {
; 235  :                 FD_SET( bs->sd, readset );  /* then add file to set */

  00057	48 8b 54 24 48	 mov	 rdx, QWORD PTR readset$[rsp]
  0005c	48 8b 44 24 20	 mov	 rax, QWORD PTR bs$[rsp]
  00061	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 236  : 
; 237  :                 if (bs->sd > maxfd)

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR bs$[rsp]
  0006f	8b 4c 24 40	 mov	 ecx, DWORD PTR maxfd$[rsp]
  00073	39 48 20	 cmp	 DWORD PTR [rax+32], ecx
  00076	7e 0c		 jle	 SHORT $LN5@add_socket

; 238  :                     maxfd = bs->sd;

  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR bs$[rsp]
  0007d	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00080	89 44 24 40	 mov	 DWORD PTR maxfd$[rsp], eax
$LN5@add_socket:
$LN4@add_socket:

; 239  :             }
; 240  : 
; 241  :             pListEntry = pListEntry->Flink;

  00084	48 8b 44 24 28	 mov	 rax, QWORD PTR pListEntry$[rsp]
  00089	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008c	48 89 44 24 28	 mov	 QWORD PTR pListEntry$[rsp], rax

; 242  :         }

  00091	eb a1		 jmp	 SHORT $LN2@add_socket
$LN3@add_socket:

; 243  :     }
; 244  :     release_lock( &sysblk.bindlock );

  00093	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009a	48 83 c0 78	 add	 rax, 120		; 00000078H
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168245
  000a5	48 8b c8	 mov	 rcx, rax
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 245  : 
; 246  :     return maxfd;

  000ae	8b 44 24 40	 mov	 eax, DWORD PTR maxfd$[rsp]

; 247  : }

  000b2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b6	c3		 ret	 0
add_socket_devices_to_fd_set ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sockdev.c
_TEXT	SEGMENT
sd$ = 80
service$ = 88
node$ = 96
one$ = 104
colon$ = 112
he$1 = 120
se$2 = 128
tv164 = 136
tv196 = 144
sin$ = 152
buf$ = 176
__$ArrayPad$ = 448
spec$ = 480
inet_socket PROC

; 128  : {

$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec d0 01
	00 00		 sub	 rsp, 464		; 000001d0H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 129  :     /* We need a copy of the path to overwrite a ':' with '\0' */
; 130  : 
; 131  :     char buf[sizeof(((DEVBLK*)0)->filename)];
; 132  :     char* colon;
; 133  :     char* node;
; 134  :     char* service;
; 135  :     int sd;
; 136  :     int one = 1;

  0001f	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR one$[rsp], 1

; 137  :     struct sockaddr_in sin;
; 138  : 
; 139  :     DEBUGMSG("inet_socket(%s)\n", spec);
; 140  : 
; 141  :     memset( &sin, 0, sizeof( sin ));

  00027	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR sin$[rsp]
  0002f	48 8b f8	 mov	 rdi, rax
  00032	33 c0		 xor	 eax, eax
  00034	b9 10 00 00 00	 mov	 ecx, 16
  00039	f3 aa		 rep stosb

; 142  : 
; 143  :     sin.sin_family = AF_INET;

  0003b	b8 02 00 00 00	 mov	 eax, 2
  00040	66 89 84 24 98
	00 00 00	 mov	 WORD PTR sin$[rsp], ax

; 144  :     STRLCPY( buf, spec );

  00048	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  0004e	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR spec$[rsp]
  00056	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 145  :     colon = strchr( buf, ':' );

  00064	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  00069	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00071	e8 00 00 00 00	 call	 strchr
  00076	48 89 44 24 70	 mov	 QWORD PTR colon$[rsp], rax

; 146  : 
; 147  :     if (colon)

  0007b	48 83 7c 24 70
	00		 cmp	 QWORD PTR colon$[rsp], 0
  00081	74 24		 je	 SHORT $LN2@inet_socke

; 148  :     {
; 149  :         *colon = '\0';

  00083	48 8b 44 24 70	 mov	 rax, QWORD PTR colon$[rsp]
  00088	c6 00 00	 mov	 BYTE PTR [rax], 0

; 150  :         node = buf;

  0008b	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00093	48 89 44 24 60	 mov	 QWORD PTR node$[rsp], rax

; 151  :         service = colon + 1;

  00098	48 8b 44 24 70	 mov	 rax, QWORD PTR colon$[rsp]
  0009d	48 ff c0	 inc	 rax
  000a0	48 89 44 24 58	 mov	 QWORD PTR service$[rsp], rax

; 152  :     }

  000a5	eb 16		 jmp	 SHORT $LN3@inet_socke
$LN2@inet_socke:

; 153  :     else
; 154  :     {
; 155  :         node = NULL;

  000a7	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR node$[rsp], 0

; 156  :         service = buf;

  000b0	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  000b8	48 89 44 24 58	 mov	 QWORD PTR service$[rsp], rax
$LN3@inet_socke:

; 157  :     }
; 158  : 
; 159  :     if (!node)

  000bd	48 83 7c 24 60
	00		 cmp	 QWORD PTR node$[rsp], 0
  000c3	75 10		 jne	 SHORT $LN4@inet_socke

; 160  :         sin.sin_addr.s_addr = INADDR_ANY;

  000c5	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sin$[rsp+4], 0
  000d0	e9 92 00 00 00	 jmp	 $LN5@inet_socke
$LN4@inet_socke:

; 161  :     else
; 162  :     {
; 163  :         struct hostent* he = gethostbyname( node );

  000d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR node$[rsp]
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gethostbyname
  000e0	48 89 44 24 78	 mov	 QWORD PTR he$1[rsp], rax

; 164  : 
; 165  :         if (!he)

  000e5	48 83 7c 24 78
	00		 cmp	 QWORD PTR he$1[rsp], 0
  000eb	75 5b		 jne	 SHORT $LN6@inet_socke

; 166  :         {
; 167  :             // "COMM: failed to determine IP address from node %s"
; 168  :             WRMSG( HHC01035, "E", node );

  000ed	b9 01 00 00 00	 mov	 ecx, 1
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR node$[rsp]
  000fd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168203
  00109	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168204
  00115	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0011a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00125	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168205
  0012c	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  00131	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168206
  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 169  :             return -1;

  0013e	b8 ff ff ff ff	 mov	 eax, -1
  00143	e9 78 02 00 00	 jmp	 $LN1@inet_socke
$LN6@inet_socke:

; 170  :         }
; 171  : 
; 172  :         memcpy( &sin.sin_addr, he->h_addr_list[0], sizeof( sin.sin_addr ));

  00148	b8 08 00 00 00	 mov	 eax, 8
  0014d	48 6b c0 00	 imul	 rax, rax, 0
  00151	48 8b 4c 24 78	 mov	 rcx, QWORD PTR he$1[rsp]
  00156	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0015a	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  0015e	8b 00		 mov	 eax, DWORD PTR [rax]
  00160	89 84 24 9c 00
	00 00		 mov	 DWORD PTR sin$[rsp+4], eax
$LN5@inet_socke:

; 173  :     }
; 174  : 
; 175  :     if (isdigit( service[0] ))

  00167	b8 01 00 00 00	 mov	 eax, 1
  0016c	48 6b c0 00	 imul	 rax, rax, 0
  00170	48 8b 4c 24 58	 mov	 rcx, QWORD PTR service$[rsp]
  00175	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00179	8b c8		 mov	 ecx, eax
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00181	85 c0		 test	 eax, eax
  00183	74 21		 je	 SHORT $LN7@inet_socke

; 176  :     {
; 177  :         sin.sin_port = htons( atoi( service ));

  00185	48 8b 4c 24 58	 mov	 rcx, QWORD PTR service$[rsp]
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00190	0f b7 c8	 movzx	 ecx, ax
  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  00199	66 89 84 24 9a
	00 00 00	 mov	 WORD PTR sin$[rsp+2], ax

; 178  :     }

  001a1	e9 94 00 00 00	 jmp	 $LN8@inet_socke
$LN7@inet_socke:

; 179  :     else
; 180  :     {
; 181  :         struct servent* se = getservbyname( service, "tcp" );

  001a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168209
  001ad	48 8b 4c 24 58	 mov	 rcx, QWORD PTR service$[rsp]
  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getservbyname
  001b8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR se$2[rsp], rax

; 182  : 
; 183  :         if (!se)

  001c0	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR se$2[rsp], 0
  001c9	75 5b		 jne	 SHORT $LN9@inet_socke

; 184  :         {
; 185  :             // "COMM: failed to determine port number from service %s"
; 186  :             WRMSG( HHC01036, "E", service );

  001cb	b9 01 00 00 00	 mov	 ecx, 1
  001d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001d6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR service$[rsp]
  001db	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168211
  001e7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168212
  001f3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fd	41 b9 03 00 00
	00		 mov	 r9d, 3
  00203	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168213
  0020a	ba ba 00 00 00	 mov	 edx, 186		; 000000baH
  0020f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168214
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 187  :             return -1;

  0021c	b8 ff ff ff ff	 mov	 eax, -1
  00221	e9 9a 01 00 00	 jmp	 $LN1@inet_socke
$LN9@inet_socke:

; 188  :         }
; 189  : 
; 190  :         sin.sin_port = se->s_port;

  00226	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR se$2[rsp]
  0022e	0f b7 40 18	 movzx	 eax, WORD PTR [rax+24]
  00232	66 89 84 24 9a
	00 00 00	 mov	 WORD PTR sin$[rsp+2], ax
$LN8@inet_socke:

; 191  :     }
; 192  : 
; 193  :     if ((sd = socket( PF_INET, SOCK_STREAM, 0 )) < 0)

  0023a	45 33 c0	 xor	 r8d, r8d
  0023d	ba 01 00 00 00	 mov	 edx, 1
  00242	b9 02 00 00 00	 mov	 ecx, 2
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_socket
  0024d	89 44 24 50	 mov	 DWORD PTR sd$[rsp], eax
  00251	83 7c 24 50 00	 cmp	 DWORD PTR sd$[rsp], 0
  00256	0f 8d 80 00 00
	00		 jge	 $LN10@inet_socke

; 194  :     {
; 195  :         // "COMM: error in function %s: %s"
; 196  :         WRMSG( HHC01034, "E", "socket()", strerror( HSO_errno ));

  0025c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00262	8b c8		 mov	 ecx, eax
  00264	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0026a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv164[rsp], rax
  00272	b9 01 00 00 00	 mov	 ecx, 1
  00277	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0027d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv164[rsp]
  00285	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0028a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168216
  00291	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168217
  0029d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168218
  002a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  002b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168219
  002c0	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  002c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168220
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 197  :         return -1;

  002d2	b8 ff ff ff ff	 mov	 eax, -1
  002d7	e9 e4 00 00 00	 jmp	 $LN1@inet_socke
$LN10@inet_socke:

; 198  :     }
; 199  : 
; 200  :     setsockopt( sd, SOL_SOCKET, SO_REUSEADDR, (GETSET_SOCKOPT_T*) &one, sizeof( one ));

  002dc	48 63 44 24 50	 movsxd	 rax, DWORD PTR sd$[rsp]
  002e1	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  002e9	4c 8d 4c 24 68	 lea	 r9, QWORD PTR one$[rsp]
  002ee	41 b8 04 00 00
	00		 mov	 r8d, 4
  002f4	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  002f9	48 8b c8	 mov	 rcx, rax
  002fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 201  : 
; 202  :     if (0
; 203  :         || bind( sd, (struct sockaddr*) &sin, sizeof( sin )) < 0
; 204  :         || listen( sd, 1 ) < 0

  00302	33 c0		 xor	 eax, eax
  00304	85 c0		 test	 eax, eax
  00306	75 37		 jne	 SHORT $LN12@inet_socke
  00308	48 63 44 24 50	 movsxd	 rax, DWORD PTR sd$[rsp]
  0030d	41 b8 10 00 00
	00		 mov	 r8d, 16
  00313	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR sin$[rsp]
  0031b	48 8b c8	 mov	 rcx, rax
  0031e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  00324	85 c0		 test	 eax, eax
  00326	7c 17		 jl	 SHORT $LN12@inet_socke
  00328	48 63 44 24 50	 movsxd	 rax, DWORD PTR sd$[rsp]
  0032d	ba 01 00 00 00	 mov	 edx, 1
  00332	48 8b c8	 mov	 rcx, rax
  00335	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_listen
  0033b	85 c0		 test	 eax, eax
  0033d	7d 7d		 jge	 SHORT $LN11@inet_socke
$LN12@inet_socke:

; 205  :         )
; 206  :     {
; 207  :         // "COMM: error in function %s: %s"
; 208  :         WRMSG( HHC01034, "E", "bind()", strerror( HSO_errno ));

  0033f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00345	8b c8		 mov	 ecx, eax
  00347	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0034d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv196[rsp], rax
  00355	b9 01 00 00 00	 mov	 ecx, 1
  0035a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00360	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv196[rsp]
  00368	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0036d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168223
  00374	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00379	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168224
  00380	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00385	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168225
  0038c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00391	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00396	41 b9 03 00 00
	00		 mov	 r9d, 3
  0039c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168226
  003a3	ba d0 00 00 00	 mov	 edx, 208		; 000000d0H
  003a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168227
  003af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 209  :         return -1;

  003b5	b8 ff ff ff ff	 mov	 eax, -1
  003ba	eb 04		 jmp	 SHORT $LN1@inet_socke
$LN11@inet_socke:

; 210  :     }
; 211  : 
; 212  :     return sd;

  003bc	8b 44 24 50	 mov	 eax, DWORD PTR sd$[rsp]
$LN1@inet_socke:

; 213  : }

  003c0	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003c8	48 33 cc	 xor	 rcx, rsp
  003cb	e8 00 00 00 00	 call	 __security_check_cookie
  003d0	48 81 c4 d0 01
	00 00		 add	 rsp, 464		; 000001d0H
  003d7	5f		 pop	 rdi
  003d8	c3		 ret	 0
inet_socket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sockdev.c
_TEXT	SEGMENT
path$ = 80
unix_socket PROC

; 75   : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@unix_socke:

; 76   : #if !defined( HAVE_SYS_UN_H )
; 77   :     UNREFERENCED( path );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@unix_socke

; 78   :     // "COMM: this hercules build does not support unix domain sockets"
; 79   :     WRMSG( HHC01032, "E" );

  0000f	b9 01 00 00 00	 mov	 ecx, 1
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168173
  00021	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168174
  0002d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00037	41 b9 03 00 00
	00		 mov	 r9d, 3
  0003d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168175
  00044	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168176
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 80   :     return -1;

  00056	b8 ff ff ff ff	 mov	 eax, -1

; 81   : #else
; 82   : 
; 83   :     struct sockaddr_un addr;
; 84   :     int sd;
; 85   : 
; 86   :     DEBUGMSG( "unix_socket(%s)\n", path );
; 87   : 
; 88   :     if (strlen( path ) > sizeof( addr.sun_path ) - 1)
; 89   :     {
; 90   :         // "COMM: error: socket pathname %s exceeds limit %d"
; 91   :         WRMSG( HHC01033, "E", path, (int) sizeof( addr.sun_path ) - 1 );
; 92   :         return -1;
; 93   :     }
; 94   : 
; 95   :     addr.sun_family = AF_UNIX;
; 96   :     STRLCPY( addr.sun_path, path ); /* guaranteed room by above check */
; 97   : 
; 98   :     if ((sd = socket( PF_UNIX, SOCK_STREAM, 0 )) < 0)
; 99   :     {
; 100  :         // "COMM: error in function %s: %s"
; 101  :         WRMSG( HHC01034, "E", "socket()", strerror( HSO_errno ));
; 102  :         return -1;
; 103  :     }
; 104  : 
; 105  :     unlink( path );         // (i.e. delete file/folder)
; 106  :     fchmod( sd, 0700 );     // (remove group permissions)
; 107  : 
; 108  :     if (0
; 109  :         || bind( sd, (struct sockaddr*) &addr, sizeof( addr )) < 0
; 110  :         || listen( sd, 1 ) < 0
; 111  :         )
; 112  :     {
; 113  :         // "COMM: error in function %s: %s"
; 114  :         WRMSG( HHC01034, "E", "bind()", strerror( HSO_errno ));
; 115  :         return -1;
; 116  :     }
; 117  : 
; 118  :     return sd;
; 119  : 
; 120  : #endif // defined( HAVE_SYS_UN_H )
; 121  : }

  0005b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005f	c3		 ret	 0
unix_socket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sockdev.c
_TEXT	SEGMENT
c$1 = 32
f$2 = 36
saved_errno$3 = 40
arg$ = 64
term_sockdev PROC

; 62   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@term_sockd:

; 63   :     UNREFERENCED( arg );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@term_sockd

; 64   :     if (!init_done) init_sockdev();

  0000f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR init_done, 0
  00016	75 05		 jne	 SHORT $LN14@term_sockd
  00018	e8 00 00 00 00	 call	 init_sockdev
$LN14@term_sockd:
$LN7@term_sockd:

; 65   :     SIGNAL_SOCKDEV_THREAD();

  0001d	c6 44 24 20 00	 mov	 BYTE PTR c$1[rsp], 0
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00028	89 44 24 28	 mov	 DWORD PTR saved_errno$3[rsp], eax
  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00033	48 05 d8 10 00
	00		 add	 rax, 4312		; 000010d8H
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168151
  00040	48 8b c8	 mov	 rcx, rax
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  00049	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00050	8b 80 e0 10 00
	00		 mov	 eax, DWORD PTR [rax+4320]
  00056	89 44 24 24	 mov	 DWORD PTR f$2[rsp], eax
  0005a	83 7c 24 24 00	 cmp	 DWORD PTR f$2[rsp], 0
  0005f	7f 11		 jg	 SHORT $LN15@term_sockd
  00061	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00068	c7 80 e0 10 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4320], 1
$LN15@term_sockd:
  00072	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00079	48 05 d8 10 00
	00		 add	 rax, 4312		; 000010d8H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168153
  00086	48 8b c8	 mov	 rcx, rax
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
  0008f	83 7c 24 24 00	 cmp	 DWORD PTR f$2[rsp], 0
  00094	0f 8f 90 00 00
	00		 jg	 $LN16@term_sockd
$LN10@term_sockd:
  0009a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a1	48 63 80 e4 10
	00 00		 movsxd	 rax, DWORD PTR [rax+4324]
  000a8	45 33 c9	 xor	 r9d, r9d
  000ab	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b1	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$1[rsp]
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  000bf	83 f8 01	 cmp	 eax, 1
  000c2	74 5c		 je	 SHORT $LN17@term_sockd
$LN13@term_sockd:
  000c4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168156
  000cb	41 b8 41 00 00
	00		 mov	 r8d, 65			; 00000041H
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168157
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168158
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000eb	85 c0		 test	 eax, eax
  000ed	74 20		 je	 SHORT $LN18@term_sockd
  000ef	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168160
  000f6	41 b8 41 00 00
	00		 mov	 r8d, 65			; 00000041H
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168161
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168162
  0010a	e8 00 00 00 00	 call	 DebuggerTrace
$LN18@term_sockd:
  0010f	33 c0		 xor	 eax, eax
  00111	85 c0		 test	 eax, eax
  00113	75 af		 jne	 SHORT $LN13@term_sockd
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0011b	85 c0		 test	 eax, eax
  0011d	74 01		 je	 SHORT $LN19@term_sockd
  0011f	cc		 int	 3
$LN19@term_sockd:
$LN17@term_sockd:
  00120	33 c0		 xor	 eax, eax
  00122	85 c0		 test	 eax, eax
  00124	0f 85 70 ff ff
	ff		 jne	 $LN10@term_sockd
$LN16@term_sockd:
  0012a	8b 4c 24 28	 mov	 ecx, DWORD PTR saved_errno$3[rsp]
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSASetLastError
  00134	33 c0		 xor	 eax, eax
  00136	85 c0		 test	 eax, eax
  00138	0f 85 df fe ff
	ff		 jne	 $LN7@term_sockd

; 66   :     join_thread   ( sysblk.socktid, NULL );

  0013e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168164
  00145	33 d2		 xor	 edx, edx
  00147	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0014e	8b 88 ac 10 00
	00		 mov	 ecx, DWORD PTR [rax+4268]
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_join_thread

; 67   :     detach_thread ( sysblk.socktid );

  0015a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168165
  00161	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00168	8b 88 ac 10 00
	00		 mov	 ecx, DWORD PTR [rax+4268]
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_detach_thread

; 68   : }

  00174	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00178	c3		 ret	 0
term_sockdev ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sockdev.c
_TEXT	SEGMENT
init_sockdev PROC

; 48   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 49   :     obtain_lock( &sysblk.bindlock );

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	48 83 c0 78	 add	 rax, 120		; 00000078H
  0000f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168125
  00016	48 8b c8	 mov	 rcx, rax
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 50   :     {
; 51   :         if (!init_done)

  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR init_done, 0
  00026	75 3d		 jne	 SHORT $LN2@init_sockd

; 52   :         {
; 53   :             InitializeListHead( &bind_head );

  00028	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:bind_head
  0002f	48 89 05 08 00
	00 00		 mov	 QWORD PTR bind_head+8, rax
  00036	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR bind_head+8
  0003d	48 89 05 00 00
	00 00		 mov	 QWORD PTR bind_head, rax

; 54   :             hdl_addshut( "term_sockdev", term_sockdev, NULL );

  00044	45 33 c0	 xor	 r8d, r8d
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:term_sockdev
  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168127
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_addshut

; 55   :             init_done = TRUE;

  0005b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR init_done, 1
$LN2@init_sockd:

; 56   :         }
; 57   :     }
; 58   :     release_lock( &sysblk.bindlock );

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 c0 78	 add	 rax, 120		; 00000078H
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168128
  00077	48 8b c8	 mov	 rcx, rax
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 59   : }

  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	c3		 ret	 0
init_sockdev ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sockdev.c
_TEXT	SEGMENT
c$1 = 96
bs$ = 104
tv69 = 112
tv75 = 116
tv136 = 120
tv142 = 124
tv165 = 128
tv171 = 132
f$2 = 136
tv232 = 140
tv238 = 144
saved_errno$3 = 148
_EX_Flink$4 = 152
_EX_Blink$5 = 160
tv273 = 168
tv272 = 176
tv271 = 184
tv270 = 192
tv269 = 200
tv268 = 208
dev$ = 240
forced$ = 248
unbind_device_ex PROC

; 564  : {

$LN40:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 565  :     bind_struct* bs;
; 566  : 
; 567  :     DEBUGMSG("unbind_device(%4.4X)\n", dev->devnum);
; 568  : 
; 569  :     /* Error if device not bound */
; 570  :     if (!(bs = dev->bs))

  00010	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00018	48 8b 80 b8 01
	00 00		 mov	 rax, QWORD PTR [rax+440]
  0001f	48 89 44 24 68	 mov	 QWORD PTR bs$[rsp], rax
  00024	48 83 7c 24 68
	00		 cmp	 QWORD PTR bs$[rsp], 0
  0002a	0f 85 aa 00 00
	00		 jne	 $LN11@unbind_dev

; 571  :     {
; 572  :         // "%1d:%04X COMM: device not bound to any socket"
; 573  :         WRMSG( HHC01043, "E", LCSS_DEVNUM );

  00030	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00039	74 12		 je	 SHORT $LN24@unbind_dev
  0003b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00043	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00047	89 44 24 70	 mov	 DWORD PTR tv69[rsp], eax
  0004b	eb 08		 jmp	 SHORT $LN25@unbind_dev
$LN24@unbind_dev:
  0004d	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN25@unbind_dev:
  00055	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0005e	74 14		 je	 SHORT $LN26@unbind_dev
  00060	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00068	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0006c	d1 f8		 sar	 eax, 1
  0006e	89 44 24 74	 mov	 DWORD PTR tv75[rsp], eax
  00072	eb 08		 jmp	 SHORT $LN27@unbind_dev
$LN26@unbind_dev:
  00074	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN27@unbind_dev:
  0007c	b9 01 00 00 00	 mov	 ecx, 1
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00087	8b 4c 24 70	 mov	 ecx, DWORD PTR tv69[rsp]
  0008b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0008f	8b 4c 24 74	 mov	 ecx, DWORD PTR tv75[rsp]
  00093	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168522
  0009e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168523
  000aa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b4	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168524
  000c1	ba 3d 02 00 00	 mov	 edx, 573		; 0000023dH
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168525
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 574  :         return 0;   /* (failure) */

  000d3	33 c0		 xor	 eax, eax
  000d5	e9 b6 05 00 00	 jmp	 $LN1@unbind_dev
$LN11@unbind_dev:

; 575  :     }
; 576  : 
; 577  :     /* Is anyone still connected? */
; 578  :     if (dev->fd >= 0)

  000da	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e2	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  000e9	0f 8c 88 02 00
	00		 jl	 $LN12@unbind_dev

; 579  :     {
; 580  :         /* Yes. Should we forcibly disconnect them? */
; 581  :         if (forced)

  000ef	83 bc 24 f8 00
	00 00 00	 cmp	 DWORD PTR forced$[rsp], 0
  000f7	0f 84 46 01 00
	00		 je	 $LN13@unbind_dev

; 582  :         {
; 583  :             /* Yes. Then do so... */
; 584  :             close_socket( dev->fd );

  000fd	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00105	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 585  :             dev->fd = -1;

  00111	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00119	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 586  :             // "%1d:%04X COMM: client %s, IP %s disconnected from device %s"
; 587  :             WRMSG( HHC01044, "I", LCSS_DEVNUM, dev->bs->clientip,

  00123	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0012c	74 12		 je	 SHORT $LN28@unbind_dev
  0012e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00136	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0013a	89 44 24 78	 mov	 DWORD PTR tv136[rsp], eax
  0013e	eb 08		 jmp	 SHORT $LN29@unbind_dev
$LN28@unbind_dev:
  00140	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN29@unbind_dev:
  00148	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00151	74 14		 je	 SHORT $LN30@unbind_dev
  00153	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0015b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0015f	d1 f8		 sar	 eax, 1
  00161	89 44 24 7c	 mov	 DWORD PTR tv142[rsp], eax
  00165	eb 08		 jmp	 SHORT $LN31@unbind_dev
$LN30@unbind_dev:
  00167	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN31@unbind_dev:
  0016f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00177	48 8b 80 b8 01
	00 00		 mov	 rax, QWORD PTR [rax+440]
  0017e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv273[rsp], rax
  00186	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018e	48 8b 89 b8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+440]
  00195	48 89 8c 24 b0
	00 00 00	 mov	 QWORD PTR tv272[rsp], rcx
  0019d	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001a5	48 8b 92 b8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+440]
  001ac	48 89 94 24 b8
	00 00 00	 mov	 QWORD PTR tv271[rsp], rdx
  001b4	b9 01 00 00 00	 mov	 ecx, 1
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001bf	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv273[rsp]
  001c7	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001cb	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001d0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv272[rsp]
  001d8	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001dc	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001e1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv271[rsp]
  001e9	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  001ed	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001f2	8b 4c 24 78	 mov	 ecx, DWORD PTR tv136[rsp]
  001f6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001fa	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv142[rsp]
  001fe	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168529
  00209	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168530
  00215	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0021f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00225	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168531
  0022c	ba 4c 02 00 00	 mov	 edx, 588		; 0000024cH
  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168532
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 588  :                    dev->bs->clientname, dev->bs->spec );
; 589  :         }

  0023e	e9 34 01 00 00	 jmp	 $LN14@unbind_dev
$LN13@unbind_dev:

; 590  :         else
; 591  :         {
; 592  :             /* No. Then fail the request. */
; 593  :             // "%1d:%04X COMM: client %s, IP %s still connected to device %s"
; 594  :             WRMSG( HHC01045, "E", LCSS_DEVNUM, dev->bs->clientip,

  00243	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0024c	74 15		 je	 SHORT $LN32@unbind_dev
  0024e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00256	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0025a	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv165[rsp], eax
  00261	eb 0b		 jmp	 SHORT $LN33@unbind_dev
$LN32@unbind_dev:
  00263	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv165[rsp], 0
$LN33@unbind_dev:
  0026e	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00277	74 17		 je	 SHORT $LN34@unbind_dev
  00279	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00281	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00285	d1 f8		 sar	 eax, 1
  00287	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv171[rsp], eax
  0028e	eb 0b		 jmp	 SHORT $LN35@unbind_dev
$LN34@unbind_dev:
  00290	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv171[rsp], 0
$LN35@unbind_dev:
  0029b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a3	48 8b 80 b8 01
	00 00		 mov	 rax, QWORD PTR [rax+440]
  002aa	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv270[rsp], rax
  002b2	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002ba	48 8b 89 b8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+440]
  002c1	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv269[rsp], rcx
  002c9	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002d1	48 8b 92 b8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+440]
  002d8	48 89 94 24 d0
	00 00 00	 mov	 QWORD PTR tv268[rsp], rdx
  002e0	b9 01 00 00 00	 mov	 ecx, 1
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002eb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv270[rsp]
  002f3	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  002f7	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002fc	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv269[rsp]
  00304	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00308	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0030d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv268[rsp]
  00315	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00319	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0031e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv165[rsp]
  00325	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00329	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv171[rsp]
  00330	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00334	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168533
  0033b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00340	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168534
  00347	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0034c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00351	41 b9 03 00 00
	00		 mov	 r9d, 3
  00357	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168535
  0035e	ba 53 02 00 00	 mov	 edx, 595		; 00000253H
  00363	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168536
  0036a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 595  :                    dev->bs->clientname, dev->bs->spec );
; 596  :             return 0;   /* (failure) */

  00370	33 c0		 xor	 eax, eax
  00372	e9 19 03 00 00	 jmp	 $LN1@unbind_dev
$LN14@unbind_dev:
$LN12@unbind_dev:

; 597  :         }
; 598  :     }
; 599  : 
; 600  :     /* Remove the entry from our list */
; 601  :     obtain_lock( &sysblk.bindlock );

  00377	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0037e	48 83 c0 78	 add	 rax, 120		; 00000078H
  00382	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168537
  00389	48 8b c8	 mov	 rcx, rax
  0038c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 602  :     {
; 603  :         RemoveListEntry( &bs->bind_link );

  00392	48 8b 44 24 68	 mov	 rax, QWORD PTR bs$[rsp]
  00397	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0039a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR _EX_Flink$4[rsp], rax
  003a2	48 8b 44 24 68	 mov	 rax, QWORD PTR bs$[rsp]
  003a7	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003ab	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR _EX_Blink$5[rsp], rax
  003b3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR _EX_Blink$5[rsp]
  003bb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR _EX_Flink$4[rsp]
  003c3	48 89 08	 mov	 QWORD PTR [rax], rcx
  003c6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR _EX_Flink$4[rsp]
  003ce	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR _EX_Blink$5[rsp]
  003d6	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN4@unbind_dev:

; 604  :         SIGNAL_SOCKDEV_THREAD();

  003da	c6 44 24 60 00	 mov	 BYTE PTR c$1[rsp], 0
  003df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  003e5	89 84 24 94 00
	00 00		 mov	 DWORD PTR saved_errno$3[rsp], eax
  003ec	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003f3	48 05 d8 10 00
	00		 add	 rax, 4312		; 000010d8H
  003f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168538
  00400	48 8b c8	 mov	 rcx, rax
  00403	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  00409	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00410	8b 80 e0 10 00
	00		 mov	 eax, DWORD PTR [rax+4320]
  00416	89 84 24 88 00
	00 00		 mov	 DWORD PTR f$2[rsp], eax
  0041d	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR f$2[rsp], 0
  00425	7f 11		 jg	 SHORT $LN15@unbind_dev
  00427	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0042e	c7 80 e0 10 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4320], 1
$LN15@unbind_dev:
  00438	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0043f	48 05 d8 10 00
	00		 add	 rax, 4312		; 000010d8H
  00445	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168540
  0044c	48 8b c8	 mov	 rcx, rax
  0044f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
  00455	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR f$2[rsp], 0
  0045d	0f 8f 90 00 00
	00		 jg	 $LN16@unbind_dev
$LN7@unbind_dev:
  00463	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0046a	48 63 80 e4 10
	00 00		 movsxd	 rax, DWORD PTR [rax+4324]
  00471	45 33 c9	 xor	 r9d, r9d
  00474	41 b8 01 00 00
	00		 mov	 r8d, 1
  0047a	48 8d 54 24 60	 lea	 rdx, QWORD PTR c$1[rsp]
  0047f	48 8b c8	 mov	 rcx, rax
  00482	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  00488	83 f8 01	 cmp	 eax, 1
  0048b	74 5c		 je	 SHORT $LN17@unbind_dev
$LN10@unbind_dev:
  0048d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168543
  00494	41 b8 5c 02 00
	00		 mov	 r8d, 604		; 0000025cH
  0049a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168544
  004a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168545
  004a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  004ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004b4	85 c0		 test	 eax, eax
  004b6	74 20		 je	 SHORT $LN18@unbind_dev
  004b8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168547
  004bf	41 b8 5c 02 00
	00		 mov	 r8d, 604		; 0000025cH
  004c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168548
  004cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168549
  004d3	e8 00 00 00 00	 call	 DebuggerTrace
$LN18@unbind_dev:
  004d8	33 c0		 xor	 eax, eax
  004da	85 c0		 test	 eax, eax
  004dc	75 af		 jne	 SHORT $LN10@unbind_dev
  004de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004e4	85 c0		 test	 eax, eax
  004e6	74 01		 je	 SHORT $LN19@unbind_dev
  004e8	cc		 int	 3
$LN19@unbind_dev:
$LN17@unbind_dev:
  004e9	33 c0		 xor	 eax, eax
  004eb	85 c0		 test	 eax, eax
  004ed	0f 85 70 ff ff
	ff		 jne	 $LN7@unbind_dev
$LN16@unbind_dev:
  004f3	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR saved_errno$3[rsp]
  004fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSASetLastError
  00500	33 c0		 xor	 eax, eax
  00502	85 c0		 test	 eax, eax
  00504	0f 85 d0 fe ff
	ff		 jne	 $LN4@unbind_dev

; 605  :     }
; 606  :     release_lock( &sysblk.bindlock );

  0050a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00511	48 83 c0 78	 add	 rax, 120		; 00000078H
  00515	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168551
  0051c	48 8b c8	 mov	 rcx, rax
  0051f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 607  : 
; 608  :     // "%1d:%04X COMM: device unbound from socket %s"
; 609  :     WRMSG( HHC01046, "I",LCSS_DEVNUM, bs->spec );

  00525	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0052e	74 15		 je	 SHORT $LN36@unbind_dev
  00530	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00538	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0053c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv232[rsp], eax
  00543	eb 0b		 jmp	 SHORT $LN37@unbind_dev
$LN36@unbind_dev:
  00545	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv232[rsp], 0
$LN37@unbind_dev:
  00550	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00559	74 17		 je	 SHORT $LN38@unbind_dev
  0055b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00563	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00567	d1 f8		 sar	 eax, 1
  00569	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv238[rsp], eax
  00570	eb 0b		 jmp	 SHORT $LN39@unbind_dev
$LN38@unbind_dev:
  00572	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv238[rsp], 0
$LN39@unbind_dev:
  0057d	b9 01 00 00 00	 mov	 ecx, 1
  00582	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00588	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bs$[rsp]
  0058d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00591	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00596	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv232[rsp]
  0059d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005a1	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv238[rsp]
  005a8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168552
  005b3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168553
  005bf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005c9	41 b9 03 00 00
	00		 mov	 r9d, 3
  005cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168554
  005d6	ba 61 02 00 00	 mov	 edx, 609		; 00000261H
  005db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168555
  005e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 610  : 
; 611  :     if (bs->sd >= 0)

  005e8	48 8b 44 24 68	 mov	 rax, QWORD PTR bs$[rsp]
  005ed	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  005f1	7c 0e		 jl	 SHORT $LN20@unbind_dev

; 612  :         close_socket( bs->sd );

  005f3	48 8b 44 24 68	 mov	 rax, QWORD PTR bs$[rsp]
  005f8	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  005fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket
$LN20@unbind_dev:

; 613  : 
; 614  :     /* Unchain device and bind_struct from each another */
; 615  : 
; 616  :     dev->bs = NULL;

  00601	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00609	48 c7 80 b8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+440], 0

; 617  :     bs->dev = NULL;

  00614	48 8b 44 24 68	 mov	 rax, QWORD PTR bs$[rsp]
  00619	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 618  : 
; 619  :     /* Discard the entry */
; 620  : 
; 621  :     if ( bs->clientname ) free( bs->clientname );

  00621	48 8b 44 24 68	 mov	 rax, QWORD PTR bs$[rsp]
  00626	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0062b	74 0f		 je	 SHORT $LN21@unbind_dev
  0062d	48 8b 44 24 68	 mov	 rax, QWORD PTR bs$[rsp]
  00632	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00636	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN21@unbind_dev:

; 622  :     if ( bs->clientip   ) free( bs->clientip   );

  0063c	48 8b 44 24 68	 mov	 rax, QWORD PTR bs$[rsp]
  00641	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00646	74 0f		 je	 SHORT $LN22@unbind_dev
  00648	48 8b 44 24 68	 mov	 rax, QWORD PTR bs$[rsp]
  0064d	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  00651	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN22@unbind_dev:

; 623  : 
; 624  :     bs->clientname = NULL;

  00657	48 8b 44 24 68	 mov	 rax, QWORD PTR bs$[rsp]
  0065c	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 625  :     bs->clientip   = NULL;

  00664	48 8b 44 24 68	 mov	 rax, QWORD PTR bs$[rsp]
  00669	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 626  : 
; 627  :     free ( bs->spec );

  00671	48 8b 44 24 68	 mov	 rax, QWORD PTR bs$[rsp]
  00676	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0067a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 628  :     free ( bs );

  00680	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bs$[rsp]
  00685	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 629  : 
; 630  :     return 1;   /* (success) */

  0068b	b8 01 00 00 00	 mov	 eax, 1
$LN1@unbind_dev:

; 631  : }

  00690	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00697	c3		 ret	 0
unbind_device_ex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sockdev.c
_TEXT	SEGMENT
bs$ = 96
c$1 = 104
tv77 = 108
tv83 = 112
tv144 = 116
tv150 = 120
tv179 = 124
tv185 = 128
tv221 = 132
rc$ = 136
f$2 = 140
tv308 = 144
tv314 = 148
was_list_empty$ = 152
saved_errno$3 = 156
_EX_Head$4 = 160
tv168 = 168
_EX_Tail$5 = 176
_EX_Flink$6 = 184
_EX_Blink$7 = 192
tv360 = 200
tv132 = 208
tv171 = 216
tv240 = 224
tv358 = 232
buf$8 = 240
__$ArrayPad$ = 280
dev$ = 304
spec$ = 312
fn$ = 320
arg$ = 328
bind_device_ex PROC

; 461  : {

$LN45:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 462  :     bind_struct* bs;
; 463  :     int was_list_empty;
; 464  :     int rc;
; 465  : 
; 466  :     if (!init_done)

  0002e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR init_done, 0
  00035	75 05		 jne	 SHORT $LN11@bind_devic

; 467  :         init_sockdev();

  00037	e8 00 00 00 00	 call	 init_sockdev
$LN11@bind_devic:

; 468  : 
; 469  :     if (sysblk.shutdown)

  0003c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00043	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00049	c1 e8 0b	 shr	 eax, 11
  0004c	83 e0 01	 and	 eax, 1
  0004f	85 c0		 test	 eax, eax
  00051	74 07		 je	 SHORT $LN12@bind_devic

; 470  :         return 0;

  00053	33 c0		 xor	 eax, eax
  00055	e9 32 08 00 00	 jmp	 $LN1@bind_devic
$LN12@bind_devic:

; 471  : 
; 472  :     DEBUGMSG("bind_device (%4.4X, %s)\n", dev->devnum, spec);
; 473  : 
; 474  :     /* Error if device already bound */
; 475  :     if (dev->bs)

  0005a	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00062	48 83 b8 b8 01
	00 00 00	 cmp	 QWORD PTR [rax+440], 0
  0006a	0f 84 d2 00 00
	00		 je	 $LN13@bind_devic

; 476  :     {
; 477  :         WRMSG( HHC01041, "E", LCSS_DEVNUM, dev->bs->spec );

  00070	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00079	74 12		 je	 SHORT $LN27@bind_devic
  0007b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00083	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00087	89 44 24 6c	 mov	 DWORD PTR tv77[rsp], eax
  0008b	eb 08		 jmp	 SHORT $LN28@bind_devic
$LN27@bind_devic:
  0008d	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN28@bind_devic:
  00095	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0009e	74 14		 je	 SHORT $LN29@bind_devic
  000a0	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a8	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000ac	d1 f8		 sar	 eax, 1
  000ae	89 44 24 70	 mov	 DWORD PTR tv83[rsp], eax
  000b2	eb 08		 jmp	 SHORT $LN30@bind_devic
$LN29@bind_devic:
  000b4	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN30@bind_devic:
  000bc	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c4	48 8b 80 b8 01
	00 00		 mov	 rax, QWORD PTR [rax+440]
  000cb	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv360[rsp], rax
  000d3	b9 01 00 00 00	 mov	 ecx, 1
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000de	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv360[rsp]
  000e6	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000ea	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000ef	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv77[rsp]
  000f3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f7	8b 4c 24 70	 mov	 ecx, DWORD PTR tv83[rsp]
  000fb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168443
  00106	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168444
  00112	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00117	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00122	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168445
  00129	ba dd 01 00 00	 mov	 edx, 477		; 000001ddH
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168446
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 478  :         return 0;   /* (failure) */

  0013b	33 c0		 xor	 eax, eax
  0013d	e9 4a 07 00 00	 jmp	 $LN1@bind_devic
$LN13@bind_devic:

; 479  :     }
; 480  : 
; 481  :     /* Create a new bind_struct entry */
; 482  :     bs = malloc( sizeof( bind_struct ));

  00142	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0014d	48 89 44 24 60	 mov	 QWORD PTR bs$[rsp], rax

; 483  : 
; 484  :     if (!bs)

  00152	48 83 7c 24 60
	00		 cmp	 QWORD PTR bs$[rsp], 0
  00158	0f 85 fa 00 00
	00		 jne	 $LN14@bind_devic

; 485  :     {
; 486  :         char buf[40];
; 487  :         MSGBUF( buf, "malloc(%d)", (int) sizeof( bind_struct ));

  0015e	41 b9 48 00 00
	00		 mov	 r9d, 72			; 00000048H
  00164	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168448
  0016b	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00170	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR buf$8[rsp]
  00178	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 488  :         // "%1d:%04X COMM: error in function %s: %s"
; 489  :         WRMSG( HHC01000, "E", LCSS_DEVNUM, buf, strerror( errno ));

  0017e	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00187	74 12		 je	 SHORT $LN31@bind_devic
  00189	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00191	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00195	89 44 24 74	 mov	 DWORD PTR tv144[rsp], eax
  00199	eb 08		 jmp	 SHORT $LN32@bind_devic
$LN31@bind_devic:
  0019b	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv144[rsp], 0
$LN32@bind_devic:
  001a3	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001ac	74 14		 je	 SHORT $LN33@bind_devic
  001ae	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001b6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001ba	d1 f8		 sar	 eax, 1
  001bc	89 44 24 78	 mov	 DWORD PTR tv150[rsp], eax
  001c0	eb 08		 jmp	 SHORT $LN34@bind_devic
$LN33@bind_devic:
  001c2	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv150[rsp], 0
$LN34@bind_devic:
  001ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001d0	8b 08		 mov	 ecx, DWORD PTR [rax]
  001d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001d8	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
  001e0	b9 01 00 00 00	 mov	 ecx, 1
  001e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001eb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  001f3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001f8	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR buf$8[rsp]
  00200	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00205	8b 4c 24 74	 mov	 ecx, DWORD PTR tv144[rsp]
  00209	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0020d	8b 4c 24 78	 mov	 ecx, DWORD PTR tv150[rsp]
  00211	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00215	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168449
  0021c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168450
  00228	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0022d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00232	41 b9 03 00 00
	00		 mov	 r9d, 3
  00238	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168451
  0023f	ba e9 01 00 00	 mov	 edx, 489		; 000001e9H
  00244	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168452
  0024b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 490  :         return 0;   /* (failure) */

  00251	33 c0		 xor	 eax, eax
  00253	e9 34 06 00 00	 jmp	 $LN1@bind_devic
$LN14@bind_devic:

; 491  :     }
; 492  : 
; 493  :     memset( bs, 0, sizeof( bind_struct ));

  00258	48 8b 7c 24 60	 mov	 rdi, QWORD PTR bs$[rsp]
  0025d	33 c0		 xor	 eax, eax
  0025f	b9 48 00 00 00	 mov	 ecx, 72			; 00000048H
  00264	f3 aa		 rep stosb

; 494  : 
; 495  :     bs->fn  = fn;

  00266	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  0026b	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR fn$[rsp]
  00273	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 496  :     bs->arg = arg;

  00277	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  0027c	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR arg$[rsp]
  00284	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 497  : 
; 498  :     if (!(bs->spec = strdup( spec )))

  00288	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR spec$[rsp]
  00290	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00296	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv168[rsp], rax
  0029e	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  002a3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv168[rsp]
  002ab	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
  002af	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR tv168[rsp], 0
  002b8	0f 85 ed 00 00
	00		 jne	 $LN15@bind_devic

; 499  :     {
; 500  :         // "%1d:%04X COMM: error in function %s: %s"
; 501  :         WRMSG( HHC01000, "E", LCSS_DEVNUM, "strdup()", strerror( errno ));

  002be	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002c7	74 12		 je	 SHORT $LN35@bind_devic
  002c9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002d1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002d5	89 44 24 7c	 mov	 DWORD PTR tv179[rsp], eax
  002d9	eb 08		 jmp	 SHORT $LN36@bind_devic
$LN35@bind_devic:
  002db	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv179[rsp], 0
$LN36@bind_devic:
  002e3	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002ec	74 17		 je	 SHORT $LN37@bind_devic
  002ee	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002fa	d1 f8		 sar	 eax, 1
  002fc	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv185[rsp], eax
  00303	eb 0b		 jmp	 SHORT $LN38@bind_devic
$LN37@bind_devic:
  00305	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv185[rsp], 0
$LN38@bind_devic:
  00310	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00316	8b 08		 mov	 ecx, DWORD PTR [rax]
  00318	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0031e	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv171[rsp], rax
  00326	b9 01 00 00 00	 mov	 ecx, 1
  0032b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00331	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv171[rsp]
  00339	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0033e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168454
  00345	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0034a	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv179[rsp]
  0034e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00352	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv185[rsp]
  00359	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0035d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168455
  00364	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00369	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168456
  00370	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00375	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0037a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00380	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168457
  00387	ba f5 01 00 00	 mov	 edx, 501		; 000001f5H
  0038c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168458
  00393	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 502  :         free( bs );

  00399	48 8b 4c 24 60	 mov	 rcx, QWORD PTR bs$[rsp]
  0039e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 503  :         return 0;   /* (failure) */

  003a4	33 c0		 xor	 eax, eax
  003a6	e9 e1 04 00 00	 jmp	 $LN1@bind_devic
$LN15@bind_devic:

; 504  :     }
; 505  : 
; 506  :     /* Create a listening socket */
; 507  :     if (bs->spec[0] == '/') bs->sd = unix_socket( bs->spec );

  003ab	b8 01 00 00 00	 mov	 eax, 1
  003b0	48 6b c0 00	 imul	 rax, rax, 0
  003b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR bs$[rsp]
  003b9	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  003bd	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  003c1	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  003c4	75 18		 jne	 SHORT $LN16@bind_devic
  003c6	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  003cb	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  003cf	e8 00 00 00 00	 call	 unix_socket
  003d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR bs$[rsp]
  003d9	89 41 20	 mov	 DWORD PTR [rcx+32], eax
  003dc	eb 16		 jmp	 SHORT $LN17@bind_devic
$LN16@bind_devic:

; 508  :     else                    bs->sd = inet_socket( bs->spec );

  003de	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  003e3	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  003e7	e8 00 00 00 00	 call	 inet_socket
  003ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR bs$[rsp]
  003f1	89 41 20	 mov	 DWORD PTR [rcx+32], eax
$LN17@bind_devic:

; 509  :     if (bs->sd < 0)

  003f4	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  003f9	83 78 20 00	 cmp	 DWORD PTR [rax+32], 0
  003fd	7d 21		 jge	 SHORT $LN18@bind_devic

; 510  :     {
; 511  :         /* (error message already issued) */
; 512  :         free( bs->spec );

  003ff	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  00404	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00408	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 513  :         free( bs );

  0040e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR bs$[rsp]
  00413	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 514  :         return 0; /* (failure) */

  00419	33 c0		 xor	 eax, eax
  0041b	e9 6c 04 00 00	 jmp	 $LN1@bind_devic
$LN18@bind_devic:

; 515  :     }
; 516  : 
; 517  :     /* Chain device and bind_struct to each other */
; 518  :     dev->bs = bs;

  00420	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00428	48 8b 4c 24 60	 mov	 rcx, QWORD PTR bs$[rsp]
  0042d	48 89 88 b8 01
	00 00		 mov	 QWORD PTR [rax+440], rcx

; 519  :     bs->dev = dev;

  00434	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  00439	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00441	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 520  : 
; 521  :     /* Add the new entry to our list of bound devices
; 522  :        and create the socket thread that will listen
; 523  :        for connections (if it doesn't already exist) */
; 524  : 
; 525  :     obtain_lock( &sysblk.bindlock );

  00445	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0044c	48 83 c0 78	 add	 rax, 120		; 00000078H
  00450	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168462
  00457	48 8b c8	 mov	 rcx, rax
  0045a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 526  :     {
; 527  :         was_list_empty = IsListEmpty( &bind_head );

  00460	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:bind_head
  00467	48 39 05 00 00
	00 00		 cmp	 QWORD PTR bind_head, rax
  0046e	75 0d		 jne	 SHORT $LN39@bind_devic
  00470	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv221[rsp], 1
  0047b	eb 0b		 jmp	 SHORT $LN40@bind_devic
$LN39@bind_devic:
  0047d	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv221[rsp], 0
$LN40@bind_devic:
  00488	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv221[rsp]
  0048f	89 84 24 98 00
	00 00		 mov	 DWORD PTR was_list_empty$[rsp], eax

; 528  : 
; 529  :         InsertListTail( &bind_head, &bs->bind_link );

  00496	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:bind_head
  0049d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR _EX_Head$4[rsp], rax
  004a5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR _EX_Head$4[rsp]
  004ad	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  004b1	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR _EX_Tail$5[rsp], rax
  004b9	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  004be	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR _EX_Head$4[rsp]
  004c6	48 89 08	 mov	 QWORD PTR [rax], rcx
  004c9	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  004ce	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR _EX_Tail$5[rsp]
  004d6	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  004da	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  004df	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR _EX_Tail$5[rsp]
  004e7	48 89 01	 mov	 QWORD PTR [rcx], rax
  004ea	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  004ef	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR _EX_Head$4[rsp]
  004f7	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 530  : 
; 531  :         if (was_list_empty)

  004fb	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR was_list_empty$[rsp], 0
  00503	0f 84 56 01 00
	00		 je	 $LN19@bind_devic

; 532  :         {
; 533  :             rc = create_thread( &sysblk.socktid, JOINABLE,

  00509	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00510	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  00516	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0051d	48 81 c1 ac 10
	00 00		 add	 rcx, 4268		; 000010acH
  00524	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168464
  0052b	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00530	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168465
  00537	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0053c	45 33 c9	 xor	 r9d, r9d
  0053f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:socket_thread
  00546	48 8b d0	 mov	 rdx, rax
  00549	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  0054f	89 84 24 88 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 534  :                                 socket_thread, NULL, SOCKET_THREAD_NAME );
; 535  :             if (rc)

  00556	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0055e	0f 84 fb 00 00
	00		 je	 $LN20@bind_devic

; 536  :             {
; 537  :                 // "Error in function create_thread(): %s"
; 538  :                 WRMSG( HHC00102, "E", strerror( rc ));

  00564	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR rc$[rsp]
  0056b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00571	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv240[rsp], rax
  00579	b9 01 00 00 00	 mov	 ecx, 1
  0057e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00584	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv240[rsp]
  0058c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00591	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168467
  00598	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0059d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168468
  005a4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005ae	41 b9 03 00 00
	00		 mov	 r9d, 3
  005b4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168469
  005bb	ba 1a 02 00 00	 mov	 edx, 538		; 0000021aH
  005c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168470
  005c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 539  :                 RemoveListEntry( &bs->bind_link );

  005cd	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  005d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005d5	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR _EX_Flink$6[rsp], rax
  005dd	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  005e2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  005e6	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR _EX_Blink$7[rsp], rax
  005ee	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR _EX_Blink$7[rsp]
  005f6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR _EX_Flink$6[rsp]
  005fe	48 89 08	 mov	 QWORD PTR [rax], rcx
  00601	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR _EX_Flink$6[rsp]
  00609	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR _EX_Blink$7[rsp]
  00611	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 540  :                 close_socket( bs->sd );

  00615	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  0061a	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  0061d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 541  :                 free( bs->spec );

  00623	48 8b 44 24 60	 mov	 rax, QWORD PTR bs$[rsp]
  00628	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0062c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 542  :                 free( bs );

  00632	48 8b 4c 24 60	 mov	 rcx, QWORD PTR bs$[rsp]
  00637	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 543  :                 release_lock( &sysblk.bindlock );

  0063d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00644	48 83 c0 78	 add	 rax, 120		; 00000078H
  00648	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168471
  0064f	48 8b c8	 mov	 rcx, rax
  00652	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 544  :                 return 0; /* (failure) */

  00658	33 c0		 xor	 eax, eax
  0065a	e9 2d 02 00 00	 jmp	 $LN1@bind_devic
$LN20@bind_devic:
$LN19@bind_devic:
$LN4@bind_devic:

; 545  :             }
; 546  :         }
; 547  : 
; 548  :         SIGNAL_SOCKDEV_THREAD();

  0065f	c6 44 24 68 00	 mov	 BYTE PTR c$1[rsp], 0
  00664	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0066a	89 84 24 9c 00
	00 00		 mov	 DWORD PTR saved_errno$3[rsp], eax
  00671	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00678	48 05 d8 10 00
	00		 add	 rax, 4312		; 000010d8H
  0067e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168472
  00685	48 8b c8	 mov	 rcx, rax
  00688	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  0068e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00695	8b 80 e0 10 00
	00		 mov	 eax, DWORD PTR [rax+4320]
  0069b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR f$2[rsp], eax
  006a2	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR f$2[rsp], 0
  006aa	7f 11		 jg	 SHORT $LN21@bind_devic
  006ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006b3	c7 80 e0 10 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4320], 1
$LN21@bind_devic:
  006bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006c4	48 05 d8 10 00
	00		 add	 rax, 4312		; 000010d8H
  006ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168474
  006d1	48 8b c8	 mov	 rcx, rax
  006d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
  006da	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR f$2[rsp], 0
  006e2	0f 8f 90 00 00
	00		 jg	 $LN22@bind_devic
$LN7@bind_devic:
  006e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006ef	48 63 80 e4 10
	00 00		 movsxd	 rax, DWORD PTR [rax+4324]
  006f6	45 33 c9	 xor	 r9d, r9d
  006f9	41 b8 01 00 00
	00		 mov	 r8d, 1
  006ff	48 8d 54 24 68	 lea	 rdx, QWORD PTR c$1[rsp]
  00704	48 8b c8	 mov	 rcx, rax
  00707	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  0070d	83 f8 01	 cmp	 eax, 1
  00710	74 5c		 je	 SHORT $LN23@bind_devic
$LN10@bind_devic:
  00712	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168477
  00719	41 b8 24 02 00
	00		 mov	 r8d, 548		; 00000224H
  0071f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168478
  00726	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168479
  0072d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00733	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00739	85 c0		 test	 eax, eax
  0073b	74 20		 je	 SHORT $LN24@bind_devic
  0073d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168481
  00744	41 b8 24 02 00
	00		 mov	 r8d, 548		; 00000224H
  0074a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168482
  00751	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168483
  00758	e8 00 00 00 00	 call	 DebuggerTrace
$LN24@bind_devic:
  0075d	33 c0		 xor	 eax, eax
  0075f	85 c0		 test	 eax, eax
  00761	75 af		 jne	 SHORT $LN10@bind_devic
  00763	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00769	85 c0		 test	 eax, eax
  0076b	74 01		 je	 SHORT $LN25@bind_devic
  0076d	cc		 int	 3
$LN25@bind_devic:
$LN23@bind_devic:
  0076e	33 c0		 xor	 eax, eax
  00770	85 c0		 test	 eax, eax
  00772	0f 85 70 ff ff
	ff		 jne	 $LN7@bind_devic
$LN22@bind_devic:
  00778	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR saved_errno$3[rsp]
  0077f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSASetLastError
  00785	33 c0		 xor	 eax, eax
  00787	85 c0		 test	 eax, eax
  00789	0f 85 d0 fe ff
	ff		 jne	 $LN4@bind_devic

; 549  :     }
; 550  :     release_lock( &sysblk.bindlock );

  0078f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00796	48 83 c0 78	 add	 rax, 120		; 00000078H
  0079a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168485
  007a1	48 8b c8	 mov	 rcx, rax
  007a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 551  : 
; 552  :     // "%1d:%04X COMM: device bound to socket %s"
; 553  :     WRMSG( HHC01042, "I", LCSS_DEVNUM, dev->bs->spec );

  007aa	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  007b3	74 15		 je	 SHORT $LN41@bind_devic
  007b5	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007bd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  007c1	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv308[rsp], eax
  007c8	eb 0b		 jmp	 SHORT $LN42@bind_devic
$LN41@bind_devic:
  007ca	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv308[rsp], 0
$LN42@bind_devic:
  007d5	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  007de	74 17		 je	 SHORT $LN43@bind_devic
  007e0	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007e8	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  007ec	d1 f8		 sar	 eax, 1
  007ee	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv314[rsp], eax
  007f5	eb 0b		 jmp	 SHORT $LN44@bind_devic
$LN43@bind_devic:
  007f7	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv314[rsp], 0
$LN44@bind_devic:
  00802	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0080a	48 8b 80 b8 01
	00 00		 mov	 rax, QWORD PTR [rax+440]
  00811	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv358[rsp], rax
  00819	b9 01 00 00 00	 mov	 ecx, 1
  0081e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00824	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv358[rsp]
  0082c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00830	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00835	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv308[rsp]
  0083c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00840	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv314[rsp]
  00847	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0084b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168486
  00852	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00857	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168487
  0085e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00863	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00868	41 b9 03 00 00
	00		 mov	 r9d, 3
  0086e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168488
  00875	ba 29 02 00 00	 mov	 edx, 553		; 00000229H
  0087a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168489
  00881	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 554  : 
; 555  :     return 1;   /* (success) */

  00887	b8 01 00 00 00	 mov	 eax, 1
$LN1@bind_devic:

; 556  : }

  0088c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00894	48 33 cc	 xor	 rcx, rsp
  00897	e8 00 00 00 00	 call	 __security_check_cookie
  0089c	48 81 c4 20 01
	00 00		 add	 rsp, 288		; 00000120H
  008a3	5f		 pop	 rdi
  008a4	c3		 ret	 0
bind_device_ex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
