; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	map32:QWORD:0400H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	lar_tcpip
EXTRN	__report_rangecheckfailure:PROC
EXTRN	strlen:PROC
EXTRN	__imp_InitializeCriticalSection:PROC
EXTRN	__imp_EnterCriticalSection:PROC
EXTRN	__imp_LeaveCriticalSection:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_bind:PROC
EXTRN	__imp_closesocket:PROC
EXTRN	__imp_connect:PROC
EXTRN	__imp_ioctlsocket:PROC
EXTRN	__imp_getpeername:PROC
EXTRN	__imp_getsockname:PROC
EXTRN	__imp_htonl:PROC
EXTRN	__imp_htons:PROC
EXTRN	__imp_listen:PROC
EXTRN	__imp_ntohl:PROC
EXTRN	__imp_recv:PROC
EXTRN	__imp_send:PROC
EXTRN	__imp_gethostbyaddr:PROC
EXTRN	__imp_gethostbyname:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp_w32_socket:PROC
EXTRN	__imp_w32_accept:PROC
EXTRN	__imp_w32_FD_SET:PROC
EXTRN	__imp_w32_FD_ISSET:PROC
EXTRN	__imp_w32_select:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
Ccom_opn DB	0400H DUP (?)
Ccom_blk DB	0400H DUP (?)
Ccom_han DQ	0400H DUP (?)
CerrGen	DD	01H DUP (?)
Cerr	DD	0400H DUP (?)
	ALIGN	8

Cselect	DQ	0400H DUP (?)
tcpip_lock DB	028H DUP (?)
_BSS	ENDS
pdata	SEGMENT
$pdata$find_slot DD imagerel find_slot
	DD	imagerel find_slot+111
	DD	imagerel $unwind$find_slot
$pdata$tcpip_init DD imagerel tcpip_init
	DD	imagerel tcpip_init+202
	DD	imagerel $unwind$tcpip_init
$pdata$Get_errno DD imagerel Get_errno
	DD	imagerel Get_errno+616
	DD	imagerel $unwind$Get_errno
$pdata$EZASOKET DD imagerel EZASOKET
	DD	imagerel EZASOKET+9028
	DD	imagerel $unwind$EZASOKET
$pdata$lar_tcpip DD imagerel $LN11
	DD	imagerel $LN11+696
	DD	imagerel $unwind$lar_tcpip
pdata	ENDS
_DATA	SEGMENT
DCCascii_to_ebcdic DB 00H, 01H, 02H, 03H, '7-./', 016H, 05H, 015H, 0bH, 0cH
	DB	0dH, 0eH, 0fH, 010H, 011H, 012H, 013H, '<=2&', 018H, 019H, '?'''
	DB	01cH, 01dH, 01eH, 01fH, '@Z', 07fH, '{[lP}M]\Nk`Ka', 0f0H, 0f1H
	DB	0f2H, 0f3H, 0f4H, 0f5H, 0f6H, 0f7H, 0f8H, 0f9H, 'z^L~no|', 0c1H
	DB	0c2H, 0c3H, 0c4H, 0c5H, 0c6H, 0c7H, 0c8H, 0c9H, 0d1H, 0d2H, 0d3H
	DB	0d4H, 0d5H, 0d6H, 0d7H, 0d8H, 0d9H, 0e2H, 0e3H, 0e4H, 0e5H, 0e6H
	DB	0e7H, 0e8H, 0e9H, 0adH, 0e0H, 0bdH, '_my', 081H, 082H, 083H, 084H
	DB	085H, 086H, 087H, 088H, 089H, 091H, 092H, 093H, 094H, 095H, 096H
	DB	097H, 098H, 099H, 0a2H, 0a3H, 0a4H, 0a5H, 0a6H, 0a7H, 0a8H, 0a9H
	DB	0c0H, 'O', 0d0H, 0a1H, 07H, ' !"#$%', 06H, 017H, '()*+,', 09H, 0aH
	DB	01bH, '01', 01aH, '3456', 08H, '89:;', 04H, 014H, '>', 0ffH, 'A'
	DB	0aaH, 'J', 0b1H, 09fH, 0b2H, 'j', 0b5H, 0bbH, 0b4H, 09aH, 08aH
	DB	0b0H, 0caH, 0afH, 0bcH, 090H, 08fH, 0eaH, 0faH, 0beH, 0a0H, 0b6H
	DB	0b3H, 09dH, 0daH, 09bH, 08bH, 0b7H, 0b8H, 0b9H, 0abH, 'debfcg', 09eH
	DB	'htqrsxuvw', 0acH, 'i', 0edH, 0eeH, 0ebH, 0efH, 0ecH, 0bfH, 080H
	DB	0fdH, 0feH, 0fbH, 0fcH, 0baH, 0aeH, 'YDEBFCG', 09cH, 'HTQRSXUV'
	DB	'W', 08cH, 'I', 0cdH, 0ceH, 0cbH, 0cfH, 0ccH, 0e1H, 'p', 0ddH, 0deH
	DB	0dbH, 0dcH, 08dH, 08eH, 0dfH, 00H
	ORG $+15
DCCebcdic_to_ascii DB 00H, 01H, 02H, 03H, 09cH, 09H, 086H, 07fH, 097H, 08dH
	DB	08eH, 0bH, 0cH, 0dH, 0eH, 0fH, 010H, 011H, 012H, 013H, 09dH, 0aH
	DB	08H, 087H, 018H, 019H, 092H, 08fH, 01cH, 01dH, 01eH, 01fH, 080H
	DB	081H, 082H, 083H, 084H, 085H, 017H, 01bH, 088H, 089H, 08aH, 08bH
	DB	08cH, 05H, 06H, 07H, 090H, 091H, 016H, 093H, 094H, 095H, 096H, 04H
	DB	098H, 099H, 09aH, 09bH, 014H, 015H, 09eH, 01aH, ' ', 0a0H, 0e2H
	DB	0e4H, 0e0H, 0e1H, 0e3H, 0e5H, 0e7H, 0f1H, 0a2H, '.<(+|&', 0e9H
	DB	0eaH, 0ebH, 0e8H, 0edH, 0eeH, 0efH, 0ecH, 0dfH, '!$*);^-/', 0c2H
	DB	0c4H, 0c0H, 0c1H, 0c3H, 0c5H, 0c7H, 0d1H, 0a6H, ',%_>?', 0f8H, 0c9H
	DB	0caH, 0cbH, 0c8H, 0cdH, 0ceH, 0cfH, 0ccH, '`:#@''="', 0d8H, 'a'
	DB	'bcdefghi', 0abH, 0bbH, 0f0H, 0fdH, 0feH, 0b1H, 0b0H, 'jklmnop'
	DB	'qr', 0aaH, 0baH, 0e6H, 0b8H, 0c6H, 0a4H, 0b5H, '~stuvwxyz', 0a1H
	DB	0bfH, 0d0H, '[', 0deH, 0aeH, 0acH, 0a3H, 0a5H, 0b7H, 0a9H, 0a7H
	DB	0b6H, 0bcH, 0bdH, 0beH, 0ddH, 0a8H, 0afH, ']', 0b4H, 0d7H, '{A'
	DB	'BCDEFGHI', 0adH, 0f4H, 0f6H, 0f2H, 0f3H, 0f5H, '}JKLMNOPQR', 0b9H
	DB	0fbH, 0fcH, 0f9H, 0faH, 0ffH, '\', 0f7H, 'STUVWXYZ', 0b2H, 0d4H
	DB	0d6H, 0d2H, 0d3H, 0d5H, '0123456789', 0b3H, 0dbH, 0dcH, 0d9H, 0daH
	DB	09fH, 00H
	ORG $+3
tcpip_init_req DD 01H
$SG159398 DB	'tcpip.c', 00H
$SG159408 DB	'tcpip.c', 00H
$SG159446 DB	'tcpip.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:EZASOKET
	DD	02bH
	DD	022b8H
voltbl	ENDS
xdata	SEGMENT
$unwind$find_slot DD 010901H
	DD	06209H
$unwind$tcpip_init DD 010401H
	DD	06204H
$unwind$Get_errno DD 010401H
	DD	06204H
$unwind$EZASOKET DD 043319H
	DD	04390121H
	DD	060137014H
	DD	imagerel __GSHandlerCheck
	DD	021b0H
$unwind$lar_tcpip DD 010901H
	DD	06209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tcpip.c
_TEXT	SEGMENT
tv177 = 32
tv181 = 36
t$ = 40
regs$ = 64
lar_tcpip PROC

; 976  : u_int  lar_tcpip (u_int  * regs) {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 977  :     talk_ptr t;
; 978  : 
; 979  :     if (tcpip_init_req) {

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR tcpip_init_req, 0
  00010	74 0f		 je	 SHORT $LN2@lar_tcpip

; 980  :         tcpip_init_req = 0;

  00012	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR tcpip_init_req, 0

; 981  :         tcpip_init ();

  0001c	e8 00 00 00 00	 call	 tcpip_init
$LN2@lar_tcpip:

; 982  :     }
; 983  : 
; 984  :     if (get_reg (regs, 0) == 0) { /* Initial call. */

  00021	33 d2		 xor	 edx, edx
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00028	e8 00 00 00 00	 call	 get_reg
  0002d	85 c0		 test	 eax, eax
  0002f	0f 85 66 01 00
	00		 jne	 $LN3@lar_tcpip

; 985  : 
; 986  :         if (get_reg (regs, 3) == 0) { /* Alloc memory for this communication. */

  00035	ba 03 00 00 00	 mov	 edx, 3
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0003f	e8 00 00 00 00	 call	 get_reg
  00044	85 c0		 test	 eax, eax
  00046	0f 85 e1 00 00
	00		 jne	 $LN5@lar_tcpip

; 987  : 
; 988  :             t = (talk_ptr)malloc (sizeof (talk));

  0004c	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00057	48 89 44 24 28	 mov	 QWORD PTR t$[rsp], rax

; 989  :             t->slot = find_slot ((U_LONG_PTR)t);

  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  00061	e8 00 00 00 00	 call	 find_slot
  00066	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  0006b	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 990  : 
; 991  :             t->len_in = get_reg (regs, 1);

  0006e	ba 01 00 00 00	 mov	 edx, 1
  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00078	e8 00 00 00 00	 call	 get_reg
  0007d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  00082	89 01		 mov	 DWORD PTR [rcx], eax

; 992  :             t->buffer_in = (char *)malloc (t->len_in + 1);

  00084	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00089	8b 00		 mov	 eax, DWORD PTR [rax]
  0008b	ff c0		 inc	 eax
  0008d	8b c0		 mov	 eax, eax
  0008f	8b c8		 mov	 ecx, eax
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00097	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  0009c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 993  :             t->buffer_in_slot = find_slot ((U_LONG_PTR)&(t->buffer_in [0]));

  000a0	b8 01 00 00 00	 mov	 eax, 1
  000a5	48 6b c0 00	 imul	 rax, rax, 0
  000a9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  000ae	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	e8 00 00 00 00	 call	 find_slot
  000ba	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  000bf	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 994  :             t->buffer_in [t->len_in] = 0; /* NULL Terminator */

  000c2	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  000c7	8b 00		 mov	 eax, DWORD PTR [rax]
  000c9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  000ce	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000d2	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 995  : 
; 996  :             t->len_out = 0;

  000d6	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  000db	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 997  :             t->buffer_out = NULL; /* I've got nothing, at the moment */

  000e2	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  000e7	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 998  :             t->ret_cd = 0;

  000ef	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  000f4	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 999  : 
; 1000 :             set_reg (regs, 14, (u_int )t->slot);

  000fb	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00100	44 8b 40 24	 mov	 r8d, DWORD PTR [rax+36]
  00104	ba 0e 00 00 00	 mov	 edx, 14
  00109	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	e8 00 00 00 00	 call	 set_reg

; 1001 : 
; 1002 :             set_reg (regs, 2, (u_int )t->buffer_in_slot);

  00113	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00118	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  0011c	ba 02 00 00 00	 mov	 edx, 2
  00121	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 set_reg

; 1003 : 
; 1004 :         } else {                      /* They want some return info... */

  0012b	eb 69		 jmp	 SHORT $LN6@lar_tcpip
$LN5@lar_tcpip:

; 1005 : 
; 1006 :             t = (talk_ptr)map32[get_reg (regs, 14)];

  0012d	ba 0e 00 00 00	 mov	 edx, 14
  00132	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00137	e8 00 00 00 00	 call	 get_reg
  0013c	8b c0		 mov	 eax, eax
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map32
  00145	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00149	48 89 44 24 28	 mov	 QWORD PTR t$[rsp], rax

; 1007 : 
; 1008 :             set_reg (regs, 1, t->len_out);

  0014e	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00153	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00157	ba 01 00 00 00	 mov	 edx, 1
  0015c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	e8 00 00 00 00	 call	 set_reg

; 1009 :             set_reg (regs, 2, (u_int )t->buffer_out_slot);

  00166	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  0016b	44 8b 40 2c	 mov	 r8d, DWORD PTR [rax+44]
  0016f	ba 02 00 00 00	 mov	 edx, 2
  00174	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	e8 00 00 00 00	 call	 set_reg

; 1010 : 
; 1011 :             set_reg (regs, 4, t->ret_cd);

  0017e	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00183	44 8b 40 20	 mov	 r8d, DWORD PTR [rax+32]
  00187	ba 04 00 00 00	 mov	 edx, 4
  0018c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00191	e8 00 00 00 00	 call	 set_reg
$LN6@lar_tcpip:

; 1012 :         }
; 1013 : 
; 1014 :     } else {                      /* Must need additional processing. */

  00196	e9 13 01 00 00	 jmp	 $LN4@lar_tcpip
$LN3@lar_tcpip:

; 1015 : 
; 1016 :         t = (talk_ptr)map32[get_reg (regs, 14)];

  0019b	ba 0e 00 00 00	 mov	 edx, 14
  001a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  001a5	e8 00 00 00 00	 call	 get_reg
  001aa	8b c0		 mov	 eax, eax
  001ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map32
  001b3	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  001b7	48 89 44 24 28	 mov	 QWORD PTR t$[rsp], rax

; 1017 : 
; 1018 :         if (get_reg (regs, 3) == 0) { /* Run. */

  001bc	ba 03 00 00 00	 mov	 edx, 3
  001c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  001c6	e8 00 00 00 00	 call	 get_reg
  001cb	85 c0		 test	 eax, eax
  001cd	75 53		 jne	 SHORT $LN7@lar_tcpip

; 1019 : 
; 1020 :             EZASOKET (get_reg (regs, 7), get_reg (regs, 8), get_reg (regs, 9), t);

  001cf	ba 09 00 00 00	 mov	 edx, 9
  001d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  001d9	e8 00 00 00 00	 call	 get_reg
  001de	89 44 24 20	 mov	 DWORD PTR tv177[rsp], eax
  001e2	ba 08 00 00 00	 mov	 edx, 8
  001e7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  001ec	e8 00 00 00 00	 call	 get_reg
  001f1	89 44 24 24	 mov	 DWORD PTR tv181[rsp], eax
  001f5	ba 07 00 00 00	 mov	 edx, 7
  001fa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  001ff	e8 00 00 00 00	 call	 get_reg
  00204	4c 8b 4c 24 28	 mov	 r9, QWORD PTR t$[rsp]
  00209	8b 4c 24 20	 mov	 ecx, DWORD PTR tv177[rsp]
  0020d	44 8b c1	 mov	 r8d, ecx
  00210	8b 4c 24 24	 mov	 ecx, DWORD PTR tv181[rsp]
  00214	8b d1		 mov	 edx, ecx
  00216	8b c8		 mov	 ecx, eax
  00218	e8 00 00 00 00	 call	 EZASOKET

; 1021 : 
; 1022 :         } else {                      /* Dealloc memory for this communication. */

  0021d	e9 8c 00 00 00	 jmp	 $LN8@lar_tcpip
$LN7@lar_tcpip:

; 1023 : 
; 1024 :             map32[t->buffer_in_slot] = -1;

  00222	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00227	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0022a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map32
  00231	48 c7 04 c1 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax*8], -1

; 1025 :             free (t->buffer_in);

  00239	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  0023e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00242	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1026 :             if (t->buffer_out) {

  00248	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  0024d	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00252	74 26		 je	 SHORT $LN9@lar_tcpip

; 1027 :                 map32[t->buffer_out_slot] = -1;

  00254	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00259	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0025c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map32
  00263	48 c7 04 c1 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax*8], -1

; 1028 :                 free (t->buffer_out);

  0026b	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  00270	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00274	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN9@lar_tcpip:

; 1029 :             }
; 1030 :             map32[t->slot] = -1;

  0027a	48 8b 44 24 28	 mov	 rax, QWORD PTR t$[rsp]
  0027f	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00282	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map32
  00289	48 c7 04 c1 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax*8], -1

; 1031 :             free (t);

  00291	48 8b 4c 24 28	 mov	 rcx, QWORD PTR t$[rsp]
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1032 : 
; 1033 :             set_reg (regs, 14, 0);

  0029c	45 33 c0	 xor	 r8d, r8d
  0029f	ba 0e 00 00 00	 mov	 edx, 14
  002a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  002a9	e8 00 00 00 00	 call	 set_reg
$LN8@lar_tcpip:
$LN4@lar_tcpip:

; 1034 :         }
; 1035 :     }
; 1036 : 
; 1037 :     return (1); /* We never return 0, that's for the DLL Loader. */

  002ae	b8 01 00 00 00	 mov	 eax, 1

; 1038 : }

  002b3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002b7	c3		 ret	 0
lar_tcpip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tcpip.c
_TEXT	SEGMENT
i$ = 64
m$ = 68
k$ = 72
isock$ = 76
tv255 = 80
tv65 = 84
l$ = 88
timeout$ = 96
size$ = 104
hp$ = 112
tv679 = 120
tv1962 = 124
tv1982 = 128
tv2002 = 132
tv2044 = 136
tv1054 = 140
tv2078 = 144
tv1128 = 148
tv2112 = 152
tv1202 = 156
tv176 = 160
tv347 = 168
$T1 = 176
$T2 = 184
tv1272 = 192
tv1397 = 200
tv793 = 208
tv1523 = 216
tv1418 = 224
tv843 = 232
tv1517 = 240
tv1423 = 248
tv893 = 256
tv1511 = 264
tv1428 = 272
tv1019 = 280
tv1444 = 288
tv1042 = 296
tv1494 = 304
tv1093 = 312
tv1448 = 320
tv1116 = 328
tv1487 = 336
tv1167 = 344
tv1452 = 352
tv1190 = 360
tv1480 = 368
Clocal_adx$ = 376
Slocal_adx$ = 392
sockets$ = 416
__$ArrayPad$ = 8624
func$ = 8672
aux1$ = 8680
aux2$ = 8688
t$ = 8696
EZASOKET PROC

; 243  : static void EZASOKET (u_int  func, int  aux1, int  aux2, talk_ptr t) {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	b8 c8 21 00 00	 mov	 eax, 8648		; 000021c8H
  00019	e8 00 00 00 00	 call	 __chkstk
  0001e	48 2b e0	 sub	 rsp, rax
  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00028	48 33 c4	 xor	 rax, rsp
  0002b	48 89 84 24 b0
	21 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 244  :     int    i;
; 245  :     socklen_t  isock;
; 246  :     int    k;
; 247  :     int    l;
; 248  :     int    m;
; 249  :     int    size;
; 250  :     struct hostent * hp;
; 251  :     struct timeval timeout;
; 252  :     fd_set sockets;
; 253  :     SOCKADDR_IN Clocal_adx;
; 254  :     SOCKADDR    Slocal_adx;
; 255  : 
; 256  :     switch (func & 0xFF) {

  00033	8b 84 24 e0 21
	00 00		 mov	 eax, DWORD PTR func$[rsp]
  0003a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0003f	89 44 24 54	 mov	 DWORD PTR tv65[rsp], eax
  00043	8b 44 24 54	 mov	 eax, DWORD PTR tv65[rsp]
  00047	ff c8		 dec	 eax
  00049	89 44 24 54	 mov	 DWORD PTR tv65[rsp], eax
  0004d	83 7c 24 54 12	 cmp	 DWORD PTR tv65[rsp], 18
  00052	0f 87 51 22 00
	00		 ja	 $LN2@EZASOKET
  00058	8b 44 24 54	 mov	 eax, DWORD PTR tv65[rsp]
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00063	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN153@EZASOKET[rcx+rax*4]
  0006a	48 03 c1	 add	 rax, rcx
  0006d	ff e0		 jmp	 rax
$LN44@EZASOKET:

; 257  :     case 1:  /* INITAPI */
; 258  : 
; 259  :         t->ret_cd = 0;

  0006f	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00077	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 260  :         return;

  0007e	e9 35 22 00 00	 jmp	 $LN1@EZASOKET
$LN45@EZASOKET:

; 261  : 
; 262  :     case 2:  /* GETERRORS */
; 263  : 
; 264  :         if (check_not_sock (aux1, t)) {

  00083	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  0008b	8b 8c 24 e8 21
	00 00		 mov	 ecx, DWORD PTR aux1$[rsp]
  00092	e8 00 00 00 00	 call	 check_not_sock
  00097	85 c0		 test	 eax, eax
  00099	74 14		 je	 SHORT $LN46@EZASOKET

; 265  :             t->ret_cd = hENOTSOCK;

  0009b	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  000a3	c7 40 20 26 00
	00 00		 mov	 DWORD PTR [rax+32], 38	; 00000026H

; 266  :             return;

  000aa	e9 09 22 00 00	 jmp	 $LN1@EZASOKET
$LN46@EZASOKET:

; 267  :         }
; 268  : 
; 269  :         t->ret_cd = Cerr [aux1];

  000af	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cerr
  000be	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  000c6	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000c9	89 42 20	 mov	 DWORD PTR [rdx+32], eax

; 270  :         return;

  000cc	e9 e7 21 00 00	 jmp	 $LN1@EZASOKET
$LN47@EZASOKET:

; 271  : 
; 272  :     case 3:  /* GETERROR */
; 273  : 
; 274  :         t->ret_cd = CerrGen;

  000d1	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  000d9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR CerrGen
  000df	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 275  :         return;

  000e2	e9 d1 21 00 00	 jmp	 $LN1@EZASOKET
$LN48@EZASOKET:

; 276  : 
; 277  :     case 4:  /* GETHOSTBYNAME */
; 278  : 
; 279  :         m = strlen (t->buffer_in);

  000e7	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  000ef	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000f3	e8 00 00 00 00	 call	 strlen
  000f8	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 280  :         k = 0;

  000fc	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
$LN4@EZASOKET:

; 281  :         while (m) {

  00104	83 7c 24 44 00	 cmp	 DWORD PTR m$[rsp], 0
  00109	74 7f		 je	 SHORT $LN5@EZASOKET

; 282  :             t->buffer_in [k] = DCCebcdic_to_ascii [(unsigned char)(t->buffer_in [k])];

  0010b	48 63 44 24 48	 movsxd	 rax, DWORD PTR k$[rsp]
  00110	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00118	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0011c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DCCebcdic_to_ascii
  00127	48 63 54 24 48	 movsxd	 rdx, DWORD PTR k$[rsp]
  0012c	4c 8b 84 24 f8
	21 00 00	 mov	 r8, QWORD PTR t$[rsp]
  00134	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00138	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0013c	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 283  :             if ((unsigned char)t->buffer_in [k] == 0x20) {t->buffer_in [k] = 0; break;};

  00140	48 63 44 24 48	 movsxd	 rax, DWORD PTR k$[rsp]
  00145	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  0014d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00151	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00155	83 f8 20	 cmp	 eax, 32			; 00000020H
  00158	75 17		 jne	 SHORT $LN49@EZASOKET
  0015a	48 63 44 24 48	 movsxd	 rax, DWORD PTR k$[rsp]
  0015f	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00167	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0016b	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  0016f	eb 19		 jmp	 SHORT $LN5@EZASOKET
$LN49@EZASOKET:

; 284  :             k++;

  00171	8b 44 24 48	 mov	 eax, DWORD PTR k$[rsp]
  00175	ff c0		 inc	 eax
  00177	89 44 24 48	 mov	 DWORD PTR k$[rsp], eax

; 285  :             m--;

  0017b	8b 44 24 44	 mov	 eax, DWORD PTR m$[rsp]
  0017f	ff c8		 dec	 eax
  00181	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 286  :         }

  00185	e9 7a ff ff ff	 jmp	 $LN4@EZASOKET
$LN5@EZASOKET:

; 287  : 
; 288  :         if ((hp = gethostbyname (t->buffer_in)) == NULL) {

  0018a	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00192	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gethostbyname
  0019c	48 89 44 24 70	 mov	 QWORD PTR hp$[rsp], rax
  001a1	48 83 7c 24 70
	00		 cmp	 QWORD PTR hp$[rsp], 0
  001a7	75 21		 jne	 SHORT $LN50@EZASOKET

; 289  : 
; 290  :             CerrGen = Get_errno ();

  001a9	e8 00 00 00 00	 call	 Get_errno
  001ae	89 05 00 00 00
	00		 mov	 DWORD PTR CerrGen, eax

; 291  : 
; 292  :             t->ret_cd = 0;

  001b4	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  001bc	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 293  :             return;

  001c3	e9 f0 20 00 00	 jmp	 $LN1@EZASOKET

; 294  :         } else {

  001c8	eb 67		 jmp	 SHORT $LN51@EZASOKET
$LN50@EZASOKET:

; 295  :             if (hp->h_addr_list [0] == NULL) {

  001ca	b8 08 00 00 00	 mov	 eax, 8
  001cf	48 6b c0 00	 imul	 rax, rax, 0
  001d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hp$[rsp]
  001d8	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001dc	48 83 3c 08 00	 cmp	 QWORD PTR [rax+rcx], 0
  001e1	75 16		 jne	 SHORT $LN52@EZASOKET

; 296  :                 t->ret_cd = 0;

  001e3	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  001eb	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 297  :                 return;

  001f2	e9 c1 20 00 00	 jmp	 $LN1@EZASOKET

; 298  :             } else {

  001f7	eb 38		 jmp	 SHORT $LN53@EZASOKET
$LN52@EZASOKET:

; 299  :                 t->ret_cd = (ntohl(((u_int  *)(hp->h_addr_list [0])) [0]));

  001f9	b8 08 00 00 00	 mov	 eax, 8
  001fe	48 6b c0 00	 imul	 rax, rax, 0
  00202	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hp$[rsp]
  00207	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0020b	ba 04 00 00 00	 mov	 edx, 4
  00210	48 6b d2 00	 imul	 rdx, rdx, 0
  00214	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00218	8b 0c 10	 mov	 ecx, DWORD PTR [rax+rdx]
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohl
  00221	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00229	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 300  :                 return;

  0022c	e9 87 20 00 00	 jmp	 $LN1@EZASOKET
$LN53@EZASOKET:
$LN51@EZASOKET:
$LN54@EZASOKET:

; 301  :             }
; 302  :         }
; 303  : 
; 304  :     case 5:  /* SOCKET */
; 305  : 
; 306  :         obtain_lock (&tcpip_lock);

  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tcpip_lock
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 307  : 
; 308  :         m = 1;

  0023e	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR m$[rsp], 1
$LN6@EZASOKET:

; 309  :         while (m < Ccom) {

  00246	81 7c 24 44 00
	04 00 00	 cmp	 DWORD PTR m$[rsp], 1024	; 00000400H
  0024e	7d 22		 jge	 SHORT $LN7@EZASOKET

; 310  :             if (Ccom_opn [m] == 0) break;

  00250	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  00255	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_opn
  0025c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00260	85 c0		 test	 eax, eax
  00262	75 02		 jne	 SHORT $LN55@EZASOKET
  00264	eb 0c		 jmp	 SHORT $LN7@EZASOKET
$LN55@EZASOKET:

; 311  :             m++;

  00266	8b 44 24 44	 mov	 eax, DWORD PTR m$[rsp]
  0026a	ff c0		 inc	 eax
  0026c	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 312  :         }

  00270	eb d4		 jmp	 SHORT $LN6@EZASOKET
$LN7@EZASOKET:

; 313  :         if (m == Ccom) {

  00272	81 7c 24 44 00
	04 00 00	 cmp	 DWORD PTR m$[rsp], 1024	; 00000400H
  0027a	75 2b		 jne	 SHORT $LN56@EZASOKET

; 314  : 
; 315  :             CerrGen = hEMFILE;

  0027c	c7 05 00 00 00
	00 18 00 00 00	 mov	 DWORD PTR CerrGen, 24

; 316  : 
; 317  :             release_lock (&tcpip_lock);

  00286	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tcpip_lock
  0028d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 318  : 
; 319  :             t->ret_cd = -1;

  00293	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  0029b	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 320  :             return;  /* None available. */

  002a2	e9 11 20 00 00	 jmp	 $LN1@EZASOKET
$LN56@EZASOKET:

; 321  :         }
; 322  : 
; 323  :         i = aux1 >> 16; /* Family: eg. PF_INET */

  002a7	8b 84 24 e8 21
	00 00		 mov	 eax, DWORD PTR aux1$[rsp]
  002ae	c1 f8 10	 sar	 eax, 16
  002b1	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 324  : 
; 325  :         if ((Ccom_han [m] = socket (i, (aux1 & 0xFFFF), aux2)) == INVALID_SOCKET) {

  002b5	8b 84 24 e8 21
	00 00		 mov	 eax, DWORD PTR aux1$[rsp]
  002bc	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  002c1	44 8b 84 24 f0
	21 00 00	 mov	 r8d, DWORD PTR aux2$[rsp]
  002c9	8b d0		 mov	 edx, eax
  002cb	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  002cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_socket
  002d5	48 98		 cdqe
  002d7	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv176[rsp], rax
  002df	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  002e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  002eb	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR tv176[rsp]
  002f3	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
  002f7	48 83 bc 24 a0
	00 00 00 ff	 cmp	 QWORD PTR tv176[rsp], -1
  00300	75 2c		 jne	 SHORT $LN57@EZASOKET

; 326  : 
; 327  :             CerrGen = Get_errno ();

  00302	e8 00 00 00 00	 call	 Get_errno
  00307	89 05 00 00 00
	00		 mov	 DWORD PTR CerrGen, eax

; 328  : 
; 329  :             release_lock (&tcpip_lock);

  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tcpip_lock
  00314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 330  : 
; 331  :             t->ret_cd = -1;

  0031a	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00322	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 332  :             return;  /* ERROR */

  00329	e9 8a 1f 00 00	 jmp	 $LN1@EZASOKET
$LN57@EZASOKET:

; 333  :         }
; 334  : 
; 335  :         Ccom_opn [m] = 1;

  0032e	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  00333	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_opn
  0033a	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 336  : 
; 337  :         release_lock (&tcpip_lock);

  0033e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tcpip_lock
  00345	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 338  : 
; 339  :         t->ret_cd = m;

  0034b	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00353	8b 4c 24 44	 mov	 ecx, DWORD PTR m$[rsp]
  00357	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 340  :         return;

  0035a	e9 59 1f 00 00	 jmp	 $LN1@EZASOKET
$LN58@EZASOKET:

; 341  : 
; 342  :     case 6:  /* BIND */
; 343  : 
; 344  :         /* FUNC:SOCK&FUNC, AUX1:ADDRESS, AUX2:FAMILY&PORT */
; 345  : 
; 346  :         m = func >> 16; /* SOCKET # */

  0035f	8b 84 24 e0 21
	00 00		 mov	 eax, DWORD PTR func$[rsp]
  00366	c1 e8 10	 shr	 eax, 16
  00369	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 347  :         i = aux2 >> 16; /* Family */

  0036d	8b 84 24 f0 21
	00 00		 mov	 eax, DWORD PTR aux2$[rsp]
  00374	c1 f8 10	 sar	 eax, 16
  00377	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 348  : 
; 349  :         if (check_not_sock (m, t)) return;

  0037b	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  00383	8b 4c 24 44	 mov	 ecx, DWORD PTR m$[rsp]
  00387	e8 00 00 00 00	 call	 check_not_sock
  0038c	85 c0		 test	 eax, eax
  0038e	74 05		 je	 SHORT $LN59@EZASOKET
  00390	e9 23 1f 00 00	 jmp	 $LN1@EZASOKET
$LN59@EZASOKET:

; 350  : 
; 351  : #if defined(__APPLE__)
; 352  :         bzero ((LPSOCKADDR)&Clocal_adx, sizeof (Clocal_adx)); /* cleanup address */
; 353  : #endif
; 354  : 
; 355  :         /* set up socket */
; 356  :         Clocal_adx.sin_family = (short)(i & 0xFF);

  00395	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00399	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0039e	66 89 84 24 78
	01 00 00	 mov	 WORD PTR Clocal_adx$[rsp], ax

; 357  : 
; 358  :         Clocal_adx.sin_addr.s_addr = htonl (aux1);

  003a6	8b 8c 24 e8 21
	00 00		 mov	 ecx, DWORD PTR aux1$[rsp]
  003ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  003b3	89 84 24 7c 01
	00 00		 mov	 DWORD PTR Clocal_adx$[rsp+4], eax

; 359  : 
; 360  :         Clocal_adx.sin_port = htons ((unsigned short)(aux2 & 0xFFFF));

  003ba	8b 84 24 f0 21
	00 00		 mov	 eax, DWORD PTR aux2$[rsp]
  003c1	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  003c6	0f b7 c8	 movzx	 ecx, ax
  003c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  003cf	66 89 84 24 7a
	01 00 00	 mov	 WORD PTR Clocal_adx$[rsp+2], ax

; 361  : 
; 362  :         if (bind (Ccom_han [m], (LPSOCKADDR)&Clocal_adx, sizeof (Clocal_adx))) {

  003d7	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  003dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  003e3	41 b8 10 00 00
	00		 mov	 r8d, 16
  003e9	48 8d 94 24 78
	01 00 00	 lea	 rdx, QWORD PTR Clocal_adx$[rsp]
  003f1	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  003f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  003fb	85 c0		 test	 eax, eax
  003fd	74 28		 je	 SHORT $LN60@EZASOKET

; 363  : 
; 364  :             Cerr [m] = Get_errno ();

  003ff	e8 00 00 00 00	 call	 Get_errno
  00404	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  00409	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cerr
  00410	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 365  : 
; 366  :             t->ret_cd = -1;

  00413	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  0041b	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 367  :             return;  /* ERROR */

  00422	e9 91 1e 00 00	 jmp	 $LN1@EZASOKET
$LN60@EZASOKET:

; 368  :         }
; 369  : 
; 370  :         t->ret_cd = 0;

  00427	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  0042f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 371  :         return;

  00436	e9 7d 1e 00 00	 jmp	 $LN1@EZASOKET
$LN61@EZASOKET:

; 372  : 
; 373  :     case 7:  /* CONNECT */
; 374  : 
; 375  :         m = func >> 16; /* SOCKET # */

  0043b	8b 84 24 e0 21
	00 00		 mov	 eax, DWORD PTR func$[rsp]
  00442	c1 e8 10	 shr	 eax, 16
  00445	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 376  :         i = aux2 >> 16; /* Family */

  00449	8b 84 24 f0 21
	00 00		 mov	 eax, DWORD PTR aux2$[rsp]
  00450	c1 f8 10	 sar	 eax, 16
  00453	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 377  : 
; 378  :         if (check_not_sock (m, t)) return;

  00457	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  0045f	8b 4c 24 44	 mov	 ecx, DWORD PTR m$[rsp]
  00463	e8 00 00 00 00	 call	 check_not_sock
  00468	85 c0		 test	 eax, eax
  0046a	74 05		 je	 SHORT $LN62@EZASOKET
  0046c	e9 47 1e 00 00	 jmp	 $LN1@EZASOKET
$LN62@EZASOKET:

; 379  : 
; 380  :         /* set up socket */
; 381  :         Clocal_adx.sin_family = (short)(i & 0xFF);

  00471	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00475	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0047a	66 89 84 24 78
	01 00 00	 mov	 WORD PTR Clocal_adx$[rsp], ax

; 382  : 
; 383  :         Clocal_adx.sin_addr.s_addr = htonl (aux1);

  00482	8b 8c 24 e8 21
	00 00		 mov	 ecx, DWORD PTR aux1$[rsp]
  00489	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  0048f	89 84 24 7c 01
	00 00		 mov	 DWORD PTR Clocal_adx$[rsp+4], eax

; 384  : 
; 385  :         Clocal_adx.sin_port = htons ((unsigned short)(aux2 & 0xFFFF));

  00496	8b 84 24 f0 21
	00 00		 mov	 eax, DWORD PTR aux2$[rsp]
  0049d	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  004a2	0f b7 c8	 movzx	 ecx, ax
  004a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  004ab	66 89 84 24 7a
	01 00 00	 mov	 WORD PTR Clocal_adx$[rsp+2], ax

; 386  : 
; 387  :         k = 1;

  004b3	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR k$[rsp], 1

; 388  :         ioctlsocket (Ccom_han [m], FIONBIO, &k);

  004bb	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  004c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  004c7	4c 8d 44 24 48	 lea	 r8, QWORD PTR k$[rsp]
  004cc	ba 7e 66 04 80	 mov	 edx, -2147195266	; ffffffff8004667eH
  004d1	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ioctlsocket

; 389  : 
; 390  :         i = connect (Ccom_han [m], (LPSOCKADDR)&Clocal_adx, sizeof (Clocal_adx));

  004db	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  004e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  004e7	41 b8 10 00 00
	00		 mov	 r8d, 16
  004ed	48 8d 94 24 78
	01 00 00	 lea	 rdx, QWORD PTR Clocal_adx$[rsp]
  004f5	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_connect
  004ff	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 391  :         Cerr [m] = Get_errno ();

  00503	e8 00 00 00 00	 call	 Get_errno
  00508	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  0050d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cerr
  00514	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 392  : 
; 393  :         k = 0;

  00517	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0

; 394  :         ioctlsocket (Ccom_han [m], FIONBIO, &k);

  0051f	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  00524	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  0052b	4c 8d 44 24 48	 lea	 r8, QWORD PTR k$[rsp]
  00530	ba 7e 66 04 80	 mov	 edx, -2147195266	; ffffffff8004667eH
  00535	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00539	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ioctlsocket

; 395  : 
; 396  :         if (i == -1) {

  0053f	83 7c 24 40 ff	 cmp	 DWORD PTR i$[rsp], -1
  00544	0f 85 9c 00 00
	00		 jne	 $LN63@EZASOKET

; 397  : 
; 398  :             switch (Cerr [m]) {

  0054a	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  0054f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cerr
  00556	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00559	89 44 24 50	 mov	 DWORD PTR tv255[rsp], eax
  0055d	83 7c 24 50 16	 cmp	 DWORD PTR tv255[rsp], 22
  00562	74 32		 je	 SHORT $LN65@EZASOKET
  00564	83 7c 24 50 23	 cmp	 DWORD PTR tv255[rsp], 35 ; 00000023H
  00569	74 2b		 je	 SHORT $LN67@EZASOKET
  0056b	83 7c 24 50 24	 cmp	 DWORD PTR tv255[rsp], 36 ; 00000024H
  00570	74 24		 je	 SHORT $LN68@EZASOKET
  00572	83 7c 24 50 25	 cmp	 DWORD PTR tv255[rsp], 37 ; 00000025H
  00577	74 1d		 je	 SHORT $LN66@EZASOKET
  00579	83 7c 24 50 38	 cmp	 DWORD PTR tv255[rsp], 56 ; 00000038H
  0057e	74 02		 je	 SHORT $LN64@EZASOKET
  00580	eb 50		 jmp	 SHORT $LN8@EZASOKET
$LN64@EZASOKET:

; 399  :             case hEISCONN :
; 400  :                 t->ret_cd = 0;  /* Worked! */

  00582	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  0058a	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 401  :                 return;

  00591	e9 22 1d 00 00	 jmp	 $LN1@EZASOKET
$LN65@EZASOKET:
$LN66@EZASOKET:
$LN67@EZASOKET:
$LN68@EZASOKET:

; 402  : 
; 403  :             case hEINVAL :      /* WSAEALREADY in Windows old sockets */
; 404  :             case hEALREADY :
; 405  :             case hEWOULDBLOCK :
; 406  :             case hEINPROGRESS :
; 407  : 
; 408  :                 if (Ccom_blk [m] == 0) {

  00596	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  0059b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_blk
  005a2	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  005a6	85 c0		 test	 eax, eax
  005a8	75 14		 jne	 SHORT $LN69@EZASOKET

; 409  :                     t->ret_cd = -1;

  005aa	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  005b2	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 410  :                     return;  /* ERROR, But Client Knows... */

  005b9	e9 fa 1c 00 00	 jmp	 $LN1@EZASOKET
$LN69@EZASOKET:

; 411  :                 }
; 412  : 
; 413  :                 t->ret_cd = -2; /* Must wait. */

  005be	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  005c6	c7 40 20 fe ff
	ff ff		 mov	 DWORD PTR [rax+32], -2

; 414  :                 return;

  005cd	e9 e6 1c 00 00	 jmp	 $LN1@EZASOKET
$LN8@EZASOKET:

; 415  :             }
; 416  : 
; 417  :             t->ret_cd = -1;

  005d2	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  005da	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 418  :             return;  /* ERROR */

  005e1	e9 d2 1c 00 00	 jmp	 $LN1@EZASOKET
$LN63@EZASOKET:

; 419  :         }
; 420  : 
; 421  :         t->ret_cd = 0;

  005e6	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  005ee	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 422  :         return;

  005f5	e9 be 1c 00 00	 jmp	 $LN1@EZASOKET
$LN70@EZASOKET:

; 423  : 
; 424  :     case 8:  /* LISTEN */
; 425  : 
; 426  :         if (check_not_sock (aux1, t)) return;

  005fa	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  00602	8b 8c 24 e8 21
	00 00		 mov	 ecx, DWORD PTR aux1$[rsp]
  00609	e8 00 00 00 00	 call	 check_not_sock
  0060e	85 c0		 test	 eax, eax
  00610	74 05		 je	 SHORT $LN71@EZASOKET
  00612	e9 a1 1c 00 00	 jmp	 $LN1@EZASOKET
$LN71@EZASOKET:

; 427  : 
; 428  :         i = aux2;

  00617	8b 84 24 f0 21
	00 00		 mov	 eax, DWORD PTR aux2$[rsp]
  0061e	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 429  :         if (i == 0) i = SOMAXCONN;

  00622	83 7c 24 40 00	 cmp	 DWORD PTR i$[rsp], 0
  00627	75 08		 jne	 SHORT $LN72@EZASOKET
  00629	c7 44 24 40 ff
	ff ff 7f	 mov	 DWORD PTR i$[rsp], 2147483647 ; 7fffffffH
$LN72@EZASOKET:

; 430  : 
; 431  :         if (listen (Ccom_han [aux1], i)) {

  00631	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  00639	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  00640	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  00644	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00648	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_listen
  0064e	85 c0		 test	 eax, eax
  00650	74 2b		 je	 SHORT $LN73@EZASOKET

; 432  : 
; 433  :             Cerr [aux1] = Get_errno ();

  00652	e8 00 00 00 00	 call	 Get_errno
  00657	48 63 8c 24 e8
	21 00 00	 movsxd	 rcx, DWORD PTR aux1$[rsp]
  0065f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cerr
  00666	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 434  : 
; 435  :             t->ret_cd = -1;

  00669	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00671	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 436  :             return;  /* ERROR */

  00678	e9 3b 1c 00 00	 jmp	 $LN1@EZASOKET
$LN73@EZASOKET:

; 437  :         }
; 438  : 
; 439  :         t->ret_cd = 0;

  0067d	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00685	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 440  :         return;

  0068c	e9 27 1c 00 00	 jmp	 $LN1@EZASOKET
$LN74@EZASOKET:

; 441  : 
; 442  :     case 9:  /* ACCEPT */
; 443  : 
; 444  :         if (check_not_sock (aux1, t)) return;

  00691	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  00699	8b 8c 24 e8 21
	00 00		 mov	 ecx, DWORD PTR aux1$[rsp]
  006a0	e8 00 00 00 00	 call	 check_not_sock
  006a5	85 c0		 test	 eax, eax
  006a7	74 05		 je	 SHORT $LN75@EZASOKET
  006a9	e9 0a 1c 00 00	 jmp	 $LN1@EZASOKET
$LN75@EZASOKET:

; 445  : 
; 446  :         obtain_lock (&tcpip_lock);

  006ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tcpip_lock
  006b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 447  : 
; 448  :         m = 1;

  006bb	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR m$[rsp], 1
$LN10@EZASOKET:

; 449  :         while (m < Ccom) {

  006c3	81 7c 24 44 00
	04 00 00	 cmp	 DWORD PTR m$[rsp], 1024	; 00000400H
  006cb	7d 22		 jge	 SHORT $LN11@EZASOKET

; 450  :             if (Ccom_opn [m] == 0) break;

  006cd	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  006d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_opn
  006d9	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  006dd	85 c0		 test	 eax, eax
  006df	75 02		 jne	 SHORT $LN76@EZASOKET
  006e1	eb 0c		 jmp	 SHORT $LN11@EZASOKET
$LN76@EZASOKET:

; 451  :             m++;

  006e3	8b 44 24 44	 mov	 eax, DWORD PTR m$[rsp]
  006e7	ff c0		 inc	 eax
  006e9	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 452  :         }

  006ed	eb d4		 jmp	 SHORT $LN10@EZASOKET
$LN11@EZASOKET:

; 453  : 
; 454  :         if (m == Ccom) {

  006ef	81 7c 24 44 00
	04 00 00	 cmp	 DWORD PTR m$[rsp], 1024	; 00000400H
  006f7	75 37		 jne	 SHORT $LN77@EZASOKET

; 455  : 
; 456  :             Cerr [aux1] = hEMFILE;

  006f9	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  00701	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cerr
  00708	c7 04 81 18 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 24

; 457  : 
; 458  :             release_lock (&tcpip_lock);

  0070f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tcpip_lock
  00716	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 459  : 
; 460  :             t->ret_cd = -1;

  0071c	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00724	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 461  :             return; /* None available. */

  0072b	e9 88 1b 00 00	 jmp	 $LN1@EZASOKET
$LN77@EZASOKET:

; 462  :         }
; 463  : 
; 464  :         isock = sizeof (Slocal_adx);

  00730	c7 44 24 4c 10
	00 00 00	 mov	 DWORD PTR isock$[rsp], 16

; 465  : 
; 466  :         timeout.tv_sec = 0;

  00738	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR timeout$[rsp], 0

; 467  :         timeout.tv_usec = 0;

  00740	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR timeout$[rsp+4], 0

; 468  : 
; 469  :         FD_ZERO (&sockets);

  00748	c7 84 24 a0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR sockets$[rsp], 0

; 470  :         FD_SET (Ccom_han [aux1], &sockets);

  00753	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  0075b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  00762	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR sockets$[rsp]
  0076a	8b 0c c1	 mov	 ecx, DWORD PTR [rcx+rax*8]
  0076d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 471  : 
; 472  :         if (select (Ccom_han [aux1] + 1, &sockets, NULL, NULL, &timeout) == 0) {

  00773	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  0077b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  00782	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00786	48 ff c0	 inc	 rax
  00789	c7 44 24 30 d8
	01 00 00	 mov	 DWORD PTR [rsp+48], 472	; 000001d8H
  00791	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159398
  00798	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0079d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR timeout$[rsp]
  007a2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  007a7	45 33 c9	 xor	 r9d, r9d
  007aa	45 33 c0	 xor	 r8d, r8d
  007ad	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR sockets$[rsp]
  007b5	8b c8		 mov	 ecx, eax
  007b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_select
  007bd	85 c0		 test	 eax, eax
  007bf	75 5f		 jne	 SHORT $LN78@EZASOKET

; 473  : 
; 474  :             release_lock (&tcpip_lock);

  007c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tcpip_lock
  007c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 475  : 
; 476  :             if (Ccom_blk [aux1]) {

  007ce	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  007d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_blk
  007dd	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  007e1	85 c0		 test	 eax, eax
  007e3	74 11		 je	 SHORT $LN79@EZASOKET

; 477  :                 t->ret_cd = -2;

  007e5	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  007ed	c7 40 20 fe ff
	ff ff		 mov	 DWORD PTR [rax+32], -2

; 478  :             } else {

  007f4	eb 25		 jmp	 SHORT $LN80@EZASOKET
$LN79@EZASOKET:

; 479  :                 Cerr [aux1] = hEWOULDBLOCK;

  007f6	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  007fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cerr
  00805	c7 04 81 23 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 35 ; 00000023H

; 480  :                 t->ret_cd = -1;

  0080c	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00814	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1
$LN80@EZASOKET:

; 481  :             }
; 482  :             return;

  0081b	e9 98 1a 00 00	 jmp	 $LN1@EZASOKET
$LN78@EZASOKET:

; 483  :         }
; 484  : 
; 485  :         l = Ccom_han [m] = accept (Ccom_han [aux1], &Slocal_adx, &isock);

  00820	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  00828	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  0082f	4c 8d 44 24 4c	 lea	 r8, QWORD PTR isock$[rsp]
  00834	48 8d 94 24 88
	01 00 00	 lea	 rdx, QWORD PTR Slocal_adx$[rsp]
  0083c	8b 0c c1	 mov	 ecx, DWORD PTR [rcx+rax*8]
  0083f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_accept
  00845	48 98		 cdqe
  00847	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv347[rsp], rax
  0084f	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  00854	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  0085b	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR tv347[rsp]
  00863	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
  00867	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv347[rsp]
  0086e	89 44 24 58	 mov	 DWORD PTR l$[rsp], eax

; 486  : 
; 487  :         if (l == INVALID_SOCKET) {

  00872	48 63 44 24 58	 movsxd	 rax, DWORD PTR l$[rsp]
  00877	48 83 f8 ff	 cmp	 rax, -1
  0087b	75 38		 jne	 SHORT $LN81@EZASOKET

; 488  : 
; 489  :             Cerr [aux1] = Get_errno ();

  0087d	e8 00 00 00 00	 call	 Get_errno
  00882	48 63 8c 24 e8
	21 00 00	 movsxd	 rcx, DWORD PTR aux1$[rsp]
  0088a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cerr
  00891	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 490  : 
; 491  :             release_lock (&tcpip_lock);

  00894	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tcpip_lock
  0089b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 492  : 
; 493  :             t->ret_cd = -1;

  008a1	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  008a9	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 494  :             return;  /* ERROR */

  008b0	e9 03 1a 00 00	 jmp	 $LN1@EZASOKET
$LN81@EZASOKET:

; 495  :         }
; 496  : 
; 497  :         Ccom_opn [m] = 1;

  008b5	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  008ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_opn
  008c1	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 498  : 
; 499  :         release_lock (&tcpip_lock);

  008c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tcpip_lock
  008cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 500  : 
; 501  :         t->len_out = sizeof (Clocal_adx);

  008d2	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  008da	c7 40 10 10 00
	00 00		 mov	 DWORD PTR [rax+16], 16

; 502  :         t->buffer_out = (char *)malloc (t->len_out);

  008e1	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  008e9	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  008ec	8b c8		 mov	 ecx, eax
  008ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  008f4	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  008fc	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 503  :         t->buffer_out_slot = find_slot ((U_LONG_PTR)&(t->buffer_out [0]));

  00900	b8 01 00 00 00	 mov	 eax, 1
  00905	48 6b c0 00	 imul	 rax, rax, 0
  00909	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00911	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00915	48 8b c8	 mov	 rcx, rax
  00918	e8 00 00 00 00	 call	 find_slot
  0091d	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00925	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 504  :         memcpy (t->buffer_out, &Slocal_adx, t->len_out);

  00928	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00930	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00933	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  0093b	48 8d 94 24 88
	01 00 00	 lea	 rdx, QWORD PTR Slocal_adx$[rsp]
  00943	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  00947	48 8b f2	 mov	 rsi, rdx
  0094a	8b c8		 mov	 ecx, eax
  0094c	f3 a4		 rep movsb

; 505  :         ((SOCKADDR_IN *)(t->buffer_out))->sin_family = htons (((SOCKADDR_IN *)(t->buffer_out))->sin_family);

  0094e	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00956	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0095a	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  0095d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  00963	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  0096b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0096f	66 89 01	 mov	 WORD PTR [rcx], ax

; 506  : 
; 507  :         t->ret_cd = m;

  00972	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  0097a	8b 4c 24 44	 mov	 ecx, DWORD PTR m$[rsp]
  0097e	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 508  :         return;

  00981	e9 32 19 00 00	 jmp	 $LN1@EZASOKET
$LN82@EZASOKET:

; 509  : 
; 510  :     case 10: /* SEND */
; 511  : 
; 512  :         if (check_not_sock (aux1, t)) return;

  00986	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  0098e	8b 8c 24 e8 21
	00 00		 mov	 ecx, DWORD PTR aux1$[rsp]
  00995	e8 00 00 00 00	 call	 check_not_sock
  0099a	85 c0		 test	 eax, eax
  0099c	74 05		 je	 SHORT $LN83@EZASOKET
  0099e	e9 15 19 00 00	 jmp	 $LN1@EZASOKET
$LN83@EZASOKET:

; 513  : 
; 514  :         if ((l = send (Ccom_han [aux1], t->buffer_in, t->len_in, 0)) == SOCKET_ERROR) {

  009a3	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  009ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  009b2	45 33 c9	 xor	 r9d, r9d
  009b5	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  009bd	44 8b 02	 mov	 r8d, DWORD PTR [rdx]
  009c0	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  009c8	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  009cc	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  009d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  009d6	89 44 24 58	 mov	 DWORD PTR l$[rsp], eax
  009da	83 7c 24 58 ff	 cmp	 DWORD PTR l$[rsp], -1
  009df	75 2b		 jne	 SHORT $LN84@EZASOKET

; 515  : 
; 516  :             Cerr [aux1] = Get_errno ();

  009e1	e8 00 00 00 00	 call	 Get_errno
  009e6	48 63 8c 24 e8
	21 00 00	 movsxd	 rcx, DWORD PTR aux1$[rsp]
  009ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cerr
  009f5	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 517  : 
; 518  :             t->ret_cd = -1;

  009f8	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00a00	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 519  :             return;

  00a07	e9 ac 18 00 00	 jmp	 $LN1@EZASOKET
$LN84@EZASOKET:

; 520  :         }
; 521  : 
; 522  :         t->ret_cd = l;

  00a0c	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00a14	8b 4c 24 58	 mov	 ecx, DWORD PTR l$[rsp]
  00a18	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 523  :         return;

  00a1b	e9 98 18 00 00	 jmp	 $LN1@EZASOKET
$LN85@EZASOKET:

; 524  : 
; 525  :     case 11: /* RECV */
; 526  : 
; 527  :         if (check_not_sock (aux1, t)) return;

  00a20	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  00a28	8b 8c 24 e8 21
	00 00		 mov	 ecx, DWORD PTR aux1$[rsp]
  00a2f	e8 00 00 00 00	 call	 check_not_sock
  00a34	85 c0		 test	 eax, eax
  00a36	74 05		 je	 SHORT $LN86@EZASOKET
  00a38	e9 7b 18 00 00	 jmp	 $LN1@EZASOKET
$LN86@EZASOKET:

; 528  : 
; 529  :         timeout.tv_sec = 0;

  00a3d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR timeout$[rsp], 0

; 530  :         timeout.tv_usec = 0;

  00a45	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR timeout$[rsp+4], 0

; 531  : 
; 532  :         FD_ZERO (&sockets);

  00a4d	c7 84 24 a0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR sockets$[rsp], 0

; 533  :         FD_SET (Ccom_han [aux1], &sockets);

  00a58	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  00a60	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  00a67	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR sockets$[rsp]
  00a6f	8b 0c c1	 mov	 ecx, DWORD PTR [rcx+rax*8]
  00a72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 534  : 
; 535  :         if (select (Ccom_han [aux1] + 1, &sockets, NULL, NULL, &timeout) == 0) {

  00a78	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  00a80	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  00a87	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00a8b	48 ff c0	 inc	 rax
  00a8e	c7 44 24 30 17
	02 00 00	 mov	 DWORD PTR [rsp+48], 535	; 00000217H
  00a96	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159408
  00a9d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00aa2	48 8d 4c 24 60	 lea	 rcx, QWORD PTR timeout$[rsp]
  00aa7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00aac	45 33 c9	 xor	 r9d, r9d
  00aaf	45 33 c0	 xor	 r8d, r8d
  00ab2	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR sockets$[rsp]
  00aba	8b c8		 mov	 ecx, eax
  00abc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_select
  00ac2	85 c0		 test	 eax, eax
  00ac4	75 52		 jne	 SHORT $LN87@EZASOKET

; 536  : 
; 537  :             if (Ccom_blk [aux1]) {

  00ac6	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  00ace	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_blk
  00ad5	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00ad9	85 c0		 test	 eax, eax
  00adb	74 11		 je	 SHORT $LN88@EZASOKET

; 538  :                 t->ret_cd = -2;

  00add	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00ae5	c7 40 20 fe ff
	ff ff		 mov	 DWORD PTR [rax+32], -2

; 539  :             } else {

  00aec	eb 25		 jmp	 SHORT $LN89@EZASOKET
$LN88@EZASOKET:

; 540  :                 Cerr [aux1] = hEWOULDBLOCK;

  00aee	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  00af6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cerr
  00afd	c7 04 81 23 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 35 ; 00000023H

; 541  :                 t->ret_cd = -1;

  00b04	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00b0c	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1
$LN89@EZASOKET:

; 542  :             }
; 543  :             return;

  00b13	e9 a0 17 00 00	 jmp	 $LN1@EZASOKET
$LN87@EZASOKET:

; 544  :         }
; 545  : 
; 546  :         t->buffer_out = (char *)malloc (aux2);

  00b18	48 63 84 24 f0
	21 00 00	 movsxd	 rax, DWORD PTR aux2$[rsp]
  00b20	48 8b c8	 mov	 rcx, rax
  00b23	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00b29	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00b31	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 547  :         t->buffer_out_slot = find_slot ((U_LONG_PTR)&(t->buffer_out [0]));

  00b35	b8 01 00 00 00	 mov	 eax, 1
  00b3a	48 6b c0 00	 imul	 rax, rax, 0
  00b3e	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00b46	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00b4a	48 8b c8	 mov	 rcx, rax
  00b4d	e8 00 00 00 00	 call	 find_slot
  00b52	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00b5a	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 548  : 
; 549  :         if ((size = recv (Ccom_han [aux1], t->buffer_out, aux2, 0)) == SOCKET_ERROR) {    /* receive command */

  00b5d	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  00b65	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  00b6c	45 33 c9	 xor	 r9d, r9d
  00b6f	44 8b 84 24 f0
	21 00 00	 mov	 r8d, DWORD PTR aux2$[rsp]
  00b77	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  00b7f	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00b83	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00b87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  00b8d	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax
  00b91	83 7c 24 68 ff	 cmp	 DWORD PTR size$[rsp], -1
  00b96	75 76		 jne	 SHORT $LN90@EZASOKET

; 550  : 
; 551  :             Cerr [aux1] = Get_errno ();

  00b98	e8 00 00 00 00	 call	 Get_errno
  00b9d	48 63 8c 24 e8
	21 00 00	 movsxd	 rcx, DWORD PTR aux1$[rsp]
  00ba5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cerr
  00bac	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 552  : 
; 553  :             t->len_out = 0;

  00baf	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00bb7	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 554  :             map32[t->buffer_out_slot] = -1;

  00bbe	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00bc6	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00bc9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map32
  00bd0	48 c7 04 c1 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax*8], -1

; 555  :             free (t->buffer_out);

  00bd8	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00be0	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00be4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 556  :             t->buffer_out = NULL;

  00bea	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00bf2	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 557  : 
; 558  :             t->ret_cd = -1;

  00bfa	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00c02	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 559  :             return;

  00c09	e9 aa 16 00 00	 jmp	 $LN1@EZASOKET
$LN90@EZASOKET:

; 560  :         }
; 561  : 
; 562  :         t->len_out = size;

  00c0e	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00c16	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  00c1a	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 563  :         t->ret_cd = size;

  00c1d	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00c25	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  00c29	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 564  :         return;

  00c2c	e9 87 16 00 00	 jmp	 $LN1@EZASOKET
$LN91@EZASOKET:

; 565  : 
; 566  :     case 12: /* CLOSE */
; 567  : 
; 568  :         if ((aux1 > 0) && (aux1 < Ccom)) {

  00c31	83 bc 24 e8 21
	00 00 00	 cmp	 DWORD PTR aux1$[rsp], 0
  00c39	0f 8e a3 00 00
	00		 jle	 $LN92@EZASOKET
  00c3f	81 bc 24 e8 21
	00 00 00 04 00
	00		 cmp	 DWORD PTR aux1$[rsp], 1024 ; 00000400H
  00c4a	0f 8d 92 00 00
	00		 jge	 $LN92@EZASOKET

; 569  :             /* close connection */
; 570  :             if (Ccom_opn [aux1])

  00c50	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  00c58	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_opn
  00c5f	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00c63	85 c0		 test	 eax, eax
  00c65	74 19		 je	 SHORT $LN93@EZASOKET

; 571  :                 closesocket (Ccom_han [aux1]);

  00c67	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  00c6f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  00c76	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00c7a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
$LN93@EZASOKET:

; 572  : 
; 573  :             Ccom_opn [aux1] = 0;

  00c80	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  00c88	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  00c90	48 81 bc 24 b0
	00 00 00 00 04
	00 00		 cmp	 QWORD PTR $T1[rsp], 1024 ; 00000400H
  00c9c	73 02		 jae	 SHORT $LN148@EZASOKET
  00c9e	eb 05		 jmp	 SHORT $LN149@EZASOKET
$LN148@EZASOKET:
  00ca0	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN149@EZASOKET:
  00ca5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Ccom_opn
  00cac	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR $T1[rsp]
  00cb4	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 574  :             Ccom_han [aux1] = -1;

  00cb8	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  00cc0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  00cc7	48 c7 04 c1 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax*8], -1

; 575  :             Ccom_blk [aux1] = 1;

  00ccf	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  00cd7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_blk
  00cde	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1
$LN92@EZASOKET:

; 576  :         }
; 577  : 
; 578  :         t->ret_cd = 0;

  00ce2	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00cea	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 579  :         return;

  00cf1	e9 c2 15 00 00	 jmp	 $LN1@EZASOKET
$LN94@EZASOKET:

; 580  : 
; 581  :     case 13: /* EBCDIC2ASCII */
; 582  : 
; 583  :         t->len_out = t->len_in;

  00cf6	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00cfe	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00d06	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00d08	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 584  :         t->buffer_out = (char *)malloc (t->len_out);

  00d0b	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00d13	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00d16	8b c8		 mov	 ecx, eax
  00d18	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00d1e	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00d26	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 585  :         t->buffer_out_slot = find_slot ((U_LONG_PTR)&(t->buffer_out [0]));

  00d2a	b8 01 00 00 00	 mov	 eax, 1
  00d2f	48 6b c0 00	 imul	 rax, rax, 0
  00d33	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00d3b	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00d3f	48 8b c8	 mov	 rcx, rax
  00d42	e8 00 00 00 00	 call	 find_slot
  00d47	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00d4f	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 586  : 
; 587  :         m = t->len_out;

  00d52	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00d5a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00d5d	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 588  :         i = 0;

  00d61	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 589  :         k = 0;

  00d69	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
$LN12@EZASOKET:

; 590  :         while (m) {

  00d71	83 7c 24 44 00	 cmp	 DWORD PTR m$[rsp], 0
  00d76	74 54		 je	 SHORT $LN13@EZASOKET

; 591  :             t->buffer_out [k++] = DCCebcdic_to_ascii [(unsigned char)(t->buffer_in [i++])];

  00d78	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00d7d	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00d85	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00d89	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d8d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DCCebcdic_to_ascii
  00d94	48 63 54 24 48	 movsxd	 rdx, DWORD PTR k$[rsp]
  00d99	48 8b bc 24 f8
	21 00 00	 mov	 rdi, QWORD PTR t$[rsp]
  00da1	48 8b 7f 18	 mov	 rdi, QWORD PTR [rdi+24]
  00da5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00da9	88 04 17	 mov	 BYTE PTR [rdi+rdx], al
  00dac	8b 44 24 48	 mov	 eax, DWORD PTR k$[rsp]
  00db0	ff c0		 inc	 eax
  00db2	89 44 24 48	 mov	 DWORD PTR k$[rsp], eax
  00db6	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00dba	ff c0		 inc	 eax
  00dbc	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 592  :             m--;

  00dc0	8b 44 24 44	 mov	 eax, DWORD PTR m$[rsp]
  00dc4	ff c8		 dec	 eax
  00dc6	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 593  :         }

  00dca	eb a5		 jmp	 SHORT $LN12@EZASOKET
$LN13@EZASOKET:

; 594  : 
; 595  :         t->ret_cd = t->len_out;

  00dcc	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00dd4	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00ddc	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00ddf	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 596  :         return;

  00de2	e9 d1 14 00 00	 jmp	 $LN1@EZASOKET
$LN95@EZASOKET:

; 597  : 
; 598  :     case 14: /* ASCII2EBCDIC */
; 599  : 
; 600  :         t->len_out = t->len_in;

  00de7	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00def	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00df7	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00df9	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 601  :         t->buffer_out = (char *)malloc (t->len_out);

  00dfc	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00e04	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00e07	8b c8		 mov	 ecx, eax
  00e09	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00e0f	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00e17	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 602  :         t->buffer_out_slot = find_slot ((U_LONG_PTR)&(t->buffer_out [0]));

  00e1b	b8 01 00 00 00	 mov	 eax, 1
  00e20	48 6b c0 00	 imul	 rax, rax, 0
  00e24	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00e2c	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  00e30	48 8b c8	 mov	 rcx, rax
  00e33	e8 00 00 00 00	 call	 find_slot
  00e38	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00e40	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 603  : 
; 604  :         m = t->len_out;

  00e43	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00e4b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00e4e	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 605  :         i = 0;

  00e52	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 606  :         k = 0;

  00e5a	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
$LN14@EZASOKET:

; 607  :         while (m) {

  00e62	83 7c 24 44 00	 cmp	 DWORD PTR m$[rsp], 0
  00e67	74 54		 je	 SHORT $LN15@EZASOKET

; 608  :             t->buffer_out [k++] = DCCascii_to_ebcdic [(unsigned char)(t->buffer_in [i++])];

  00e69	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00e6e	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00e76	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00e7a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e7e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DCCascii_to_ebcdic
  00e85	48 63 54 24 48	 movsxd	 rdx, DWORD PTR k$[rsp]
  00e8a	48 8b bc 24 f8
	21 00 00	 mov	 rdi, QWORD PTR t$[rsp]
  00e92	48 8b 7f 18	 mov	 rdi, QWORD PTR [rdi+24]
  00e96	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e9a	88 04 17	 mov	 BYTE PTR [rdi+rdx], al
  00e9d	8b 44 24 48	 mov	 eax, DWORD PTR k$[rsp]
  00ea1	ff c0		 inc	 eax
  00ea3	89 44 24 48	 mov	 DWORD PTR k$[rsp], eax
  00ea7	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00eab	ff c0		 inc	 eax
  00ead	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 609  :             m--;

  00eb1	8b 44 24 44	 mov	 eax, DWORD PTR m$[rsp]
  00eb5	ff c8		 dec	 eax
  00eb7	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 610  :         }

  00ebb	eb a5		 jmp	 SHORT $LN14@EZASOKET
$LN15@EZASOKET:

; 611  : 
; 612  :         t->ret_cd = t->len_out;

  00ebd	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00ec5	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  00ecd	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00ed0	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 613  :         return;

  00ed3	e9 e0 13 00 00	 jmp	 $LN1@EZASOKET
$LN96@EZASOKET:

; 614  : 
; 615  :     case 15: /* IOCTL */
; 616  : 
; 617  :         m = func >> 16;

  00ed8	8b 84 24 e0 21
	00 00		 mov	 eax, DWORD PTR func$[rsp]
  00edf	c1 e8 10	 shr	 eax, 16
  00ee2	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 618  : 
; 619  :         if (check_not_sock (m, t)) return;

  00ee6	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  00eee	8b 4c 24 44	 mov	 ecx, DWORD PTR m$[rsp]
  00ef2	e8 00 00 00 00	 call	 check_not_sock
  00ef7	85 c0		 test	 eax, eax
  00ef9	74 05		 je	 SHORT $LN97@EZASOKET
  00efb	e9 b8 13 00 00	 jmp	 $LN1@EZASOKET
$LN97@EZASOKET:

; 620  : 
; 621  :         if (aux1 == 1) {

  00f00	83 bc 24 e8 21
	00 00 01	 cmp	 DWORD PTR aux1$[rsp], 1
  00f08	75 62		 jne	 SHORT $LN98@EZASOKET

; 622  : 
; 623  :             if (aux2) {

  00f0a	83 bc 24 f0 21
	00 00 00	 cmp	 DWORD PTR aux2$[rsp], 0
  00f12	74 37		 je	 SHORT $LN100@EZASOKET

; 624  :                 Ccom_blk [m] = 0; /* No longer blocking */

  00f14	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  00f19	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR $T2[rsp], rax
  00f21	48 81 bc 24 b8
	00 00 00 00 04
	00 00		 cmp	 QWORD PTR $T2[rsp], 1024 ; 00000400H
  00f2d	73 02		 jae	 SHORT $LN150@EZASOKET
  00f2f	eb 05		 jmp	 SHORT $LN151@EZASOKET
$LN150@EZASOKET:
  00f31	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN151@EZASOKET:
  00f36	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Ccom_blk
  00f3d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR $T2[rsp]
  00f45	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 625  :             } else {

  00f49	eb 10		 jmp	 SHORT $LN101@EZASOKET
$LN100@EZASOKET:

; 626  :                 Ccom_blk [m] = 1;

  00f4b	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  00f50	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_blk
  00f57	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1
$LN101@EZASOKET:

; 627  :             }
; 628  : 
; 629  :             t->ret_cd = 0;

  00f5b	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00f63	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 630  : 
; 631  :         } else {

  00f6a	eb 68		 jmp	 SHORT $LN99@EZASOKET
$LN98@EZASOKET:

; 632  : 
; 633  :             i = ioctlsocket (Ccom_han [m], FIONREAD, &(t->ret_cd));

  00f6c	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00f74	48 83 c0 20	 add	 rax, 32			; 00000020H
  00f78	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  00f7d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Ccom_han
  00f84	48 89 94 24 c8
	00 00 00	 mov	 QWORD PTR tv1397[rsp], rdx
  00f8c	4c 8b c0	 mov	 r8, rax
  00f8f	ba 7f 66 04 40	 mov	 edx, 1074030207		; 4004667fH
  00f94	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv1397[rsp]
  00f9c	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00fa0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ioctlsocket
  00fa6	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 634  :             if (i == -1) {

  00faa	83 7c 24 40 ff	 cmp	 DWORD PTR i$[rsp], -1
  00faf	75 23		 jne	 SHORT $LN102@EZASOKET

; 635  :                 t->ret_cd = -1;

  00fb1	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00fb9	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 636  :                 Cerr [m] = Get_errno ();

  00fc0	e8 00 00 00 00	 call	 Get_errno
  00fc5	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  00fca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cerr
  00fd1	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
$LN102@EZASOKET:
$LN99@EZASOKET:

; 637  :             }
; 638  :         }
; 639  : 
; 640  :         return;

  00fd4	e9 df 12 00 00	 jmp	 $LN1@EZASOKET
$LN103@EZASOKET:

; 641  : 
; 642  :     case 16: /* GETSOCKNAME */
; 643  : 
; 644  :         if (check_not_sock (aux1, t)) return;

  00fd9	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  00fe1	8b 8c 24 e8 21
	00 00		 mov	 ecx, DWORD PTR aux1$[rsp]
  00fe8	e8 00 00 00 00	 call	 check_not_sock
  00fed	85 c0		 test	 eax, eax
  00fef	74 05		 je	 SHORT $LN104@EZASOKET
  00ff1	e9 c2 12 00 00	 jmp	 $LN1@EZASOKET
$LN104@EZASOKET:

; 645  : 
; 646  :         t->len_out = sizeof (Clocal_adx);

  00ff6	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00ffe	c7 40 10 10 00
	00 00		 mov	 DWORD PTR [rax+16], 16

; 647  :         t->buffer_out = (char *)malloc (t->len_out);

  01005	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  0100d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  01010	8b c8		 mov	 ecx, eax
  01012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  01018	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01020	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 648  :         t->buffer_out_slot = find_slot ((U_LONG_PTR)&(t->buffer_out [0]));

  01024	b8 01 00 00 00	 mov	 eax, 1
  01029	48 6b c0 00	 imul	 rax, rax, 0
  0102d	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01035	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  01039	48 8b c8	 mov	 rcx, rax
  0103c	e8 00 00 00 00	 call	 find_slot
  01041	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01049	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 649  : 
; 650  :         isock = t->len_out;

  0104c	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01054	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  01057	89 44 24 4c	 mov	 DWORD PTR isock$[rsp], eax

; 651  :         t->ret_cd = getsockname (Ccom_han [aux1], (struct sockaddr *)(t->buffer_out), &isock);

  0105b	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  01063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  0106a	4c 8d 44 24 4c	 lea	 r8, QWORD PTR isock$[rsp]
  0106f	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  01077	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  0107b	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0107f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getsockname
  01085	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  0108d	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 652  : 
; 653  :         if (t->ret_cd == -1) {

  01090	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01098	83 78 20 ff	 cmp	 DWORD PTR [rax+32], -1
  0109c	75 19		 jne	 SHORT $LN105@EZASOKET

; 654  :             Cerr [aux1] = Get_errno ();

  0109e	e8 00 00 00 00	 call	 Get_errno
  010a3	48 63 8c 24 e8
	21 00 00	 movsxd	 rcx, DWORD PTR aux1$[rsp]
  010ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cerr
  010b2	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 655  :         } else {

  010b5	eb 24		 jmp	 SHORT $LN106@EZASOKET
$LN105@EZASOKET:

; 656  :             ((SOCKADDR_IN *)(t->buffer_out))->sin_family = htons (((SOCKADDR_IN *)(t->buffer_out))->sin_family);

  010b7	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  010bf	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  010c3	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  010c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  010cc	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  010d4	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  010d8	66 89 01	 mov	 WORD PTR [rcx], ax
$LN106@EZASOKET:

; 657  :         }
; 658  : 
; 659  :         return;

  010db	e9 d8 11 00 00	 jmp	 $LN1@EZASOKET
$LN107@EZASOKET:

; 660  : 
; 661  :     case 17: /* SELECT */
; 662  : 
; 663  :         /* func>>16 = socket
; 664  :            aux1 = func subcode
; 665  :            aux2 = maxsock+1 */
; 666  : 
; 667  :         m = func >> 16;

  010e0	8b 84 24 e0 21
	00 00		 mov	 eax, DWORD PTR func$[rsp]
  010e7	c1 e8 10	 shr	 eax, 16
  010ea	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 668  : 
; 669  :         if (check_not_sock (m, t)) return;

  010ee	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  010f6	8b 4c 24 44	 mov	 ecx, DWORD PTR m$[rsp]
  010fa	e8 00 00 00 00	 call	 check_not_sock
  010ff	85 c0		 test	 eax, eax
  01101	74 05		 je	 SHORT $LN108@EZASOKET
  01103	e9 b0 11 00 00	 jmp	 $LN1@EZASOKET
$LN108@EZASOKET:

; 670  : 
; 671  :         switch (aux1 & 0xFF) {

  01108	8b 84 24 e8 21
	00 00		 mov	 eax, DWORD PTR aux1$[rsp]
  0110f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01114	89 44 24 78	 mov	 DWORD PTR tv679[rsp], eax
  01118	83 7c 24 78 08	 cmp	 DWORD PTR tv679[rsp], 8
  0111d	0f 87 fc 0e 00
	00		 ja	 $LN16@EZASOKET
  01123	48 63 44 24 78	 movsxd	 rax, DWORD PTR tv679[rsp]
  01128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0112f	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN152@EZASOKET[rcx+rax*4]
  01136	48 03 c1	 add	 rax, rcx
  01139	ff e0		 jmp	 rax
$LN109@EZASOKET:

; 672  :         case 0:  /* Start */
; 673  :             if (Cselect [m] == NULL) { /* Start-part */

  0113b	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01147	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0114c	0f 85 d5 00 00
	00		 jne	 $LN110@EZASOKET

; 674  : 
; 675  :                 Cselect [m] = malloc (sizeof (selects));

  01152	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  01157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0115d	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  01162	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cselect
  01169	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 676  : 
; 677  :                 Cselect [m]->ri = malloc (sizeof (fd_set));

  0116d	b9 08 20 00 00	 mov	 ecx, 8200		; 00002008H
  01172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  01178	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  0117d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cselect
  01184	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  01188	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 678  :                 Cselect [m]->wi = malloc (sizeof (fd_set));

  0118c	b9 08 20 00 00	 mov	 ecx, 8200		; 00002008H
  01191	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  01197	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  0119c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cselect
  011a3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  011a7	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 679  :                 Cselect [m]->ei = malloc (sizeof (fd_set));

  011ab	b9 08 20 00 00	 mov	 ecx, 8200		; 00002008H
  011b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  011b6	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  011bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cselect
  011c2	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  011c6	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 680  : 
; 681  :                 Cselect [m]->ro = malloc (sizeof (fd_set));

  011ca	b9 08 20 00 00	 mov	 ecx, 8200		; 00002008H
  011cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  011d5	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  011da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cselect
  011e1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  011e5	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 682  :                 Cselect [m]->wo = malloc (sizeof (fd_set));

  011e9	b9 08 20 00 00	 mov	 ecx, 8200		; 00002008H
  011ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  011f4	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  011f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cselect
  01200	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  01204	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 683  :                 Cselect [m]->eo = malloc (sizeof (fd_set));

  01208	b9 08 20 00 00	 mov	 ecx, 8200		; 00002008H
  0120d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  01213	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  01218	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cselect
  0121f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  01223	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN110@EZASOKET:

; 684  :             }
; 685  : 
; 686  :             FD_ZERO ((fd_set *)(Cselect [m]->ri));

  01227	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  0122c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01233	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01237	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0123b	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 687  :             FD_ZERO ((fd_set *)(Cselect [m]->wi));

  01241	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01246	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  0124d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01251	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01255	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 688  :             FD_ZERO ((fd_set *)(Cselect [m]->ei));

  0125b	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01260	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01267	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0126b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0126f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 689  : 
; 690  :             Cselect [m]->len = 0;

  01275	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  0127a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01281	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01285	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 691  :             Cselect [m]->invalid = 0;

  0128b	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01297	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0129b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 692  : 
; 693  :             t->ret_cd = 0;

  012a2	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  012aa	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 694  :             return;

  012b1	e9 02 10 00 00	 jmp	 $LN1@EZASOKET
$LN111@EZASOKET:

; 695  : 
; 696  :         case 1:  /* Read Inputs */
; 697  : 
; 698  :             Cselect [m]->len = t->len_in; /* Copy every time... */

  012b6	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  012bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  012c2	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  012c6	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  012ce	8b 09		 mov	 ecx, DWORD PTR [rcx]
  012d0	89 08		 mov	 DWORD PTR [rax], ecx

; 699  : 
; 700  :             /* Need to bswap every long in the incoming array... */
; 701  :             i = t->len_in / 4;

  012d2	33 d2		 xor	 edx, edx
  012d4	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  012dc	8b 00		 mov	 eax, DWORD PTR [rax]
  012de	b9 04 00 00 00	 mov	 ecx, 4
  012e3	f7 f1		 div	 ecx
  012e5	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN18@EZASOKET:

; 702  :             while (i) {

  012e9	83 7c 24 40 00	 cmp	 DWORD PTR i$[rsp], 0
  012ee	74 3a		 je	 SHORT $LN19@EZASOKET

; 703  :                 i--;

  012f0	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  012f4	ff c8		 dec	 eax
  012f6	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 704  :                 ((u_int  *)t->buffer_in) [i] = htonl (((u_int  *)t->buffer_in) [i]);

  012fa	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  012ff	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01307	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0130b	8b 0c 81	 mov	 ecx, DWORD PTR [rcx+rax*4]
  0130e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  01314	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01319	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  01321	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  01325	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 705  :             }

  01328	eb bf		 jmp	 SHORT $LN18@EZASOKET
$LN19@EZASOKET:

; 706  : 
; 707  :             i = 0;

  0132a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN20@EZASOKET:

; 708  :             while (i < aux2) {

  01332	8b 84 24 f0 21
	00 00		 mov	 eax, DWORD PTR aux2$[rsp]
  01339	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  0133d	0f 8d e4 00 00
	00		 jge	 $LN21@EZASOKET

; 709  :                 if (hercFD_ISSET (i, (hercfd_set *)(t->buffer_in))) {

  01343	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  0134b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0134f	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv1523[rsp], rax
  01357	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  0135c	33 d2		 xor	 edx, edx
  0135e	48 8b c1	 mov	 rax, rcx
  01361	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01366	48 f7 f1	 div	 rcx
  01369	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv793[rsp], rax
  01371	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01376	33 d2		 xor	 edx, edx
  01378	48 8b c1	 mov	 rax, rcx
  0137b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01380	48 f7 f1	 div	 rcx
  01383	48 8b c2	 mov	 rax, rdx
  01386	b9 01 00 00 00	 mov	 ecx, 1
  0138b	89 4c 24 7c	 mov	 DWORD PTR tv1962[rsp], ecx
  0138f	0f b6 c8	 movzx	 ecx, al
  01392	8b 44 24 7c	 mov	 eax, DWORD PTR tv1962[rsp]
  01396	d3 e0		 shl	 eax, cl
  01398	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv793[rsp]
  013a0	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR tv1523[rsp]
  013a8	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  013ab	23 c8		 and	 ecx, eax
  013ad	8b c1		 mov	 eax, ecx
  013af	85 c0		 test	 eax, eax
  013b1	74 65		 je	 SHORT $LN112@EZASOKET

; 710  :                     if (Ccom_han [i] == -1) {

  013b3	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  013b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  013bf	48 83 3c c1 ff	 cmp	 QWORD PTR [rcx+rax*8], -1
  013c4	75 19		 jne	 SHORT $LN113@EZASOKET

; 711  :                         Cselect [m]->invalid = 1;

  013c6	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  013cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  013d2	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  013d6	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1

; 712  :                     } else {

  013dd	eb 39		 jmp	 SHORT $LN114@EZASOKET
$LN113@EZASOKET:

; 713  :                         FD_SET (Ccom_han [i], (fd_set *)(Cselect [m]->ri));

  013df	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  013e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  013eb	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  013ef	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  013f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Ccom_han
  013fb	48 89 94 24 e0
	00 00 00	 mov	 QWORD PTR tv1418[rsp], rdx
  01403	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  01407	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv1418[rsp]
  0140f	8b 0c c8	 mov	 ecx, DWORD PTR [rax+rcx*8]
  01412	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET
$LN114@EZASOKET:
$LN112@EZASOKET:

; 714  :                     }
; 715  :                 }
; 716  :                 i++;

  01418	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0141c	ff c0		 inc	 eax
  0141e	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 717  :             }

  01422	e9 0b ff ff ff	 jmp	 $LN20@EZASOKET
$LN21@EZASOKET:

; 718  : 
; 719  :             t->ret_cd = 0;

  01427	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  0142f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 720  :             return;

  01436	e9 7d 0e 00 00	 jmp	 $LN1@EZASOKET
$LN115@EZASOKET:

; 721  : 
; 722  :         case 2:  /* Write Inputs */
; 723  : 
; 724  :             Cselect [m]->len = t->len_in; /* Copy every time... */

  0143b	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01440	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01447	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0144b	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01453	8b 09		 mov	 ecx, DWORD PTR [rcx]
  01455	89 08		 mov	 DWORD PTR [rax], ecx

; 725  : 
; 726  :             /* Need to bswap every long in the incoming array... */
; 727  :             i = t->len_in / 4;

  01457	33 d2		 xor	 edx, edx
  01459	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01461	8b 00		 mov	 eax, DWORD PTR [rax]
  01463	b9 04 00 00 00	 mov	 ecx, 4
  01468	f7 f1		 div	 ecx
  0146a	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN22@EZASOKET:

; 728  :             while (i) {

  0146e	83 7c 24 40 00	 cmp	 DWORD PTR i$[rsp], 0
  01473	74 3a		 je	 SHORT $LN23@EZASOKET

; 729  :                 i--;

  01475	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  01479	ff c8		 dec	 eax
  0147b	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 730  :                 ((u_int  *)t->buffer_in) [i] = htonl (((u_int  *)t->buffer_in) [i]);

  0147f	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  01484	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  0148c	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  01490	8b 0c 81	 mov	 ecx, DWORD PTR [rcx+rax*4]
  01493	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  01499	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  0149e	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  014a6	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  014aa	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 731  :             }

  014ad	eb bf		 jmp	 SHORT $LN22@EZASOKET
$LN23@EZASOKET:

; 732  : 
; 733  :             i = 0;

  014af	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN24@EZASOKET:

; 734  :             while (i < aux2) {

  014b7	8b 84 24 f0 21
	00 00		 mov	 eax, DWORD PTR aux2$[rsp]
  014be	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  014c2	0f 8d ea 00 00
	00		 jge	 $LN25@EZASOKET

; 735  :                 if (hercFD_ISSET (i, (hercfd_set *)(t->buffer_in))) {

  014c8	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  014d0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  014d4	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv1517[rsp], rax
  014dc	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  014e1	33 d2		 xor	 edx, edx
  014e3	48 8b c1	 mov	 rax, rcx
  014e6	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  014eb	48 f7 f1	 div	 rcx
  014ee	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv843[rsp], rax
  014f6	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  014fb	33 d2		 xor	 edx, edx
  014fd	48 8b c1	 mov	 rax, rcx
  01500	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01505	48 f7 f1	 div	 rcx
  01508	48 8b c2	 mov	 rax, rdx
  0150b	b9 01 00 00 00	 mov	 ecx, 1
  01510	89 8c 24 80 00
	00 00		 mov	 DWORD PTR tv1982[rsp], ecx
  01517	0f b6 c8	 movzx	 ecx, al
  0151a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv1982[rsp]
  01521	d3 e0		 shl	 eax, cl
  01523	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv843[rsp]
  0152b	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR tv1517[rsp]
  01533	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  01536	23 c8		 and	 ecx, eax
  01538	8b c1		 mov	 eax, ecx
  0153a	85 c0		 test	 eax, eax
  0153c	74 65		 je	 SHORT $LN116@EZASOKET

; 736  :                     if (Ccom_han [i] == -1) {

  0153e	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  01543	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  0154a	48 83 3c c1 ff	 cmp	 QWORD PTR [rcx+rax*8], -1
  0154f	75 19		 jne	 SHORT $LN117@EZASOKET

; 737  :                         Cselect [m]->invalid = 1;

  01551	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01556	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  0155d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01561	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1

; 738  :                     } else {

  01568	eb 39		 jmp	 SHORT $LN118@EZASOKET
$LN117@EZASOKET:

; 739  :                         FD_SET (Ccom_han [i], (fd_set *)(Cselect [m]->wi));

  0156a	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  0156f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01576	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0157a	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  0157f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Ccom_han
  01586	48 89 94 24 f8
	00 00 00	 mov	 QWORD PTR tv1423[rsp], rdx
  0158e	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  01592	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR tv1423[rsp]
  0159a	8b 0c c8	 mov	 ecx, DWORD PTR [rax+rcx*8]
  0159d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET
$LN118@EZASOKET:
$LN116@EZASOKET:

; 740  :                     }
; 741  :                 }
; 742  :                 i++;

  015a3	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  015a7	ff c0		 inc	 eax
  015a9	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 743  :             }

  015ad	e9 05 ff ff ff	 jmp	 $LN24@EZASOKET
$LN25@EZASOKET:

; 744  : 
; 745  :             t->ret_cd = 0;

  015b2	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  015ba	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 746  :             return;

  015c1	e9 f2 0c 00 00	 jmp	 $LN1@EZASOKET
$LN119@EZASOKET:

; 747  : 
; 748  :         case 3:  /* Exception Inputs */
; 749  : 
; 750  :             Cselect [m]->len = t->len_in; /* Copy every time... */

  015c6	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  015cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  015d2	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  015d6	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  015de	8b 09		 mov	 ecx, DWORD PTR [rcx]
  015e0	89 08		 mov	 DWORD PTR [rax], ecx

; 751  : 
; 752  :             /* Need to bswap every long in the incoming array... */
; 753  :             i = t->len_in / 4;

  015e2	33 d2		 xor	 edx, edx
  015e4	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  015ec	8b 00		 mov	 eax, DWORD PTR [rax]
  015ee	b9 04 00 00 00	 mov	 ecx, 4
  015f3	f7 f1		 div	 ecx
  015f5	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN26@EZASOKET:

; 754  :             while (i) {

  015f9	83 7c 24 40 00	 cmp	 DWORD PTR i$[rsp], 0
  015fe	74 3a		 je	 SHORT $LN27@EZASOKET

; 755  :                 i--;

  01600	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  01604	ff c8		 dec	 eax
  01606	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 756  :                 ((u_int  *)t->buffer_in) [i] = htonl (((u_int  *)t->buffer_in) [i]);

  0160a	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0160f	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01617	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0161b	8b 0c 81	 mov	 ecx, DWORD PTR [rcx+rax*4]
  0161e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  01624	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01629	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  01631	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  01635	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 757  :             }

  01638	eb bf		 jmp	 SHORT $LN26@EZASOKET
$LN27@EZASOKET:

; 758  : 
; 759  :             i = 0;

  0163a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN28@EZASOKET:

; 760  :             while (i < aux2) {

  01642	8b 84 24 f0 21
	00 00		 mov	 eax, DWORD PTR aux2$[rsp]
  01649	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  0164d	0f 8d ea 00 00
	00		 jge	 $LN29@EZASOKET

; 761  :                 if (hercFD_ISSET (i, (hercfd_set *)(t->buffer_in))) {

  01653	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  0165b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0165f	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv1511[rsp], rax
  01667	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  0166c	33 d2		 xor	 edx, edx
  0166e	48 8b c1	 mov	 rax, rcx
  01671	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01676	48 f7 f1	 div	 rcx
  01679	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv893[rsp], rax
  01681	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01686	33 d2		 xor	 edx, edx
  01688	48 8b c1	 mov	 rax, rcx
  0168b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01690	48 f7 f1	 div	 rcx
  01693	48 8b c2	 mov	 rax, rdx
  01696	b9 01 00 00 00	 mov	 ecx, 1
  0169b	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv2002[rsp], ecx
  016a2	0f b6 c8	 movzx	 ecx, al
  016a5	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv2002[rsp]
  016ac	d3 e0		 shl	 eax, cl
  016ae	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv893[rsp]
  016b6	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR tv1511[rsp]
  016be	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  016c1	23 c8		 and	 ecx, eax
  016c3	8b c1		 mov	 eax, ecx
  016c5	85 c0		 test	 eax, eax
  016c7	74 65		 je	 SHORT $LN120@EZASOKET

; 762  :                     if (Ccom_han [i] == -1) {

  016c9	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  016ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  016d5	48 83 3c c1 ff	 cmp	 QWORD PTR [rcx+rax*8], -1
  016da	75 19		 jne	 SHORT $LN121@EZASOKET

; 763  :                         Cselect [m]->invalid = 1;

  016dc	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  016e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  016e8	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  016ec	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1

; 764  :                     } else {

  016f3	eb 39		 jmp	 SHORT $LN122@EZASOKET
$LN121@EZASOKET:

; 765  :                         FD_SET (Ccom_han [i], (fd_set *)(Cselect [m]->ei));

  016f5	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  016fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01701	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01705	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  0170a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Ccom_han
  01711	48 89 94 24 10
	01 00 00	 mov	 QWORD PTR tv1428[rsp], rdx
  01719	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  0171d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR tv1428[rsp]
  01725	8b 0c c8	 mov	 ecx, DWORD PTR [rax+rcx*8]
  01728	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET
$LN122@EZASOKET:
$LN120@EZASOKET:

; 766  :                     }
; 767  :                 }
; 768  :                 i++;

  0172e	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  01732	ff c0		 inc	 eax
  01734	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 769  :             }

  01738	e9 05 ff ff ff	 jmp	 $LN28@EZASOKET
$LN29@EZASOKET:

; 770  : 
; 771  :             t->ret_cd = 0;

  0173d	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01745	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 772  :             return;

  0174c	e9 67 0b 00 00	 jmp	 $LN1@EZASOKET
$LN123@EZASOKET:

; 773  : 
; 774  :         case 4:  /* Run 'select' (never blocking here, so may loop back.) */
; 775  : 
; 776  :             memcpy (Cselect [m]->ro, Cselect [m]->ri, sizeof (fd_set));

  01751	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01756	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  0175d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01761	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  01766	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cselect
  0176d	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  01771	48 8b 79 20	 mov	 rdi, QWORD PTR [rcx+32]
  01775	48 8b 70 08	 mov	 rsi, QWORD PTR [rax+8]
  01779	b9 08 20 00 00	 mov	 ecx, 8200		; 00002008H
  0177e	f3 a4		 rep movsb

; 777  :             memcpy (Cselect [m]->wo, Cselect [m]->wi, sizeof (fd_set));

  01780	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01785	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  0178c	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01790	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  01795	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cselect
  0179c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  017a0	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  017a4	48 8b 70 10	 mov	 rsi, QWORD PTR [rax+16]
  017a8	b9 08 20 00 00	 mov	 ecx, 8200		; 00002008H
  017ad	f3 a4		 rep movsb

; 778  :             memcpy (Cselect [m]->eo, Cselect [m]->ei, sizeof (fd_set));

  017af	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  017b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  017bb	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  017bf	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  017c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cselect
  017cb	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  017cf	48 8b 79 30	 mov	 rdi, QWORD PTR [rcx+48]
  017d3	48 8b 70 18	 mov	 rsi, QWORD PTR [rax+24]
  017d7	b9 08 20 00 00	 mov	 ecx, 8200		; 00002008H
  017dc	f3 a4		 rep movsb

; 779  : 
; 780  :             if (Cselect [m]->invalid) {

  017de	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  017e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  017ea	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  017ee	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  017f2	74 27		 je	 SHORT $LN124@EZASOKET

; 781  :                 Cerr [m] = hENOTSOCK;

  017f4	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  017f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cerr
  01800	c7 04 81 26 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 38 ; 00000026H

; 782  :                 t->ret_cd = -1;

  01807	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  0180f	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 783  :                 return;

  01816	e9 9d 0a 00 00	 jmp	 $LN1@EZASOKET
$LN124@EZASOKET:

; 784  :             }
; 785  : 
; 786  :             timeout.tv_sec = 0;

  0181b	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR timeout$[rsp], 0

; 787  :             timeout.tv_usec = 0;

  01823	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR timeout$[rsp+4], 0

; 788  : 
; 789  :             i = select (Ccom_han [aux2 - 1] + 1,

  0182b	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01830	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01837	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0183b	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR m$[rsp]
  01840	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cselect
  01847	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0184b	48 63 54 24 44	 movsxd	 rdx, DWORD PTR m$[rsp]
  01850	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:Cselect
  01857	48 8b 14 d7	 mov	 rdx, QWORD PTR [rdi+rdx*8]
  0185b	8b bc 24 f0 21
	00 00		 mov	 edi, DWORD PTR aux2$[rsp]
  01862	ff cf		 dec	 edi
  01864	48 63 ff	 movsxd	 rdi, edi
  01867	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:Ccom_han
  0186e	48 8b 3c fe	 mov	 rdi, QWORD PTR [rsi+rdi*8]
  01872	48 ff c7	 inc	 rdi
  01875	c7 44 24 30 19
	03 00 00	 mov	 DWORD PTR [rsp+48], 793	; 00000319H
  0187d	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:$SG159446
  01884	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  01889	48 8d 74 24 60	 lea	 rsi, QWORD PTR timeout$[rsp]
  0188e	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  01893	4c 8b 48 30	 mov	 r9, QWORD PTR [rax+48]
  01897	4c 8b 41 28	 mov	 r8, QWORD PTR [rcx+40]
  0189b	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  0189f	8b cf		 mov	 ecx, edi
  018a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_select
  018a7	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 790  :                         (fd_set *)(Cselect [m]->ro),
; 791  :                         (fd_set *)(Cselect [m]->wo),
; 792  :                         (fd_set *)(Cselect [m]->eo),
; 793  :                         &timeout);
; 794  : 
; 795  :             if (i == 0) {

  018ab	83 7c 24 40 00	 cmp	 DWORD PTR i$[rsp], 0
  018b0	75 11		 jne	 SHORT $LN125@EZASOKET

; 796  :                 t->ret_cd = -2; /* Let the caller decide what to do. */

  018b2	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  018ba	c7 40 20 fe ff
	ff ff		 mov	 DWORD PTR [rax+32], -2

; 797  :             } else {

  018c1	eb 0f		 jmp	 SHORT $LN126@EZASOKET
$LN125@EZASOKET:

; 798  :                 t->ret_cd = i;

  018c3	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  018cb	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  018cf	89 48 20	 mov	 DWORD PTR [rax+32], ecx
$LN126@EZASOKET:

; 799  :             }
; 800  :             return;

  018d2	e9 e1 09 00 00	 jmp	 $LN1@EZASOKET
$LN127@EZASOKET:

; 801  : 
; 802  :         case 5:  /* Read Outputs */
; 803  : 
; 804  :             t->len_out = Cselect [m]->len;

  018d7	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  018dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  018e3	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  018e7	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  018ef	8b 00		 mov	 eax, DWORD PTR [rax]
  018f1	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 805  :             t->buffer_out = (char *)malloc (t->len_out);

  018f4	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  018fc	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  018ff	8b c8		 mov	 ecx, eax
  01901	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  01907	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  0190f	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 806  :             t->buffer_out_slot = find_slot ((U_LONG_PTR)&(t->buffer_out [0]));

  01913	b8 01 00 00 00	 mov	 eax, 1
  01918	48 6b c0 00	 imul	 rax, rax, 0
  0191c	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01924	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  01928	48 8b c8	 mov	 rcx, rax
  0192b	e8 00 00 00 00	 call	 find_slot
  01930	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01938	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 807  :             memset (t->buffer_out, 0, t->len_out);

  0193b	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01943	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  01946	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv1019[rsp], rax
  0194e	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01956	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  0195a	33 c0		 xor	 eax, eax
  0195c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv1019[rsp]
  01964	f3 aa		 rep stosb

; 808  : 
; 809  :             i = 0;

  01966	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN30@EZASOKET:

; 810  :             while (i < aux2) {

  0196e	8b 84 24 f0 21
	00 00		 mov	 eax, DWORD PTR aux2$[rsp]
  01975	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  01979	0f 8d 08 01 00
	00		 jge	 $LN31@EZASOKET

; 811  :                 if (Ccom_han [i] != -1)

  0197f	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  01984	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  0198b	48 83 3c c1 ff	 cmp	 QWORD PTR [rcx+rax*8], -1
  01990	0f 84 e2 00 00
	00		 je	 $LN128@EZASOKET

; 812  :                     if (FD_ISSET (Ccom_han [i], (fd_set *)(Cselect [m]->ro)))

  01996	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  0199b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  019a2	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  019a6	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  019ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Ccom_han
  019b2	48 89 94 24 20
	01 00 00	 mov	 QWORD PTR tv1444[rsp], rdx
  019ba	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  019be	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR tv1444[rsp]
  019c6	8b 0c c8	 mov	 ecx, DWORD PTR [rax+rcx*8]
  019c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  019cf	85 c0		 test	 eax, eax
  019d1	0f 84 a1 00 00
	00		 je	 $LN129@EZASOKET

; 813  :                         hercFD_SET (i, (hercfd_set *)(t->buffer_out));

  019d7	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  019df	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  019e3	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv1494[rsp], rax
  019eb	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  019f0	33 d2		 xor	 edx, edx
  019f2	48 8b c1	 mov	 rax, rcx
  019f5	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  019fa	48 f7 f1	 div	 rcx
  019fd	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv1042[rsp], rax
  01a05	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01a0a	33 d2		 xor	 edx, edx
  01a0c	48 8b c1	 mov	 rax, rcx
  01a0f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01a14	48 f7 f1	 div	 rcx
  01a17	48 8b c2	 mov	 rax, rdx
  01a1a	b9 01 00 00 00	 mov	 ecx, 1
  01a1f	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv2044[rsp], ecx
  01a26	0f b6 c8	 movzx	 ecx, al
  01a29	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv2044[rsp]
  01a30	d3 e0		 shl	 eax, cl
  01a32	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv1042[rsp]
  01a3a	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR tv1494[rsp]
  01a42	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  01a45	0b c8		 or	 ecx, eax
  01a47	8b c1		 mov	 eax, ecx
  01a49	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv1054[rsp], eax
  01a50	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01a55	33 d2		 xor	 edx, edx
  01a57	48 8b c1	 mov	 rax, rcx
  01a5a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01a5f	48 f7 f1	 div	 rcx
  01a62	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01a6a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  01a6e	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR tv1054[rsp]
  01a75	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN129@EZASOKET:
$LN128@EZASOKET:

; 814  :                 i++;

  01a78	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  01a7c	ff c0		 inc	 eax
  01a7e	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 815  :             }

  01a82	e9 e7 fe ff ff	 jmp	 $LN30@EZASOKET
$LN31@EZASOKET:

; 816  : 
; 817  :             /* Need to bswap every long in the outgoing array... */
; 818  :             i = t->len_out / 4;

  01a87	33 d2		 xor	 edx, edx
  01a89	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01a91	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  01a94	b9 04 00 00 00	 mov	 ecx, 4
  01a99	f7 f1		 div	 ecx
  01a9b	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN32@EZASOKET:

; 819  :             while (i) {

  01a9f	83 7c 24 40 00	 cmp	 DWORD PTR i$[rsp], 0
  01aa4	74 3a		 je	 SHORT $LN33@EZASOKET

; 820  :                 i--;

  01aa6	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  01aaa	ff c8		 dec	 eax
  01aac	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 821  :                 ((u_int  *)t->buffer_out) [i] = htonl (((u_int  *)t->buffer_out) [i]);

  01ab0	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  01ab5	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01abd	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  01ac1	8b 0c 81	 mov	 ecx, DWORD PTR [rcx+rax*4]
  01ac4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  01aca	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01acf	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  01ad7	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  01adb	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 822  :             }

  01ade	eb bf		 jmp	 SHORT $LN32@EZASOKET
$LN33@EZASOKET:

; 823  : 
; 824  :             t->ret_cd = 0;

  01ae0	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01ae8	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 825  :             return;

  01aef	e9 c4 07 00 00	 jmp	 $LN1@EZASOKET
$LN130@EZASOKET:

; 826  : 
; 827  :         case 6:  /* Write Outputs */
; 828  : 
; 829  :             t->len_out = Cselect [m]->len;

  01af4	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01af9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01b00	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01b04	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01b0c	8b 00		 mov	 eax, DWORD PTR [rax]
  01b0e	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 830  :             t->buffer_out = (char *)malloc (t->len_out);

  01b11	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01b19	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  01b1c	8b c8		 mov	 ecx, eax
  01b1e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  01b24	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01b2c	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 831  :             t->buffer_out_slot = find_slot ((U_LONG_PTR)&(t->buffer_out [0]));

  01b30	b8 01 00 00 00	 mov	 eax, 1
  01b35	48 6b c0 00	 imul	 rax, rax, 0
  01b39	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01b41	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  01b45	48 8b c8	 mov	 rcx, rax
  01b48	e8 00 00 00 00	 call	 find_slot
  01b4d	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01b55	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 832  :             memset (t->buffer_out, 0, t->len_out);

  01b58	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01b60	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  01b63	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv1093[rsp], rax
  01b6b	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01b73	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  01b77	33 c0		 xor	 eax, eax
  01b79	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv1093[rsp]
  01b81	f3 aa		 rep stosb

; 833  : 
; 834  :             i = 0;

  01b83	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN34@EZASOKET:

; 835  :             while (i < aux2) {

  01b8b	8b 84 24 f0 21
	00 00		 mov	 eax, DWORD PTR aux2$[rsp]
  01b92	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  01b96	0f 8d 08 01 00
	00		 jge	 $LN35@EZASOKET

; 836  :                 if (Ccom_han [i] != -1)

  01b9c	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  01ba1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  01ba8	48 83 3c c1 ff	 cmp	 QWORD PTR [rcx+rax*8], -1
  01bad	0f 84 e2 00 00
	00		 je	 $LN131@EZASOKET

; 837  :                     if (FD_ISSET (Ccom_han [i], (fd_set *)(Cselect [m]->wo)))

  01bb3	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01bb8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01bbf	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01bc3	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01bc8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Ccom_han
  01bcf	48 89 94 24 40
	01 00 00	 mov	 QWORD PTR tv1448[rsp], rdx
  01bd7	48 8b 50 28	 mov	 rdx, QWORD PTR [rax+40]
  01bdb	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR tv1448[rsp]
  01be3	8b 0c c8	 mov	 ecx, DWORD PTR [rax+rcx*8]
  01be6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  01bec	85 c0		 test	 eax, eax
  01bee	0f 84 a1 00 00
	00		 je	 $LN132@EZASOKET

; 838  :                         hercFD_SET (i, (hercfd_set *)(t->buffer_out));

  01bf4	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01bfc	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01c00	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv1487[rsp], rax
  01c08	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01c0d	33 d2		 xor	 edx, edx
  01c0f	48 8b c1	 mov	 rax, rcx
  01c12	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01c17	48 f7 f1	 div	 rcx
  01c1a	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv1116[rsp], rax
  01c22	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01c27	33 d2		 xor	 edx, edx
  01c29	48 8b c1	 mov	 rax, rcx
  01c2c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01c31	48 f7 f1	 div	 rcx
  01c34	48 8b c2	 mov	 rax, rdx
  01c37	b9 01 00 00 00	 mov	 ecx, 1
  01c3c	89 8c 24 90 00
	00 00		 mov	 DWORD PTR tv2078[rsp], ecx
  01c43	0f b6 c8	 movzx	 ecx, al
  01c46	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv2078[rsp]
  01c4d	d3 e0		 shl	 eax, cl
  01c4f	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv1116[rsp]
  01c57	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR tv1487[rsp]
  01c5f	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  01c62	0b c8		 or	 ecx, eax
  01c64	8b c1		 mov	 eax, ecx
  01c66	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv1128[rsp], eax
  01c6d	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01c72	33 d2		 xor	 edx, edx
  01c74	48 8b c1	 mov	 rax, rcx
  01c77	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01c7c	48 f7 f1	 div	 rcx
  01c7f	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01c87	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  01c8b	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR tv1128[rsp]
  01c92	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN132@EZASOKET:
$LN131@EZASOKET:

; 839  :                 i++;

  01c95	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  01c99	ff c0		 inc	 eax
  01c9b	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 840  :             }

  01c9f	e9 e7 fe ff ff	 jmp	 $LN34@EZASOKET
$LN35@EZASOKET:

; 841  : 
; 842  :             /* Need to bswap every long in the outgoing array... */
; 843  :             i = t->len_out / 4;

  01ca4	33 d2		 xor	 edx, edx
  01ca6	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01cae	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  01cb1	b9 04 00 00 00	 mov	 ecx, 4
  01cb6	f7 f1		 div	 ecx
  01cb8	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN36@EZASOKET:

; 844  :             while (i) {

  01cbc	83 7c 24 40 00	 cmp	 DWORD PTR i$[rsp], 0
  01cc1	74 3a		 je	 SHORT $LN37@EZASOKET

; 845  :                 i--;

  01cc3	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  01cc7	ff c8		 dec	 eax
  01cc9	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 846  :                 ((u_int  *)t->buffer_out) [i] = htonl (((u_int  *)t->buffer_out) [i]);

  01ccd	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  01cd2	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01cda	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  01cde	8b 0c 81	 mov	 ecx, DWORD PTR [rcx+rax*4]
  01ce1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  01ce7	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01cec	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  01cf4	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  01cf8	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 847  :             }

  01cfb	eb bf		 jmp	 SHORT $LN36@EZASOKET
$LN37@EZASOKET:

; 848  : 
; 849  :             t->ret_cd = 0;

  01cfd	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01d05	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 850  :             return;

  01d0c	e9 a7 05 00 00	 jmp	 $LN1@EZASOKET
$LN133@EZASOKET:

; 851  : 
; 852  :         case 7:  /* Exception Outputs */
; 853  : 
; 854  :             t->len_out = Cselect [m]->len;

  01d11	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01d16	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01d1d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01d21	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01d29	8b 00		 mov	 eax, DWORD PTR [rax]
  01d2b	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 855  :             t->buffer_out = (char *)malloc (t->len_out);

  01d2e	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01d36	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  01d39	8b c8		 mov	 ecx, eax
  01d3b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  01d41	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01d49	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 856  :             t->buffer_out_slot = find_slot ((U_LONG_PTR)&(t->buffer_out [0]));

  01d4d	b8 01 00 00 00	 mov	 eax, 1
  01d52	48 6b c0 00	 imul	 rax, rax, 0
  01d56	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01d5e	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  01d62	48 8b c8	 mov	 rcx, rax
  01d65	e8 00 00 00 00	 call	 find_slot
  01d6a	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01d72	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 857  :             memset (t->buffer_out, 0, t->len_out);

  01d75	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01d7d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  01d80	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv1167[rsp], rax
  01d88	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01d90	48 8b 79 18	 mov	 rdi, QWORD PTR [rcx+24]
  01d94	33 c0		 xor	 eax, eax
  01d96	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv1167[rsp]
  01d9e	f3 aa		 rep stosb

; 858  : 
; 859  :             i = 0;

  01da0	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN38@EZASOKET:

; 860  :             while (i < aux2) {

  01da8	8b 84 24 f0 21
	00 00		 mov	 eax, DWORD PTR aux2$[rsp]
  01daf	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  01db3	0f 8d 08 01 00
	00		 jge	 $LN39@EZASOKET

; 861  :                 if (Ccom_han [i] != -1)

  01db9	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  01dbe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  01dc5	48 83 3c c1 ff	 cmp	 QWORD PTR [rcx+rax*8], -1
  01dca	0f 84 e2 00 00
	00		 je	 $LN134@EZASOKET

; 862  :                     if (FD_ISSET (Ccom_han [i], (fd_set *)(Cselect [m]->eo)))

  01dd0	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01dd5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01ddc	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01de0	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01de5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Ccom_han
  01dec	48 89 94 24 60
	01 00 00	 mov	 QWORD PTR tv1452[rsp], rdx
  01df4	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  01df8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR tv1452[rsp]
  01e00	8b 0c c8	 mov	 ecx, DWORD PTR [rax+rcx*8]
  01e03	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  01e09	85 c0		 test	 eax, eax
  01e0b	0f 84 a1 00 00
	00		 je	 $LN135@EZASOKET

; 863  :                         hercFD_SET (i, (hercfd_set *)(t->buffer_out));

  01e11	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01e19	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  01e1d	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv1480[rsp], rax
  01e25	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01e2a	33 d2		 xor	 edx, edx
  01e2c	48 8b c1	 mov	 rax, rcx
  01e2f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01e34	48 f7 f1	 div	 rcx
  01e37	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv1190[rsp], rax
  01e3f	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01e44	33 d2		 xor	 edx, edx
  01e46	48 8b c1	 mov	 rax, rcx
  01e49	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01e4e	48 f7 f1	 div	 rcx
  01e51	48 8b c2	 mov	 rax, rdx
  01e54	b9 01 00 00 00	 mov	 ecx, 1
  01e59	89 8c 24 98 00
	00 00		 mov	 DWORD PTR tv2112[rsp], ecx
  01e60	0f b6 c8	 movzx	 ecx, al
  01e63	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv2112[rsp]
  01e6a	d3 e0		 shl	 eax, cl
  01e6c	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv1190[rsp]
  01e74	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR tv1480[rsp]
  01e7c	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  01e7f	0b c8		 or	 ecx, eax
  01e81	8b c1		 mov	 eax, ecx
  01e83	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv1202[rsp], eax
  01e8a	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01e8f	33 d2		 xor	 edx, edx
  01e91	48 8b c1	 mov	 rax, rcx
  01e94	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01e99	48 f7 f1	 div	 rcx
  01e9c	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01ea4	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  01ea8	8b 94 24 9c 00
	00 00		 mov	 edx, DWORD PTR tv1202[rsp]
  01eaf	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN135@EZASOKET:
$LN134@EZASOKET:

; 864  :                 i++;

  01eb2	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  01eb6	ff c0		 inc	 eax
  01eb8	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 865  :             }

  01ebc	e9 e7 fe ff ff	 jmp	 $LN38@EZASOKET
$LN39@EZASOKET:

; 866  : 
; 867  :             /* Need to bswap every long in the outgoing array... */
; 868  :             i = t->len_out / 4;

  01ec1	33 d2		 xor	 edx, edx
  01ec3	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01ecb	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  01ece	b9 04 00 00 00	 mov	 ecx, 4
  01ed3	f7 f1		 div	 ecx
  01ed5	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN40@EZASOKET:

; 869  :             while (i) {

  01ed9	83 7c 24 40 00	 cmp	 DWORD PTR i$[rsp], 0
  01ede	74 3a		 je	 SHORT $LN41@EZASOKET

; 870  :                 i--;

  01ee0	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  01ee4	ff c8		 dec	 eax
  01ee6	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 871  :                 ((u_int  *)t->buffer_out) [i] = htonl (((u_int  *)t->buffer_out) [i]);

  01eea	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  01eef	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  01ef7	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  01efb	8b 0c 81	 mov	 ecx, DWORD PTR [rcx+rax*4]
  01efe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  01f04	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  01f09	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  01f11	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  01f15	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 872  :             }

  01f18	eb bf		 jmp	 SHORT $LN40@EZASOKET
$LN41@EZASOKET:

; 873  : 
; 874  :             t->ret_cd = 0;

  01f1a	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  01f22	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 875  :             return;

  01f29	e9 8a 03 00 00	 jmp	 $LN1@EZASOKET
$LN136@EZASOKET:

; 876  : 
; 877  :         case 8:  /* Finish */
; 878  : 
; 879  :             if (Cselect [m] != NULL) { /* Clean-up */

  01f2e	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01f33	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01f3a	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  01f3f	0f 84 c6 00 00
	00		 je	 $LN137@EZASOKET

; 880  : 
; 881  :                 free (Cselect [m]->ri);

  01f45	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01f4a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01f51	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01f55	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  01f59	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 882  :                 free (Cselect [m]->wi);

  01f5f	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01f64	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01f6b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01f6f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  01f73	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 883  :                 free (Cselect [m]->ei);

  01f79	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01f7e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01f85	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01f89	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  01f8d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 884  : 
; 885  :                 free (Cselect [m]->ro);

  01f93	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01f98	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01f9f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01fa3	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  01fa7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 886  :                 free (Cselect [m]->wo);

  01fad	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01fb2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01fb9	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01fbd	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  01fc1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 887  :                 free (Cselect [m]->eo);

  01fc7	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01fcc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01fd3	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01fd7	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  01fdb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 888  : 
; 889  :                 free (Cselect [m]);

  01fe1	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01fe6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  01fed	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  01ff1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 890  :                 Cselect [m] = NULL;

  01ff7	48 63 44 24 44	 movsxd	 rax, DWORD PTR m$[rsp]
  01ffc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  02003	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
$LN137@EZASOKET:

; 891  :             }
; 892  : 
; 893  :             t->ret_cd = 0;

  0200b	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  02013	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 894  :             return;

  0201a	e9 99 02 00 00	 jmp	 $LN1@EZASOKET
$LN16@EZASOKET:

; 895  :         }
; 896  : 
; 897  :         return;

  0201f	e9 94 02 00 00	 jmp	 $LN1@EZASOKET
$LN138@EZASOKET:

; 898  : 
; 899  :     case 18:  /* GETHOSTBYADDR */
; 900  : 
; 901  :         isock = sizeof (Slocal_adx);

  02024	c7 44 24 4c 10
	00 00 00	 mov	 DWORD PTR isock$[rsp], 16

; 902  :         i = htonl (aux1);

  0202c	8b 8c 24 e8 21
	00 00		 mov	 ecx, DWORD PTR aux1$[rsp]
  02033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  02039	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 903  : 
; 904  : #ifdef _MSVC_
; 905  :         if ((hp = gethostbyaddr ((const char *) &i, isock, AF_INET)) == NULL) {

  0203d	41 b8 02 00 00
	00		 mov	 r8d, 2
  02043	8b 54 24 4c	 mov	 edx, DWORD PTR isock$[rsp]
  02047	48 8d 4c 24 40	 lea	 rcx, QWORD PTR i$[rsp]
  0204c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gethostbyaddr
  02052	48 89 44 24 70	 mov	 QWORD PTR hp$[rsp], rax
  02057	48 83 7c 24 70
	00		 cmp	 QWORD PTR hp$[rsp], 0
  0205d	75 24		 jne	 SHORT $LN139@EZASOKET

; 906  : #else
; 907  :         if ((hp = gethostbyaddr (&i, isock, AF_INET)) == NULL) {
; 908  : #endif
; 909  : 
; 910  :             CerrGen = Get_errno ();

  0205f	e8 00 00 00 00	 call	 Get_errno
  02064	89 05 00 00 00
	00		 mov	 DWORD PTR CerrGen, eax

; 911  : 
; 912  :             t->ret_cd = 0;

  0206a	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  02072	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 913  :             return;

  02079	e9 3a 02 00 00	 jmp	 $LN1@EZASOKET

; 914  :         } else {

  0207e	e9 22 01 00 00	 jmp	 $LN140@EZASOKET
$LN139@EZASOKET:

; 915  :             if (!(t->ret_cd = strlen (hp->h_name) )) {

  02083	48 8b 44 24 70	 mov	 rax, QWORD PTR hp$[rsp]
  02088	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0208b	e8 00 00 00 00	 call	 strlen
  02090	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv1272[rsp], rax
  02098	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  020a0	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv1272[rsp]
  020a7	89 48 20	 mov	 DWORD PTR [rax+32], ecx
  020aa	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR tv1272[rsp], 0
  020b2	75 19		 jne	 SHORT $LN141@EZASOKET

; 916  :                 t->ret_cd = 0;

  020b4	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  020bc	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0

; 917  :                 return;

  020c3	e9 f0 01 00 00	 jmp	 $LN1@EZASOKET

; 918  :             } else {

  020c8	e9 d8 00 00 00	 jmp	 $LN142@EZASOKET
$LN141@EZASOKET:

; 919  : 
; 920  :                 t->len_out = t->ret_cd;

  020cd	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  020d5	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  020dd	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  020e0	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 921  :                 t->buffer_out = (char *) malloc (t->len_out);

  020e3	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  020eb	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  020ee	8b c8		 mov	 ecx, eax
  020f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  020f6	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  020fe	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 922  :                 t->buffer_out_slot = find_slot ((U_LONG_PTR)&(t->buffer_out [0]));

  02102	b8 01 00 00 00	 mov	 eax, 1
  02107	48 6b c0 00	 imul	 rax, rax, 0
  0210b	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  02113	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  02117	48 8b c8	 mov	 rcx, rax
  0211a	e8 00 00 00 00	 call	 find_slot
  0211f	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  02127	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 923  : 
; 924  :                 m = t->ret_cd;

  0212a	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  02132	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  02135	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 925  :                 i = 0;

  02139	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 926  :                 k = 0;

  02141	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
$LN42@EZASOKET:

; 927  :                 while (m) {

  02149	83 7c 24 44 00	 cmp	 DWORD PTR m$[rsp], 0
  0214e	74 50		 je	 SHORT $LN43@EZASOKET

; 928  :                     t->buffer_out [k++] = DCCascii_to_ebcdic [(unsigned char)(hp->h_name [i++])];

  02150	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  02155	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hp$[rsp]
  0215a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0215d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DCCascii_to_ebcdic
  02168	48 63 54 24 48	 movsxd	 rdx, DWORD PTR k$[rsp]
  0216d	48 8b bc 24 f8
	21 00 00	 mov	 rdi, QWORD PTR t$[rsp]
  02175	48 8b 7f 18	 mov	 rdi, QWORD PTR [rdi+24]
  02179	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0217d	88 04 17	 mov	 BYTE PTR [rdi+rdx], al
  02180	8b 44 24 48	 mov	 eax, DWORD PTR k$[rsp]
  02184	ff c0		 inc	 eax
  02186	89 44 24 48	 mov	 DWORD PTR k$[rsp], eax
  0218a	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0218e	ff c0		 inc	 eax
  02190	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 929  :                     m--;

  02194	8b 44 24 44	 mov	 eax, DWORD PTR m$[rsp]
  02198	ff c8		 dec	 eax
  0219a	89 44 24 44	 mov	 DWORD PTR m$[rsp], eax

; 930  :                 }

  0219e	eb a9		 jmp	 SHORT $LN42@EZASOKET
$LN43@EZASOKET:

; 931  :                 return;

  021a0	e9 13 01 00 00	 jmp	 $LN1@EZASOKET
$LN142@EZASOKET:
$LN140@EZASOKET:
$LN143@EZASOKET:

; 932  :             }
; 933  :         }
; 934  : 
; 935  :     case 19:  /* GETPEERNAME */
; 936  : 
; 937  :         if (check_not_sock (aux1, t)) return;

  021a5	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  021ad	8b 8c 24 e8 21
	00 00		 mov	 ecx, DWORD PTR aux1$[rsp]
  021b4	e8 00 00 00 00	 call	 check_not_sock
  021b9	85 c0		 test	 eax, eax
  021bb	74 05		 je	 SHORT $LN144@EZASOKET
  021bd	e9 f6 00 00 00	 jmp	 $LN1@EZASOKET
$LN144@EZASOKET:

; 938  : 
; 939  :         t->len_out = sizeof (Clocal_adx);

  021c2	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  021ca	c7 40 10 10 00
	00 00		 mov	 DWORD PTR [rax+16], 16

; 940  :         t->buffer_out = (char *) malloc (t->len_out);

  021d1	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  021d9	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  021dc	8b c8		 mov	 ecx, eax
  021de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  021e4	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  021ec	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 941  :         t->buffer_out_slot = find_slot ((U_LONG_PTR)&(t->buffer_out [0]));

  021f0	b8 01 00 00 00	 mov	 eax, 1
  021f5	48 6b c0 00	 imul	 rax, rax, 0
  021f9	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  02201	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  02205	48 8b c8	 mov	 rcx, rax
  02208	e8 00 00 00 00	 call	 find_slot
  0220d	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  02215	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 942  : 
; 943  :         isock = t->len_out;

  02218	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  02220	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  02223	89 44 24 4c	 mov	 DWORD PTR isock$[rsp], eax

; 944  :         t->ret_cd = getpeername (Ccom_han [aux1], (struct sockaddr *)(t->buffer_out), &isock);

  02227	48 63 84 24 e8
	21 00 00	 movsxd	 rax, DWORD PTR aux1$[rsp]
  0222f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  02236	4c 8d 44 24 4c	 lea	 r8, QWORD PTR isock$[rsp]
  0223b	48 8b 94 24 f8
	21 00 00	 mov	 rdx, QWORD PTR t$[rsp]
  02243	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  02247	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0224b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpeername
  02251	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  02259	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 945  : 
; 946  :         if (t->ret_cd == -1) {

  0225c	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  02264	83 78 20 ff	 cmp	 DWORD PTR [rax+32], -1
  02268	75 19		 jne	 SHORT $LN145@EZASOKET

; 947  :             Cerr [aux1] = Get_errno ();

  0226a	e8 00 00 00 00	 call	 Get_errno
  0226f	48 63 8c 24 e8
	21 00 00	 movsxd	 rcx, DWORD PTR aux1$[rsp]
  02277	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Cerr
  0227e	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 948  :         } else {

  02281	eb 24		 jmp	 SHORT $LN146@EZASOKET
$LN145@EZASOKET:

; 949  :             ((SOCKADDR_IN *)(t->buffer_out))->sin_family = htons (((SOCKADDR_IN *)(t->buffer_out))->sin_family);

  02283	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  0228b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0228f	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  02292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  02298	48 8b 8c 24 f8
	21 00 00	 mov	 rcx, QWORD PTR t$[rsp]
  022a0	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  022a4	66 89 01	 mov	 WORD PTR [rcx], ax
$LN146@EZASOKET:

; 950  :         }
; 951  : 
; 952  :         return;

  022a7	eb 0f		 jmp	 SHORT $LN1@EZASOKET
$LN2@EZASOKET:

; 953  : 
; 954  :     }
; 955  : 
; 956  :     t->ret_cd = 0;

  022a9	48 8b 84 24 f8
	21 00 00	 mov	 rax, QWORD PTR t$[rsp]
  022b1	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [rax+32], 0
$LN1@EZASOKET:
$LN147@EZASOKET:

; 957  :     return;
; 958  : }

  022b8	48 8b 8c 24 b0
	21 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  022c0	48 33 cc	 xor	 rcx, rsp
  022c3	e8 00 00 00 00	 call	 __security_check_cookie
  022c8	48 81 c4 c8 21
	00 00		 add	 rsp, 8648		; 000021c8H
  022cf	5f		 pop	 rdi
  022d0	5e		 pop	 rsi
  022d1	c3		 ret	 0
  022d2	66 90		 npad	 2
$LN153@EZASOKET:
  022d4	00 00 00 00	 DD	 $LN44@EZASOKET
  022d8	00 00 00 00	 DD	 $LN45@EZASOKET
  022dc	00 00 00 00	 DD	 $LN47@EZASOKET
  022e0	00 00 00 00	 DD	 $LN48@EZASOKET
  022e4	00 00 00 00	 DD	 $LN54@EZASOKET
  022e8	00 00 00 00	 DD	 $LN58@EZASOKET
  022ec	00 00 00 00	 DD	 $LN61@EZASOKET
  022f0	00 00 00 00	 DD	 $LN70@EZASOKET
  022f4	00 00 00 00	 DD	 $LN74@EZASOKET
  022f8	00 00 00 00	 DD	 $LN82@EZASOKET
  022fc	00 00 00 00	 DD	 $LN85@EZASOKET
  02300	00 00 00 00	 DD	 $LN91@EZASOKET
  02304	00 00 00 00	 DD	 $LN94@EZASOKET
  02308	00 00 00 00	 DD	 $LN95@EZASOKET
  0230c	00 00 00 00	 DD	 $LN96@EZASOKET
  02310	00 00 00 00	 DD	 $LN103@EZASOKET
  02314	00 00 00 00	 DD	 $LN107@EZASOKET
  02318	00 00 00 00	 DD	 $LN138@EZASOKET
  0231c	00 00 00 00	 DD	 $LN143@EZASOKET
$LN152@EZASOKET:
  02320	00 00 00 00	 DD	 $LN109@EZASOKET
  02324	00 00 00 00	 DD	 $LN111@EZASOKET
  02328	00 00 00 00	 DD	 $LN115@EZASOKET
  0232c	00 00 00 00	 DD	 $LN119@EZASOKET
  02330	00 00 00 00	 DD	 $LN123@EZASOKET
  02334	00 00 00 00	 DD	 $LN127@EZASOKET
  02338	00 00 00 00	 DD	 $LN130@EZASOKET
  0233c	00 00 00 00	 DD	 $LN133@EZASOKET
  02340	00 00 00 00	 DD	 $LN136@EZASOKET
EZASOKET ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tcpip.c
_TEXT	SEGMENT
s$ = 8
t$ = 16
check_not_sock PROC

; 228  : static u_int  check_not_sock (u_int  s, talk_ptr t) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 229  : 
; 230  :     if ((s < 1) || (s >= Ccom)) {

  00009	83 7c 24 08 01	 cmp	 DWORD PTR s$[rsp], 1
  0000e	72 0a		 jb	 SHORT $LN3@check_not_
  00010	81 7c 24 08 00
	04 00 00	 cmp	 DWORD PTR s$[rsp], 1024	; 00000400H
  00018	72 13		 jb	 SHORT $LN2@check_not_
$LN3@check_not_:

; 231  :         t->ret_cd = -1;

  0001a	48 8b 44 24 10	 mov	 rax, QWORD PTR t$[rsp]
  0001f	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 232  :         return (1);

  00026	b8 01 00 00 00	 mov	 eax, 1
  0002b	eb 27		 jmp	 SHORT $LN1@check_not_
$LN2@check_not_:

; 233  :     }
; 234  : 
; 235  :     if (Ccom_han [s] == -1) {

  0002d	8b 44 24 08	 mov	 eax, DWORD PTR s$[rsp]
  00031	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  00038	48 83 3c c1 ff	 cmp	 QWORD PTR [rcx+rax*8], -1
  0003d	75 13		 jne	 SHORT $LN4@check_not_

; 236  :         t->ret_cd = -1;

  0003f	48 8b 44 24 10	 mov	 rax, QWORD PTR t$[rsp]
  00044	c7 40 20 ff ff
	ff ff		 mov	 DWORD PTR [rax+32], -1

; 237  :         return (1);

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	eb 02		 jmp	 SHORT $LN1@check_not_
$LN4@check_not_:

; 238  :     }
; 239  : 
; 240  :     return (0);

  00052	33 c0		 xor	 eax, eax
$LN1@check_not_:

; 241  : }

  00054	c3		 ret	 0
check_not_sock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tcpip.c
_TEXT	SEGMENT
regs$ = 8
r$ = 16
get_reg	PROC

; 220  : static u_int  get_reg (u_int  * regs, u_int  r) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 221  :     return (regs [r * 2]);

  00009	8b 44 24 10	 mov	 eax, DWORD PTR r$[rsp]
  0000d	d1 e0		 shl	 eax, 1
  0000f	8b c0		 mov	 eax, eax
  00011	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00016	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]

; 222  : }

  00019	c3		 ret	 0
get_reg	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tcpip.c
_TEXT	SEGMENT
regs$ = 8
r$ = 16
v$ = 24
set_reg	PROC

; 216  : static void set_reg (u_int  * regs, u_int  r, u_int  v) {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 217  :     regs [r * 2] = v;

  0000e	8b 44 24 10	 mov	 eax, DWORD PTR r$[rsp]
  00012	d1 e0		 shl	 eax, 1
  00014	8b c0		 mov	 eax, eax
  00016	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	8b 54 24 18	 mov	 edx, DWORD PTR v$[rsp]
  0001f	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 218  : }

  00022	c3		 ret	 0
set_reg	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tcpip.c
_TEXT	SEGMENT
tv65 = 32
i$ = 36
Get_errno PROC

; 91   : static int Get_errno () {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 92   :     u_int  i;
; 93   : 
; 94   : #ifndef _MSVC_
; 95   :     i = errno;
; 96   : #else
; 97   :     i = WSAGetLastError ();

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0000a	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax

; 98   : #endif
; 99   : 
; 100  :     switch (i) {

  0000e	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00012	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00016	8b 44 24 20	 mov	 eax, DWORD PTR tv65[rsp]
  0001a	2d 26 27 00 00	 sub	 eax, 10022		; 00002726H
  0001f	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00023	83 7c 24 20 31	 cmp	 DWORD PTR tv65[rsp], 49	; 00000031H
  00028	0f 87 67 01 00
	00		 ja	 $LN2@Get_errno
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR tv65[rsp]
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00039	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN44@Get_errno[rcx+rax*4]
  00040	48 03 c1	 add	 rax, rcx
  00043	ff e0		 jmp	 rax
$LN4@Get_errno:

; 101  :     case fEMFILE:
; 102  :         return (hEMFILE);

  00045	b8 18 00 00 00	 mov	 eax, 24
  0004a	e9 4a 01 00 00	 jmp	 $LN1@Get_errno
$LN5@Get_errno:

; 103  : /*    case EAGAIN:
; 104  :         return (hEAGAIN);  SAME AS EWOULDBLOCK*/
; 105  :     case EWOULDBLOCK:
; 106  :         return (hEWOULDBLOCK);

  0004f	b8 23 00 00 00	 mov	 eax, 35			; 00000023H
  00054	e9 40 01 00 00	 jmp	 $LN1@Get_errno
$LN6@Get_errno:

; 107  :     case EINPROGRESS:
; 108  :         return (hEINPROGRESS);

  00059	b8 24 00 00 00	 mov	 eax, 36			; 00000024H
  0005e	e9 36 01 00 00	 jmp	 $LN1@Get_errno
$LN7@Get_errno:

; 109  :     case EALREADY:
; 110  :         return (hEALREADY);

  00063	b8 25 00 00 00	 mov	 eax, 37			; 00000025H
  00068	e9 2c 01 00 00	 jmp	 $LN1@Get_errno
$LN8@Get_errno:

; 111  :     case ENOTSOCK:
; 112  :         return (hENOTSOCK);

  0006d	b8 26 00 00 00	 mov	 eax, 38			; 00000026H
  00072	e9 22 01 00 00	 jmp	 $LN1@Get_errno
$LN9@Get_errno:

; 113  :     case EDESTADDRREQ:
; 114  :         return (hEDESTADDRREQ);

  00077	b8 27 00 00 00	 mov	 eax, 39			; 00000027H
  0007c	e9 18 01 00 00	 jmp	 $LN1@Get_errno
$LN10@Get_errno:

; 115  :     case EMSGSIZE:
; 116  :         return (hEMSGSIZE);

  00081	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  00086	e9 0e 01 00 00	 jmp	 $LN1@Get_errno
$LN11@Get_errno:

; 117  :     case EPROTOTYPE:
; 118  :         return (hEPROTOTYPE);

  0008b	b8 29 00 00 00	 mov	 eax, 41			; 00000029H
  00090	e9 04 01 00 00	 jmp	 $LN1@Get_errno
$LN12@Get_errno:

; 119  :     case ENOPROTOOPT:
; 120  :         return (hENOPROTOOPT);

  00095	b8 2a 00 00 00	 mov	 eax, 42			; 0000002aH
  0009a	e9 fa 00 00 00	 jmp	 $LN1@Get_errno
$LN13@Get_errno:

; 121  :     case EPROTONOSUPPORT:
; 122  :         return (hEPROTONOSUPPORT);

  0009f	b8 2b 00 00 00	 mov	 eax, 43			; 0000002bH
  000a4	e9 f0 00 00 00	 jmp	 $LN1@Get_errno
$LN14@Get_errno:

; 123  :     case ESOCKTNOSUPPORT:
; 124  :         return (hESOCKTNOSUPPORT);

  000a9	b8 2c 00 00 00	 mov	 eax, 44			; 0000002cH
  000ae	e9 e6 00 00 00	 jmp	 $LN1@Get_errno
$LN15@Get_errno:

; 125  :     case EOPNOTSUPP:
; 126  :         return (hEOPNOTSUPP);

  000b3	b8 2d 00 00 00	 mov	 eax, 45			; 0000002dH
  000b8	e9 dc 00 00 00	 jmp	 $LN1@Get_errno
$LN16@Get_errno:

; 127  :     case EPFNOSUPPORT:
; 128  :         return (hEPFNOSUPPORT);

  000bd	b8 2e 00 00 00	 mov	 eax, 46			; 0000002eH
  000c2	e9 d2 00 00 00	 jmp	 $LN1@Get_errno
$LN17@Get_errno:

; 129  :     case EAFNOSUPPORT:
; 130  :         return (hEAFNOSUPPORT);

  000c7	b8 2f 00 00 00	 mov	 eax, 47			; 0000002fH
  000cc	e9 c8 00 00 00	 jmp	 $LN1@Get_errno
$LN18@Get_errno:

; 131  :     case EADDRINUSE:
; 132  :         return (hEADDRINUSE);

  000d1	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  000d6	e9 be 00 00 00	 jmp	 $LN1@Get_errno
$LN19@Get_errno:

; 133  :     case EADDRNOTAVAIL:
; 134  :         return (hEADDRNOTAVAIL);

  000db	b8 31 00 00 00	 mov	 eax, 49			; 00000031H
  000e0	e9 b4 00 00 00	 jmp	 $LN1@Get_errno
$LN20@Get_errno:

; 135  :     case ENETDOWN:
; 136  :         return (hENETDOWN);

  000e5	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  000ea	e9 aa 00 00 00	 jmp	 $LN1@Get_errno
$LN21@Get_errno:

; 137  :     case ENETUNREACH:
; 138  :         return (hENETUNREACH);

  000ef	b8 33 00 00 00	 mov	 eax, 51			; 00000033H
  000f4	e9 a0 00 00 00	 jmp	 $LN1@Get_errno
$LN22@Get_errno:

; 139  :     case ENETRESET:
; 140  :         return (hENETRESET);

  000f9	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
  000fe	e9 96 00 00 00	 jmp	 $LN1@Get_errno
$LN23@Get_errno:

; 141  :     case ECONNABORTED:
; 142  :         return (hECONNABORTED);

  00103	b8 35 00 00 00	 mov	 eax, 53			; 00000035H
  00108	e9 8c 00 00 00	 jmp	 $LN1@Get_errno
$LN24@Get_errno:

; 143  :     case ECONNRESET:
; 144  :         return (hECONNRESET);

  0010d	b8 36 00 00 00	 mov	 eax, 54			; 00000036H
  00112	e9 82 00 00 00	 jmp	 $LN1@Get_errno
$LN25@Get_errno:

; 145  :     case ENOBUFS:
; 146  :         return (hENOBUFS);

  00117	b8 37 00 00 00	 mov	 eax, 55			; 00000037H
  0011c	eb 7b		 jmp	 SHORT $LN1@Get_errno
$LN26@Get_errno:

; 147  :     case EISCONN:
; 148  :         return (hEISCONN);

  0011e	b8 38 00 00 00	 mov	 eax, 56			; 00000038H
  00123	eb 74		 jmp	 SHORT $LN1@Get_errno
$LN27@Get_errno:

; 149  :     case ENOTCONN:
; 150  :         return (hENOTCONN);

  00125	b8 39 00 00 00	 mov	 eax, 57			; 00000039H
  0012a	eb 6d		 jmp	 SHORT $LN1@Get_errno
$LN28@Get_errno:

; 151  :     case ESHUTDOWN:
; 152  :         return (hESHUTDOWN);

  0012c	b8 3a 00 00 00	 mov	 eax, 58			; 0000003aH
  00131	eb 66		 jmp	 SHORT $LN1@Get_errno
$LN29@Get_errno:

; 153  :     case ETOOMANYREFS:
; 154  :         return (hETOOMANYREFS);

  00133	b8 3b 00 00 00	 mov	 eax, 59			; 0000003bH
  00138	eb 5f		 jmp	 SHORT $LN1@Get_errno
$LN30@Get_errno:

; 155  :     case ETIMEDOUT:
; 156  :         return (hETIMEDOUT);

  0013a	b8 3c 00 00 00	 mov	 eax, 60			; 0000003cH
  0013f	eb 58		 jmp	 SHORT $LN1@Get_errno
$LN31@Get_errno:

; 157  :     case ECONNREFUSED:
; 158  :         return (hECONNREFUSED);

  00141	b8 3d 00 00 00	 mov	 eax, 61			; 0000003dH
  00146	eb 51		 jmp	 SHORT $LN1@Get_errno
$LN32@Get_errno:

; 159  :     case fEINVAL :
; 160  :         return (hEINVAL);

  00148	b8 16 00 00 00	 mov	 eax, 22
  0014d	eb 4a		 jmp	 SHORT $LN1@Get_errno
$LN33@Get_errno:

; 161  :     case ELOOP :
; 162  :         return (hELOOP);

  0014f	b8 3e 00 00 00	 mov	 eax, 62			; 0000003eH
  00154	eb 43		 jmp	 SHORT $LN1@Get_errno
$LN34@Get_errno:

; 163  :     case fENAMETOOLONG :
; 164  :         return (hENAMETOOLONG);

  00156	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  0015b	eb 3c		 jmp	 SHORT $LN1@Get_errno
$LN35@Get_errno:

; 165  :     case EHOSTDOWN :
; 166  :         return (hEHOSTDOWN);

  0015d	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  00162	eb 35		 jmp	 SHORT $LN1@Get_errno
$LN36@Get_errno:

; 167  :     case EHOSTUNREACH :
; 168  :         return (hEHOSTUNREACH);

  00164	b8 41 00 00 00	 mov	 eax, 65			; 00000041H
  00169	eb 2e		 jmp	 SHORT $LN1@Get_errno
$LN37@Get_errno:

; 169  :     case fENOTEMPTY :
; 170  :         return (hENOTEMPTY);

  0016b	b8 42 00 00 00	 mov	 eax, 66			; 00000042H
  00170	eb 27		 jmp	 SHORT $LN1@Get_errno
$LN38@Get_errno:

; 171  : #ifdef EPROCLIM // Some *nixs don't have this error
; 172  :     case EPROCLIM :
; 173  :         return (hEPROCLIM);

  00172	b8 43 00 00 00	 mov	 eax, 67			; 00000043H
  00177	eb 20		 jmp	 SHORT $LN1@Get_errno
$LN39@Get_errno:

; 174  : #endif
; 175  :     case EUSERS :
; 176  :         return (hEUSERS);

  00179	b8 44 00 00 00	 mov	 eax, 68			; 00000044H
  0017e	eb 19		 jmp	 SHORT $LN1@Get_errno
$LN40@Get_errno:

; 177  :     case EDQUOT :
; 178  :         return (hEDQUOT);

  00180	b8 45 00 00 00	 mov	 eax, 69			; 00000045H
  00185	eb 12		 jmp	 SHORT $LN1@Get_errno
$LN41@Get_errno:

; 179  :     case ESTALE :
; 180  :         return (hESTALE);

  00187	b8 46 00 00 00	 mov	 eax, 70			; 00000046H
  0018c	eb 0b		 jmp	 SHORT $LN1@Get_errno
$LN42@Get_errno:

; 181  :     case EREMOTE :
; 182  :         return (hEREMOTE);

  0018e	b8 47 00 00 00	 mov	 eax, 71			; 00000047H
  00193	eb 04		 jmp	 SHORT $LN1@Get_errno
$LN2@Get_errno:

; 183  :     }
; 184  : 
; 185  :     return (i);

  00195	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
$LN1@Get_errno:

; 186  : }

  00199	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0019d	c3		 ret	 0
  0019e	66 90		 npad	 2
$LN44@Get_errno:
  001a0	00 00 00 00	 DD	 $LN32@Get_errno
  001a4	00 00 00 00	 DD	 $LN2@Get_errno
  001a8	00 00 00 00	 DD	 $LN4@Get_errno
  001ac	00 00 00 00	 DD	 $LN2@Get_errno
  001b0	00 00 00 00	 DD	 $LN2@Get_errno
  001b4	00 00 00 00	 DD	 $LN2@Get_errno
  001b8	00 00 00 00	 DD	 $LN2@Get_errno
  001bc	00 00 00 00	 DD	 $LN2@Get_errno
  001c0	00 00 00 00	 DD	 $LN2@Get_errno
  001c4	00 00 00 00	 DD	 $LN2@Get_errno
  001c8	00 00 00 00	 DD	 $LN2@Get_errno
  001cc	00 00 00 00	 DD	 $LN2@Get_errno
  001d0	00 00 00 00	 DD	 $LN2@Get_errno
  001d4	00 00 00 00	 DD	 $LN5@Get_errno
  001d8	00 00 00 00	 DD	 $LN6@Get_errno
  001dc	00 00 00 00	 DD	 $LN7@Get_errno
  001e0	00 00 00 00	 DD	 $LN8@Get_errno
  001e4	00 00 00 00	 DD	 $LN9@Get_errno
  001e8	00 00 00 00	 DD	 $LN10@Get_errno
  001ec	00 00 00 00	 DD	 $LN11@Get_errno
  001f0	00 00 00 00	 DD	 $LN12@Get_errno
  001f4	00 00 00 00	 DD	 $LN13@Get_errno
  001f8	00 00 00 00	 DD	 $LN14@Get_errno
  001fc	00 00 00 00	 DD	 $LN15@Get_errno
  00200	00 00 00 00	 DD	 $LN16@Get_errno
  00204	00 00 00 00	 DD	 $LN17@Get_errno
  00208	00 00 00 00	 DD	 $LN18@Get_errno
  0020c	00 00 00 00	 DD	 $LN19@Get_errno
  00210	00 00 00 00	 DD	 $LN20@Get_errno
  00214	00 00 00 00	 DD	 $LN21@Get_errno
  00218	00 00 00 00	 DD	 $LN22@Get_errno
  0021c	00 00 00 00	 DD	 $LN23@Get_errno
  00220	00 00 00 00	 DD	 $LN24@Get_errno
  00224	00 00 00 00	 DD	 $LN25@Get_errno
  00228	00 00 00 00	 DD	 $LN26@Get_errno
  0022c	00 00 00 00	 DD	 $LN27@Get_errno
  00230	00 00 00 00	 DD	 $LN28@Get_errno
  00234	00 00 00 00	 DD	 $LN29@Get_errno
  00238	00 00 00 00	 DD	 $LN30@Get_errno
  0023c	00 00 00 00	 DD	 $LN31@Get_errno
  00240	00 00 00 00	 DD	 $LN33@Get_errno
  00244	00 00 00 00	 DD	 $LN34@Get_errno
  00248	00 00 00 00	 DD	 $LN35@Get_errno
  0024c	00 00 00 00	 DD	 $LN36@Get_errno
  00250	00 00 00 00	 DD	 $LN37@Get_errno
  00254	00 00 00 00	 DD	 $LN38@Get_errno
  00258	00 00 00 00	 DD	 $LN39@Get_errno
  0025c	00 00 00 00	 DD	 $LN40@Get_errno
  00260	00 00 00 00	 DD	 $LN41@Get_errno
  00264	00 00 00 00	 DD	 $LN42@Get_errno
Get_errno ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tcpip.c
_TEXT	SEGMENT
i$ = 32
$T1 = 40
tcpip_init PROC

; 70   : static void tcpip_init () {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 71   :     u_int  i;
; 72   : 
; 73   :     initialize_lock(&tcpip_lock);

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tcpip_lock
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 74   : 
; 75   :     CerrGen = 0;

  00011	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR CerrGen, 0

; 76   : 
; 77   :     i = 0;

  0001b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN2@tcpip_init:

; 78   :     while (i < Ccom) {

  00023	81 7c 24 20 00
	04 00 00	 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  0002b	0f 83 94 00 00
	00		 jae	 $LN3@tcpip_init

; 79   :         map32[i] = -1;

  00031	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map32
  0003c	48 c7 04 c1 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax*8], -1

; 80   : 
; 81   :         Cselect [i] = NULL;

  00044	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cselect
  0004f	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 82   : 
; 83   :         Cerr [i] = 0;

  00057	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Cerr
  00062	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0

; 84   :         Ccom_blk [i] = 1;

  00069	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_blk
  00074	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 85   :         Ccom_han [i] = -1;

  00078	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:Ccom_han
  00083	48 c7 04 c1 ff
	ff ff ff	 mov	 QWORD PTR [rcx+rax*8], -1

; 86   :         Ccom_opn [i++] = 0;

  0008b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0008f	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00094	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00098	ff c0		 inc	 eax
  0009a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0009e	48 81 7c 24 28
	00 04 00 00	 cmp	 QWORD PTR $T1[rsp], 1024 ; 00000400H
  000a7	73 02		 jae	 SHORT $LN5@tcpip_init
  000a9	eb 05		 jmp	 SHORT $LN6@tcpip_init
$LN5@tcpip_init:
  000ab	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN6@tcpip_init:
  000b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:Ccom_opn
  000b7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  000bc	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 87   :     }

  000c0	e9 5e ff ff ff	 jmp	 $LN2@tcpip_init
$LN3@tcpip_init:
$LN4@tcpip_init:

; 88   : }

  000c5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c9	c3		 ret	 0
tcpip_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tcpip.c
_TEXT	SEGMENT
i$ = 32
address$ = 64
find_slot PROC

; 60   : static u_int find_slot ( U_LONG_PTR address ) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 61   :     u_int  i;
; 62   :     i = 0;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 63   :     obtain_lock (&tcpip_lock);

  00011	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tcpip_lock
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
$LN2@find_slot:

; 64   :     while ((((signed) map32[i]) != -1) && (i < Ccom-1)) i++;

  0001e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map32
  00029	83 3c c1 ff	 cmp	 DWORD PTR [rcx+rax*8], -1
  0002d	74 16		 je	 SHORT $LN3@find_slot
  0002f	81 7c 24 20 ff
	03 00 00	 cmp	 DWORD PTR i$[rsp], 1023	; 000003ffH
  00037	73 0c		 jae	 SHORT $LN3@find_slot
  00039	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0003d	ff c0		 inc	 eax
  0003f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00043	eb d9		 jmp	 SHORT $LN2@find_slot
$LN3@find_slot:

; 65   :     map32[i] = address;

  00045	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map32
  00050	48 8b 54 24 40	 mov	 rdx, QWORD PTR address$[rsp]
  00055	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 66   :     release_lock (&tcpip_lock);

  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tcpip_lock
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 67   :     return (i);

  00066	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]

; 68   : }

  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	c3		 ret	 0
find_slot ENDP
_TEXT	ENDS
END
