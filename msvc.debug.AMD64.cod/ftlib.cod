; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG159142 DB	'No error', 00H
	ORG $+7
$SG159143 DB	'File error', 00H
	ORG $+5
$SG159144 DB	'Tapemark read', 00H
	ORG $+2
$SG159145 DB	'Beginning of tape', 00H
	ORG $+6
$SG159146 DB	'End of tape', 00H
	ORG $+4
$SG159147 DB	'BOR not found', 00H
	ORG $+2
$SG159148 DB	'EOR not found', 00H
	ORG $+2
$SG159149 DB	'Unexpected tapemark', 00H
	ORG $+4
$SG159150 DB	'Buffer not big enough', 00H
	ORG $+2
$SG159151 DB	'Premature EOF', 00H
	ORG $+2
$SG159152 DB	'Decompression error', 00H
	ORG $+4
$SG159153 DB	'Unknown compression method', 00H
	ORG $+5
$SG159154 DB	'Compression error', 00H
	ORG $+6
$SG159155 DB	'Specified length to big', 00H
$SG159156 DB	'Write protected', 00H
$SG159157 DB	'Bad function code passed', 00H
	ORG $+7
$SG159158 DB	'Bad compression method', 00H
	ORG $+1
$SG159159 DB	'Bad compression level', 00H
	ORG $+2
$SG159160 DB	'Bad write chunk size', 00H
	ORG $+3
$SG159161 DB	'Invalid direction specified', 00H
	ORG $+4
$SG159162 DB	'Insufficient memory', 00H
	ORG $+4
$SG159163 DB	'Couldn''t read block header', 00H
	ORG $+5
$SG159164 DB	'Inconsistent compression flags', 00H
	ORG $+1
$SG159165 DB	'Block is short', 00H
	ORG $+1
$SG159166 DB	'Location error', 00H
	ORG $+1
$SG159167 DB	'Invalid error code', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	fet_open
PUBLIC	fet_close
PUBLIC	fet_read_header
PUBLIC	fet_read
PUBLIC	fet_write_header
PUBLIC	fet_write
PUBLIC	fet_tapemark
PUBLIC	fet_sync
PUBLIC	fet_bsb
PUBLIC	fet_fsb
PUBLIC	fet_bsf
PUBLIC	fet_fsf
PUBLIC	fet_rewind
PUBLIC	fet_passedeot
PUBLIC	fet_error
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp__chsize_s:PROC
EXTRN	__imp__commit:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp__fseeki64:PROC
EXTRN	__imp__ftelli64:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_fdopen:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fclose:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$fet_open DD imagerel $LN19
	DD	imagerel $LN19+742
	DD	imagerel $unwind$fet_open
$pdata$fet_close DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$fet_close
$pdata$fet_read_header DD imagerel $LN16
	DD	imagerel $LN16+524
	DD	imagerel $unwind$fet_read_header
$pdata$fet_read DD imagerel $LN9
	DD	imagerel $LN9+310
	DD	imagerel $unwind$fet_read
$pdata$fet_write_header DD imagerel $LN6
	DD	imagerel $LN6+294
	DD	imagerel $unwind$fet_write_header
$pdata$fet_write DD imagerel $LN16
	DD	imagerel $LN16+508
	DD	imagerel $unwind$fet_write
$pdata$fet_tapemark DD imagerel $LN14
	DD	imagerel $LN14+426
	DD	imagerel $unwind$fet_tapemark
$pdata$fet_sync DD imagerel $LN5
	DD	imagerel $LN5+66
	DD	imagerel $unwind$fet_sync
$pdata$fet_bsb DD imagerel $LN6
	DD	imagerel $LN6+209
	DD	imagerel $unwind$fet_bsb
$pdata$fet_fsb DD imagerel $LN5
	DD	imagerel $LN5+197
	DD	imagerel $unwind$fet_fsb
$pdata$fet_bsf DD imagerel $LN8
	DD	imagerel $LN8+83
	DD	imagerel $unwind$fet_bsf
$pdata$fet_fsf DD imagerel $LN7
	DD	imagerel $LN7+61
	DD	imagerel $unwind$fet_fsf
$pdata$fet_rewind DD imagerel $LN4
	DD	imagerel $LN4+117
	DD	imagerel $unwind$fet_rewind
pdata	ENDS
_DATA	SEGMENT
	ORG $+13
fet_errstr DQ	FLAT:$SG159142
	DQ	FLAT:$SG159143
	DQ	FLAT:$SG159144
	DQ	FLAT:$SG159145
	DQ	FLAT:$SG159146
	DQ	FLAT:$SG159147
	DQ	FLAT:$SG159148
	DQ	FLAT:$SG159149
	DQ	FLAT:$SG159150
	DQ	FLAT:$SG159151
	DQ	FLAT:$SG159152
	DQ	FLAT:$SG159153
	DQ	FLAT:$SG159154
	DQ	FLAT:$SG159155
	DQ	FLAT:$SG159156
	DQ	FLAT:$SG159157
	DQ	FLAT:$SG159158
	DQ	FLAT:$SG159159
	DQ	FLAT:$SG159160
	DQ	FLAT:$SG159161
	DQ	FLAT:$SG159162
	DQ	FLAT:$SG159163
	DQ	FLAT:$SG159164
	DQ	FLAT:$SG159165
	DQ	FLAT:$SG159166
	DQ	FLAT:$SG159167
$SG159190 DB	'r+b', 00H
$SG159195 DB	'rb', 00H
	ORG $+1
$SG159239 DB	'%x', 00H
	ORG $+1
$SG159240 DB	'%x', 00H
	ORG $+1
$SG159241 DB	'%x', 00H
	ORG $+1
$SG159279 DB	'%4.4X', 00H
	ORG $+2
$SG159280 DB	'%4.4X', 00H
	ORG $+2
$SG159281 DB	'%4.4X', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:fet_write_header
	DD	024H
	DD	0114H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:fet_read_header
	DD	022H
	DD	01faH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:fet_open
	DD	020H
	DD	02ceH
voltbl	ENDS
xdata	SEGMENT
$unwind$fet_open DD 022819H
	DD	02d0116H
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$fet_close DD 010901H
	DD	04209H
$unwind$fet_read_header DD 012719H
	DD	0e218H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$fet_read DD 010e01H
	DD	0620eH
$unwind$fet_write_header DD 012919H
	DD	0a21aH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$fet_write DD 011401H
	DD	08214H
$unwind$fet_tapemark DD 010901H
	DD	08209H
$unwind$fet_sync DD 010901H
	DD	04209H
$unwind$fet_bsb DD 010901H
	DD	08209H
$unwind$fet_fsb DD 010901H
	DD	06209H
$unwind$fet_bsf DD 010901H
	DD	06209H
$unwind$fet_fsf DD 010901H
	DD	06209H
$unwind$fet_rewind DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
rc$ = 8
fet_error PROC

; 776  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 777  :     // no error, return OK
; 778  :     if( rc > -1 )

  00004	83 7c 24 08 ff	 cmp	 DWORD PTR rc$[rsp], -1
  00009	7e 08		 jle	 SHORT $LN2@fet_error

; 779  :         rc = 0;

  0000b	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN2@fet_error:

; 780  : 
; 781  :     rc *= -1;       // make positive for indexing

  00013	6b 44 24 08 ff	 imul	 eax, DWORD PTR rc$[rsp], -1
  00018	89 44 24 08	 mov	 DWORD PTR rc$[rsp], eax

; 782  : 
; 783  :     if( rc >= (int)FET_ERRSTR_MAX )     // detect mismatch errors vs error strings

  0001c	83 7c 24 08 1a	 cmp	 DWORD PTR rc$[rsp], 26
  00021	7c 08		 jl	 SHORT $LN3@fet_error

; 784  :         rc = FET_ERRSTR_MAX - 1;

  00023	c7 44 24 08 19
	00 00 00	 mov	 DWORD PTR rc$[rsp], 25
$LN3@fet_error:

; 785  : 
; 786  :     return( fet_errstr[ rc ] );

  0002b	48 63 44 24 08	 movsxd	 rax, DWORD PTR rc$[rsp]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fet_errstr
  00037	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]

; 787  : }

  0003b	c3		 ret	 0
fet_error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
fetb$ = 8
fet_passedeot PROC

; 760  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 761  :     if(fetb->nxtblkpos==0)

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR fetb$[rsp]
  0000a	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  00012	75 1e		 jne	 SHORT $LN2@fet_passed

; 762  :         fetb->eotwarning = FALSE;

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR fetb$[rsp]
  00019	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  0001f	83 e0 f7	 and	 eax, -9			; fffffff7H
  00022	48 8b 4c 24 08	 mov	 rcx, QWORD PTR fetb$[rsp]
  00027	89 81 44 01 00
	00		 mov	 DWORD PTR [rcx+324], eax
  0002d	e9 84 00 00 00	 jmp	 $LN3@fet_passed
$LN2@fet_passed:

; 763  :     else
; 764  :         if(fetb->maxsize==0)

  00032	48 8b 44 24 08	 mov	 rax, QWORD PTR fetb$[rsp]
  00037	48 83 b8 28 01
	00 00 00	 cmp	 QWORD PTR [rax+296], 0
  0003f	75 1b		 jne	 SHORT $LN4@fet_passed

; 765  :             fetb->eotwarning = TRUE;

  00041	48 8b 44 24 08	 mov	 rax, QWORD PTR fetb$[rsp]
  00046	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  0004c	83 c8 08	 or	 eax, 8
  0004f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR fetb$[rsp]
  00054	89 81 44 01 00
	00		 mov	 DWORD PTR [rcx+324], eax
  0005a	eb 5a		 jmp	 SHORT $LN5@fet_passed
$LN4@fet_passed:

; 766  :     else
; 767  :         if(fetb->nxtblkpos+fetb->eotmargin > fetb->maxsize)

  0005c	48 8b 44 24 08	 mov	 rax, QWORD PTR fetb$[rsp]
  00061	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  00068	48 8b 4c 24 08	 mov	 rcx, QWORD PTR fetb$[rsp]
  0006d	48 03 81 20 01
	00 00		 add	 rax, QWORD PTR [rcx+288]
  00074	48 8b 4c 24 08	 mov	 rcx, QWORD PTR fetb$[rsp]
  00079	48 3b 81 28 01
	00 00		 cmp	 rax, QWORD PTR [rcx+296]
  00080	7e 1b		 jle	 SHORT $LN6@fet_passed

; 768  :             fetb->eotwarning = TRUE;

  00082	48 8b 44 24 08	 mov	 rax, QWORD PTR fetb$[rsp]
  00087	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  0008d	83 c8 08	 or	 eax, 8
  00090	48 8b 4c 24 08	 mov	 rcx, QWORD PTR fetb$[rsp]
  00095	89 81 44 01 00
	00		 mov	 DWORD PTR [rcx+324], eax
  0009b	eb 19		 jmp	 SHORT $LN7@fet_passed
$LN6@fet_passed:

; 769  :     else
; 770  :         fetb->eotwarning = FALSE;

  0009d	48 8b 44 24 08	 mov	 rax, QWORD PTR fetb$[rsp]
  000a2	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  000a8	83 e0 f7	 and	 eax, -9			; fffffff7H
  000ab	48 8b 4c 24 08	 mov	 rcx, QWORD PTR fetb$[rsp]
  000b0	89 81 44 01 00
	00		 mov	 DWORD PTR [rcx+324], eax
$LN7@fet_passed:
$LN5@fet_passed:
$LN3@fet_passed:

; 771  :     return fetb->eotwarning;

  000b6	48 8b 44 24 08	 mov	 rax, QWORD PTR fetb$[rsp]
  000bb	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  000c1	c1 e8 03	 shr	 eax, 3
  000c4	83 e0 01	 and	 eax, 1

; 772  : }

  000c7	c3		 ret	 0
fet_passedeot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
rc$ = 32
fetb$ = 64
fet_rewind PROC

; 739  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 740  : int         rc;
; 741  : 
; 742  :     rc = fseek( fetb->fh, 0L, SEEK_SET );

  00009	45 33 c0	 xor	 r8d, r8d
  0000c	33 d2		 xor	 edx, edx
  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  00013	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  0001c	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 743  :     if ( rc < 0 )

  00020	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00025	7d 07		 jge	 SHORT $LN2@fet_rewind

; 744  :     {
; 745  :         return FETE_ERROR;

  00027	b8 ff ff ff ff	 mov	 eax, -1
  0002c	eb 42		 jmp	 SHORT $LN1@fet_rewind
$LN2@fet_rewind:

; 746  :     }
; 747  : 
; 748  :     fetb->nxtblkpos=0;

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  00033	48 c7 80 10 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+272], 0

; 749  :     fetb->prvblkpos=-1;

  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  00043	48 c7 80 18 01
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+280], -1

; 750  :     fetb->curfilen=1;

  0004e	b8 01 00 00 00	 mov	 eax, 1
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fetb$[rsp]
  00058	66 89 81 30 01
	00 00		 mov	 WORD PTR [rcx+304], ax

; 751  :     fetb->blockid=0;

  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  00064	c7 80 34 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+308], 0

; 752  :     return 0;

  0006e	33 c0		 xor	 eax, eax
$LN1@fet_rewind:

; 753  : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
fet_rewind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
rc$ = 32
fetb$ = 64
fet_fsf	PROC

; 672  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN2@fet_fsf:

; 673  : int             rc;                     /* Return code               */
; 674  : 
; 675  :     while (1)

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	74 26		 je	 SHORT $LN3@fet_fsf

; 676  :     {
; 677  :         /* Forward space over next block */
; 678  :         rc = fet_fsb( fetb );

  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fetb$[rsp]
  00015	e8 00 00 00 00	 call	 fet_fsb
  0001a	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 679  :         if (rc < 0)

  0001e	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00023	7d 06		 jge	 SHORT $LN4@fet_fsf

; 680  :             return rc; /* (error message already issued) */

  00025	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00029	eb 0d		 jmp	 SHORT $LN1@fet_fsf
$LN4@fet_fsf:

; 681  : 
; 682  :         /* Exit loop if spaced over a tapemark */
; 683  :         if (rc == 0)

  0002b	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00030	75 02		 jne	 SHORT $LN5@fet_fsf

; 684  :             break;

  00032	eb 02		 jmp	 SHORT $LN3@fet_fsf
$LN5@fet_fsf:

; 685  : 
; 686  :     } /* end while */

  00034	eb d3		 jmp	 SHORT $LN2@fet_fsf
$LN3@fet_fsf:

; 687  : 
; 688  :     /* Return normal status */
; 689  :     return 0;

  00036	33 c0		 xor	 eax, eax
$LN1@fet_fsf:

; 690  : 
; 691  : } /* end function fet_fsf */

  00038	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003c	c3		 ret	 0
fet_fsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
rc$ = 32
fetb$ = 64
fet_bsf	PROC

; 706  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN2@fet_bsf:

; 707  : int             rc;                     /* Return code               */
; 708  : 
; 709  :     while (1)

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	74 3c		 je	 SHORT $LN3@fet_bsf

; 710  :     {
; 711  :         /* Exit if now at start of tape */
; 712  :         if (fetb->nxtblkpos == 0)

  00010	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  00015	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  0001d	75 07		 jne	 SHORT $LN4@fet_bsf

; 713  :         {
; 714  :             return FETE_BOT;

  0001f	b8 fd ff ff ff	 mov	 eax, -3
  00024	eb 28		 jmp	 SHORT $LN1@fet_bsf
$LN4@fet_bsf:

; 715  :         }
; 716  : 
; 717  :         /* Backspace to previous block position */
; 718  :         rc = fet_bsb( fetb );

  00026	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fetb$[rsp]
  0002b	e8 00 00 00 00	 call	 fet_bsb
  00030	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 719  :         if (rc < 0)

  00034	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00039	7d 06		 jge	 SHORT $LN5@fet_bsf

; 720  :             return rc; /* (error message already issued) */

  0003b	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  0003f	eb 0d		 jmp	 SHORT $LN1@fet_bsf
$LN5@fet_bsf:

; 721  : 
; 722  :         /* Exit loop if backspaced over a tapemark */
; 723  :         if (rc == 0)

  00041	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00046	75 02		 jne	 SHORT $LN6@fet_bsf

; 724  :             break;

  00048	eb 02		 jmp	 SHORT $LN3@fet_bsf
$LN6@fet_bsf:

; 725  : 
; 726  :     } /* end while */

  0004a	eb bd		 jmp	 SHORT $LN2@fet_bsf
$LN3@fet_bsf:

; 727  : 
; 728  :     /* Return normal status */
; 729  :     return 0;

  0004c	33 c0		 xor	 eax, eax
$LN1@fet_bsf:

; 730  : 
; 731  : } /* end function fet_bsf */

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
fet_bsf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
blklen$ = 32
rc$ = 36
blkpos$ = 40
fetb$ = 64
fet_fsb	PROC

; 582  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 583  : int             rc;                     /* Return code               */
; 584  : off_t           blkpos;                 /* Offset of block header    */
; 585  : U16             blklen;                 /* Block length              */
; 586  : 
; 587  :     /* Initialize current block position */
; 588  :     blkpos = fetb->nxtblkpos;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  0000e	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  00015	48 89 44 24 28	 mov	 QWORD PTR blkpos$[rsp], rax

; 589  : 
; 590  :     /* Read the block header to obtain the current block length */
; 591  :     rc = fet_read_header( fetb, blkpos, NULL, &blklen );

  0001a	4c 8d 4c 24 20	 lea	 r9, QWORD PTR blklen$[rsp]
  0001f	45 33 c0	 xor	 r8d, r8d
  00022	48 8b 54 24 28	 mov	 rdx, QWORD PTR blkpos$[rsp]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fetb$[rsp]
  0002c	e8 00 00 00 00	 call	 fet_read_header
  00031	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 592  :     if (rc < 0)

  00035	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  0003a	7d 06		 jge	 SHORT $LN2@fet_fsb

; 593  :         return rc; /* (error message already issued) */

  0003c	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00040	eb 7e		 jmp	 SHORT $LN1@fet_fsb
$LN2@fet_fsb:

; 594  : 
; 595  :     /* Calculate the offset of the next block */
; 596  :     blkpos += sizeof(FAKETAPE_BLKHDR) + blklen;

  00042	0f b7 44 24 20	 movzx	 eax, WORD PTR blklen$[rsp]
  00047	48 8b 4c 24 28	 mov	 rcx, QWORD PTR blkpos$[rsp]
  0004c	48 8d 44 01 0c	 lea	 rax, QWORD PTR [rcx+rax+12]
  00051	48 89 44 24 28	 mov	 QWORD PTR blkpos$[rsp], rax

; 597  : 
; 598  :     /* Calculate the offsets of the next and previous blocks */
; 599  :     fetb->prvblkpos = fetb->nxtblkpos;

  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fetb$[rsp]
  00060	48 8b 89 10 01
	00 00		 mov	 rcx, QWORD PTR [rcx+272]
  00067	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 600  :     fetb->nxtblkpos = blkpos;

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  00073	48 8b 4c 24 28	 mov	 rcx, QWORD PTR blkpos$[rsp]
  00078	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 601  : 
; 602  :     /* Increment current file number if tapemark was skipped */
; 603  :     if (blklen == 0)

  0007f	0f b7 44 24 20	 movzx	 eax, WORD PTR blklen$[rsp]
  00084	85 c0		 test	 eax, eax
  00086	75 1b		 jne	 SHORT $LN3@fet_fsb

; 604  :         fetb->curfilen++;

  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  0008d	0f b7 80 30 01
	00 00		 movzx	 eax, WORD PTR [rax+304]
  00094	66 ff c0	 inc	 ax
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fetb$[rsp]
  0009c	66 89 81 30 01
	00 00		 mov	 WORD PTR [rcx+304], ax
$LN3@fet_fsb:

; 605  : 
; 606  :     /* Increment the block number */
; 607  :     fetb->blockid++;

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  000a8	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  000ae	ff c0		 inc	 eax
  000b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fetb$[rsp]
  000b5	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 608  : 
; 609  :     /* Return block length or zero if tapemark */
; 610  :     return blklen;

  000bb	0f b7 44 24 20	 movzx	 eax, WORD PTR blklen$[rsp]
$LN1@fet_fsb:

; 611  : 
; 612  : } /* end function fet_fsb */

  000c0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c4	c3		 ret	 0
fet_fsb	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
curblkl$ = 32
prvblkl$ = 36
rc$ = 40
blkpos$ = 48
fetb$ = 80
fet_bsb	PROC

; 624  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 625  : int             rc;                     /* Return code               */
; 626  : U16             curblkl;                /* Length of current block   */
; 627  : U16             prvblkl;                /* Length of previous block  */
; 628  : off_t           blkpos;                 /* Offset of block header    */
; 629  : 
; 630  :     /* Unit check if already at start of tape */
; 631  :     if (fetb->nxtblkpos == 0)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  0000e	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  00016	75 0a		 jne	 SHORT $LN2@fet_bsb

; 632  :     {
; 633  :         return FETE_BOT;

  00018	b8 fd ff ff ff	 mov	 eax, -3
  0001d	e9 aa 00 00 00	 jmp	 $LN1@fet_bsb
$LN2@fet_bsb:

; 634  :     }
; 635  : 
; 636  :     /* Backspace to previous block position */
; 637  :     blkpos = fetb->prvblkpos;

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00027	48 8b 80 18 01
	00 00		 mov	 rax, QWORD PTR [rax+280]
  0002e	48 89 44 24 30	 mov	 QWORD PTR blkpos$[rsp], rax

; 638  : 
; 639  :     /* Read the block header to obtain the block lengths */
; 640  :     rc = fet_read_header( fetb, blkpos, &prvblkl, &curblkl );

  00033	4c 8d 4c 24 20	 lea	 r9, QWORD PTR curblkl$[rsp]
  00038	4c 8d 44 24 24	 lea	 r8, QWORD PTR prvblkl$[rsp]
  0003d	48 8b 54 24 30	 mov	 rdx, QWORD PTR blkpos$[rsp]
  00042	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  00047	e8 00 00 00 00	 call	 fet_read_header
  0004c	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 641  :     if (rc < 0)

  00050	83 7c 24 28 00	 cmp	 DWORD PTR rc$[rsp], 0
  00055	7d 06		 jge	 SHORT $LN3@fet_bsb

; 642  :         return rc; /* (error message already issued) */

  00057	8b 44 24 28	 mov	 eax, DWORD PTR rc$[rsp]
  0005b	eb 6f		 jmp	 SHORT $LN1@fet_bsb
$LN3@fet_bsb:

; 643  : 
; 644  :     /* Calculate the offset of the previous block */
; 645  :     fetb->prvblkpos = blkpos - sizeof(FAKETAPE_BLKHDR) - prvblkl;

  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR blkpos$[rsp]
  00062	48 83 e8 0c	 sub	 rax, 12
  00066	0f b7 4c 24 24	 movzx	 ecx, WORD PTR prvblkl$[rsp]
  0006b	48 2b c1	 sub	 rax, rcx
  0006e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  00073	48 89 81 18 01
	00 00		 mov	 QWORD PTR [rcx+280], rax

; 646  :     fetb->nxtblkpos = blkpos;

  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  0007f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR blkpos$[rsp]
  00084	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 647  : 
; 648  :     /* Decrement current file number if backspaced over tapemark */
; 649  :     if (curblkl == 0)

  0008b	0f b7 44 24 20	 movzx	 eax, WORD PTR curblkl$[rsp]
  00090	85 c0		 test	 eax, eax
  00092	75 1b		 jne	 SHORT $LN4@fet_bsb

; 650  :         fetb->curfilen--;

  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00099	0f b7 80 30 01
	00 00		 movzx	 eax, WORD PTR [rax+304]
  000a0	66 ff c8	 dec	 ax
  000a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  000a8	66 89 81 30 01
	00 00		 mov	 WORD PTR [rcx+304], ax
$LN4@fet_bsb:

; 651  : 
; 652  :     /* Decrement the block number */
; 653  :     fetb->blockid--;

  000af	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  000b4	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  000ba	ff c8		 dec	 eax
  000bc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  000c1	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 654  : 
; 655  :     /* Return block length or zero if tapemark */
; 656  :     return curblkl;

  000c7	0f b7 44 24 20	 movzx	 eax, WORD PTR curblkl$[rsp]
$LN1@fet_bsb:

; 657  : 
; 658  : } /* end function fet_bsb */

  000cc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d0	c3		 ret	 0
fet_bsb	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
fetb$ = 48
fet_sync PROC

; 554  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 555  :     /* Unit check if tape is write-protected */
; 556  :     if (fetb->writeprotect)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR fetb$[rsp]
  0000e	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	74 07		 je	 SHORT $LN2@fet_sync

; 557  :     {
; 558  :         return FETE_PROTECTED;

  0001b	b8 f2 ff ff ff	 mov	 eax, -14
  00020	eb 1b		 jmp	 SHORT $LN1@fet_sync
$LN2@fet_sync:

; 559  :     }
; 560  : 
; 561  :     /* Perform sync. Return error on failure. */
; 562  :     if (fdatasync( fetb->fd ) < 0)

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR fetb$[rsp]
  00027	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__commit
  00030	85 c0		 test	 eax, eax
  00032	7d 07		 jge	 SHORT $LN3@fet_sync

; 563  :     {
; 564  :         return FETE_ERROR;

  00034	b8 ff ff ff ff	 mov	 eax, -1
  00039	eb 02		 jmp	 SHORT $LN1@fet_sync
$LN3@fet_sync:

; 565  :     }
; 566  : 
; 567  :     /* Return normal status */
; 568  :     return 0;

  0003b	33 c0		 xor	 eax, eax
$LN1@fet_sync:

; 569  : 
; 570  : } /* end function fet_sync */

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
fet_sync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
prvblkl$ = 32
rc$ = 36
blkpos$ = 40
rcoff$ = 48
fetb$ = 80
fet_tapemark PROC

; 479  : {

$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 480  : int             rc;                     /* Return code               */
; 481  : off_t           rcoff;                  /* Return code from lseek()  */
; 482  : off_t           blkpos;                 /* Offset of block header    */
; 483  : U16             prvblkl;                /* Length of previous block  */
; 484  : 
; 485  :     /* Initialize current block position and previous block length */
; 486  :     blkpos = fetb->nxtblkpos;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  0000e	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  00015	48 89 44 24 28	 mov	 QWORD PTR blkpos$[rsp], rax

; 487  :     prvblkl = 0;

  0001a	33 c0		 xor	 eax, eax
  0001c	66 89 44 24 20	 mov	 WORD PTR prvblkl$[rsp], ax

; 488  : 
; 489  :     /* Determine previous block length if not at start of tape */
; 490  :     if (fetb->nxtblkpos > 0)

  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00026	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  0002e	7e 4d		 jle	 SHORT $LN5@fet_tapema

; 491  :     {
; 492  :         /* Retrieve the previous block length */
; 493  :         rc = fet_read_header( fetb, fetb->prvblkpos, NULL, &prvblkl );

  00030	4c 8d 4c 24 20	 lea	 r9, QWORD PTR prvblkl$[rsp]
  00035	45 33 c0	 xor	 r8d, r8d
  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  0003d	48 8b 90 18 01
	00 00		 mov	 rdx, QWORD PTR [rax+280]
  00044	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  00049	e8 00 00 00 00	 call	 fet_read_header
  0004e	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 494  :         if (rc < 0)

  00052	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  00057	7d 09		 jge	 SHORT $LN6@fet_tapema

; 495  :             return rc;

  00059	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  0005d	e9 43 01 00 00	 jmp	 $LN1@fet_tapema
$LN6@fet_tapema:

; 496  : 
; 497  :         /* Recalculate the offset of the next block */
; 498  :         blkpos = fetb->prvblkpos + sizeof(FAKETAPE_BLKHDR) + prvblkl;

  00062	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00067	48 8b 80 18 01
	00 00		 mov	 rax, QWORD PTR [rax+280]
  0006e	0f b7 4c 24 20	 movzx	 ecx, WORD PTR prvblkl$[rsp]
  00073	48 8d 44 08 0c	 lea	 rax, QWORD PTR [rax+rcx+12]
  00078	48 89 44 24 28	 mov	 QWORD PTR blkpos$[rsp], rax
$LN5@fet_tapema:

; 499  :     }
; 500  : 
; 501  :     /* Reposition file to the new block header */
; 502  :     rc = fseek( fetb->fh, blkpos, SEEK_SET );

  0007d	45 33 c0	 xor	 r8d, r8d
  00080	48 8b 54 24 28	 mov	 rdx, QWORD PTR blkpos$[rsp]
  00085	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  0008a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  00093	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 503  :     if (rc < 0)

  00097	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  0009c	7d 0c		 jge	 SHORT $LN7@fet_tapema

; 504  :     {
; 505  :         return FETE_BADLOC;

  0009e	b8 e8 ff ff ff	 mov	 eax, -24
  000a3	e9 fd 00 00 00	 jmp	 $LN1@fet_tapema

; 506  :     }

  000a8	eb 13		 jmp	 SHORT $LN8@fet_tapema
$LN7@fet_tapema:

; 507  :     else
; 508  :         rcoff = ftell( fetb->fh );

  000aa	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  000af	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ftelli64
  000b8	48 89 44 24 30	 mov	 QWORD PTR rcoff$[rsp], rax
$LN8@fet_tapema:

; 509  : 
; 510  :     if(fetb->maxsize>0)

  000bd	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  000c2	48 83 b8 28 01
	00 00 00	 cmp	 QWORD PTR [rax+296], 0
  000ca	7e 28		 jle	 SHORT $LN9@fet_tapema

; 511  :     {
; 512  :         if((off_t)(fetb->nxtblkpos+sizeof(FAKETAPE_BLKHDR)) > fetb->maxsize)

  000cc	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  000d1	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  000d8	48 83 c0 0c	 add	 rax, 12
  000dc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  000e1	48 3b 81 28 01
	00 00		 cmp	 rax, QWORD PTR [rcx+296]
  000e8	7e 0a		 jle	 SHORT $LN10@fet_tapema

; 513  :         {
; 514  :             return FETE_EOT;

  000ea	b8 fc ff ff ff	 mov	 eax, -4
  000ef	e9 b1 00 00 00	 jmp	 $LN1@fet_tapema
$LN10@fet_tapema:
$LN9@fet_tapema:

; 515  :         }
; 516  :     }
; 517  : 
; 518  :     /* Write the block header */
; 519  :     rc = fet_write_header( fetb, rcoff, prvblkl, 0 );

  000f4	45 33 c9	 xor	 r9d, r9d
  000f7	44 0f b7 44 24
	20		 movzx	 r8d, WORD PTR prvblkl$[rsp]
  000fd	48 8b 54 24 30	 mov	 rdx, QWORD PTR rcoff$[rsp]
  00102	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  00107	e8 00 00 00 00	 call	 fet_write_header
  0010c	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 520  :     if (rc < 0)

  00110	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  00115	7d 09		 jge	 SHORT $LN11@fet_tapema

; 521  :         return rc; /* (error message already issued) */

  00117	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  0011b	e9 85 00 00 00	 jmp	 $LN1@fet_tapema
$LN11@fet_tapema:

; 522  : 
; 523  :     /* Increment the block number */
; 524  :     fetb->blockid++;

  00120	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00125	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  0012b	ff c0		 inc	 eax
  0012d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  00132	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 525  : 
; 526  :     /* Calculate the offsets of the next and previous blocks */
; 527  :     fetb->nxtblkpos = blkpos + sizeof(FAKETAPE_BLKHDR);

  00138	48 8b 44 24 28	 mov	 rax, QWORD PTR blkpos$[rsp]
  0013d	48 83 c0 0c	 add	 rax, 12
  00141	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  00146	48 89 81 10 01
	00 00		 mov	 QWORD PTR [rcx+272], rax

; 528  :     fetb->prvblkpos = blkpos;

  0014d	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00152	48 8b 4c 24 28	 mov	 rcx, QWORD PTR blkpos$[rsp]
  00157	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 529  : 
; 530  :     /* Set new physical EOF */
; 531  :     rc = ftell( fetb->fh );

  0015e	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00163	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ftelli64
  0016c	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax
$LN4@fet_tapema:

; 532  : 
; 533  :     do rc = ftruncate( fetb->fd, fetb->nxtblkpos );

  00170	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00175	48 8b 90 10 01
	00 00		 mov	 rdx, QWORD PTR [rax+272]
  0017c	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00181	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__chsize_s
  0018a	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 534  :     while (EINTR == rc);

  0018e	83 7c 24 24 04	 cmp	 DWORD PTR rc$[rsp], 4
  00193	74 db		 je	 SHORT $LN4@fet_tapema

; 535  : 
; 536  :     if (rc != 0)

  00195	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  0019a	74 07		 je	 SHORT $LN12@fet_tapema

; 537  :     {
; 538  :         return FETE_PROTECTED;

  0019c	b8 f2 ff ff ff	 mov	 eax, -14
  001a1	eb 02		 jmp	 SHORT $LN1@fet_tapema
$LN12@fet_tapema:

; 539  :     }
; 540  : 
; 541  :     /* Return normal status */
; 542  :     return 0;

  001a3	33 c0		 xor	 eax, eax
$LN1@fet_tapema:

; 543  : 
; 544  : } /* end function fet_tapemark */

  001a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a9	c3		 ret	 0
fet_tapemark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
prvblkl$ = 32
rc$ = 36
blkpos$ = 40
rcoff$ = 48
fetb$ = 80
buf$ = 88
blklen$ = 96
fet_write PROC

; 392  : {

$LN16:
  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 393  : int             rc;                     /* Return code               */
; 394  : off_t           rcoff;                  /* Return code from lseek()  */
; 395  : off_t           blkpos;                 /* Offset of block header    */
; 396  : U16             prvblkl;                /* Length of previous block  */
; 397  : 
; 398  :     /* Initialize current block position and previous block length */
; 399  :     blkpos = fetb->nxtblkpos;

  00014	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00019	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  00020	48 89 44 24 28	 mov	 QWORD PTR blkpos$[rsp], rax

; 400  :     prvblkl = 0;

  00025	33 c0		 xor	 eax, eax
  00027	66 89 44 24 20	 mov	 WORD PTR prvblkl$[rsp], ax

; 401  : 
; 402  :     /* Determine previous block length if not at start of tape */
; 403  :     if (fetb->nxtblkpos > 0)

  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00031	48 83 b8 10 01
	00 00 00	 cmp	 QWORD PTR [rax+272], 0
  00039	7e 4e		 jle	 SHORT $LN5@fet_write

; 404  :     {
; 405  :         /* Retrieve the previous block length */
; 406  :         rc = fet_read_header( fetb, fetb->prvblkpos, NULL, &prvblkl );

  0003b	4c 8d 4c 24 20	 lea	 r9, QWORD PTR prvblkl$[rsp]
  00040	45 33 c0	 xor	 r8d, r8d
  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00048	48 8b 90 18 01
	00 00		 mov	 rdx, QWORD PTR [rax+280]
  0004f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  00054	e8 00 00 00 00	 call	 fet_read_header
  00059	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 407  :         if (rc < 0) return FETE_ERROR;

  0005d	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN6@fet_write
  00064	b8 ff ff ff ff	 mov	 eax, -1
  00069	e9 89 01 00 00	 jmp	 $LN1@fet_write
$LN6@fet_write:

; 408  : 
; 409  :         /* Recalculate the offset of the next block */
; 410  :         blkpos = fetb->prvblkpos + sizeof(FAKETAPE_BLKHDR) + prvblkl;

  0006e	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00073	48 8b 80 18 01
	00 00		 mov	 rax, QWORD PTR [rax+280]
  0007a	0f b7 4c 24 20	 movzx	 ecx, WORD PTR prvblkl$[rsp]
  0007f	48 8d 44 08 0c	 lea	 rax, QWORD PTR [rax+rcx+12]
  00084	48 89 44 24 28	 mov	 QWORD PTR blkpos$[rsp], rax
$LN5@fet_write:

; 411  :     }
; 412  : 
; 413  :     /* Reposition file to the new block header */
; 414  :     rc = fseek( fetb->fh, blkpos, SEEK_SET );

  00089	45 33 c0	 xor	 r8d, r8d
  0008c	48 8b 54 24 28	 mov	 rdx, QWORD PTR blkpos$[rsp]
  00091	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00096	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  0009f	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 415  :     if (rc < 0)

  000a3	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  000a8	7d 0c		 jge	 SHORT $LN7@fet_write

; 416  :     {
; 417  :         return FETE_BADLOC;

  000aa	b8 e8 ff ff ff	 mov	 eax, -24
  000af	e9 43 01 00 00	 jmp	 $LN1@fet_write

; 418  :     }

  000b4	eb 13		 jmp	 SHORT $LN8@fet_write
$LN7@fet_write:

; 419  :     else
; 420  :         rcoff = ftell( fetb->fh );

  000b6	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  000bb	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ftelli64
  000c4	48 89 44 24 30	 mov	 QWORD PTR rcoff$[rsp], rax
$LN8@fet_write:

; 421  : 
; 422  :     if(fetb->maxsize>0)

  000c9	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  000ce	48 83 b8 28 01
	00 00 00	 cmp	 QWORD PTR [rax+296], 0
  000d6	7e 2e		 jle	 SHORT $LN9@fet_write

; 423  :     {
; 424  :         if((off_t)(fetb->nxtblkpos+blklen+sizeof(FAKETAPE_BLKHDR)) > fetb->maxsize )

  000d8	0f b7 44 24 60	 movzx	 eax, WORD PTR blklen$[rsp]
  000dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  000e2	48 8b 89 10 01
	00 00		 mov	 rcx, QWORD PTR [rcx+272]
  000e9	48 8d 44 01 0c	 lea	 rax, QWORD PTR [rcx+rax+12]
  000ee	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  000f3	48 3b 81 28 01
	00 00		 cmp	 rax, QWORD PTR [rcx+296]
  000fa	7e 0a		 jle	 SHORT $LN10@fet_write

; 425  :         {
; 426  :             return FETE_EOT;

  000fc	b8 fc ff ff ff	 mov	 eax, -4
  00101	e9 f1 00 00 00	 jmp	 $LN1@fet_write
$LN10@fet_write:
$LN9@fet_write:

; 427  :         }
; 428  :     }
; 429  : 
; 430  :     /* Write the block header */
; 431  :     rc = fet_write_header( fetb, rcoff, prvblkl, blklen );

  00106	44 0f b7 4c 24
	60		 movzx	 r9d, WORD PTR blklen$[rsp]
  0010c	44 0f b7 44 24
	20		 movzx	 r8d, WORD PTR prvblkl$[rsp]
  00112	48 8b 54 24 30	 mov	 rdx, QWORD PTR rcoff$[rsp]
  00117	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  0011c	e8 00 00 00 00	 call	 fet_write_header
  00121	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 432  :     if (rc < 0)

  00125	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  0012a	7d 0a		 jge	 SHORT $LN11@fet_write

; 433  :         return FETE_EOT; /* (error message already issued) */

  0012c	b8 fc ff ff ff	 mov	 eax, -4
  00131	e9 c1 00 00 00	 jmp	 $LN1@fet_write
$LN11@fet_write:

; 434  : 
; 435  :     /* Calculate the offsets of the next and previous blocks */
; 436  :     fetb->nxtblkpos = blkpos + sizeof(FAKETAPE_BLKHDR) + blklen;

  00136	0f b7 44 24 60	 movzx	 eax, WORD PTR blklen$[rsp]
  0013b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR blkpos$[rsp]
  00140	48 8d 44 01 0c	 lea	 rax, QWORD PTR [rcx+rax+12]
  00145	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  0014a	48 89 81 10 01
	00 00		 mov	 QWORD PTR [rcx+272], rax

; 437  :     fetb->prvblkpos = blkpos;

  00151	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  00156	48 8b 4c 24 28	 mov	 rcx, QWORD PTR blkpos$[rsp]
  0015b	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 438  : 
; 439  :     /* Write the data block */
; 440  :     rc = (int)fwrite( buf, 1, blklen, fetb->fh);

  00162	0f b7 44 24 60	 movzx	 eax, WORD PTR blklen$[rsp]
  00167	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  0016c	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  0016f	44 8b c0	 mov	 r8d, eax
  00172	ba 01 00 00 00	 mov	 edx, 1
  00177	48 8b 4c 24 58	 mov	 rcx, QWORD PTR buf$[rsp]
  0017c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  00182	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 441  :     if (rc < blklen)

  00186	0f b7 44 24 60	 movzx	 eax, WORD PTR blklen$[rsp]
  0018b	39 44 24 24	 cmp	 DWORD PTR rc$[rsp], eax
  0018f	7d 19		 jge	 SHORT $LN12@fet_write

; 442  :     {
; 443  :         if(errno==ENOSPC)

  00191	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00197	83 38 1c	 cmp	 DWORD PTR [rax], 28
  0019a	75 07		 jne	 SHORT $LN13@fet_write

; 444  :         {
; 445  :             /* Disk FULL */
; 446  :             return FETE_ERROR;

  0019c	b8 ff ff ff ff	 mov	 eax, -1
  001a1	eb 54		 jmp	 SHORT $LN1@fet_write
$LN13@fet_write:

; 447  :         }
; 448  : 
; 449  :         return FETE_EOT;

  001a3	b8 fc ff ff ff	 mov	 eax, -4
  001a8	eb 4d		 jmp	 SHORT $LN1@fet_write
$LN12@fet_write:

; 450  :     }
; 451  : 
; 452  :     /* Increment the block number */
; 453  :     fetb->blockid++;

  001aa	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  001af	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  001b5	ff c0		 inc	 eax
  001b7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fetb$[rsp]
  001bc	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax
$LN4@fet_write:

; 454  : 
; 455  :     /* Set new physical EOF */
; 456  : 
; 457  : 
; 458  :     do rc = ftruncate( fetb->fd, fetb->nxtblkpos );

  001c2	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  001c7	48 8b 90 10 01
	00 00		 mov	 rdx, QWORD PTR [rax+272]
  001ce	48 8b 44 24 50	 mov	 rax, QWORD PTR fetb$[rsp]
  001d3	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__chsize_s
  001dc	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 459  :     while (EINTR == rc);

  001e0	83 7c 24 24 04	 cmp	 DWORD PTR rc$[rsp], 4
  001e5	74 db		 je	 SHORT $LN4@fet_write

; 460  : 
; 461  :     if (rc != 0)

  001e7	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  001ec	74 07		 je	 SHORT $LN14@fet_write

; 462  :     {
; 463  :         return FETE_EOT;

  001ee	b8 fc ff ff ff	 mov	 eax, -4
  001f3	eb 02		 jmp	 SHORT $LN1@fet_write
$LN14@fet_write:

; 464  :     }
; 465  : 
; 466  :     /* Return normal status */
; 467  :     return 0;

  001f5	33 c0		 xor	 eax, eax
$LN1@fet_write:

; 468  : 
; 469  : } /* end function fet_write */

  001f7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001fb	c3		 ret	 0
fet_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
rc$ = 32
fakehdr$ = 40
temp$ = 56
__$ArrayPad$ = 64
fetb$ = 96
blkpos$ = 104
prvblkl$ = 112
curblkl$ = 120
fet_write_header PROC

; 347  : {

$LN6:
  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 348  : int             rc;                     /* Return code               */
; 349  : FAKETAPE_BLKHDR fakehdr;                /* FAKETAPE block header     */
; 350  : char    temp[5];
; 351  : 
; 352  :     /* Position file to where block header is to go */
; 353  :     rc = fseek( fetb->fh, blkpos, SEEK_SET );

  00029	45 33 c0	 xor	 r8d, r8d
  0002c	48 8b 54 24 68	 mov	 rdx, QWORD PTR blkpos$[rsp]
  00031	48 8b 44 24 60	 mov	 rax, QWORD PTR fetb$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  0003f	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 354  :     if (rc < 0)

  00043	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00048	7d 0a		 jge	 SHORT $LN2@fet_write_

; 355  :     {
; 356  :         return FETE_BADLOC;

  0004a	b8 e8 ff ff ff	 mov	 eax, -24
  0004f	e9 c0 00 00 00	 jmp	 $LN1@fet_write_
$LN2@fet_write_:

; 357  :     }
; 358  : 
; 359  :     /* Build the 12-ASCII-hex-character block header */
; 360  :     MSGBUF( temp, "%4.4X", prvblkl );

  00054	0f b7 44 24 70	 movzx	 eax, WORD PTR prvblkl$[rsp]
  00059	44 8b c8	 mov	 r9d, eax
  0005c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159279
  00063	ba 05 00 00 00	 mov	 edx, 5
  00068	48 8d 4c 24 38	 lea	 rcx, QWORD PTR temp$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 361  :     memcpy( fakehdr.sprvblkl, temp, sizeof(fakehdr.sprvblkl));

  00073	8b 44 24 38	 mov	 eax, DWORD PTR temp$[rsp]
  00077	89 44 24 28	 mov	 DWORD PTR fakehdr$[rsp], eax

; 362  :     MSGBUF( temp, "%4.4X", curblkl );

  0007b	0f b7 44 24 78	 movzx	 eax, WORD PTR curblkl$[rsp]
  00080	44 8b c8	 mov	 r9d, eax
  00083	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159280
  0008a	ba 05 00 00 00	 mov	 edx, 5
  0008f	48 8d 4c 24 38	 lea	 rcx, QWORD PTR temp$[rsp]
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 363  :     memcpy( fakehdr.scurblkl, temp, sizeof(fakehdr.scurblkl));

  0009a	8b 44 24 38	 mov	 eax, DWORD PTR temp$[rsp]
  0009e	89 44 24 2c	 mov	 DWORD PTR fakehdr$[rsp+4], eax

; 364  :     MSGBUF( temp, "%4.4X", prvblkl ^ curblkl );

  000a2	0f b7 44 24 70	 movzx	 eax, WORD PTR prvblkl$[rsp]
  000a7	0f b7 4c 24 78	 movzx	 ecx, WORD PTR curblkl$[rsp]
  000ac	33 c1		 xor	 eax, ecx
  000ae	44 8b c8	 mov	 r9d, eax
  000b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159281
  000b8	ba 05 00 00 00	 mov	 edx, 5
  000bd	48 8d 4c 24 38	 lea	 rcx, QWORD PTR temp$[rsp]
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 365  :     memcpy( fakehdr.sxorblkl, temp, sizeof(fakehdr.sxorblkl));

  000c8	8b 44 24 38	 mov	 eax, DWORD PTR temp$[rsp]
  000cc	89 44 24 30	 mov	 DWORD PTR fakehdr$[rsp+8], eax

; 366  : 
; 367  :     /* Write the block header */
; 368  :     rc = (int)fwrite( &fakehdr, 1, sizeof(FAKETAPE_BLKHDR), fetb->fh );

  000d0	48 8b 44 24 60	 mov	 rax, QWORD PTR fetb$[rsp]
  000d5	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  000d8	41 b8 0c 00 00
	00		 mov	 r8d, 12
  000de	ba 01 00 00 00	 mov	 edx, 1
  000e3	48 8d 4c 24 28	 lea	 rcx, QWORD PTR fakehdr$[rsp]
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  000ee	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 369  :     if (rc < (int)sizeof(FAKETAPE_BLKHDR))

  000f2	83 7c 24 20 0c	 cmp	 DWORD PTR rc$[rsp], 12
  000f7	7d 19		 jge	 SHORT $LN3@fet_write_

; 370  :     {
; 371  :         if(errno==ENOSPC)

  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ff	83 38 1c	 cmp	 DWORD PTR [rax], 28
  00102	75 07		 jne	 SHORT $LN4@fet_write_

; 372  :         {
; 373  :             /* Disk FULL */
; 374  :             return FETE_EOT;

  00104	b8 fc ff ff ff	 mov	 eax, -4
  00109	eb 09		 jmp	 SHORT $LN1@fet_write_
$LN4@fet_write_:

; 375  :         }
; 376  : 
; 377  :         return FETE_ERROR;

  0010b	b8 ff ff ff ff	 mov	 eax, -1
  00110	eb 02		 jmp	 SHORT $LN1@fet_write_
$LN3@fet_write_:

; 378  :     }
; 379  : 
; 380  :     return 0;

  00112	33 c0		 xor	 eax, eax
$LN1@fet_write_:

; 381  : 
; 382  : } /* end function fet_write_header */

  00114	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00119	48 33 cc	 xor	 rcx, rsp
  0011c	e8 00 00 00 00	 call	 __security_check_cookie
  00121	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00125	c3		 ret	 0
fet_write_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
curblkl$ = 32
rc$ = 36
blkpos$ = 40
fetb$ = 64
buf$ = 72
fet_read PROC

; 283  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 284  : int             rc;                     /* Return code               */
; 285  : off_t           blkpos;                 /* Offset of block header    */
; 286  : U16             curblkl;                /* Current block length      */
; 287  : 
; 288  :     /* Initialize current block position */
; 289  :     blkpos = fetb->nxtblkpos;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  00013	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  0001a	48 89 44 24 28	 mov	 QWORD PTR blkpos$[rsp], rax

; 290  : 
; 291  :     /* Read the block header to obtain the current block length */
; 292  :     rc = fet_read_header( fetb, blkpos, NULL, &curblkl );

  0001f	4c 8d 4c 24 20	 lea	 r9, QWORD PTR curblkl$[rsp]
  00024	45 33 c0	 xor	 r8d, r8d
  00027	48 8b 54 24 28	 mov	 rdx, QWORD PTR blkpos$[rsp]
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fetb$[rsp]
  00031	e8 00 00 00 00	 call	 fet_read_header
  00036	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 293  :     if ( rc == FETE_EOT ) return FETE_EOT;

  0003a	83 7c 24 24 fc	 cmp	 DWORD PTR rc$[rsp], -4
  0003f	75 0a		 jne	 SHORT $LN2@fet_read
  00041	b8 fc ff ff ff	 mov	 eax, -4
  00046	e9 e6 00 00 00	 jmp	 $LN1@fet_read
$LN2@fet_read:

; 294  :     if (rc < 0)

  0004b	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  00050	7d 0a		 jge	 SHORT $LN3@fet_read

; 295  :         return FETE_BADHDR; /* (error message already issued) */

  00052	b8 eb ff ff ff	 mov	 eax, -21
  00057	e9 d5 00 00 00	 jmp	 $LN1@fet_read
$LN3@fet_read:

; 296  : 
; 297  :     /* Calculate the offset of the next block header */
; 298  :     blkpos += sizeof(FAKETAPE_BLKHDR) + curblkl;

  0005c	0f b7 44 24 20	 movzx	 eax, WORD PTR curblkl$[rsp]
  00061	48 8b 4c 24 28	 mov	 rcx, QWORD PTR blkpos$[rsp]
  00066	48 8d 44 01 0c	 lea	 rax, QWORD PTR [rcx+rax+12]
  0006b	48 89 44 24 28	 mov	 QWORD PTR blkpos$[rsp], rax

; 299  : 
; 300  :     /* If not a tapemark, read the data block */
; 301  :     if (curblkl > 0)

  00070	0f b7 44 24 20	 movzx	 eax, WORD PTR curblkl$[rsp]
  00075	85 c0		 test	 eax, eax
  00077	7e 47		 jle	 SHORT $LN4@fet_read

; 302  :     {
; 303  :         rc = (int)fread( buf, 1, curblkl, fetb->fh );

  00079	0f b7 44 24 20	 movzx	 eax, WORD PTR curblkl$[rsp]
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fetb$[rsp]
  00083	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00086	44 8b c0	 mov	 r8d, eax
  00089	ba 01 00 00 00	 mov	 edx, 1
  0008e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  00099	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 304  : 
; 305  :         /* Handle read error condition */
; 306  :         if (rc < 0)

  0009d	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  000a2	7d 0a		 jge	 SHORT $LN5@fet_read

; 307  :         {
; 308  :             return FETE_ERROR;

  000a4	b8 ff ff ff ff	 mov	 eax, -1
  000a9	e9 83 00 00 00	 jmp	 $LN1@fet_read
$LN5@fet_read:

; 309  :         }
; 310  : 
; 311  :         /* Handle end of file within data block */
; 312  :         if (rc < curblkl)

  000ae	0f b7 44 24 20	 movzx	 eax, WORD PTR curblkl$[rsp]
  000b3	39 44 24 24	 cmp	 DWORD PTR rc$[rsp], eax
  000b7	7d 07		 jge	 SHORT $LN6@fet_read

; 313  :         {
; 314  :             return FETE_BADBLOCK;

  000b9	b8 e9 ff ff ff	 mov	 eax, -23
  000be	eb 71		 jmp	 SHORT $LN1@fet_read
$LN6@fet_read:
$LN4@fet_read:

; 315  :         }
; 316  :     }
; 317  : 
; 318  :     /* Calculate the offsets of the next and previous blocks */
; 319  :     fetb->prvblkpos = fetb->nxtblkpos;

  000c0	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fetb$[rsp]
  000ca	48 8b 89 10 01
	00 00		 mov	 rcx, QWORD PTR [rcx+272]
  000d1	48 89 88 18 01
	00 00		 mov	 QWORD PTR [rax+280], rcx

; 320  :     fetb->nxtblkpos = blkpos;

  000d8	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  000dd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR blkpos$[rsp]
  000e2	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 321  : 
; 322  :     /* Increment the block number */
; 323  :     fetb->blockid++;

  000e9	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  000ee	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  000f4	ff c0		 inc	 eax
  000f6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fetb$[rsp]
  000fb	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 324  : 
; 325  :     /* Increment file number and return zero if tapemark was read */
; 326  :     if (curblkl == 0)

  00101	0f b7 44 24 20	 movzx	 eax, WORD PTR curblkl$[rsp]
  00106	85 c0		 test	 eax, eax
  00108	75 22		 jne	 SHORT $LN7@fet_read

; 327  :     {
; 328  :         fetb->curfilen++;

  0010a	48 8b 44 24 40	 mov	 rax, QWORD PTR fetb$[rsp]
  0010f	0f b7 80 30 01
	00 00		 movzx	 eax, WORD PTR [rax+304]
  00116	66 ff c0	 inc	 ax
  00119	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fetb$[rsp]
  0011e	66 89 81 30 01
	00 00		 mov	 WORD PTR [rcx+304], ax

; 329  :         return FETE_TAPEMARK; /* UX will be set by caller */

  00125	b8 fe ff ff ff	 mov	 eax, -2
  0012a	eb 05		 jmp	 SHORT $LN1@fet_read
$LN7@fet_read:

; 330  :     }
; 331  : 
; 332  :     /* Return block length */
; 333  :     return curblkl;

  0012c	0f b7 44 24 20	 movzx	 eax, WORD PTR curblkl$[rsp]
$LN1@fet_read:

; 334  : 
; 335  : } /* end function fet_read */

  00131	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00135	c3		 ret	 0
fet_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
rc$ = 32
prvblkl$ = 36
curblkl$ = 40
xorblkl$ = 44
$T1 = 48
$T2 = 56
$T3 = 64
fakehdr$ = 72
sblklen$ = 88
__$ArrayPad$ = 96
fetb$ = 128
blkpos$ = 136
pprvblkl$ = 144
pcurblkl$ = 152
fet_read_header PROC

; 217  : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 218  : int             rc;                     /* Return code               */
; 219  : FAKETAPE_BLKHDR fakehdr;                /* FakeTape block header     */
; 220  : char            sblklen[5];             /* work for converting hdr   */
; 221  : int             prvblkl;                /* Previous block length     */
; 222  : int             curblkl;                /* Current block length      */
; 223  : int             xorblkl;                /* XOR check of block lens   */
; 224  : 
; 225  :     /* Reposition file to the requested block header */
; 226  :     rc = fseek( fetb->fh, blkpos, SEEK_SET );

  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR blkpos$[rsp]
  00032	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR fetb$[rsp]
  0003a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  00043	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 227  :     if (rc < 0)

  00047	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004c	7d 0a		 jge	 SHORT $LN2@fet_read_h

; 228  :     {
; 229  :         return FETE_ERROR;

  0004e	b8 ff ff ff ff	 mov	 eax, -1
  00053	e9 a2 01 00 00	 jmp	 $LN1@fet_read_h
$LN2@fet_read_h:

; 230  :     }
; 231  : 
; 232  :     /* Read the 12-ASCII-hex-character block header */
; 233  :     rc = (int)fread( &fakehdr, 1, sizeof(FAKETAPE_BLKHDR), fetb->fh );

  00058	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR fetb$[rsp]
  00060	4c 8b 08	 mov	 r9, QWORD PTR [rax]
  00063	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00069	ba 01 00 00 00	 mov	 edx, 1
  0006e	48 8d 4c 24 48	 lea	 rcx, QWORD PTR fakehdr$[rsp]
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  00079	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 234  : 
; 235  :     /* Handle read error condition */
; 236  :     if (rc < 0)

  0007d	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00082	7d 0a		 jge	 SHORT $LN3@fet_read_h

; 237  :     {
; 238  :         return FETE_ERROR;

  00084	b8 ff ff ff ff	 mov	 eax, -1
  00089	e9 6c 01 00 00	 jmp	 $LN1@fet_read_h
$LN3@fet_read_h:

; 239  :     }
; 240  : 
; 241  :     /* Handle end of file (uninitialized tape) condition */
; 242  :     if (rc == 0)

  0008e	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00093	75 0a		 jne	 SHORT $LN4@fet_read_h

; 243  :     {
; 244  :         return FETE_EOT;

  00095	b8 fc ff ff ff	 mov	 eax, -4
  0009a	e9 5b 01 00 00	 jmp	 $LN1@fet_read_h
$LN4@fet_read_h:

; 245  :     }
; 246  : 
; 247  :     /* Handle end of file within block header */
; 248  :     if (rc < (int)sizeof(FAKETAPE_BLKHDR))

  0009f	83 7c 24 20 0c	 cmp	 DWORD PTR rc$[rsp], 12
  000a4	7d 0a		 jge	 SHORT $LN5@fet_read_h

; 249  :     {
; 250  :         return FETE_BADHDR;

  000a6	b8 eb ff ff ff	 mov	 eax, -21
  000ab	e9 4a 01 00 00	 jmp	 $LN1@fet_read_h
$LN5@fet_read_h:

; 251  :     }
; 252  : 
; 253  :     /* Convert the ASCII-hex-character block lengths to binary */
; 254  :     strncpy( sblklen, fakehdr.sprvblkl, 4 ); sblklen[4] = 0; sscanf( sblklen, "%x", &prvblkl );

  000b0	41 b8 04 00 00
	00		 mov	 r8d, 4
  000b6	48 8d 54 24 48	 lea	 rdx, QWORD PTR fakehdr$[rsp]
  000bb	48 8d 4c 24 58	 lea	 rcx, QWORD PTR sblklen$[rsp]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  000c6	b8 01 00 00 00	 mov	 eax, 1
  000cb	48 6b c0 04	 imul	 rax, rax, 4
  000cf	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  000d4	48 83 7c 24 30
	05		 cmp	 QWORD PTR $T1[rsp], 5
  000da	73 02		 jae	 SHORT $LN10@fet_read_h
  000dc	eb 05		 jmp	 SHORT $LN11@fet_read_h
$LN10@fet_read_h:
  000de	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN11@fet_read_h:
  000e3	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  000e8	c6 44 04 58 00	 mov	 BYTE PTR sblklen$[rsp+rax], 0
  000ed	4c 8d 44 24 24	 lea	 r8, QWORD PTR prvblkl$[rsp]
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159239
  000f9	48 8d 4c 24 58	 lea	 rcx, QWORD PTR sblklen$[rsp]
  000fe	e8 00 00 00 00	 call	 sscanf

; 255  :     strncpy( sblklen, fakehdr.scurblkl, 4 ); sblklen[4] = 0; sscanf( sblklen, "%x", &curblkl );

  00103	41 b8 04 00 00
	00		 mov	 r8d, 4
  00109	48 8d 54 24 4c	 lea	 rdx, QWORD PTR fakehdr$[rsp+4]
  0010e	48 8d 4c 24 58	 lea	 rcx, QWORD PTR sblklen$[rsp]
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  00119	b8 01 00 00 00	 mov	 eax, 1
  0011e	48 6b c0 04	 imul	 rax, rax, 4
  00122	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp], rax
  00127	48 83 7c 24 38
	05		 cmp	 QWORD PTR $T2[rsp], 5
  0012d	73 02		 jae	 SHORT $LN12@fet_read_h
  0012f	eb 05		 jmp	 SHORT $LN13@fet_read_h
$LN12@fet_read_h:
  00131	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN13@fet_read_h:
  00136	48 8b 44 24 38	 mov	 rax, QWORD PTR $T2[rsp]
  0013b	c6 44 04 58 00	 mov	 BYTE PTR sblklen$[rsp+rax], 0
  00140	4c 8d 44 24 28	 lea	 r8, QWORD PTR curblkl$[rsp]
  00145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159240
  0014c	48 8d 4c 24 58	 lea	 rcx, QWORD PTR sblklen$[rsp]
  00151	e8 00 00 00 00	 call	 sscanf

; 256  :     strncpy( sblklen, fakehdr.sxorblkl, 4 ); sblklen[4] = 0; sscanf( sblklen, "%x", &xorblkl );

  00156	41 b8 04 00 00
	00		 mov	 r8d, 4
  0015c	48 8d 54 24 50	 lea	 rdx, QWORD PTR fakehdr$[rsp+8]
  00161	48 8d 4c 24 58	 lea	 rcx, QWORD PTR sblklen$[rsp]
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy
  0016c	b8 01 00 00 00	 mov	 eax, 1
  00171	48 6b c0 04	 imul	 rax, rax, 4
  00175	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
  0017a	48 83 7c 24 40
	05		 cmp	 QWORD PTR $T3[rsp], 5
  00180	73 02		 jae	 SHORT $LN14@fet_read_h
  00182	eb 05		 jmp	 SHORT $LN15@fet_read_h
$LN14@fet_read_h:
  00184	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN15@fet_read_h:
  00189	48 8b 44 24 40	 mov	 rax, QWORD PTR $T3[rsp]
  0018e	c6 44 04 58 00	 mov	 BYTE PTR sblklen$[rsp+rax], 0
  00193	4c 8d 44 24 2c	 lea	 r8, QWORD PTR xorblkl$[rsp]
  00198	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159241
  0019f	48 8d 4c 24 58	 lea	 rcx, QWORD PTR sblklen$[rsp]
  001a4	e8 00 00 00 00	 call	 sscanf

; 257  : 
; 258  :     /* Verify header integrity using the XOR header field */
; 259  :     if ( (prvblkl ^ curblkl) != xorblkl )

  001a9	8b 44 24 28	 mov	 eax, DWORD PTR curblkl$[rsp]
  001ad	8b 4c 24 24	 mov	 ecx, DWORD PTR prvblkl$[rsp]
  001b1	33 c8		 xor	 ecx, eax
  001b3	8b c1		 mov	 eax, ecx
  001b5	3b 44 24 2c	 cmp	 eax, DWORD PTR xorblkl$[rsp]
  001b9	74 07		 je	 SHORT $LN6@fet_read_h

; 260  :     {
; 261  :         return FETE_ERROR;

  001bb	b8 ff ff ff ff	 mov	 eax, -1
  001c0	eb 38		 jmp	 SHORT $LN1@fet_read_h
$LN6@fet_read_h:

; 262  :     }
; 263  : 
; 264  :     /* Return the converted value(s) to the caller */
; 265  :     if (pprvblkl) *pprvblkl = prvblkl;

  001c2	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR pprvblkl$[rsp], 0
  001cb	74 10		 je	 SHORT $LN7@fet_read_h
  001cd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pprvblkl$[rsp]
  001d5	0f b7 4c 24 24	 movzx	 ecx, WORD PTR prvblkl$[rsp]
  001da	66 89 08	 mov	 WORD PTR [rax], cx
$LN7@fet_read_h:

; 266  :     if (pcurblkl) *pcurblkl = curblkl;

  001dd	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR pcurblkl$[rsp], 0
  001e6	74 10		 je	 SHORT $LN8@fet_read_h
  001e8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pcurblkl$[rsp]
  001f0	0f b7 4c 24 28	 movzx	 ecx, WORD PTR curblkl$[rsp]
  001f5	66 89 08	 mov	 WORD PTR [rax], cx
$LN8@fet_read_h:

; 267  : 
; 268  :     /* Successful return */
; 269  :     return FETE_OK;

  001f8	33 c0		 xor	 eax, eax
$LN1@fet_read_h:
$LN9@fet_read_h:

; 270  : 
; 271  : } /* end function fet_read_header */

  001fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001ff	48 33 cc	 xor	 rcx, rsp
  00202	e8 00 00 00 00	 call	 __security_check_cookie
  00207	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0020b	c3		 ret	 0
fet_read_header ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
fetb$ = 48
fet_close PROC

; 192  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 193  :     if( *(fetb) != NULL )

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR fetb$[rsp]
  0000e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00012	74 2d		 je	 SHORT $LN2@fet_close

; 194  :     {
; 195  :         if( (*fetb)->fh != NULL )

  00014	48 8b 44 24 30	 mov	 rax, QWORD PTR fetb$[rsp]
  00019	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00020	74 11		 je	 SHORT $LN3@fet_close

; 196  :         {
; 197  :             fclose( (*fetb)->fh );

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR fetb$[rsp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
$LN3@fet_close:

; 198  :         }
; 199  :         free( *(fetb) );

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR fetb$[rsp]
  00038	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@fet_close:

; 200  :     }
; 201  :     *fetb = NULL;

  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR fetb$[rsp]
  00046	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 202  :     return( 0 );

  0004d	33 c0		 xor	 eax, eax

; 203  : }

  0004f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00053	c3		 ret	 0
fet_close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ftlib.c
_TEXT	SEGMENT
rc$ = 32
tfetb$ = 40
tv80 = 48
oflags$ = 52
omode$ = 56
pathname$ = 64
__$ArrayPad$ = 336
fetb$ = 368
filename$ = 376
flags$ = 384
fet_open PROC

; 67   : {

$LN19:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 68   : int             rc = -1;                /* Return code               */

  00028	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 69   : char            pathname[MAX_PATH];     /* file path in host format  */
; 70   : FETB           *tfetb;
; 71   : char           *omode;
; 72   : int             oflags;
; 73   : 
; 74   : 
; 75   :     /* Open the FAKETAPE file */
; 76   :     *fetb = NULL;

  00030	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR fetb$[rsp]
  00038	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 77   : 
; 78   :     hostpath(pathname, filename, sizeof(pathname));

  0003f	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00045	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR filename$[rsp]
  0004d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pathname$[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 79   : 
; 80   :     /*
; 81   :     || Allocate a new FETB
; 82   :     */
; 83   :     tfetb = calloc( 1, sizeof( FETB ) );

  00058	ba 48 01 00 00	 mov	 edx, 328		; 00000148H
  0005d	b9 01 00 00 00	 mov	 ecx, 1
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00068	48 89 44 24 28	 mov	 QWORD PTR tfetb$[rsp], rax

; 84   :     if( tfetb == NULL )

  0006d	48 83 7c 24 28
	00		 cmp	 QWORD PTR tfetb$[rsp], 0
  00073	75 0a		 jne	 SHORT $LN2@fet_open

; 85   :     {
; 86   :         return( FETE_NOMEM );

  00075	b8 ec ff ff ff	 mov	 eax, -20
  0007a	e9 4f 02 00 00	 jmp	 $LN1@fet_open
$LN2@fet_open:

; 87   :     }
; 88   : 
; 89   :     /* Initialize FETB */
; 90   :     tfetb->fd = -1;

  0007f	48 8b 44 24 28	 mov	 rax, QWORD PTR tfetb$[rsp]
  00084	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [rax+8], -1

; 91   : 
; 92   :     /*
; 93   :     || clear FETOPEN_CREATE if FETOPEN_READONLY is specified
; 94   :     */
; 95   :     if(flags & FETOPEN_READONLY)

  0008b	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00092	83 e0 02	 and	 eax, 2
  00095	85 c0		 test	 eax, eax
  00097	74 11		 je	 SHORT $LN3@fet_open

; 96   :     {
; 97   :         flags&=~FETOPEN_CREATE;

  00099	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  000a0	83 e0 fe	 and	 eax, -2
  000a3	89 84 24 80 01
	00 00		 mov	 DWORD PTR flags$[rsp], eax
$LN3@fet_open:

; 98   :     }
; 99   :     /*
; 100  :     || Translate HET create flag to filesystem flag
; 101  :     */
; 102  :     oflags = ( ( flags & FETOPEN_CREATE ) ? O_CREAT : 0 );

  000aa	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  000b1	83 e0 01	 and	 eax, 1
  000b4	85 c0		 test	 eax, eax
  000b6	74 0a		 je	 SHORT $LN17@fet_open
  000b8	c7 44 24 30 00
	01 00 00	 mov	 DWORD PTR tv80[rsp], 256 ; 00000100H
  000c0	eb 08		 jmp	 SHORT $LN18@fet_open
$LN17@fet_open:
  000c2	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@fet_open:
  000ca	8b 44 24 30	 mov	 eax, DWORD PTR tv80[rsp]
  000ce	89 44 24 34	 mov	 DWORD PTR oflags$[rsp], eax

; 103  : 
; 104  :     omode = "r+b";

  000d2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159190
  000d9	48 89 44 24 38	 mov	 QWORD PTR omode$[rsp], rax

; 105  :     if( !( flags & FETOPEN_READONLY ) )

  000de	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  000e5	83 e0 02	 and	 eax, 2
  000e8	85 c0		 test	 eax, eax
  000ea	75 24		 jne	 SHORT $LN4@fet_open

; 106  :     {
; 107  :         tfetb->fd = HOPEN( pathname, O_RDWR | O_BINARY | oflags, S_IRUSR | S_IWUSR | S_IRGRP );

  000ec	8b 44 24 34	 mov	 eax, DWORD PTR oflags$[rsp]
  000f0	0d 02 80 00 00	 or	 eax, 32770		; 00008002H
  000f5	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  000fb	8b d0		 mov	 edx, eax
  000fd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pathname$[rsp]
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00108	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tfetb$[rsp]
  0010d	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN4@fet_open:

; 108  :     }
; 109  : 
; 110  :     /* If file is read-only, attempt to open again */
; 111  :     if ( ( flags & FETOPEN_READONLY ) || (tfetb->fd < 0 && (EROFS == errno || EACCES == errno)))

  00110	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00117	83 e0 02	 and	 eax, 2
  0011a	85 c0		 test	 eax, eax
  0011c	75 21		 jne	 SHORT $LN6@fet_open
  0011e	48 8b 44 24 28	 mov	 rax, QWORD PTR tfetb$[rsp]
  00123	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00127	7d 59		 jge	 SHORT $LN5@fet_open
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0012f	83 38 1e	 cmp	 DWORD PTR [rax], 30
  00132	74 0b		 je	 SHORT $LN7@fet_open
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0013a	83 38 0d	 cmp	 DWORD PTR [rax], 13
  0013d	75 43		 jne	 SHORT $LN5@fet_open
$LN7@fet_open:
$LN6@fet_open:

; 112  :     {
; 113  :         omode = "rb";

  0013f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159195
  00146	48 89 44 24 38	 mov	 QWORD PTR omode$[rsp], rax

; 114  :         tfetb->writeprotect = TRUE;

  0014b	48 8b 44 24 28	 mov	 rax, QWORD PTR tfetb$[rsp]
  00150	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  00156	83 c8 01	 or	 eax, 1
  00159	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tfetb$[rsp]
  0015e	89 81 44 01 00
	00		 mov	 DWORD PTR [rcx+324], eax

; 115  :         tfetb->fd = HOPEN( pathname, O_RDONLY | O_BINARY, S_IRUSR | S_IRGRP );

  00164	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0016a	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  0016f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR pathname$[rsp]
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  0017a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tfetb$[rsp]
  0017f	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN5@fet_open:

; 116  :     }
; 117  : 
; 118  :     /*
; 119  :     || Error out if both opens failed
; 120  :     */
; 121  :     if( tfetb->fd == -1 )

  00182	48 8b 44 24 28	 mov	 rax, QWORD PTR tfetb$[rsp]
  00187	83 78 08 ff	 cmp	 DWORD PTR [rax+8], -1
  0018b	75 15		 jne	 SHORT $LN8@fet_open

; 122  :     {
; 123  :         free( tfetb );

  0018d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tfetb$[rsp]
  00192	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 124  :         return( FETE_ERROR );

  00198	b8 ff ff ff ff	 mov	 eax, -1
  0019d	e9 2c 01 00 00	 jmp	 $LN1@fet_open
$LN8@fet_open:

; 125  :     }
; 126  : 
; 127  :     /*
; 128  :     || Associate stream with file descriptor
; 129  :     */
; 130  :     tfetb->fh = fdopen( tfetb->fd, omode );

  001a2	48 8b 54 24 38	 mov	 rdx, QWORD PTR omode$[rsp]
  001a7	48 8b 44 24 28	 mov	 rax, QWORD PTR tfetb$[rsp]
  001ac	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fdopen
  001b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tfetb$[rsp]
  001ba	48 89 01	 mov	 QWORD PTR [rcx], rax

; 131  : 
; 132  :     if( tfetb->fh == NULL )

  001bd	48 8b 44 24 28	 mov	 rax, QWORD PTR tfetb$[rsp]
  001c2	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001c6	75 3b		 jne	 SHORT $LN9@fet_open

; 133  :     {
; 134  :         rc = errno;

  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001ce	8b 00		 mov	 eax, DWORD PTR [rax]
  001d0	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 135  :         close( tfetb->fd );

  001d4	48 8b 44 24 28	 mov	 rax, QWORD PTR tfetb$[rsp]
  001d9	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 136  :         errno = rc;

  001e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001e8	8b 4c 24 20	 mov	 ecx, DWORD PTR rc$[rsp]
  001ec	89 08		 mov	 DWORD PTR [rax], ecx

; 137  :         free( tfetb );

  001ee	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tfetb$[rsp]
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 138  :         return( FETE_ERROR );

  001f9	b8 ff ff ff ff	 mov	 eax, -1
  001fe	e9 cb 00 00 00	 jmp	 $LN1@fet_open
$LN9@fet_open:

; 139  :     }
; 140  : 
; 141  :     /*
; 142  :     || If uninitialized tape, write 2 tapemarks to make it a valid NL tape
; 143  :     */
; 144  :     rc = fet_read_header( tfetb, 0L, NULL, NULL );

  00203	45 33 c9	 xor	 r9d, r9d
  00206	45 33 c0	 xor	 r8d, r8d
  00209	33 d2		 xor	 edx, edx
  0020b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tfetb$[rsp]
  00210	e8 00 00 00 00	 call	 fet_read_header
  00215	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 145  :     if( rc < 0 && rc != FETE_TAPEMARK )

  00219	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0021e	7d 68		 jge	 SHORT $LN10@fet_open
  00220	83 7c 24 20 fe	 cmp	 DWORD PTR rc$[rsp], -2
  00225	74 61		 je	 SHORT $LN10@fet_open

; 146  :     {
; 147  :         if( rc != FETE_EOT )

  00227	83 7c 24 20 fc	 cmp	 DWORD PTR rc$[rsp], -4
  0022c	74 09		 je	 SHORT $LN12@fet_open

; 148  :         {
; 149  :             return( rc );

  0022e	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00232	e9 97 00 00 00	 jmp	 $LN1@fet_open
$LN12@fet_open:

; 150  :         }
; 151  : 
; 152  :         rc = fet_tapemark( tfetb );

  00237	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tfetb$[rsp]
  0023c	e8 00 00 00 00	 call	 fet_tapemark
  00241	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 153  :         if( rc < 0 )

  00245	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0024a	7d 06		 jge	 SHORT $LN13@fet_open

; 154  :         {
; 155  :             return( rc );

  0024c	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  00250	eb 7c		 jmp	 SHORT $LN1@fet_open
$LN13@fet_open:

; 156  :         }
; 157  : 
; 158  :         rc = fet_tapemark( tfetb );

  00252	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tfetb$[rsp]
  00257	e8 00 00 00 00	 call	 fet_tapemark
  0025c	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 159  :         if( rc < 0 )

  00260	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00265	7d 06		 jge	 SHORT $LN14@fet_open

; 160  :         {
; 161  :             return( rc );

  00267	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  0026b	eb 61		 jmp	 SHORT $LN1@fet_open
$LN14@fet_open:

; 162  :         }
; 163  : 
; 164  :         tfetb->created = TRUE;

  0026d	48 8b 44 24 28	 mov	 rax, QWORD PTR tfetb$[rsp]
  00272	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  00278	83 c8 10	 or	 eax, 16
  0027b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tfetb$[rsp]
  00280	89 81 44 01 00
	00		 mov	 DWORD PTR [rcx+324], eax

; 165  :     }

  00286	eb 19		 jmp	 SHORT $LN11@fet_open
$LN10@fet_open:

; 166  :     else
; 167  :         tfetb->created = FALSE;

  00288	48 8b 44 24 28	 mov	 rax, QWORD PTR tfetb$[rsp]
  0028d	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  00293	83 e0 ef	 and	 eax, -17		; ffffffefH
  00296	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tfetb$[rsp]
  0029b	89 81 44 01 00
	00		 mov	 DWORD PTR [rcx+324], eax
$LN11@fet_open:

; 168  : 
; 169  :     /*
; 170  :     || Reposition tape to load point
; 171  :     */
; 172  :     rc = fet_rewind( tfetb );

  002a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tfetb$[rsp]
  002a6	e8 00 00 00 00	 call	 fet_rewind
  002ab	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 173  :     if( rc < 0 )

  002af	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  002b4	7d 06		 jge	 SHORT $LN15@fet_open

; 174  :     {
; 175  :         return( rc );

  002b6	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
  002ba	eb 12		 jmp	 SHORT $LN1@fet_open
$LN15@fet_open:

; 176  :     }
; 177  : 
; 178  :     /*
; 179  :     || Give the caller the new FETB
; 180  :     */
; 181  :     *fetb = tfetb;

  002bc	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR fetb$[rsp]
  002c4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tfetb$[rsp]
  002c9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 182  : 
; 183  :     return( 0 );

  002cc	33 c0		 xor	 eax, eax
$LN1@fet_open:

; 184  : 
; 185  : } /* end function fet_open */

  002ce	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002d6	48 33 cc	 xor	 rcx, rsp
  002d9	e8 00 00 00 00	 call	 __security_check_cookie
  002de	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  002e5	c3		 ret	 0
fet_open ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
END
