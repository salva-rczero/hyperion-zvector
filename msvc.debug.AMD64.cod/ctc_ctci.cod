; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	ctci_device_hndinfo
PUBLIC	CTCI_Init
PUBLIC	CTCI_Close
PUBLIC	CTCI_Query
PUBLIC	CTCI_ExecuteCCW
_DATA	SEGMENT
ctci_device_hndinfo DQ FLAT:CTCI_Init
	DQ	FLAT:CTCI_ExecuteCCW
	DQ	FLAT:CTCI_Close
	DQ	FLAT:CTCI_Query
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:ctc_halt_or_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:CTCI_Immed_Commands
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG169648 DB	'dev', 00H
$SG169651 DB	'mac', 00H
CTCI_Immed_Commands DB 00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
$SG169649 DB	'kbuff', 00H
	ORG $+2
$SG169650 DB	'ibuff', 00H
	ORG $+2
$SG169652 DB	'mtu', 00H
	ORG $+4
$SG169653 DB	'netmask', 00H
$SG169654 DB	'debug', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	CTCI_Read
PUBLIC	CTCI_Write
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_inet_addr:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_getpid:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_timed_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_join_thread:PROC
EXTRN	__imp_hthread_detach_thread:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_gettimeofday:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_inet_aton:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	tt32_write:PROC
EXTRN	tt32_close:PROC
EXTRN	tt32_ioctl:PROC
EXTRN	__imp_init_sysblk_netdev:PROC
EXTRN	__imp_group_device:PROC
EXTRN	__imp_getopt_long:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	read_tuntap:PROC
EXTRN	TUNTAP_CreateInterface:PROC
EXTRN	TUNTAP_SetIPAddr:PROC
EXTRN	TUNTAP_SetDestAddr:PROC
EXTRN	TUNTAP_SetNetMask:PROC
EXTRN	TUNTAP_SetMTU:PROC
EXTRN	TUNTAP_SetMACAddr:PROC
EXTRN	TUNTAP_SetFlags:PROC
EXTRN	build_herc_iface_mac:PROC
EXTRN	ParseMAC:PROC
EXTRN	net_data_trace:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_optind:DWORD
EXTRN	__imp_optarg:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG169324 DB	01H DUP (?)
$SG169475 DB	01H DUP (?)
$SG169523 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$CTCI_Init DD imagerel $LN71
	DD	imagerel $LN71+3798
	DD	imagerel $unwind$CTCI_Init
$pdata$CTCI_Close DD imagerel $LN4
	DD	imagerel $LN4+131
	DD	imagerel $unwind$CTCI_Close
$pdata$CTCI_Query DD imagerel $LN18
	DD	imagerel $LN18+644
	DD	imagerel $unwind$CTCI_Query
$pdata$CTCI_ExecuteCCW DD imagerel $LN58
	DD	imagerel $LN58+1504
	DD	imagerel $unwind$CTCI_ExecuteCCW
$pdata$CTCI_Read DD imagerel $LN16
	DD	imagerel $LN16+1283
	DD	imagerel $unwind$CTCI_Read
$pdata$CTCI_Write DD imagerel $LN24
	DD	imagerel $LN24+2496
	DD	imagerel $unwind$CTCI_Write
$pdata$SetSIDInfo DD imagerel SetSIDInfo
	DD	imagerel SetSIDInfo+269
	DD	imagerel $unwind$SetSIDInfo
$pdata$ctc_halt_or_clear DD imagerel ctc_halt_or_clear
	DD	imagerel ctc_halt_or_clear+159
	DD	imagerel $unwind$ctc_halt_or_clear
$pdata$CTCI_ReadThread DD imagerel CTCI_ReadThread
	DD	imagerel CTCI_ReadThread+1268
	DD	imagerel $unwind$CTCI_ReadThread
$pdata$CTCI_EnqueueIPFrame DD imagerel CTCI_EnqueueIPFrame
	DD	imagerel CTCI_EnqueueIPFrame+571
	DD	imagerel $unwind$CTCI_EnqueueIPFrame
$pdata$ParseArgs DD imagerel ParseArgs
	DD	imagerel ParseArgs+5216
	DD	imagerel $unwind$ParseArgs
pdata	ENDS
_DATA	SEGMENT
	ORG $+2
$SG169113 DB	'malloc(%d)', 00H
	ORG $+1
$SG169114 DB	'CTCI', 00H
	ORG $+3
$SG169115 DB	'E', 00H
	ORG $+2
$SG169116 DB	'HHC00900%s %1d:%04X %s: Error in function %s: %s', 0aH, 00H
	ORG $+2
$SG169125 DB	'TUN', 00H
$SG169117 DB	'CTCI_Init', 00H
	ORG $+2
$SG169126 DB	'I', 00H
	ORG $+2
$SG169118 DB	'ctc_ctci.c', 00H
	ORG $+1
$SG169133 DB	'W', 00H
	ORG $+2
$SG169119 DB	'ctc_ctci.c:229', 00H
	ORG $+1
$SG169120 DB	'&pDevCTCBLK->Lock', 00H
	ORG $+2
$SG169139 DB	'W', 00H
	ORG $+2
$SG169121 DB	'ctc_ctci.c:230', 00H
	ORG $+1
$SG169122 DB	'&pDevCTCBLK->EventLock', 00H
	ORG $+1
$SG169123 DB	'ctc_ctci.c:231', 00H
	ORG $+1
$SG169127 DB	'HHC00901%s %1d:%04X %s: Interface %s, type %s opened', 0aH
	DB	00H
	ORG $+2
$SG169128 DB	'CTCI_Init', 00H
	ORG $+2
$SG169206 DB	'E', 00H
	ORG $+2
$SG169129 DB	'ctc_ctci.c', 00H
	ORG $+1
$SG169314 DB	'.', 00H
	ORG $+2
$SG169132 DB	'TT32SDEVBUFF', 00H
	ORG $+3
$SG169134 DB	'HHC00902%s %1d:%04X %s: ioctl %s failed for device %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169319 DB	'-', 00H
	ORG $+2
$SG169135 DB	'CTCI_Init', 00H
	ORG $+2
$SG169322 DB	'-', 00H
	ORG $+2
$SG169136 DB	'ctc_ctci.c', 00H
	ORG $+1
$SG169323 DB	' -d', 00H
$SG169138 DB	'TT32SIOBUFF', 00H
$SG169377 DB	'I', 00H
	ORG $+2
$SG169140 DB	'HHC00902%s %1d:%04X %s: ioctl %s failed for device %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169390 DB	'D', 00H
	ORG $+2
$SG169141 DB	'CTCI_Init', 00H
	ORG $+2
$SG169444 DB	'E', 00H
	ORG $+2
$SG169142 DB	'ctc_ctci.c', 00H
	ORG $+1
$SG169449 DB	'D', 00H
	ORG $+2
$SG169145 DB	'%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X', 00H
$SG169458 DB	'I', 00H
	ORG $+2
$SG169146 DB	'** CTCI_Init: %4.4X (%s): IP "%s"  -->  default MAC "%s"'
	DB	0aH, 00H
	ORG $+2
$SG169464 DB	'E', 00H
	ORG $+2
$SG169148 DB	'** CTCI_Init: %4.4X (%s): IP "%s"  -->  default MAC "%s"'
	DB	0aH, 00H
	ORG $+2
$SG169470 DB	'E', 00H
	ORG $+2
$SG169150 DB	'CTCI_Init', 00H
	ORG $+2
$SG169477 DB	'D', 00H
	ORG $+2
$SG169151 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169203 DB	'CTCI %4.4X ReadThread', 00H
	ORG $+2
$SG169152 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169154 DB	'CTCI_Init', 00H
	ORG $+2
$SG169481 DB	'packet', 00H
	ORG $+1
$SG169484 DB	'E', 00H
	ORG $+2
$SG169155 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169156 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169159 DB	'CTCI_Init', 00H
	ORG $+2
$SG169517 DB	'E', 00H
	ORG $+2
$SG169160 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169204 DB	'ctc_ctci.c:345', 00H
	ORG $+1
$SG169207 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG169161 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169163 DB	'CTCI_Init', 00H
	ORG $+2
$SG169525 DB	'D', 00H
	ORG $+2
$SG169164 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169290 DB	'ctc_ctci.c:611', 00H
	ORG $+1
$SG169308 DB	'CTCA', 00H
	ORG $+3
$SG169165 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169168 DB	'CTCI_Init', 00H
	ORG $+2
$SG169529 DB	'packet', 00H
	ORG $+1
$SG169532 DB	'W', 00H
	ORG $+2
$SG169169 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169170 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169172 DB	'CTCI_Init', 00H
	ORG $+2
$SG169640 DB	'E', 00H
	ORG $+2
$SG169173 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169291 DB	'ctc_ctci.c:613', 00H
	ORG $+1
$SG169376 DB	'CTCI', 00H
	ORG $+3
$SG169174 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169177 DB	'CTCI_Init', 00H
	ORG $+2
$SG169646 DB	'/', 00H
	ORG $+2
$SG169178 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169316 DB	'*Uninitialized', 00H
	ORG $+1
$SG169378 DB	'HHC00904%s %1d:%04X %s: Halt or clear recognized', 0aH, 00H
	ORG $+6
$SG169179 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169181 DB	'CTCI_Init', 00H
	ORG $+2
$SG169662 DB	'E', 00H
	ORG $+2
$SG169182 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169331 DB	'ctc_ctci.c:676', 00H
	ORG $+1
$SG169389 DB	'CTCI', 00H
	ORG $+3
$SG169183 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169186 DB	'CTCI_Init', 00H
	ORG $+2
$SG169669 DB	'E', 00H
	ORG $+2
$SG169187 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169333 DB	'ctc_ctci.c:681', 00H
	ORG $+1
$SG169394 DB	'data', 00H
	ORG $+3
$SG169188 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169190 DB	'CTCI_Init', 00H
	ORG $+2
$SG169678 DB	'E', 00H
	ORG $+2
$SG169191 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169334 DB	'ctc_ctci.c:684', 00H
	ORG $+1
$SG169445 DB	'HHC00906%s %1d:%04X CTC: write CCW count %u is invalid', 0aH
	DB	00H
$SG169192 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169195 DB	'CTCI_Init', 00H
	ORG $+2
$SG169687 DB	'E', 00H
	ORG $+2
$SG169196 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169367 DB	'ctc_ctci.c:722', 00H
	ORG $+1
$SG169453 DB	'data', 00H
	ORG $+3
$SG169197 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169199 DB	'CTCI_Init', 00H
	ORG $+2
$SG169696 DB	'E', 00H
	ORG $+2
$SG169200 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169369 DB	'ctc_ctci.c:726', 00H
	ORG $+1
$SG169459 DB	'HHC00907%s %1d:%04X CTC: interface command: %s %8.8X', 0aH
	DB	00H
	ORG $+2
$SG169201 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169208 DB	'CTCI_Init', 00H
	ORG $+2
$SG169705 DB	'E', 00H
	ORG $+2
$SG169209 DB	'ctc_ctci.c', 00H
	ORG $+1
$SG169713 DB	'E', 00H
	ORG $+2
$SG169325 DB	'CTCI %s/%s (%s)%s IO[%llu]', 00H
	ORG $+1
$SG169726 DB	'E', 00H
	ORG $+2
$SG169370 DB	'ctc_ctci.c:736', 00H
	ORG $+1
$SG169371 DB	'ctc_ctci.c:740', 00H
	ORG $+1
$SG169373 DB	'ctc_ctci.c:749', 00H
	ORG $+1
$SG169379 DB	'CTCI_Read', 00H
	ORG $+2
$SG169733 DB	'E', 00H
	ORG $+2
$SG169380 DB	'ctc_ctci.c', 00H
	ORG $+1
$SG169738 DB	'E', 00H
	ORG $+2
$SG169383 DB	'ctc_ctci.c:769', 00H
	ORG $+1
$SG169385 DB	'ctc_ctci.c:775', 00H
	ORG $+1
$SG169476 DB	'CTCI', 00H
	ORG $+3
$SG169391 DB	'HHC00982%s %1d:%04X %s: Present data of size %d bytes to'
	DB	' guest', 0aH, 00H
$SG169392 DB	'CTCI_Read', 00H
	ORG $+2
$SG169746 DB	'E', 00H
	ORG $+2
$SG169393 DB	'ctc_ctci.c', 00H
	ORG $+1
$SG169754 DB	'E', 00H
	ORG $+2
$SG169395 DB	'ctc_ctci.c:818', 00H
	ORG $+1
$SG169446 DB	'CTCI_Write', 00H
	ORG $+1
$SG169763 DB	'E', 00H
	ORG $+2
$SG169447 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169450 DB	'HHC00981%s %1d:%04X %s: Accept data of size %d bytes fro'
	DB	'm guest', 0aH, 00H
	ORG $+3
$SG169772 DB	'E', 00H
	ORG $+2
$SG169451 DB	'CTCI_Write', 00H
	ORG $+1
$SG169778 DB	'E', 00H
	ORG $+2
$SG169452 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169460 DB	'CTCI_Write', 00H
	ORG $+5
$SG169461 DB	'ctc_ctci.c', 00H
	ORG $+1
$SG169483 DB	'CTCI', 00H
	ORG $+7
$SG169465 DB	'HHC00908%s %1d:%04X CTC: incomplete write buffer segment'
	DB	' header at offset %4.4X', 0aH, 00H
	ORG $+7
$SG169466 DB	'CTCI_Write', 00H
	ORG $+5
$SG169467 DB	'ctc_ctci.c', 00H
	ORG $+1
$SG169516 DB	'CTCI', 00H
	ORG $+7
$SG169471 DB	'HHC00909%s %1d:%04X CTC: invalid write buffer segment le'
	DB	'ngth %u at offset %4.4X', 0aH, 00H
	ORG $+7
$SG169472 DB	'CTCI_Write', 00H
	ORG $+5
$SG169473 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169518 DB	'HHC00912%s %1d:%04X %s: Error reading from device %s: %d'
	DB	' %s', 0aH, 00H
	ORG $+3
$SG169519 DB	'CTCI_ReadThread', 00H
$SG169524 DB	'CTCI', 00H
	ORG $+3
$SG169478 DB	'HHC00910%s %1d:%04X %s: Send%s packet of size %d bytes t'
	DB	'o device %s', 0aH, 00H
	ORG $+3
$SG169479 DB	'CTCI_Write', 00H
	ORG $+5
$SG169480 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169485 DB	'HHC00911%s %1d:%04X %s: Error writing to device %s: %d %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169486 DB	'CTCI_Write', 00H
	ORG $+5
$SG169487 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169520 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169527 DB	'CTCI_ReadThread', 00H
$SG169533 DB	'HHC00914%s %1d:%04X CTC: packet frame too big, dropped', 0aH
	DB	00H
$SG169526 DB	'HHC00913%s %1d:%04X %s: Receive%s packet of size %d byte'
	DB	's from device %s', 0aH, 00H
	ORG $+6
$SG169528 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169534 DB	'CTCI_ReadThread', 00H
$SG169535 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169537 DB	'CTCI_ReadThread', 00H
$SG169538 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169539 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169541 DB	'CTCI_ReadThread', 00H
$SG169542 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169546 DB	'CTCI_ReadThread', 00H
$SG169636 DB	'1500', 00H
	ORG $+3
$SG169543 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169547 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169550 DB	'CTCI_ReadThread', 00H
$SG169639 DB	'CTCI', 00H
	ORG $+3
$SG169548 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169551 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169581 DB	'ctc_ctci.c:1135', 00H
$SG169641 DB	'HHC00915%s %1d:%04X %s: Incorrect number of parameters', 0aH
	DB	00H
$SG169552 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169583 DB	'ctc_ctci.c:1145', 00H
$SG169584 DB	'ctc_ctci.c:1180', 00H
$SG169585 DB	'ctc_ctci.c:1182', 00H
$SG169586 DB	'ctc_ctci.c:1183', 00H
$SG169587 DB	'ctc_ctci.c:1184', 00H
$SG169661 DB	'CTCI', 00H
	ORG $+3
?options@?7??ParseArgs@@9@9 DQ FLAT:$SG169648		; `ParseArgs'::`8'::options
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06eH
	ORG $+4
	DQ	FLAT:$SG169649
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06bH
	ORG $+4
	DQ	FLAT:$SG169650
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	069H
	ORG $+4
	DQ	FLAT:$SG169651
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06dH
	ORG $+4
	DQ	FLAT:$SG169652
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	074H
	ORG $+4
	DQ	FLAT:$SG169653
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	073H
	ORG $+4
	DQ	FLAT:$SG169654
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	064H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
$SG169637 DB	'255.255.255.255', 00H
$SG169642 DB	'ParseArgs', 00H
	ORG $+6
$SG169643 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169655 DB	'n:k:i:m:t:s:d', 00H
	ORG $+2
$SG169660 DB	'adapter address', 00H
$SG169663 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG169664 DB	'ParseArgs', 00H
	ORG $+6
$SG169665 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169667 DB	'device name', 00H
$SG169668 DB	'CTCI', 00H
	ORG $+7
$SG169670 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG169671 DB	'ParseArgs', 00H
	ORG $+6
$SG169672 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169676 DB	'kernel buffer size', 00H
	ORG $+1
$SG169677 DB	'CTCI', 00H
	ORG $+7
$SG169679 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG169680 DB	'ParseArgs', 00H
	ORG $+6
$SG169681 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169685 DB	'dll i/o buffer size', 00H
$SG169686 DB	'CTCI', 00H
	ORG $+7
$SG169688 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG169689 DB	'ParseArgs', 00H
	ORG $+6
$SG169690 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169694 DB	'MAC address', 00H
$SG169695 DB	'CTCI', 00H
	ORG $+7
$SG169697 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG169698 DB	'ParseArgs', 00H
	ORG $+6
$SG169699 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169703 DB	'MTU size', 00H
	ORG $+3
$SG169704 DB	'CTCI', 00H
	ORG $+7
$SG169706 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG169707 DB	'ParseArgs', 00H
	ORG $+6
$SG169708 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169711 DB	'netmask', 00H
$SG169712 DB	'CTCI', 00H
	ORG $+3
$SG169714 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG169715 DB	'ParseArgs', 00H
	ORG $+6
$SG169716 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169724 DB	'IP address', 00H
	ORG $+1
$SG169725 DB	'CTCI', 00H
	ORG $+7
$SG169727 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG169728 DB	'ParseArgs', 00H
	ORG $+6
$SG169729 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169731 DB	'IP address', 00H
	ORG $+1
$SG169732 DB	'CTCI', 00H
	ORG $+7
$SG169734 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG169735 DB	'ParseArgs', 00H
	ORG $+6
$SG169736 DB	'ctc_ctci.c', 00H
	ORG $+1
$SG169737 DB	'CTCI', 00H
	ORG $+7
$SG169739 DB	'HHC00915%s %1d:%04X %s: Incorrect number of parameters', 0aH
	DB	00H
$SG169740 DB	'ParseArgs', 00H
	ORG $+6
$SG169741 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169744 DB	'IP address', 00H
	ORG $+1
$SG169745 DB	'CTCI', 00H
	ORG $+7
$SG169747 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG169748 DB	'ParseArgs', 00H
	ORG $+6
$SG169749 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169752 DB	'MAC address', 00H
$SG169753 DB	'CTCI', 00H
	ORG $+7
$SG169755 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG169756 DB	'ParseArgs', 00H
	ORG $+6
$SG169757 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169761 DB	'kernel buffer size', 00H
	ORG $+1
$SG169762 DB	'CTCI', 00H
	ORG $+7
$SG169764 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG169765 DB	'ParseArgs', 00H
	ORG $+6
$SG169766 DB	'ctc_ctci.c', 00H
	ORG $+5
$SG169770 DB	'dll i/o buffer size', 00H
$SG169771 DB	'CTCI', 00H
	ORG $+7
$SG169773 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG169774 DB	'ParseArgs', 00H
	ORG $+6
$SG169775 DB	'ctc_ctci.c', 00H
	ORG $+1
$SG169777 DB	'CTCI', 00H
	ORG $+7
$SG169779 DB	'HHC00915%s %1d:%04X %s: Incorrect number of parameters', 0aH
	DB	00H
$SG169780 DB	'ParseArgs', 00H
	ORG $+6
$SG169781 DB	'ctc_ctci.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ParseArgs
	DD	02cH
	DD	01400H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCI_ReadThread
	DD	016H
	DD	04dcH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCI_Write
	DD	024H
	DD	09a8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCI_Read
	DD	026H
	DD	04e9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCI_Query
	DD	025H
	DD	026cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCI_Init
	DD	027H
	DD	0ebcH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$CTCI_Init DD 042f19H
	DD	0a6f011dH
	DD	0600f7010H
	DD	imagerel __GSHandlerCheck
	DD	05360H
$unwind$CTCI_Close DD 010901H
	DD	06209H
$unwind$CTCI_Query DD 022d19H
	DD	033011bH
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$CTCI_ExecuteCCW DD 031901H
	DD	07015a219H
	DD	06014H
$unwind$CTCI_Read DD 042e19H
	DD	017011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$CTCI_Write DD 022c19H
	DD	029011aH
	DD	imagerel __GSHandlerCheck
	DD	0138H
$unwind$SetSIDInfo DD 021a01H
	DD	07016121aH
$unwind$ctc_halt_or_clear DD 010901H
	DD	06209H
$unwind$CTCI_ReadThread DD 021e19H
	DD	011b010cH
	DD	imagerel __GSHandlerCheck
	DD	08c0H
$unwind$CTCI_EnqueueIPFrame DD 031501H
	DD	070118215H
	DD	06010H
$unwind$ParseArgs DD 033419H
	DD	04260122H
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	02128H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ctci.c
_TEXT	SEGMENT
i$ = 96
argv$ = 104
iKernBuff$ = 112
iIOBuff$ = 116
addr$ = 120
tv181 = 124
saw_conf$ = 128
tv538 = 132
c$1 = 136
iMTU$ = 140
tv135 = 144
tv194 = 148
tv198 = 152
tv216 = 156
tv220 = 160
tv245 = 164
tv249 = 168
tv272 = 172
tv276 = 176
tv340 = 180
tv344 = 184
tv367 = 188
tv371 = 192
tv394 = 196
tv398 = 200
tv435 = 204
tv439 = 208
tv464 = 212
tv468 = 216
tv522 = 220
tv526 = 224
tv547 = 228
tv551 = 232
tv580 = 236
tv584 = 240
tv617 = 244
tv621 = 248
tv647 = 252
tv651 = 256
tv669 = 260
tv705 = 264
tv131 = 268
iOpt$2 = 272
saw_if$ = 276
argn$ = 288
mac$ = 8480
__$ArrayPad$ = 8488
pDEVBLK$ = 8512
pCTCBLK$ = 8520
argc$ = 8528
argx$ = 8536
ParseArgs PROC

; 1195 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	b8 30 21 00 00	 mov	 eax, 8496		; 00002130H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 84 24 28
	21 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1196 :     int             saw_if = 0;       /* -if specified               */

  00034	c7 84 24 14 01
	00 00 00 00 00
	00		 mov	 DWORD PTR saw_if$[rsp], 0

; 1197 :     int             saw_conf = 0; /* Other configuration flags present */

  0003f	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR saw_conf$[rsp], 0

; 1198 :     struct in_addr  addr;               // Work area for addresses
; 1199 :     int             iMTU;
; 1200 :     int             i;
; 1201 :     MAC             mac;                // Work area for MAC address
; 1202 : #if defined(OPTION_W32_CTCI)
; 1203 :     int             iKernBuff;
; 1204 :     int             iIOBuff;
; 1205 : #endif
; 1206 :     char          *argn[MAX_ARGS];
; 1207 :     char         **argv = argn;

  0004a	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR argn$[rsp]
  00052	48 89 44 24 68	 mov	 QWORD PTR argv$[rsp], rax

; 1208 : 
; 1209 :     // Copy argv (as this routine needs to make local changes)
; 1210 :     for(i=0; i<argc && i<MAX_ARGS;i++)

  00057	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0005f	eb 0a		 jmp	 SHORT $LN4@ParseArgs
$LN2@ParseArgs:
  00061	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00065	ff c0		 inc	 eax
  00067	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@ParseArgs:
  0006b	8b 84 24 50 21
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00072	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  00076	7d 2a		 jge	 SHORT $LN3@ParseArgs
  00078	81 7c 24 60 00
	04 00 00	 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  00080	7d 20		 jge	 SHORT $LN3@ParseArgs

; 1211 :         argn[i]=argx[i];

  00082	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00087	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  0008c	48 8b 94 24 58
	21 00 00	 mov	 rdx, QWORD PTR argx$[rsp]
  00094	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  00098	48 89 84 cc 20
	01 00 00	 mov	 QWORD PTR argn$[rsp+rcx*8], rax
  000a0	eb bf		 jmp	 SHORT $LN2@ParseArgs
$LN3@ParseArgs:

; 1212 : 
; 1213 :     // Housekeeping
; 1214 :     memset( &addr, 0, sizeof( struct in_addr ) );

  000a2	48 8d 44 24 78	 lea	 rax, QWORD PTR addr$[rsp]
  000a7	48 8b f8	 mov	 rdi, rax
  000aa	33 c0		 xor	 eax, eax
  000ac	b9 04 00 00 00	 mov	 ecx, 4
  000b1	f3 aa		 rep stosb

; 1215 :     memset( &mac, 0, sizeof( MAC ) );

  000b3	48 8d 84 24 20
	21 00 00	 lea	 rax, QWORD PTR mac$[rsp]
  000bb	48 8b f8	 mov	 rdi, rax
  000be	33 c0		 xor	 eax, eax
  000c0	b9 06 00 00 00	 mov	 ecx, 6
  000c5	f3 aa		 rep stosb

; 1216 : 
; 1217 :     // Set some initial defaults
; 1218 :     STRLCPY( pCTCBLK->szMTU,     "1500" );

  000c7	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  000cf	48 05 a6 50 00
	00		 add	 rax, 20646		; 000050a6H
  000d5	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169636
  000e2	48 8b c8	 mov	 rcx, rax
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1219 :     STRLCPY( pCTCBLK->szNetMask, "255.255.255.255" );

  000eb	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  000f3	48 05 86 50 00
	00		 add	 rax, 20614		; 00005086H
  000f9	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169637
  00106	48 8b c8	 mov	 rcx, rax
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1220 :     STRLCPY( pCTCBLK->szTUNCharDevName, DEF_NETDEV );

  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_init_sysblk_netdev
  00115	48 8b 8c 24 48
	21 00 00	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  0011d	48 81 c1 c6 50
	00 00		 add	 rcx, 20678		; 000050c6H
  00124	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0012a	48 8b d0	 mov	 rdx, rax
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1221 : 
; 1222 : #if defined( OPTION_W32_CTCI )
; 1223 :     pCTCBLK->iKernBuff = DEF_CAPTURE_BUFFSIZE;

  00133	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0013b	c7 80 3e 50 00
	00 00 00 10 00	 mov	 DWORD PTR [rax+20542], 1048576 ; 00100000H

; 1224 :     pCTCBLK->iIOBuff   = DEF_PACKET_BUFFSIZE;

  00145	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0014d	c7 80 42 50 00
	00 00 00 01 00	 mov	 DWORD PTR [rax+20546], 65536 ; 00010000H

; 1225 : #endif
; 1226 : 
; 1227 :     // Initialize getopt's counter. This is necessary in the case
; 1228 :     // that getopt was used previously for another device.
; 1229 : 
; 1230 :     OPTRESET();
; 1231 :     optind      = 0;

  00157	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  0015e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1232 :     // Check for correct number of arguments
; 1233 :     if( argc < 1 )

  00164	83 bc 24 50 21
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  0016c	0f 8d 9b 00 00
	00		 jge	 $LN16@ParseArgs

; 1234 :     {
; 1235 :         // "%1d:%04X CTC: incorrect number of parameters"
; 1236 :         WRMSG(HHC00915, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI");

  00172	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0017a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0017e	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv131[rsp], eax
  00185	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0018d	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00191	d1 f9		 sar	 ecx, 1
  00193	89 8c 24 90 00
	00 00		 mov	 DWORD PTR tv135[rsp], ecx
  0019a	b9 01 00 00 00	 mov	 ecx, 1
  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169639
  001ac	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001b1	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv131[rsp]
  001b8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001bc	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv135[rsp]
  001c3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169640
  001ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169641
  001da	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e4	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169642
  001f1	ba d4 04 00 00	 mov	 edx, 1236		; 000004d4H
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169643
  001fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1237 :         return -1;

  00203	b8 ff ff ff ff	 mov	 eax, -1
  00208	e9 f3 11 00 00	 jmp	 $LN1@ParseArgs
$LN16@ParseArgs:

; 1238 :     }
; 1239 :     // Compatibility with old format configuration files needs to be
; 1240 :     // maintained. Old format statements have the tun character device
; 1241 :     // name as the second argument on Linux.
; 1242 :     if (strncasecmp( argv[0], "/", 1 ) == 0)

  0020d	b8 08 00 00 00	 mov	 eax, 8
  00212	48 6b c0 00	 imul	 rax, rax, 0
  00216	41 b8 01 00 00
	00		 mov	 r8d, 1
  0021c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169646
  00223	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  00228	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00232	85 c0		 test	 eax, eax
  00234	75 24		 jne	 SHORT $LN17@ParseArgs

; 1243 :     {
; 1244 :         pCTCBLK->fOldFormat = 1;

  00236	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0023e	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  00244	83 c8 02	 or	 eax, 2
  00247	48 8b 8c 24 48
	21 00 00	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  0024f	89 81 3a 50 00
	00		 mov	 DWORD PTR [rcx+20538], eax

; 1245 :     }

  00255	e9 85 00 00 00	 jmp	 $LN18@ParseArgs
$LN17@ParseArgs:

; 1246 :     else
; 1247 :     {
; 1248 :         // Build new argv list.
; 1249 :         // getopt_long used to work on old format configuration statements
; 1250 :         // because LCS was the first argument passed to the device
; 1251 :         // initialization routine (and was interpreted by getopt*
; 1252 :         // as the program name and ignored). Now that argv[0] is a valid
; 1253 :         // argument, we need to shift the arguments and insert a dummy
; 1254 :         // argv[0];
; 1255 : 
; 1256 :         // Don't allow us to exceed the allocated storage (sanity check)
; 1257 :         if( argc > (MAX_ARGS-1) )

  0025a	81 bc 24 50 21
	00 00 ff 03 00
	00		 cmp	 DWORD PTR argc$[rsp], 1023 ; 000003ffH
  00265	7e 0b		 jle	 SHORT $LN19@ParseArgs

; 1258 :             argc = (MAX_ARGS-1);

  00267	c7 84 24 50 21
	00 00 ff 03 00
	00		 mov	 DWORD PTR argc$[rsp], 1023 ; 000003ffH
$LN19@ParseArgs:

; 1259 : 
; 1260 :         for( i = argc; i > 0; i-- )

  00272	8b 84 24 50 21
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00279	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
  0027d	eb 0a		 jmp	 SHORT $LN7@ParseArgs
$LN5@ParseArgs:
  0027f	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00283	ff c8		 dec	 eax
  00285	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN7@ParseArgs:
  00289	83 7c 24 60 00	 cmp	 DWORD PTR i$[rsp], 0
  0028e	7e 21		 jle	 SHORT $LN6@ParseArgs

; 1261 :             argv[i] = argv[i - 1];

  00290	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00294	ff c8		 dec	 eax
  00296	48 98		 cdqe
  00298	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  0029d	48 8b 54 24 68	 mov	 rdx, QWORD PTR argv$[rsp]
  002a2	48 8b 7c 24 68	 mov	 rdi, QWORD PTR argv$[rsp]
  002a7	48 8b 04 c7	 mov	 rax, QWORD PTR [rdi+rax*8]
  002ab	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  002af	eb ce		 jmp	 SHORT $LN5@ParseArgs
$LN6@ParseArgs:

; 1262 : 
; 1263 :         argc++;

  002b1	8b 84 24 50 21
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  002b8	ff c0		 inc	 eax
  002ba	89 84 24 50 21
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 1264 :         argv[0] = pDEVBLK->typname;

  002c1	b8 08 00 00 00	 mov	 eax, 8
  002c6	48 6b c0 00	 imul	 rax, rax, 0
  002ca	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  002cf	48 8b 94 24 40
	21 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  002d7	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  002db	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
$LN18@ParseArgs:
$LN8@ParseArgs:

; 1265 :     }
; 1266 : 
; 1267 :     // Parse any optional arguments if not old format
; 1268 :     while( !pCTCBLK->fOldFormat )

  002df	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  002e7	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  002ed	d1 e8		 shr	 eax, 1
  002ef	83 e0 01	 and	 eax, 1
  002f2	85 c0		 test	 eax, eax
  002f4	0f 85 05 08 00
	00		 jne	 $LN9@ParseArgs

; 1269 :     {
; 1270 :         int     c;
; 1271 : 
; 1272 : #if defined( OPTION_W32_CTCI )
; 1273 :   #define  CTCI_OPTSTRING  "n:k:i:m:t:s:d"
; 1274 : #else
; 1275 :   #define  CTCI_OPTSTRING  "n:x:t:s:d"
; 1276 : #endif
; 1277 : 
; 1278 : #if defined(HAVE_GETOPT_LONG)
; 1279 :         int     iOpt;
; 1280 : 
; 1281 :         static struct option options[] =
; 1282 :         {
; 1283 :             { "dev",     required_argument, NULL, 'n' },
; 1284 : #if !defined( OPTION_W32_CTCI )
; 1285 :             { "tundev",  required_argument, NULL, 'x' },
; 1286 :             { "if",      required_argument, NULL, 'x' },
; 1287 : #endif
; 1288 : #if defined( OPTION_W32_CTCI )
; 1289 :             { "kbuff",   required_argument, NULL, 'k' },
; 1290 :             { "ibuff",   required_argument, NULL, 'i' },
; 1291 :             { "mac",     required_argument, NULL, 'm' },
; 1292 : #endif
; 1293 :             { "mtu",     required_argument, NULL, 't' },
; 1294 :             { "netmask", required_argument, NULL, 's' },
; 1295 :             { "debug",   no_argument,       NULL, 'd' },
; 1296 :             { NULL,      0,                 NULL,  0  }
; 1297 :         };
; 1298 : 
; 1299 :         c = getopt_long( argc, argv, CTCI_OPTSTRING, options, &iOpt );

  002fa	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR iOpt$2[rsp]
  00302	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00307	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?options@?7??ParseArgs@@9@9
  0030e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169655
  00315	48 8b 54 24 68	 mov	 rdx, QWORD PTR argv$[rsp]
  0031a	8b 8c 24 50 21
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00321	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getopt_long
  00327	89 84 24 88 00
	00 00		 mov	 DWORD PTR c$1[rsp], eax

; 1300 : #else /* defined(HAVE_GETOPT_LONG) */
; 1301 :         c = getopt( argc, argv, CTCI_OPTSTRING );
; 1302 : #endif /* defined(HAVE_GETOPT_LONG) */
; 1303 : 
; 1304 :         if (c == -1)  // No more options found

  0032e	83 bc 24 88 00
	00 00 ff	 cmp	 DWORD PTR c$1[rsp], -1
  00336	75 05		 jne	 SHORT $LN20@ParseArgs

; 1305 :             break;

  00338	e9 c2 07 00 00	 jmp	 $LN9@ParseArgs
$LN20@ParseArgs:

; 1306 : 
; 1307 :         switch (c)

  0033d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR c$1[rsp]
  00344	89 44 24 7c	 mov	 DWORD PTR tv181[rsp], eax
  00348	8b 44 24 7c	 mov	 eax, DWORD PTR tv181[rsp]
  0034c	83 e8 64	 sub	 eax, 100		; 00000064H
  0034f	89 44 24 7c	 mov	 DWORD PTR tv181[rsp], eax
  00353	83 7c 24 7c 10	 cmp	 DWORD PTR tv181[rsp], 16
  00358	0f 87 9c 07 00
	00		 ja	 $LN40@ParseArgs
  0035e	48 63 44 24 7c	 movsxd	 rax, DWORD PTR tv181[rsp]
  00363	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0036a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN61@ParseArgs[rcx+rax*4]
  00371	48 03 c1	 add	 rax, rcx
  00374	ff e0		 jmp	 rax
$LN21@ParseArgs:

; 1308 :         {
; 1309 :         case 'n':     // Network Device (special character device)
; 1310 : 
; 1311 : #if defined( OPTION_W32_CTCI )
; 1312 : 
; 1313 :             // This could be the IP or MAC address of the
; 1314 :             // host ethernet adapter.
; 1315 :             if (!inet_aton( optarg, &addr ))

  00376	48 8d 54 24 78	 lea	 rdx, QWORD PTR addr$[rsp]
  0037b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00382	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00385	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton
  0038b	85 c0		 test	 eax, eax
  0038d	0f 85 d5 00 00
	00		 jne	 $LN22@ParseArgs

; 1316 :             {
; 1317 :                 // Not an IP address, check for valid MAC
; 1318 :                 if (ParseMAC( optarg, mac ) != 0)

  00393	48 8d 94 24 20
	21 00 00	 lea	 rdx, QWORD PTR mac$[rsp]
  0039b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  003a2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003a5	e8 00 00 00 00	 call	 ParseMAC
  003aa	85 c0		 test	 eax, eax
  003ac	0f 84 b6 00 00
	00		 je	 $LN23@ParseArgs

; 1319 :                 {
; 1320 :                     // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1321 :                     WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  003b2	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003ba	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003be	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv194[rsp], eax
  003c5	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003cd	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  003d1	d1 f9		 sar	 ecx, 1
  003d3	89 8c 24 98 00
	00 00		 mov	 DWORD PTR tv198[rsp], ecx
  003da	b9 01 00 00 00	 mov	 ecx, 1
  003df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003e5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  003ec	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003ef	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  003f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169660
  003fb	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00400	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169661
  00407	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0040c	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv194[rsp]
  00413	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00417	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv198[rsp]
  0041e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00422	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169662
  00429	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0042e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169663
  00435	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0043a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0043f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00445	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169664
  0044c	ba 2a 05 00 00	 mov	 edx, 1322		; 0000052aH
  00451	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169665
  00458	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1322 :                         pDEVBLK->devnum, "CTCI", "adapter address", optarg );
; 1323 :                     return -1;

  0045e	b8 ff ff ff ff	 mov	 eax, -1
  00463	e9 98 0f 00 00	 jmp	 $LN1@ParseArgs
$LN23@ParseArgs:
$LN22@ParseArgs:

; 1324 :                 }
; 1325 :             }
; 1326 : 
; 1327 : #endif // defined( OPTION_W32_CTCI )
; 1328 : 
; 1329 :             // This is the file name of the special TUN/TAP character device
; 1330 :             if (strlen( optarg ) > sizeof( pCTCBLK->szTUNCharDevName ) - 1)

  00468	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  0046f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00472	e8 00 00 00 00	 call	 strlen
  00477	48 3d ff 00 00
	00		 cmp	 rax, 255		; 000000ffH
  0047d	0f 86 b6 00 00
	00		 jbe	 $LN24@ParseArgs

; 1331 :             {
; 1332 :                 // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1333 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  00483	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0048b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0048f	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv216[rsp], eax
  00496	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0049e	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  004a2	d1 f9		 sar	 ecx, 1
  004a4	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR tv220[rsp], ecx
  004ab	b9 01 00 00 00	 mov	 ecx, 1
  004b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  004bd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  004c0	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  004c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169667
  004cc	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  004d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169668
  004d8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  004dd	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv216[rsp]
  004e4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004e8	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv220[rsp]
  004ef	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169669
  004fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169670
  00506	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0050b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00510	41 b9 03 00 00
	00		 mov	 r9d, 3
  00516	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169671
  0051d	ba 36 05 00 00	 mov	 edx, 1334		; 00000536H
  00522	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169672
  00529	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1334 :                     pDEVBLK->devnum, "CTCI", "device name", optarg );
; 1335 :                 return -1;

  0052f	b8 ff ff ff ff	 mov	 eax, -1
  00534	e9 c7 0e 00 00	 jmp	 $LN1@ParseArgs
$LN24@ParseArgs:

; 1336 :             }
; 1337 : 
; 1338 :             STRLCPY( pCTCBLK->szTUNCharDevName, optarg );

  00539	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00541	48 05 c6 50 00
	00		 add	 rax, 20678		; 000050c6H
  00547	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0054d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00554	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00557	48 8b c8	 mov	 rcx, rax
  0055a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1339 :             break;

  00560	e9 95 05 00 00	 jmp	 $LN10@ParseArgs
$LN25@ParseArgs:

; 1340 : 
; 1341 : #if !defined( OPTION_W32_CTCI )
; 1342 : 
; 1343 :         case 'x':     // TUN network interface name
; 1344 : 
; 1345 :             if (strlen( optarg ) > sizeof( pCTCBLK->szTUNIfName )-1)
; 1346 :             {
; 1347 :                 // HHC00916 "%1d:%04X %s: option '%s' value '%s' invalid"
; 1348 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),
; 1349 :                     pDEVBLK->devnum, "CTCI", "TUN device name", optarg );
; 1350 :                 return -1;
; 1351 :             }
; 1352 : 
; 1353 :             STRLCPY( pCTCBLK->szTUNIfName, optarg );
; 1354 :             saw_if = 1;
; 1355 :             break;
; 1356 : #endif
; 1357 : 
; 1358 : #if defined( OPTION_W32_CTCI )
; 1359 : 
; 1360 :         case 'k':     // Kernel Buffer Size (Windows only)
; 1361 : 
; 1362 :             iKernBuff = atoi( optarg );

  00565	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  0056c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0056f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00575	89 44 24 70	 mov	 DWORD PTR iKernBuff$[rsp], eax

; 1363 : 
; 1364 :             if (iKernBuff * 1024 < MIN_CAPTURE_BUFFSIZE    ||

  00579	69 44 24 70 00
	04 00 00	 imul	 eax, DWORD PTR iKernBuff$[rsp], 1024 ; 00000400H
  00581	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  00586	7c 13		 jl	 SHORT $LN27@ParseArgs
  00588	69 44 24 70 00
	04 00 00	 imul	 eax, DWORD PTR iKernBuff$[rsp], 1024 ; 00000400H
  00590	3d 00 00 00 01	 cmp	 eax, 16777216		; 01000000H
  00595	0f 8e b6 00 00
	00		 jle	 $LN26@ParseArgs
$LN27@ParseArgs:

; 1365 :                 iKernBuff * 1024 > MAX_CAPTURE_BUFFSIZE)
; 1366 :             {
; 1367 :                 // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1368 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  0059b	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005a3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005a7	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv245[rsp], eax
  005ae	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  005b6	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  005ba	d1 f9		 sar	 ecx, 1
  005bc	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv249[rsp], ecx
  005c3	b9 01 00 00 00	 mov	 ecx, 1
  005c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  005d5	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  005d8	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  005dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169676
  005e4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169677
  005f0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005f5	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv245[rsp]
  005fc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00600	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv249[rsp]
  00607	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0060b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169678
  00612	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00617	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169679
  0061e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00623	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00628	41 b9 03 00 00
	00		 mov	 r9d, 3
  0062e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169680
  00635	ba 59 05 00 00	 mov	 edx, 1369		; 00000559H
  0063a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169681
  00641	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1369 :                     pDEVBLK->devnum, "CTCI", "kernel buffer size", optarg );
; 1370 :                 return -1;

  00647	b8 ff ff ff ff	 mov	 eax, -1
  0064c	e9 af 0d 00 00	 jmp	 $LN1@ParseArgs
$LN26@ParseArgs:

; 1371 :             }
; 1372 : 
; 1373 :             pCTCBLK->iKernBuff = iKernBuff * 1024;

  00651	69 44 24 70 00
	04 00 00	 imul	 eax, DWORD PTR iKernBuff$[rsp], 1024 ; 00000400H
  00659	48 8b 8c 24 48
	21 00 00	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  00661	89 81 3e 50 00
	00		 mov	 DWORD PTR [rcx+20542], eax

; 1374 :             break;

  00667	e9 8e 04 00 00	 jmp	 $LN10@ParseArgs
$LN28@ParseArgs:

; 1375 : 
; 1376 :         case 'i':     // I/O Buffer Size (Windows only)
; 1377 : 
; 1378 :             iIOBuff = atoi( optarg );

  0066c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00673	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00676	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0067c	89 44 24 74	 mov	 DWORD PTR iIOBuff$[rsp], eax

; 1379 : 
; 1380 :             if (iIOBuff * 1024 < MIN_PACKET_BUFFSIZE    ||

  00680	69 44 24 74 00
	04 00 00	 imul	 eax, DWORD PTR iIOBuff$[rsp], 1024 ; 00000400H
  00688	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0068d	7c 13		 jl	 SHORT $LN30@ParseArgs
  0068f	69 44 24 74 00
	04 00 00	 imul	 eax, DWORD PTR iIOBuff$[rsp], 1024 ; 00000400H
  00697	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  0069c	0f 8e b6 00 00
	00		 jle	 $LN29@ParseArgs
$LN30@ParseArgs:

; 1381 :                 iIOBuff * 1024 > MAX_PACKET_BUFFSIZE)
; 1382 :             {
; 1383 :                 // "%1d:%04X %s: option '%s' value '%s' invalid"
; 1384 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  006a2	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006aa	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006ae	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv272[rsp], eax
  006b5	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006bd	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  006c1	d1 f9		 sar	 ecx, 1
  006c3	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv276[rsp], ecx
  006ca	b9 01 00 00 00	 mov	 ecx, 1
  006cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  006dc	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  006df	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  006e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169685
  006eb	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169686
  006f7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006fc	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv272[rsp]
  00703	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00707	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv276[rsp]
  0070e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00712	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169687
  00719	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0071e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169688
  00725	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0072a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0072f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00735	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169689
  0073c	ba 69 05 00 00	 mov	 edx, 1385		; 00000569H
  00741	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169690
  00748	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1385 :                     pDEVBLK->devnum, "CTCI", "dll i/o buffer size", optarg );
; 1386 :                 return -1;

  0074e	b8 ff ff ff ff	 mov	 eax, -1
  00753	e9 a8 0c 00 00	 jmp	 $LN1@ParseArgs
$LN29@ParseArgs:

; 1387 :             }
; 1388 : 
; 1389 :             pCTCBLK->iIOBuff = iIOBuff * 1024;

  00758	69 44 24 74 00
	04 00 00	 imul	 eax, DWORD PTR iIOBuff$[rsp], 1024 ; 00000400H
  00760	48 8b 8c 24 48
	21 00 00	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  00768	89 81 42 50 00
	00		 mov	 DWORD PTR [rcx+20546], eax

; 1390 :             break;

  0076e	e9 87 03 00 00	 jmp	 $LN10@ParseArgs
$LN31@ParseArgs:

; 1391 : 
; 1392 :         case 'm':
; 1393 : 
; 1394 :             if (0
; 1395 :                 || ParseMAC( optarg, mac ) != 0 // (invalid format)
; 1396 :                 || !(mac[0] & 0x02)             // (locally assigned MAC bit not ON)
; 1397 :                 ||  (mac[0] & 0x01)             // (broadcast bit is ON)

  00773	33 c0		 xor	 eax, eax
  00775	85 c0		 test	 eax, eax
  00777	75 4f		 jne	 SHORT $LN33@ParseArgs
  00779	48 8d 94 24 20
	21 00 00	 lea	 rdx, QWORD PTR mac$[rsp]
  00781	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00788	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0078b	e8 00 00 00 00	 call	 ParseMAC
  00790	85 c0		 test	 eax, eax
  00792	75 34		 jne	 SHORT $LN33@ParseArgs
  00794	b8 01 00 00 00	 mov	 eax, 1
  00799	48 6b c0 00	 imul	 rax, rax, 0
  0079d	0f b6 84 04 20
	21 00 00	 movzx	 eax, BYTE PTR mac$[rsp+rax]
  007a5	83 e0 02	 and	 eax, 2
  007a8	85 c0		 test	 eax, eax
  007aa	74 1c		 je	 SHORT $LN33@ParseArgs
  007ac	b8 01 00 00 00	 mov	 eax, 1
  007b1	48 6b c0 00	 imul	 rax, rax, 0
  007b5	0f b6 84 04 20
	21 00 00	 movzx	 eax, BYTE PTR mac$[rsp+rax]
  007bd	83 e0 01	 and	 eax, 1
  007c0	85 c0		 test	 eax, eax
  007c2	0f 84 b6 00 00
	00		 je	 $LN32@ParseArgs
$LN33@ParseArgs:

; 1398 :             )
; 1399 :             {
; 1400 :                 // "%1d:%04X %s: Option %s value %s invalid"
; 1401 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  007c8	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  007d0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  007d4	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv340[rsp], eax
  007db	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  007e3	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  007e7	d1 f9		 sar	 ecx, 1
  007e9	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv344[rsp], ecx
  007f0	b9 01 00 00 00	 mov	 ecx, 1
  007f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00802	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00805	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0080a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169694
  00811	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00816	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169695
  0081d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00822	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv340[rsp]
  00829	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0082d	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv344[rsp]
  00834	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00838	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169696
  0083f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00844	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169697
  0084b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00850	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00855	41 b9 03 00 00
	00		 mov	 r9d, 3
  0085b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169698
  00862	ba 7a 05 00 00	 mov	 edx, 1402		; 0000057aH
  00867	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169699
  0086e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1402 :                     pDEVBLK->devnum, "CTCI", "MAC address", optarg );
; 1403 :                 return -1;

  00874	b8 ff ff ff ff	 mov	 eax, -1
  00879	e9 82 0b 00 00	 jmp	 $LN1@ParseArgs
$LN32@ParseArgs:

; 1404 :             }
; 1405 : 
; 1406 :             STRLCPY( pCTCBLK->szMACAddress, optarg );

  0087e	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00886	48 05 d6 51 00
	00		 add	 rax, 20950		; 000051d6H
  0088c	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00892	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00899	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0089c	48 8b c8	 mov	 rcx, rax
  0089f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1407 :             saw_conf = 1;

  008a5	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR saw_conf$[rsp], 1

; 1408 :             break;

  008b0	e9 45 02 00 00	 jmp	 $LN10@ParseArgs
$LN34@ParseArgs:

; 1409 : 
; 1410 : #endif // defined( OPTION_W32_CTCI )
; 1411 : 
; 1412 :         case 't':     // MTU of point-to-point link (ignored if Windows)
; 1413 : 
; 1414 :             iMTU = atoi( optarg );

  008b5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  008bc	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  008bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  008c5	89 84 24 8c 00
	00 00		 mov	 DWORD PTR iMTU$[rsp], eax

; 1415 : 
; 1416 :             if (iMTU < 46 || iMTU > 65536)

  008cc	83 bc 24 8c 00
	00 00 2e	 cmp	 DWORD PTR iMTU$[rsp], 46 ; 0000002eH
  008d4	7c 11		 jl	 SHORT $LN36@ParseArgs
  008d6	81 bc 24 8c 00
	00 00 00 00 01
	00		 cmp	 DWORD PTR iMTU$[rsp], 65536 ; 00010000H
  008e1	0f 8e b6 00 00
	00		 jle	 $LN35@ParseArgs
$LN36@ParseArgs:

; 1417 :             {
; 1418 :                 // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1419 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),\

  008e7	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008ef	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  008f3	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv367[rsp], eax
  008fa	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00902	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00906	d1 f9		 sar	 ecx, 1
  00908	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv371[rsp], ecx
  0090f	b9 01 00 00 00	 mov	 ecx, 1
  00914	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0091a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00921	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00924	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00929	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169703
  00930	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00935	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169704
  0093c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00941	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv367[rsp]
  00948	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0094c	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv371[rsp]
  00953	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00957	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169705
  0095e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00963	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169706
  0096a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0096f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00974	41 b9 03 00 00
	00		 mov	 r9d, 3
  0097a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169707
  00981	ba 8c 05 00 00	 mov	 edx, 1420		; 0000058cH
  00986	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169708
  0098d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1420 :                     pDEVBLK->devnum, "CTCI", "MTU size", optarg );
; 1421 :                 return -1;

  00993	b8 ff ff ff ff	 mov	 eax, -1
  00998	e9 63 0a 00 00	 jmp	 $LN1@ParseArgs
$LN35@ParseArgs:

; 1422 :             }
; 1423 : 
; 1424 :             STRLCPY( pCTCBLK->szMTU, optarg );

  0099d	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  009a5	48 05 a6 50 00
	00		 add	 rax, 20646		; 000050a6H
  009ab	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  009b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  009b8	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  009bb	48 8b c8	 mov	 rcx, rax
  009be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1425 :             saw_conf = 1;

  009c4	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR saw_conf$[rsp], 1

; 1426 :             break;

  009cf	e9 26 01 00 00	 jmp	 $LN10@ParseArgs
$LN37@ParseArgs:

; 1427 : 
; 1428 :         case 's':     // Netmask of point-to-point link
; 1429 : 
; 1430 :             if (!inet_aton( optarg, &addr ))

  009d4	48 8d 54 24 78	 lea	 rdx, QWORD PTR addr$[rsp]
  009d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  009e0	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  009e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton
  009e9	85 c0		 test	 eax, eax
  009eb	0f 85 b6 00 00
	00		 jne	 $LN38@ParseArgs

; 1431 :             {
; 1432 :                 // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1433 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  009f1	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  009f9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  009fd	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv394[rsp], eax
  00a04	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a0c	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00a10	d1 f9		 sar	 ecx, 1
  00a12	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR tv398[rsp], ecx
  00a19	b9 01 00 00 00	 mov	 ecx, 1
  00a1e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a24	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00a2b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00a2e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00a33	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169711
  00a3a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00a3f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169712
  00a46	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a4b	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv394[rsp]
  00a52	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a56	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv398[rsp]
  00a5d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169713
  00a68	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a6d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169714
  00a74	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a79	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a7e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a84	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169715
  00a8b	ba 9a 05 00 00	 mov	 edx, 1434		; 0000059aH
  00a90	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169716
  00a97	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1434 :                     pDEVBLK->devnum, "CTCI", "netmask", optarg );
; 1435 :                 return -1;

  00a9d	b8 ff ff ff ff	 mov	 eax, -1
  00aa2	e9 59 09 00 00	 jmp	 $LN1@ParseArgs
$LN38@ParseArgs:

; 1436 :             }
; 1437 : 
; 1438 :             STRLCPY( pCTCBLK->szNetMask, optarg );

  00aa7	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00aaf	48 05 86 50 00
	00		 add	 rax, 20614		; 00005086H
  00ab5	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00abb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00ac2	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00ac5	48 8b c8	 mov	 rcx, rax
  00ac8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1439 :             saw_conf = 1;

  00ace	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR saw_conf$[rsp], 1

; 1440 :             break;

  00ad9	eb 1f		 jmp	 SHORT $LN10@ParseArgs
$LN39@ParseArgs:

; 1441 : 
; 1442 :         case 'd':     // Diagnostics
; 1443 : 
; 1444 :             pCTCBLK->fDebug = TRUE;

  00adb	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00ae3	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  00ae9	83 c8 01	 or	 eax, 1
  00aec	48 8b 8c 24 48
	21 00 00	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  00af4	89 81 3a 50 00
	00		 mov	 DWORD PTR [rcx+20538], eax
$LN40@ParseArgs:
$LN10@ParseArgs:

; 1445 :             break;
; 1446 : 
; 1447 :         default:
; 1448 :             break;
; 1449 :         }
; 1450 :     }

  00afa	e9 e0 f7 ff ff	 jmp	 $LN8@ParseArgs
$LN9@ParseArgs:

; 1451 : 
; 1452 :     // Shift past any options
; 1453 :     argc -= optind;

  00aff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  00b06	8b 00		 mov	 eax, DWORD PTR [rax]
  00b08	8b 8c 24 50 21
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00b0f	2b c8		 sub	 ecx, eax
  00b11	8b c1		 mov	 eax, ecx
  00b13	89 84 24 50 21
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 1454 :     argv += optind;

  00b1a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  00b21	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00b24	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  00b29	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00b2d	48 89 44 24 68	 mov	 QWORD PTR argv$[rsp], rax

; 1455 : 
; 1456 :     i = 0;

  00b32	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 1457 : 
; 1458 :     if( !pCTCBLK->fOldFormat )

  00b3a	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00b42	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  00b48	d1 e8		 shr	 eax, 1
  00b4a	83 e0 01	 and	 eax, 1
  00b4d	85 c0		 test	 eax, eax
  00b4f	0f 85 f6 02 00
	00		 jne	 $LN41@ParseArgs

; 1459 :     {
; 1460 :         // New format.
; 1461 :         // For *nix, there can be either:-
; 1462 :         // a) Two parameters (a pair of IPv4 addresses). If the -x option
; 1463 :         //    has not been specified, CTCI will use a TUN interface whose
; 1464 :         //    name is allocated by the kernel (e.g. tun0), that is
; 1465 :         //    configured by CTCI. If the -x option has been specified,
; 1466 :         //    CTCI will use a pre-named TUN interface. The TUN interface
; 1467 :         //    may have been created before CTCI was started, or it may be
; 1468 :         //    created by CTCI, but in either case the TUN interface is
; 1469 :         //    configured by CTCI.
; 1470 :         // b) One parameter when the -x option has not been specified.
; 1471 :         //    The single parameter specifies the name of a pre-configured
; 1472 :         //    TUN inferface that CTCI will use.
; 1473 :         // c) Zero parameters when the -x option has been specified. The
; 1474 :         //    The -x option specified the name of a pre-configured TUN
; 1475 :         //    inferface that CTCI will use..
; 1476 :         // For Windows there can be:-
; 1477 :         // a) Two parameters (a pair of IPv4 addresses).
; 1478 :         if (argc == 2 ) /* Not pre-configured, but possibly pre-named */

  00b55	83 bc 24 50 21
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00b5d	0f 85 48 02 00
	00		 jne	 $LN43@ParseArgs

; 1479 :         {
; 1480 :             // Guest IP Address
; 1481 :             if( inet_aton( *argv, &addr ) == 0 )

  00b63	48 8d 54 24 78	 lea	 rdx, QWORD PTR addr$[rsp]
  00b68	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  00b6d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00b70	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton
  00b76	85 c0		 test	 eax, eax
  00b78	0f 85 b4 00 00
	00		 jne	 $LN45@ParseArgs

; 1482 :             {
; 1483 :                 // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1484 :                 WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",

  00b7e	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b86	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b8a	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv435[rsp], eax
  00b91	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00b99	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00b9d	d1 f9		 sar	 ecx, 1
  00b9f	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv439[rsp], ecx
  00ba6	b9 01 00 00 00	 mov	 ecx, 1
  00bab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bb1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  00bb6	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00bb9	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00bbe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169724
  00bc5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00bca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169725
  00bd1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00bd6	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv435[rsp]
  00bdd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00be1	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv439[rsp]
  00be8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00bec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169726
  00bf3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bf8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169727
  00bff	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c04	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c09	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c0f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169728
  00c16	ba cd 05 00 00	 mov	 edx, 1485		; 000005cdH
  00c1b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169729
  00c22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1485 :                       "IP address", *argv );
; 1486 :                 return -1;

  00c28	b8 ff ff ff ff	 mov	 eax, -1
  00c2d	e9 ce 07 00 00	 jmp	 $LN1@ParseArgs
$LN45@ParseArgs:

; 1487 :             }
; 1488 :             STRLCPY( pCTCBLK->szGuestIPAddr, *argv );

  00c32	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00c3a	48 05 46 50 00
	00		 add	 rax, 20550		; 00005046H
  00c40	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00c46	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  00c4b	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00c4e	48 8b c8	 mov	 rcx, rax
  00c51	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1489 :             argc--; argv++;

  00c57	8b 84 24 50 21
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00c5e	ff c8		 dec	 eax
  00c60	89 84 24 50 21
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  00c67	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  00c6c	48 83 c0 08	 add	 rax, 8
  00c70	48 89 44 24 68	 mov	 QWORD PTR argv$[rsp], rax

; 1490 : 
; 1491 :             // Driver IP Address
; 1492 :             if( inet_aton( *argv, &addr ) == 0 )

  00c75	48 8d 54 24 78	 lea	 rdx, QWORD PTR addr$[rsp]
  00c7a	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  00c7f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00c82	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton
  00c88	85 c0		 test	 eax, eax
  00c8a	0f 85 b4 00 00
	00		 jne	 $LN46@ParseArgs

; 1493 :             {
; 1494 :                 // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1495 :                 WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",

  00c90	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c98	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00c9c	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv464[rsp], eax
  00ca3	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00cab	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00caf	d1 f9		 sar	 ecx, 1
  00cb1	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR tv468[rsp], ecx
  00cb8	b9 01 00 00 00	 mov	 ecx, 1
  00cbd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cc3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  00cc8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00ccb	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00cd0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169731
  00cd7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00cdc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169732
  00ce3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00ce8	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv464[rsp]
  00cef	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00cf3	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv468[rsp]
  00cfa	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00cfe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169733
  00d05	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d0a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169734
  00d11	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d16	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d1b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d21	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169735
  00d28	ba d8 05 00 00	 mov	 edx, 1496		; 000005d8H
  00d2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169736
  00d34	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1496 :                       "IP address", *argv );
; 1497 :                 return -1;

  00d3a	b8 ff ff ff ff	 mov	 eax, -1
  00d3f	e9 bc 06 00 00	 jmp	 $LN1@ParseArgs
$LN46@ParseArgs:

; 1498 :             }
; 1499 :             STRLCPY( pCTCBLK->szDriveIPAddr, *argv );

  00d44	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00d4c	48 05 66 50 00
	00		 add	 rax, 20582		; 00005066H
  00d52	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00d58	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  00d5d	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00d60	48 8b c8	 mov	 rcx, rax
  00d63	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1500 :             argc--; argv++;

  00d69	8b 84 24 50 21
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00d70	ff c8		 dec	 eax
  00d72	89 84 24 50 21
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  00d79	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  00d7e	48 83 c0 08	 add	 rax, 8
  00d82	48 89 44 24 68	 mov	 QWORD PTR argv$[rsp], rax

; 1501 : 
; 1502 :             pCTCBLK->fPreconfigured = FALSE;

  00d87	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00d8f	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  00d95	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00d98	48 8b 8c 24 48
	21 00 00	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  00da0	89 81 3a 50 00
	00		 mov	 DWORD PTR [rcx+20538], eax

; 1503 :         }

  00da6	e9 9b 00 00 00	 jmp	 $LN44@ParseArgs
$LN43@ParseArgs:

; 1504 : #if !defined( OPTION_W32_CTCI )
; 1505 :         else if (argc == 1 && !saw_if && !saw_conf) /* Pre-configured using name */
; 1506 :         {
; 1507 :             if( strlen( *argv ) > sizeof(pCTCBLK->szTUNIfName)-1 )
; 1508 :             {
; 1509 :                 // HHC00916 "%1d:%04X %s: option '%s' value '%s' invalid"
; 1510 :                 WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",
; 1511 :                       "TUN device name", optarg );
; 1512 :                 return -1;
; 1513 :             }
; 1514 :             STRLCPY( pCTCBLK->szTUNIfName, *argv );
; 1515 :             argc--; argv++;
; 1516 : 
; 1517 :             pCTCBLK->fPreconfigured = TRUE;
; 1518 :         }
; 1519 :         else if (argc == 0 && saw_if && !saw_conf) /* Pre-configured using -x option */
; 1520 :         {
; 1521 :             pCTCBLK->fPreconfigured = TRUE;
; 1522 :         }
; 1523 : #endif /* !defined( OPTION_W32_CTCI ) */
; 1524 :         else
; 1525 :         {
; 1526 :             // "%1d:%04X CTC: incorrect number of parameters"
; 1527 :             WRMSG(HHC00915, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI");

  00dab	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00db3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00db7	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv522[rsp], eax
  00dbe	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00dc6	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00dca	d1 f9		 sar	 ecx, 1
  00dcc	89 8c 24 e0 00
	00 00		 mov	 DWORD PTR tv526[rsp], ecx
  00dd3	b9 01 00 00 00	 mov	 ecx, 1
  00dd8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00dde	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169737
  00de5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00dea	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv522[rsp]
  00df1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00df5	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv526[rsp]
  00dfc	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e00	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169738
  00e07	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e0c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169739
  00e13	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e18	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e1d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e23	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169740
  00e2a	ba f7 05 00 00	 mov	 edx, 1527		; 000005f7H
  00e2f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169741
  00e36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1528 :             return -1;

  00e3c	b8 ff ff ff ff	 mov	 eax, -1
  00e41	e9 ba 05 00 00	 jmp	 $LN1@ParseArgs
$LN44@ParseArgs:

; 1529 :         }
; 1530 : 
; 1531 : #if defined( __APPLE__ ) || defined( FREEBSD_OR_NETBSD )
; 1532 :         if (TRUE == pCTCBLK->fPreconfigured)
; 1533 :         {
; 1534 :             /* Need  to append the interface number to the character */
; 1535 :             /* device name to open the requested interface.          */
; 1536 : 
; 1537 :             char * s = pCTCBLK->szTUNIfName + strlen(pCTCBLK->szTUNIfName);
; 1538 : 
; 1539 :             while(isdigit(s[- 1])) s--;
; 1540 :             STRLCAT( pCTCBLK->szTUNCharDevName, s );
; 1541 :         }
; 1542 : #endif
; 1543 :     }

  00e46	e9 b3 05 00 00	 jmp	 $LN42@ParseArgs
$LN41@ParseArgs:
$LN60@ParseArgs:
$LN59@ParseArgs:
$LN12@ParseArgs:

; 1544 :     else // if( pCTCBLK->fOldFormat )
; 1545 :     {
; 1546 : #if !defined( OPTION_W32_CTCI )
; 1547 :         // All arguments are non-optional in linux old-format
; 1548 :         // Old format has 5 and only 5 arguments
; 1549 :         if( argc != 5 )
; 1550 :         {
; 1551 :             // "%1d:%04X CTC: incorrect number of parameters"
; 1552 :             WRMSG(HHC00915, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI");
; 1553 :             return -1;
; 1554 :         }
; 1555 : 
; 1556 :         // TUN/TAP Device
; 1557 :         if( **argv != '/' ||
; 1558 :             strlen( *argv ) > sizeof( pCTCBLK->szTUNCharDevName ) - 1 )
; 1559 :         {
; 1560 :             // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1561 :             WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",
; 1562 :                   "device name", *argv );
; 1563 :             return -1;
; 1564 :         }
; 1565 : 
; 1566 :         STRLCPY( pCTCBLK->szTUNCharDevName, *argv );
; 1567 : 
; 1568 :         argc--; argv++;
; 1569 : 
; 1570 :         // MTU Size
; 1571 :         iMTU = atoi( *argv );
; 1572 : 
; 1573 :         if( iMTU < 46 || iMTU > 65536 )
; 1574 :         {
; 1575 :             // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1576 :             WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",
; 1577 :                   "MTU size", *argv );
; 1578 :             return -1;
; 1579 :         }
; 1580 : 
; 1581 :         STRLCPY( pCTCBLK->szMTU, *argv );
; 1582 :         argc--; argv++;
; 1583 : 
; 1584 :         // Guest IP Address
; 1585 :         if( inet_aton( *argv, &addr ) == 0 )
; 1586 :         {
; 1587 :             // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1588 :             WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",
; 1589 :                   "IP address", *argv );
; 1590 :             return -1;
; 1591 :         }
; 1592 : 
; 1593 :         STRLCPY( pCTCBLK->szGuestIPAddr, *argv );
; 1594 : 
; 1595 :         argc--; argv++;
; 1596 : 
; 1597 :         // Driver IP Address
; 1598 :         if( inet_aton( *argv, &addr ) == 0 )
; 1599 :         {
; 1600 :             // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1601 :             WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",
; 1602 :                   "IP address", *argv );
; 1603 :             return -1;
; 1604 :         }
; 1605 : 
; 1606 :         STRLCPY( pCTCBLK->szDriveIPAddr, *argv );
; 1607 : 
; 1608 :         argc--; argv++;
; 1609 : 
; 1610 :         // Netmask
; 1611 :         if( inet_aton( *argv, &addr ) == 0 )
; 1612 :         {
; 1613 :             // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1614 :             WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",
; 1615 :                   "netmask", *argv );
; 1616 :             return -1;
; 1617 :         }
; 1618 : 
; 1619 :         STRLCPY( pCTCBLK->szNetMask, *argv );
; 1620 : 
; 1621 :         argc--; argv++;
; 1622 : 
; 1623 :         if( argc > 0 )
; 1624 :         {
; 1625 :             // "%1d:%04X CTC: incorrect number of parameters"
; 1626 :             WRMSG(HHC00915, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI");
; 1627 :             return -1;
; 1628 :         }
; 1629 : 
; 1630 : #else // defined( OPTION_W32_CTCI )
; 1631 : 
; 1632 :         // There are 2 non-optional arguments in the Windows old-format:
; 1633 :         //   Guest IP address and Gateway address.
; 1634 :         // There are also 2 additional optional arguments:
; 1635 :         //   Kernel buffer size and I/O buffer size.
; 1636 : 
; 1637 :         while (argc > 0)

  00e4b	83 bc 24 50 21
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  00e53	0f 8e a5 05 00
	00		 jle	 $LN13@ParseArgs

; 1638 :         {
; 1639 :             switch (i)

  00e59	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00e5d	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv538[rsp], eax
  00e64	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tv538[rsp], 0
  00e6c	74 21		 je	 SHORT $LN47@ParseArgs
  00e6e	83 bc 24 84 00
	00 00 01	 cmp	 DWORD PTR tv538[rsp], 1
  00e76	0f 84 8f 02 00
	00		 je	 $LN51@ParseArgs
  00e7c	83 bc 24 84 00
	00 00 02	 cmp	 DWORD PTR tv538[rsp], 2
  00e84	0f 84 ac 03 00
	00		 je	 $LN54@ParseArgs
  00e8a	e9 d2 04 00 00	 jmp	 $LN57@ParseArgs
$LN47@ParseArgs:

; 1640 :             {
; 1641 :             // Non-optional arguments
; 1642 :             case 0:
; 1643 : 
; 1644 :                 // Guest IP Address
; 1645 :                 if( inet_aton( *argv, &addr ) == 0 )

  00e8f	48 8d 54 24 78	 lea	 rdx, QWORD PTR addr$[rsp]
  00e94	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  00e99	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00e9c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton
  00ea2	85 c0		 test	 eax, eax
  00ea4	0f 85 b4 00 00
	00		 jne	 $LN48@ParseArgs

; 1646 :                 {
; 1647 :                     // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1648 :                     WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",

  00eaa	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00eb2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00eb6	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv547[rsp], eax
  00ebd	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00ec5	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00ec9	d1 f9		 sar	 ecx, 1
  00ecb	89 8c 24 e8 00
	00 00		 mov	 DWORD PTR tv551[rsp], ecx
  00ed2	b9 01 00 00 00	 mov	 ecx, 1
  00ed7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00edd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  00ee2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00ee5	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00eea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169744
  00ef1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00ef6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169745
  00efd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00f02	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv547[rsp]
  00f09	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00f0d	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv551[rsp]
  00f14	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00f18	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169746
  00f1f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f24	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169747
  00f2b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f30	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f35	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f3b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169748
  00f42	ba 71 06 00 00	 mov	 edx, 1649		; 00000671H
  00f47	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169749
  00f4e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1649 :                           "IP address", *argv );
; 1650 :                     return -1;

  00f54	b8 ff ff ff ff	 mov	 eax, -1
  00f59	e9 a2 04 00 00	 jmp	 $LN1@ParseArgs
$LN48@ParseArgs:

; 1651 :                 }
; 1652 : 
; 1653 :                 STRLCPY( pCTCBLK->szGuestIPAddr, *argv );

  00f5e	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00f66	48 05 46 50 00
	00		 add	 rax, 20550		; 00005046H
  00f6c	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00f72	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  00f77	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00f7a	48 8b c8	 mov	 rcx, rax
  00f7d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1654 : 
; 1655 :                 argc--; argv++;

  00f83	8b 84 24 50 21
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00f8a	ff c8		 dec	 eax
  00f8c	89 84 24 50 21
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  00f93	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  00f98	48 83 c0 08	 add	 rax, 8
  00f9c	48 89 44 24 68	 mov	 QWORD PTR argv$[rsp], rax

; 1656 : 
; 1657 :                 // Destination (Gateway) Address
; 1658 :                 if( inet_aton( *argv, &addr ) == 0 )

  00fa1	48 8d 54 24 78	 lea	 rdx, QWORD PTR addr$[rsp]
  00fa6	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  00fab	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00fae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton
  00fb4	85 c0		 test	 eax, eax
  00fb6	0f 85 d1 00 00
	00		 jne	 $LN49@ParseArgs

; 1659 :                 {
; 1660 :                     // Not an IP address, check for valid MAC
; 1661 :                     if( ParseMAC( *argv, mac ) != 0 )

  00fbc	48 8d 94 24 20
	21 00 00	 lea	 rdx, QWORD PTR mac$[rsp]
  00fc4	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  00fc9	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00fcc	e8 00 00 00 00	 call	 ParseMAC
  00fd1	85 c0		 test	 eax, eax
  00fd3	0f 84 b4 00 00
	00		 je	 $LN50@ParseArgs

; 1662 :                     {
; 1663 :                         // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1664 :                         WRMSG(HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",

  00fd9	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00fe1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00fe5	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv580[rsp], eax
  00fec	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00ff4	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00ff8	d1 f9		 sar	 ecx, 1
  00ffa	89 8c 24 f0 00
	00 00		 mov	 DWORD PTR tv584[rsp], ecx
  01001	b9 01 00 00 00	 mov	 ecx, 1
  01006	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0100c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  01011	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  01014	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169752
  01020	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169753
  0102c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01031	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv580[rsp]
  01038	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0103c	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv584[rsp]
  01043	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169754
  0104e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169755
  0105a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0105f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01064	41 b9 03 00 00
	00		 mov	 r9d, 3
  0106a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169756
  01071	ba 81 06 00 00	 mov	 edx, 1665		; 00000681H
  01076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169757
  0107d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1665 :                               "MAC address", *argv );
; 1666 :                         return -1;

  01083	b8 ff ff ff ff	 mov	 eax, -1
  01088	e9 73 03 00 00	 jmp	 $LN1@ParseArgs
$LN50@ParseArgs:
$LN49@ParseArgs:

; 1667 :                     }
; 1668 :                 }
; 1669 : 
; 1670 :                 STRLCPY( pCTCBLK->szTUNCharDevName, *argv );

  0108d	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  01095	48 05 c6 50 00
	00		 add	 rax, 20678		; 000050c6H
  0109b	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  010a1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  010a6	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  010a9	48 8b c8	 mov	 rcx, rax
  010ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1671 : 
; 1672 :                 // Kludge: This may look strange at first, but with
; 1673 :                 // TunTap32, only the last 3 bytes of the "driver IP
; 1674 :                 // address" is actually used. It's purpose is to
; 1675 :                 // generate a unique MAC for the virtual interface.
; 1676 :                 // Thus, having the same address for the adapter and
; 1677 :                 // destination is not an issue. This used to be
; 1678 :                 // generated from the guest IP address, I screwed up
; 1679 :                 // TunTap32 V2. (JAP)
; 1680 :                 // This also fixes the confusing error messages from
; 1681 :                 // TunTap.c when a MAC is given for this argument.
; 1682 : 
; 1683 :                 STRLCPY( pCTCBLK->szDriveIPAddr, pCTCBLK->szGuestIPAddr );

  010b2	48 8b 84 24 48
	21 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  010ba	48 05 46 50 00
	00		 add	 rax, 20550		; 00005046H
  010c0	48 8b 8c 24 48
	21 00 00	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  010c8	48 81 c1 66 50
	00 00		 add	 rcx, 20582		; 00005066H
  010cf	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  010d5	48 8b d0	 mov	 rdx, rax
  010d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1684 :                 argc--; argv++; i++;

  010de	8b 84 24 50 21
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  010e5	ff c8		 dec	 eax
  010e7	89 84 24 50 21
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  010ee	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  010f3	48 83 c0 08	 add	 rax, 8
  010f7	48 89 44 24 68	 mov	 QWORD PTR argv$[rsp], rax
  010fc	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01100	ff c0		 inc	 eax
  01102	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax

; 1685 :                 continue;

  01106	e9 40 fd ff ff	 jmp	 $LN12@ParseArgs
$LN51@ParseArgs:

; 1686 : 
; 1687 :             // Optional arguments from here on:
; 1688 : 
; 1689 :             case 1: // Kernel Buffer Size
; 1690 : 
; 1691 :                 iKernBuff = atoi( *argv );

  0110b	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  01110	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  01113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  01119	89 44 24 70	 mov	 DWORD PTR iKernBuff$[rsp], eax

; 1692 : 
; 1693 :                 if (iKernBuff * 1024 < MIN_CAPTURE_BUFFSIZE ||

  0111d	69 44 24 70 00
	04 00 00	 imul	 eax, DWORD PTR iKernBuff$[rsp], 1024 ; 00000400H
  01125	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  0112a	7c 13		 jl	 SHORT $LN53@ParseArgs
  0112c	69 44 24 70 00
	04 00 00	 imul	 eax, DWORD PTR iKernBuff$[rsp], 1024 ; 00000400H
  01134	3d 00 00 00 01	 cmp	 eax, 16777216		; 01000000H
  01139	0f 8e b4 00 00
	00		 jle	 $LN52@ParseArgs
$LN53@ParseArgs:

; 1694 :                     iKernBuff * 1024 > MAX_CAPTURE_BUFFSIZE)
; 1695 :                 {
; 1696 :                     // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1697 :                     WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  0113f	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01147	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0114b	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv617[rsp], eax
  01152	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0115a	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0115e	d1 f9		 sar	 ecx, 1
  01160	89 8c 24 f8 00
	00 00		 mov	 DWORD PTR tv621[rsp], ecx
  01167	b9 01 00 00 00	 mov	 ecx, 1
  0116c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01172	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  01177	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0117a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0117f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169761
  01186	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0118b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169762
  01192	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01197	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv617[rsp]
  0119e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  011a2	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv621[rsp]
  011a9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  011ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169763
  011b4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  011b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169764
  011c0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  011c5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011ca	41 b9 03 00 00
	00		 mov	 r9d, 3
  011d0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169765
  011d7	ba a2 06 00 00	 mov	 edx, 1698		; 000006a2H
  011dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169766
  011e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1698 :                         pDEVBLK->devnum, "CTCI", "kernel buffer size", *argv );
; 1699 :                     return -1;

  011e9	b8 ff ff ff ff	 mov	 eax, -1
  011ee	e9 0d 02 00 00	 jmp	 $LN1@ParseArgs
$LN52@ParseArgs:

; 1700 :                 }
; 1701 : 
; 1702 :                 pCTCBLK->iKernBuff = iKernBuff * 1024;

  011f3	69 44 24 70 00
	04 00 00	 imul	 eax, DWORD PTR iKernBuff$[rsp], 1024 ; 00000400H
  011fb	48 8b 8c 24 48
	21 00 00	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  01203	89 81 3e 50 00
	00		 mov	 DWORD PTR [rcx+20542], eax

; 1703 :                 argc--; argv++; i++;

  01209	8b 84 24 50 21
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  01210	ff c8		 dec	 eax
  01212	89 84 24 50 21
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  01219	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  0121e	48 83 c0 08	 add	 rax, 8
  01222	48 89 44 24 68	 mov	 QWORD PTR argv$[rsp], rax
  01227	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0122b	ff c0		 inc	 eax
  0122d	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax

; 1704 :                 continue;

  01231	e9 15 fc ff ff	 jmp	 $LN59@ParseArgs
$LN54@ParseArgs:

; 1705 : 
; 1706 :             case 2: // I/O Buffer Size
; 1707 : 
; 1708 :                 iIOBuff = atoi( *argv );

  01236	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  0123b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0123e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  01244	89 44 24 74	 mov	 DWORD PTR iIOBuff$[rsp], eax

; 1709 : 
; 1710 :                 if (iIOBuff * 1024 < MIN_PACKET_BUFFSIZE ||

  01248	69 44 24 74 00
	04 00 00	 imul	 eax, DWORD PTR iIOBuff$[rsp], 1024 ; 00000400H
  01250	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  01255	7c 13		 jl	 SHORT $LN56@ParseArgs
  01257	69 44 24 74 00
	04 00 00	 imul	 eax, DWORD PTR iIOBuff$[rsp], 1024 ; 00000400H
  0125f	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  01264	0f 8e b4 00 00
	00		 jle	 $LN55@ParseArgs
$LN56@ParseArgs:

; 1711 :                     iIOBuff * 1024 > MAX_PACKET_BUFFSIZE)
; 1712 :                 {
; 1713 :                     // "%1d:%04X CTC: option '%s' value '%s' invalid"
; 1714 :                     WRMSG( HHC00916, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  0126a	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01272	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01276	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv647[rsp], eax
  0127d	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01285	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01289	d1 f9		 sar	 ecx, 1
  0128b	89 8c 24 00 01
	00 00		 mov	 DWORD PTR tv651[rsp], ecx
  01292	b9 01 00 00 00	 mov	 ecx, 1
  01297	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0129d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR argv$[rsp]
  012a2	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  012a5	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  012aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169770
  012b1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  012b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169771
  012bd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  012c2	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv647[rsp]
  012c9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  012cd	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv651[rsp]
  012d4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  012d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169772
  012df	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  012e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169773
  012eb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012f5	41 b9 03 00 00
	00		 mov	 r9d, 3
  012fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169774
  01302	ba b3 06 00 00	 mov	 edx, 1715		; 000006b3H
  01307	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169775
  0130e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1715 :                         pDEVBLK->devnum, "CTCI", "dll i/o buffer size", *argv );
; 1716 :                     return -1;

  01314	b8 ff ff ff ff	 mov	 eax, -1
  01319	e9 e2 00 00 00	 jmp	 $LN1@ParseArgs
$LN55@ParseArgs:

; 1717 :                 }
; 1718 : 
; 1719 :                 pCTCBLK->iIOBuff = iIOBuff * 1024;

  0131e	69 44 24 74 00
	04 00 00	 imul	 eax, DWORD PTR iIOBuff$[rsp], 1024 ; 00000400H
  01326	48 8b 8c 24 48
	21 00 00	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  0132e	89 81 42 50 00
	00		 mov	 DWORD PTR [rcx+20546], eax

; 1720 :                 argc--; argv++; i++;

  01334	8b 84 24 50 21
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0133b	ff c8		 dec	 eax
  0133d	89 84 24 50 21
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  01344	48 8b 44 24 68	 mov	 rax, QWORD PTR argv$[rsp]
  01349	48 83 c0 08	 add	 rax, 8
  0134d	48 89 44 24 68	 mov	 QWORD PTR argv$[rsp], rax
  01352	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01356	ff c0		 inc	 eax
  01358	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax

; 1721 :                 continue;

  0135c	e9 ea fa ff ff	 jmp	 $LN60@ParseArgs
$LN57@ParseArgs:

; 1722 : 
; 1723 :             default:
; 1724 : 
; 1725 :                 // "%1d:%04X CTC: incorrect number of parameters"
; 1726 :                 WRMSG( HHC00915, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  01361	48 8b 84 24 40
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01369	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0136d	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv669[rsp], eax
  01374	48 8b 8c 24 40
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0137c	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01380	d1 f9		 sar	 ecx, 1
  01382	89 8c 24 08 01
	00 00		 mov	 DWORD PTR tv705[rsp], ecx
  01389	b9 01 00 00 00	 mov	 ecx, 1
  0138e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01394	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169777
  0139b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  013a0	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv669[rsp]
  013a7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  013ab	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv705[rsp]
  013b2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  013b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169778
  013bd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  013c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169779
  013c9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  013ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  013d3	41 b9 03 00 00
	00		 mov	 r9d, 3
  013d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169780
  013e0	ba bf 06 00 00	 mov	 edx, 1727		; 000006bfH
  013e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169781
  013ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1727 :                     pDEVBLK->devnum, "CTCI" );
; 1728 :                 return -1;

  013f2	b8 ff ff ff ff	 mov	 eax, -1
  013f7	eb 07		 jmp	 SHORT $LN1@ParseArgs

; 1729 :             }
; 1730 :         }

  013f9	e9 4d fa ff ff	 jmp	 $LN12@ParseArgs
$LN13@ParseArgs:
$LN42@ParseArgs:

; 1731 : #endif // !defined( OPTION_W32_CTCI )
; 1732 :     }
; 1733 : 
; 1734 :     return 0;

  013fe	33 c0		 xor	 eax, eax
$LN1@ParseArgs:

; 1735 : }

  01400	48 8b 8c 24 28
	21 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01408	48 33 cc	 xor	 rcx, rsp
  0140b	e8 00 00 00 00	 call	 __security_check_cookie
  01410	48 81 c4 30 21
	00 00		 add	 rsp, 8496		; 00002130H
  01417	5f		 pop	 rdi
  01418	c3		 ret	 0
  01419	0f 1f 00	 npad	 3
$LN61@ParseArgs:
  0141c	00 00 00 00	 DD	 $LN39@ParseArgs
  01420	00 00 00 00	 DD	 $LN40@ParseArgs
  01424	00 00 00 00	 DD	 $LN40@ParseArgs
  01428	00 00 00 00	 DD	 $LN40@ParseArgs
  0142c	00 00 00 00	 DD	 $LN40@ParseArgs
  01430	00 00 00 00	 DD	 $LN28@ParseArgs
  01434	00 00 00 00	 DD	 $LN40@ParseArgs
  01438	00 00 00 00	 DD	 $LN25@ParseArgs
  0143c	00 00 00 00	 DD	 $LN40@ParseArgs
  01440	00 00 00 00	 DD	 $LN31@ParseArgs
  01444	00 00 00 00	 DD	 $LN21@ParseArgs
  01448	00 00 00 00	 DD	 $LN40@ParseArgs
  0144c	00 00 00 00	 DD	 $LN40@ParseArgs
  01450	00 00 00 00	 DD	 $LN40@ParseArgs
  01454	00 00 00 00	 DD	 $LN40@ParseArgs
  01458	00 00 00 00	 DD	 $LN37@ParseArgs
  0145c	00 00 00 00	 DD	 $LN34@ParseArgs
ParseArgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ctci.c
_TEXT	SEGMENT
pCTCBLK$ = 32
pSegment$ = 40
tv129 = 48
pFrame$ = 56
pDEVBLK$ = 96
pData$ = 104
iSize$ = 112
CTCI_EnqueueIPFrame PROC

; 1123 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1124 :     PCTCIHDR pFrame;
; 1125 :     PCTCISEG pSegment;
; 1126 :     PCTCBLK  pCTCBLK = (PCTCBLK)pDEVBLK->dev_data;

  00015	48 8b 44 24 60	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001a	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00021	48 89 44 24 20	 mov	 QWORD PTR pCTCBLK$[rsp], rax

; 1127 : 
; 1128 :     // Will frame NEVER fit into buffer??
; 1129 :     if( iSize > MAX_CTCI_FRAME_SIZE( pCTCBLK ) || iSize > 9000 )

  00026	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0002b	0f b7 40 1c	 movzx	 eax, WORD PTR [rax+28]
  0002f	48 83 e8 0a	 sub	 rax, 10
  00033	48 39 44 24 70	 cmp	 QWORD PTR iSize$[rsp], rax
  00038	77 0b		 ja	 SHORT $LN3@CTCI_Enque
  0003a	48 81 7c 24 70
	28 23 00 00	 cmp	 QWORD PTR iSize$[rsp], 9000 ; 00002328H
  00043	76 16		 jbe	 SHORT $LN2@CTCI_Enque
$LN3@CTCI_Enque:

; 1130 :     {
; 1131 :         errno = EMSGSIZE;   // Message too long

  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004b	c7 00 73 00 00
	00		 mov	 DWORD PTR [rax], 115	; 00000073H

; 1132 :         return -1;          // (-1==failure)

  00051	b8 ff ff ff ff	 mov	 eax, -1
  00056	e9 d9 01 00 00	 jmp	 $LN1@CTCI_Enque
$LN2@CTCI_Enque:

; 1133 :     }
; 1134 : 
; 1135 :     obtain_lock( &pCTCBLK->Lock );

  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00060	48 05 22 50 00
	00		 add	 rax, 20514		; 00005022H
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169581
  0006d	48 8b c8	 mov	 rcx, rax
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1136 : 
; 1137 :     // Ensure we dont overflow the buffer
; 1138 :     if( ( pCTCBLK->iFrameOffset +         // Current buffer Offset
; 1139 :           sizeof( CTCIHDR ) +             // Size of Block Header
; 1140 :           sizeof( CTCISEG ) +             // Size of Segment Header
; 1141 :           iSize +                         // Size of Ethernet packet
; 1142 :           sizeof(pFrame->hwOffset) )      // Size of Block terminator
; 1143 :         > pCTCBLK->iMaxFrameBufferSize )  // Size of Frame buffer

  00076	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0007b	0f b7 80 1e 50
	00 00		 movzx	 eax, WORD PTR [rax+20510]
  00082	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iSize$[rsp]
  00087	48 8d 44 08 0a	 lea	 rax, QWORD PTR [rax+rcx+10]
  0008c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  00091	0f b7 49 1c	 movzx	 ecx, WORD PTR [rcx+28]
  00095	48 3b c1	 cmp	 rax, rcx
  00098	76 31		 jbe	 SHORT $LN4@CTCI_Enque

; 1144 :     {
; 1145 :         release_lock( &pCTCBLK->Lock );

  0009a	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0009f	48 05 22 50 00
	00		 add	 rax, 20514		; 00005022H
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169583
  000ac	48 8b c8	 mov	 rcx, rax
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1146 :         errno = ENOBUFS;    // No buffer space available

  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000bb	c7 00 77 00 00
	00		 mov	 DWORD PTR [rax], 119	; 00000077H

; 1147 :         return -1;          // (-1==failure)

  000c1	b8 ff ff ff ff	 mov	 eax, -1
  000c6	e9 69 01 00 00	 jmp	 $LN1@CTCI_Enque
$LN4@CTCI_Enque:

; 1148 :     }
; 1149 : 
; 1150 :     // Fix-up Frame pointer
; 1151 :     pFrame = (PCTCIHDR)pCTCBLK->bFrameBuffer;

  000cb	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  000d0	48 83 c0 1e	 add	 rax, 30
  000d4	48 89 44 24 38	 mov	 QWORD PTR pFrame$[rsp], rax

; 1152 : 
; 1153 :     // Fix-up Segment pointer
; 1154 :     pSegment = (PCTCISEG)( pCTCBLK->bFrameBuffer +

  000d9	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  000de	0f b7 80 1e 50
	00 00		 movzx	 eax, WORD PTR [rax+20510]
  000e5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  000ea	48 8d 44 01 20	 lea	 rax, QWORD PTR [rcx+rax+32]
  000ef	48 89 44 24 28	 mov	 QWORD PTR pSegment$[rsp], rax

; 1155 :                            sizeof( CTCIHDR ) +
; 1156 :                            pCTCBLK->iFrameOffset );
; 1157 : 
; 1158 :     // Initialize segment
; 1159 :     memset( pSegment, 0, iSize + sizeof( CTCISEG ) );

  000f4	48 8b 44 24 70	 mov	 rax, QWORD PTR iSize$[rsp]
  000f9	48 83 c0 06	 add	 rax, 6
  000fd	48 89 44 24 30	 mov	 QWORD PTR tv129[rsp], rax
  00102	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pSegment$[rsp]
  00107	33 c0		 xor	 eax, eax
  00109	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv129[rsp]
  0010e	f3 aa		 rep stosb

; 1160 : 
; 1161 :     // Increment offset
; 1162 :     pCTCBLK->iFrameOffset += (U16)(sizeof( CTCISEG ) + iSize);

  00110	48 8b 44 24 70	 mov	 rax, QWORD PTR iSize$[rsp]
  00115	48 83 c0 06	 add	 rax, 6
  00119	0f b7 c0	 movzx	 eax, ax
  0011c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  00121	0f b7 89 1e 50
	00 00		 movzx	 ecx, WORD PTR [rcx+20510]
  00128	03 c8		 add	 ecx, eax
  0012a	8b c1		 mov	 eax, ecx
  0012c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  00131	66 89 81 1e 50
	00 00		 mov	 WORD PTR [rcx+20510], ax

; 1163 : 
; 1164 :     // Update next frame offset
; 1165 :     STORE_HW( pFrame->hwOffset,

  00138	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0013d	0f b7 80 1e 50
	00 00		 movzx	 eax, WORD PTR [rax+20510]
  00144	48 83 c0 02	 add	 rax, 2
  00148	0f b7 c8	 movzx	 ecx, ax
  0014b	e8 00 00 00 00	 call	 _byteswap_ushort
  00150	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pFrame$[rsp]
  00155	0f b7 d0	 movzx	 edx, ax
  00158	e8 00 00 00 00	 call	 store_hw_noswap

; 1166 :               pCTCBLK->iFrameOffset + sizeof( CTCIHDR ) );
; 1167 : 
; 1168 :     // Store segment length
; 1169 :     STORE_HW( pSegment->hwLength, (U16)(sizeof( CTCISEG ) + iSize) );

  0015d	48 8b 44 24 70	 mov	 rax, QWORD PTR iSize$[rsp]
  00162	48 83 c0 06	 add	 rax, 6
  00166	0f b7 c8	 movzx	 ecx, ax
  00169	e8 00 00 00 00	 call	 _byteswap_ushort
  0016e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pSegment$[rsp]
  00173	0f b7 d0	 movzx	 edx, ax
  00176	e8 00 00 00 00	 call	 store_hw_noswap

; 1170 : 
; 1171 :     // Store Frame type
; 1172 :     STORE_HW( pSegment->hwType, ETH_TYPE_IP );

  0017b	66 b9 00 08	 mov	 cx, 2048		; 00000800H
  0017f	e8 00 00 00 00	 call	 _byteswap_ushort
  00184	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pSegment$[rsp]
  00189	48 83 c1 02	 add	 rcx, 2
  0018d	0f b7 d0	 movzx	 edx, ax
  00190	e8 00 00 00 00	 call	 store_hw_noswap

; 1173 : 
; 1174 :     // Copy data
; 1175 :     memcpy( pSegment->bData, pData, iSize );

  00195	48 8b 44 24 28	 mov	 rax, QWORD PTR pSegment$[rsp]
  0019a	48 83 c0 06	 add	 rax, 6
  0019e	48 8b f8	 mov	 rdi, rax
  001a1	48 8b 74 24 68	 mov	 rsi, QWORD PTR pData$[rsp]
  001a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iSize$[rsp]
  001ab	f3 a4		 rep movsb

; 1176 : 
; 1177 :     // Mark data pending
; 1178 :     pCTCBLK->fDataPending = 1;

  001ad	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  001b2	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  001b8	83 c8 10	 or	 eax, 16
  001bb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  001c0	89 81 3a 50 00
	00		 mov	 DWORD PTR [rcx+20538], eax

; 1179 : 
; 1180 :     release_lock( &pCTCBLK->Lock );

  001c6	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  001cb	48 05 22 50 00
	00		 add	 rax, 20514		; 00005022H
  001d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169584
  001d8	48 8b c8	 mov	 rcx, rax
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1181 : 
; 1182 :     obtain_lock( &pCTCBLK->EventLock );

  001e1	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  001e6	48 05 2a 50 00
	00		 add	 rax, 20522		; 0000502aH
  001ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169585
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1183 :     signal_condition( &pCTCBLK->Event );

  001fc	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00201	48 05 32 50 00
	00		 add	 rax, 20530		; 00005032H
  00207	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169586
  0020e	48 8b c8	 mov	 rcx, rax
  00211	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 1184 :     release_lock( &pCTCBLK->EventLock );

  00217	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0021c	48 05 2a 50 00
	00		 add	 rax, 20522		; 0000502aH
  00222	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169587
  00229	48 8b c8	 mov	 rcx, rax
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1185 : 
; 1186 :     return 0;       // (0==success)

  00232	33 c0		 xor	 eax, eax
$LN1@CTCI_Enque:

; 1187 : }

  00234	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00238	5f		 pop	 rdi
  00239	5e		 pop	 rsi
  0023a	c3		 ret	 0
CTCI_EnqueueIPFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ctci.c
_TEXT	SEGMENT
pCTCBLK$ = 112
iLength$ = 120
pDEVBLK$ = 128
tv128 = 136
tv132 = 140
tv153 = 144
tv157 = 148
tv193 = 152
tv197 = 156
tv86 = 160
tv90 = 168
tv92 = 176
tv147 = 184
szBuff$ = 192
__$ArrayPad$ = 2240
arg$ = 2272
CTCI_ReadThread PROC

; 1035 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec d8 08
	00 00		 sub	 rsp, 2264		; 000008d8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 c0
	08 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1036 :     PCTCBLK  pCTCBLK = (PCTCBLK) arg;

  0001e	48 8b 84 24 e0
	08 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00026	48 89 44 24 70	 mov	 QWORD PTR pCTCBLK$[rsp], rax

; 1037 :     DEVBLK*  pDEVBLK = pCTCBLK->pDEVBLK[CTC_READ_SUBCHANN];

  0002b	b8 08 00 00 00	 mov	 eax, 8
  00030	48 6b c0 00	 imul	 rax, rax, 0
  00034	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  00039	48 8b 44 01 0c	 mov	 rax, QWORD PTR [rcx+rax+12]
  0003e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 1038 :     int      iLength;
; 1039 :     BYTE     szBuff[2048];
; 1040 : 
; 1041 :     // ZZ FIXME: Try to avoid race condition at startup with hercifc
; 1042 : #if defined(BUILD_HERCIFC)
; 1043 :     SLEEP(10);
; 1044 : #endif
; 1045 : 
; 1046 :     pCTCBLK->pid = getpid();

  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid
  0004c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  00051	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN31@CTCI_ReadT:
$LN2@CTCI_ReadT:

; 1047 : 
; 1048 :     while( pCTCBLK->fd != -1 && !pCTCBLK->fCloseInProgress )

  00054	48 8b 44 24 70	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00059	83 38 ff	 cmp	 DWORD PTR [rax], -1
  0005c	0f 84 f1 03 00
	00		 je	 $LN3@CTCI_ReadT
  00062	48 8b 44 24 70	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00067	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  0006d	c1 e8 05	 shr	 eax, 5
  00070	83 e0 01	 and	 eax, 1
  00073	85 c0		 test	 eax, eax
  00075	0f 85 d8 03 00
	00		 jne	 $LN3@CTCI_ReadT

; 1049 :     {
; 1050 :         // Read frame from the TUN/TAP interface
; 1051 :         iLength = read_tuntap( pCTCBLK->fd, szBuff, sizeof( szBuff ), DEF_NET_READ_TIMEOUT_SECS );

  0007b	41 b9 05 00 00
	00		 mov	 r9d, 5
  00081	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00087	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR szBuff$[rsp]
  0008f	48 8b 44 24 70	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00094	8b 08		 mov	 ecx, DWORD PTR [rax]
  00096	e8 00 00 00 00	 call	 read_tuntap
  0009b	89 44 24 78	 mov	 DWORD PTR iLength$[rsp], eax

; 1052 : 
; 1053 :         // Check for error condition
; 1054 :         if( iLength < 0 )

  0009f	83 7c 24 78 00	 cmp	 DWORD PTR iLength$[rsp], 0
  000a4	0f 8d 12 01 00
	00		 jge	 $LN18@CTCI_ReadT

; 1055 :         {
; 1056 :             if( !pCTCBLK->fCloseInProgress )

  000aa	48 8b 44 24 70	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  000af	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  000b5	c1 e8 05	 shr	 eax, 5
  000b8	83 e0 01	 and	 eax, 1
  000bb	85 c0		 test	 eax, eax
  000bd	0f 85 f4 00 00
	00		 jne	 $LN19@CTCI_ReadT

; 1057 :             {
; 1058 :                 // "%1d:%04X %s: error reading from device %s: %d %s"
; 1059 :                 WRMSG(HHC00912, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",

  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000c9	8b 08		 mov	 ecx, DWORD PTR [rax]
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000d1	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv86[rsp], rax
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000df	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  000e7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  000ec	48 81 c1 c6 51
	00 00		 add	 rcx, 20934		; 000051c6H
  000f3	48 89 8c 24 b0
	00 00 00	 mov	 QWORD PTR tv92[rsp], rcx
  000fb	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00103	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00107	89 94 24 88 00
	00 00		 mov	 DWORD PTR tv128[rsp], edx
  0010e	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  00116	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  0011b	41 d1 f8	 sar	 r8d, 1
  0011e	44 89 84 24 8c
	00 00 00	 mov	 DWORD PTR tv132[rsp], r8d
  00126	b9 01 00 00 00	 mov	 ecx, 1
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00131	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv86[rsp]
  00139	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0013e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv90[rsp]
  00146	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00148	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0014c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv92[rsp]
  00154	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169516
  00160	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00165	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv128[rsp]
  0016c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00170	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv132[rsp]
  00177	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0017b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169517
  00182	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169518
  0018e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00193	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00198	41 b9 03 00 00
	00		 mov	 r9d, 3
  0019e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169519
  001a5	ba 24 04 00 00	 mov	 edx, 1060		; 00000424H
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169520
  001b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN19@CTCI_ReadT:

; 1060 :                                      pCTCBLK->szTUNIfName, errno, strerror( errno ));
; 1061 :             }
; 1062 :             break;

  001b7	e9 97 02 00 00	 jmp	 $LN3@CTCI_ReadT
$LN18@CTCI_ReadT:

; 1063 :         }
; 1064 : 
; 1065 :         if( iLength == 0 )      // (probably EINTR; ignore)

  001bc	83 7c 24 78 00	 cmp	 DWORD PTR iLength$[rsp], 0
  001c1	75 05		 jne	 SHORT $LN20@CTCI_ReadT

; 1066 :             continue;

  001c3	e9 8c fe ff ff	 jmp	 $LN2@CTCI_ReadT
$LN20@CTCI_ReadT:

; 1067 : 
; 1068 :         if( pCTCBLK->fDebug )

  001c8	48 8b 44 24 70	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  001cd	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  001d3	83 e0 01	 and	 eax, 1
  001d6	85 c0		 test	 eax, eax
  001d8	0f 84 fb 00 00
	00		 je	 $LN21@CTCI_ReadT

; 1069 :         {
; 1070 :             // "%1d:%04X %s: receive%s packet of size %d bytes from device %s"
; 1071 :             WRMSG(HHC00913, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",

  001de	48 8b 44 24 70	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  001e3	48 05 c6 51 00
	00		 add	 rax, 20934		; 000051c6H
  001e9	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv147[rsp], rax
  001f1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001f9	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001fd	89 8c 24 90 00
	00 00		 mov	 DWORD PTR tv153[rsp], ecx
  00204	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0020c	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00210	d1 fa		 sar	 edx, 1
  00212	89 94 24 94 00
	00 00		 mov	 DWORD PTR tv157[rsp], edx
  00219	b9 01 00 00 00	 mov	 ecx, 1
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00224	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv147[rsp]
  0022c	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00231	8b 4c 24 78	 mov	 ecx, DWORD PTR iLength$[rsp]
  00235	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00239	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169523
  00240	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00245	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169524
  0024c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00251	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv153[rsp]
  00258	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0025c	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv157[rsp]
  00263	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00267	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169525
  0026e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00273	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169526
  0027a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0027f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00284	41 b9 03 00 00
	00		 mov	 r9d, 3
  0028a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169527
  00291	ba 30 04 00 00	 mov	 edx, 1072		; 00000430H
  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169528
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1072 :                                  "", iLength, pCTCBLK->szTUNIfName );
; 1073 :             net_data_trace( pDEVBLK, szBuff, iLength, '>', 'D', "packet", 0 );

  002a3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  002ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169529
  002b2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002b7	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  002bc	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  002bf	44 8b 44 24 78	 mov	 r8d, DWORD PTR iLength$[rsp]
  002c4	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR szBuff$[rsp]
  002cc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002d4	e8 00 00 00 00	 call	 net_data_trace
$LN21@CTCI_ReadT:
$LN4@CTCI_ReadT:

; 1074 :         }
; 1075 : 
; 1076 :         // Enqueue frame on buffer, if buffer is full, keep trying
; 1077 :         while( CTCI_EnqueueIPFrame( pDEVBLK, szBuff, iLength ) < 0
; 1078 :             && pCTCBLK->fd != -1 && !pCTCBLK->fCloseInProgress )

  002d9	48 63 44 24 78	 movsxd	 rax, DWORD PTR iLength$[rsp]
  002de	4c 8b c0	 mov	 r8, rax
  002e1	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR szBuff$[rsp]
  002e9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002f1	e8 00 00 00 00	 call	 CTCI_EnqueueIPFrame
  002f6	85 c0		 test	 eax, eax
  002f8	0f 8d 50 01 00
	00		 jge	 $LN5@CTCI_ReadT
  002fe	48 8b 44 24 70	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00303	83 38 ff	 cmp	 DWORD PTR [rax], -1
  00306	0f 84 42 01 00
	00		 je	 $LN5@CTCI_ReadT
  0030c	48 8b 44 24 70	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00311	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  00317	c1 e8 05	 shr	 eax, 5
  0031a	83 e0 01	 and	 eax, 1
  0031d	85 c0		 test	 eax, eax
  0031f	0f 85 29 01 00
	00		 jne	 $LN5@CTCI_ReadT

; 1079 :         {
; 1080 :             if( EMSGSIZE == errno )     // (if too large for buffer)

  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0032b	83 38 73	 cmp	 DWORD PTR [rax], 115	; 00000073H
  0032e	0f 85 9d 00 00
	00		 jne	 $LN22@CTCI_ReadT

; 1081 :             {
; 1082 :                 if( pCTCBLK->fDebug )

  00334	48 8b 44 24 70	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00339	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  0033f	83 e0 01	 and	 eax, 1
  00342	85 c0		 test	 eax, eax
  00344	0f 84 85 00 00
	00		 je	 $LN23@CTCI_ReadT

; 1083 :                 {
; 1084 :                     // "%1d:%04X CTC: packet frame too big, dropped"
; 1085 :                     WRMSG(HHC00914, "W", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum );

  0034a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00352	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00356	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv193[rsp], eax
  0035d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00365	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00369	d1 f9		 sar	 ecx, 1
  0036b	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv197[rsp], ecx
  00372	b9 01 00 00 00	 mov	 ecx, 1
  00377	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0037d	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv193[rsp]
  00384	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00388	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv197[rsp]
  0038f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00393	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169532
  0039a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0039f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169533
  003a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b0	41 b9 03 00 00
	00		 mov	 r9d, 3
  003b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169534
  003bd	ba 3d 04 00 00	 mov	 edx, 1085		; 0000043dH
  003c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169535
  003c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@CTCI_ReadT:

; 1086 :                 }
; 1087 :                 break;                  // (discard it...)

  003cf	eb 7d		 jmp	 SHORT $LN5@CTCI_ReadT
$LN22@CTCI_ReadT:
$LN8@CTCI_ReadT:

; 1088 :             }
; 1089 : 
; 1090 :             ASSERT( ENOBUFS == errno );

  003d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003d7	83 38 77	 cmp	 DWORD PTR [rax], 119	; 00000077H
  003da	74 5c		 je	 SHORT $LN24@CTCI_ReadT
$LN11@CTCI_ReadT:
  003dc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169537
  003e3	41 b8 42 04 00
	00		 mov	 r8d, 1090		; 00000442H
  003e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169538
  003f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169539
  003f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  003fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00403	85 c0		 test	 eax, eax
  00405	74 20		 je	 SHORT $LN25@CTCI_ReadT
  00407	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169541
  0040e	41 b8 42 04 00
	00		 mov	 r8d, 1090		; 00000442H
  00414	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169542
  0041b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169543
  00422	e8 00 00 00 00	 call	 DebuggerTrace
$LN25@CTCI_ReadT:
  00427	33 c0		 xor	 eax, eax
  00429	85 c0		 test	 eax, eax
  0042b	75 af		 jne	 SHORT $LN11@CTCI_ReadT
  0042d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00433	85 c0		 test	 eax, eax
  00435	74 01		 je	 SHORT $LN26@CTCI_ReadT
  00437	cc		 int	 3
$LN26@CTCI_ReadT:
$LN24@CTCI_ReadT:
  00438	33 c0		 xor	 eax, eax
  0043a	85 c0		 test	 eax, eax
  0043c	75 93		 jne	 SHORT $LN8@CTCI_ReadT

; 1091 : 
; 1092 :             // Don't use sched_yield() here; use an actual non-dispatchable
; 1093 :             // delay instead so as to allow another [possibly lower priority]
; 1094 :             // thread to 'read' (remove) some packet(s) from our frame buffer.
; 1095 :             usleep( CTC_DELAY_USECS );  // (wait a bit before retrying...)

  0043e	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00443	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 1096 :         }

  00449	e9 8b fe ff ff	 jmp	 $LN4@CTCI_ReadT
$LN5@CTCI_ReadT:

; 1097 :     }

  0044e	e9 01 fc ff ff	 jmp	 $LN31@CTCI_ReadT
$LN3@CTCI_ReadT:
$LN14@CTCI_ReadT:

; 1098 : 
; 1099 :     // We must do the close since we were the one doing the i/o...
; 1100 : 
; 1101 :     VERIFY( pCTCBLK->fd == -1 || TUNTAP_Close( pCTCBLK->fd ) == 0 );

  00453	48 8b 44 24 70	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00458	83 38 ff	 cmp	 DWORD PTR [rax], -1
  0045b	74 6c		 je	 SHORT $LN27@CTCI_ReadT
  0045d	48 8b 44 24 70	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00462	8b 08		 mov	 ecx, DWORD PTR [rax]
  00464	e8 00 00 00 00	 call	 tt32_close
  00469	85 c0		 test	 eax, eax
  0046b	74 5c		 je	 SHORT $LN27@CTCI_ReadT
$LN17@CTCI_ReadT:
  0046d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169546
  00474	41 b8 4d 04 00
	00		 mov	 r8d, 1101		; 0000044dH
  0047a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169547
  00481	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169548
  00488	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0048e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00494	85 c0		 test	 eax, eax
  00496	74 20		 je	 SHORT $LN28@CTCI_ReadT
  00498	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169550
  0049f	41 b8 4d 04 00
	00		 mov	 r8d, 1101		; 0000044dH
  004a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169551
  004ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169552
  004b3	e8 00 00 00 00	 call	 DebuggerTrace
$LN28@CTCI_ReadT:
  004b8	33 c0		 xor	 eax, eax
  004ba	85 c0		 test	 eax, eax
  004bc	75 af		 jne	 SHORT $LN17@CTCI_ReadT
  004be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004c4	85 c0		 test	 eax, eax
  004c6	74 01		 je	 SHORT $LN29@CTCI_ReadT
  004c8	cc		 int	 3
$LN29@CTCI_ReadT:
$LN27@CTCI_ReadT:
  004c9	33 c0		 xor	 eax, eax
  004cb	85 c0		 test	 eax, eax
  004cd	75 84		 jne	 SHORT $LN14@CTCI_ReadT

; 1102 :     pCTCBLK->fd = -1;

  004cf	48 8b 44 24 70	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  004d4	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1

; 1103 : 
; 1104 :     return NULL;

  004da	33 c0		 xor	 eax, eax

; 1105 : }

  004dc	48 8b 8c 24 c0
	08 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004e4	48 33 cc	 xor	 rcx, rsp
  004e7	e8 00 00 00 00	 call	 __security_check_cookie
  004ec	48 81 c4 d8 08
	00 00		 add	 rsp, 2264		; 000008d8H
  004f3	c3		 ret	 0
CTCI_ReadThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ctci.c
_TEXT	SEGMENT
pCTCBLK$ = 32
pDEVBLK$ = 64
ctc_halt_or_clear PROC

; 674  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 675  :     PCTCBLK pCTCBLK = (PCTCBLK) pDEVBLK->dev_data;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0000e	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00015	48 89 44 24 20	 mov	 QWORD PTR pCTCBLK$[rsp], rax

; 676  :     obtain_lock( &pCTCBLK->EventLock );

  0001a	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0001f	48 05 2a 50 00
	00		 add	 rax, 20522		; 0000502aH
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169331
  0002c	48 8b c8	 mov	 rcx, rax
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 677  :     {
; 678  :         if (pCTCBLK->fReadWaiting)

  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0003a	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  00040	c1 e8 07	 shr	 eax, 7
  00043	83 e0 01	 and	 eax, 1
  00046	85 c0		 test	 eax, eax
  00048	74 35		 je	 SHORT $LN2@ctc_halt_o

; 679  :         {
; 680  :             pCTCBLK->fHaltOrClear = 1;

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0004f	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  00055	0f ba e8 08	 bts	 eax, 8
  00059	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  0005e	89 81 3a 50 00
	00		 mov	 DWORD PTR [rcx+20538], eax

; 681  :             signal_condition( &pCTCBLK->Event );

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00069	48 05 32 50 00
	00		 add	 rax, 20530		; 00005032H
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169333
  00076	48 8b c8	 mov	 rcx, rax
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN2@ctc_halt_o:

; 682  :         }
; 683  :     }
; 684  :     release_lock( &pCTCBLK->EventLock );

  0007f	48 8b 44 24 20	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00084	48 05 2a 50 00
	00		 add	 rax, 20522		; 0000502aH
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169334
  00091	48 8b c8	 mov	 rcx, rax
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 685  : }

  0009a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009e	c3		 ret	 0
ctc_halt_or_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.h
_TEXT	SEGMENT
pSIDInfo$ = 0
pDEVBLK$ = 32
wCUType$ = 40
bCUMod$ = 48
wDevType$ = 56
bDevMod$ = 64
SetSIDInfo PROC

; 1343 : {

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	57		 push	 rdi
  00016	48 83 ec 10	 sub	 rsp, 16

; 1344 :     BYTE* pSIDInfo = pDEVBLK->devid;

  0001a	48 8b 44 24 20	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001f	48 05 68 04 00
	00		 add	 rax, 1128		; 00000468H
  00025	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1345 : 
; 1346 :     memset( pSIDInfo, 0, sizeof(pDEVBLK->devid) );

  00029	48 8b 3c 24	 mov	 rdi, QWORD PTR pSIDInfo$[rsp]
  0002d	33 c0		 xor	 eax, eax
  0002f	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00034	f3 aa		 rep stosb

; 1347 : 
; 1348 :     *pSIDInfo++ = 0x0FF;

  00036	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0003a	c6 00 ff	 mov	 BYTE PTR [rax], 255	; 000000ffH
  0003d	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00041	48 ff c0	 inc	 rax
  00044	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1349 :     *pSIDInfo++ = (BYTE)(( wCUType >> 8 ) & 0x00FF );

  00048	0f b7 44 24 28	 movzx	 eax, WORD PTR wCUType$[rsp]
  0004d	c1 f8 08	 sar	 eax, 8
  00050	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00055	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  00059	88 01		 mov	 BYTE PTR [rcx], al
  0005b	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0005f	48 ff c0	 inc	 rax
  00062	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1350 :     *pSIDInfo++ = (BYTE)( wCUType & 0x00FF );

  00066	0f b7 44 24 28	 movzx	 eax, WORD PTR wCUType$[rsp]
  0006b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00070	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  00074	88 01		 mov	 BYTE PTR [rcx], al
  00076	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0007a	48 ff c0	 inc	 rax
  0007d	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1351 :     *pSIDInfo++ = bCUMod;

  00081	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00085	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR bCUMod$[rsp]
  0008a	88 08		 mov	 BYTE PTR [rax], cl
  0008c	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1352 :     *pSIDInfo++ = (BYTE)(( wDevType >> 8 ) & 0x00FF );

  00097	0f b7 44 24 38	 movzx	 eax, WORD PTR wDevType$[rsp]
  0009c	c1 f8 08	 sar	 eax, 8
  0009f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a4	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  000a8	88 01		 mov	 BYTE PTR [rcx], al
  000aa	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000ae	48 ff c0	 inc	 rax
  000b1	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1353 :     *pSIDInfo++ = (BYTE)( wDevType & 0x00FF );

  000b5	0f b7 44 24 38	 movzx	 eax, WORD PTR wDevType$[rsp]
  000ba	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000bf	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  000c3	88 01		 mov	 BYTE PTR [rcx], al
  000c5	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000c9	48 ff c0	 inc	 rax
  000cc	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1354 :     *pSIDInfo++ = bDevMod;

  000d0	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000d4	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR bDevMod$[rsp]
  000d9	88 08		 mov	 BYTE PTR [rax], cl
  000db	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000df	48 ff c0	 inc	 rax
  000e2	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1355 :     *pSIDInfo++ = 0x00;

  000e6	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000ea	c6 00 00	 mov	 BYTE PTR [rax], 0
  000ed	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000f1	48 ff c0	 inc	 rax
  000f4	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1356 : 
; 1357 :     pDEVBLK->numdevid = 7;

  000f8	48 8b 44 24 20	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000fd	c7 80 64 04 00
	00 07 00 00 00	 mov	 DWORD PTR [rax+1124], 7

; 1358 : }

  00107	48 83 c4 10	 add	 rsp, 16
  0010b	5f		 pop	 rdi
  0010c	c3		 ret	 0
SetSIDInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ctci.c
_TEXT	SEGMENT
sSegLen$ = 112
i$ = 116
sOffset$ = 120
iPos$ = 124
sDataLen$ = 128
hwType$ = 132
pSegment$ = 136
pCTCBLK$ = 144
tv94 = 152
tv130 = 156
iStackCmd$ = 160
tv194 = 164
tv198 = 168
tv224 = 172
tv228 = 176
tv259 = 180
tv262 = 184
tv266 = 188
tv288 = 192
tv293 = 196
tv297 = 200
rc$ = 204
tv335 = 208
tv339 = 212
tv69 = 216
tv73 = 220
$T1 = 224
pFrame$ = 232
tv286 = 240
tv325 = 248
tv329 = 256
tv331 = 264
szStackID$ = 272
__$ArrayPad$ = 312
pDEVBLK$ = 336
sCount$ = 344
pIOBuf$ = 352
pUnitStat$ = 360
pResidual$ = 368
CTCI_Write PROC

; 835  : {

$LN24:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 836  :     PCTCBLK    pCTCBLK  = (PCTCBLK)pDEVBLK->dev_data;

  0002c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00034	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0003b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pCTCBLK$[rsp], rax

; 837  :     PCTCIHDR   pFrame;                  // -> Frame header
; 838  :     PCTCISEG   pSegment;                // -> Segment in buffer
; 839  :     U16        sOffset;                 // Offset of next frame
; 840  :     U16        sSegLen;                 // Current segment length
; 841  :     U16        sDataLen;                // Length of IP Frame data
; 842  :     int        iPos;                    // Offset into buffer
; 843  :     U16        i;                       // Array subscript
; 844  :     int        rc;                      // Return code
; 845  :     BYTE       szStackID[33];           // VSE IP stack identity
; 846  :     U32        iStackCmd;               // VSE IP stack command
; 847  :     U16        hwType;                  // Ethernet packet type
; 848  : 
; 849  :     // Check that CCW count is sufficient to contain block header
; 850  :     if( sCount < sizeof( CTCIHDR ) )

  00043	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  0004a	48 83 f8 02	 cmp	 rax, 2
  0004e	0f 83 b9 00 00
	00		 jae	 $LN8@CTCI_Write

; 851  :     {
; 852  :         // "%1d:%04X CTC: write CCW count %u is invalid"
; 853  :         WRMSG(HHC00906, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, sCount );

  00054	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0005c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00060	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv69[rsp], eax
  00067	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0006f	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00073	d1 f9		 sar	 ecx, 1
  00075	89 8c 24 dc 00
	00 00		 mov	 DWORD PTR tv73[rsp], ecx
  0007c	b9 01 00 00 00	 mov	 ecx, 1
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00087	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  0008e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00092	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv69[rsp]
  00099	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0009d	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv73[rsp]
  000a4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169444
  000af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169445
  000bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  000cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169446
  000d2	ba 55 03 00 00	 mov	 edx, 853		; 00000355H
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169447
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 854  : 
; 855  :         pDEVBLK->sense[0] = SENSE_DC;

  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 00	 imul	 rax, rax, 0
  000ed	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000f5	c6 84 01 64 03
	00 00 08	 mov	 BYTE PTR [rcx+rax+868], 8

; 856  :         *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  000fd	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00105	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 857  : 
; 858  :         return;

  00108	e9 9b 08 00 00	 jmp	 $LN1@CTCI_Write
$LN8@CTCI_Write:

; 859  :     }
; 860  : 
; 861  :     //
; 862  :     if( pCTCBLK->fDebug )

  0010d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00115	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  0011b	83 e0 01	 and	 eax, 1
  0011e	85 c0		 test	 eax, eax
  00120	0f 84 da 00 00
	00		 je	 $LN9@CTCI_Write

; 863  :     {
; 864  :         // HHC00981 "%1d:%04X %s: Accept data of size %d bytes from guest"
; 865  :         WRMSG(HHC00981, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,  pDEVBLK->typname, (int)sCount );

  00126	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0012e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00132	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv94[rsp], eax
  00139	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00141	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00145	d1 f9		 sar	 ecx, 1
  00147	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv130[rsp], ecx
  0014e	b9 01 00 00 00	 mov	 ecx, 1
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00159	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  00160	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00164	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0016c	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00170	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00175	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv94[rsp]
  0017c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00180	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv130[rsp]
  00187	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0018b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169449
  00192	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00197	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169450
  0019e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a8	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ae	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169451
  001b5	ba 61 03 00 00	 mov	 edx, 865		; 00000361H
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169452
  001c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 866  :         net_data_trace( pDEVBLK, pIOBuf, (int)sCount, '<', 'D', "data", 0 );

  001c7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  001cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169453
  001d6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001db	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  001e0	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  001e3	44 8b 84 24 58
	01 00 00	 mov	 r8d, DWORD PTR sCount$[rsp]
  001eb	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pIOBuf$[rsp]
  001f3	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001fb	e8 00 00 00 00	 call	 net_data_trace
$LN9@CTCI_Write:

; 867  :     }
; 868  : 
; 869  :     // Fix-up frame pointer
; 870  :     pFrame = (PCTCIHDR)pIOBuf;

  00200	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  00208	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pFrame$[rsp], rax

; 871  : 
; 872  :     // Extract the frame length from the header
; 873  :     FETCH_HW( sOffset, pFrame->hwOffset );

  00210	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR pFrame$[rsp]
  00218	48 8b c8	 mov	 rcx, rax
  0021b	e8 00 00 00 00	 call	 fetch_hw_noswap
  00220	0f b7 c8	 movzx	 ecx, ax
  00223	e8 00 00 00 00	 call	 _byteswap_ushort
  00228	66 89 44 24 78	 mov	 WORD PTR sOffset$[rsp], ax

; 874  : 
; 875  :     // Check for special VSE TCP/IP stack command packet
; 876  :     // The following example is from a VSE 5.1 system
; 877  :     //   +0000  00280026 C9E5E2C5 C3E3C3C1 F0F14BF0   ....IVSECTCA01.0
; 878  :     //   +0010  F540C640 F0F261F2 F661F0F8 F1F84BF2   5 F 02/26/0818.2
; 879  :     //   +0020  F4404040 09010001                     4   ....
; 880  :     if( sCount == 40 )

  0022d	83 bc 24 58 01
	00 00 28	 cmp	 DWORD PTR sCount$[rsp], 40 ; 00000028H
  00235	0f 85 d7 01 00
	00		 jne	 $LN10@CTCI_Write

; 881  :     {
; 882  :         if( sOffset == 0 || sOffset == 40 )

  0023b	0f b7 44 24 78	 movzx	 eax, WORD PTR sOffset$[rsp]
  00240	85 c0		 test	 eax, eax
  00242	74 0e		 je	 SHORT $LN12@CTCI_Write
  00244	0f b7 44 24 78	 movzx	 eax, WORD PTR sOffset$[rsp]
  00249	83 f8 28	 cmp	 eax, 40			; 00000028H
  0024c	0f 85 c0 01 00
	00		 jne	 $LN11@CTCI_Write
$LN12@CTCI_Write:

; 883  :         {
; 884  :             pSegment = (PCTCISEG)(pIOBuf + sizeof( CTCIHDR ));

  00252	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  0025a	48 83 c0 02	 add	 rax, 2
  0025e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pSegment$[rsp], rax

; 885  :             FETCH_HW( hwType, pSegment->hwType );

  00266	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pSegment$[rsp]
  0026e	48 83 c0 02	 add	 rax, 2
  00272	48 8b c8	 mov	 rcx, rax
  00275	e8 00 00 00 00	 call	 fetch_hw_noswap
  0027a	0f b7 c8	 movzx	 ecx, ax
  0027d	e8 00 00 00 00	 call	 _byteswap_ushort
  00282	66 89 84 24 84
	00 00 00	 mov	 WORD PTR hwType$[rsp], ax

; 886  :             if (hwType != ETH_TYPE_IP)

  0028a	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR hwType$[rsp]
  00292	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00297	0f 84 75 01 00
	00		 je	 $LN13@CTCI_Write

; 887  :             {
; 888  :                 // Extract the 32-byte stack identity string
; 889  :                 for( i = 0;

  0029d	33 c0		 xor	 eax, eax
  0029f	66 89 44 24 74	 mov	 WORD PTR i$[rsp], ax
  002a4	eb 0d		 jmp	 SHORT $LN4@CTCI_Write
$LN2@CTCI_Write:

; 891  :                      i++)

  002a6	0f b7 44 24 74	 movzx	 eax, WORD PTR i$[rsp]
  002ab	66 ff c0	 inc	 ax
  002ae	66 89 44 24 74	 mov	 WORD PTR i$[rsp], ax
$LN4@CTCI_Write:

; 890  :                      i < sizeof( szStackID ) - 1 && i < sCount - 4;

  002b3	0f b7 44 24 74	 movzx	 eax, WORD PTR i$[rsp]
  002b8	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  002bc	73 3d		 jae	 SHORT $LN3@CTCI_Write
  002be	0f b7 44 24 74	 movzx	 eax, WORD PTR i$[rsp]
  002c3	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  002ca	83 e9 04	 sub	 ecx, 4
  002cd	3b c1		 cmp	 eax, ecx
  002cf	73 2a		 jae	 SHORT $LN3@CTCI_Write

; 892  :                     szStackID[i] = guest_to_host( pIOBuf[i+4] );

  002d1	0f b7 44 24 74	 movzx	 eax, WORD PTR i$[rsp]
  002d6	83 c0 04	 add	 eax, 4
  002d9	48 98		 cdqe
  002db	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pIOBuf$[rsp]
  002e3	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  002e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  002ed	0f b7 4c 24 74	 movzx	 ecx, WORD PTR i$[rsp]
  002f2	88 84 0c 10 01
	00 00		 mov	 BYTE PTR szStackID$[rsp+rcx], al
  002f9	eb ab		 jmp	 SHORT $LN2@CTCI_Write
$LN3@CTCI_Write:

; 893  :                 szStackID[i] = '\0';

  002fb	0f b7 44 24 74	 movzx	 eax, WORD PTR i$[rsp]
  00300	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  00308	48 83 bc 24 e0
	00 00 00 21	 cmp	 QWORD PTR $T1[rsp], 33	; 00000021H
  00311	73 02		 jae	 SHORT $LN22@CTCI_Write
  00313	eb 05		 jmp	 SHORT $LN23@CTCI_Write
$LN22@CTCI_Write:
  00315	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN23@CTCI_Write:
  0031a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  00322	c6 84 04 10 01
	00 00 00	 mov	 BYTE PTR szStackID$[rsp+rax], 0

; 894  : 
; 895  :                 // Extract the stack command word
; 896  :                 FETCH_FW( iStackCmd, *((FWORD*)&pIOBuf[36]) );

  0032a	b8 01 00 00 00	 mov	 eax, 1
  0032f	48 6b c0 24	 imul	 rax, rax, 36		; 00000024H
  00333	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pIOBuf$[rsp]
  0033b	48 03 c8	 add	 rcx, rax
  0033e	48 8b c1	 mov	 rax, rcx
  00341	48 8b c8	 mov	 rcx, rax
  00344	e8 00 00 00 00	 call	 fetch_fw_noswap
  00349	8b c8		 mov	 ecx, eax
  0034b	e8 00 00 00 00	 call	 _byteswap_ulong
  00350	89 84 24 a0 00
	00 00		 mov	 DWORD PTR iStackCmd$[rsp], eax

; 897  : 
; 898  :                 // Display stack command and discard the packet
; 899  :                 // "%1d:%04X CTC: interface command: '%s' %8.8X"
; 900  :                 WRMSG(HHC00907, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, szStackID, iStackCmd );

  00357	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0035f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00363	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv194[rsp], eax
  0036a	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00372	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00376	d1 f9		 sar	 ecx, 1
  00378	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv198[rsp], ecx
  0037f	b9 01 00 00 00	 mov	 ecx, 1
  00384	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0038a	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR iStackCmd$[rsp]
  00391	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00395	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR szStackID$[rsp]
  0039d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003a2	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv194[rsp]
  003a9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003ad	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv198[rsp]
  003b4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169458
  003bf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169459
  003cb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003d5	41 b9 03 00 00
	00		 mov	 r9d, 3
  003db	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169460
  003e2	ba 84 03 00 00	 mov	 edx, 900		; 00000384H
  003e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169461
  003ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 901  : 
; 902  :                 *pUnitStat = CSW_CE | CSW_DE;

  003f4	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  003fc	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 903  :                 *pResidual = 0;

  003ff	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00407	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 904  : 
; 905  :                 return;

  0040d	e9 96 05 00 00	 jmp	 $LN1@CTCI_Write
$LN13@CTCI_Write:
$LN11@CTCI_Write:
$LN10@CTCI_Write:

; 906  :             }
; 907  :         }
; 908  :     }
; 909  : 
; 910  :     // Check for special L/390 initialization packet
; 911  :     if( sOffset == 0 )

  00412	0f b7 44 24 78	 movzx	 eax, WORD PTR sOffset$[rsp]
  00417	85 c0		 test	 eax, eax
  00419	75 1e		 jne	 SHORT $LN14@CTCI_Write

; 912  :     {
; 913  :         // Return normal status and discard the packet
; 914  :         *pUnitStat = CSW_CE | CSW_DE;

  0041b	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00423	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 915  :         *pResidual = 0;

  00426	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  0042e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 916  : 
; 917  :         return;

  00434	e9 6f 05 00 00	 jmp	 $LN1@CTCI_Write
$LN14@CTCI_Write:

; 918  :     }
; 919  : 
; 920  :     // Adjust the residual byte count
; 921  :     *pResidual -= sizeof( CTCIHDR );

  00439	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00441	8b 00		 mov	 eax, DWORD PTR [rax]
  00443	48 83 e8 02	 sub	 rax, 2
  00447	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  0044f	89 01		 mov	 DWORD PTR [rcx], eax

; 922  : 
; 923  :     // Process each segment in the buffer
; 924  :     for( iPos  = sizeof( CTCIHDR );

  00451	c7 44 24 7c 02
	00 00 00	 mov	 DWORD PTR iPos$[rsp], 2
  00459	eb 11		 jmp	 SHORT $LN7@CTCI_Write
$LN5@CTCI_Write:

; 926  :          iPos += sSegLen )

  0045b	0f b7 44 24 70	 movzx	 eax, WORD PTR sSegLen$[rsp]
  00460	8b 4c 24 7c	 mov	 ecx, DWORD PTR iPos$[rsp]
  00464	03 c8		 add	 ecx, eax
  00466	8b c1		 mov	 eax, ecx
  00468	89 44 24 7c	 mov	 DWORD PTR iPos$[rsp], eax
$LN7@CTCI_Write:

; 925  :          iPos  < sOffset;

  0046c	0f b7 44 24 78	 movzx	 eax, WORD PTR sOffset$[rsp]
  00471	39 44 24 7c	 cmp	 DWORD PTR iPos$[rsp], eax
  00475	0f 8d 14 05 00
	00		 jge	 $LN6@CTCI_Write

; 927  :     {
; 928  :         // Check that the segment is fully contained within the block
; 929  :         if( iPos + sizeof( CTCISEG ) > sOffset )

  0047b	48 63 44 24 7c	 movsxd	 rax, DWORD PTR iPos$[rsp]
  00480	48 83 c0 06	 add	 rax, 6
  00484	0f b7 4c 24 78	 movzx	 ecx, WORD PTR sOffset$[rsp]
  00489	48 3b c1	 cmp	 rax, rcx
  0048c	0f 86 b6 00 00
	00		 jbe	 $LN15@CTCI_Write

; 930  :         {
; 931  :             // "%1d:%04X CTC: incomplete write buffer segment header at offset %4.4X"
; 932  :             WRMSG(HHC00908, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, iPos );

  00492	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0049a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0049e	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv224[rsp], eax
  004a5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004ad	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  004b1	d1 f9		 sar	 ecx, 1
  004b3	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv228[rsp], ecx
  004ba	b9 01 00 00 00	 mov	 ecx, 1
  004bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004c5	8b 4c 24 7c	 mov	 ecx, DWORD PTR iPos$[rsp]
  004c9	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  004cd	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv224[rsp]
  004d4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004d8	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv228[rsp]
  004df	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169464
  004ea	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169465
  004f6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00500	41 b9 03 00 00
	00		 mov	 r9d, 3
  00506	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169466
  0050d	ba a4 03 00 00	 mov	 edx, 932		; 000003a4H
  00512	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169467
  00519	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 933  : 
; 934  :             pDEVBLK->sense[0] = SENSE_DC;

  0051f	b8 01 00 00 00	 mov	 eax, 1
  00524	48 6b c0 00	 imul	 rax, rax, 0
  00528	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00530	c6 84 01 64 03
	00 00 08	 mov	 BYTE PTR [rcx+rax+868], 8

; 935  :             *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  00538	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00540	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 936  :             return;

  00543	e9 60 04 00 00	 jmp	 $LN1@CTCI_Write
$LN15@CTCI_Write:

; 937  :         }
; 938  : 
; 939  :         // Fix-up segment header in the I/O buffer
; 940  :         pSegment = (PCTCISEG)(pIOBuf + iPos);

  00548	48 63 44 24 7c	 movsxd	 rax, DWORD PTR iPos$[rsp]
  0054d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pIOBuf$[rsp]
  00555	48 03 c8	 add	 rcx, rax
  00558	48 8b c1	 mov	 rax, rcx
  0055b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pSegment$[rsp], rax

; 941  : 
; 942  :         // Extract the segment length from the segment header
; 943  :         FETCH_HW( sSegLen, pSegment->hwLength );

  00563	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pSegment$[rsp]
  0056b	48 8b c8	 mov	 rcx, rax
  0056e	e8 00 00 00 00	 call	 fetch_hw_noswap
  00573	0f b7 c8	 movzx	 ecx, ax
  00576	e8 00 00 00 00	 call	 _byteswap_ushort
  0057b	66 89 44 24 70	 mov	 WORD PTR sSegLen$[rsp], ax

; 944  : 
; 945  :         // Check that the segment length is valid
; 946  :         if( ( sSegLen        < sizeof( CTCISEG ) ) ||
; 947  :             ( (U32)iPos + sSegLen > sOffset      ) ||

  00580	0f b7 44 24 70	 movzx	 eax, WORD PTR sSegLen$[rsp]
  00585	48 83 f8 06	 cmp	 rax, 6
  00589	72 30		 jb	 SHORT $LN17@CTCI_Write
  0058b	0f b7 44 24 70	 movzx	 eax, WORD PTR sSegLen$[rsp]
  00590	8b 4c 24 7c	 mov	 ecx, DWORD PTR iPos$[rsp]
  00594	03 c8		 add	 ecx, eax
  00596	8b c1		 mov	 eax, ecx
  00598	0f b7 4c 24 78	 movzx	 ecx, WORD PTR sOffset$[rsp]
  0059d	3b c1		 cmp	 eax, ecx
  0059f	77 1a		 ja	 SHORT $LN17@CTCI_Write
  005a1	0f b7 44 24 70	 movzx	 eax, WORD PTR sSegLen$[rsp]
  005a6	8b 4c 24 7c	 mov	 ecx, DWORD PTR iPos$[rsp]
  005aa	03 c8		 add	 ecx, eax
  005ac	8b c1		 mov	 eax, ecx
  005ae	3b 84 24 58 01
	00 00		 cmp	 eax, DWORD PTR sCount$[rsp]
  005b5	0f 86 cd 00 00
	00		 jbe	 $LN16@CTCI_Write
$LN17@CTCI_Write:

; 948  :             ( (U32)iPos + sSegLen > sCount       ) )
; 949  :         {
; 950  :             // "%1d:%04X CTC: invalid write buffer segment length %u at offset %4.4X"
; 951  :             WRMSG(HHC00909, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, sSegLen, iPos );

  005bb	0f b7 44 24 70	 movzx	 eax, WORD PTR sSegLen$[rsp]
  005c0	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv259[rsp], eax
  005c7	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  005cf	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  005d3	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv262[rsp], ecx
  005da	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  005e2	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  005e6	d1 fa		 sar	 edx, 1
  005e8	89 94 24 bc 00
	00 00		 mov	 DWORD PTR tv266[rsp], edx
  005ef	b9 01 00 00 00	 mov	 ecx, 1
  005f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005fa	8b 4c 24 7c	 mov	 ecx, DWORD PTR iPos$[rsp]
  005fe	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00602	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv259[rsp]
  00609	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0060d	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv262[rsp]
  00614	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00618	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv266[rsp]
  0061f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00623	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169470
  0062a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0062f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169471
  00636	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0063b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00640	41 b9 03 00 00
	00		 mov	 r9d, 3
  00646	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169472
  0064d	ba b7 03 00 00	 mov	 edx, 951		; 000003b7H
  00652	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169473
  00659	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 952  : 
; 953  :             pDEVBLK->sense[0] = SENSE_DC;

  0065f	b8 01 00 00 00	 mov	 eax, 1
  00664	48 6b c0 00	 imul	 rax, rax, 0
  00668	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00670	c6 84 01 64 03
	00 00 08	 mov	 BYTE PTR [rcx+rax+868], 8

; 954  :             *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  00678	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00680	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 955  :             return;

  00683	e9 20 03 00 00	 jmp	 $LN1@CTCI_Write
$LN16@CTCI_Write:

; 956  :         }
; 957  : 
; 958  :         // Calculate length of IP frame data
; 959  :         sDataLen = sSegLen - sizeof( CTCISEG );

  00688	0f b7 44 24 70	 movzx	 eax, WORD PTR sSegLen$[rsp]
  0068d	48 83 e8 06	 sub	 rax, 6
  00691	66 89 84 24 80
	00 00 00	 mov	 WORD PTR sDataLen$[rsp], ax

; 960  : 
; 961  :         // Trace the IP packet before sending to TUN device
; 962  :         if( pCTCBLK->fDebug )

  00699	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  006a1	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  006a7	83 e0 01	 and	 eax, 1
  006aa	85 c0		 test	 eax, eax
  006ac	0f 84 20 01 00
	00		 je	 $LN18@CTCI_Write

; 963  :         {
; 964  :             // "%1d:%04X %s: send%s packet of size %d bytes to device %s"
; 965  :             WRMSG(HHC00910, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",

  006b2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  006ba	48 05 c6 51 00
	00		 add	 rax, 20934		; 000051c6H
  006c0	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv286[rsp], rax
  006c8	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR sDataLen$[rsp]
  006d0	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv288[rsp], ecx
  006d7	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  006df	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  006e3	89 94 24 c4 00
	00 00		 mov	 DWORD PTR tv293[rsp], edx
  006ea	4c 8b 84 24 50
	01 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  006f2	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  006f7	41 d1 f8	 sar	 r8d, 1
  006fa	44 89 84 24 c8
	00 00 00	 mov	 DWORD PTR tv297[rsp], r8d
  00702	b9 01 00 00 00	 mov	 ecx, 1
  00707	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0070d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv286[rsp]
  00715	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0071a	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv288[rsp]
  00721	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00725	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169475
  0072c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00731	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169476
  00738	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0073d	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv293[rsp]
  00744	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00748	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv297[rsp]
  0074f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00753	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169477
  0075a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0075f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169478
  00766	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0076b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00770	41 b9 03 00 00
	00		 mov	 r9d, 3
  00776	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169479
  0077d	ba c6 03 00 00	 mov	 edx, 966		; 000003c6H
  00782	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169480
  00789	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 966  :                                  "", sDataLen, pCTCBLK->szTUNIfName );
; 967  :             net_data_trace( pDEVBLK, pSegment->bData, sDataLen, '<', 'D', "packet", 0 );

  0078f	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR sDataLen$[rsp]
  00797	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pSegment$[rsp]
  0079f	48 83 c1 06	 add	 rcx, 6
  007a3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  007ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169481
  007b2	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  007b7	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  007bc	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  007bf	44 8b c0	 mov	 r8d, eax
  007c2	48 8b d1	 mov	 rdx, rcx
  007c5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  007cd	e8 00 00 00 00	 call	 net_data_trace
$LN18@CTCI_Write:

; 968  :         }
; 969  : 
; 970  :         // Write the IP packet to the TUN/TAP interface
; 971  :         rc = TUNTAP_Write( pCTCBLK->fd, pSegment->bData, sDataLen );

  007d2	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR sDataLen$[rsp]
  007da	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pSegment$[rsp]
  007e2	48 83 c1 06	 add	 rcx, 6
  007e6	44 8b c0	 mov	 r8d, eax
  007e9	48 8b d1	 mov	 rdx, rcx
  007ec	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  007f4	8b 08		 mov	 ecx, DWORD PTR [rax]
  007f6	e8 00 00 00 00	 call	 tt32_write
  007fb	89 84 24 cc 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 972  : 
; 973  :         if( rc < 0 )

  00802	83 bc 24 cc 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0080a	0f 8d 1d 01 00
	00		 jge	 $LN19@CTCI_Write

; 974  :         {
; 975  :             // "%1d:%04X %s: error writing to device %s: %d %s"
; 976  :             WRMSG(HHC00911, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI",

  00810	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00816	8b 08		 mov	 ecx, DWORD PTR [rax]
  00818	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0081e	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv325[rsp], rax
  00826	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0082c	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv329[rsp], rax
  00834	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  0083c	48 81 c1 c6 51
	00 00		 add	 rcx, 20934		; 000051c6H
  00843	48 89 8c 24 08
	01 00 00	 mov	 QWORD PTR tv331[rsp], rcx
  0084b	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00853	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00857	89 94 24 d0 00
	00 00		 mov	 DWORD PTR tv335[rsp], edx
  0085e	4c 8b 84 24 50
	01 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  00866	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  0086b	41 d1 f8	 sar	 r8d, 1
  0086e	44 89 84 24 d4
	00 00 00	 mov	 DWORD PTR tv339[rsp], r8d
  00876	b9 01 00 00 00	 mov	 ecx, 1
  0087b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00881	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv325[rsp]
  00889	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0088e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv329[rsp]
  00896	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00898	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0089c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv331[rsp]
  008a4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  008a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169483
  008b0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008b5	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv335[rsp]
  008bc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  008c0	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv339[rsp]
  008c7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169484
  008d2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169485
  008de	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008e3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008e8	41 b9 03 00 00
	00		 mov	 r9d, 3
  008ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169486
  008f5	ba d1 03 00 00	 mov	 edx, 977		; 000003d1H
  008fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169487
  00901	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 977  :                                  pCTCBLK->szTUNIfName, errno, strerror( errno ));
; 978  :             pDEVBLK->sense[0] = SENSE_EC;

  00907	b8 01 00 00 00	 mov	 eax, 1
  0090c	48 6b c0 00	 imul	 rax, rax, 0
  00910	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00918	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 979  :             *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  00920	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00928	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 980  :             return;

  0092b	eb 7b		 jmp	 SHORT $LN1@CTCI_Write
$LN19@CTCI_Write:

; 981  :         }
; 982  : 
; 983  :         // Adjust the residual byte count
; 984  :         *pResidual -= sSegLen;

  0092d	0f b7 44 24 70	 movzx	 eax, WORD PTR sSegLen$[rsp]
  00932	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  0093a	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0093c	2b c8		 sub	 ecx, eax
  0093e	8b c1		 mov	 eax, ecx
  00940	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  00948	89 01		 mov	 DWORD PTR [rcx], eax

; 985  : 
; 986  :         // We are done if current segment satisfies CCW count
; 987  :         if( (U32)iPos + sSegLen == sCount )

  0094a	0f b7 44 24 70	 movzx	 eax, WORD PTR sSegLen$[rsp]
  0094f	8b 4c 24 7c	 mov	 ecx, DWORD PTR iPos$[rsp]
  00953	03 c8		 add	 ecx, eax
  00955	8b c1		 mov	 eax, ecx
  00957	3b 84 24 58 01
	00 00		 cmp	 eax, DWORD PTR sCount$[rsp]
  0095e	75 2a		 jne	 SHORT $LN20@CTCI_Write

; 988  :         {
; 989  :             *pResidual -= sSegLen;

  00960	0f b7 44 24 70	 movzx	 eax, WORD PTR sSegLen$[rsp]
  00965	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  0096d	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0096f	2b c8		 sub	 ecx, eax
  00971	8b c1		 mov	 eax, ecx
  00973	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  0097b	89 01		 mov	 DWORD PTR [rcx], eax

; 990  :             *pUnitStat = CSW_CE | CSW_DE;

  0097d	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00985	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 991  :             return;

  00988	eb 1e		 jmp	 SHORT $LN1@CTCI_Write
$LN20@CTCI_Write:

; 992  :         }
; 993  :     }

  0098a	e9 cc fa ff ff	 jmp	 $LN5@CTCI_Write
$LN6@CTCI_Write:

; 994  : 
; 995  :     // Set unit status and residual byte count
; 996  :     *pUnitStat = CSW_CE | CSW_DE;

  0098f	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00997	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 997  :     *pResidual = 0;

  0099a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  009a2	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN1@CTCI_Write:
$LN21@CTCI_Write:

; 998  : }

  009a8	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  009b0	48 33 cc	 xor	 rcx, rsp
  009b3	e8 00 00 00 00	 call	 __security_check_cookie
  009b8	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  009bf	c3		 ret	 0
CTCI_Write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ctci.c
_TEXT	SEGMENT
pCTCBLK$ = 96
haltorclear$ = 104
rc$ = 108
iLength$ = 112
tv146 = 120
tv150 = 124
tv202 = 128
tv206 = 132
now$1 = 136
pFrame$ = 144
waittime$2 = 152
__$ArrayPad$ = 168
pDEVBLK$ = 208
sCount$ = 216
pIOBuf$ = 224
pUnitStat$ = 232
pResidual$ = 240
pMore$ = 248
CTCI_Read PROC

; 713  : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 714  :     PCTCBLK     pCTCBLK  = (PCTCBLK)pDEVBLK->dev_data;

  0002e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00036	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0003d	48 89 44 24 60	 mov	 QWORD PTR pCTCBLK$[rsp], rax

; 715  :     PCTCIHDR    pFrame   = NULL;

  00042	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pFrame$[rsp], 0

; 716  :     size_t      iLength  = 0;

  0004e	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR iLength$[rsp], 0

; 717  :     int         rc       = 0;

  00057	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 718  :     BYTE        haltorclear = FALSE;

  0005f	c6 44 24 68 00	 mov	 BYTE PTR haltorclear$[rsp], 0
$LN2@CTCI_Read:

; 719  : 
; 720  :     for ( ; ; )
; 721  :     {
; 722  :         obtain_lock( &pCTCBLK->Lock );

  00064	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00069	48 05 22 50 00
	00		 add	 rax, 20514		; 00005022H
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169367
  00076	48 8b c8	 mov	 rcx, rax
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 723  : 
; 724  :         if (!pCTCBLK->fDataPending)

  0007f	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00084	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  0008a	c1 e8 04	 shr	 eax, 4
  0008d	83 e0 01	 and	 eax, 1
  00090	85 c0		 test	 eax, eax
  00092	0f 85 22 02 00
	00		 jne	 $LN5@CTCI_Read

; 725  :         {
; 726  :             release_lock( &pCTCBLK->Lock );

  00098	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0009d	48 05 22 50 00
	00		 add	 rax, 20514		; 00005022H
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169369
  000aa	48 8b c8	 mov	 rcx, rax
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 727  :             {
; 728  :                 struct timespec waittime;
; 729  :                 struct timeval  now;
; 730  : 
; 731  :                 gettimeofday( &now, NULL );

  000b3	33 d2		 xor	 edx, edx
  000b5	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR now$1[rsp]
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 732  : 
; 733  :                 waittime.tv_sec  = now.tv_sec  + DEF_NET_READ_TIMEOUT_SECS;

  000c3	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR now$1[rsp]
  000ca	83 c0 05	 add	 eax, 5
  000cd	48 98		 cdqe
  000cf	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR waittime$2[rsp], rax

; 734  :                 waittime.tv_nsec = now.tv_usec * 1000;

  000d7	69 84 24 8c 00
	00 00 e8 03 00
	00		 imul	 eax, DWORD PTR now$1[rsp+4], 1000 ; 000003e8H
  000e2	89 84 24 a0 00
	00 00		 mov	 DWORD PTR waittime$2[rsp+8], eax

; 735  : 
; 736  :                 obtain_lock( &pCTCBLK->EventLock );

  000e9	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  000ee	48 05 2a 50 00
	00		 add	 rax, 20522		; 0000502aH
  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169370
  000fb	48 8b c8	 mov	 rcx, rax
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 737  :                 pCTCBLK->fReadWaiting = 1;

  00104	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00109	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  0010f	0f ba e8 07	 bts	 eax, 7
  00113	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  00118	89 81 3a 50 00
	00		 mov	 DWORD PTR [rcx+20538], eax

; 738  :                 rc = timed_wait_condition( &pCTCBLK->Event,

  0011e	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00123	48 05 2a 50 00
	00		 add	 rax, 20522		; 0000502aH
  00129	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  0012e	48 81 c1 32 50
	00 00		 add	 rcx, 20530		; 00005032H
  00135	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169371
  0013c	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR waittime$2[rsp]
  00144	48 8b d0	 mov	 rdx, rax
  00147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_timed_wait_condition
  0014d	89 44 24 6c	 mov	 DWORD PTR rc$[rsp], eax

; 739  :                                            &pCTCBLK->EventLock,
; 740  :                                            &waittime );
; 741  :                 pCTCBLK->fReadWaiting = 0;

  00151	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00156	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  0015c	0f ba f0 07	 btr	 eax, 7
  00160	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  00165	89 81 3a 50 00
	00		 mov	 DWORD PTR [rcx+20538], eax

; 742  :             }
; 743  :             // check for halt condition
; 744  :             if (pCTCBLK->fHaltOrClear)

  0016b	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00170	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  00176	c1 e8 08	 shr	 eax, 8
  00179	83 e0 01	 and	 eax, 1
  0017c	85 c0		 test	 eax, eax
  0017e	74 1f		 je	 SHORT $LN6@CTCI_Read

; 745  :             {
; 746  :                 haltorclear = TRUE;

  00180	c6 44 24 68 01	 mov	 BYTE PTR haltorclear$[rsp], 1

; 747  :                 pCTCBLK->fHaltOrClear = 0;

  00185	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0018a	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  00190	0f ba f0 08	 btr	 eax, 8
  00194	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  00199	89 81 3a 50 00
	00		 mov	 DWORD PTR [rcx+20538], eax
$LN6@CTCI_Read:

; 748  :             }
; 749  :             release_lock( &pCTCBLK->EventLock );

  0019f	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  001a4	48 05 2a 50 00
	00		 add	 rax, 20522		; 0000502aH
  001aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169373
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 750  : 
; 751  :             // check for halt condition
; 752  :             if (haltorclear)

  001ba	0f b6 44 24 68	 movzx	 eax, BYTE PTR haltorclear$[rsp]
  001bf	85 c0		 test	 eax, eax
  001c1	0f 84 c2 00 00
	00		 je	 $LN7@CTCI_Read

; 753  :             {
; 754  :                 if (pDEVBLK->ccwtrace)

  001c7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001cf	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001d5	c1 e8 0f	 shr	 eax, 15
  001d8	83 e0 01	 and	 eax, 1
  001db	85 c0		 test	 eax, eax
  001dd	0f 84 85 00 00
	00		 je	 $LN8@CTCI_Read

; 755  :                 {
; 756  :                     // "%1d:%04X %s: halt or clear recognized"
; 757  :                     WRMSG( HHC00904, "I", SSID_TO_LCSS( pDEVBLK->ssid ),

  001e3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001eb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001ef	89 44 24 78	 mov	 DWORD PTR tv146[rsp], eax
  001f3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001fb	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  001ff	d1 f9		 sar	 ecx, 1
  00201	89 4c 24 7c	 mov	 DWORD PTR tv150[rsp], ecx
  00205	b9 01 00 00 00	 mov	 ecx, 1
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00210	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169376
  00217	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0021c	8b 4c 24 78	 mov	 ecx, DWORD PTR tv146[rsp]
  00220	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00224	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv150[rsp]
  00228	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0022c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169377
  00233	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00238	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169378
  0023f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00244	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00249	41 b9 03 00 00
	00		 mov	 r9d, 3
  0024f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169379
  00256	ba f6 02 00 00	 mov	 edx, 758		; 000002f6H
  0025b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169380
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@CTCI_Read:

; 758  :                         pDEVBLK->devnum, "CTCI" );
; 759  :                 }
; 760  : 
; 761  :                 *pUnitStat = CSW_CE | CSW_DE;

  00268	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00270	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 762  :                 *pResidual = sCount;

  00273	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  0027b	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  00282	89 08		 mov	 DWORD PTR [rax], ecx

; 763  :                 return;

  00284	e9 60 02 00 00	 jmp	 $LN1@CTCI_Read
$LN7@CTCI_Read:

; 764  :             }
; 765  : 
; 766  :             if (rc == ETIMEDOUT || rc == EINTR)

  00289	81 7c 24 6c 8a
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 138	; 0000008aH
  00291	74 07		 je	 SHORT $LN10@CTCI_Read
  00293	83 7c 24 6c 04	 cmp	 DWORD PTR rc$[rsp], 4
  00298	75 05		 jne	 SHORT $LN9@CTCI_Read
$LN10@CTCI_Read:

; 767  :                 continue;

  0029a	e9 c5 fd ff ff	 jmp	 $LN2@CTCI_Read
$LN9@CTCI_Read:

; 768  : 
; 769  :             obtain_lock( &pCTCBLK->Lock );

  0029f	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  002a4	48 05 22 50 00
	00		 add	 rax, 20514		; 00005022H
  002aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169383
  002b1	48 8b c8	 mov	 rcx, rax
  002b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN5@CTCI_Read:

; 770  :         }
; 771  : 
; 772  :         // Sanity check
; 773  :         if( pCTCBLK->iFrameOffset == 0 )

  002ba	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  002bf	0f b7 80 1e 50
	00 00		 movzx	 eax, WORD PTR [rax+20510]
  002c6	85 c0		 test	 eax, eax
  002c8	75 20		 jne	 SHORT $LN11@CTCI_Read

; 774  :         {
; 775  :             release_lock( &pCTCBLK->Lock );

  002ca	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  002cf	48 05 22 50 00
	00		 add	 rax, 20514		; 00005022H
  002d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169385
  002dc	48 8b c8	 mov	 rcx, rax
  002df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 776  :             continue;

  002e5	e9 7a fd ff ff	 jmp	 $LN2@CTCI_Read
$LN11@CTCI_Read:

; 777  :         }
; 778  : 
; 779  :         // Fix-up frame pointer and terminate block
; 780  :         pFrame = (PCTCIHDR)( pCTCBLK->bFrameBuffer +

  002ea	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  002ef	0f b7 80 1e 50
	00 00		 movzx	 eax, WORD PTR [rax+20510]
  002f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  002fb	48 8d 44 01 20	 lea	 rax, QWORD PTR [rcx+rax+32]
  00300	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pFrame$[rsp], rax

; 781  :                   sizeof( CTCIHDR ) +
; 782  :                   pCTCBLK->iFrameOffset );
; 783  : 
; 784  :         STORE_HW( pFrame->hwOffset, 0x0000 );

  00308	33 c9		 xor	 ecx, ecx
  0030a	e8 00 00 00 00	 call	 _byteswap_ushort
  0030f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pFrame$[rsp]
  00317	0f b7 d0	 movzx	 edx, ax
  0031a	e8 00 00 00 00	 call	 store_hw_noswap

; 785  : 
; 786  :         // (fix for day-1 bug offered by Vince Weaver [vince@deater.net])
; 787  : //      iLength = pCTCBLK->iFrameOffset + sizeof( CTCIHDR ) + 2;
; 788  :         iLength = pCTCBLK->iFrameOffset + sizeof( CTCIHDR );

  0031f	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00324	0f b7 80 1e 50
	00 00		 movzx	 eax, WORD PTR [rax+20510]
  0032b	48 83 c0 02	 add	 rax, 2
  0032f	48 89 44 24 70	 mov	 QWORD PTR iLength$[rsp], rax

; 789  : 
; 790  :         if( sCount < iLength )

  00334	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  0033b	48 3b 44 24 70	 cmp	 rax, QWORD PTR iLength$[rsp]
  00340	73 27		 jae	 SHORT $LN12@CTCI_Read

; 791  :         {
; 792  :             *pMore     = 1;

  00342	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  0034a	c6 00 01	 mov	 BYTE PTR [rax], 1

; 793  :             *pResidual = 0;

  0034d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00355	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 794  : 
; 795  :             iLength    = sCount;

  0035b	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  00362	48 89 44 24 70	 mov	 QWORD PTR iLength$[rsp], rax

; 796  :         }

  00367	eb 28		 jmp	 SHORT $LN13@CTCI_Read
$LN12@CTCI_Read:

; 797  :         else
; 798  :         {
; 799  :             *pMore      = 0;

  00369	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  00371	c6 00 00	 mov	 BYTE PTR [rax], 0

; 800  :             *pResidual -= (U16)iLength;

  00374	0f b7 44 24 70	 movzx	 eax, WORD PTR iLength$[rsp]
  00379	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  00381	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00383	2b c8		 sub	 ecx, eax
  00385	8b c1		 mov	 eax, ecx
  00387	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  0038f	89 01		 mov	 DWORD PTR [rcx], eax
$LN13@CTCI_Read:

; 801  :         }
; 802  : 
; 803  :         *pUnitStat = CSW_CE | CSW_DE;

  00391	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00399	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 804  : 
; 805  :         memcpy( pIOBuf, pCTCBLK->bFrameBuffer, iLength );

  0039c	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  003a1	48 83 c0 1e	 add	 rax, 30
  003a5	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  003ad	48 8b f0	 mov	 rsi, rax
  003b0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iLength$[rsp]
  003b5	f3 a4		 rep movsb

; 806  : 
; 807  :         if( pCTCBLK->fDebug )

  003b7	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  003bc	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  003c2	83 e0 01	 and	 eax, 1
  003c5	85 c0		 test	 eax, eax
  003c7	0f 84 d3 00 00
	00		 je	 $LN14@CTCI_Read

; 808  :         {
; 809  :             // "%1d:%04X %s: Present data of size %d bytes to guest"
; 810  :             WRMSG(HHC00982, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI", (int)iLength);

  003cd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003d5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003d9	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv202[rsp], eax
  003e0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003e8	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  003ec	d1 f9		 sar	 ecx, 1
  003ee	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv206[rsp], ecx
  003f5	b9 01 00 00 00	 mov	 ecx, 1
  003fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00400	8b 4c 24 70	 mov	 ecx, DWORD PTR iLength$[rsp]
  00404	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00408	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169389
  0040f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00414	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv202[rsp]
  0041b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0041f	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv206[rsp]
  00426	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0042a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169390
  00431	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00436	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169391
  0043d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00442	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00447	41 b9 03 00 00
	00		 mov	 r9d, 3
  0044d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169392
  00454	ba 2a 03 00 00	 mov	 edx, 810		; 0000032aH
  00459	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169393
  00460	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 811  :             net_data_trace( pDEVBLK, pCTCBLK->bFrameBuffer, (int)iLength, '>', 'D', "data", 0 );

  00466	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0046b	48 83 c0 1e	 add	 rax, 30
  0046f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00477	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169394
  0047e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00483	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00488	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  0048b	44 8b 44 24 70	 mov	 r8d, DWORD PTR iLength$[rsp]
  00490	48 8b d0	 mov	 rdx, rax
  00493	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0049b	e8 00 00 00 00	 call	 net_data_trace
$LN14@CTCI_Read:

; 812  :         }
; 813  : 
; 814  :         // Reset frame buffer
; 815  :         pCTCBLK->iFrameOffset  = 0;

  004a0	33 c0		 xor	 eax, eax
  004a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  004a7	66 89 81 1e 50
	00 00		 mov	 WORD PTR [rcx+20510], ax

; 816  :         pCTCBLK->fDataPending  = 0;

  004ae	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  004b3	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  004b9	83 e0 ef	 and	 eax, -17		; ffffffefH
  004bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  004c1	89 81 3a 50 00
	00		 mov	 DWORD PTR [rcx+20538], eax

; 817  : 
; 818  :         release_lock( &pCTCBLK->Lock );

  004c7	48 8b 44 24 60	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  004cc	48 05 22 50 00
	00		 add	 rax, 20514		; 00005022H
  004d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169395
  004d9	48 8b c8	 mov	 rcx, rax
  004dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 819  : 
; 820  :         return;

  004e2	eb 05		 jmp	 SHORT $LN1@CTCI_Read

; 821  :     }

  004e4	e9 7b fb ff ff	 jmp	 $LN2@CTCI_Read
$LN1@CTCI_Read:

; 822  : }

  004e9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004f1	48 33 cc	 xor	 rcx, rsp
  004f4	e8 00 00 00 00	 call	 __security_check_cookie
  004f9	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00500	5f		 pop	 rdi
  00501	5e		 pop	 rsi
  00502	c3		 ret	 0
CTCI_Read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ctci.c
_TEXT	SEGMENT
bOpCode$ = 48
iNum$ = 52
tv140 = 56
tv128 = 60
tv174 = 64
tv193 = 68
pDEVBLK$ = 112
bCode$ = 120
bFlags$ = 128
bChained$ = 136
sCount$ = 144
bPrevCode$ = 152
iCCWSeq$ = 160
pIOBuf$ = 168
pMore$ = 176
pUnitStat$ = 184
pResidual$ = 192
CTCI_ExecuteCCW PROC

; 368  : {

$LN58:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@CTCI_Execu:

; 369  :     int             iNum;               // Number of bytes to move
; 370  :     BYTE            bOpCode;            // CCW opcode with modifier
; 371  :                                         //   bits masked off
; 372  : 
; 373  :     UNREFERENCED( bFlags    );

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	75 fa		 jne	 SHORT $LN4@CTCI_Execu
$LN7@CTCI_Execu:

; 374  :     UNREFERENCED( bChained  );

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN7@CTCI_Execu
$LN10@CTCI_Execu:

; 375  :     UNREFERENCED( bPrevCode );

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN10@CTCI_Execu
$LN13@CTCI_Execu:

; 376  :     UNREFERENCED( iCCWSeq   );

  0002b	33 c0		 xor	 eax, eax
  0002d	85 c0		 test	 eax, eax
  0002f	75 fa		 jne	 SHORT $LN13@CTCI_Execu

; 377  : 
; 378  :     // Intervention required if the device file is not open
; 379  :     if( pDEVBLK->fd < 0 &&
; 380  :         !IS_CCW_SENSE( bCode ) &&

  00031	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00036	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  0003d	7d 40		 jge	 SHORT $LN16@CTCI_Execu
  0003f	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  00044	83 e0 0f	 and	 eax, 15
  00047	83 f8 04	 cmp	 eax, 4
  0004a	74 33		 je	 SHORT $LN16@CTCI_Execu
  0004c	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  00051	83 e0 03	 and	 eax, 3
  00054	83 f8 03	 cmp	 eax, 3
  00057	74 26		 je	 SHORT $LN16@CTCI_Execu

; 381  :         !IS_CCW_CONTROL( bCode ) )
; 382  :     {
; 383  :         pDEVBLK->sense[0] = SENSE_IR;

  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	48 6b c0 00	 imul	 rax, rax, 0
  00062	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00067	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 384  :         *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  0006f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00077	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 385  :         return;

  0007a	e9 41 04 00 00	 jmp	 $LN1@CTCI_Execu
$LN16@CTCI_Execu:

; 386  :     }
; 387  : 
; 388  :     // Mask off the modifier bits in the CCW bOpCode
; 389  :     if( ( bCode & 0x07 ) == 0x07 )

  0007f	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  00084	83 e0 07	 and	 eax, 7
  00087	83 f8 07	 cmp	 eax, 7
  0008a	75 0a		 jne	 SHORT $LN17@CTCI_Execu

; 390  :         bOpCode = 0x07;

  0008c	c6 44 24 30 07	 mov	 BYTE PTR bOpCode$[rsp], 7
  00091	e9 b7 00 00 00	 jmp	 $LN18@CTCI_Execu
$LN17@CTCI_Execu:

; 391  :     else if( ( bCode & 0x03 ) == 0x02 )

  00096	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  0009b	83 e0 03	 and	 eax, 3
  0009e	83 f8 02	 cmp	 eax, 2
  000a1	75 0a		 jne	 SHORT $LN19@CTCI_Execu

; 392  :         bOpCode = 0x02;

  000a3	c6 44 24 30 02	 mov	 BYTE PTR bOpCode$[rsp], 2
  000a8	e9 a0 00 00 00	 jmp	 $LN20@CTCI_Execu
$LN19@CTCI_Execu:

; 393  :     else if( ( bCode & 0x0F ) == 0x0C )

  000ad	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  000b2	83 e0 0f	 and	 eax, 15
  000b5	83 f8 0c	 cmp	 eax, 12
  000b8	75 0a		 jne	 SHORT $LN21@CTCI_Execu

; 394  :         bOpCode = 0x0C;

  000ba	c6 44 24 30 0c	 mov	 BYTE PTR bOpCode$[rsp], 12
  000bf	e9 89 00 00 00	 jmp	 $LN22@CTCI_Execu
$LN21@CTCI_Execu:

; 395  :     else if( ( bCode & 0x03 ) == 0x01 )

  000c4	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  000c9	83 e0 03	 and	 eax, 3
  000cc	83 f8 01	 cmp	 eax, 1
  000cf	75 35		 jne	 SHORT $LN23@CTCI_Execu

; 396  :         bOpCode = pDEVBLK->ctcxmode ? ( bCode & 0x83 ) : 0x01;

  000d1	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000d6	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  000dc	83 e0 01	 and	 eax, 1
  000df	85 c0		 test	 eax, eax
  000e1	74 10		 je	 SHORT $LN50@CTCI_Execu
  000e3	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  000e8	25 83 00 00 00	 and	 eax, 131		; 00000083H
  000ed	89 44 24 3c	 mov	 DWORD PTR tv128[rsp], eax
  000f1	eb 08		 jmp	 SHORT $LN51@CTCI_Execu
$LN50@CTCI_Execu:
  000f3	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
$LN51@CTCI_Execu:
  000fb	0f b6 44 24 3c	 movzx	 eax, BYTE PTR tv128[rsp]
  00100	88 44 24 30	 mov	 BYTE PTR bOpCode$[rsp], al
  00104	eb 47		 jmp	 SHORT $LN24@CTCI_Execu
$LN23@CTCI_Execu:

; 397  :     else if( ( bCode & 0x1F ) == 0x14 )

  00106	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  0010b	83 e0 1f	 and	 eax, 31
  0010e	83 f8 14	 cmp	 eax, 20
  00111	75 07		 jne	 SHORT $LN25@CTCI_Execu

; 398  :         bOpCode = 0x14;

  00113	c6 44 24 30 14	 mov	 BYTE PTR bOpCode$[rsp], 20
  00118	eb 33		 jmp	 SHORT $LN26@CTCI_Execu
$LN25@CTCI_Execu:

; 399  :     else if( ( bCode & 0x47 ) == 0x03 )

  0011a	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  0011f	83 e0 47	 and	 eax, 71			; 00000047H
  00122	83 f8 03	 cmp	 eax, 3
  00125	75 07		 jne	 SHORT $LN27@CTCI_Execu

; 400  :         bOpCode = 0x03;

  00127	c6 44 24 30 03	 mov	 BYTE PTR bOpCode$[rsp], 3
  0012c	eb 1f		 jmp	 SHORT $LN28@CTCI_Execu
$LN27@CTCI_Execu:

; 401  :     else if( ( bCode & 0xC7 ) == 0x43 )

  0012e	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  00133	25 c7 00 00 00	 and	 eax, 199		; 000000c7H
  00138	83 f8 43	 cmp	 eax, 67			; 00000043H
  0013b	75 07		 jne	 SHORT $LN29@CTCI_Execu

; 402  :         bOpCode = 0x43;

  0013d	c6 44 24 30 43	 mov	 BYTE PTR bOpCode$[rsp], 67 ; 00000043H
  00142	eb 09		 jmp	 SHORT $LN30@CTCI_Execu
$LN29@CTCI_Execu:

; 403  :     else
; 404  :         bOpCode = bCode;

  00144	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  00149	88 44 24 30	 mov	 BYTE PTR bOpCode$[rsp], al
$LN30@CTCI_Execu:
$LN28@CTCI_Execu:
$LN26@CTCI_Execu:
$LN24@CTCI_Execu:
$LN22@CTCI_Execu:
$LN20@CTCI_Execu:
$LN18@CTCI_Execu:

; 405  : 
; 406  :     // Process depending on CCW bOpCode
; 407  :     switch (bOpCode)

  0014d	0f b6 44 24 30	 movzx	 eax, BYTE PTR bOpCode$[rsp]
  00152	89 44 24 38	 mov	 DWORD PTR tv140[rsp], eax
  00156	8b 44 24 38	 mov	 eax, DWORD PTR tv140[rsp]
  0015a	ff c8		 dec	 eax
  0015c	89 44 24 38	 mov	 DWORD PTR tv140[rsp], eax
  00160	81 7c 24 38 e3
	00 00 00	 cmp	 DWORD PTR tv140[rsp], 227 ; 000000e3H
  00168	0f 87 31 03 00
	00		 ja	 $LN48@CTCI_Execu
  0016e	48 63 44 24 38	 movsxd	 rax, DWORD PTR tv140[rsp]
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0017a	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN56@CTCI_Execu[rcx+rax]
  00182	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN57@CTCI_Execu[rcx+rax*4]
  00189	48 03 c1	 add	 rax, rcx
  0018c	ff e0		 jmp	 rax
$LN31@CTCI_Execu:

; 408  :     {
; 409  :     case 0x01:  // 0MMMMM01  WRITE
; 410  :         //------------------------------------------------------------
; 411  :         // WRITE
; 412  :         //------------------------------------------------------------
; 413  : 
; 414  :         // Return normal status if CCW count is zero
; 415  :         if( sCount == 0 )

  0018e	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR sCount$[rsp], 0
  00196	75 10		 jne	 SHORT $LN32@CTCI_Execu

; 416  :         {
; 417  :             *pUnitStat = CSW_CE | CSW_DE;

  00198	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  001a0	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 418  :             break;

  001a3	e9 18 03 00 00	 jmp	 $LN14@CTCI_Execu
$LN32@CTCI_Execu:

; 419  :         }
; 420  : 
; 421  :         CTCI_Write( pDEVBLK, sCount, pIOBuf, pUnitStat, pResidual );

  001a8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  001b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b5	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  001bd	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR pIOBuf$[rsp]
  001c5	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR sCount$[rsp]
  001cc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001d1	e8 00 00 00 00	 call	 CTCI_Write

; 422  :         break;

  001d6	e9 e5 02 00 00	 jmp	 $LN14@CTCI_Execu
$LN33@CTCI_Execu:

; 423  : 
; 424  :     case 0x81:  // 1MMMMM01  WEOF
; 425  :         //------------------------------------------------------------
; 426  :         // WRITE EOF
; 427  :         //------------------------------------------------------------
; 428  : 
; 429  :         // Return normal status
; 430  :         *pUnitStat = CSW_CE | CSW_DE;

  001db	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  001e3	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 431  :         break;

  001e6	e9 d5 02 00 00	 jmp	 $LN14@CTCI_Execu
$LN34@CTCI_Execu:
$LN35@CTCI_Execu:

; 432  : 
; 433  :     case 0x02:  // MMMMMM10  READ
; 434  :     case 0x0C:  // MMMM1100  RDBACK
; 435  :         // -----------------------------------------------------------
; 436  :         // READ & READ BACKWARDS
; 437  :         // -----------------------------------------------------------
; 438  : 
; 439  :         // Read data and set unit status and residual byte count
; 440  :         CTCI_Read( pDEVBLK, sCount, pIOBuf, pUnitStat, pResidual, pMore );

  001eb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  001f3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001f8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00200	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00205	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  0020d	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR pIOBuf$[rsp]
  00215	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR sCount$[rsp]
  0021c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00221	e8 00 00 00 00	 call	 CTCI_Read

; 441  :         break;

  00226	e9 95 02 00 00	 jmp	 $LN14@CTCI_Execu
$LN36@CTCI_Execu:

; 442  : 
; 443  :     case 0x07:  // MMMMM111  CTL
; 444  :         // -----------------------------------------------------------
; 445  :         // CONTROL
; 446  :         // -----------------------------------------------------------
; 447  : 
; 448  :         *pUnitStat = CSW_CE | CSW_DE;

  0022b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00233	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 449  :         break;

  00236	e9 85 02 00 00	 jmp	 $LN14@CTCI_Execu
$LN37@CTCI_Execu:

; 450  : 
; 451  :     case 0x03:  // M0MMM011  NOP
; 452  :         // -----------------------------------------------------------
; 453  :         // CONTROL NO-OPERATON
; 454  :         // -----------------------------------------------------------
; 455  : 
; 456  :         *pUnitStat = CSW_CE | CSW_DE;

  0023b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00243	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 457  :         break;

  00246	e9 75 02 00 00	 jmp	 $LN14@CTCI_Execu
$LN38@CTCI_Execu:

; 458  : 
; 459  :     case 0x43:  // 00XXX011  SBM
; 460  :         // -----------------------------------------------------------
; 461  :         // SET BASIC MODE
; 462  :         // -----------------------------------------------------------
; 463  : 
; 464  :         // Command reject if in basic mode
; 465  :         if( pDEVBLK->ctcxmode == 0 )

  0024b	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00250	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00256	83 e0 01	 and	 eax, 1
  00259	85 c0		 test	 eax, eax
  0025b	75 26		 jne	 SHORT $LN39@CTCI_Execu

; 466  :         {
; 467  :             pDEVBLK->sense[0] = SENSE_CR;

  0025d	b8 01 00 00 00	 mov	 eax, 1
  00262	48 6b c0 00	 imul	 rax, rax, 0
  00266	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0026b	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 468  :             *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  00273	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0027b	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 469  : 
; 470  :             break;

  0027e	e9 3d 02 00 00	 jmp	 $LN14@CTCI_Execu
$LN39@CTCI_Execu:

; 471  :         }
; 472  : 
; 473  :         // Reset extended mode and return normal status
; 474  :         pDEVBLK->ctcxmode = 0;

  00283	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00288	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  0028e	83 e0 fe	 and	 eax, -2			; fffffffeH
  00291	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00296	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 475  : 
; 476  :         *pResidual = 0;

  0029c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  002a4	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 477  :         *pUnitStat = CSW_CE | CSW_DE;

  002aa	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  002b2	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 478  : 
; 479  :         break;

  002b5	e9 06 02 00 00	 jmp	 $LN14@CTCI_Execu
$LN40@CTCI_Execu:

; 480  : 
; 481  :     case 0xC3:  // 11000011  SEM
; 482  :         // -----------------------------------------------------------
; 483  :         // SET EXTENDED MODE
; 484  :         // -----------------------------------------------------------
; 485  : 
; 486  :         pDEVBLK->ctcxmode = 1;

  002ba	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002bf	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  002c5	83 c8 01	 or	 eax, 1
  002c8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002cd	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 487  : 
; 488  :         *pResidual = 0;

  002d3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  002db	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 489  :         *pUnitStat = CSW_CE | CSW_DE;

  002e1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  002e9	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 490  : 
; 491  :         break;

  002ec	e9 cf 01 00 00	 jmp	 $LN14@CTCI_Execu
$LN41@CTCI_Execu:

; 492  : 
; 493  :     case 0xE3:  // 11100011
; 494  :         // -----------------------------------------------------------
; 495  :         // PREPARE (PREP)
; 496  :         // -----------------------------------------------------------
; 497  : 
; 498  :         *pUnitStat = CSW_CE | CSW_DE;

  002f1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  002f9	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 499  : 
; 500  :         break;

  002fc	e9 bf 01 00 00	 jmp	 $LN14@CTCI_Execu
$LN42@CTCI_Execu:

; 501  : 
; 502  :     case 0x14:  // XXX10100  SCB
; 503  :         // -----------------------------------------------------------
; 504  :         // SENSE COMMAND BYTE
; 505  :         // -----------------------------------------------------------
; 506  : 
; 507  :         *pUnitStat = CSW_CE | CSW_DE;

  00301	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00309	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 508  :         break;

  0030c	e9 af 01 00 00	 jmp	 $LN14@CTCI_Execu
$LN43@CTCI_Execu:

; 509  : 
; 510  :     case 0x04:  // 00000100  SENSE
; 511  :       // -----------------------------------------------------------
; 512  :       // SENSE
; 513  :       // -----------------------------------------------------------
; 514  : 
; 515  :         // Command reject if in basic mode
; 516  :         if( pDEVBLK->ctcxmode == 0 )

  00311	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00316	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  0031c	83 e0 01	 and	 eax, 1
  0031f	85 c0		 test	 eax, eax
  00321	75 26		 jne	 SHORT $LN44@CTCI_Execu

; 517  :         {
; 518  :             pDEVBLK->sense[0] = SENSE_CR;

  00323	b8 01 00 00 00	 mov	 eax, 1
  00328	48 6b c0 00	 imul	 rax, rax, 0
  0032c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00331	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 519  :             *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  00339	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00341	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 520  :             break;

  00344	e9 77 01 00 00	 jmp	 $LN14@CTCI_Execu
$LN44@CTCI_Execu:

; 521  :         }
; 522  : 
; 523  :         // Calculate residual byte count
; 524  :         iNum = ( sCount < pDEVBLK->numsense ) ?

  00349	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0034e	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00354	39 84 24 90 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  0035b	73 0d		 jae	 SHORT $LN52@CTCI_Execu
  0035d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  00364	89 44 24 40	 mov	 DWORD PTR tv174[rsp], eax
  00368	eb 0f		 jmp	 SHORT $LN53@CTCI_Execu
$LN52@CTCI_Execu:
  0036a	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0036f	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00375	89 44 24 40	 mov	 DWORD PTR tv174[rsp], eax
$LN53@CTCI_Execu:
  00379	8b 44 24 40	 mov	 eax, DWORD PTR tv174[rsp]
  0037d	89 44 24 34	 mov	 DWORD PTR iNum$[rsp], eax

; 525  :             sCount : pDEVBLK->numsense;
; 526  : 
; 527  :         *pResidual = sCount - iNum;

  00381	8b 44 24 34	 mov	 eax, DWORD PTR iNum$[rsp]
  00385	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  0038c	2b c8		 sub	 ecx, eax
  0038e	8b c1		 mov	 eax, ecx
  00390	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  00398	89 01		 mov	 DWORD PTR [rcx], eax

; 528  : 
; 529  :         if( sCount < pDEVBLK->numsense )

  0039a	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0039f	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  003a5	39 84 24 90 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  003ac	73 0b		 jae	 SHORT $LN45@CTCI_Execu

; 530  :             *pMore = 1;

  003ae	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  003b6	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN45@CTCI_Execu:

; 531  : 
; 532  :         // Copy device sense bytes to channel I/O buffer
; 533  :         memcpy( pIOBuf, pDEVBLK->sense, iNum );

  003b9	48 63 44 24 34	 movsxd	 rax, DWORD PTR iNum$[rsp]
  003be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003c3	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  003ca	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  003d2	48 8b f1	 mov	 rsi, rcx
  003d5	48 8b c8	 mov	 rcx, rax
  003d8	f3 a4		 rep movsb

; 534  : 
; 535  :         // Clear the device sense bytes
; 536  :         memset( pDEVBLK->sense, 0, sizeof( pDEVBLK->sense ) );

  003da	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003df	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  003e5	48 8b f8	 mov	 rdi, rax
  003e8	33 c0		 xor	 eax, eax
  003ea	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  003ef	f3 aa		 rep stosb

; 537  : 
; 538  :         // Return unit status
; 539  :         *pUnitStat = CSW_CE | CSW_DE;

  003f1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  003f9	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 540  : 
; 541  :         break;

  003fc	e9 bf 00 00 00	 jmp	 $LN14@CTCI_Execu
$LN46@CTCI_Execu:

; 542  : 
; 543  :     case 0xE4:  //  11100100  SID
; 544  :         // -----------------------------------------------------------
; 545  :         // SENSE ID
; 546  :         // -----------------------------------------------------------
; 547  : 
; 548  :         // Calculate residual byte count
; 549  :         iNum = ( sCount < pDEVBLK->numdevid ) ?

  00401	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00406	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  0040c	39 84 24 90 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  00413	73 0d		 jae	 SHORT $LN54@CTCI_Execu
  00415	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  0041c	89 44 24 44	 mov	 DWORD PTR tv193[rsp], eax
  00420	eb 0f		 jmp	 SHORT $LN55@CTCI_Execu
$LN54@CTCI_Execu:
  00422	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00427	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  0042d	89 44 24 44	 mov	 DWORD PTR tv193[rsp], eax
$LN55@CTCI_Execu:
  00431	8b 44 24 44	 mov	 eax, DWORD PTR tv193[rsp]
  00435	89 44 24 34	 mov	 DWORD PTR iNum$[rsp], eax

; 550  :             sCount : pDEVBLK->numdevid;
; 551  : 
; 552  :         *pResidual = sCount - iNum;

  00439	8b 44 24 34	 mov	 eax, DWORD PTR iNum$[rsp]
  0043d	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  00444	2b c8		 sub	 ecx, eax
  00446	8b c1		 mov	 eax, ecx
  00448	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  00450	89 01		 mov	 DWORD PTR [rcx], eax

; 553  : 
; 554  :         if( sCount < pDEVBLK->numdevid )

  00452	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00457	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  0045d	39 84 24 90 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  00464	73 0b		 jae	 SHORT $LN47@CTCI_Execu

; 555  :             *pMore = 1;

  00466	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  0046e	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN47@CTCI_Execu:

; 556  : 
; 557  :         // Copy device identifier bytes to channel I/O buffer
; 558  :         memcpy( pIOBuf, pDEVBLK->devid, iNum );

  00471	48 63 44 24 34	 movsxd	 rax, DWORD PTR iNum$[rsp]
  00476	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0047b	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  00482	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  0048a	48 8b f1	 mov	 rsi, rcx
  0048d	48 8b c8	 mov	 rcx, rax
  00490	f3 a4		 rep movsb

; 559  : 
; 560  :         // Return unit status
; 561  :         *pUnitStat = CSW_CE | CSW_DE;

  00492	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0049a	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 562  : 
; 563  :         break;

  0049d	eb 21		 jmp	 SHORT $LN14@CTCI_Execu
$LN48@CTCI_Execu:

; 564  : 
; 565  :     default:
; 566  :         // ------------------------------------------------------------
; 567  :         // INVALID OPERATION
; 568  :         // ------------------------------------------------------------
; 569  : 
; 570  :         // Set command reject sense byte, and unit check status
; 571  :         pDEVBLK->sense[0] = SENSE_CR;

  0049f	b8 01 00 00 00	 mov	 eax, 1
  004a4	48 6b c0 00	 imul	 rax, rax, 0
  004a8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004ad	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 572  :         *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  004b5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  004bd	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN14@CTCI_Execu:
$LN1@CTCI_Execu:

; 573  :     }
; 574  : }

  004c0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  004c4	5f		 pop	 rdi
  004c5	5e		 pop	 rsi
  004c6	c3		 ret	 0
  004c7	90		 npad	 1
$LN57@CTCI_Execu:
  004c8	00 00 00 00	 DD	 $LN31@CTCI_Execu
  004cc	00 00 00 00	 DD	 $LN34@CTCI_Execu
  004d0	00 00 00 00	 DD	 $LN37@CTCI_Execu
  004d4	00 00 00 00	 DD	 $LN43@CTCI_Execu
  004d8	00 00 00 00	 DD	 $LN36@CTCI_Execu
  004dc	00 00 00 00	 DD	 $LN35@CTCI_Execu
  004e0	00 00 00 00	 DD	 $LN42@CTCI_Execu
  004e4	00 00 00 00	 DD	 $LN38@CTCI_Execu
  004e8	00 00 00 00	 DD	 $LN33@CTCI_Execu
  004ec	00 00 00 00	 DD	 $LN40@CTCI_Execu
  004f0	00 00 00 00	 DD	 $LN41@CTCI_Execu
  004f4	00 00 00 00	 DD	 $LN46@CTCI_Execu
  004f8	00 00 00 00	 DD	 $LN48@CTCI_Execu
$LN56@CTCI_Execu:
  004fc	00		 DB	 0
  004fd	01		 DB	 1
  004fe	02		 DB	 2
  004ff	03		 DB	 3
  00500	0c		 DB	 12
  00501	0c		 DB	 12
  00502	04		 DB	 4
  00503	0c		 DB	 12
  00504	0c		 DB	 12
  00505	0c		 DB	 12
  00506	0c		 DB	 12
  00507	05		 DB	 5
  00508	0c		 DB	 12
  00509	0c		 DB	 12
  0050a	0c		 DB	 12
  0050b	0c		 DB	 12
  0050c	0c		 DB	 12
  0050d	0c		 DB	 12
  0050e	0c		 DB	 12
  0050f	06		 DB	 6
  00510	0c		 DB	 12
  00511	0c		 DB	 12
  00512	0c		 DB	 12
  00513	0c		 DB	 12
  00514	0c		 DB	 12
  00515	0c		 DB	 12
  00516	0c		 DB	 12
  00517	0c		 DB	 12
  00518	0c		 DB	 12
  00519	0c		 DB	 12
  0051a	0c		 DB	 12
  0051b	0c		 DB	 12
  0051c	0c		 DB	 12
  0051d	0c		 DB	 12
  0051e	0c		 DB	 12
  0051f	0c		 DB	 12
  00520	0c		 DB	 12
  00521	0c		 DB	 12
  00522	0c		 DB	 12
  00523	0c		 DB	 12
  00524	0c		 DB	 12
  00525	0c		 DB	 12
  00526	0c		 DB	 12
  00527	0c		 DB	 12
  00528	0c		 DB	 12
  00529	0c		 DB	 12
  0052a	0c		 DB	 12
  0052b	0c		 DB	 12
  0052c	0c		 DB	 12
  0052d	0c		 DB	 12
  0052e	0c		 DB	 12
  0052f	0c		 DB	 12
  00530	0c		 DB	 12
  00531	0c		 DB	 12
  00532	0c		 DB	 12
  00533	0c		 DB	 12
  00534	0c		 DB	 12
  00535	0c		 DB	 12
  00536	0c		 DB	 12
  00537	0c		 DB	 12
  00538	0c		 DB	 12
  00539	0c		 DB	 12
  0053a	0c		 DB	 12
  0053b	0c		 DB	 12
  0053c	0c		 DB	 12
  0053d	0c		 DB	 12
  0053e	07		 DB	 7
  0053f	0c		 DB	 12
  00540	0c		 DB	 12
  00541	0c		 DB	 12
  00542	0c		 DB	 12
  00543	0c		 DB	 12
  00544	0c		 DB	 12
  00545	0c		 DB	 12
  00546	0c		 DB	 12
  00547	0c		 DB	 12
  00548	0c		 DB	 12
  00549	0c		 DB	 12
  0054a	0c		 DB	 12
  0054b	0c		 DB	 12
  0054c	0c		 DB	 12
  0054d	0c		 DB	 12
  0054e	0c		 DB	 12
  0054f	0c		 DB	 12
  00550	0c		 DB	 12
  00551	0c		 DB	 12
  00552	0c		 DB	 12
  00553	0c		 DB	 12
  00554	0c		 DB	 12
  00555	0c		 DB	 12
  00556	0c		 DB	 12
  00557	0c		 DB	 12
  00558	0c		 DB	 12
  00559	0c		 DB	 12
  0055a	0c		 DB	 12
  0055b	0c		 DB	 12
  0055c	0c		 DB	 12
  0055d	0c		 DB	 12
  0055e	0c		 DB	 12
  0055f	0c		 DB	 12
  00560	0c		 DB	 12
  00561	0c		 DB	 12
  00562	0c		 DB	 12
  00563	0c		 DB	 12
  00564	0c		 DB	 12
  00565	0c		 DB	 12
  00566	0c		 DB	 12
  00567	0c		 DB	 12
  00568	0c		 DB	 12
  00569	0c		 DB	 12
  0056a	0c		 DB	 12
  0056b	0c		 DB	 12
  0056c	0c		 DB	 12
  0056d	0c		 DB	 12
  0056e	0c		 DB	 12
  0056f	0c		 DB	 12
  00570	0c		 DB	 12
  00571	0c		 DB	 12
  00572	0c		 DB	 12
  00573	0c		 DB	 12
  00574	0c		 DB	 12
  00575	0c		 DB	 12
  00576	0c		 DB	 12
  00577	0c		 DB	 12
  00578	0c		 DB	 12
  00579	0c		 DB	 12
  0057a	0c		 DB	 12
  0057b	0c		 DB	 12
  0057c	08		 DB	 8
  0057d	0c		 DB	 12
  0057e	0c		 DB	 12
  0057f	0c		 DB	 12
  00580	0c		 DB	 12
  00581	0c		 DB	 12
  00582	0c		 DB	 12
  00583	0c		 DB	 12
  00584	0c		 DB	 12
  00585	0c		 DB	 12
  00586	0c		 DB	 12
  00587	0c		 DB	 12
  00588	0c		 DB	 12
  00589	0c		 DB	 12
  0058a	0c		 DB	 12
  0058b	0c		 DB	 12
  0058c	0c		 DB	 12
  0058d	0c		 DB	 12
  0058e	0c		 DB	 12
  0058f	0c		 DB	 12
  00590	0c		 DB	 12
  00591	0c		 DB	 12
  00592	0c		 DB	 12
  00593	0c		 DB	 12
  00594	0c		 DB	 12
  00595	0c		 DB	 12
  00596	0c		 DB	 12
  00597	0c		 DB	 12
  00598	0c		 DB	 12
  00599	0c		 DB	 12
  0059a	0c		 DB	 12
  0059b	0c		 DB	 12
  0059c	0c		 DB	 12
  0059d	0c		 DB	 12
  0059e	0c		 DB	 12
  0059f	0c		 DB	 12
  005a0	0c		 DB	 12
  005a1	0c		 DB	 12
  005a2	0c		 DB	 12
  005a3	0c		 DB	 12
  005a4	0c		 DB	 12
  005a5	0c		 DB	 12
  005a6	0c		 DB	 12
  005a7	0c		 DB	 12
  005a8	0c		 DB	 12
  005a9	0c		 DB	 12
  005aa	0c		 DB	 12
  005ab	0c		 DB	 12
  005ac	0c		 DB	 12
  005ad	0c		 DB	 12
  005ae	0c		 DB	 12
  005af	0c		 DB	 12
  005b0	0c		 DB	 12
  005b1	0c		 DB	 12
  005b2	0c		 DB	 12
  005b3	0c		 DB	 12
  005b4	0c		 DB	 12
  005b5	0c		 DB	 12
  005b6	0c		 DB	 12
  005b7	0c		 DB	 12
  005b8	0c		 DB	 12
  005b9	0c		 DB	 12
  005ba	0c		 DB	 12
  005bb	0c		 DB	 12
  005bc	0c		 DB	 12
  005bd	0c		 DB	 12
  005be	09		 DB	 9
  005bf	0c		 DB	 12
  005c0	0c		 DB	 12
  005c1	0c		 DB	 12
  005c2	0c		 DB	 12
  005c3	0c		 DB	 12
  005c4	0c		 DB	 12
  005c5	0c		 DB	 12
  005c6	0c		 DB	 12
  005c7	0c		 DB	 12
  005c8	0c		 DB	 12
  005c9	0c		 DB	 12
  005ca	0c		 DB	 12
  005cb	0c		 DB	 12
  005cc	0c		 DB	 12
  005cd	0c		 DB	 12
  005ce	0c		 DB	 12
  005cf	0c		 DB	 12
  005d0	0c		 DB	 12
  005d1	0c		 DB	 12
  005d2	0c		 DB	 12
  005d3	0c		 DB	 12
  005d4	0c		 DB	 12
  005d5	0c		 DB	 12
  005d6	0c		 DB	 12
  005d7	0c		 DB	 12
  005d8	0c		 DB	 12
  005d9	0c		 DB	 12
  005da	0c		 DB	 12
  005db	0c		 DB	 12
  005dc	0c		 DB	 12
  005dd	0c		 DB	 12
  005de	0a		 DB	 10
  005df	0b		 DB	 11
CTCI_ExecuteCCW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ctci.c
_TEXT	SEGMENT
pCTCBLK$ = 64
$T1 = 72
tv144 = 80
pDriveIP$ = 88
pGuestIP$ = 96
filename$ = 112
__$ArrayPad$ = 384
pDEVBLK$ = 416
ppszClass$ = 424
iBufLen$ = 432
pBuffer$ = 440
CTCI_Query PROC

; 628  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 629  :     char filename[ PATH_MAX + 1 ];      /* full path or just name    */
; 630  : 
; 631  :     CTCBLK*  pCTCBLK;
; 632  :     char*    pGuestIP;
; 633  :     char*    pDriveIP;
; 634  : 
; 635  :     BEGIN_DEVICE_CLASS_QUERY( "CTCA", pDEVBLK, ppszClass, iBufLen, pBuffer );

  0002d	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR ppszClass$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@CTCI_Query
  00038	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR ppszClass$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169308
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@CTCI_Query:
  0004a	48 83 bc 24 a0
	01 00 00 00	 cmp	 QWORD PTR pDEVBLK$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@CTCI_Query
  00055	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR ppszClass$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@CTCI_Query
  00060	83 bc 24 b0 01
	00 00 00	 cmp	 DWORD PTR iBufLen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@CTCI_Query
  0006a	48 83 bc 24 b8
	01 00 00 00	 cmp	 QWORD PTR pBuffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@CTCI_Query
$LN4@CTCI_Query:
  00075	e9 f2 01 00 00	 jmp	 $LN1@CTCI_Query
$LN3@CTCI_Query:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 6c		 je	 SHORT $LN5@CTCI_Query
  00091	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169314
  000c3	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  000c8	e8 00 00 00 00	 call	 strcmp
  000cd	85 c0		 test	 eax, eax
  000cf	75 2a		 jne	 SHORT $LN7@CTCI_Query
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	48 89 44 24 48	 mov	 QWORD PTR $T1[rsp], rax
  000df	48 81 7c 24 48
	05 01 00 00	 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  000e8	73 02		 jae	 SHORT $LN14@CTCI_Query
  000ea	eb 05		 jmp	 SHORT $LN15@CTCI_Query
$LN14@CTCI_Query:
  000ec	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN15@CTCI_Query:
  000f1	48 8b 44 24 48	 mov	 rax, QWORD PTR $T1[rsp]
  000f6	c6 44 04 70 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@CTCI_Query:
  000fb	eb 22		 jmp	 SHORT $LN6@CTCI_Query
$LN5@CTCI_Query:
  000fd	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00105	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0010b	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@CTCI_Query:

; 636  : 
; 637  :     pCTCBLK  = (CTCBLK*) pDEVBLK->dev_data;

  0011f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00127	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0012e	48 89 44 24 40	 mov	 QWORD PTR pCTCBLK$[rsp], rax

; 638  : 
; 639  :     if(!pCTCBLK)

  00133	48 83 7c 24 40
	00		 cmp	 QWORD PTR pCTCBLK$[rsp], 0
  00139	75 25		 jne	 SHORT $LN8@CTCI_Query

; 640  :     {
; 641  :         strlcpy(pBuffer,"*Uninitialized",iBufLen);

  0013b	48 63 84 24 b0
	01 00 00	 movsxd	 rax, DWORD PTR iBufLen$[rsp]
  00143	4c 8b c0	 mov	 r8, rax
  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169316
  0014d	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR pBuffer$[rsp]
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 642  :         return;

  0015b	e9 0c 01 00 00	 jmp	 $LN1@CTCI_Query
$LN8@CTCI_Query:

; 643  :     }
; 644  : 
; 645  :     if (strlen( pCTCBLK->szGuestIPAddr ))

  00160	48 8b 44 24 40	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00165	48 05 46 50 00
	00		 add	 rax, 20550		; 00005046H
  0016b	48 8b c8	 mov	 rcx, rax
  0016e	e8 00 00 00 00	 call	 strlen
  00173	48 85 c0	 test	 rax, rax
  00176	74 12		 je	 SHORT $LN9@CTCI_Query

; 646  :        pGuestIP = pCTCBLK->szGuestIPAddr;

  00178	48 8b 44 24 40	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0017d	48 05 46 50 00
	00		 add	 rax, 20550		; 00005046H
  00183	48 89 44 24 60	 mov	 QWORD PTR pGuestIP$[rsp], rax
  00188	eb 0c		 jmp	 SHORT $LN10@CTCI_Query
$LN9@CTCI_Query:

; 647  :     else
; 648  :        pGuestIP = "-";

  0018a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169319
  00191	48 89 44 24 60	 mov	 QWORD PTR pGuestIP$[rsp], rax
$LN10@CTCI_Query:

; 649  : 
; 650  :     if (strlen( pCTCBLK->szDriveIPAddr ))

  00196	48 8b 44 24 40	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0019b	48 05 66 50 00
	00		 add	 rax, 20582		; 00005066H
  001a1	48 8b c8	 mov	 rcx, rax
  001a4	e8 00 00 00 00	 call	 strlen
  001a9	48 85 c0	 test	 rax, rax
  001ac	74 12		 je	 SHORT $LN11@CTCI_Query

; 651  :        pDriveIP = pCTCBLK->szDriveIPAddr;

  001ae	48 8b 44 24 40	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  001b3	48 05 66 50 00
	00		 add	 rax, 20582		; 00005066H
  001b9	48 89 44 24 58	 mov	 QWORD PTR pDriveIP$[rsp], rax
  001be	eb 0c		 jmp	 SHORT $LN12@CTCI_Query
$LN11@CTCI_Query:

; 652  :     else
; 653  :        pDriveIP = "-";

  001c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169322
  001c7	48 89 44 24 58	 mov	 QWORD PTR pDriveIP$[rsp], rax
$LN12@CTCI_Query:

; 654  : 
; 655  :     snprintf( pBuffer, iBufLen, "CTCI %s/%s (%s)%s IO[%"PRIu64"]",

  001cc	48 8b 44 24 40	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  001d1	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  001d7	83 e0 01	 and	 eax, 1
  001da	85 c0		 test	 eax, eax
  001dc	74 0e		 je	 SHORT $LN16@CTCI_Query
  001de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169323
  001e5	48 89 44 24 50	 mov	 QWORD PTR tv144[rsp], rax
  001ea	eb 0c		 jmp	 SHORT $LN17@CTCI_Query
$LN16@CTCI_Query:
  001ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169324
  001f3	48 89 44 24 50	 mov	 QWORD PTR tv144[rsp], rax
$LN17@CTCI_Query:
  001f8	48 8b 44 24 40	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  001fd	48 05 c6 51 00
	00		 add	 rax, 20934		; 000051c6H
  00203	48 63 8c 24 b0
	01 00 00	 movsxd	 rcx, DWORD PTR iBufLen$[rsp]
  0020b	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00213	48 8b 92 00 06
	00 00		 mov	 rdx, QWORD PTR [rdx+1536]
  0021a	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  0021f	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv144[rsp]
  00224	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  00229	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0022e	48 8b 44 24 58	 mov	 rax, QWORD PTR pDriveIP$[rsp]
  00233	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00238	4c 8b 4c 24 60	 mov	 r9, QWORD PTR pGuestIP$[rsp]
  0023d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169325
  00244	48 8b d1	 mov	 rdx, rcx
  00247	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR pBuffer$[rsp]
  0024f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 656  :               pGuestIP,
; 657  :               pDriveIP,
; 658  :               pCTCBLK->szTUNIfName,
; 659  :               pCTCBLK->fDebug ? " -d" : "",
; 660  :               pDEVBLK->excps );
; 661  :     pBuffer[iBufLen-1] = '\0';

  00255	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR iBufLen$[rsp]
  0025c	ff c8		 dec	 eax
  0025e	48 98		 cdqe
  00260	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR pBuffer$[rsp]
  00268	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN1@CTCI_Query:
$LN13@CTCI_Query:

; 662  : 
; 663  :     return;
; 664  : }

  0026c	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00274	48 33 cc	 xor	 rcx, rsp
  00277	e8 00 00 00 00	 call	 __security_check_cookie
  0027c	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00283	c3		 ret	 0
CTCI_Query ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ctci.c
_TEXT	SEGMENT
tid$1 = 32
pCTCBLK$ = 40
pDEVBLK$ = 64
CTCI_Close PROC

; 581  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 582  :     /* DEVBLK* pDEVBLK2; */
; 583  :     PCTCBLK pCTCBLK  = (PCTCBLK)pDEVBLK->dev_data;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0000e	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00015	48 89 44 24 28	 mov	 QWORD PTR pCTCBLK$[rsp], rax

; 584  : 
; 585  :     // Close the device file (if not already closed)
; 586  :     if( pCTCBLK->fd >= 0 )

  0001a	48 8b 44 24 28	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  0001f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00022	7c 49		 jl	 SHORT $LN2@CTCI_Close

; 587  :     {
; 588  :         // PROGRAMMING NOTE: there's currently no way to interrupt
; 589  :         // the "CTCI_ReadThread"s TUNTAP_Read of the adapter. Thus
; 590  :         // we must simply wait for CTCI_ReadThread to eventually
; 591  :         // notice that we're doing a close (via our setting of the
; 592  :         // fCloseInProgress flag). Its TUNTAP_Read will eventually
; 593  :         // timeout after a few seconds (currently 5, which is dif-
; 594  :         // ferent than the DEF_NET_READ_TIMEOUT_SECS timeout value
; 595  :         // CTCI_Read function uses) and will then do the close of
; 596  :         // the adapter for us (TUNTAP_Close) so we don't have to.
; 597  :         // All we need to do is ask it to exit (via our setting of
; 598  :         // the fCloseInProgress flag) and then wait for it to exit
; 599  :         // (which, as stated, could take up to a max of 5 seconds).
; 600  : 
; 601  :         // All of this is simply because it's poor form to close a
; 602  :         // device from one thread while another thread is reading
; 603  :         // from it. Attempting to do so could trip a race condition
; 604  :         // wherein the internal i/o buffers used to process the
; 605  :         // read request could have been freed (by the close call)
; 606  :         // by the time the read request eventually gets serviced.
; 607  : 
; 608  :         TID tid = pCTCBLK->tid;

  00024	48 8b 44 24 28	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00029	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0002c	89 44 24 20	 mov	 DWORD PTR tid$1[rsp], eax

; 609  :         pCTCBLK->fCloseInProgress = 1;  // (ask read thread to exit)

  00030	48 8b 44 24 28	 mov	 rax, QWORD PTR pCTCBLK$[rsp]
  00035	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  0003b	83 c8 20	 or	 eax, 32			; 00000020H
  0003e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCTCBLK$[rsp]
  00043	89 81 3a 50 00
	00		 mov	 DWORD PTR [rcx+20538], eax

; 610  : #if defined(_MSVC_)
; 611  :         join_thread( tid, NULL );       // (wait for thread to end)

  00049	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169290
  00050	33 d2		 xor	 edx, edx
  00052	8b 4c 24 20	 mov	 ecx, DWORD PTR tid$1[rsp]
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_join_thread

; 612  : #endif
; 613  :         detach_thread( tid );           // (wait for thread to end)

  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169291
  00063	8b 4c 24 20	 mov	 ecx, DWORD PTR tid$1[rsp]
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_detach_thread
$LN2@CTCI_Close:

; 614  :     }
; 615  : 
; 616  :     pDEVBLK->fd = -1;           // indicate we're now closed

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00072	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 617  : 
; 618  :     return 0;

  0007c	33 c0		 xor	 eax, eax

; 619  : }

  0007e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00082	c3		 ret	 0
CTCI_Close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_ctci.c
_TEXT	SEGMENT
pDevCTCBLK$ = 112
rc$ = 120
wrk_guest_ip_addr$1 = 124
tv129 = 128
tv133 = 132
tv267 = 136
nIFFlags$ = 140
pWrkCTCBLK$ = 144
tv86 = 152
tv252 = 160
tv256 = 168
tv696 = 176
tv304 = 184
tv308 = 192
tv693 = 200
tv345 = 208
tv349 = 216
tv690 = 224
tv417 = 232
tv659 = 240
tt32ctl$2 = 248
wblk$ = 272
wrk_guest_mac_addr$3 = 21264
thread_name$ = 21272
buf$4 = 21304
__$ArrayPad$ = 21344
pDEVBLK$ = 21392
argc$ = 21400
argv$ = 21408
CTCI_Init PROC

; 156  : {

$LN71:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	b8 78 53 00 00	 mov	 eax, 21368		; 00005378H
  00015	e8 00 00 00 00	 call	 __chkstk
  0001a	48 2b e0	 sub	 rsp, rax
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 60
	53 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 157  :     CTCBLK          wblk;
; 158  :     PCTCBLK         pWrkCTCBLK = &wblk; // Working CTCBLK

  0002f	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR wblk$[rsp]
  00037	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pWrkCTCBLK$[rsp], rax

; 159  :     PCTCBLK         pDevCTCBLK = NULL;  // Device  CTCBLK

  0003f	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR pDevCTCBLK$[rsp], 0

; 160  :     int             rc = 0;             // Return code

  00048	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 161  :     int             nIFFlags;           // Interface flags
; 162  :     char            thread_name[32];    // CTCI_ReadThread
; 163  : 
; 164  :     nIFFlags =               // Interface flags

  00050	c7 84 24 8c 00
	00 00 03 00 00
	00		 mov	 DWORD PTR nIFFlags$[rsp], 3

; 165  :         0
; 166  :         | IFF_UP            // (interface is being enabled)
; 167  :         | IFF_BROADCAST     // (interface broadcast addr is valid)
; 168  :         ;
; 169  : 
; 170  : #if defined( TUNTAP_IFF_RUNNING_NEEDED )
; 171  : 
; 172  :     nIFFlags |=             // ADDITIONAL Interface flags
; 173  :         0
; 174  :         | IFF_RUNNING       // (interface is ALSO operational)
; 175  :         ;
; 176  : 
; 177  : #endif /* defined( TUNTAP_IFF_RUNNING_NEEDED ) */
; 178  : 
; 179  :     pDEVBLK->devtype = 0x3088;

  0005b	b8 88 30 00 00	 mov	 eax, 12424		; 00003088H
  00060	48 8b 8c 24 90
	53 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00068	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax

; 180  :     pDEVBLK->excps = 0;

  0006c	48 8b 84 24 90
	53 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00074	48 c7 80 00 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1536], 0

; 181  : 
; 182  :     // CTC is a group device
; 183  :     if(!group_device(pDEVBLK, CTC_DEVICES_IN_GROUP))

  0007f	ba 02 00 00 00	 mov	 edx, 2
  00084	48 8b 8c 24 90
	53 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_group_device
  00092	85 c0		 test	 eax, eax
  00094	75 07		 jne	 SHORT $LN41@CTCI_Init

; 184  :         return 0;

  00096	33 c0		 xor	 eax, eax
  00098	e9 1f 0e 00 00	 jmp	 $LN1@CTCI_Init
$LN41@CTCI_Init:

; 185  : 
; 186  :     // Housekeeping
; 187  :     memset( pWrkCTCBLK, 0, sizeof( CTCBLK ) );

  0009d	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR pWrkCTCBLK$[rsp]
  000a5	33 c0		 xor	 eax, eax
  000a7	b9 f6 51 00 00	 mov	 ecx, 20982		; 000051f6H
  000ac	f3 aa		 rep stosb

; 188  : 
; 189  :     // Parse configuration file statement
; 190  :     if( ParseArgs( pDEVBLK, pWrkCTCBLK, argc, (char**)argv ) != 0 )

  000ae	4c 8b 8c 24 a0
	53 00 00	 mov	 r9, QWORD PTR argv$[rsp]
  000b6	44 8b 84 24 98
	53 00 00	 mov	 r8d, DWORD PTR argc$[rsp]
  000be	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pWrkCTCBLK$[rsp]
  000c6	48 8b 8c 24 90
	53 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000ce	e8 00 00 00 00	 call	 ParseArgs
  000d3	85 c0		 test	 eax, eax
  000d5	74 0a		 je	 SHORT $LN42@CTCI_Init

; 191  :         return -1;

  000d7	b8 ff ff ff ff	 mov	 eax, -1
  000dc	e9 db 0d 00 00	 jmp	 $LN1@CTCI_Init
$LN42@CTCI_Init:

; 192  : 
; 193  :     // Allocate the device CTCBLK and copy parsed information.
; 194  : 
; 195  :     pDevCTCBLK = malloc( sizeof( CTCBLK ) );

  000e1	b9 f6 51 00 00	 mov	 ecx, 20982		; 000051f6H
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000ec	48 89 44 24 70	 mov	 QWORD PTR pDevCTCBLK$[rsp], rax

; 196  : 
; 197  :     if( !pDevCTCBLK )

  000f1	48 83 7c 24 70
	00		 cmp	 QWORD PTR pDevCTCBLK$[rsp], 0
  000f7	0f 85 eb 00 00
	00		 jne	 $LN43@CTCI_Init

; 198  :     {
; 199  :         char buf[40];
; 200  :         MSGBUF(buf, "malloc(%d)", (int)sizeof(CTCBLK));

  000fd	41 b9 f6 51 00
	00		 mov	 r9d, 20982		; 000051f6H
  00103	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169113
  0010a	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0010f	48 8d 8c 24 38
	53 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 201  :         // "%1d:%04X %s: error in function %s: %s"
; 202  :         WRMSG(HHC00900, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTCI", buf, strerror(errno) );

  0011d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00123	8b 08		 mov	 ecx, DWORD PTR [rax]
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0012b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv86[rsp], rax
  00133	48 8b 8c 24 90
	53 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0013b	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0013f	89 8c 24 80 00
	00 00		 mov	 DWORD PTR tv129[rsp], ecx
  00146	48 8b 94 24 90
	53 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0014e	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00152	d1 fa		 sar	 edx, 1
  00154	89 94 24 84 00
	00 00		 mov	 DWORD PTR tv133[rsp], edx
  0015b	b9 01 00 00 00	 mov	 ecx, 1
  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00166	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv86[rsp]
  0016e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00173	48 8d 8c 24 38
	53 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  0017b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169114
  00187	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0018c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv129[rsp]
  00193	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00197	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv133[rsp]
  0019e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169115
  001a9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169116
  001b5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bf	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169117
  001cc	ba ca 00 00 00	 mov	 edx, 202		; 000000caH
  001d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169118
  001d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 203  :         return -1;

  001de	b8 ff ff ff ff	 mov	 eax, -1
  001e3	e9 d4 0c 00 00	 jmp	 $LN1@CTCI_Init
$LN43@CTCI_Init:

; 204  :     }
; 205  : 
; 206  :     memcpy( pDevCTCBLK, pWrkCTCBLK, sizeof( CTCBLK ) );

  001e8	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pDevCTCBLK$[rsp]
  001ed	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR pWrkCTCBLK$[rsp]
  001f5	b9 f6 51 00 00	 mov	 ecx, 20982		; 000051f6H
  001fa	f3 a4		 rep movsb

; 207  : 
; 208  :     // New format has only one device statement for both addresses
; 209  :     // We need to dynamically allocate the read device block
; 210  : 
; 211  :     pDevCTCBLK->pDEVBLK[ CTC_READ_SUBCHANN  ] = pDEVBLK->group->memdev[0];

  001fc	48 8b 84 24 90
	53 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00204	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00208	b9 08 00 00 00	 mov	 ecx, 8
  0020d	48 6b c9 00	 imul	 rcx, rcx, 0
  00211	ba 08 00 00 00	 mov	 edx, 8
  00216	48 6b d2 00	 imul	 rdx, rdx, 0
  0021a	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pDevCTCBLK$[rsp]
  0021f	48 8b 44 08 10	 mov	 rax, QWORD PTR [rax+rcx+16]
  00224	48 89 44 17 0c	 mov	 QWORD PTR [rdi+rdx+12], rax

; 212  :     pDevCTCBLK->pDEVBLK[ CTC_WRITE_SUBCHANN ] = pDEVBLK->group->memdev[1];

  00229	48 8b 84 24 90
	53 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00231	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00235	b9 08 00 00 00	 mov	 ecx, 8
  0023a	48 6b c9 01	 imul	 rcx, rcx, 1
  0023e	ba 08 00 00 00	 mov	 edx, 8
  00243	48 6b d2 01	 imul	 rdx, rdx, 1
  00247	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pDevCTCBLK$[rsp]
  0024c	48 8b 44 08 10	 mov	 rax, QWORD PTR [rax+rcx+16]
  00251	48 89 44 17 0c	 mov	 QWORD PTR [rdi+rdx+12], rax

; 213  : 
; 214  :     pDevCTCBLK->pDEVBLK[ CTC_READ_SUBCHANN  ]->dev_data = pDevCTCBLK;

  00256	b8 08 00 00 00	 mov	 eax, 8
  0025b	48 6b c0 00	 imul	 rax, rax, 0
  0025f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00264	48 8b 44 01 0c	 mov	 rax, QWORD PTR [rcx+rax+12]
  00269	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  0026e	48 89 88 08 06
	00 00		 mov	 QWORD PTR [rax+1544], rcx

; 215  :     pDevCTCBLK->pDEVBLK[ CTC_WRITE_SUBCHANN ]->dev_data = pDevCTCBLK;

  00275	b8 08 00 00 00	 mov	 eax, 8
  0027a	48 6b c0 01	 imul	 rax, rax, 1
  0027e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00283	48 8b 44 01 0c	 mov	 rax, QWORD PTR [rcx+rax+12]
  00288	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  0028d	48 89 88 08 06
	00 00		 mov	 QWORD PTR [rax+1544], rcx

; 216  : 
; 217  :     SetSIDInfo( pDevCTCBLK->pDEVBLK[ CTC_READ_SUBCHANN  ], 0x3088, 0x08, 0x3088, 0x01 );

  00294	b8 08 00 00 00	 mov	 eax, 8
  00299	48 6b c0 00	 imul	 rax, rax, 0
  0029d	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  002a2	66 41 b9 88 30	 mov	 r9w, 12424		; 00003088H
  002a7	41 b0 08	 mov	 r8b, 8
  002aa	66 ba 88 30	 mov	 dx, 12424		; 00003088H
  002ae	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  002b3	48 8b 4c 01 0c	 mov	 rcx, QWORD PTR [rcx+rax+12]
  002b8	e8 00 00 00 00	 call	 SetSIDInfo

; 218  :     SetSIDInfo( pDevCTCBLK->pDEVBLK[ CTC_WRITE_SUBCHANN ], 0x3088, 0x08, 0x3088, 0x01 );

  002bd	b8 08 00 00 00	 mov	 eax, 8
  002c2	48 6b c0 01	 imul	 rax, rax, 1
  002c6	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  002cb	66 41 b9 88 30	 mov	 r9w, 12424		; 00003088H
  002d0	41 b0 08	 mov	 r8b, 8
  002d3	66 ba 88 30	 mov	 dx, 12424		; 00003088H
  002d7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  002dc	48 8b 4c 01 0c	 mov	 rcx, QWORD PTR [rcx+rax+12]
  002e1	e8 00 00 00 00	 call	 SetSIDInfo

; 219  : 
; 220  :     pDevCTCBLK->pDEVBLK[ CTC_READ_SUBCHANN  ]->ctctype  = CTC_CTCI;

  002e6	b8 08 00 00 00	 mov	 eax, 8
  002eb	48 6b c0 00	 imul	 rax, rax, 0
  002ef	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  002f4	48 8b 44 01 0c	 mov	 rax, QWORD PTR [rcx+rax+12]
  002f9	c6 80 1c 07 00
	00 02		 mov	 BYTE PTR [rax+1820], 2

; 221  :     pDevCTCBLK->pDEVBLK[ CTC_READ_SUBCHANN  ]->ctcxmode = 1;

  00300	b8 08 00 00 00	 mov	 eax, 8
  00305	48 6b c0 00	 imul	 rax, rax, 0
  00309	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  0030e	48 8b 44 01 0c	 mov	 rax, QWORD PTR [rcx+rax+12]
  00313	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00319	83 c8 01	 or	 eax, 1
  0031c	b9 08 00 00 00	 mov	 ecx, 8
  00321	48 6b c9 00	 imul	 rcx, rcx, 0
  00325	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDevCTCBLK$[rsp]
  0032a	48 8b 4c 0a 0c	 mov	 rcx, QWORD PTR [rdx+rcx+12]
  0032f	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 222  : 
; 223  :     pDevCTCBLK->pDEVBLK[ CTC_WRITE_SUBCHANN ]->ctctype  = CTC_CTCI;

  00335	b8 08 00 00 00	 mov	 eax, 8
  0033a	48 6b c0 01	 imul	 rax, rax, 1
  0033e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00343	48 8b 44 01 0c	 mov	 rax, QWORD PTR [rcx+rax+12]
  00348	c6 80 1c 07 00
	00 02		 mov	 BYTE PTR [rax+1820], 2

; 224  :     pDevCTCBLK->pDEVBLK[ CTC_WRITE_SUBCHANN ]->ctcxmode = 1;

  0034f	b8 08 00 00 00	 mov	 eax, 8
  00354	48 6b c0 01	 imul	 rax, rax, 1
  00358	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  0035d	48 8b 44 01 0c	 mov	 rax, QWORD PTR [rcx+rax+12]
  00362	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00368	83 c8 01	 or	 eax, 1
  0036b	b9 08 00 00 00	 mov	 ecx, 8
  00370	48 6b c9 01	 imul	 rcx, rcx, 1
  00374	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDevCTCBLK$[rsp]
  00379	48 8b 4c 0a 0c	 mov	 rcx, QWORD PTR [rdx+rcx+12]
  0037e	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 225  : 
; 226  :     pDevCTCBLK->sMTU                = atoi( pDevCTCBLK->szMTU );

  00384	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00389	48 05 a6 50 00
	00		 add	 rax, 20646		; 000050a6H
  0038f	48 8b c8	 mov	 rcx, rax
  00392	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00398	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  0039d	66 89 81 20 50
	00 00		 mov	 WORD PTR [rcx+20512], ax

; 227  :     pDevCTCBLK->iMaxFrameBufferSize = sizeof(pDevCTCBLK->bFrameBuffer);

  003a4	b8 00 50 00 00	 mov	 eax, 20480		; 00005000H
  003a9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  003ae	66 89 41 1c	 mov	 WORD PTR [rcx+28], ax

; 228  : 
; 229  :     initialize_lock( &pDevCTCBLK->Lock );

  003b2	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  003b7	48 05 22 50 00
	00		 add	 rax, 20514		; 00005022H
  003bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169119
  003c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169120
  003cb	48 8b c8	 mov	 rcx, rax
  003ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 230  :     initialize_lock( &pDevCTCBLK->EventLock );

  003d4	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  003d9	48 05 2a 50 00
	00		 add	 rax, 20522		; 0000502aH
  003df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169121
  003e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169122
  003ed	48 8b c8	 mov	 rcx, rax
  003f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 231  :     initialize_condition( &pDevCTCBLK->Event );

  003f6	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  003fb	48 05 32 50 00
	00		 add	 rax, 20530		; 00005032H
  00401	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169123
  00408	48 8b c8	 mov	 rcx, rax
  0040b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 232  : 
; 233  :     // Give both Herc devices a reasonable name...
; 234  : 
; 235  :     STRLCPY( pDevCTCBLK->pDEVBLK[ CTC_READ_SUBCHANN  ]->filename, pDevCTCBLK->szTUNCharDevName );

  00411	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00416	48 05 c6 50 00
	00		 add	 rax, 20678		; 000050c6H
  0041c	b9 08 00 00 00	 mov	 ecx, 8
  00421	48 6b c9 00	 imul	 rcx, rcx, 0
  00425	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDevCTCBLK$[rsp]
  0042a	48 8b 4c 0a 0c	 mov	 rcx, QWORD PTR [rdx+rcx+12]
  0042f	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00436	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  0043c	48 8b d0	 mov	 rdx, rax
  0043f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 236  :     STRLCPY( pDevCTCBLK->pDEVBLK[ CTC_WRITE_SUBCHANN ]->filename, pDevCTCBLK->szTUNCharDevName );

  00445	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  0044a	48 05 c6 50 00
	00		 add	 rax, 20678		; 000050c6H
  00450	b9 08 00 00 00	 mov	 ecx, 8
  00455	48 6b c9 01	 imul	 rcx, rcx, 1
  00459	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDevCTCBLK$[rsp]
  0045e	48 8b 4c 0a 0c	 mov	 rcx, QWORD PTR [rdx+rcx+12]
  00463	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0046a	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00470	48 8b d0	 mov	 rdx, rax
  00473	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 237  : 
; 238  :     /* It  might  be  tempting  to  add IFF_TUN_EXCL to the flags to */
; 239  :     /* avoid  a  race,  but it does not work like open exclusive; it */
; 240  :     /* would appear that the bit is permanent so that hercifc cannot */
; 241  :     /* configure the interface.                                      */
; 242  :     rc = TUNTAP_CreateInterface( pDevCTCBLK->szTUNCharDevName,

  00479	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  0047e	48 05 c6 51 00
	00		 add	 rax, 20934		; 000051c6H
  00484	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00489	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDevCTCBLK$[rsp]
  0048e	48 81 c2 c6 50
	00 00		 add	 rdx, 20678		; 000050c6H
  00495	48 89 94 24 a0
	00 00 00	 mov	 QWORD PTR tv252[rsp], rdx
  0049d	4c 8b c8	 mov	 r9, rax
  004a0	4c 8b c1	 mov	 r8, rcx
  004a3	ba 01 10 00 00	 mov	 edx, 4097		; 00001001H
  004a8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv252[rsp]
  004b0	48 8b c8	 mov	 rcx, rax
  004b3	e8 00 00 00 00	 call	 TUNTAP_CreateInterface
  004b8	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 243  : #if defined(BUILD_HERCIFC)
; 244  :                                  (pDevCTCBLK->fPreconfigured ? IFF_NO_HERCIFC : 0) |
; 245  : #endif // __HERCIFC_H_
; 246  :                                  IFF_TUN | IFF_NO_PI,
; 247  :                                  &pDevCTCBLK->fd,
; 248  :                                  pDevCTCBLK->szTUNIfName );
; 249  : 
; 250  :     if( rc < 0 ) return -1;

  004bc	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  004c1	7d 0a		 jge	 SHORT $LN44@CTCI_Init
  004c3	b8 ff ff ff ff	 mov	 eax, -1
  004c8	e9 ef 09 00 00	 jmp	 $LN1@CTCI_Init
$LN44@CTCI_Init:

; 251  : 
; 252  :     // HHC00901 "%1d:%04X %s: interface %s, type %s opened"
; 253  :     WRMSG(HHC00901, "I", SSID_TO_LCSS(pDevCTCBLK->pDEVBLK[CTC_READ_SUBCHANN]->ssid), pDevCTCBLK->pDEVBLK[CTC_READ_SUBCHANN]->devnum,

  004cd	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  004d2	48 05 c6 51 00
	00		 add	 rax, 20934		; 000051c6H
  004d8	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv256[rsp], rax
  004e0	b9 08 00 00 00	 mov	 ecx, 8
  004e5	48 6b c9 00	 imul	 rcx, rcx, 0
  004e9	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDevCTCBLK$[rsp]
  004ee	48 8b 4c 0a 0c	 mov	 rcx, QWORD PTR [rdx+rcx+12]
  004f3	48 89 8c 24 b0
	00 00 00	 mov	 QWORD PTR tv696[rsp], rcx
  004fb	ba 08 00 00 00	 mov	 edx, 8
  00500	48 6b d2 00	 imul	 rdx, rdx, 0
  00504	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pDevCTCBLK$[rsp]
  00509	48 8b 54 17 0c	 mov	 rdx, QWORD PTR [rdi+rdx+12]
  0050e	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00512	89 94 24 88 00
	00 00		 mov	 DWORD PTR tv267[rsp], edx
  00519	bf 08 00 00 00	 mov	 edi, 8
  0051e	48 6b ff 00	 imul	 rdi, rdi, 0
  00522	48 8b 74 24 70	 mov	 rsi, QWORD PTR pDevCTCBLK$[rsp]
  00527	48 8b 7c 3e 0c	 mov	 rdi, QWORD PTR [rsi+rdi+12]
  0052c	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00530	d1 ff		 sar	 edi, 1
  00532	b9 01 00 00 00	 mov	 ecx, 1
  00537	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0053d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169125
  00544	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00549	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv256[rsp]
  00551	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00556	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv696[rsp]
  0055e	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00562	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00567	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv267[rsp]
  0056e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00572	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00576	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169126
  0057d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00582	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169127
  00589	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0058e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00593	41 b9 03 00 00
	00		 mov	 r9d, 3
  00599	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169128
  005a0	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  005a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169129
  005ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 254  :                          pDevCTCBLK->pDEVBLK[CTC_READ_SUBCHANN]->typname,
; 255  :                          pDevCTCBLK->szTUNIfName, "TUN");
; 256  : 
; 257  :     if (!pDevCTCBLK->fPreconfigured)

  005b2	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  005b7	8b 80 3a 50 00
	00		 mov	 eax, DWORD PTR [rax+20538]
  005bd	c1 e8 06	 shr	 eax, 6
  005c0	83 e0 01	 and	 eax, 1
  005c3	85 c0		 test	 eax, eax
  005c5	0f 85 7d 07 00
	00		 jne	 $LN45@CTCI_Init

; 258  :     {
; 259  : 
; 260  : #if defined(OPTION_W32_CTCI)
; 261  :         // Set the specified driver/dll i/o buffer sizes..
; 262  :         {
; 263  :             struct tt32ctl tt32ctl;
; 264  : 
; 265  :             memset( &tt32ctl, 0, sizeof(tt32ctl) );

  005cb	48 8d 84 24 f8
	00 00 00	 lea	 rax, QWORD PTR tt32ctl$2[rsp]
  005d3	48 8b f8	 mov	 rdi, rax
  005d6	33 c0		 xor	 eax, eax
  005d8	b9 14 00 00 00	 mov	 ecx, 20
  005dd	f3 aa		 rep stosb

; 266  :             STRLCPY( tt32ctl.tt32ctl_name, pDevCTCBLK->szTUNIfName );

  005df	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  005e4	48 05 c6 51 00
	00		 add	 rax, 20934		; 000051c6H
  005ea	41 b8 10 00 00
	00		 mov	 r8d, 16
  005f0	48 8b d0	 mov	 rdx, rax
  005f3	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR tt32ctl$2[rsp]
  005fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 267  : 
; 268  :             tt32ctl.tt32ctl_devbuffsize = pDevCTCBLK->iKernBuff;

  00601	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00606	8b 80 3e 50 00
	00		 mov	 eax, DWORD PTR [rax+20542]
  0060c	89 84 24 08 01
	00 00		 mov	 DWORD PTR tt32ctl$2[rsp+16], eax

; 269  :             if( TUNTAP_IOCtl( pDevCTCBLK->fd, TT32SDEVBUFF, (char*)&tt32ctl ) != 0  )

  00613	4c 8d 84 24 f8
	00 00 00	 lea	 r8, QWORD PTR tt32ctl$2[rsp]
  0061b	ba dc 54 04 80	 mov	 edx, -2147199780	; ffffffff800454dcH
  00620	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00625	8b 08		 mov	 ecx, DWORD PTR [rax]
  00627	e8 00 00 00 00	 call	 tt32_ioctl
  0062c	85 c0		 test	 eax, eax
  0062e	0f 84 fb 00 00
	00		 je	 $LN46@CTCI_Init

; 270  :             {
; 271  :                 // "%1d:%04X %s: ioctl '%s' failed for device '%s': '%s'"
; 272  :                 WRMSG(HHC00902, "W", SSID_TO_LCSS(pDevCTCBLK->pDEVBLK[CTC_READ_SUBCHANN]->ssid), pDevCTCBLK->pDEVBLK[CTC_READ_SUBCHANN]->devnum,

  00634	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0063a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0063c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00642	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv304[rsp], rax
  0064a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  0064f	48 81 c1 c6 51
	00 00		 add	 rcx, 20934		; 000051c6H
  00656	48 89 8c 24 c0
	00 00 00	 mov	 QWORD PTR tv308[rsp], rcx
  0065e	ba 08 00 00 00	 mov	 edx, 8
  00663	48 6b d2 00	 imul	 rdx, rdx, 0
  00667	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pDevCTCBLK$[rsp]
  0066c	48 8b 54 17 0c	 mov	 rdx, QWORD PTR [rdi+rdx+12]
  00671	48 89 94 24 c8
	00 00 00	 mov	 QWORD PTR tv693[rsp], rdx
  00679	bf 08 00 00 00	 mov	 edi, 8
  0067e	48 6b ff 00	 imul	 rdi, rdi, 0
  00682	48 8b 74 24 70	 mov	 rsi, QWORD PTR pDevCTCBLK$[rsp]
  00687	48 8b 7c 3e 0c	 mov	 rdi, QWORD PTR [rsi+rdi+12]
  0068c	0f b7 7f 48	 movzx	 edi, WORD PTR [rdi+72]
  00690	be 08 00 00 00	 mov	 esi, 8
  00695	48 6b f6 00	 imul	 rsi, rsi, 0
  00699	4c 8b 44 24 70	 mov	 r8, QWORD PTR pDevCTCBLK$[rsp]
  0069e	49 8b 74 30 0c	 mov	 rsi, QWORD PTR [r8+rsi+12]
  006a3	0f b7 76 44	 movzx	 esi, WORD PTR [rsi+68]
  006a7	d1 fe		 sar	 esi, 1
  006a9	b9 01 00 00 00	 mov	 ecx, 1
  006ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006b4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv304[rsp]
  006bc	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  006c1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv308[rsp]
  006c9	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  006ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169132
  006d5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006da	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv693[rsp]
  006e2	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  006e6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006eb	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  006ef	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  006f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169133
  006fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169134
  00706	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0070b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00710	41 b9 03 00 00
	00		 mov	 r9d, 3
  00716	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169135
  0071d	ba 12 01 00 00	 mov	 edx, 274		; 00000112H
  00722	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169136
  00729	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN46@CTCI_Init:

; 273  :                       pDevCTCBLK->pDEVBLK[CTC_READ_SUBCHANN]->typname,
; 274  :                       "TT32SDEVBUFF", pDevCTCBLK->szTUNIfName, strerror( errno ) );
; 275  :             }
; 276  : 
; 277  :             tt32ctl.tt32ctl_iobuffsize = pDevCTCBLK->iIOBuff;

  0072f	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00734	8b 80 42 50 00
	00		 mov	 eax, DWORD PTR [rax+20546]
  0073a	89 84 24 08 01
	00 00		 mov	 DWORD PTR tt32ctl$2[rsp+16], eax

; 278  :             if( TUNTAP_IOCtl( pDevCTCBLK->fd, TT32SIOBUFF, (char*)&tt32ctl ) != 0  )

  00741	4c 8d 84 24 f8
	00 00 00	 lea	 r8, QWORD PTR tt32ctl$2[rsp]
  00749	ba dd 54 04 80	 mov	 edx, -2147199779	; ffffffff800454ddH
  0074e	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00753	8b 08		 mov	 ecx, DWORD PTR [rax]
  00755	e8 00 00 00 00	 call	 tt32_ioctl
  0075a	85 c0		 test	 eax, eax
  0075c	0f 84 fb 00 00
	00		 je	 $LN47@CTCI_Init

; 279  :             {
; 280  :                 // "%1d:%04X %s: ioctl '%s' failed for device '%s': '%s'"
; 281  :                 WRMSG(HHC00902, "W", SSID_TO_LCSS(pDevCTCBLK->pDEVBLK[CTC_READ_SUBCHANN]->ssid), pDevCTCBLK->pDEVBLK[CTC_READ_SUBCHANN]->devnum,

  00762	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00768	8b 08		 mov	 ecx, DWORD PTR [rax]
  0076a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00770	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv345[rsp], rax
  00778	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  0077d	48 81 c1 c6 51
	00 00		 add	 rcx, 20934		; 000051c6H
  00784	48 89 8c 24 d8
	00 00 00	 mov	 QWORD PTR tv349[rsp], rcx
  0078c	ba 08 00 00 00	 mov	 edx, 8
  00791	48 6b d2 00	 imul	 rdx, rdx, 0
  00795	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pDevCTCBLK$[rsp]
  0079a	48 8b 54 17 0c	 mov	 rdx, QWORD PTR [rdi+rdx+12]
  0079f	48 89 94 24 e0
	00 00 00	 mov	 QWORD PTR tv690[rsp], rdx
  007a7	bf 08 00 00 00	 mov	 edi, 8
  007ac	48 6b ff 00	 imul	 rdi, rdi, 0
  007b0	48 8b 74 24 70	 mov	 rsi, QWORD PTR pDevCTCBLK$[rsp]
  007b5	48 8b 7c 3e 0c	 mov	 rdi, QWORD PTR [rsi+rdi+12]
  007ba	0f b7 7f 48	 movzx	 edi, WORD PTR [rdi+72]
  007be	be 08 00 00 00	 mov	 esi, 8
  007c3	48 6b f6 00	 imul	 rsi, rsi, 0
  007c7	4c 8b 44 24 70	 mov	 r8, QWORD PTR pDevCTCBLK$[rsp]
  007cc	49 8b 74 30 0c	 mov	 rsi, QWORD PTR [r8+rsi+12]
  007d1	0f b7 76 44	 movzx	 esi, WORD PTR [rsi+68]
  007d5	d1 fe		 sar	 esi, 1
  007d7	b9 01 00 00 00	 mov	 ecx, 1
  007dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007e2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv345[rsp]
  007ea	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  007ef	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv349[rsp]
  007f7	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  007fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169138
  00803	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00808	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv690[rsp]
  00810	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00814	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00819	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  0081d	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  00821	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169139
  00828	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0082d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169140
  00834	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00839	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0083e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00844	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169141
  0084b	ba 1b 01 00 00	 mov	 edx, 283		; 0000011bH
  00850	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169142
  00857	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN47@CTCI_Init:

; 282  :                       pDevCTCBLK->pDEVBLK[CTC_READ_SUBCHANN]->typname,
; 283  :                       "TT32SIOBUFF", pDevCTCBLK->szTUNIfName, strerror( errno ) );
; 284  :             }
; 285  :         }
; 286  : 
; 287  : #ifdef OPTION_TUNTAP_SETMACADDR
; 288  :         if( !pDevCTCBLK->szMACAddress[0] )   // (if MAC address unspecified)

  0085d	b8 01 00 00 00	 mov	 eax, 1
  00862	48 6b c0 00	 imul	 rax, rax, 0
  00866	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  0086b	0f be 84 01 d6
	51 00 00	 movsx	 eax, BYTE PTR [rcx+rax+20950]
  00873	85 c0		 test	 eax, eax
  00875	0f 85 e5 00 00
	00		 jne	 $LN48@CTCI_Init

; 289  :         {
; 290  :             in_addr_t  wrk_guest_ip_addr;
; 291  :             MAC        wrk_guest_mac_addr;
; 292  : 
; 293  :             if ((in_addr_t)-1 != (wrk_guest_ip_addr = inet_addr( pDevCTCBLK->szGuestIPAddr )))

  0087b	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00880	48 05 46 50 00
	00		 add	 rax, 20550		; 00005046H
  00886	48 8b c8	 mov	 rcx, rax
  00889	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_addr
  0088f	89 44 24 7c	 mov	 DWORD PTR wrk_guest_ip_addr$1[rsp], eax
  00893	83 7c 24 7c ff	 cmp	 DWORD PTR wrk_guest_ip_addr$1[rsp], -1 ; ffffffffH
  00898	0f 84 c2 00 00
	00		 je	 $LN49@CTCI_Init

; 294  :             {
; 295  :                 build_herc_iface_mac ( wrk_guest_mac_addr, (const BYTE*) &wrk_guest_ip_addr );

  0089e	48 8d 54 24 7c	 lea	 rdx, QWORD PTR wrk_guest_ip_addr$1[rsp]
  008a3	48 8d 8c 24 10
	53 00 00	 lea	 rcx, QWORD PTR wrk_guest_mac_addr$3[rsp]
  008ab	e8 00 00 00 00	 call	 build_herc_iface_mac

; 296  : 
; 297  :                 MSGBUF( pDevCTCBLK->szMACAddress,

  008b0	b8 01 00 00 00	 mov	 eax, 1
  008b5	48 6b c0 05	 imul	 rax, rax, 5
  008b9	0f b6 84 04 10
	53 00 00	 movzx	 eax, BYTE PTR wrk_guest_mac_addr$3[rsp+rax]
  008c1	b9 01 00 00 00	 mov	 ecx, 1
  008c6	48 6b c9 04	 imul	 rcx, rcx, 4
  008ca	0f b6 8c 0c 10
	53 00 00	 movzx	 ecx, BYTE PTR wrk_guest_mac_addr$3[rsp+rcx]
  008d2	ba 01 00 00 00	 mov	 edx, 1
  008d7	48 6b d2 03	 imul	 rdx, rdx, 3
  008db	0f b6 94 14 10
	53 00 00	 movzx	 edx, BYTE PTR wrk_guest_mac_addr$3[rsp+rdx]
  008e3	bf 01 00 00 00	 mov	 edi, 1
  008e8	48 6b ff 02	 imul	 rdi, rdi, 2
  008ec	0f b6 bc 3c 10
	53 00 00	 movzx	 edi, BYTE PTR wrk_guest_mac_addr$3[rsp+rdi]
  008f4	be 01 00 00 00	 mov	 esi, 1
  008f9	48 6b f6 01	 imul	 rsi, rsi, 1
  008fd	0f b6 b4 34 10
	53 00 00	 movzx	 esi, BYTE PTR wrk_guest_mac_addr$3[rsp+rsi]
  00905	41 b8 01 00 00
	00		 mov	 r8d, 1
  0090b	4d 6b c0 00	 imul	 r8, r8, 0
  0090f	46 0f b6 84 04
	10 53 00 00	 movzx	 r8d, BYTE PTR wrk_guest_mac_addr$3[rsp+r8]
  00918	4c 8b 4c 24 70	 mov	 r9, QWORD PTR pDevCTCBLK$[rsp]
  0091d	49 81 c1 d6 51
	00 00		 add	 r9, 20950		; 000051d6H
  00924	4c 89 8c 24 e8
	00 00 00	 mov	 QWORD PTR tv417[rsp], r9
  0092c	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00930	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00934	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00938	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  0093c	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  00940	45 8b c8	 mov	 r9d, r8d
  00943	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169145
  0094a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0094f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv417[rsp]
  00957	48 8b c8	 mov	 rcx, rax
  0095a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN49@CTCI_Init:
$LN48@CTCI_Init:
$LN4@CTCI_Init:

; 298  :                         "%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X"
; 299  :                         ,wrk_guest_mac_addr[0]
; 300  :                         ,wrk_guest_mac_addr[1]
; 301  :                         ,wrk_guest_mac_addr[2]
; 302  :                         ,wrk_guest_mac_addr[3]
; 303  :                         ,wrk_guest_mac_addr[4]
; 304  :                         ,wrk_guest_mac_addr[5] );
; 305  :             }
; 306  :         }
; 307  : 
; 308  :         TRACE

  00960	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00965	48 05 d6 51 00
	00		 add	 rax, 20950		; 000051d6H
  0096b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00970	48 81 c1 46 50
	00 00		 add	 rcx, 20550		; 00005046H
  00977	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDevCTCBLK$[rsp]
  0097c	48 81 c2 c6 51
	00 00		 add	 rdx, 20934		; 000051c6H
  00983	bf 08 00 00 00	 mov	 edi, 8
  00988	48 6b ff 00	 imul	 rdi, rdi, 0
  0098c	48 8b 74 24 70	 mov	 rsi, QWORD PTR pDevCTCBLK$[rsp]
  00991	48 8b 7c 3e 0c	 mov	 rdi, QWORD PTR [rsi+rdi+12]
  00996	0f b7 7f 48	 movzx	 edi, WORD PTR [rdi+72]
  0099a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0099f	4c 8b c9	 mov	 r9, rcx
  009a2	4c 8b c2	 mov	 r8, rdx
  009a5	8b d7		 mov	 edx, edi
  009a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169146
  009ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  009b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  009ba	85 c0		 test	 eax, eax
  009bc	74 53		 je	 SHORT $LN50@CTCI_Init
  009be	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  009c3	48 05 d6 51 00
	00		 add	 rax, 20950		; 000051d6H
  009c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  009ce	48 81 c1 46 50
	00 00		 add	 rcx, 20550		; 00005046H
  009d5	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDevCTCBLK$[rsp]
  009da	48 81 c2 c6 51
	00 00		 add	 rdx, 20934		; 000051c6H
  009e1	bf 08 00 00 00	 mov	 edi, 8
  009e6	48 6b ff 00	 imul	 rdi, rdi, 0
  009ea	48 8b 74 24 70	 mov	 rsi, QWORD PTR pDevCTCBLK$[rsp]
  009ef	48 8b 7c 3e 0c	 mov	 rdi, QWORD PTR [rsi+rdi+12]
  009f4	0f b7 7f 48	 movzx	 edi, WORD PTR [rdi+72]
  009f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009fd	4c 8b c9	 mov	 r9, rcx
  00a00	4c 8b c2	 mov	 r8, rdx
  00a03	8b d7		 mov	 edx, edi
  00a05	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169148
  00a0c	e8 00 00 00 00	 call	 DebuggerTrace
$LN50@CTCI_Init:
  00a11	33 c0		 xor	 eax, eax
  00a13	85 c0		 test	 eax, eax
  00a15	0f 85 45 ff ff
	ff		 jne	 $LN4@CTCI_Init
$LN7@CTCI_Init:

; 309  :         (
; 310  :             "** CTCI_Init: %4.4X (%s): IP \"%s\"  -->  default MAC \"%s\"\n"
; 311  : 
; 312  :             ,pDevCTCBLK->pDEVBLK[CTC_READ_SUBCHANN]->devnum
; 313  :             ,pDevCTCBLK->szTUNIfName
; 314  :             ,pDevCTCBLK->szGuestIPAddr
; 315  :             ,pDevCTCBLK->szMACAddress
; 316  :         );
; 317  : 
; 318  :         VERIFY( TUNTAP_SetMACAddr ( pDevCTCBLK->szTUNIfName, pDevCTCBLK->szMACAddress  ) == 0 );

  00a1b	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00a20	48 05 d6 51 00
	00		 add	 rax, 20950		; 000051d6H
  00a26	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00a2b	48 81 c1 c6 51
	00 00		 add	 rcx, 20934		; 000051c6H
  00a32	48 8b d0	 mov	 rdx, rax
  00a35	e8 00 00 00 00	 call	 TUNTAP_SetMACAddr
  00a3a	85 c0		 test	 eax, eax
  00a3c	74 5c		 je	 SHORT $LN51@CTCI_Init
$LN10@CTCI_Init:
  00a3e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169150
  00a45	41 b8 3e 01 00
	00		 mov	 r8d, 318		; 0000013eH
  00a4b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169151
  00a52	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169152
  00a59	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00a5f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00a65	85 c0		 test	 eax, eax
  00a67	74 20		 je	 SHORT $LN52@CTCI_Init
  00a69	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169154
  00a70	41 b8 3e 01 00
	00		 mov	 r8d, 318		; 0000013eH
  00a76	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169155
  00a7d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169156
  00a84	e8 00 00 00 00	 call	 DebuggerTrace
$LN52@CTCI_Init:
  00a89	33 c0		 xor	 eax, eax
  00a8b	85 c0		 test	 eax, eax
  00a8d	75 af		 jne	 SHORT $LN10@CTCI_Init
  00a8f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00a95	85 c0		 test	 eax, eax
  00a97	74 01		 je	 SHORT $LN53@CTCI_Init
  00a99	cc		 int	 3
$LN53@CTCI_Init:
$LN51@CTCI_Init:
  00a9a	33 c0		 xor	 eax, eax
  00a9c	85 c0		 test	 eax, eax
  00a9e	0f 85 77 ff ff
	ff		 jne	 $LN7@CTCI_Init
$LN13@CTCI_Init:

; 319  : #endif
; 320  : 
; 321  : #ifdef OPTION_TUNTAP_CLRIPADDR
; 322  :         VERIFY( TUNTAP_ClrIPAddr  ( pDevCTCBLK->szTUNIfName ) == 0 );
; 323  : #endif
; 324  : #endif
; 325  : 
; 326  :         VERIFY( TUNTAP_SetIPAddr  ( pDevCTCBLK->szTUNIfName, pDevCTCBLK->szDriveIPAddr ) == 0 );

  00aa4	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00aa9	48 05 66 50 00
	00		 add	 rax, 20582		; 00005066H
  00aaf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00ab4	48 81 c1 c6 51
	00 00		 add	 rcx, 20934		; 000051c6H
  00abb	48 8b d0	 mov	 rdx, rax
  00abe	e8 00 00 00 00	 call	 TUNTAP_SetIPAddr
  00ac3	85 c0		 test	 eax, eax
  00ac5	74 5c		 je	 SHORT $LN54@CTCI_Init
$LN16@CTCI_Init:
  00ac7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169159
  00ace	41 b8 46 01 00
	00		 mov	 r8d, 326		; 00000146H
  00ad4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169160
  00adb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169161
  00ae2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00ae8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00aee	85 c0		 test	 eax, eax
  00af0	74 20		 je	 SHORT $LN55@CTCI_Init
  00af2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169163
  00af9	41 b8 46 01 00
	00		 mov	 r8d, 326		; 00000146H
  00aff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169164
  00b06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169165
  00b0d	e8 00 00 00 00	 call	 DebuggerTrace
$LN55@CTCI_Init:
  00b12	33 c0		 xor	 eax, eax
  00b14	85 c0		 test	 eax, eax
  00b16	75 af		 jne	 SHORT $LN16@CTCI_Init
  00b18	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00b1e	85 c0		 test	 eax, eax
  00b20	74 01		 je	 SHORT $LN56@CTCI_Init
  00b22	cc		 int	 3
$LN56@CTCI_Init:
$LN54@CTCI_Init:
  00b23	33 c0		 xor	 eax, eax
  00b25	85 c0		 test	 eax, eax
  00b27	0f 85 77 ff ff
	ff		 jne	 $LN13@CTCI_Init
$LN19@CTCI_Init:

; 327  : 
; 328  :         VERIFY( TUNTAP_SetDestAddr( pDevCTCBLK->szTUNIfName, pDevCTCBLK->szGuestIPAddr ) == 0 );

  00b2d	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00b32	48 05 46 50 00
	00		 add	 rax, 20550		; 00005046H
  00b38	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00b3d	48 81 c1 c6 51
	00 00		 add	 rcx, 20934		; 000051c6H
  00b44	48 8b d0	 mov	 rdx, rax
  00b47	e8 00 00 00 00	 call	 TUNTAP_SetDestAddr
  00b4c	85 c0		 test	 eax, eax
  00b4e	74 5c		 je	 SHORT $LN57@CTCI_Init
$LN22@CTCI_Init:
  00b50	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169168
  00b57	41 b8 48 01 00
	00		 mov	 r8d, 328		; 00000148H
  00b5d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169169
  00b64	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169170
  00b6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00b71	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00b77	85 c0		 test	 eax, eax
  00b79	74 20		 je	 SHORT $LN58@CTCI_Init
  00b7b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169172
  00b82	41 b8 48 01 00
	00		 mov	 r8d, 328		; 00000148H
  00b88	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169173
  00b8f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169174
  00b96	e8 00 00 00 00	 call	 DebuggerTrace
$LN58@CTCI_Init:
  00b9b	33 c0		 xor	 eax, eax
  00b9d	85 c0		 test	 eax, eax
  00b9f	75 af		 jne	 SHORT $LN22@CTCI_Init
  00ba1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00ba7	85 c0		 test	 eax, eax
  00ba9	74 01		 je	 SHORT $LN59@CTCI_Init
  00bab	cc		 int	 3
$LN59@CTCI_Init:
$LN57@CTCI_Init:
  00bac	33 c0		 xor	 eax, eax
  00bae	85 c0		 test	 eax, eax
  00bb0	0f 85 77 ff ff
	ff		 jne	 $LN19@CTCI_Init
$LN25@CTCI_Init:

; 329  : 
; 330  : #ifdef OPTION_TUNTAP_SETNETMASK
; 331  :         VERIFY( TUNTAP_SetNetMask ( pDevCTCBLK->szTUNIfName, pDevCTCBLK->szNetMask     ) == 0 );

  00bb6	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00bbb	48 05 86 50 00
	00		 add	 rax, 20614		; 00005086H
  00bc1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00bc6	48 81 c1 c6 51
	00 00		 add	 rcx, 20934		; 000051c6H
  00bcd	48 8b d0	 mov	 rdx, rax
  00bd0	e8 00 00 00 00	 call	 TUNTAP_SetNetMask
  00bd5	85 c0		 test	 eax, eax
  00bd7	74 5c		 je	 SHORT $LN60@CTCI_Init
$LN28@CTCI_Init:
  00bd9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169177
  00be0	41 b8 4b 01 00
	00		 mov	 r8d, 331		; 0000014bH
  00be6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169178
  00bed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169179
  00bf4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00bfa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00c00	85 c0		 test	 eax, eax
  00c02	74 20		 je	 SHORT $LN61@CTCI_Init
  00c04	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169181
  00c0b	41 b8 4b 01 00
	00		 mov	 r8d, 331		; 0000014bH
  00c11	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169182
  00c18	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169183
  00c1f	e8 00 00 00 00	 call	 DebuggerTrace
$LN61@CTCI_Init:
  00c24	33 c0		 xor	 eax, eax
  00c26	85 c0		 test	 eax, eax
  00c28	75 af		 jne	 SHORT $LN28@CTCI_Init
  00c2a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00c30	85 c0		 test	 eax, eax
  00c32	74 01		 je	 SHORT $LN62@CTCI_Init
  00c34	cc		 int	 3
$LN62@CTCI_Init:
$LN60@CTCI_Init:
  00c35	33 c0		 xor	 eax, eax
  00c37	85 c0		 test	 eax, eax
  00c39	0f 85 77 ff ff
	ff		 jne	 $LN25@CTCI_Init
$LN31@CTCI_Init:

; 332  : #endif
; 333  : 
; 334  :         VERIFY( TUNTAP_SetMTU     ( pDevCTCBLK->szTUNIfName, pDevCTCBLK->szMTU         ) == 0 );

  00c3f	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00c44	48 05 a6 50 00
	00		 add	 rax, 20646		; 000050a6H
  00c4a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00c4f	48 81 c1 c6 51
	00 00		 add	 rcx, 20934		; 000051c6H
  00c56	48 8b d0	 mov	 rdx, rax
  00c59	e8 00 00 00 00	 call	 TUNTAP_SetMTU
  00c5e	85 c0		 test	 eax, eax
  00c60	74 5c		 je	 SHORT $LN63@CTCI_Init
$LN34@CTCI_Init:
  00c62	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169186
  00c69	41 b8 4e 01 00
	00		 mov	 r8d, 334		; 0000014eH
  00c6f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169187
  00c76	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169188
  00c7d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00c83	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00c89	85 c0		 test	 eax, eax
  00c8b	74 20		 je	 SHORT $LN64@CTCI_Init
  00c8d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169190
  00c94	41 b8 4e 01 00
	00		 mov	 r8d, 334		; 0000014eH
  00c9a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169191
  00ca1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169192
  00ca8	e8 00 00 00 00	 call	 DebuggerTrace
$LN64@CTCI_Init:
  00cad	33 c0		 xor	 eax, eax
  00caf	85 c0		 test	 eax, eax
  00cb1	75 af		 jne	 SHORT $LN34@CTCI_Init
  00cb3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00cb9	85 c0		 test	 eax, eax
  00cbb	74 01		 je	 SHORT $LN65@CTCI_Init
  00cbd	cc		 int	 3
$LN65@CTCI_Init:
$LN63@CTCI_Init:
  00cbe	33 c0		 xor	 eax, eax
  00cc0	85 c0		 test	 eax, eax
  00cc2	0f 85 77 ff ff
	ff		 jne	 $LN31@CTCI_Init
$LN37@CTCI_Init:

; 335  : 
; 336  :         VERIFY( TUNTAP_SetFlags   ( pDevCTCBLK->szTUNIfName, nIFFlags                  ) == 0 );

  00cc8	48 8b 44 24 70	 mov	 rax, QWORD PTR pDevCTCBLK$[rsp]
  00ccd	48 05 c6 51 00
	00		 add	 rax, 20934		; 000051c6H
  00cd3	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR nIFFlags$[rsp]
  00cda	48 8b c8	 mov	 rcx, rax
  00cdd	e8 00 00 00 00	 call	 TUNTAP_SetFlags
  00ce2	85 c0		 test	 eax, eax
  00ce4	74 5c		 je	 SHORT $LN66@CTCI_Init
$LN40@CTCI_Init:
  00ce6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169195
  00ced	41 b8 50 01 00
	00		 mov	 r8d, 336		; 00000150H
  00cf3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169196
  00cfa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169197
  00d01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00d07	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00d0d	85 c0		 test	 eax, eax
  00d0f	74 20		 je	 SHORT $LN67@CTCI_Init
  00d11	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169199
  00d18	41 b8 50 01 00
	00		 mov	 r8d, 336		; 00000150H
  00d1e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169200
  00d25	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169201
  00d2c	e8 00 00 00 00	 call	 DebuggerTrace
$LN67@CTCI_Init:
  00d31	33 c0		 xor	 eax, eax
  00d33	85 c0		 test	 eax, eax
  00d35	75 af		 jne	 SHORT $LN40@CTCI_Init
  00d37	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00d3d	85 c0		 test	 eax, eax
  00d3f	74 01		 je	 SHORT $LN68@CTCI_Init
  00d41	cc		 int	 3
$LN68@CTCI_Init:
$LN66@CTCI_Init:
  00d42	33 c0		 xor	 eax, eax
  00d44	85 c0		 test	 eax, eax
  00d46	75 80		 jne	 SHORT $LN37@CTCI_Init
$LN45@CTCI_Init:

; 337  : 
; 338  :     }
; 339  : 
; 340  :     // Copy the fd to make panel.c happy
; 341  :     pDevCTCBLK->pDEVBLK[ CTC_READ_SUBCHANN  ]->fd =

  00d48	b8 08 00 00 00	 mov	 eax, 8
  00d4d	48 6b c0 01	 imul	 rax, rax, 1
  00d51	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00d56	48 8b 44 01 0c	 mov	 rax, QWORD PTR [rcx+rax+12]
  00d5b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00d60	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00d62	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx
  00d68	b8 08 00 00 00	 mov	 eax, 8
  00d6d	48 6b c0 01	 imul	 rax, rax, 1
  00d71	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00d76	48 8b 44 01 0c	 mov	 rax, QWORD PTR [rcx+rax+12]
  00d7b	b9 08 00 00 00	 mov	 ecx, 8
  00d80	48 6b c9 00	 imul	 rcx, rcx, 0
  00d84	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDevCTCBLK$[rsp]
  00d89	48 8b 4c 0a 0c	 mov	 rcx, QWORD PTR [rdx+rcx+12]
  00d8e	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [rax+428]
  00d94	89 81 ac 01 00
	00		 mov	 DWORD PTR [rcx+428], eax

; 342  :     pDevCTCBLK->pDEVBLK[ CTC_WRITE_SUBCHANN ]->fd = pDevCTCBLK->fd;
; 343  : 
; 344  :     MSGBUF(thread_name, "CTCI %4.4X ReadThread", pDEVBLK->devnum);

  00d9a	48 8b 84 24 90
	53 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00da2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00da6	44 8b c8	 mov	 r9d, eax
  00da9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169203
  00db0	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00db5	48 8d 8c 24 18
	53 00 00	 lea	 rcx, QWORD PTR thread_name$[rsp]
  00dbd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 345  :     rc = create_thread( &pDevCTCBLK->tid, JOINABLE, CTCI_ReadThread, pDevCTCBLK, thread_name );

  00dc3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00dca	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  00dd0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00dd5	48 83 c1 04	 add	 rcx, 4
  00dd9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169204
  00de0	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00de5	48 8d 94 24 18
	53 00 00	 lea	 rdx, QWORD PTR thread_name$[rsp]
  00ded	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00df2	4c 8b 4c 24 70	 mov	 r9, QWORD PTR pDevCTCBLK$[rsp]
  00df7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:CTCI_ReadThread
  00dfe	48 8b d0	 mov	 rdx, rax
  00e01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00e07	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 346  :     if(rc)

  00e0b	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  00e10	74 66		 je	 SHORT $LN69@CTCI_Init

; 347  :     {
; 348  :        // "Error in function create_thread(): %s"
; 349  :        WRMSG(HHC00102, "E", strerror(rc));

  00e12	8b 4c 24 78	 mov	 ecx, DWORD PTR rc$[rsp]
  00e16	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00e1c	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv659[rsp], rax
  00e24	b9 01 00 00 00	 mov	 ecx, 1
  00e29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e2f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv659[rsp]
  00e37	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e3c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169206
  00e43	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e48	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169207
  00e4f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e54	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e59	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e5f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169208
  00e66	ba 5d 01 00 00	 mov	 edx, 349		; 0000015dH
  00e6b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169209
  00e72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN69@CTCI_Init:

; 350  :     }
; 351  : 
; 352  :     pDevCTCBLK->pDEVBLK[ CTC_READ_SUBCHANN  ]->tid = pDevCTCBLK->tid;

  00e78	b8 08 00 00 00	 mov	 eax, 8
  00e7d	48 6b c0 00	 imul	 rax, rax, 0
  00e81	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00e86	48 8b 44 01 0c	 mov	 rax, QWORD PTR [rcx+rax+12]
  00e8b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00e90	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00e93	89 88 14 02 00
	00		 mov	 DWORD PTR [rax+532], ecx

; 353  :     pDevCTCBLK->pDEVBLK[ CTC_WRITE_SUBCHANN ]->tid = pDevCTCBLK->tid;

  00e99	b8 08 00 00 00	 mov	 eax, 8
  00e9e	48 6b c0 01	 imul	 rax, rax, 1
  00ea2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00ea7	48 8b 44 01 0c	 mov	 rax, QWORD PTR [rcx+rax+12]
  00eac	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDevCTCBLK$[rsp]
  00eb1	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00eb4	89 88 14 02 00
	00		 mov	 DWORD PTR [rax+532], ecx

; 354  : 
; 355  :     return 0;

  00eba	33 c0		 xor	 eax, eax
$LN1@CTCI_Init:

; 356  : }

  00ebc	48 8b 8c 24 60
	53 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00ec4	48 33 cc	 xor	 rcx, rsp
  00ec7	e8 00 00 00 00	 call	 __security_check_cookie
  00ecc	48 81 c4 78 53
	00 00		 add	 rsp, 21368		; 00005378H
  00ed3	5f		 pop	 rdi
  00ed4	5e		 pop	 rsi
  00ed5	c3		 ret	 0
CTCI_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
