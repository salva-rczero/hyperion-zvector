; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	s370_tcpip
PUBLIC	fetch_fw_noswap
PUBLIC	s370_maddr_l
PUBLIC	s370_vstorec
PUBLIC	s370_vfetchc
EXTRN	_byteswap_ulong:PROC
EXTRN	s370_fetch_int_timer:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	lar_tcpip:PROC
EXTRN	map32:BYTE
pdata	SEGMENT
$pdata$s370_tcpip DD imagerel $LN30
	DD	imagerel $LN30+923
	DD	imagerel $unwind$s370_tcpip
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstorec DD imagerel $LN24
	DD	imagerel $LN24+597
	DD	imagerel $unwind$s370_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetchc DD imagerel $LN24
	DD	imagerel $LN24+528
	DD	imagerel $unwind$s370_vfetchc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$s370_tcpip DD 010e01H
	DD	0c20eH
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv80 = 56
tv94 = 60
main1$ = 64
main2$ = 72
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s370_vfetchc PROC					; COMDAT

; 631  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN11@s370_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN12@s370_vfetc
$LN11@s370_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	0f 84 c6 00 00
	00		 je	 $LN5@s370_vfetc
$LN4@s370_vfetc:

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );

  00054	83 bc 24 80 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  0005c	73 0a		 jae	 SHORT $LN15@s370_vfetc
  0005e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00066	eb 08		 jmp	 SHORT $LN16@s370_vfetc
$LN15@s370_vfetc:
  00068	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN16@s370_vfetc:
  00070	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00075	74 1f		 je	 SHORT $LN17@s370_vfetc
  00077	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0007c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008a	72 0a		 jb	 SHORT $LN17@s370_vfetc
  0008c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00094	eb 08		 jmp	 SHORT $LN23@s370_vfetc
$LN17@s370_vfetc:
  00096	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN23@s370_vfetc:
  0009e	83 7c 24 3c 00	 cmp	 DWORD PTR tv94[rsp], 0
  000a3	74 0d		 je	 SHORT $LN7@s370_vfetc
  000a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 9c		 jne	 SHORT $LN4@s370_vfetc

; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b8	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  000bd	ff c0		 inc	 eax
  000bf	48 98		 cdqe
  000c1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000cd	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000d1	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d9	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e1	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000e9	48 8b d0	 mov	 rdx, rax
  000ec	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	e8 00 00 00 00	 call	 s370_maddr_l
  000f8	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  000fd	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00102	ff c0		 inc	 eax
  00104	48 98		 cdqe
  00106	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  0010b	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  00110	48 8b c8	 mov	 rcx, rax
  00113	f3 a4		 rep movsb

; 640  :     }

  00115	e9 ef 00 00 00	 jmp	 $LN6@s370_vfetc
$LN5@s370_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0011a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00121	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00126	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0012b	2b c8		 sub	 ecx, eax
  0012d	8b c1		 mov	 eax, ecx
  0012f	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00133	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00138	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00144	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00148	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00150	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00158	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00160	48 8b d0	 mov	 rdx, rax
  00163	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0016a	e8 00 00 00 00	 call	 s370_maddr_l
  0016f	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00174	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00179	ff c0		 inc	 eax
  0017b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0017f	48 98		 cdqe
  00181	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00185	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0018c	03 d1		 add	 edx, ecx
  0018e	8b ca		 mov	 ecx, edx
  00190	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00196	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0019e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001a2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001a6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  001ae	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001b6	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001be	48 8b d0	 mov	 rdx, rax
  001c1	e8 00 00 00 00	 call	 s370_maddr_l
  001c6	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  001cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001d0	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  001d5	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  001da	48 8b c8	 mov	 rcx, rax
  001dd	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  001df	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  001e4	ff c0		 inc	 eax
  001e6	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001ea	48 98		 cdqe
  001ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001f1	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001f6	48 03 d1	 add	 rdx, rcx
  001f9	48 8b ca	 mov	 rcx, rdx
  001fc	48 8b f9	 mov	 rdi, rcx
  001ff	48 8b 74 24 48	 mov	 rsi, QWORD PTR main2$[rsp]
  00204	48 8b c8	 mov	 rcx, rax
  00207	f3 a4		 rep movsb
$LN6@s370_vfetc:

; 649  :     }
; 650  : }

  00209	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0020d	5f		 pop	 rdi
  0020e	5e		 pop	 rsi
  0020f	c3		 ret	 0
s370_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv131 = 56
tv145 = 60
sk$ = 64
tv81 = 72
main1$ = 80
main2$ = 88
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s370_vstorec PROC					; COMDAT

; 489  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN11@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN11@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	0f 84 d6 00 00
	00		 je	 $LN5@s370_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00057	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005f	ff c0		 inc	 eax
  00061	48 98		 cdqe
  00063	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
  00068	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  00070	ff c1		 inc	 ecx
  00072	48 63 c9	 movsxd	 rcx, ecx
  00075	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007d	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00081	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00085	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009d	48 8b d1	 mov	 rdx, rcx
  000a0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a7	e8 00 00 00 00	 call	 s370_maddr_l
  000ac	48 8b f8	 mov	 rdi, rax
  000af	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR tv81[rsp]
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	f3 a4		 rep movsb
$LN4@s370_vstor:

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );

  000c1	83 bc 24 90 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000c9	73 0a		 jae	 SHORT $LN15@s370_vstor
  000cb	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000d5	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@s370_vstor:
  000dd	83 7c 24 38 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 22		 je	 SHORT $LN17@s370_vstor
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  000ec	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	03 c8		 add	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	83 f8 50	 cmp	 eax, 80			; 00000050H
  000fa	72 0a		 jb	 SHORT $LN17@s370_vstor
  000fc	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  00104	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  00106	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN23@s370_vstor:
  0010e	83 7c 24 3c 00	 cmp	 DWORD PTR tv145[rsp], 0
  00113	74 0d		 je	 SHORT $LN7@s370_vstor
  00115	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  00122	33 c0		 xor	 eax, eax
  00124	85 c0		 test	 eax, eax
  00126	75 99		 jne	 SHORT $LN4@s370_vstor

; 499  :     }

  00128	e9 21 01 00 00	 jmp	 $LN6@s370_vstor
$LN5@s370_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0012d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00134	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00139	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0013e	2b c8		 sub	 ecx, eax
  00140	8b c1		 mov	 eax, ecx
  00142	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  00146	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0014b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00157	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0015b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00163	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0016b	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00173	48 8b d0	 mov	 rdx, rax
  00176	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0017d	e8 00 00 00 00	 call	 s370_maddr_l
  00182	48 89 44 24 50	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00187	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018f	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00196	48 89 44 24 40	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  0019b	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001a3	ff c0		 inc	 eax
  001a5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001a9	48 98		 cdqe
  001ab	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  001af	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  001b6	03 d1		 add	 edx, ecx
  001b8	8b ca		 mov	 ecx, edx
  001ba	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  001c0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001cc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001d0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001d8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001e0	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001e8	48 8b d0	 mov	 rdx, rax
  001eb	e8 00 00 00 00	 call	 s370_maddr_l
  001f0	48 89 44 24 58	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  001f5	48 8b 44 24 40	 mov	 rax, QWORD PTR sk$[rsp]
  001fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fd	83 c8 06	 or	 eax, 6
  00200	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sk$[rsp]
  00205	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  00207	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0020c	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main1$[rsp]
  00211	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  00219	48 8b c8	 mov	 rcx, rax
  0021c	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  0021e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00226	ff c0		 inc	 eax
  00228	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0022c	48 98		 cdqe
  0022e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00233	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  0023b	48 03 d1	 add	 rdx, rcx
  0023e	48 8b ca	 mov	 rcx, rdx
  00241	48 8b 7c 24 58	 mov	 rdi, QWORD PTR main2$[rsp]
  00246	48 8b f1	 mov	 rsi, rcx
  00249	48 8b c8	 mov	 rcx, rax
  0024c	f3 a4		 rep movsb
$LN6@s370_vstor:

; 512  :     }
; 513  : }

  0024e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00252	5f		 pop	 rdi
  00253	5e		 pop	 rsi
  00254	c3		 ret	 0
s370_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\x75.c
_TEXT	SEGMENT
effective_addr2$ = 48
i$ = 52
b2$ = 56
temp$1 = 60
tv77 = 64
x2$ = 68
tv88 = 72
s$ = 80
r1$ = 88
inst$ = 112
regs$ = 120
s370_tcpip PROC

; 74   : {

$LN30:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 75   :     int     r1;              /* Value of R field       */
; 76   :     int     x2;              /* Index register         */
; 77   :     int     b2;              /* Base of effective addr */
; 78   :     VADR    effective_addr2; /* Effective address      */
; 79   :     int     i;
; 80   :     unsigned char * s;
; 81   : 
; 82   :     /*  vv---vv---------------- input variables to TCPIP */
; 83   :     RX(inst, regs, r1, x2, b2, effective_addr2);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 3c	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002c	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00030	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00034	c1 e8 10	 shr	 eax, 16
  00037	83 e0 0f	 and	 eax, 15
  0003a	89 44 24 44	 mov	 DWORD PTR x2$[rsp], eax
  0003e	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00042	c1 e8 14	 shr	 eax, 20
  00045	83 e0 0f	 and	 eax, 15
  00048	89 44 24 58	 mov	 DWORD PTR r1$[rsp], eax
  0004c	83 7c 24 44 00	 cmp	 DWORD PTR x2$[rsp], 0
  00051	74 0a		 je	 SHORT $LN26@s370_tcpip
  00053	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv77[rsp], 1
  0005b	eb 08		 jmp	 SHORT $LN27@s370_tcpip
$LN26@s370_tcpip:
  0005d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN27@s370_tcpip:
  00065	83 7c 24 40 00	 cmp	 DWORD PTR tv77[rsp], 0
  0006a	74 1d		 je	 SHORT $LN10@s370_tcpip
  0006c	48 63 44 24 44	 movsxd	 rax, DWORD PTR x2$[rsp]
  00071	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00076	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007d	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00081	03 c8		 add	 ecx, eax
  00083	8b c1		 mov	 eax, ecx
  00085	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN10@s370_tcpip:
  00089	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  0008d	c1 e8 0c	 shr	 eax, 12
  00090	83 e0 0f	 and	 eax, 15
  00093	89 44 24 38	 mov	 DWORD PTR b2$[rsp], eax
  00097	83 7c 24 38 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009c	74 0a		 je	 SHORT $LN28@s370_tcpip
  0009e	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  000a6	eb 08		 jmp	 SHORT $LN29@s370_tcpip
$LN28@s370_tcpip:
  000a8	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN29@s370_tcpip:
  000b0	83 7c 24 48 00	 cmp	 DWORD PTR tv88[rsp], 0
  000b5	74 1d		 je	 SHORT $LN11@s370_tcpip
  000b7	48 63 44 24 38	 movsxd	 rax, DWORD PTR b2$[rsp]
  000bc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c8	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000cc	03 c8		 add	 ecx, eax
  000ce	8b c1		 mov	 eax, ecx
  000d0	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN11@s370_tcpip:
  000d4	33 c0		 xor	 eax, eax
  000d6	83 f8 04	 cmp	 eax, 4
  000d9	74 0d		 je	 SHORT $LN12@s370_tcpip
  000db	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000df	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000e4	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN12@s370_tcpip:
$LN4@s370_tcpip:
  000e8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f1	48 83 c0 04	 add	 rax, 4
  000f5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000fe	33 c0		 xor	 eax, eax
  00100	83 f8 04	 cmp	 eax, 4
  00103	74 0c		 je	 SHORT $LN13@s370_tcpip
  00105	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0010a	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN13@s370_tcpip:
  00111	33 c0		 xor	 eax, eax
  00113	85 c0		 test	 eax, eax
  00115	75 d1		 jne	 SHORT $LN4@s370_tcpip
$LN7@s370_tcpip:

; 84   :     /*             ^^-------------- becomes to-store register a */
; 85   :     /*                 ^^---------- becomes index register b */
; 86   :     /*                     ^^------ becomes access register c */
; 87   :     /*                         ^^-- becomes yyy+gr[b]+gr[c] */
; 88   :     UNREFERENCED(r1);

  00117	33 c0		 xor	 eax, eax
  00119	85 c0		 test	 eax, eax
  0011b	75 fa		 jne	 SHORT $LN7@s370_tcpip

; 89   : 
; 90   :     if (!FACILITY_ENABLED( HERC_TCPIP_PROB_STATE, regs )) PRIV_CHECK(regs);

  0011d	b8 01 00 00 00	 mov	 eax, 1
  00122	48 6b c0 22	 imul	 rax, rax, 34		; 00000022H
  00126	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00133	83 e0 40	 and	 eax, 64			; 00000040H
  00136	85 c0		 test	 eax, eax
  00138	75 25		 jne	 SHORT $LN14@s370_tcpip
  0013a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00143	83 e0 01	 and	 eax, 1
  00146	85 c0		 test	 eax, eax
  00148	74 15		 je	 SHORT $LN15@s370_tcpip
  0014a	ba 02 00 00 00	 mov	 edx, 2
  0014f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00154	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00159	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@s370_tcpip:
$LN14@s370_tcpip:

; 91   : 
; 92   :     if (regs->GR_L(0) == 0) { /* Only run when R0 = 0, (restart) */

  0015f	b8 08 00 00 00	 mov	 eax, 8
  00164	48 6b c0 00	 imul	 rax, rax, 0
  00168	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016d	83 bc 01 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax+640], 0
  00175	75 59		 jne	 SHORT $LN16@s370_tcpip

; 93   : 
; 94   :         if (lar_tcpip (&(regs->gr [0])) == 0) { /* Get PC buffer */

  00177	b8 08 00 00 00	 mov	 eax, 8
  0017c	48 6b c0 00	 imul	 rax, rax, 0
  00180	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00185	48 8d 84 01 80
	02 00 00	 lea	 rax, QWORD PTR [rcx+rax+640]
  0018d	48 8b c8	 mov	 rcx, rax
  00190	e8 00 00 00 00	 call	 lar_tcpip
  00195	85 c0		 test	 eax, eax
  00197	75 1e		 jne	 SHORT $LN17@s370_tcpip

; 95   :             regs->GR_L(15) = -1; /* Error */

  00199	b8 08 00 00 00	 mov	 eax, 8
  0019e	48 6b c0 0f	 imul	 rax, rax, 15
  001a2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	c7 84 01 80 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax+640], -1 ; ffffffffH

; 96   :             return;

  001b2	e9 df 01 00 00	 jmp	 $LN1@s370_tcpip
$LN17@s370_tcpip:

; 97   :         }
; 98   : 
; 99   :         regs->GR_L(0) = 1;    /* Do not call native routine again */

  001b7	b8 08 00 00 00	 mov	 eax, 8
  001bc	48 6b c0 00	 imul	 rax, rax, 0
  001c0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001c5	c7 84 01 80 02
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 1
$LN16@s370_tcpip:

; 100  :     }
; 101  : 
; 102  :     if (regs->GR_L(1) != 0) s = (unsigned char *)(map32[regs->GR_L(2)]);

  001d0	b8 08 00 00 00	 mov	 eax, 8
  001d5	48 6b c0 01	 imul	 rax, rax, 1
  001d9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001de	83 bc 01 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax+640], 0
  001e6	74 25		 je	 SHORT $LN18@s370_tcpip
  001e8	b8 08 00 00 00	 mov	 eax, 8
  001ed	48 6b c0 02	 imul	 rax, rax, 2
  001f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001f6	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:map32
  00204	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00208	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax
$LN18@s370_tcpip:
$LN8@s370_tcpip:

; 103  : 
; 104  :     while (regs->GR_L(1) != 0) { /* Finished > */

  0020d	b8 08 00 00 00	 mov	 eax, 8
  00212	48 6b c0 01	 imul	 rax, rax, 1
  00216	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0021b	83 bc 01 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax+640], 0
  00223	0f 84 17 01 00
	00		 je	 $LN9@s370_tcpip

; 105  : 
; 106  :         i = regs->GR_L(1) - 1;

  00229	b8 08 00 00 00	 mov	 eax, 8
  0022e	48 6b c0 01	 imul	 rax, rax, 1
  00232	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00237	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0023e	ff c8		 dec	 eax
  00240	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 107  :         if (i > 255) i = 255;

  00244	81 7c 24 34 ff
	00 00 00	 cmp	 DWORD PTR i$[rsp], 255	; 000000ffH
  0024c	7e 08		 jle	 SHORT $LN19@s370_tcpip
  0024e	c7 44 24 34 ff
	00 00 00	 mov	 DWORD PTR i$[rsp], 255	; 000000ffH
$LN19@s370_tcpip:

; 108  : 
; 109  :         if (regs->GR_L(3) == 0) { /* Going to host */

  00256	b8 08 00 00 00	 mov	 eax, 8
  0025b	48 6b c0 03	 imul	 rax, rax, 3
  0025f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00264	83 bc 01 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax+640], 0
  0026c	75 25		 jne	 SHORT $LN20@s370_tcpip

; 110  :             /* Load bytes from operand address */
; 111  :             ARCH_DEP(vfetchc) ( s, (unsigned char)i, effective_addr2, b2, regs );

  0026e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00273	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00278	44 8b 4c 24 38	 mov	 r9d, DWORD PTR b2$[rsp]
  0027d	44 8b 44 24 30	 mov	 r8d, DWORD PTR effective_addr2$[rsp]
  00282	0f b6 54 24 34	 movzx	 edx, BYTE PTR i$[rsp]
  00287	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0028c	e8 00 00 00 00	 call	 s370_vfetchc

; 112  :         } else {                  /* Going from host */

  00291	eb 23		 jmp	 SHORT $LN21@s370_tcpip
$LN20@s370_tcpip:

; 113  :             /* Store bytes at operand address */
; 114  :             ARCH_DEP(vstorec) ( s, (unsigned char)i, effective_addr2, b2, regs );

  00293	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00298	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0029d	44 8b 4c 24 38	 mov	 r9d, DWORD PTR b2$[rsp]
  002a2	44 8b 44 24 30	 mov	 r8d, DWORD PTR effective_addr2$[rsp]
  002a7	0f b6 54 24 34	 movzx	 edx, BYTE PTR i$[rsp]
  002ac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002b1	e8 00 00 00 00	 call	 s370_vstorec
$LN21@s370_tcpip:

; 115  :         }
; 116  : 
; 117  :         i++;

  002b6	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  002ba	ff c0		 inc	 eax
  002bc	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax

; 118  :         effective_addr2 += i;  /* No exception, quick copy without calc's */

  002c0	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  002c4	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  002c8	03 c8		 add	 ecx, eax
  002ca	8b c1		 mov	 eax, ecx
  002cc	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax

; 119  :         (regs->GR_L(b2)) += i; /* Exception, can recalculate if/when restart */

  002d0	48 63 44 24 38	 movsxd	 rax, DWORD PTR b2$[rsp]
  002d5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002da	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002e1	03 44 24 34	 add	 eax, DWORD PTR i$[rsp]
  002e5	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR b2$[rsp]
  002ea	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  002ef	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 120  :         s += i;                /* Next PC byte segment location */

  002f6	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  002fb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00300	48 03 c8	 add	 rcx, rax
  00303	48 8b c1	 mov	 rax, rcx
  00306	48 89 44 24 50	 mov	 QWORD PTR s$[rsp], rax

; 121  :         (regs->GR_L(1)) -= i;  /* One less segment to copy next time */

  0030b	b8 08 00 00 00	 mov	 eax, 8
  00310	48 6b c0 01	 imul	 rax, rax, 1
  00314	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00319	8b 54 24 34	 mov	 edx, DWORD PTR i$[rsp]
  0031d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00324	2b c2		 sub	 eax, edx
  00326	b9 08 00 00 00	 mov	 ecx, 8
  0032b	48 6b c9 01	 imul	 rcx, rcx, 1
  0032f	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00334	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 122  :     }

  0033b	e9 cd fe ff ff	 jmp	 $LN8@s370_tcpip
$LN9@s370_tcpip:

; 123  : 
; 124  :     if (lar_tcpip (&(regs->gr [0])) == 0) { /* Run! */

  00340	b8 08 00 00 00	 mov	 eax, 8
  00345	48 6b c0 00	 imul	 rax, rax, 0
  00349	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0034e	48 8d 84 01 80
	02 00 00	 lea	 rax, QWORD PTR [rcx+rax+640]
  00356	48 8b c8	 mov	 rcx, rax
  00359	e8 00 00 00 00	 call	 lar_tcpip
  0035e	85 c0		 test	 eax, eax
  00360	75 1b		 jne	 SHORT $LN22@s370_tcpip

; 125  :         regs->GR_L(15) = -1; /* Error */

  00362	b8 08 00 00 00	 mov	 eax, 8
  00367	48 6b c0 0f	 imul	 rax, rax, 15
  0036b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00370	c7 84 01 80 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax+640], -1 ; ffffffffH

; 126  :         return;

  0037b	eb 19		 jmp	 SHORT $LN1@s370_tcpip
$LN22@s370_tcpip:

; 127  :     }
; 128  : 
; 129  :     regs->GR_L(15) = 0; /* No error */

  0037d	b8 08 00 00 00	 mov	 eax, 8
  00382	48 6b c0 0f	 imul	 rax, rax, 15
  00386	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0038b	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0
$LN1@s370_tcpip:

; 130  : }

  00396	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0039a	c3		 ret	 0
s370_tcpip ENDP
_TEXT	ENDS
END
