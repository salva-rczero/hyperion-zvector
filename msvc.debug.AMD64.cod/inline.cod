; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	fetch_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s370__or_storage_key
PUBLIC	s370_or_2K_storage_key
PUBLIC	s370_or_storage_key
PUBLIC	add_logical
PUBLIC	sub_logical
PUBLIC	add_signed
PUBLIC	sub_signed
PUBLIC	mul_signed
PUBLIC	mul_unsigned_long
PUBLIC	mul_signed_long
PUBLIC	div_signed
PUBLIC	div_logical_long
PUBLIC	add_logical_long
PUBLIC	sub_logical_long
PUBLIC	add_signed_long
PUBLIC	sub_signed_long
PUBLIC	mult_logical_long
PUBLIC	s370_is_fetch_protected
PUBLIC	s370_is_low_address_protected
PUBLIC	s370_is_store_protected
PUBLIC	s370_fetch_main_absolute
PUBLIC	s370_per1_gra
PUBLIC	s370_is_per3_event_suppressed
PUBLIC	s370_per3_zero
PUBLIC	s370_per3_zero_check
PUBLIC	s370_per3_zero_check2
PUBLIC	s370_per3_zero_lcheck
PUBLIC	s370_per3_zero_lcheck2
PUBLIC	s370_per3_zero_l24check
PUBLIC	s370_per3_zero_l24check2
PUBLIC	s370_per3_zero_xcheck
PUBLIC	s370_per3_zero_xcheck2
PUBLIC	s370_FPC_check
PUBLIC	s370_fetch_doubleword_absolute
PUBLIC	s370_fetch_fullword_absolute
PUBLIC	s370_fetch_halfword_absolute
PUBLIC	s370_store_doubleword_absolute
PUBLIC	s370_store_fullword_absolute
PUBLIC	s390__or_storage_key
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_or_storage_key
PUBLIC	s390_is_fetch_protected
PUBLIC	s390_is_low_address_protected
PUBLIC	s390_is_store_protected
PUBLIC	s390_fetch_main_absolute
PUBLIC	s390_per1_gra
PUBLIC	s390_is_per3_event_suppressed
PUBLIC	s390_per3_zero
PUBLIC	s390_per3_zero_check
PUBLIC	s390_per3_zero_check2
PUBLIC	s390_per3_zero_lcheck
PUBLIC	s390_per3_zero_lcheck2
PUBLIC	s390_per3_zero_l24check
PUBLIC	s390_per3_zero_l24check2
PUBLIC	s390_per3_zero_xcheck
PUBLIC	s390_per3_zero_xcheck2
PUBLIC	s390_FPC_check
PUBLIC	s390_fetch_doubleword_absolute
PUBLIC	s390_fetch_fullword_absolute
PUBLIC	s390_fetch_halfword_absolute
PUBLIC	s390_store_doubleword_absolute
PUBLIC	s390_store_fullword_absolute
PUBLIC	z900__or_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_or_storage_key
PUBLIC	z900_is_fetch_protected
PUBLIC	z900_is_low_address_protected
PUBLIC	z900_is_store_protected
PUBLIC	z900_fetch_main_absolute
PUBLIC	z900_per1_gra
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_check
PUBLIC	z900_per3_zero_check2
PUBLIC	z900_per3_zero_lcheck
PUBLIC	z900_per3_zero_lcheck2
PUBLIC	z900_per3_zero_l24check
PUBLIC	z900_per3_zero_l24check2
PUBLIC	z900_per3_zero_xcheck
PUBLIC	z900_per3_zero_xcheck2
PUBLIC	z900_FPC_check
PUBLIC	z900_fetch_doubleword_absolute
PUBLIC	z900_fetch_fullword_absolute
PUBLIC	z900_fetch_halfword_absolute
PUBLIC	z900_store_doubleword_absolute
PUBLIC	z900_store_fullword_absolute
PUBLIC	??_C@_0CM@OMLMFJCF@C?3?2papa?2MyGit?2hyperion?9zvector?2@ ; `string'
PUBLIC	??_C@_0CM@JBMLKNGA@C?3?2papa?2MyGit?2hyperion?9zvector?2@ ; `string'
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	longjmp:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__imp_sysblk:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+170
	DD	imagerel $unwind$s370__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s370_or_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s370_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_logical DD imagerel $LN7
	DD	imagerel $LN7+110
	DD	imagerel $unwind$add_logical
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sub_logical DD imagerel $LN7
	DD	imagerel $LN7+110
	DD	imagerel $unwind$sub_logical
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_signed DD imagerel $LN11
	DD	imagerel $LN11+186
	DD	imagerel $unwind$add_signed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sub_signed DD imagerel $LN11
	DD	imagerel $LN11+186
	DD	imagerel $unwind$sub_signed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mul_signed DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$mul_signed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mul_unsigned_long DD imagerel $LN3
	DD	imagerel $LN3+255
	DD	imagerel $unwind$mul_unsigned_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mul_signed_long DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$mul_signed_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$div_signed DD imagerel $LN6
	DD	imagerel $LN6+178
	DD	imagerel $unwind$div_signed
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$div_logical_long DD imagerel $LN9
	DD	imagerel $LN9+239
	DD	imagerel $unwind$div_logical_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_logical_long DD imagerel $LN7
	DD	imagerel $LN7+119
	DD	imagerel $unwind$add_logical_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sub_logical_long DD imagerel $LN7
	DD	imagerel $LN7+119
	DD	imagerel $unwind$sub_logical_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$add_signed_long DD imagerel $LN11
	DD	imagerel $LN11+218
	DD	imagerel $unwind$add_signed_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sub_signed_long DD imagerel $LN11
	DD	imagerel $LN11+234
	DD	imagerel $unwind$sub_signed_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$mult_logical_long DD imagerel $LN9
	DD	imagerel $LN9+250
	DD	imagerel $unwind$mult_logical_long
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_is_fetch_protected DD imagerel $LN14
	DD	imagerel $LN14+114
	DD	imagerel $unwind$s370_is_fetch_protected
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_is_store_protected DD imagerel $LN8
	DD	imagerel $LN8+166
	DD	imagerel $unwind$s370_is_store_protected
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_fetch_main_absolute DD imagerel $LN7
	DD	imagerel $LN7+184
	DD	imagerel $unwind$s370_fetch_main_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_per1_gra DD imagerel $LN7
	DD	imagerel $LN7+149
	DD	imagerel $unwind$s370_per1_gra
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_FPC_check DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s370_FPC_check
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_fetch_doubleword_absolute DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$s370_fetch_doubleword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_fetch_fullword_absolute DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$s370_fetch_fullword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_fetch_halfword_absolute DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$s370_fetch_halfword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_store_doubleword_absolute DD imagerel $LN7
	DD	imagerel $LN7+207
	DD	imagerel $unwind$s370_store_doubleword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_store_fullword_absolute DD imagerel $LN7
	DD	imagerel $LN7+204
	DD	imagerel $unwind$s370_store_fullword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_is_fetch_protected DD imagerel $LN16
	DD	imagerel $LN16+244
	DD	imagerel $unwind$s390_is_fetch_protected
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_is_store_protected DD imagerel $LN9
	DD	imagerel $LN9+230
	DD	imagerel $unwind$s390_is_store_protected
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_fetch_main_absolute DD imagerel $LN9
	DD	imagerel $LN9+284
	DD	imagerel $unwind$s390_fetch_main_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_FPC_check DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390_FPC_check
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_fetch_doubleword_absolute DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$s390_fetch_doubleword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_fetch_fullword_absolute DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$s390_fetch_fullword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_fetch_halfword_absolute DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$s390_fetch_halfword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_store_doubleword_absolute DD imagerel $LN9
	DD	imagerel $LN9+307
	DD	imagerel $unwind$s390_store_doubleword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_store_fullword_absolute DD imagerel $LN9
	DD	imagerel $LN9+304
	DD	imagerel $unwind$s390_store_fullword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_is_fetch_protected DD imagerel $LN16
	DD	imagerel $LN16+252
	DD	imagerel $unwind$z900_is_fetch_protected
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_is_store_protected DD imagerel $LN9
	DD	imagerel $LN9+235
	DD	imagerel $unwind$z900_is_store_protected
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_fetch_main_absolute DD imagerel $LN7
	DD	imagerel $LN7+185
	DD	imagerel $unwind$z900_fetch_main_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_check DD imagerel $LN6
	DD	imagerel $LN6+101
	DD	imagerel $unwind$z900_per3_zero_check
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_check2 DD imagerel $LN9
	DD	imagerel $LN9+189
	DD	imagerel $unwind$z900_per3_zero_check2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_lcheck DD imagerel $LN8
	DD	imagerel $LN8+190
	DD	imagerel $unwind$z900_per3_zero_lcheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_lcheck2 DD imagerel $LN14
	DD	imagerel $LN14+366
	DD	imagerel $unwind$z900_per3_zero_lcheck2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_l24check DD imagerel $LN6
	DD	imagerel $LN6+139
	DD	imagerel $unwind$z900_per3_zero_l24check
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_l24check2 DD imagerel $LN10
	DD	imagerel $LN10+260
	DD	imagerel $unwind$z900_per3_zero_l24check2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck DD imagerel $LN6
	DD	imagerel $LN6+108
	DD	imagerel $unwind$z900_per3_zero_xcheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck2 DD imagerel $LN18
	DD	imagerel $LN18+485
	DD	imagerel $unwind$z900_per3_zero_xcheck2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_FPC_check DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900_FPC_check
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_fetch_doubleword_absolute DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$z900_fetch_doubleword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_fetch_fullword_absolute DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$z900_fetch_fullword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_fetch_halfword_absolute DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$z900_fetch_halfword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_store_doubleword_absolute DD imagerel $LN7
	DD	imagerel $LN7+208
	DD	imagerel $unwind$z900_store_doubleword_absolute
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_store_fullword_absolute DD imagerel $LN7
	DD	imagerel $LN7+205
	DD	imagerel $unwind$z900_store_fullword_absolute
pdata	ENDS
;	COMDAT ??_C@_0CM@JBMLKNGA@C?3?2papa?2MyGit?2hyperion?9zvector?2@
_DATA	SEGMENT
??_C@_0CM@JBMLKNGA@C?3?2papa?2MyGit?2hyperion?9zvector?2@ DB 'C:\papa\MyG'
	DB	'it\hyperion-zvector\inline.h:555', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@OMLMFJCF@C?3?2papa?2MyGit?2hyperion?9zvector?2@
_DATA	SEGMENT
??_C@_0CM@OMLMFJCF@C?3?2papa?2MyGit?2hyperion?9zvector?2@ DB 'C:\papa\MyG'
	DB	'it\hyperion-zvector\inline.h:550', 00H	; `string'
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_store_fullword_absolute DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_store_doubleword_absolute DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_fetch_halfword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_fetch_fullword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_fetch_doubleword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_FPC_check DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck2 DD 011201H
	DD	0a212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_l24check2 DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_l24check DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_lcheck2 DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_lcheck DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_check2 DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_check DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_fetch_main_absolute DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_is_store_protected DD 011701H
	DD	04217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_is_fetch_protected DD 011701H
	DD	02217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_store_fullword_absolute DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_store_doubleword_absolute DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_fetch_halfword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_fetch_fullword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_fetch_doubleword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_FPC_check DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_fetch_main_absolute DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_is_store_protected DD 011601H
	DD	04216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_is_fetch_protected DD 011601H
	DD	02216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_store_fullword_absolute DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_store_doubleword_absolute DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_fetch_halfword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_fetch_fullword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_fetch_doubleword_absolute DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_FPC_check DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_per1_gra DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_fetch_main_absolute DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_is_store_protected DD 011601H
	DD	04216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_is_fetch_protected DD 011601H
	DD	02216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mult_logical_long DD 011801H
	DD	02218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sub_signed_long DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_signed_long DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sub_logical_long DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_logical_long DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$div_logical_long DD 011801H
	DD	02218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$div_signed DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mul_signed_long DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mul_unsigned_long DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$mul_signed DD 011801H
	DD	02218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sub_signed DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_signed DD 011201H
	DD	04212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sub_logical DD 011201H
	DD	02212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$add_logical DD 011201H
	DD	02212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_2K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
xdata	SEGMENT
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_store_fullword_absolute
_TEXT	SEGMENT
value$ = 64
addr$ = 72
regs$ = 80
z900_store_fullword_absolute PROC			; COMDAT

; 891  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900_store:

; 892  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 893  :     if (addr > regs->mainlim - 4)
; 894  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 895  : #endif
; 896  : 
; 897  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 898  :        is treated as a no-operation if SIE_MODE not active */
; 899  :     SIE_TRANSLATE( &addr, ACCTYPE_WRITE, regs );

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00017	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0001d	d1 e8		 shr	 eax, 1
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 6b		 je	 SHORT $LN5@z900_store
  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00031	c1 e8 02	 shr	 eax, 2
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	75 56		 jne	 SHORT $LN5@z900_store
  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00040	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00047	48 03 44 24 48	 add	 rax, QWORD PTR addr$[rsp]
  0004c	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00055	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0005a	41 b9 02 00 00
	00		 mov	 r9d, 2
  00060	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  0006c	ba fd ff ff ff	 mov	 edx, -3
  00071	48 8b c8	 mov	 rcx, rax
  00074	e8 00 00 00 00	 call	 z900_logical_to_main_l
  00079	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00085	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  0008c	48 89 44 24 48	 mov	 QWORD PTR addr$[rsp], rax
$LN5@z900_store:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	0f 85 77 ff ff
	ff		 jne	 $LN4@z900_store

; 900  : 
; 901  :     /* Set the main storage reference and change bits */
; 902  :     ARCH_DEP( or_storage_key )( addr, (STORKEY_REF | STORKEY_CHANGE) );

  0009b	b2 06		 mov	 dl, 6
  0009d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR addr$[rsp]
  000a2	e8 00 00 00 00	 call	 z900_or_storage_key

; 903  : 
; 904  :     /* Store the fullword into absolute storage */
; 905  :     store_fw( regs->mainstor + addr, value );

  000a7	8b 4c 24 40	 mov	 ecx, DWORD PTR value$[rsp]
  000ab	e8 00 00 00 00	 call	 _byteswap_ulong
  000b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  000bc	48 03 4c 24 48	 add	 rcx, QWORD PTR addr$[rsp]
  000c1	8b d0		 mov	 edx, eax
  000c3	e8 00 00 00 00	 call	 store_fw_noswap

; 906  : 
; 907  : } /* end function store_fullword_absolute */

  000c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cc	c3		 ret	 0
z900_store_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_store_doubleword_absolute
_TEXT	SEGMENT
value$ = 64
addr$ = 72
regs$ = 80
z900_store_doubleword_absolute PROC			; COMDAT

; 863  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900_store:

; 864  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 865  :     if (addr > regs->mainlim - 8)
; 866  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 867  : #endif
; 868  : 
; 869  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 870  :        is treated as a no-operation if SIE_MODE not active */
; 871  :     SIE_TRANSLATE( &addr, ACCTYPE_WRITE, regs );

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00018	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0001e	d1 e8		 shr	 eax, 1
  00020	83 e0 01	 and	 eax, 1
  00023	85 c0		 test	 eax, eax
  00025	74 6b		 je	 SHORT $LN5@z900_store
  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00032	c1 e8 02	 shr	 eax, 2
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	75 56		 jne	 SHORT $LN5@z900_store
  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00041	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00048	48 03 44 24 48	 add	 rax, QWORD PTR addr$[rsp]
  0004d	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00056	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0005b	41 b9 02 00 00
	00		 mov	 r9d, 2
  00061	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  0006d	ba fd ff ff ff	 mov	 edx, -3
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 z900_logical_to_main_l
  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00086	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  0008d	48 89 44 24 48	 mov	 QWORD PTR addr$[rsp], rax
$LN5@z900_store:
  00092	33 c0		 xor	 eax, eax
  00094	85 c0		 test	 eax, eax
  00096	0f 85 77 ff ff
	ff		 jne	 $LN4@z900_store

; 872  : 
; 873  :     /* Set the main storage reference and change bits */
; 874  :     ARCH_DEP( or_storage_key )( addr, (STORKEY_REF | STORKEY_CHANGE) );

  0009c	b2 06		 mov	 dl, 6
  0009e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR addr$[rsp]
  000a3	e8 00 00 00 00	 call	 z900_or_storage_key

; 875  : 
; 876  :     /* Store the doubleword into absolute storage */
; 877  :     store_dw( regs->mainstor + addr, value );

  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR value$[rsp]
  000ad	e8 00 00 00 00	 call	 _byteswap_uint64
  000b2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000b7	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  000be	48 03 4c 24 48	 add	 rcx, QWORD PTR addr$[rsp]
  000c3	48 8b d0	 mov	 rdx, rax
  000c6	e8 00 00 00 00	 call	 store_dw_noswap

; 878  : 
; 879  : } /* end function store_doubleword_absolute */

  000cb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cf	c3		 ret	 0
z900_store_doubleword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_fetch_halfword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
z900_fetch_halfword_absolute PROC			; COMDAT

; 850  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 851  :     return fetch_hw( FETCH_MAIN_ABSOLUTE( addr, regs, 2 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 z900_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_hw_noswap
  00025	0f b7 c8	 movzx	 ecx, ax
  00028	e8 00 00 00 00	 call	 _byteswap_ushort

; 852  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
z900_fetch_halfword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_fetch_fullword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
z900_fetch_fullword_absolute PROC			; COMDAT

; 835  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 836  :     return fetch_fw( FETCH_MAIN_ABSOLUTE( addr, regs, 4 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 z900_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_fw_noswap
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 _byteswap_ulong

; 837  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
z900_fetch_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_fetch_doubleword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
z900_fetch_doubleword_absolute PROC			; COMDAT

; 815  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 816  :     // The change below affects 32 bit hosts that use something like
; 817  :     // cmpxchg8b to fetch the doubleword concurrently.
; 818  :     // This routine is mainly called by DAT in 64 bit guest mode
; 819  :     // to access DAT-related values.  In most `well-behaved' OS's,
; 820  :     // other CPUs should not be interfering with these values
; 821  : 
; 822  :     return fetch_dw( FETCH_MAIN_ABSOLUTE( addr, regs, 8 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 z900_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_dw_noswap
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 _byteswap_uint64

; 823  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
z900_fetch_doubleword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_FPC_check
_TEXT	SEGMENT
regs$ = 48
fpc$ = 56
z900_FPC_check PROC					; COMDAT

; 788  : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 789  :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0000d	b8 01 00 00 00	 mov	 eax, 1
  00012	48 6b c0 04	 imul	 rax, rax, 4
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00023	83 e0 04	 and	 eax, 4
  00026	85 c0		 test	 eax, eax
  00028	74 4e		 je	 SHORT $LN2@z900_FPC_c

; 790  :     {
; 791  :         if (0
; 792  :             || (fpc & FPC_RESV_FPX)
; 793  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV4
; 794  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV5
; 795  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV6

  0002a	33 c0		 xor	 eax, eax
  0002c	85 c0		 test	 eax, eax
  0002e	75 31		 jne	 SHORT $LN5@z900_FPC_c
  00030	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00034	25 88 00 03 03	 and	 eax, 50528392		; 03030088H
  00039	85 c0		 test	 eax, eax
  0003b	75 24		 jne	 SHORT $LN5@z900_FPC_c
  0003d	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00041	83 e0 07	 and	 eax, 7
  00044	83 f8 04	 cmp	 eax, 4
  00047	74 18		 je	 SHORT $LN5@z900_FPC_c
  00049	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  0004d	83 e0 07	 and	 eax, 7
  00050	83 f8 05	 cmp	 eax, 5
  00053	74 0c		 je	 SHORT $LN5@z900_FPC_c
  00055	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00059	83 e0 07	 and	 eax, 7
  0005c	83 f8 06	 cmp	 eax, 6
  0005f	75 15		 jne	 SHORT $LN4@z900_FPC_c
$LN5@z900_FPC_c:

; 796  :         )
; 797  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00061	ba 06 00 00 00	 mov	 edx, 6
  00066	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00070	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN4@z900_FPC_c:

; 798  :     }

  00076	eb 22		 jmp	 SHORT $LN3@z900_FPC_c
$LN2@z900_FPC_c:

; 799  :     else
; 800  :     {
; 801  :         if (fpc & FPC_RESERVED)

  00078	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  0007c	25 8c 00 07 07	 and	 eax, 117899404		; 0707008cH
  00081	85 c0		 test	 eax, eax
  00083	74 15		 je	 SHORT $LN6@z900_FPC_c

; 802  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00085	ba 06 00 00 00	 mov	 edx, 6
  0008a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00094	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@z900_FPC_c:
$LN3@z900_FPC_c:

; 803  :     }
; 804  : }

  0009a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009e	c3		 ret	 0
z900_FPC_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck2
_TEXT	SEGMENT
tv81 = 32
tv131 = 40
tv150 = 48
tv181 = 56
tv166 = 64
regs$ = 96
x2$ = 104
b2$ = 112
z900_per3_zero_xcheck2 PROC				; COMDAT

; 765  : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 766  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 767  :     if (0
; 768  :         || (!b2 && x2 && GR_A( x2, regs ) == 0)
; 769  :         || (!x2 && b2 && GR_A( b2, regs ) == 0)
; 770  :         || ( b2 && x2 && (0

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	0f 85 ba 01 00
	00		 jne	 $LN3@z900_per3_
  0001c	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00021	75 54		 jne	 SHORT $LN4@z900_per3_
  00023	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  00028	74 4d		 je	 SHORT $LN4@z900_per3_
  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0002f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 19		 je	 SHORT $LN8@z900_per3_
  0003c	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00041	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00046	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0004e	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
  00053	eb 16		 jmp	 SHORT $LN9@z900_per3_
$LN8@z900_per3_:
  00055	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00066	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
$LN9@z900_per3_:
  0006b	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv81[rsp], 0
  00071	0f 84 5f 01 00
	00		 je	 $LN3@z900_per3_
$LN4@z900_per3_:
  00077	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  0007c	75 54		 jne	 SHORT $LN5@z900_per3_
  0007e	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 4d		 je	 SHORT $LN5@z900_per3_
  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00090	83 e0 01	 and	 eax, 1
  00093	85 c0		 test	 eax, eax
  00095	74 19		 je	 SHORT $LN10@z900_per3_
  00097	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a9	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
  000ae	eb 16		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  000b0	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000ba	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c1	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
$LN11@z900_per3_:
  000c6	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv131[rsp], 0
  000cc	0f 84 04 01 00
	00		 je	 $LN3@z900_per3_
$LN5@z900_per3_:
  000d2	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  000d7	0f 84 03 01 00
	00		 je	 $LN2@z900_per3_
  000dd	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  000e2	0f 84 f8 00 00
	00		 je	 $LN2@z900_per3_
  000e8	33 c0		 xor	 eax, eax
  000ea	85 c0		 test	 eax, eax
  000ec	0f 85 e4 00 00
	00		 jne	 $LN6@z900_per3_
  000f2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 19		 je	 SHORT $LN12@z900_per3_
  00104	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00109	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00116	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
  0011b	eb 16		 jmp	 SHORT $LN13@z900_per3_
$LN12@z900_per3_:
  0011d	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0012e	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
$LN13@z900_per3_:
  00133	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv150[rsp], 0
  00139	0f 84 97 00 00
	00		 je	 $LN6@z900_per3_
  0013f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00144	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0014a	83 e0 01	 and	 eax, 1
  0014d	85 c0		 test	 eax, eax
  0014f	74 19		 je	 SHORT $LN14@z900_per3_
  00151	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00156	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0015b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00163	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
  00168	eb 16		 jmp	 SHORT $LN15@z900_per3_
$LN14@z900_per3_:
  0016a	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00174	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0017b	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
$LN15@z900_per3_:
  00180	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00185	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0018b	83 e0 01	 and	 eax, 1
  0018e	85 c0		 test	 eax, eax
  00190	74 19		 je	 SHORT $LN16@z900_per3_
  00192	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00197	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0019c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001a4	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
  001a9	eb 16		 jmp	 SHORT $LN17@z900_per3_
$LN16@z900_per3_:
  001ab	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  001b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001bc	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
$LN17@z900_per3_:
  001c1	48 8b 44 24 38	 mov	 rax, QWORD PTR tv181[rsp]
  001c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv166[rsp]
  001cb	48 03 c8	 add	 rcx, rax
  001ce	48 8b c1	 mov	 rax, rcx
  001d1	48 85 c0	 test	 rax, rax
  001d4	75 0a		 jne	 SHORT $LN2@z900_per3_
$LN6@z900_per3_:
$LN3@z900_per3_:

; 771  :                           || GR_A( b2, regs ) == 0
; 772  :                           || GR_A( b2, regs ) + GR_A( x2, regs ) == 0
; 773  :                          )
; 774  :            )
; 775  :     )
; 776  :         ARCH_DEP( per3_zero )( regs );

  001d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 777  : #else
; 778  :     UNREFERENCED( regs );
; 779  :     UNREFERENCED( x2 );
; 780  :     UNREFERENCED( b2 );
; 781  : #endif
; 782  : }

  001e0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e4	c3		 ret	 0
z900_per3_zero_xcheck2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck
_TEXT	SEGMENT
tv79 = 32
regs$ = 64
b1$ = 72
z900_per3_zero_xcheck PROC				; COMDAT

; 754  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 755  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 756  :     if (b1 && GR_A( b1, regs ) == 0)

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  00012	74 53		 je	 SHORT $LN2@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 19		 je	 SHORT $LN4@z900_per3_
  00026	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00030	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00038	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  0003d	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  0003f	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00050	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN5@z900_per3_:
  00055	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  0005b	75 0a		 jne	 SHORT $LN2@z900_per3_

; 757  :         ARCH_DEP( per3_zero )( regs );

  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 758  : #else
; 759  :     UNREFERENCED( regs );
; 760  :     UNREFERENCED( b1 );
; 761  : #endif
; 762  : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
z900_per3_zero_xcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_l24check2
_TEXT	SEGMENT
tv87 = 32
tv143 = 40
regs$ = 64
r1$ = 72
l1$ = 80
r2$ = 88
l2$ = 96
z900_per3_zero_l24check2 PROC				; COMDAT

; 723  : {

$LN10:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 724  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 725  :     if (0
; 726  :         || (1
; 727  :             && regs->GR_LA24( l1 ) != 0
; 728  :             && GR_A( r1, regs )    == 0
; 729  :            )
; 730  :         || (1

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	0f 85 d4 00 00
	00		 jne	 $LN3@z900_per3_
  00021	33 c0		 xor	 eax, eax
  00023	83 f8 01	 cmp	 eax, 1
  00026	74 63		 je	 SHORT $LN4@z900_per3_
  00028	48 63 44 24 50	 movsxd	 rax, DWORD PTR l1$[rsp]
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00032	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00039	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0003e	85 c0		 test	 eax, eax
  00040	74 49		 je	 SHORT $LN4@z900_per3_
  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00047	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0004d	83 e0 01	 and	 eax, 1
  00050	85 c0		 test	 eax, eax
  00052	74 19		 je	 SHORT $LN6@z900_per3_
  00054	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00066	48 89 44 24 20	 mov	 QWORD PTR tv87[rsp], rax
  0006b	eb 16		 jmp	 SHORT $LN7@z900_per3_
$LN6@z900_per3_:
  0006d	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007e	48 89 44 24 20	 mov	 QWORD PTR tv87[rsp], rax
$LN7@z900_per3_:
  00083	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv87[rsp], 0
  00089	74 6a		 je	 SHORT $LN3@z900_per3_
$LN4@z900_per3_:
  0008b	33 c0		 xor	 eax, eax
  0008d	83 f8 01	 cmp	 eax, 1
  00090	74 6d		 je	 SHORT $LN2@z900_per3_
  00092	48 63 44 24 60	 movsxd	 rax, DWORD PTR l2$[rsp]
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000a3	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000a8	85 c0		 test	 eax, eax
  000aa	74 53		 je	 SHORT $LN2@z900_per3_
  000ac	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000b7	83 e0 01	 and	 eax, 1
  000ba	85 c0		 test	 eax, eax
  000bc	74 19		 je	 SHORT $LN8@z900_per3_
  000be	48 63 44 24 58	 movsxd	 rax, DWORD PTR r2$[rsp]
  000c3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000c8	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000d0	48 89 44 24 28	 mov	 QWORD PTR tv143[rsp], rax
  000d5	eb 16		 jmp	 SHORT $LN9@z900_per3_
$LN8@z900_per3_:
  000d7	48 63 44 24 58	 movsxd	 rax, DWORD PTR r2$[rsp]
  000dc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000e1	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000e8	48 89 44 24 28	 mov	 QWORD PTR tv143[rsp], rax
$LN9@z900_per3_:
  000ed	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv143[rsp], 0
  000f3	75 0a		 jne	 SHORT $LN2@z900_per3_
$LN3@z900_per3_:

; 731  :             && regs->GR_LA24( l2 ) != 0
; 732  :             && GR_A( r2, regs )    == 0
; 733  :            )
; 734  :     )
; 735  :         ARCH_DEP( per3_zero )( regs );

  000f5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 736  : #else
; 737  :     UNREFERENCED( regs );
; 738  :     UNREFERENCED( r1 );
; 739  :     UNREFERENCED( l1 );
; 740  :     UNREFERENCED( r2 );
; 741  :     UNREFERENCED( l2 );
; 742  : #endif
; 743  : }

  000ff	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00103	c3		 ret	 0
z900_per3_zero_l24check2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_l24check
_TEXT	SEGMENT
tv86 = 32
regs$ = 64
r1$ = 72
l1$ = 80
z900_per3_zero_l24check PROC				; COMDAT

; 708  : {

$LN6:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 709  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 710  :     if (1
; 711  :         && regs->GR_LA24( l1 ) != 0
; 712  :         && GR_A( r1, regs )    == 0

  00012	33 c0		 xor	 eax, eax
  00014	83 f8 01	 cmp	 eax, 1
  00017	74 6d		 je	 SHORT $LN2@z900_per3_
  00019	48 63 44 24 50	 movsxd	 rax, DWORD PTR l1$[rsp]
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00023	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0002a	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0002f	85 c0		 test	 eax, eax
  00031	74 53		 je	 SHORT $LN2@z900_per3_
  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00038	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0003e	83 e0 01	 and	 eax, 1
  00041	85 c0		 test	 eax, eax
  00043	74 19		 je	 SHORT $LN4@z900_per3_
  00045	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00057	48 89 44 24 20	 mov	 QWORD PTR tv86[rsp], rax
  0005c	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  0005e	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00068	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006f	48 89 44 24 20	 mov	 QWORD PTR tv86[rsp], rax
$LN5@z900_per3_:
  00074	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv86[rsp], 0
  0007a	75 0a		 jne	 SHORT $LN2@z900_per3_

; 713  :     )
; 714  :         ARCH_DEP( per3_zero )( regs );

  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 715  : #else
; 716  :     UNREFERENCED( regs );
; 717  :     UNREFERENCED( r1 );
; 718  :     UNREFERENCED( l1 );
; 719  : #endif
; 720  : }

  00086	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008a	c3		 ret	 0
z900_per3_zero_l24check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_lcheck2
_TEXT	SEGMENT
tv80 = 32
tv128 = 40
tv145 = 48
tv161 = 56
regs$ = 80
r1$ = 88
l1$ = 96
r2$ = 104
l2$ = 112
z900_per3_zero_lcheck2 PROC				; COMDAT

; 677  : {

$LN14:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 678  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 679  :     if (0
; 680  :         || (1
; 681  :             && GR_A( l1, regs ) != 0
; 682  :             && GR_A( r1, regs ) == 0
; 683  :            )
; 684  :         || (1

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	0f 85 3e 01 00
	00		 jne	 $LN3@z900_per3_
  00021	33 c0		 xor	 eax, eax
  00023	83 f8 01	 cmp	 eax, 1
  00026	0f 84 96 00 00
	00		 je	 $LN4@z900_per3_
  0002c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00031	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00037	83 e0 01	 and	 eax, 1
  0003a	85 c0		 test	 eax, eax
  0003c	74 19		 je	 SHORT $LN6@z900_per3_
  0003e	48 63 44 24 60	 movsxd	 rax, DWORD PTR l1$[rsp]
  00043	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00050	48 89 44 24 20	 mov	 QWORD PTR tv80[rsp], rax
  00055	eb 16		 jmp	 SHORT $LN7@z900_per3_
$LN6@z900_per3_:
  00057	48 63 44 24 60	 movsxd	 rax, DWORD PTR l1$[rsp]
  0005c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00068	48 89 44 24 20	 mov	 QWORD PTR tv80[rsp], rax
$LN7@z900_per3_:
  0006d	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv80[rsp], 0
  00073	74 4d		 je	 SHORT $LN4@z900_per3_
  00075	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00080	83 e0 01	 and	 eax, 1
  00083	85 c0		 test	 eax, eax
  00085	74 19		 je	 SHORT $LN8@z900_per3_
  00087	48 63 44 24 58	 movsxd	 rax, DWORD PTR r1$[rsp]
  0008c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00091	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00099	48 89 44 24 28	 mov	 QWORD PTR tv128[rsp], rax
  0009e	eb 16		 jmp	 SHORT $LN9@z900_per3_
$LN8@z900_per3_:
  000a0	48 63 44 24 58	 movsxd	 rax, DWORD PTR r1$[rsp]
  000a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000aa	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b1	48 89 44 24 28	 mov	 QWORD PTR tv128[rsp], rax
$LN9@z900_per3_:
  000b6	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv128[rsp], 0
  000bc	0f 84 9d 00 00
	00		 je	 $LN3@z900_per3_
$LN4@z900_per3_:
  000c2	33 c0		 xor	 eax, eax
  000c4	83 f8 01	 cmp	 eax, 1
  000c7	0f 84 9c 00 00
	00		 je	 $LN2@z900_per3_
  000cd	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000d8	83 e0 01	 and	 eax, 1
  000db	85 c0		 test	 eax, eax
  000dd	74 19		 je	 SHORT $LN10@z900_per3_
  000df	48 63 44 24 70	 movsxd	 rax, DWORD PTR l2$[rsp]
  000e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000e9	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000f1	48 89 44 24 30	 mov	 QWORD PTR tv145[rsp], rax
  000f6	eb 16		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  000f8	48 63 44 24 70	 movsxd	 rax, DWORD PTR l2$[rsp]
  000fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00102	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00109	48 89 44 24 30	 mov	 QWORD PTR tv145[rsp], rax
$LN11@z900_per3_:
  0010e	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv145[rsp], 0
  00114	74 53		 je	 SHORT $LN2@z900_per3_
  00116	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0011b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00121	83 e0 01	 and	 eax, 1
  00124	85 c0		 test	 eax, eax
  00126	74 19		 je	 SHORT $LN12@z900_per3_
  00128	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  0012d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0013a	48 89 44 24 38	 mov	 QWORD PTR tv161[rsp], rax
  0013f	eb 16		 jmp	 SHORT $LN13@z900_per3_
$LN12@z900_per3_:
  00141	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  00146	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0014b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00152	48 89 44 24 38	 mov	 QWORD PTR tv161[rsp], rax
$LN13@z900_per3_:
  00157	48 83 7c 24 38
	00		 cmp	 QWORD PTR tv161[rsp], 0
  0015d	75 0a		 jne	 SHORT $LN2@z900_per3_
$LN3@z900_per3_:

; 685  :             && GR_A( l2, regs ) != 0
; 686  :             && GR_A( r2, regs ) == 0
; 687  :            )
; 688  :     )
; 689  :         ARCH_DEP( per3_zero )( regs );

  0015f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00164	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 690  : #else
; 691  :     UNREFERENCED( regs );
; 692  :     UNREFERENCED( r1 );
; 693  :     UNREFERENCED( l1 );
; 694  :     UNREFERENCED( r2 );
; 695  :     UNREFERENCED( l2 );
; 696  : #endif
; 697  : }

  00169	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0016d	c3		 ret	 0
z900_per3_zero_lcheck2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_lcheck
_TEXT	SEGMENT
tv79 = 32
tv95 = 40
regs$ = 64
r1$ = 72
l1$ = 80
z900_per3_zero_lcheck PROC				; COMDAT

; 662  : {

$LN8:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 663  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 664  :     if (1
; 665  :         && GR_A( l1, regs ) != 0
; 666  :         && GR_A( r1, regs ) == 0

  00012	33 c0		 xor	 eax, eax
  00014	83 f8 01	 cmp	 eax, 1
  00017	0f 84 9c 00 00
	00		 je	 $LN2@z900_per3_
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00028	83 e0 01	 and	 eax, 1
  0002b	85 c0		 test	 eax, eax
  0002d	74 19		 je	 SHORT $LN4@z900_per3_
  0002f	48 63 44 24 50	 movsxd	 rax, DWORD PTR l1$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00039	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00041	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  00046	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  00048	48 63 44 24 50	 movsxd	 rax, DWORD PTR l1$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00059	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN5@z900_per3_:
  0005e	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  00064	74 53		 je	 SHORT $LN2@z900_per3_
  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00071	83 e0 01	 and	 eax, 1
  00074	85 c0		 test	 eax, eax
  00076	74 19		 je	 SHORT $LN6@z900_per3_
  00078	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  0007d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0008a	48 89 44 24 28	 mov	 QWORD PTR tv95[rsp], rax
  0008f	eb 16		 jmp	 SHORT $LN7@z900_per3_
$LN6@z900_per3_:
  00091	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00096	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0009b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000a2	48 89 44 24 28	 mov	 QWORD PTR tv95[rsp], rax
$LN7@z900_per3_:
  000a7	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv95[rsp], 0
  000ad	75 0a		 jne	 SHORT $LN2@z900_per3_

; 667  :     )
; 668  :         ARCH_DEP( per3_zero )( regs );

  000af	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000b4	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 669  : #else
; 670  :     UNREFERENCED( regs );
; 671  :     UNREFERENCED( r1 );
; 672  :     UNREFERENCED( l1 );
; 673  : #endif
; 674  : }

  000b9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bd	c3		 ret	 0
z900_per3_zero_lcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_check2
_TEXT	SEGMENT
tv79 = 32
tv95 = 40
regs$ = 64
r1$ = 72
r2$ = 80
z900_per3_zero_check2 PROC				; COMDAT

; 640  : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 642  :     if (0
; 643  :         || GR_A( r1, regs ) == 0
; 644  :         || GR_A( r2, regs ) == 0

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	0f 85 92 00 00
	00		 jne	 $LN3@z900_per3_
  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00021	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 19		 je	 SHORT $LN5@z900_per3_
  0002e	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00038	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00040	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  00045	eb 16		 jmp	 SHORT $LN6@z900_per3_
$LN5@z900_per3_:
  00047	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00051	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00058	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN6@z900_per3_:
  0005d	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  00063	74 49		 je	 SHORT $LN3@z900_per3_
  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00070	83 e0 01	 and	 eax, 1
  00073	85 c0		 test	 eax, eax
  00075	74 19		 je	 SHORT $LN7@z900_per3_
  00077	48 63 44 24 50	 movsxd	 rax, DWORD PTR r2$[rsp]
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00089	48 89 44 24 28	 mov	 QWORD PTR tv95[rsp], rax
  0008e	eb 16		 jmp	 SHORT $LN8@z900_per3_
$LN7@z900_per3_:
  00090	48 63 44 24 50	 movsxd	 rax, DWORD PTR r2$[rsp]
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000a1	48 89 44 24 28	 mov	 QWORD PTR tv95[rsp], rax
$LN8@z900_per3_:
  000a6	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv95[rsp], 0
  000ac	75 0a		 jne	 SHORT $LN2@z900_per3_
$LN3@z900_per3_:

; 645  :     )
; 646  :         ARCH_DEP( per3_zero )( regs );

  000ae	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 647  : #else
; 648  :     UNREFERENCED( regs );
; 649  :     UNREFERENCED( r1 );
; 650  :     UNREFERENCED( r2 );
; 651  : #endif
; 652  : }

  000b8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bc	c3		 ret	 0
z900_per3_zero_check2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_check
_TEXT	SEGMENT
tv78 = 32
regs$ = 64
r1$ = 72
z900_per3_zero_check PROC				; COMDAT

; 629  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 630  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 631  :     if (GR_A( r1, regs ) == 0)

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00012	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00018	83 e0 01	 and	 eax, 1
  0001b	85 c0		 test	 eax, eax
  0001d	74 19		 je	 SHORT $LN4@z900_per3_
  0001f	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00029	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00031	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
  00036	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  00038	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00049	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
$LN5@z900_per3_:
  0004e	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv78[rsp], 0
  00054	75 0a		 jne	 SHORT $LN2@z900_per3_

; 632  :         ARCH_DEP( per3_zero )( regs );

  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 633  : #else
; 634  :     UNREFERENCED( regs );
; 635  :     UNREFERENCED( r1 );
; 636  : #endif
; 637  : }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
z900_per3_zero_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per1_gra
_TEXT	SEGMENT
regs$ = 8
z900_per1_gra PROC					; COMDAT

; 546  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@z900_per1_:

; 547  : #if !defined( FEATURE_PER1 )
; 548  :     UNREFERENCED( regs );

  00005	33 c0		 xor	 eax, eax
  00007	85 c0		 test	 eax, eax
  00009	75 fa		 jne	 SHORT $LN4@z900_per1_

; 549  : #else
; 550  :     OBTAIN_INTLOCK( regs );
; 551  :     {
; 552  :         regs->peradr = regs->periaddr;
; 553  :         ON_IC_PER_GRA( regs );
; 554  :     }
; 555  :     RELEASE_INTLOCK( regs );
; 556  : 
; 557  :     if (OPEN_IC_PER_GRA( regs ))
; 558  :         RETURN_INTCHECK( regs );
; 559  : #endif
; 560  : }

  0000b	c3		 ret	 0
z900_per1_gra ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_fetch_main_absolute
_TEXT	SEGMENT
addr$ = 64
regs$ = 72
z900_fetch_main_absolute PROC				; COMDAT

; 524  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900_fetch:

; 525  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 526  :     if (addr > (regs->mainlim - len))
; 527  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 528  : #endif
; 529  : 
; 530  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 531  :        is treated as a no-operation if SIE_MODE not active */
; 532  :     SIE_TRANSLATE( &addr, ACCTYPE_READ, regs );

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00019	d1 e8		 shr	 eax, 1
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 6b		 je	 SHORT $LN5@z900_fetch
  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0002d	c1 e8 02	 shr	 eax, 2
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	75 56		 jne	 SHORT $LN5@z900_fetch
  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0003c	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00043	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]
  00048	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00051	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00056	41 b9 04 00 00
	00		 mov	 r9d, 4
  0005c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00068	ba fd ff ff ff	 mov	 edx, -3
  0006d	48 8b c8	 mov	 rcx, rax
  00070	e8 00 00 00 00	 call	 z900_logical_to_main_l
  00075	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00081	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  00088	48 89 44 24 40	 mov	 QWORD PTR addr$[rsp], rax
$LN5@z900_fetch:
  0008d	33 c0		 xor	 eax, eax
  0008f	85 c0		 test	 eax, eax
  00091	0f 85 77 ff ff
	ff		 jne	 $LN4@z900_fetch

; 533  : 
; 534  :     /* Set the main storage reference bit */
; 535  :     ARCH_DEP( or_storage_key )( addr, STORKEY_REF );

  00097	b2 04		 mov	 dl, 4
  00099	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr$[rsp]
  0009e	e8 00 00 00 00	 call	 z900_or_storage_key

; 536  : 
; 537  :     /* Return absolute storage mainstor address */
; 538  :     return (regs->mainstor + addr);

  000a3	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000af	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]

; 539  : 
; 540  : } /* end function fetch_main_absolute */

  000b4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b8	c3		 ret	 0
z900_fetch_main_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_store_protected
_TEXT	SEGMENT
addr$ = 48
skey$ = 56
akey$ = 64
regs$ = 72
z900_is_store_protected PROC				; COMDAT

; 469  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 470  :     /* [3.4.4] Low-address protection prohibits stores into certain
; 471  :        locations in the prefixed storage area of non-private address
; 472  :        address spaces, if the low-address control bit in CR0 is set,
; 473  :        regardless of the access key and storage key */
; 474  :     if (ARCH_DEP( is_low_address_protected )( addr, regs ))

  00017	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  0001c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00021	e8 00 00 00 00	 call	 z900_is_low_address_protected
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	74 07		 je	 SHORT $LN2@z900_is_st

; 475  :         return true;

  0002d	b0 01		 mov	 al, 1
  0002f	e9 b2 00 00 00	 jmp	 $LN1@z900_is_st
$LN2@z900_is_st:

; 476  : 
; 477  :     /* Access-list controlled protection prohibits all stores into
; 478  :        the address space, and page protection prohibits all stores
; 479  :        into the page, regardless of the access key and storage key */
; 480  :     if (regs->dat.protect)

  00034	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00039	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0003f	d1 e8		 shr	 eax, 1
  00041	83 e0 03	 and	 eax, 3
  00044	85 c0		 test	 eax, eax
  00046	74 07		 je	 SHORT $LN3@z900_is_st

; 481  :         return true;

  00048	b0 01		 mov	 al, 1
  0004a	e9 97 00 00 00	 jmp	 $LN1@z900_is_st
$LN3@z900_is_st:

; 482  : 
; 483  : #if defined( _FEATURE_SIE )
; 484  :     if (SIE_MODE( regs ) && HOSTREGS->dat.protect)

  0004f	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00054	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0005a	d1 e8		 shr	 eax, 1
  0005c	83 e0 01	 and	 eax, 1
  0005f	85 c0		 test	 eax, eax
  00061	74 1f		 je	 SHORT $LN4@z900_is_st
  00063	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00068	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0006f	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00075	d1 e8		 shr	 eax, 1
  00077	83 e0 03	 and	 eax, 3
  0007a	85 c0		 test	 eax, eax
  0007c	74 04		 je	 SHORT $LN4@z900_is_st

; 485  :         return true;

  0007e	b0 01		 mov	 al, 1
  00080	eb 64		 jmp	 SHORT $LN1@z900_is_st
$LN4@z900_is_st:

; 486  : #endif
; 487  : 
; 488  :     /* [3.4.1] Store is allowed if access key is zero, regardless
; 489  :        of the storage key */
; 490  :     if (akey == 0)

  00082	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey$[rsp]
  00087	85 c0		 test	 eax, eax
  00089	75 04		 jne	 SHORT $LN5@z900_is_st

; 491  :         return false;

  0008b	32 c0		 xor	 al, al
  0008d	eb 57		 jmp	 SHORT $LN1@z900_is_st
$LN5@z900_is_st:

; 492  : 
; 493  : #if defined( FEATURE_STORAGE_PROTECTION_OVERRIDE )
; 494  :     /* [3.4.1.1] Storage protection override allows access to
; 495  :        locations with storage key 9, regardless of the access key,
; 496  :        provided that CR0 bit 7 is set */
; 497  :     if (1
; 498  :         && (skey & STORKEY_KEY) == 0x90
; 499  :         && (regs->CR(0) & CR0_STORE_OVRD)

  0008f	33 c0		 xor	 eax, eax
  00091	83 f8 01	 cmp	 eax, 1
  00094	74 36		 je	 SHORT $LN6@z900_is_st
  00096	0f b6 44 24 38	 movzx	 eax, BYTE PTR skey$[rsp]
  0009b	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000a0	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  000a5	75 25		 jne	 SHORT $LN6@z900_is_st
  000a7	b8 08 00 00 00	 mov	 eax, 8
  000ac	48 6b c0 01	 imul	 rax, rax, 1
  000b0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000bd	48 25 00 00 00
	01		 and	 rax, 16777216		; 01000000H
  000c3	48 85 c0	 test	 rax, rax
  000c6	74 04		 je	 SHORT $LN6@z900_is_st

; 500  :     )
; 501  :         return false;

  000c8	32 c0		 xor	 al, al
  000ca	eb 1a		 jmp	 SHORT $LN1@z900_is_st
$LN6@z900_is_st:

; 502  : #endif
; 503  : 
; 504  :     /* [3.4.1] Store protection prohibits stores
; 505  :        if the access key does not match the storage key */
; 506  :     if (akey != (skey & STORKEY_KEY))

  000cc	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey$[rsp]
  000d1	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR skey$[rsp]
  000d6	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  000dc	3b c1		 cmp	 eax, ecx
  000de	74 04		 je	 SHORT $LN7@z900_is_st

; 507  :         return true;

  000e0	b0 01		 mov	 al, 1
  000e2	eb 02		 jmp	 SHORT $LN1@z900_is_st
$LN7@z900_is_st:

; 508  : 
; 509  :     return false;      // (location is *NOT* store protected)

  000e4	32 c0		 xor	 al, al
$LN1@z900_is_st:

; 510  : 
; 511  : } /* end function is_store_protected */

  000e6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ea	c3		 ret	 0
z900_is_store_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_low_address_protected
_TEXT	SEGMENT
addr$ = 8
regs$ = 16
z900_is_low_address_protected PROC			; COMDAT

; 419  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 420  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 421  :     /* For z/Arch, low-address protection applies to locations
; 422  :        0-511 (0000-01FF) and also 4096-4607 (1000-11FF) */
; 423  :     if (addr & 0xFFFFFFFFFFFFEE00ULL)

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR addr$[rsp]
  0000f	48 25 00 ee ff
	ff		 and	 rax, -4608		; ffffffffffffee00H
  00015	48 85 c0	 test	 rax, rax
  00018	74 04		 je	 SHORT $LN2@z900_is_lo

; 424  : #else
; 425  :     /* For S/370 and ESA/390, low-address protection applies
; 426  :        only to locations 0-511 */
; 427  :     if (addr > 511)
; 428  : #endif
; 429  :         return false;

  0001a	32 c0		 xor	 al, al
  0001c	eb 53		 jmp	 SHORT $LN1@z900_is_lo
$LN2@z900_is_lo:

; 430  : 
; 431  :     /* Low-address protection applies only if the low-address
; 432  :        protection control bit in control register 0 is set */
; 433  :     if (!(regs->CR(0) & CR0_LOW_PROT))

  0001e	b8 08 00 00 00	 mov	 eax, 8
  00023	48 6b c0 01	 imul	 rax, rax, 1
  00027	48 8b 4c 24 10	 mov	 rcx, QWORD PTR regs$[rsp]
  0002c	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00034	48 25 00 00 00
	10		 and	 rax, 268435456		; 10000000H
  0003a	48 85 c0	 test	 rax, rax
  0003d	75 04		 jne	 SHORT $LN3@z900_is_lo

; 434  :         return false;

  0003f	32 c0		 xor	 al, al
  00041	eb 2e		 jmp	 SHORT $LN1@z900_is_lo
$LN3@z900_is_lo:

; 435  : 
; 436  : #if defined( _FEATURE_SIE )
; 437  :     /* Host low-address protection is not applied to guest
; 438  :        references to guest storage */
; 439  :     if (regs->sie_active)

  00043	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  00048	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0004e	83 e0 01	 and	 eax, 1
  00051	85 c0		 test	 eax, eax
  00053	74 04		 je	 SHORT $LN4@z900_is_lo

; 440  :         return false;

  00055	32 c0		 xor	 al, al
  00057	eb 18		 jmp	 SHORT $LN1@z900_is_lo
$LN4@z900_is_lo:

; 441  : #endif
; 442  : 
; 443  :     /* Low-addr protection doesn't apply to private address spaces */
; 444  :     if (regs->dat.pvtaddr)

  00059	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  0005e	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00064	83 e0 01	 and	 eax, 1
  00067	85 c0		 test	 eax, eax
  00069	74 04		 je	 SHORT $LN5@z900_is_lo

; 445  :         return false;

  0006b	32 c0		 xor	 al, al
  0006d	eb 02		 jmp	 SHORT $LN1@z900_is_lo
$LN5@z900_is_lo:

; 446  : 
; 447  :     return true;      // (location *IS* low-address protected)

  0006f	b0 01		 mov	 al, 1
$LN1@z900_is_lo:

; 448  : 
; 449  : } /* end function is_low_address_protected */

  00071	c3		 ret	 0
z900_is_low_address_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_fetch_protected
_TEXT	SEGMENT
tv87 = 0
addr$ = 32
skey$ = 40
akey$ = 48
regs$ = 56
z900_is_fetch_protected PROC				; COMDAT

; 365  : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 18	 sub	 rsp, 24
$LN4@z900_is_fe:

; 366  :     UNREFERENCED_370( addr );

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@z900_is_fe
$LN7@z900_is_fe:

; 367  :     UNREFERENCED_370( regs );

  0001d	33 c0		 xor	 eax, eax
  0001f	85 c0		 test	 eax, eax
  00021	75 fa		 jne	 SHORT $LN7@z900_is_fe

; 368  : 
; 369  :     /* [3.4.1] Fetch is allowed if access key is zero, regardless
; 370  :        of the storage key and fetch protection bit */
; 371  :     /* [3.4.1] Fetch protection prohibits fetch if storage key fetch
; 372  :        protect bit is on and access key does not match storage key */
; 373  :     if (likely(0

  00023	33 c0		 xor	 eax, eax
  00025	85 c0		 test	 eax, eax
  00027	75 32		 jne	 SHORT $LN12@z900_is_fe
  00029	0f b6 44 24 30	 movzx	 eax, BYTE PTR akey$[rsp]
  0002e	85 c0		 test	 eax, eax
  00030	74 29		 je	 SHORT $LN12@z900_is_fe
  00032	0f b6 44 24 30	 movzx	 eax, BYTE PTR akey$[rsp]
  00037	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR skey$[rsp]
  0003c	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00042	3b c1		 cmp	 eax, ecx
  00044	74 15		 je	 SHORT $LN12@z900_is_fe
  00046	0f b6 44 24 28	 movzx	 eax, BYTE PTR skey$[rsp]
  0004b	83 e0 08	 and	 eax, 8
  0004e	85 c0		 test	 eax, eax
  00050	74 09		 je	 SHORT $LN12@z900_is_fe
  00052	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv87[rsp], 0
  00059	eb 07		 jmp	 SHORT $LN15@z900_is_fe
$LN12@z900_is_fe:
  0005b	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv87[rsp], 1
$LN15@z900_is_fe:
  00062	83 3c 24 00	 cmp	 DWORD PTR tv87[rsp], 0
  00066	74 07		 je	 SHORT $LN8@z900_is_fe

; 374  :                || akey == 0
; 375  :                || akey == (skey & STORKEY_KEY)
; 376  :                || !(skey & STORKEY_FETCH)
; 377  :               )
; 378  :     )
; 379  :         return false;

  00068	32 c0		 xor	 al, al
  0006a	e9 88 00 00 00	 jmp	 $LN1@z900_is_fe
$LN8@z900_is_fe:

; 380  : 
; 381  : #if defined( FEATURE_FETCH_PROTECTION_OVERRIDE )
; 382  :     /* [3.4.1.2] Fetch protection override allows fetch from first
; 383  :        2K of non-private address spaces if CR0 bit 6 is set */
; 384  :     if (1
; 385  :         && addr < 2048
; 386  :         && (regs->CR(0) & CR0_FETCH_OVRD)
; 387  :         && regs->dat.pvtaddr == 0

  0006f	33 c0		 xor	 eax, eax
  00071	83 f8 01	 cmp	 eax, 1
  00074	74 42		 je	 SHORT $LN9@z900_is_fe
  00076	48 81 7c 24 20
	00 08 00 00	 cmp	 QWORD PTR addr$[rsp], 2048 ; 00000800H
  0007f	73 37		 jae	 SHORT $LN9@z900_is_fe
  00081	b8 08 00 00 00	 mov	 eax, 8
  00086	48 6b c0 01	 imul	 rax, rax, 1
  0008a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00097	48 25 00 00 00
	02		 and	 rax, 33554432		; 02000000H
  0009d	48 85 c0	 test	 rax, rax
  000a0	74 16		 je	 SHORT $LN9@z900_is_fe
  000a2	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  000ad	83 e0 01	 and	 eax, 1
  000b0	85 c0		 test	 eax, eax
  000b2	75 04		 jne	 SHORT $LN9@z900_is_fe

; 388  :     )
; 389  :         return false;

  000b4	32 c0		 xor	 al, al
  000b6	eb 3f		 jmp	 SHORT $LN1@z900_is_fe
$LN9@z900_is_fe:

; 390  : #endif
; 391  : 
; 392  : #if defined( FEATURE_STORAGE_PROTECTION_OVERRIDE )
; 393  :     /* [3.4.1.1] Storage protection override allows access to
; 394  :        locations with storage key 9, regardless of the access key,
; 395  :        provided that CR0 bit 7 is set */
; 396  :     if (1
; 397  :         && (skey & STORKEY_KEY) == 0x90
; 398  :         && (regs->CR(0) & CR0_STORE_OVRD)

  000b8	33 c0		 xor	 eax, eax
  000ba	83 f8 01	 cmp	 eax, 1
  000bd	74 36		 je	 SHORT $LN10@z900_is_fe
  000bf	0f b6 44 24 28	 movzx	 eax, BYTE PTR skey$[rsp]
  000c4	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000c9	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  000ce	75 25		 jne	 SHORT $LN10@z900_is_fe
  000d0	b8 08 00 00 00	 mov	 eax, 8
  000d5	48 6b c0 01	 imul	 rax, rax, 1
  000d9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  000de	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  000e6	48 25 00 00 00
	01		 and	 rax, 16777216		; 01000000H
  000ec	48 85 c0	 test	 rax, rax
  000ef	74 04		 je	 SHORT $LN10@z900_is_fe

; 399  :     )
; 400  :         return false;

  000f1	32 c0		 xor	 al, al
  000f3	eb 02		 jmp	 SHORT $LN1@z900_is_fe
$LN10@z900_is_fe:

; 401  : #endif
; 402  : 
; 403  :     return true;    // (location *IS* fetch protected)

  000f5	b0 01		 mov	 al, 1
$LN1@z900_is_fe:

; 404  : 
; 405  : } /* end function is_fetch_protected */

  000f7	48 83 c4 18	 add	 rsp, 24
  000fb	c3		 ret	 0
z900_is_fetch_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_store_fullword_absolute
_TEXT	SEGMENT
tv128 = 48
value$ = 80
addr$ = 88
regs$ = 96
s390_store_fullword_absolute PROC			; COMDAT

; 891  : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_store:

; 892  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 893  :     if (addr > regs->mainlim - 4)
; 894  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 895  : #endif
; 896  : 
; 897  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 898  :        is treated as a no-operation if SIE_MODE not active */
; 899  :     SIE_TRANSLATE( &addr, ACCTYPE_WRITE, regs );

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00017	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0001d	d1 e8		 shr	 eax, 1
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	0f 84 ca 00 00
	00		 je	 $LN5@s390_store
  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0002f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00035	c1 e8 02	 shr	 eax, 2
  00038	83 e0 01	 and	 eax, 1
  0003b	85 c0		 test	 eax, eax
  0003d	0f 85 b1 00 00
	00		 jne	 $LN5@s390_store
  00043	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00048	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0004f	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  00053	75 44		 jne	 SHORT $LN7@s390_store
  00055	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0005a	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00061	48 03 44 24 58	 add	 rax, QWORD PTR addr$[rsp]
  00066	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  0006f	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00074	41 b9 02 00 00
	00		 mov	 r9d, 2
  0007a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0007f	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00086	ba fd ff ff ff	 mov	 edx, -3
  0008b	8b c8		 mov	 ecx, eax
  0008d	e8 00 00 00 00	 call	 s390_logical_to_main_l
  00092	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
  00097	eb 43		 jmp	 SHORT $LN8@s390_store
$LN7@s390_store:
  00099	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  000a5	48 03 44 24 58	 add	 rax, QWORD PTR addr$[rsp]
  000aa	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  000b3	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  000b8	41 b9 02 00 00
	00		 mov	 r9d, 2
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000c3	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  000ca	ba fd ff ff ff	 mov	 edx, -3
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	e8 00 00 00 00	 call	 z900_logical_to_main_l
  000d7	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
$LN8@s390_store:
  000dc	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e8	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  000ef	48 89 44 24 58	 mov	 QWORD PTR addr$[rsp], rax
$LN5@s390_store:
  000f4	33 c0		 xor	 eax, eax
  000f6	85 c0		 test	 eax, eax
  000f8	0f 85 14 ff ff
	ff		 jne	 $LN4@s390_store

; 900  : 
; 901  :     /* Set the main storage reference and change bits */
; 902  :     ARCH_DEP( or_storage_key )( addr, (STORKEY_REF | STORKEY_CHANGE) );

  000fe	b2 06		 mov	 dl, 6
  00100	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00105	e8 00 00 00 00	 call	 s390_or_storage_key

; 903  : 
; 904  :     /* Store the fullword into absolute storage */
; 905  :     store_fw( regs->mainstor + addr, value );

  0010a	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  0010e	e8 00 00 00 00	 call	 _byteswap_ulong
  00113	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00118	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  0011f	48 03 4c 24 58	 add	 rcx, QWORD PTR addr$[rsp]
  00124	8b d0		 mov	 edx, eax
  00126	e8 00 00 00 00	 call	 store_fw_noswap

; 906  : 
; 907  : } /* end function store_fullword_absolute */

  0012b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012f	c3		 ret	 0
s390_store_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_store_doubleword_absolute
_TEXT	SEGMENT
tv128 = 48
value$ = 80
addr$ = 88
regs$ = 96
s390_store_doubleword_absolute PROC			; COMDAT

; 863  : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_store:

; 864  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 865  :     if (addr > regs->mainlim - 8)
; 866  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 867  : #endif
; 868  : 
; 869  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 870  :        is treated as a no-operation if SIE_MODE not active */
; 871  :     SIE_TRANSLATE( &addr, ACCTYPE_WRITE, regs );

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00018	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0001e	d1 e8		 shr	 eax, 1
  00020	83 e0 01	 and	 eax, 1
  00023	85 c0		 test	 eax, eax
  00025	0f 84 ca 00 00
	00		 je	 $LN5@s390_store
  0002b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00030	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00036	c1 e8 02	 shr	 eax, 2
  00039	83 e0 01	 and	 eax, 1
  0003c	85 c0		 test	 eax, eax
  0003e	0f 85 b1 00 00
	00		 jne	 $LN5@s390_store
  00044	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00049	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00050	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  00054	75 44		 jne	 SHORT $LN7@s390_store
  00056	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0005b	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00062	48 03 44 24 58	 add	 rax, QWORD PTR addr$[rsp]
  00067	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00070	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00075	41 b9 02 00 00
	00		 mov	 r9d, 2
  0007b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00080	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00087	ba fd ff ff ff	 mov	 edx, -3
  0008c	8b c8		 mov	 ecx, eax
  0008e	e8 00 00 00 00	 call	 s390_logical_to_main_l
  00093	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
  00098	eb 43		 jmp	 SHORT $LN8@s390_store
$LN7@s390_store:
  0009a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0009f	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  000a6	48 03 44 24 58	 add	 rax, QWORD PTR addr$[rsp]
  000ab	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  000b4	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  000b9	41 b9 02 00 00
	00		 mov	 r9d, 2
  000bf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  000cb	ba fd ff ff ff	 mov	 edx, -3
  000d0	48 8b c8	 mov	 rcx, rax
  000d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  000d8	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
$LN8@s390_store:
  000dd	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e9	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  000f0	48 89 44 24 58	 mov	 QWORD PTR addr$[rsp], rax
$LN5@s390_store:
  000f5	33 c0		 xor	 eax, eax
  000f7	85 c0		 test	 eax, eax
  000f9	0f 85 14 ff ff
	ff		 jne	 $LN4@s390_store

; 872  : 
; 873  :     /* Set the main storage reference and change bits */
; 874  :     ARCH_DEP( or_storage_key )( addr, (STORKEY_REF | STORKEY_CHANGE) );

  000ff	b2 06		 mov	 dl, 6
  00101	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00106	e8 00 00 00 00	 call	 s390_or_storage_key

; 875  : 
; 876  :     /* Store the doubleword into absolute storage */
; 877  :     store_dw( regs->mainstor + addr, value );

  0010b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  00110	e8 00 00 00 00	 call	 _byteswap_uint64
  00115	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0011a	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00121	48 03 4c 24 58	 add	 rcx, QWORD PTR addr$[rsp]
  00126	48 8b d0	 mov	 rdx, rax
  00129	e8 00 00 00 00	 call	 store_dw_noswap

; 878  : 
; 879  : } /* end function store_doubleword_absolute */

  0012e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00132	c3		 ret	 0
s390_store_doubleword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_fetch_halfword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
s390_fetch_halfword_absolute PROC			; COMDAT

; 850  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 851  :     return fetch_hw( FETCH_MAIN_ABSOLUTE( addr, regs, 2 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 s390_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_hw_noswap
  00025	0f b7 c8	 movzx	 ecx, ax
  00028	e8 00 00 00 00	 call	 _byteswap_ushort

; 852  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
s390_fetch_halfword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_fetch_fullword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
s390_fetch_fullword_absolute PROC			; COMDAT

; 835  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 836  :     return fetch_fw( FETCH_MAIN_ABSOLUTE( addr, regs, 4 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 s390_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_fw_noswap
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 _byteswap_ulong

; 837  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
s390_fetch_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_fetch_doubleword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
s390_fetch_doubleword_absolute PROC			; COMDAT

; 815  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 816  :     // The change below affects 32 bit hosts that use something like
; 817  :     // cmpxchg8b to fetch the doubleword concurrently.
; 818  :     // This routine is mainly called by DAT in 64 bit guest mode
; 819  :     // to access DAT-related values.  In most `well-behaved' OS's,
; 820  :     // other CPUs should not be interfering with these values
; 821  : 
; 822  :     return fetch_dw( FETCH_MAIN_ABSOLUTE( addr, regs, 8 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 s390_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_dw_noswap
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 _byteswap_uint64

; 823  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
s390_fetch_doubleword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_FPC_check
_TEXT	SEGMENT
regs$ = 48
fpc$ = 56
s390_FPC_check PROC					; COMDAT

; 788  : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 789  :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0000d	b8 01 00 00 00	 mov	 eax, 1
  00012	48 6b c0 04	 imul	 rax, rax, 4
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00023	83 e0 04	 and	 eax, 4
  00026	85 c0		 test	 eax, eax
  00028	74 4e		 je	 SHORT $LN2@s390_FPC_c

; 790  :     {
; 791  :         if (0
; 792  :             || (fpc & FPC_RESV_FPX)
; 793  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV4
; 794  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV5
; 795  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV6

  0002a	33 c0		 xor	 eax, eax
  0002c	85 c0		 test	 eax, eax
  0002e	75 31		 jne	 SHORT $LN5@s390_FPC_c
  00030	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00034	25 88 00 03 03	 and	 eax, 50528392		; 03030088H
  00039	85 c0		 test	 eax, eax
  0003b	75 24		 jne	 SHORT $LN5@s390_FPC_c
  0003d	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00041	83 e0 07	 and	 eax, 7
  00044	83 f8 04	 cmp	 eax, 4
  00047	74 18		 je	 SHORT $LN5@s390_FPC_c
  00049	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  0004d	83 e0 07	 and	 eax, 7
  00050	83 f8 05	 cmp	 eax, 5
  00053	74 0c		 je	 SHORT $LN5@s390_FPC_c
  00055	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00059	83 e0 07	 and	 eax, 7
  0005c	83 f8 06	 cmp	 eax, 6
  0005f	75 15		 jne	 SHORT $LN4@s390_FPC_c
$LN5@s390_FPC_c:

; 796  :         )
; 797  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00061	ba 06 00 00 00	 mov	 edx, 6
  00066	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00070	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN4@s390_FPC_c:

; 798  :     }

  00076	eb 22		 jmp	 SHORT $LN3@s390_FPC_c
$LN2@s390_FPC_c:

; 799  :     else
; 800  :     {
; 801  :         if (fpc & FPC_RESERVED)

  00078	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  0007c	25 8c 00 07 07	 and	 eax, 117899404		; 0707008cH
  00081	85 c0		 test	 eax, eax
  00083	74 15		 je	 SHORT $LN6@s390_FPC_c

; 802  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00085	ba 06 00 00 00	 mov	 edx, 6
  0008a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00094	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s390_FPC_c:
$LN3@s390_FPC_c:

; 803  :     }
; 804  : }

  0009a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009e	c3		 ret	 0
s390_FPC_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_per3_zero_xcheck2
_TEXT	SEGMENT
regs$ = 8
x2$ = 16
b2$ = 24
s390_per3_zero_xcheck2 PROC				; COMDAT

; 765  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_per3_:

; 766  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 767  :     if (0
; 768  :         || (!b2 && x2 && GR_A( x2, regs ) == 0)
; 769  :         || (!x2 && b2 && GR_A( b2, regs ) == 0)
; 770  :         || ( b2 && x2 && (0
; 771  :                           || GR_A( b2, regs ) == 0
; 772  :                           || GR_A( b2, regs ) + GR_A( x2, regs ) == 0
; 773  :                          )
; 774  :            )
; 775  :     )
; 776  :         ARCH_DEP( per3_zero )( regs );
; 777  : #else
; 778  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@s390_per3_
$LN7@s390_per3_:

; 779  :     UNREFERENCED( x2 );

  00014	33 c0		 xor	 eax, eax
  00016	85 c0		 test	 eax, eax
  00018	75 fa		 jne	 SHORT $LN7@s390_per3_
$LN10@s390_per3_:

; 780  :     UNREFERENCED( b2 );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN10@s390_per3_

; 781  : #endif
; 782  : }

  00020	c3		 ret	 0
s390_per3_zero_xcheck2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_per3_zero_xcheck
_TEXT	SEGMENT
regs$ = 8
b1$ = 16
s390_per3_zero_xcheck PROC				; COMDAT

; 754  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_per3_:

; 755  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 756  :     if (b1 && GR_A( b1, regs ) == 0)
; 757  :         ARCH_DEP( per3_zero )( regs );
; 758  : #else
; 759  :     UNREFERENCED( regs );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@s390_per3_
$LN7@s390_per3_:

; 760  :     UNREFERENCED( b1 );

  0000f	33 c0		 xor	 eax, eax
  00011	85 c0		 test	 eax, eax
  00013	75 fa		 jne	 SHORT $LN7@s390_per3_

; 761  : #endif
; 762  : }

  00015	c3		 ret	 0
s390_per3_zero_xcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_per3_zero_l24check2
_TEXT	SEGMENT
regs$ = 8
r1$ = 16
l1$ = 24
r2$ = 32
l2$ = 40
s390_per3_zero_l24check2 PROC				; COMDAT

; 723  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_per3_:

; 724  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 725  :     if (0
; 726  :         || (1
; 727  :             && regs->GR_LA24( l1 ) != 0
; 728  :             && GR_A( r1, regs )    == 0
; 729  :            )
; 730  :         || (1
; 731  :             && regs->GR_LA24( l2 ) != 0
; 732  :             && GR_A( r2, regs )    == 0
; 733  :            )
; 734  :     )
; 735  :         ARCH_DEP( per3_zero )( regs );
; 736  : #else
; 737  :     UNREFERENCED( regs );

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@s390_per3_
$LN7@s390_per3_:

; 738  :     UNREFERENCED( r1 );

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	75 fa		 jne	 SHORT $LN7@s390_per3_
$LN10@s390_per3_:

; 739  :     UNREFERENCED( l1 );

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN10@s390_per3_
$LN13@s390_per3_:

; 740  :     UNREFERENCED( r2 );

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN13@s390_per3_
$LN16@s390_per3_:

; 741  :     UNREFERENCED( l2 );

  0002b	33 c0		 xor	 eax, eax
  0002d	85 c0		 test	 eax, eax
  0002f	75 fa		 jne	 SHORT $LN16@s390_per3_

; 742  : #endif
; 743  : }

  00031	c3		 ret	 0
s390_per3_zero_l24check2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_per3_zero_l24check
_TEXT	SEGMENT
regs$ = 8
r1$ = 16
l1$ = 24
s390_per3_zero_l24check PROC				; COMDAT

; 708  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_per3_:

; 709  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 710  :     if (1
; 711  :         && regs->GR_LA24( l1 ) != 0
; 712  :         && GR_A( r1, regs )    == 0
; 713  :     )
; 714  :         ARCH_DEP( per3_zero )( regs );
; 715  : #else
; 716  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@s390_per3_
$LN7@s390_per3_:

; 717  :     UNREFERENCED( r1 );

  00014	33 c0		 xor	 eax, eax
  00016	85 c0		 test	 eax, eax
  00018	75 fa		 jne	 SHORT $LN7@s390_per3_
$LN10@s390_per3_:

; 718  :     UNREFERENCED( l1 );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN10@s390_per3_

; 719  : #endif
; 720  : }

  00020	c3		 ret	 0
s390_per3_zero_l24check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_per3_zero_lcheck2
_TEXT	SEGMENT
regs$ = 8
r1$ = 16
l1$ = 24
r2$ = 32
l2$ = 40
s390_per3_zero_lcheck2 PROC				; COMDAT

; 677  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_per3_:

; 678  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 679  :     if (0
; 680  :         || (1
; 681  :             && GR_A( l1, regs ) != 0
; 682  :             && GR_A( r1, regs ) == 0
; 683  :            )
; 684  :         || (1
; 685  :             && GR_A( l2, regs ) != 0
; 686  :             && GR_A( r2, regs ) == 0
; 687  :            )
; 688  :     )
; 689  :         ARCH_DEP( per3_zero )( regs );
; 690  : #else
; 691  :     UNREFERENCED( regs );

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@s390_per3_
$LN7@s390_per3_:

; 692  :     UNREFERENCED( r1 );

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	75 fa		 jne	 SHORT $LN7@s390_per3_
$LN10@s390_per3_:

; 693  :     UNREFERENCED( l1 );

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN10@s390_per3_
$LN13@s390_per3_:

; 694  :     UNREFERENCED( r2 );

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN13@s390_per3_
$LN16@s390_per3_:

; 695  :     UNREFERENCED( l2 );

  0002b	33 c0		 xor	 eax, eax
  0002d	85 c0		 test	 eax, eax
  0002f	75 fa		 jne	 SHORT $LN16@s390_per3_

; 696  : #endif
; 697  : }

  00031	c3		 ret	 0
s390_per3_zero_lcheck2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_per3_zero_lcheck
_TEXT	SEGMENT
regs$ = 8
r1$ = 16
l1$ = 24
s390_per3_zero_lcheck PROC				; COMDAT

; 662  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_per3_:

; 663  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 664  :     if (1
; 665  :         && GR_A( l1, regs ) != 0
; 666  :         && GR_A( r1, regs ) == 0
; 667  :     )
; 668  :         ARCH_DEP( per3_zero )( regs );
; 669  : #else
; 670  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@s390_per3_
$LN7@s390_per3_:

; 671  :     UNREFERENCED( r1 );

  00014	33 c0		 xor	 eax, eax
  00016	85 c0		 test	 eax, eax
  00018	75 fa		 jne	 SHORT $LN7@s390_per3_
$LN10@s390_per3_:

; 672  :     UNREFERENCED( l1 );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN10@s390_per3_

; 673  : #endif
; 674  : }

  00020	c3		 ret	 0
s390_per3_zero_lcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_per3_zero_check2
_TEXT	SEGMENT
regs$ = 8
r1$ = 16
r2$ = 24
s390_per3_zero_check2 PROC				; COMDAT

; 640  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_per3_:

; 641  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 642  :     if (0
; 643  :         || GR_A( r1, regs ) == 0
; 644  :         || GR_A( r2, regs ) == 0
; 645  :     )
; 646  :         ARCH_DEP( per3_zero )( regs );
; 647  : #else
; 648  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@s390_per3_
$LN7@s390_per3_:

; 649  :     UNREFERENCED( r1 );

  00014	33 c0		 xor	 eax, eax
  00016	85 c0		 test	 eax, eax
  00018	75 fa		 jne	 SHORT $LN7@s390_per3_
$LN10@s390_per3_:

; 650  :     UNREFERENCED( r2 );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN10@s390_per3_

; 651  : #endif
; 652  : }

  00020	c3		 ret	 0
s390_per3_zero_check2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_per3_zero_check
_TEXT	SEGMENT
regs$ = 8
r1$ = 16
s390_per3_zero_check PROC				; COMDAT

; 629  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_per3_:

; 630  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 631  :     if (GR_A( r1, regs ) == 0)
; 632  :         ARCH_DEP( per3_zero )( regs );
; 633  : #else
; 634  :     UNREFERENCED( regs );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@s390_per3_
$LN7@s390_per3_:

; 635  :     UNREFERENCED( r1 );

  0000f	33 c0		 xor	 eax, eax
  00011	85 c0		 test	 eax, eax
  00013	75 fa		 jne	 SHORT $LN7@s390_per3_

; 636  : #endif
; 637  : }

  00015	c3		 ret	 0
s390_per3_zero_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_per3_zero
_TEXT	SEGMENT
regs$ = 8
s390_per3_zero PROC					; COMDAT

; 602  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_per3_:

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )
; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;
; 610  :         ON_IC_PER_ZEROADDR( regs );
; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))
; 612  :             RETURN_INTCHECK( regs );
; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );

  00005	33 c0		 xor	 eax, eax
  00007	85 c0		 test	 eax, eax
  00009	75 fa		 jne	 SHORT $LN4@s390_per3_

; 616  : #endif
; 617  : }

  0000b	c3		 ret	 0
s390_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
s390_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_is_pe:

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@s390_is_pe
$LN7@s390_is_pe:

; 569  :     UNREFERENCED( cr9_per_event );

  0000f	33 c0		 xor	 eax, eax
  00011	85 c0		 test	 eax, eax
  00013	75 fa		 jne	 SHORT $LN7@s390_is_pe

; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))
; 573  :         return false;
; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)
; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)
; 580  :             return true;        /* Yes, then suppress it! */
; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0
; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */
; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  00015	32 c0		 xor	 al, al

; 596  : }

  00017	c3		 ret	 0
s390_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_per1_gra
_TEXT	SEGMENT
regs$ = 8
s390_per1_gra PROC					; COMDAT

; 546  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s390_per1_:

; 547  : #if !defined( FEATURE_PER1 )
; 548  :     UNREFERENCED( regs );

  00005	33 c0		 xor	 eax, eax
  00007	85 c0		 test	 eax, eax
  00009	75 fa		 jne	 SHORT $LN4@s390_per1_

; 549  : #else
; 550  :     OBTAIN_INTLOCK( regs );
; 551  :     {
; 552  :         regs->peradr = regs->periaddr;
; 553  :         ON_IC_PER_GRA( regs );
; 554  :     }
; 555  :     RELEASE_INTLOCK( regs );
; 556  : 
; 557  :     if (OPEN_IC_PER_GRA( regs ))
; 558  :         RETURN_INTCHECK( regs );
; 559  : #endif
; 560  : }

  0000b	c3		 ret	 0
s390_per1_gra ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_fetch_main_absolute
_TEXT	SEGMENT
tv128 = 48
addr$ = 80
regs$ = 88
s390_fetch_main_absolute PROC				; COMDAT

; 524  : {

$LN9:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_fetch:

; 525  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 526  :     if (addr > (regs->mainlim - len))
; 527  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 528  : #endif
; 529  : 
; 530  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 531  :        is treated as a no-operation if SIE_MODE not active */
; 532  :     SIE_TRANSLATE( &addr, ACCTYPE_READ, regs );

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00019	d1 e8		 shr	 eax, 1
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	0f 84 ca 00 00
	00		 je	 $LN5@s390_fetch
  00026	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00031	c1 e8 02	 shr	 eax, 2
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	0f 85 b1 00 00
	00		 jne	 $LN5@s390_fetch
  0003f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00044	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0004b	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  0004f	75 44		 jne	 SHORT $LN7@s390_fetch
  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00056	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  0005d	48 03 44 24 50	 add	 rax, QWORD PTR addr$[rsp]
  00062	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  0006b	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00070	41 b9 04 00 00
	00		 mov	 r9d, 4
  00076	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00082	ba fd ff ff ff	 mov	 edx, -3
  00087	8b c8		 mov	 ecx, eax
  00089	e8 00 00 00 00	 call	 s390_logical_to_main_l
  0008e	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
  00093	eb 43		 jmp	 SHORT $LN8@s390_fetch
$LN7@s390_fetch:
  00095	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0009a	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  000a1	48 03 44 24 50	 add	 rax, QWORD PTR addr$[rsp]
  000a6	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  000af	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  000b4	41 b9 04 00 00
	00		 mov	 r9d, 4
  000ba	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000bf	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  000c6	ba fd ff ff ff	 mov	 edx, -3
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	e8 00 00 00 00	 call	 z900_logical_to_main_l
  000d3	48 89 44 24 30	 mov	 QWORD PTR tv128[rsp], rax
$LN8@s390_fetch:
  000d8	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000e4	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  000eb	48 89 44 24 50	 mov	 QWORD PTR addr$[rsp], rax
$LN5@s390_fetch:
  000f0	33 c0		 xor	 eax, eax
  000f2	85 c0		 test	 eax, eax
  000f4	0f 85 14 ff ff
	ff		 jne	 $LN4@s390_fetch

; 533  : 
; 534  :     /* Set the main storage reference bit */
; 535  :     ARCH_DEP( or_storage_key )( addr, STORKEY_REF );

  000fa	b2 04		 mov	 dl, 4
  000fc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00101	e8 00 00 00 00	 call	 s390_or_storage_key

; 536  : 
; 537  :     /* Return absolute storage mainstor address */
; 538  :     return (regs->mainstor + addr);

  00106	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0010b	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00112	48 03 44 24 50	 add	 rax, QWORD PTR addr$[rsp]

; 539  : 
; 540  : } /* end function fetch_main_absolute */

  00117	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011b	c3		 ret	 0
s390_fetch_main_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_is_store_protected
_TEXT	SEGMENT
addr$ = 48
skey$ = 56
akey$ = 64
regs$ = 72
s390_is_store_protected PROC				; COMDAT

; 469  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 470  :     /* [3.4.4] Low-address protection prohibits stores into certain
; 471  :        locations in the prefixed storage area of non-private address
; 472  :        address spaces, if the low-address control bit in CR0 is set,
; 473  :        regardless of the access key and storage key */
; 474  :     if (ARCH_DEP( is_low_address_protected )( addr, regs ))

  00016	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  0001b	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  0001f	e8 00 00 00 00	 call	 s390_is_low_address_protected
  00024	0f b6 c0	 movzx	 eax, al
  00027	85 c0		 test	 eax, eax
  00029	74 07		 je	 SHORT $LN2@s390_is_st

; 475  :         return true;

  0002b	b0 01		 mov	 al, 1
  0002d	e9 af 00 00 00	 jmp	 $LN1@s390_is_st
$LN2@s390_is_st:

; 476  : 
; 477  :     /* Access-list controlled protection prohibits all stores into
; 478  :        the address space, and page protection prohibits all stores
; 479  :        into the page, regardless of the access key and storage key */
; 480  :     if (regs->dat.protect)

  00032	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00037	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0003d	d1 e8		 shr	 eax, 1
  0003f	83 e0 03	 and	 eax, 3
  00042	85 c0		 test	 eax, eax
  00044	74 07		 je	 SHORT $LN3@s390_is_st

; 481  :         return true;

  00046	b0 01		 mov	 al, 1
  00048	e9 94 00 00 00	 jmp	 $LN1@s390_is_st
$LN3@s390_is_st:

; 482  : 
; 483  : #if defined( _FEATURE_SIE )
; 484  :     if (SIE_MODE( regs ) && HOSTREGS->dat.protect)

  0004d	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00052	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00058	d1 e8		 shr	 eax, 1
  0005a	83 e0 01	 and	 eax, 1
  0005d	85 c0		 test	 eax, eax
  0005f	74 1f		 je	 SHORT $LN4@s390_is_st
  00061	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00066	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0006d	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  00073	d1 e8		 shr	 eax, 1
  00075	83 e0 03	 and	 eax, 3
  00078	85 c0		 test	 eax, eax
  0007a	74 04		 je	 SHORT $LN4@s390_is_st

; 485  :         return true;

  0007c	b0 01		 mov	 al, 1
  0007e	eb 61		 jmp	 SHORT $LN1@s390_is_st
$LN4@s390_is_st:

; 486  : #endif
; 487  : 
; 488  :     /* [3.4.1] Store is allowed if access key is zero, regardless
; 489  :        of the storage key */
; 490  :     if (akey == 0)

  00080	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey$[rsp]
  00085	85 c0		 test	 eax, eax
  00087	75 04		 jne	 SHORT $LN5@s390_is_st

; 491  :         return false;

  00089	32 c0		 xor	 al, al
  0008b	eb 54		 jmp	 SHORT $LN1@s390_is_st
$LN5@s390_is_st:

; 492  : 
; 493  : #if defined( FEATURE_STORAGE_PROTECTION_OVERRIDE )
; 494  :     /* [3.4.1.1] Storage protection override allows access to
; 495  :        locations with storage key 9, regardless of the access key,
; 496  :        provided that CR0 bit 7 is set */
; 497  :     if (1
; 498  :         && (skey & STORKEY_KEY) == 0x90
; 499  :         && (regs->CR(0) & CR0_STORE_OVRD)

  0008d	33 c0		 xor	 eax, eax
  0008f	83 f8 01	 cmp	 eax, 1
  00092	74 33		 je	 SHORT $LN6@s390_is_st
  00094	0f b6 44 24 38	 movzx	 eax, BYTE PTR skey$[rsp]
  00099	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0009e	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  000a3	75 22		 jne	 SHORT $LN6@s390_is_st
  000a5	b8 08 00 00 00	 mov	 eax, 8
  000aa	48 6b c0 01	 imul	 rax, rax, 1
  000ae	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000ba	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000bf	85 c0		 test	 eax, eax
  000c1	74 04		 je	 SHORT $LN6@s390_is_st

; 500  :     )
; 501  :         return false;

  000c3	32 c0		 xor	 al, al
  000c5	eb 1a		 jmp	 SHORT $LN1@s390_is_st
$LN6@s390_is_st:

; 502  : #endif
; 503  : 
; 504  :     /* [3.4.1] Store protection prohibits stores
; 505  :        if the access key does not match the storage key */
; 506  :     if (akey != (skey & STORKEY_KEY))

  000c7	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey$[rsp]
  000cc	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR skey$[rsp]
  000d1	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  000d7	3b c1		 cmp	 eax, ecx
  000d9	74 04		 je	 SHORT $LN7@s390_is_st

; 507  :         return true;

  000db	b0 01		 mov	 al, 1
  000dd	eb 02		 jmp	 SHORT $LN1@s390_is_st
$LN7@s390_is_st:

; 508  : 
; 509  :     return false;      // (location is *NOT* store protected)

  000df	32 c0		 xor	 al, al
$LN1@s390_is_st:

; 510  : 
; 511  : } /* end function is_store_protected */

  000e1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000e5	c3		 ret	 0
s390_is_store_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_is_low_address_protected
_TEXT	SEGMENT
addr$ = 8
regs$ = 16
s390_is_low_address_protected PROC			; COMDAT

; 419  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 420  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 421  :     /* For z/Arch, low-address protection applies to locations
; 422  :        0-511 (0000-01FF) and also 4096-4607 (1000-11FF) */
; 423  :     if (addr & 0xFFFFFFFFFFFFEE00ULL)
; 424  : #else
; 425  :     /* For S/370 and ESA/390, low-address protection applies
; 426  :        only to locations 0-511 */
; 427  :     if (addr > 511)

  00009	81 7c 24 08 ff
	01 00 00	 cmp	 DWORD PTR addr$[rsp], 511 ; 000001ffH
  00011	76 04		 jbe	 SHORT $LN2@s390_is_lo

; 428  : #endif
; 429  :         return false;

  00013	32 c0		 xor	 al, al
  00015	eb 50		 jmp	 SHORT $LN1@s390_is_lo
$LN2@s390_is_lo:

; 430  : 
; 431  :     /* Low-address protection applies only if the low-address
; 432  :        protection control bit in control register 0 is set */
; 433  :     if (!(regs->CR(0) & CR0_LOW_PROT))

  00017	b8 08 00 00 00	 mov	 eax, 8
  0001c	48 6b c0 01	 imul	 rax, rax, 1
  00020	48 8b 4c 24 10	 mov	 rcx, QWORD PTR regs$[rsp]
  00025	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0002c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00031	85 c0		 test	 eax, eax
  00033	75 04		 jne	 SHORT $LN3@s390_is_lo

; 434  :         return false;

  00035	32 c0		 xor	 al, al
  00037	eb 2e		 jmp	 SHORT $LN1@s390_is_lo
$LN3@s390_is_lo:

; 435  : 
; 436  : #if defined( _FEATURE_SIE )
; 437  :     /* Host low-address protection is not applied to guest
; 438  :        references to guest storage */
; 439  :     if (regs->sie_active)

  00039	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  0003e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00044	83 e0 01	 and	 eax, 1
  00047	85 c0		 test	 eax, eax
  00049	74 04		 je	 SHORT $LN4@s390_is_lo

; 440  :         return false;

  0004b	32 c0		 xor	 al, al
  0004d	eb 18		 jmp	 SHORT $LN1@s390_is_lo
$LN4@s390_is_lo:

; 441  : #endif
; 442  : 
; 443  :     /* Low-addr protection doesn't apply to private address spaces */
; 444  :     if (regs->dat.pvtaddr)

  0004f	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  00054	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0005a	83 e0 01	 and	 eax, 1
  0005d	85 c0		 test	 eax, eax
  0005f	74 04		 je	 SHORT $LN5@s390_is_lo

; 445  :         return false;

  00061	32 c0		 xor	 al, al
  00063	eb 02		 jmp	 SHORT $LN1@s390_is_lo
$LN5@s390_is_lo:

; 446  : 
; 447  :     return true;      // (location *IS* low-address protected)

  00065	b0 01		 mov	 al, 1
$LN1@s390_is_lo:

; 448  : 
; 449  : } /* end function is_low_address_protected */

  00067	c3		 ret	 0
s390_is_low_address_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s390_is_fetch_protected
_TEXT	SEGMENT
tv87 = 0
addr$ = 32
skey$ = 40
akey$ = 48
regs$ = 56
s390_is_fetch_protected PROC				; COMDAT

; 365  : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 18	 sub	 rsp, 24
$LN4@s390_is_fe:

; 366  :     UNREFERENCED_370( addr );

  00016	33 c0		 xor	 eax, eax
  00018	85 c0		 test	 eax, eax
  0001a	75 fa		 jne	 SHORT $LN4@s390_is_fe
$LN7@s390_is_fe:

; 367  :     UNREFERENCED_370( regs );

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN7@s390_is_fe

; 368  : 
; 369  :     /* [3.4.1] Fetch is allowed if access key is zero, regardless
; 370  :        of the storage key and fetch protection bit */
; 371  :     /* [3.4.1] Fetch protection prohibits fetch if storage key fetch
; 372  :        protect bit is on and access key does not match storage key */
; 373  :     if (likely(0

  00022	33 c0		 xor	 eax, eax
  00024	85 c0		 test	 eax, eax
  00026	75 32		 jne	 SHORT $LN12@s390_is_fe
  00028	0f b6 44 24 30	 movzx	 eax, BYTE PTR akey$[rsp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 29		 je	 SHORT $LN12@s390_is_fe
  00031	0f b6 44 24 30	 movzx	 eax, BYTE PTR akey$[rsp]
  00036	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR skey$[rsp]
  0003b	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00041	3b c1		 cmp	 eax, ecx
  00043	74 15		 je	 SHORT $LN12@s390_is_fe
  00045	0f b6 44 24 28	 movzx	 eax, BYTE PTR skey$[rsp]
  0004a	83 e0 08	 and	 eax, 8
  0004d	85 c0		 test	 eax, eax
  0004f	74 09		 je	 SHORT $LN12@s390_is_fe
  00051	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv87[rsp], 0
  00058	eb 07		 jmp	 SHORT $LN15@s390_is_fe
$LN12@s390_is_fe:
  0005a	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv87[rsp], 1
$LN15@s390_is_fe:
  00061	83 3c 24 00	 cmp	 DWORD PTR tv87[rsp], 0
  00065	74 07		 je	 SHORT $LN8@s390_is_fe

; 374  :                || akey == 0
; 375  :                || akey == (skey & STORKEY_KEY)
; 376  :                || !(skey & STORKEY_FETCH)
; 377  :               )
; 378  :     )
; 379  :         return false;

  00067	32 c0		 xor	 al, al
  00069	e9 81 00 00 00	 jmp	 $LN1@s390_is_fe
$LN8@s390_is_fe:

; 380  : 
; 381  : #if defined( FEATURE_FETCH_PROTECTION_OVERRIDE )
; 382  :     /* [3.4.1.2] Fetch protection override allows fetch from first
; 383  :        2K of non-private address spaces if CR0 bit 6 is set */
; 384  :     if (1
; 385  :         && addr < 2048
; 386  :         && (regs->CR(0) & CR0_FETCH_OVRD)
; 387  :         && regs->dat.pvtaddr == 0

  0006e	33 c0		 xor	 eax, eax
  00070	83 f8 01	 cmp	 eax, 1
  00073	74 3e		 je	 SHORT $LN9@s390_is_fe
  00075	81 7c 24 20 00
	08 00 00	 cmp	 DWORD PTR addr$[rsp], 2048 ; 00000800H
  0007d	73 34		 jae	 SHORT $LN9@s390_is_fe
  0007f	b8 08 00 00 00	 mov	 eax, 8
  00084	48 6b c0 01	 imul	 rax, rax, 1
  00088	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  0008d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00094	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00099	85 c0		 test	 eax, eax
  0009b	74 16		 je	 SHORT $LN9@s390_is_fe
  0009d	48 8b 44 24 38	 mov	 rax, QWORD PTR regs$[rsp]
  000a2	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  000a8	83 e0 01	 and	 eax, 1
  000ab	85 c0		 test	 eax, eax
  000ad	75 04		 jne	 SHORT $LN9@s390_is_fe

; 388  :     )
; 389  :         return false;

  000af	32 c0		 xor	 al, al
  000b1	eb 3c		 jmp	 SHORT $LN1@s390_is_fe
$LN9@s390_is_fe:

; 390  : #endif
; 391  : 
; 392  : #if defined( FEATURE_STORAGE_PROTECTION_OVERRIDE )
; 393  :     /* [3.4.1.1] Storage protection override allows access to
; 394  :        locations with storage key 9, regardless of the access key,
; 395  :        provided that CR0 bit 7 is set */
; 396  :     if (1
; 397  :         && (skey & STORKEY_KEY) == 0x90
; 398  :         && (regs->CR(0) & CR0_STORE_OVRD)

  000b3	33 c0		 xor	 eax, eax
  000b5	83 f8 01	 cmp	 eax, 1
  000b8	74 33		 je	 SHORT $LN10@s390_is_fe
  000ba	0f b6 44 24 28	 movzx	 eax, BYTE PTR skey$[rsp]
  000bf	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000c4	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  000c9	75 22		 jne	 SHORT $LN10@s390_is_fe
  000cb	b8 08 00 00 00	 mov	 eax, 8
  000d0	48 6b c0 01	 imul	 rax, rax, 1
  000d4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR regs$[rsp]
  000d9	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  000e0	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  000e5	85 c0		 test	 eax, eax
  000e7	74 04		 je	 SHORT $LN10@s390_is_fe

; 399  :     )
; 400  :         return false;

  000e9	32 c0		 xor	 al, al
  000eb	eb 02		 jmp	 SHORT $LN1@s390_is_fe
$LN10@s390_is_fe:

; 401  : #endif
; 402  : 
; 403  :     return true;    // (location *IS* fetch protected)

  000ed	b0 01		 mov	 al, 1
$LN1@s390_is_fe:

; 404  : 
; 405  : } /* end function is_fetch_protected */

  000ef	48 83 c4 18	 add	 rsp, 24
  000f3	c3		 ret	 0
s390_is_fetch_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_store_fullword_absolute
_TEXT	SEGMENT
value$ = 64
addr$ = 72
regs$ = 80
s370_store_fullword_absolute PROC			; COMDAT

; 891  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370_store:

; 892  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 893  :     if (addr > regs->mainlim - 4)
; 894  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 895  : #endif
; 896  : 
; 897  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 898  :        is treated as a no-operation if SIE_MODE not active */
; 899  :     SIE_TRANSLATE( &addr, ACCTYPE_WRITE, regs );

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00017	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0001d	d1 e8		 shr	 eax, 1
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 6a		 je	 SHORT $LN5@s370_store
  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00031	c1 e8 02	 shr	 eax, 2
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	75 55		 jne	 SHORT $LN5@s370_store
  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00040	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00047	48 03 44 24 48	 add	 rax, QWORD PTR addr$[rsp]
  0004c	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00055	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0005a	41 b9 02 00 00
	00		 mov	 r9d, 2
  00060	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00065	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  0006c	ba fd ff ff ff	 mov	 edx, -3
  00071	8b c8		 mov	 ecx, eax
  00073	e8 00 00 00 00	 call	 s390_logical_to_main_l
  00078	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00084	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  0008b	48 89 44 24 48	 mov	 QWORD PTR addr$[rsp], rax
$LN5@s370_store:
  00090	33 c0		 xor	 eax, eax
  00092	85 c0		 test	 eax, eax
  00094	0f 85 78 ff ff
	ff		 jne	 $LN4@s370_store

; 900  : 
; 901  :     /* Set the main storage reference and change bits */
; 902  :     ARCH_DEP( or_storage_key )( addr, (STORKEY_REF | STORKEY_CHANGE) );

  0009a	b2 06		 mov	 dl, 6
  0009c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR addr$[rsp]
  000a1	e8 00 00 00 00	 call	 s370_or_storage_key

; 903  : 
; 904  :     /* Store the fullword into absolute storage */
; 905  :     store_fw( regs->mainstor + addr, value );

  000a6	8b 4c 24 40	 mov	 ecx, DWORD PTR value$[rsp]
  000aa	e8 00 00 00 00	 call	 _byteswap_ulong
  000af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000b4	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  000bb	48 03 4c 24 48	 add	 rcx, QWORD PTR addr$[rsp]
  000c0	8b d0		 mov	 edx, eax
  000c2	e8 00 00 00 00	 call	 store_fw_noswap

; 906  : 
; 907  : } /* end function store_fullword_absolute */

  000c7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cb	c3		 ret	 0
s370_store_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_store_doubleword_absolute
_TEXT	SEGMENT
value$ = 64
addr$ = 72
regs$ = 80
s370_store_doubleword_absolute PROC			; COMDAT

; 863  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370_store:

; 864  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 865  :     if (addr > regs->mainlim - 8)
; 866  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 867  : #endif
; 868  : 
; 869  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 870  :        is treated as a no-operation if SIE_MODE not active */
; 871  :     SIE_TRANSLATE( &addr, ACCTYPE_WRITE, regs );

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00018	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0001e	d1 e8		 shr	 eax, 1
  00020	83 e0 01	 and	 eax, 1
  00023	85 c0		 test	 eax, eax
  00025	74 6a		 je	 SHORT $LN5@s370_store
  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0002c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00032	c1 e8 02	 shr	 eax, 2
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	75 55		 jne	 SHORT $LN5@s370_store
  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00041	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00048	48 03 44 24 48	 add	 rax, QWORD PTR addr$[rsp]
  0004d	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00056	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0005b	41 b9 02 00 00
	00		 mov	 r9d, 2
  00061	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  0006d	ba fd ff ff ff	 mov	 edx, -3
  00072	8b c8		 mov	 ecx, eax
  00074	e8 00 00 00 00	 call	 s390_logical_to_main_l
  00079	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00085	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  0008c	48 89 44 24 48	 mov	 QWORD PTR addr$[rsp], rax
$LN5@s370_store:
  00091	33 c0		 xor	 eax, eax
  00093	85 c0		 test	 eax, eax
  00095	0f 85 78 ff ff
	ff		 jne	 $LN4@s370_store

; 872  : 
; 873  :     /* Set the main storage reference and change bits */
; 874  :     ARCH_DEP( or_storage_key )( addr, (STORKEY_REF | STORKEY_CHANGE) );

  0009b	b2 06		 mov	 dl, 6
  0009d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR addr$[rsp]
  000a2	e8 00 00 00 00	 call	 s370_or_storage_key

; 875  : 
; 876  :     /* Store the doubleword into absolute storage */
; 877  :     store_dw( regs->mainstor + addr, value );

  000a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR value$[rsp]
  000ac	e8 00 00 00 00	 call	 _byteswap_uint64
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000b6	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  000bd	48 03 4c 24 48	 add	 rcx, QWORD PTR addr$[rsp]
  000c2	48 8b d0	 mov	 rdx, rax
  000c5	e8 00 00 00 00	 call	 store_dw_noswap

; 878  : 
; 879  : } /* end function store_doubleword_absolute */

  000ca	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ce	c3		 ret	 0
s370_store_doubleword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_fetch_halfword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
s370_fetch_halfword_absolute PROC			; COMDAT

; 850  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 851  :     return fetch_hw( FETCH_MAIN_ABSOLUTE( addr, regs, 2 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 s370_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_hw_noswap
  00025	0f b7 c8	 movzx	 ecx, ax
  00028	e8 00 00 00 00	 call	 _byteswap_ushort

; 852  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
s370_fetch_halfword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_fetch_fullword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
s370_fetch_fullword_absolute PROC			; COMDAT

; 835  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 836  :     return fetch_fw( FETCH_MAIN_ABSOLUTE( addr, regs, 4 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 s370_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_fw_noswap
  00025	8b c8		 mov	 ecx, eax
  00027	e8 00 00 00 00	 call	 _byteswap_ulong

; 837  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
s370_fetch_fullword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_fetch_doubleword_absolute
_TEXT	SEGMENT
addr$ = 48
regs$ = 56
s370_fetch_doubleword_absolute PROC			; COMDAT

; 815  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 816  :     // The change below affects 32 bit hosts that use something like
; 817  :     // cmpxchg8b to fetch the doubleword concurrently.
; 818  :     // This routine is mainly called by DAT in 64 bit guest mode
; 819  :     // to access DAT-related values.  In most `well-behaved' OS's,
; 820  :     // other CPUs should not be interfering with these values
; 821  : 
; 822  :     return fetch_dw( FETCH_MAIN_ABSOLUTE( addr, regs, 8 ));

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR regs$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	e8 00 00 00 00	 call	 s370_fetch_main_absolute
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 fetch_dw_noswap
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 _byteswap_uint64

; 823  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
s370_fetch_doubleword_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_FPC_check
_TEXT	SEGMENT
regs$ = 48
fpc$ = 56
s370_FPC_check PROC					; COMDAT

; 788  : {

$LN8:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 789  :     if (FACILITY_ENABLED( 037_FP_EXTENSION, regs ))

  0000d	b8 01 00 00 00	 mov	 eax, 1
  00012	48 6b c0 04	 imul	 rax, rax, 4
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0001b	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00023	83 e0 04	 and	 eax, 4
  00026	85 c0		 test	 eax, eax
  00028	74 4e		 je	 SHORT $LN2@s370_FPC_c

; 790  :     {
; 791  :         if (0
; 792  :             || (fpc & FPC_RESV_FPX)
; 793  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV4
; 794  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV5
; 795  :             || (fpc & FPC_BRM_3BIT) == BRM_RESV6

  0002a	33 c0		 xor	 eax, eax
  0002c	85 c0		 test	 eax, eax
  0002e	75 31		 jne	 SHORT $LN5@s370_FPC_c
  00030	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00034	25 88 00 03 03	 and	 eax, 50528392		; 03030088H
  00039	85 c0		 test	 eax, eax
  0003b	75 24		 jne	 SHORT $LN5@s370_FPC_c
  0003d	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00041	83 e0 07	 and	 eax, 7
  00044	83 f8 04	 cmp	 eax, 4
  00047	74 18		 je	 SHORT $LN5@s370_FPC_c
  00049	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  0004d	83 e0 07	 and	 eax, 7
  00050	83 f8 05	 cmp	 eax, 5
  00053	74 0c		 je	 SHORT $LN5@s370_FPC_c
  00055	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  00059	83 e0 07	 and	 eax, 7
  0005c	83 f8 06	 cmp	 eax, 6
  0005f	75 15		 jne	 SHORT $LN4@s370_FPC_c
$LN5@s370_FPC_c:

; 796  :         )
; 797  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00061	ba 06 00 00 00	 mov	 edx, 6
  00066	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00070	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN4@s370_FPC_c:

; 798  :     }

  00076	eb 22		 jmp	 SHORT $LN3@s370_FPC_c
$LN2@s370_FPC_c:

; 799  :     else
; 800  :     {
; 801  :         if (fpc & FPC_RESERVED)

  00078	8b 44 24 38	 mov	 eax, DWORD PTR fpc$[rsp]
  0007c	25 8c 00 07 07	 and	 eax, 117899404		; 0707008cH
  00081	85 c0		 test	 eax, eax
  00083	74 15		 je	 SHORT $LN6@s370_FPC_c

; 802  :             regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00085	ba 06 00 00 00	 mov	 edx, 6
  0008a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00094	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN6@s370_FPC_c:
$LN3@s370_FPC_c:

; 803  :     }
; 804  : }

  0009a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009e	c3		 ret	 0
s370_FPC_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_per3_zero_xcheck2
_TEXT	SEGMENT
regs$ = 8
x2$ = 16
b2$ = 24
s370_per3_zero_xcheck2 PROC				; COMDAT

; 765  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_per3_:

; 766  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 767  :     if (0
; 768  :         || (!b2 && x2 && GR_A( x2, regs ) == 0)
; 769  :         || (!x2 && b2 && GR_A( b2, regs ) == 0)
; 770  :         || ( b2 && x2 && (0
; 771  :                           || GR_A( b2, regs ) == 0
; 772  :                           || GR_A( b2, regs ) + GR_A( x2, regs ) == 0
; 773  :                          )
; 774  :            )
; 775  :     )
; 776  :         ARCH_DEP( per3_zero )( regs );
; 777  : #else
; 778  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@s370_per3_
$LN7@s370_per3_:

; 779  :     UNREFERENCED( x2 );

  00014	33 c0		 xor	 eax, eax
  00016	85 c0		 test	 eax, eax
  00018	75 fa		 jne	 SHORT $LN7@s370_per3_
$LN10@s370_per3_:

; 780  :     UNREFERENCED( b2 );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN10@s370_per3_

; 781  : #endif
; 782  : }

  00020	c3		 ret	 0
s370_per3_zero_xcheck2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_per3_zero_xcheck
_TEXT	SEGMENT
regs$ = 8
b1$ = 16
s370_per3_zero_xcheck PROC				; COMDAT

; 754  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_per3_:

; 755  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 756  :     if (b1 && GR_A( b1, regs ) == 0)
; 757  :         ARCH_DEP( per3_zero )( regs );
; 758  : #else
; 759  :     UNREFERENCED( regs );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@s370_per3_
$LN7@s370_per3_:

; 760  :     UNREFERENCED( b1 );

  0000f	33 c0		 xor	 eax, eax
  00011	85 c0		 test	 eax, eax
  00013	75 fa		 jne	 SHORT $LN7@s370_per3_

; 761  : #endif
; 762  : }

  00015	c3		 ret	 0
s370_per3_zero_xcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_per3_zero_l24check2
_TEXT	SEGMENT
regs$ = 8
r1$ = 16
l1$ = 24
r2$ = 32
l2$ = 40
s370_per3_zero_l24check2 PROC				; COMDAT

; 723  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_per3_:

; 724  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 725  :     if (0
; 726  :         || (1
; 727  :             && regs->GR_LA24( l1 ) != 0
; 728  :             && GR_A( r1, regs )    == 0
; 729  :            )
; 730  :         || (1
; 731  :             && regs->GR_LA24( l2 ) != 0
; 732  :             && GR_A( r2, regs )    == 0
; 733  :            )
; 734  :     )
; 735  :         ARCH_DEP( per3_zero )( regs );
; 736  : #else
; 737  :     UNREFERENCED( regs );

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@s370_per3_
$LN7@s370_per3_:

; 738  :     UNREFERENCED( r1 );

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	75 fa		 jne	 SHORT $LN7@s370_per3_
$LN10@s370_per3_:

; 739  :     UNREFERENCED( l1 );

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN10@s370_per3_
$LN13@s370_per3_:

; 740  :     UNREFERENCED( r2 );

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN13@s370_per3_
$LN16@s370_per3_:

; 741  :     UNREFERENCED( l2 );

  0002b	33 c0		 xor	 eax, eax
  0002d	85 c0		 test	 eax, eax
  0002f	75 fa		 jne	 SHORT $LN16@s370_per3_

; 742  : #endif
; 743  : }

  00031	c3		 ret	 0
s370_per3_zero_l24check2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_per3_zero_l24check
_TEXT	SEGMENT
regs$ = 8
r1$ = 16
l1$ = 24
s370_per3_zero_l24check PROC				; COMDAT

; 708  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_per3_:

; 709  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 710  :     if (1
; 711  :         && regs->GR_LA24( l1 ) != 0
; 712  :         && GR_A( r1, regs )    == 0
; 713  :     )
; 714  :         ARCH_DEP( per3_zero )( regs );
; 715  : #else
; 716  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@s370_per3_
$LN7@s370_per3_:

; 717  :     UNREFERENCED( r1 );

  00014	33 c0		 xor	 eax, eax
  00016	85 c0		 test	 eax, eax
  00018	75 fa		 jne	 SHORT $LN7@s370_per3_
$LN10@s370_per3_:

; 718  :     UNREFERENCED( l1 );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN10@s370_per3_

; 719  : #endif
; 720  : }

  00020	c3		 ret	 0
s370_per3_zero_l24check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_per3_zero_lcheck2
_TEXT	SEGMENT
regs$ = 8
r1$ = 16
l1$ = 24
r2$ = 32
l2$ = 40
s370_per3_zero_lcheck2 PROC				; COMDAT

; 677  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_per3_:

; 678  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 679  :     if (0
; 680  :         || (1
; 681  :             && GR_A( l1, regs ) != 0
; 682  :             && GR_A( r1, regs ) == 0
; 683  :            )
; 684  :         || (1
; 685  :             && GR_A( l2, regs ) != 0
; 686  :             && GR_A( r2, regs ) == 0
; 687  :            )
; 688  :     )
; 689  :         ARCH_DEP( per3_zero )( regs );
; 690  : #else
; 691  :     UNREFERENCED( regs );

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@s370_per3_
$LN7@s370_per3_:

; 692  :     UNREFERENCED( r1 );

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	75 fa		 jne	 SHORT $LN7@s370_per3_
$LN10@s370_per3_:

; 693  :     UNREFERENCED( l1 );

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN10@s370_per3_
$LN13@s370_per3_:

; 694  :     UNREFERENCED( r2 );

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN13@s370_per3_
$LN16@s370_per3_:

; 695  :     UNREFERENCED( l2 );

  0002b	33 c0		 xor	 eax, eax
  0002d	85 c0		 test	 eax, eax
  0002f	75 fa		 jne	 SHORT $LN16@s370_per3_

; 696  : #endif
; 697  : }

  00031	c3		 ret	 0
s370_per3_zero_lcheck2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_per3_zero_lcheck
_TEXT	SEGMENT
regs$ = 8
r1$ = 16
l1$ = 24
s370_per3_zero_lcheck PROC				; COMDAT

; 662  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_per3_:

; 663  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 664  :     if (1
; 665  :         && GR_A( l1, regs ) != 0
; 666  :         && GR_A( r1, regs ) == 0
; 667  :     )
; 668  :         ARCH_DEP( per3_zero )( regs );
; 669  : #else
; 670  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@s370_per3_
$LN7@s370_per3_:

; 671  :     UNREFERENCED( r1 );

  00014	33 c0		 xor	 eax, eax
  00016	85 c0		 test	 eax, eax
  00018	75 fa		 jne	 SHORT $LN7@s370_per3_
$LN10@s370_per3_:

; 672  :     UNREFERENCED( l1 );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN10@s370_per3_

; 673  : #endif
; 674  : }

  00020	c3		 ret	 0
s370_per3_zero_lcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_per3_zero_check2
_TEXT	SEGMENT
regs$ = 8
r1$ = 16
r2$ = 24
s370_per3_zero_check2 PROC				; COMDAT

; 640  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_per3_:

; 641  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 642  :     if (0
; 643  :         || GR_A( r1, regs ) == 0
; 644  :         || GR_A( r2, regs ) == 0
; 645  :     )
; 646  :         ARCH_DEP( per3_zero )( regs );
; 647  : #else
; 648  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@s370_per3_
$LN7@s370_per3_:

; 649  :     UNREFERENCED( r1 );

  00014	33 c0		 xor	 eax, eax
  00016	85 c0		 test	 eax, eax
  00018	75 fa		 jne	 SHORT $LN7@s370_per3_
$LN10@s370_per3_:

; 650  :     UNREFERENCED( r2 );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN10@s370_per3_

; 651  : #endif
; 652  : }

  00020	c3		 ret	 0
s370_per3_zero_check2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_per3_zero_check
_TEXT	SEGMENT
regs$ = 8
r1$ = 16
s370_per3_zero_check PROC				; COMDAT

; 629  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_per3_:

; 630  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 631  :     if (GR_A( r1, regs ) == 0)
; 632  :         ARCH_DEP( per3_zero )( regs );
; 633  : #else
; 634  :     UNREFERENCED( regs );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@s370_per3_
$LN7@s370_per3_:

; 635  :     UNREFERENCED( r1 );

  0000f	33 c0		 xor	 eax, eax
  00011	85 c0		 test	 eax, eax
  00013	75 fa		 jne	 SHORT $LN7@s370_per3_

; 636  : #endif
; 637  : }

  00015	c3		 ret	 0
s370_per3_zero_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_per3_zero
_TEXT	SEGMENT
regs$ = 8
s370_per3_zero PROC					; COMDAT

; 602  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_per3_:

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )
; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;
; 610  :         ON_IC_PER_ZEROADDR( regs );
; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))
; 612  :             RETURN_INTCHECK( regs );
; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );

  00005	33 c0		 xor	 eax, eax
  00007	85 c0		 test	 eax, eax
  00009	75 fa		 jne	 SHORT $LN4@s370_per3_

; 616  : #endif
; 617  : }

  0000b	c3		 ret	 0
s370_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
s370_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@s370_is_pe:

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@s370_is_pe
$LN7@s370_is_pe:

; 569  :     UNREFERENCED( cr9_per_event );

  0000f	33 c0		 xor	 eax, eax
  00011	85 c0		 test	 eax, eax
  00013	75 fa		 jne	 SHORT $LN7@s370_is_pe

; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))
; 573  :         return false;
; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)
; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)
; 580  :             return true;        /* Yes, then suppress it! */
; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0
; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */
; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  00015	32 c0		 xor	 al, al

; 596  : }

  00017	c3		 ret	 0
s370_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_per1_gra
_TEXT	SEGMENT
regs$ = 48
s370_per1_gra PROC					; COMDAT

; 546  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 547  : #if !defined( FEATURE_PER1 )
; 548  :     UNREFERENCED( regs );
; 549  : #else
; 550  :     OBTAIN_INTLOCK( regs );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@OMLMFJCF@C?3?2papa?2MyGit?2hyperion?9zvector?2@
  00010	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00015	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 551  :     {
; 552  :         regs->peradr = regs->periaddr;

  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00024	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0002b	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@s370_per1_:

; 553  :         ON_IC_PER_GRA( regs );

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00037	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0003a	0f ba e8 14	 bts	 eax, 20
  0003e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00043	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00046	33 c0		 xor	 eax, eax
  00048	85 c0		 test	 eax, eax
  0004a	75 e6		 jne	 SHORT $LN4@s370_per1_

; 554  :     }
; 555  :     RELEASE_INTLOCK( regs );

  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@JBMLKNGA@C?3?2papa?2MyGit?2hyperion?9zvector?2@
  00053	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00058	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 556  : 
; 557  :     if (OPEN_IC_PER_GRA( regs ))

  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00062	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00067	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0006a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0006d	23 c1		 and	 eax, ecx
  0006f	25 00 00 10 00	 and	 eax, 1048576		; 00100000H
  00074	85 c0		 test	 eax, eax
  00076	74 18		 je	 SHORT $LN5@s370_per1_

; 558  :         RETURN_INTCHECK( regs );

  00078	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00083	ba ff ff ff ff	 mov	 edx, -1
  00088	48 8b c8	 mov	 rcx, rax
  0008b	e8 00 00 00 00	 call	 longjmp
$LN5@s370_per1_:
$LN6@s370_per1_:

; 559  : #endif
; 560  : }

  00090	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00094	c3		 ret	 0
s370_per1_gra ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_fetch_main_absolute
_TEXT	SEGMENT
addr$ = 64
regs$ = 72
s370_fetch_main_absolute PROC				; COMDAT

; 524  : {

$LN7:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370_fetch:

; 525  : #if defined( INLINE_STORE_FETCH_ADDR_CHECK )
; 526  :     if (addr > (regs->mainlim - len))
; 527  :         regs->program_interrupt( regs, PGM_ADDRESSING_EXCEPTION );
; 528  : #endif
; 529  : 
; 530  :     /* Translate SIE host virt to SIE host abs. Note: macro
; 531  :        is treated as a no-operation if SIE_MODE not active */
; 532  :     SIE_TRANSLATE( &addr, ACCTYPE_READ, regs );

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00019	d1 e8		 shr	 eax, 1
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 6a		 je	 SHORT $LN5@s370_fetch
  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0002d	c1 e8 02	 shr	 eax, 2
  00030	83 e0 01	 and	 eax, 1
  00033	85 c0		 test	 eax, eax
  00035	75 55		 jne	 SHORT $LN5@s370_fetch
  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0003c	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00043	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]
  00048	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00051	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00056	41 b9 04 00 00
	00		 mov	 r9d, 4
  0005c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00068	ba fd ff ff ff	 mov	 edx, -3
  0006d	8b c8		 mov	 ecx, eax
  0006f	e8 00 00 00 00	 call	 s390_logical_to_main_l
  00074	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00079	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00080	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  00087	48 89 44 24 40	 mov	 QWORD PTR addr$[rsp], rax
$LN5@s370_fetch:
  0008c	33 c0		 xor	 eax, eax
  0008e	85 c0		 test	 eax, eax
  00090	0f 85 78 ff ff
	ff		 jne	 $LN4@s370_fetch

; 533  : 
; 534  :     /* Set the main storage reference bit */
; 535  :     ARCH_DEP( or_storage_key )( addr, STORKEY_REF );

  00096	b2 04		 mov	 dl, 4
  00098	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr$[rsp]
  0009d	e8 00 00 00 00	 call	 s370_or_storage_key

; 536  : 
; 537  :     /* Return absolute storage mainstor address */
; 538  :     return (regs->mainstor + addr);

  000a2	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000ae	48 03 44 24 40	 add	 rax, QWORD PTR addr$[rsp]

; 539  : 
; 540  : } /* end function fetch_main_absolute */

  000b3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b7	c3		 ret	 0
s370_fetch_main_absolute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_is_store_protected
_TEXT	SEGMENT
addr$ = 48
skey$ = 56
akey$ = 64
regs$ = 72
s370_is_store_protected PROC				; COMDAT

; 469  : {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 470  :     /* [3.4.4] Low-address protection prohibits stores into certain
; 471  :        locations in the prefixed storage area of non-private address
; 472  :        address spaces, if the low-address control bit in CR0 is set,
; 473  :        regardless of the access key and storage key */
; 474  :     if (ARCH_DEP( is_low_address_protected )( addr, regs ))

  00016	48 8b 54 24 48	 mov	 rdx, QWORD PTR regs$[rsp]
  0001b	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  0001f	e8 00 00 00 00	 call	 s370_is_low_address_protected
  00024	0f b6 c0	 movzx	 eax, al
  00027	85 c0		 test	 eax, eax
  00029	74 04		 je	 SHORT $LN2@s370_is_st

; 475  :         return true;

  0002b	b0 01		 mov	 al, 1
  0002d	eb 72		 jmp	 SHORT $LN1@s370_is_st
$LN2@s370_is_st:

; 476  : 
; 477  :     /* Access-list controlled protection prohibits all stores into
; 478  :        the address space, and page protection prohibits all stores
; 479  :        into the page, regardless of the access key and storage key */
; 480  :     if (regs->dat.protect)

  0002f	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00034	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0003a	d1 e8		 shr	 eax, 1
  0003c	83 e0 03	 and	 eax, 3
  0003f	85 c0		 test	 eax, eax
  00041	74 04		 je	 SHORT $LN3@s370_is_st

; 481  :         return true;

  00043	b0 01		 mov	 al, 1
  00045	eb 5a		 jmp	 SHORT $LN1@s370_is_st
$LN3@s370_is_st:

; 482  : 
; 483  : #if defined( _FEATURE_SIE )
; 484  :     if (SIE_MODE( regs ) && HOSTREGS->dat.protect)

  00047	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0004c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00052	d1 e8		 shr	 eax, 1
  00054	83 e0 01	 and	 eax, 1
  00057	85 c0		 test	 eax, eax
  00059	74 1f		 je	 SHORT $LN4@s370_is_st
  0005b	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00060	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00067	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0006d	d1 e8		 shr	 eax, 1
  0006f	83 e0 03	 and	 eax, 3
  00072	85 c0		 test	 eax, eax
  00074	74 04		 je	 SHORT $LN4@s370_is_st

; 485  :         return true;

  00076	b0 01		 mov	 al, 1
  00078	eb 27		 jmp	 SHORT $LN1@s370_is_st
$LN4@s370_is_st:

; 486  : #endif
; 487  : 
; 488  :     /* [3.4.1] Store is allowed if access key is zero, regardless
; 489  :        of the storage key */
; 490  :     if (akey == 0)

  0007a	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey$[rsp]
  0007f	85 c0		 test	 eax, eax
  00081	75 04		 jne	 SHORT $LN5@s370_is_st

; 491  :         return false;

  00083	32 c0		 xor	 al, al
  00085	eb 1a		 jmp	 SHORT $LN1@s370_is_st
$LN5@s370_is_st:

; 492  : 
; 493  : #if defined( FEATURE_STORAGE_PROTECTION_OVERRIDE )
; 494  :     /* [3.4.1.1] Storage protection override allows access to
; 495  :        locations with storage key 9, regardless of the access key,
; 496  :        provided that CR0 bit 7 is set */
; 497  :     if (1
; 498  :         && (skey & STORKEY_KEY) == 0x90
; 499  :         && (regs->CR(0) & CR0_STORE_OVRD)
; 500  :     )
; 501  :         return false;
; 502  : #endif
; 503  : 
; 504  :     /* [3.4.1] Store protection prohibits stores
; 505  :        if the access key does not match the storage key */
; 506  :     if (akey != (skey & STORKEY_KEY))

  00087	0f b6 44 24 40	 movzx	 eax, BYTE PTR akey$[rsp]
  0008c	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR skey$[rsp]
  00091	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00097	3b c1		 cmp	 eax, ecx
  00099	74 04		 je	 SHORT $LN6@s370_is_st

; 507  :         return true;

  0009b	b0 01		 mov	 al, 1
  0009d	eb 02		 jmp	 SHORT $LN1@s370_is_st
$LN6@s370_is_st:

; 508  : 
; 509  :     return false;      // (location is *NOT* store protected)

  0009f	32 c0		 xor	 al, al
$LN1@s370_is_st:

; 510  : 
; 511  : } /* end function is_store_protected */

  000a1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a5	c3		 ret	 0
s370_is_store_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_is_low_address_protected
_TEXT	SEGMENT
addr$ = 8
regs$ = 16
s370_is_low_address_protected PROC			; COMDAT

; 419  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 420  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 421  :     /* For z/Arch, low-address protection applies to locations
; 422  :        0-511 (0000-01FF) and also 4096-4607 (1000-11FF) */
; 423  :     if (addr & 0xFFFFFFFFFFFFEE00ULL)
; 424  : #else
; 425  :     /* For S/370 and ESA/390, low-address protection applies
; 426  :        only to locations 0-511 */
; 427  :     if (addr > 511)

  00009	81 7c 24 08 ff
	01 00 00	 cmp	 DWORD PTR addr$[rsp], 511 ; 000001ffH
  00011	76 04		 jbe	 SHORT $LN2@s370_is_lo

; 428  : #endif
; 429  :         return false;

  00013	32 c0		 xor	 al, al
  00015	eb 50		 jmp	 SHORT $LN1@s370_is_lo
$LN2@s370_is_lo:

; 430  : 
; 431  :     /* Low-address protection applies only if the low-address
; 432  :        protection control bit in control register 0 is set */
; 433  :     if (!(regs->CR(0) & CR0_LOW_PROT))

  00017	b8 08 00 00 00	 mov	 eax, 8
  0001c	48 6b c0 01	 imul	 rax, rax, 1
  00020	48 8b 4c 24 10	 mov	 rcx, QWORD PTR regs$[rsp]
  00025	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0002c	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00031	85 c0		 test	 eax, eax
  00033	75 04		 jne	 SHORT $LN3@s370_is_lo

; 434  :         return false;

  00035	32 c0		 xor	 al, al
  00037	eb 2e		 jmp	 SHORT $LN1@s370_is_lo
$LN3@s370_is_lo:

; 435  : 
; 436  : #if defined( _FEATURE_SIE )
; 437  :     /* Host low-address protection is not applied to guest
; 438  :        references to guest storage */
; 439  :     if (regs->sie_active)

  00039	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  0003e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00044	83 e0 01	 and	 eax, 1
  00047	85 c0		 test	 eax, eax
  00049	74 04		 je	 SHORT $LN4@s370_is_lo

; 440  :         return false;

  0004b	32 c0		 xor	 al, al
  0004d	eb 18		 jmp	 SHORT $LN1@s370_is_lo
$LN4@s370_is_lo:

; 441  : #endif
; 442  : 
; 443  :     /* Low-addr protection doesn't apply to private address spaces */
; 444  :     if (regs->dat.pvtaddr)

  0004f	48 8b 44 24 10	 mov	 rax, QWORD PTR regs$[rsp]
  00054	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  0005a	83 e0 01	 and	 eax, 1
  0005d	85 c0		 test	 eax, eax
  0005f	74 04		 je	 SHORT $LN5@s370_is_lo

; 445  :         return false;

  00061	32 c0		 xor	 al, al
  00063	eb 02		 jmp	 SHORT $LN1@s370_is_lo
$LN5@s370_is_lo:

; 446  : 
; 447  :     return true;      // (location *IS* low-address protected)

  00065	b0 01		 mov	 al, 1
$LN1@s370_is_lo:

; 448  : 
; 449  : } /* end function is_low_address_protected */

  00067	c3		 ret	 0
s370_is_low_address_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT s370_is_fetch_protected
_TEXT	SEGMENT
tv87 = 0
addr$ = 32
skey$ = 40
akey$ = 48
regs$ = 56
s370_is_fetch_protected PROC				; COMDAT

; 365  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 18	 sub	 rsp, 24
$LN4@s370_is_fe:

; 366  :     UNREFERENCED_370( addr );

  00016	33 c0		 xor	 eax, eax
  00018	85 c0		 test	 eax, eax
  0001a	75 fa		 jne	 SHORT $LN4@s370_is_fe
$LN7@s370_is_fe:

; 367  :     UNREFERENCED_370( regs );

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN7@s370_is_fe

; 368  : 
; 369  :     /* [3.4.1] Fetch is allowed if access key is zero, regardless
; 370  :        of the storage key and fetch protection bit */
; 371  :     /* [3.4.1] Fetch protection prohibits fetch if storage key fetch
; 372  :        protect bit is on and access key does not match storage key */
; 373  :     if (likely(0

  00022	33 c0		 xor	 eax, eax
  00024	85 c0		 test	 eax, eax
  00026	75 32		 jne	 SHORT $LN10@s370_is_fe
  00028	0f b6 44 24 30	 movzx	 eax, BYTE PTR akey$[rsp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 29		 je	 SHORT $LN10@s370_is_fe
  00031	0f b6 44 24 30	 movzx	 eax, BYTE PTR akey$[rsp]
  00036	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR skey$[rsp]
  0003b	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  00041	3b c1		 cmp	 eax, ecx
  00043	74 15		 je	 SHORT $LN10@s370_is_fe
  00045	0f b6 44 24 28	 movzx	 eax, BYTE PTR skey$[rsp]
  0004a	83 e0 08	 and	 eax, 8
  0004d	85 c0		 test	 eax, eax
  0004f	74 09		 je	 SHORT $LN10@s370_is_fe
  00051	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv87[rsp], 0
  00058	eb 07		 jmp	 SHORT $LN13@s370_is_fe
$LN10@s370_is_fe:
  0005a	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv87[rsp], 1
$LN13@s370_is_fe:
  00061	83 3c 24 00	 cmp	 DWORD PTR tv87[rsp], 0
  00065	74 04		 je	 SHORT $LN8@s370_is_fe

; 374  :                || akey == 0
; 375  :                || akey == (skey & STORKEY_KEY)
; 376  :                || !(skey & STORKEY_FETCH)
; 377  :               )
; 378  :     )
; 379  :         return false;

  00067	32 c0		 xor	 al, al
  00069	eb 02		 jmp	 SHORT $LN1@s370_is_fe
$LN8@s370_is_fe:

; 380  : 
; 381  : #if defined( FEATURE_FETCH_PROTECTION_OVERRIDE )
; 382  :     /* [3.4.1.2] Fetch protection override allows fetch from first
; 383  :        2K of non-private address spaces if CR0 bit 6 is set */
; 384  :     if (1
; 385  :         && addr < 2048
; 386  :         && (regs->CR(0) & CR0_FETCH_OVRD)
; 387  :         && regs->dat.pvtaddr == 0
; 388  :     )
; 389  :         return false;
; 390  : #endif
; 391  : 
; 392  : #if defined( FEATURE_STORAGE_PROTECTION_OVERRIDE )
; 393  :     /* [3.4.1.1] Storage protection override allows access to
; 394  :        locations with storage key 9, regardless of the access key,
; 395  :        provided that CR0 bit 7 is set */
; 396  :     if (1
; 397  :         && (skey & STORKEY_KEY) == 0x90
; 398  :         && (regs->CR(0) & CR0_STORE_OVRD)
; 399  :     )
; 400  :         return false;
; 401  : #endif
; 402  : 
; 403  :     return true;    // (location *IS* fetch protected)

  0006b	b0 01		 mov	 al, 1
$LN1@s370_is_fe:

; 404  : 
; 405  : } /* end function is_fetch_protected */

  0006d	48 83 c4 18	 add	 rsp, 24
  00071	c3		 ret	 0
s370_is_fetch_protected ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT mult_logical_long
_TEXT	SEGMENT
i$ = 0
ovf$1 = 8
high$ = 32
lo$ = 40
md$ = 48
mr$ = 56
mult_logical_long PROC					; COMDAT

; 277  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 278  :     int i;
; 279  : 
; 280  :     *high = 0; *lo = 0;

  00018	48 8b 44 24 20	 mov	 rax, QWORD PTR high$[rsp]
  0001d	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
  00024	48 8b 44 24 28	 mov	 rax, QWORD PTR lo$[rsp]
  00029	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 281  :     for (i = 0; i < 64; i++)

  00030	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00037	eb 08		 jmp	 SHORT $LN4@mult_logic
$LN2@mult_logic:
  00039	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0003c	ff c0		 inc	 eax
  0003e	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@mult_logic:
  00041	83 3c 24 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  00045	0f 8d a8 00 00
	00		 jge	 $LN3@mult_logic

; 282  :     {
; 283  :     U64 ovf;
; 284  :         ovf = *high;

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR high$[rsp]
  00050	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00053	48 89 44 24 08	 mov	 QWORD PTR ovf$1[rsp], rax

; 285  :         if (md & 1)

  00058	48 8b 44 24 30	 mov	 rax, QWORD PTR md$[rsp]
  0005d	48 83 e0 01	 and	 rax, 1
  00061	48 85 c0	 test	 rax, rax
  00064	74 15		 je	 SHORT $LN5@mult_logic

; 286  :             *high += mr;

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR high$[rsp]
  0006b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006e	48 03 44 24 38	 add	 rax, QWORD PTR mr$[rsp]
  00073	48 8b 4c 24 20	 mov	 rcx, QWORD PTR high$[rsp]
  00078	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN5@mult_logic:

; 287  :         md >>= 1;

  0007b	48 8b 44 24 30	 mov	 rax, QWORD PTR md$[rsp]
  00080	48 d1 e8	 shr	 rax, 1
  00083	48 89 44 24 30	 mov	 QWORD PTR md$[rsp], rax

; 288  :         *lo = (*lo >> 1) | (*high << 63);

  00088	48 8b 44 24 28	 mov	 rax, QWORD PTR lo$[rsp]
  0008d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00090	48 d1 e8	 shr	 rax, 1
  00093	48 8b 4c 24 20	 mov	 rcx, QWORD PTR high$[rsp]
  00098	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0009b	48 c1 e1 3f	 shl	 rcx, 63			; 0000003fH
  0009f	48 0b c1	 or	 rax, rcx
  000a2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lo$[rsp]
  000a7	48 89 01	 mov	 QWORD PTR [rcx], rax

; 289  :         if(ovf > *high)

  000aa	48 8b 44 24 20	 mov	 rax, QWORD PTR high$[rsp]
  000af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b2	48 39 44 24 08	 cmp	 QWORD PTR ovf$1[rsp], rax
  000b7	76 22		 jbe	 SHORT $LN6@mult_logic

; 290  :             *high = (*high >> 1) | 0x8000000000000000ULL;

  000b9	48 8b 44 24 20	 mov	 rax, QWORD PTR high$[rsp]
  000be	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c1	48 d1 e8	 shr	 rax, 1
  000c4	48 b9 00 00 00
	00 00 00 00 80	 mov	 rcx, -9223372036854775808 ; 8000000000000000H
  000ce	48 0b c1	 or	 rax, rcx
  000d1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR high$[rsp]
  000d6	48 89 01	 mov	 QWORD PTR [rcx], rax
  000d9	eb 13		 jmp	 SHORT $LN7@mult_logic
$LN6@mult_logic:

; 291  :         else
; 292  :             *high >>= 1;

  000db	48 8b 44 24 20	 mov	 rax, QWORD PTR high$[rsp]
  000e0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e3	48 d1 e8	 shr	 rax, 1
  000e6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR high$[rsp]
  000eb	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN7@mult_logic:

; 293  :     }

  000ee	e9 46 ff ff ff	 jmp	 $LN2@mult_logic
$LN3@mult_logic:

; 294  :     return 0;

  000f3	33 c0		 xor	 eax, eax

; 295  : }

  000f5	48 83 c4 18	 add	 rsp, 24
  000f9	c3		 ret	 0
mult_logical_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT sub_signed_long
_TEXT	SEGMENT
tv74 = 0
tv75 = 4
tv76 = 8
sop2$ = 16
sop1$ = 24
sres$ = 32
result$ = 64
op1$ = 72
op2$ = 80
sub_signed_long PROC					; COMDAT

; 253  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 254  :     S64 sres, sop1, sop2;
; 255  : 
; 256  :     /* NOTE: cannot use casting here as signed fixed point overflow
; 257  :        leads to undefined behavior! (whereas unsigned doesn't)
; 258  :     */
; 259  :     *result = op1 - op2;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR op2$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 2b c8	 sub	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  00028	48 89 01	 mov	 QWORD PTR [rcx], rax

; 260  : 
; 261  :     sres = (S64) *result;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00033	48 89 44 24 20	 mov	 QWORD PTR sres$[rsp], rax

; 262  :     sop1 = (S64) op1;

  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR op1$[rsp]
  0003d	48 89 44 24 18	 mov	 QWORD PTR sop1$[rsp], rax

; 263  :     sop2 = (S64) op2;

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR op2$[rsp]
  00047	48 89 44 24 10	 mov	 QWORD PTR sop2$[rsp], rax

; 264  : 
; 265  :     return

  0004c	33 c0		 xor	 eax, eax
  0004e	85 c0		 test	 eax, eax
  00050	0f 85 83 00 00
	00		 jne	 $LN4@sub_signed
  00056	48 83 7c 24 10
	00		 cmp	 QWORD PTR sop2$[rsp], 0
  0005c	7d 1c		 jge	 SHORT $LN3@sub_signed
  0005e	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00068	48 8b 4c 24 10	 mov	 rcx, QWORD PTR sop2$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 39 44 24 18	 cmp	 QWORD PTR sop1$[rsp], rax
  00078	7f 5f		 jg	 SHORT $LN4@sub_signed
$LN3@sub_signed:
  0007a	48 83 7c 24 10
	00		 cmp	 QWORD PTR sop2$[rsp], 0
  00080	7e 1c		 jle	 SHORT $LN5@sub_signed
  00082	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  0008c	48 8b 4c 24 10	 mov	 rcx, QWORD PTR sop2$[rsp]
  00091	48 2b c8	 sub	 rcx, rax
  00094	48 8b c1	 mov	 rax, rcx
  00097	48 39 44 24 18	 cmp	 QWORD PTR sop1$[rsp], rax
  0009c	7c 3b		 jl	 SHORT $LN4@sub_signed
$LN5@sub_signed:
  0009e	48 83 7c 24 20
	00		 cmp	 QWORD PTR sres$[rsp], 0
  000a4	7d 0a		 jge	 SHORT $LN8@sub_signed
  000a6	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  000ae	eb 1f		 jmp	 SHORT $LN9@sub_signed
$LN8@sub_signed:
  000b0	48 83 7c 24 20
	00		 cmp	 QWORD PTR sres$[rsp], 0
  000b6	7e 09		 jle	 SHORT $LN6@sub_signed
  000b8	c7 04 24 02 00
	00 00		 mov	 DWORD PTR tv74[rsp], 2
  000bf	eb 07		 jmp	 SHORT $LN7@sub_signed
$LN6@sub_signed:
  000c1	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv74[rsp], 0
$LN7@sub_signed:
  000c8	8b 04 24	 mov	 eax, DWORD PTR tv74[rsp]
  000cb	89 44 24 04	 mov	 DWORD PTR tv75[rsp], eax
$LN9@sub_signed:
  000cf	8b 44 24 04	 mov	 eax, DWORD PTR tv75[rsp]
  000d3	89 44 24 08	 mov	 DWORD PTR tv76[rsp], eax
  000d7	eb 08		 jmp	 SHORT $LN10@sub_signed
$LN4@sub_signed:
  000d9	c7 44 24 08 03
	00 00 00	 mov	 DWORD PTR tv76[rsp], 3
$LN10@sub_signed:
  000e1	8b 44 24 08	 mov	 eax, DWORD PTR tv76[rsp]

; 266  :     (0
; 267  :         || (sop2 < 0 && sop1 > (LLONG_MAX + sop2))
; 268  :         || (sop2 > 0 && sop1 < (LLONG_MIN + sop2))
; 269  :     )
; 270  :     ? 3 : (sres < 0 ? 1 : (sres > 0 ? 2 : 0));
; 271  : }

  000e5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e9	c3		 ret	 0
sub_signed_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT add_signed_long
_TEXT	SEGMENT
tv74 = 0
tv75 = 4
tv76 = 8
sop2$ = 16
sop1$ = 24
sres$ = 32
result$ = 64
op1$ = 72
op2$ = 80
add_signed_long PROC					; COMDAT

; 228  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 229  :     S64 sres, sop1, sop2;
; 230  : 
; 231  :     /* NOTE: cannot use casting here as signed fixed point overflow
; 232  :        leads to undefined behavior! (whereas unsigned doesn't)
; 233  :     */
; 234  :     *result = op1 + op2;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR op2$[rsp]
  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 03 c8	 add	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  00028	48 89 01	 mov	 QWORD PTR [rcx], rax

; 235  : 
; 236  :     sres = (S64) *result;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00033	48 89 44 24 20	 mov	 QWORD PTR sres$[rsp], rax

; 237  :     sop1 = (S64) op1;

  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR op1$[rsp]
  0003d	48 89 44 24 18	 mov	 QWORD PTR sop1$[rsp], rax

; 238  :     sop2 = (S64) op2;

  00042	48 8b 44 24 50	 mov	 rax, QWORD PTR op2$[rsp]
  00047	48 89 44 24 10	 mov	 QWORD PTR sop2$[rsp], rax

; 239  : 
; 240  :     return

  0004c	33 c0		 xor	 eax, eax
  0004e	85 c0		 test	 eax, eax
  00050	75 77		 jne	 SHORT $LN4@add_signed
  00052	48 83 7c 24 10
	00		 cmp	 QWORD PTR sop2$[rsp], 0
  00058	7e 16		 jle	 SHORT $LN3@add_signed
  0005a	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  00064	48 2b 44 24 10	 sub	 rax, QWORD PTR sop2$[rsp]
  00069	48 39 44 24 18	 cmp	 QWORD PTR sop1$[rsp], rax
  0006e	7f 59		 jg	 SHORT $LN4@add_signed
$LN3@add_signed:
  00070	48 83 7c 24 10
	00		 cmp	 QWORD PTR sop2$[rsp], 0
  00076	7d 16		 jge	 SHORT $LN5@add_signed
  00078	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00082	48 2b 44 24 10	 sub	 rax, QWORD PTR sop2$[rsp]
  00087	48 39 44 24 18	 cmp	 QWORD PTR sop1$[rsp], rax
  0008c	7c 3b		 jl	 SHORT $LN4@add_signed
$LN5@add_signed:
  0008e	48 83 7c 24 20
	00		 cmp	 QWORD PTR sres$[rsp], 0
  00094	7d 0a		 jge	 SHORT $LN8@add_signed
  00096	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0009e	eb 1f		 jmp	 SHORT $LN9@add_signed
$LN8@add_signed:
  000a0	48 83 7c 24 20
	00		 cmp	 QWORD PTR sres$[rsp], 0
  000a6	7e 09		 jle	 SHORT $LN6@add_signed
  000a8	c7 04 24 02 00
	00 00		 mov	 DWORD PTR tv74[rsp], 2
  000af	eb 07		 jmp	 SHORT $LN7@add_signed
$LN6@add_signed:
  000b1	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv74[rsp], 0
$LN7@add_signed:
  000b8	8b 04 24	 mov	 eax, DWORD PTR tv74[rsp]
  000bb	89 44 24 04	 mov	 DWORD PTR tv75[rsp], eax
$LN9@add_signed:
  000bf	8b 44 24 04	 mov	 eax, DWORD PTR tv75[rsp]
  000c3	89 44 24 08	 mov	 DWORD PTR tv76[rsp], eax
  000c7	eb 08		 jmp	 SHORT $LN10@add_signed
$LN4@add_signed:
  000c9	c7 44 24 08 03
	00 00 00	 mov	 DWORD PTR tv76[rsp], 3
$LN10@add_signed:
  000d1	8b 44 24 08	 mov	 eax, DWORD PTR tv76[rsp]

; 241  :     (0
; 242  :         || (sop2 > 0 && sop1 > (LLONG_MAX - sop2))
; 243  :         || (sop2 < 0 && sop1 < (LLONG_MIN - sop2))
; 244  :     )
; 245  :     ? 3 : (sres < 0 ? 1 : (sres > 0 ? 2 : 0));
; 246  : }

  000d5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d9	c3		 ret	 0
add_signed_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT sub_logical_long
_TEXT	SEGMENT
tv68 = 0
tv66 = 4
result$ = 32
op1$ = 40
op2$ = 48
sub_logical_long PROC					; COMDAT

; 218  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 219  :     *result = op1 - op2;

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR op2$[rsp]
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 2b c8	 sub	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00028	48 89 01	 mov	 QWORD PTR [rcx], rax

; 220  :     return (*result == 0 ? 0 : 1) | (op1 < *result ? 0 : 2);

  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00030	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00034	75 0a		 jne	 SHORT $LN3@sub_logica
  00036	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
  0003e	eb 08		 jmp	 SHORT $LN4@sub_logica
$LN3@sub_logica:
  00040	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
$LN4@sub_logica:
  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0004d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00050	48 39 44 24 28	 cmp	 QWORD PTR op1$[rsp], rax
  00055	73 09		 jae	 SHORT $LN5@sub_logica
  00057	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
  0005e	eb 07		 jmp	 SHORT $LN6@sub_logica
$LN5@sub_logica:
  00060	c7 04 24 02 00
	00 00		 mov	 DWORD PTR tv68[rsp], 2
$LN6@sub_logica:
  00067	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]
  0006a	8b 4c 24 04	 mov	 ecx, DWORD PTR tv66[rsp]
  0006e	0b c8		 or	 ecx, eax
  00070	8b c1		 mov	 eax, ecx

; 221  : }

  00072	48 83 c4 18	 add	 rsp, 24
  00076	c3		 ret	 0
sub_logical_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT add_logical_long
_TEXT	SEGMENT
tv68 = 0
tv66 = 4
result$ = 32
op1$ = 40
op2$ = 48
add_logical_long PROC					; COMDAT

; 208  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 209  :     *result = op1 + op2;

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR op2$[rsp]
  00018	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op1$[rsp]
  0001d	48 03 c8	 add	 rcx, rax
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00028	48 89 01	 mov	 QWORD PTR [rcx], rax

; 210  :     return (*result == 0 ? 0 : 1) | (op1 > *result ? 2 : 0);

  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00030	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00034	75 0a		 jne	 SHORT $LN3@add_logica
  00036	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
  0003e	eb 08		 jmp	 SHORT $LN4@add_logica
$LN3@add_logica:
  00040	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
$LN4@add_logica:
  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0004d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00050	48 39 44 24 28	 cmp	 QWORD PTR op1$[rsp], rax
  00055	76 09		 jbe	 SHORT $LN5@add_logica
  00057	c7 04 24 02 00
	00 00		 mov	 DWORD PTR tv68[rsp], 2
  0005e	eb 07		 jmp	 SHORT $LN6@add_logica
$LN5@add_logica:
  00060	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
$LN6@add_logica:
  00067	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]
  0006a	8b 4c 24 04	 mov	 ecx, DWORD PTR tv66[rsp]
  0006e	0b c8		 or	 ecx, eax
  00070	8b c1		 mov	 eax, ecx

; 211  : }

  00072	48 83 c4 18	 add	 rsp, 24
  00076	c3		 ret	 0
add_logical_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT div_logical_long
_TEXT	SEGMENT
i$ = 0
ovf$1 = 4
rem$ = 32
quot$ = 40
high$ = 48
lo$ = 56
d$ = 64
div_logical_long PROC					; COMDAT

; 181  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 182  :     int i;
; 183  : 
; 184  :     *quot = 0;

  00018	48 8b 44 24 28	 mov	 rax, QWORD PTR quot$[rsp]
  0001d	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 185  :     if (high >= d) return 1;

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR d$[rsp]
  00029	48 39 44 24 30	 cmp	 QWORD PTR high$[rsp], rax
  0002e	72 0a		 jb	 SHORT $LN5@div_logica
  00030	b8 01 00 00 00	 mov	 eax, 1
  00035	e9 b0 00 00 00	 jmp	 $LN1@div_logica
$LN5@div_logica:

; 186  :     for (i = 0; i < 64; i++)

  0003a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00041	eb 08		 jmp	 SHORT $LN4@div_logica
$LN2@div_logica:
  00043	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00046	ff c0		 inc	 eax
  00048	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@div_logica:
  0004b	83 3c 24 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  0004f	0f 8d 86 00 00
	00		 jge	 $LN3@div_logica

; 187  :     {
; 188  :     int ovf;
; 189  :         ovf = high >> 63;

  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR high$[rsp]
  0005a	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0005e	89 44 24 04	 mov	 DWORD PTR ovf$1[rsp], eax

; 190  :         high = (high << 1) | (lo >> 63);

  00062	48 8b 44 24 30	 mov	 rax, QWORD PTR high$[rsp]
  00067	48 d1 e0	 shl	 rax, 1
  0006a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR lo$[rsp]
  0006f	48 c1 e9 3f	 shr	 rcx, 63			; 0000003fH
  00073	48 0b c1	 or	 rax, rcx
  00076	48 89 44 24 30	 mov	 QWORD PTR high$[rsp], rax

; 191  :         lo <<= 1;

  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR lo$[rsp]
  00080	48 d1 e0	 shl	 rax, 1
  00083	48 89 44 24 38	 mov	 QWORD PTR lo$[rsp], rax

; 192  :         *quot <<= 1;

  00088	48 8b 44 24 28	 mov	 rax, QWORD PTR quot$[rsp]
  0008d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00090	48 d1 e0	 shl	 rax, 1
  00093	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quot$[rsp]
  00098	48 89 01	 mov	 QWORD PTR [rcx], rax

; 193  :         if (high >= d || ovf)

  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR d$[rsp]
  000a0	48 39 44 24 30	 cmp	 QWORD PTR high$[rsp], rax
  000a5	73 07		 jae	 SHORT $LN7@div_logica
  000a7	83 7c 24 04 00	 cmp	 DWORD PTR ovf$1[rsp], 0
  000ac	74 28		 je	 SHORT $LN6@div_logica
$LN7@div_logica:

; 194  :         {
; 195  :             *quot += 1;

  000ae	48 8b 44 24 28	 mov	 rax, QWORD PTR quot$[rsp]
  000b3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b6	48 ff c0	 inc	 rax
  000b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR quot$[rsp]
  000be	48 89 01	 mov	 QWORD PTR [rcx], rax

; 196  :             high -= d;

  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR d$[rsp]
  000c6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR high$[rsp]
  000cb	48 2b c8	 sub	 rcx, rax
  000ce	48 8b c1	 mov	 rax, rcx
  000d1	48 89 44 24 30	 mov	 QWORD PTR high$[rsp], rax
$LN6@div_logica:

; 197  :         }
; 198  :     }

  000d6	e9 68 ff ff ff	 jmp	 $LN2@div_logica
$LN3@div_logica:

; 199  :     *rem = high;

  000db	48 8b 44 24 20	 mov	 rax, QWORD PTR rem$[rsp]
  000e0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR high$[rsp]
  000e5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 200  :     return 0;

  000e8	33 c0		 xor	 eax, eax
$LN1@div_logica:

; 201  : }

  000ea	48 83 c4 18	 add	 rsp, 24
  000ee	c3		 ret	 0
div_logical_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT div_signed
_TEXT	SEGMENT
quotient$ = 0
dividend$ = 8
tv69 = 16
tv71 = 24
remainder$ = 32
rem$ = 64
quot$ = 72
high$ = 80
lo$ = 88
d$ = 96
div_signed PROC						; COMDAT

; 161  : {

$LN6:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 162  : U64 dividend;
; 163  : S64 quotient, remainder;
; 164  : 
; 165  :     if (d == 0) return 1;

  00018	83 7c 24 60 00	 cmp	 DWORD PTR d$[rsp], 0
  0001d	75 0a		 jne	 SHORT $LN2@div_signed
  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	e9 84 00 00 00	 jmp	 $LN1@div_signed
$LN2@div_signed:

; 166  :     dividend = (U64)high << 32 | lo;

  00029	8b 44 24 50	 mov	 eax, DWORD PTR high$[rsp]
  0002d	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  00031	8b 4c 24 58	 mov	 ecx, DWORD PTR lo$[rsp]
  00035	48 0b c1	 or	 rax, rcx
  00038	48 89 44 24 08	 mov	 QWORD PTR dividend$[rsp], rax

; 167  :     quotient = (S64)dividend / (S32)d;

  0003d	48 63 44 24 60	 movsxd	 rax, DWORD PTR d$[rsp]
  00042	48 89 44 24 10	 mov	 QWORD PTR tv69[rsp], rax
  00047	48 8b 44 24 08	 mov	 rax, QWORD PTR dividend$[rsp]
  0004c	48 99		 cdq
  0004e	48 8b 4c 24 10	 mov	 rcx, QWORD PTR tv69[rsp]
  00053	48 f7 f9	 idiv	 rcx
  00056	48 89 04 24	 mov	 QWORD PTR quotient$[rsp], rax

; 168  :     remainder = (S64)dividend % (S32)d;

  0005a	48 63 44 24 60	 movsxd	 rax, DWORD PTR d$[rsp]
  0005f	48 89 44 24 18	 mov	 QWORD PTR tv71[rsp], rax
  00064	48 8b 44 24 08	 mov	 rax, QWORD PTR dividend$[rsp]
  00069	48 99		 cdq
  0006b	48 8b 4c 24 18	 mov	 rcx, QWORD PTR tv71[rsp]
  00070	48 f7 f9	 idiv	 rcx
  00073	48 8b c2	 mov	 rax, rdx
  00076	48 89 44 24 20	 mov	 QWORD PTR remainder$[rsp], rax

; 169  :     if (quotient < -2147483648LL || quotient > 2147483647LL) return 1;

  0007b	48 81 3c 24 00
	00 00 80	 cmp	 QWORD PTR quotient$[rsp], -2147483648 ; ffffffff80000000H
  00083	7c 0a		 jl	 SHORT $LN4@div_signed
  00085	48 81 3c 24 ff
	ff ff 7f	 cmp	 QWORD PTR quotient$[rsp], 2147483647 ; 7fffffffH
  0008d	7e 07		 jle	 SHORT $LN3@div_signed
$LN4@div_signed:
  0008f	b8 01 00 00 00	 mov	 eax, 1
  00094	eb 17		 jmp	 SHORT $LN1@div_signed
$LN3@div_signed:

; 170  :     *quot = (U32)quotient;

  00096	48 8b 44 24 48	 mov	 rax, QWORD PTR quot$[rsp]
  0009b	8b 0c 24	 mov	 ecx, DWORD PTR quotient$[rsp]
  0009e	89 08		 mov	 DWORD PTR [rax], ecx

; 171  :     *rem = (U32)remainder;

  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR rem$[rsp]
  000a5	8b 4c 24 20	 mov	 ecx, DWORD PTR remainder$[rsp]
  000a9	89 08		 mov	 DWORD PTR [rax], ecx

; 172  :     return 0;

  000ab	33 c0		 xor	 eax, eax
$LN1@div_signed:

; 173  : }

  000ad	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b1	c3		 ret	 0
div_signed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT mul_signed_long
_TEXT	SEGMENT
resulthi$ = 48
resultlo$ = 56
op1$ = 64
op2$ = 72
mul_signed_long PROC					; COMDAT

; 147  : {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 148  :     mul_unsigned_long( (U64*)resulthi, (U64*)resultlo,

  00018	4c 8b 4c 24 48	 mov	 r9, QWORD PTR op2$[rsp]
  0001d	4c 8b 44 24 40	 mov	 r8, QWORD PTR op1$[rsp]
  00022	48 8b 54 24 38	 mov	 rdx, QWORD PTR resultlo$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR resulthi$[rsp]
  0002c	e8 00 00 00 00	 call	 mul_unsigned_long

; 149  :                        (U64) op1,      (U64) op2 );
; 150  : 
; 151  :     if (op1 < 0LL)  *resulthi  -=  op2;

  00031	48 83 7c 24 40
	00		 cmp	 QWORD PTR op1$[rsp], 0
  00037	7d 18		 jge	 SHORT $LN2@mul_signed
  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR resulthi$[rsp]
  0003e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  00043	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00046	48 2b c1	 sub	 rax, rcx
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR resulthi$[rsp]
  0004e	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN2@mul_signed:

; 152  :     if (op2 < 0LL)  *resulthi  -=  op1;

  00051	48 83 7c 24 48
	00		 cmp	 QWORD PTR op2$[rsp], 0
  00057	7d 18		 jge	 SHORT $LN3@mul_signed
  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR resulthi$[rsp]
  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op1$[rsp]
  00063	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00066	48 2b c1	 sub	 rax, rcx
  00069	48 8b 4c 24 30	 mov	 rcx, QWORD PTR resulthi$[rsp]
  0006e	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN3@mul_signed:

; 153  : }

  00071	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00075	c3		 ret	 0
mul_signed_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT mul_unsigned_long
_TEXT	SEGMENT
cy$ = 0
p1$ = 8
p2$ = 16
a_lo$ = 24
b_lo$ = 32
a_hi$ = 40
b_hi$ = 48
p0$ = 56
p3$ = 64
resulthi$ = 96
resultlo$ = 104
op1$ = 112
op2$ = 120
mul_unsigned_long PROC					; COMDAT

; 125  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 126  :     U64  a_lo  =  (U64)(U32)op1;

  00018	8b 44 24 70	 mov	 eax, DWORD PTR op1$[rsp]
  0001c	48 89 44 24 18	 mov	 QWORD PTR a_lo$[rsp], rax

; 127  :     U64  a_hi  =  op1 >> 32;

  00021	48 8b 44 24 70	 mov	 rax, QWORD PTR op1$[rsp]
  00026	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0002a	48 89 44 24 28	 mov	 QWORD PTR a_hi$[rsp], rax

; 128  :     U64  b_lo  =  (U64)(U32)op2;

  0002f	8b 44 24 78	 mov	 eax, DWORD PTR op2$[rsp]
  00033	48 89 44 24 20	 mov	 QWORD PTR b_lo$[rsp], rax

; 129  :     U64  b_hi  =  op2 >> 32;

  00038	48 8b 44 24 78	 mov	 rax, QWORD PTR op2$[rsp]
  0003d	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00041	48 89 44 24 30	 mov	 QWORD PTR b_hi$[rsp], rax

; 130  : 
; 131  :     U64  p0    =  a_lo * b_lo;

  00046	48 8b 44 24 18	 mov	 rax, QWORD PTR a_lo$[rsp]
  0004b	48 0f af 44 24
	20		 imul	 rax, QWORD PTR b_lo$[rsp]
  00051	48 89 44 24 38	 mov	 QWORD PTR p0$[rsp], rax

; 132  :     U64  p1    =  a_lo * b_hi;

  00056	48 8b 44 24 18	 mov	 rax, QWORD PTR a_lo$[rsp]
  0005b	48 0f af 44 24
	30		 imul	 rax, QWORD PTR b_hi$[rsp]
  00061	48 89 44 24 08	 mov	 QWORD PTR p1$[rsp], rax

; 133  :     U64  p2    =  a_hi * b_lo;

  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR a_hi$[rsp]
  0006b	48 0f af 44 24
	20		 imul	 rax, QWORD PTR b_lo$[rsp]
  00071	48 89 44 24 10	 mov	 QWORD PTR p2$[rsp], rax

; 134  :     U64  p3    =  a_hi * b_hi;

  00076	48 8b 44 24 28	 mov	 rax, QWORD PTR a_hi$[rsp]
  0007b	48 0f af 44 24
	30		 imul	 rax, QWORD PTR b_hi$[rsp]
  00081	48 89 44 24 40	 mov	 QWORD PTR p3$[rsp], rax

; 135  : 
; 136  :     U32  cy    =  (U32)(((p0 >> 32) + (U32)p1 + (U32)p2) >> 32);

  00086	48 8b 44 24 38	 mov	 rax, QWORD PTR p0$[rsp]
  0008b	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0008f	8b 4c 24 08	 mov	 ecx, DWORD PTR p1$[rsp]
  00093	48 03 c1	 add	 rax, rcx
  00096	8b 4c 24 10	 mov	 ecx, DWORD PTR p2$[rsp]
  0009a	48 03 c1	 add	 rax, rcx
  0009d	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  000a1	89 04 24	 mov	 DWORD PTR cy$[rsp], eax

; 137  : 
; 138  :     *resultlo  =  p0 + (p1 << 32) + (p2 << 32);

  000a4	48 8b 44 24 08	 mov	 rax, QWORD PTR p1$[rsp]
  000a9	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  000ad	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p0$[rsp]
  000b2	48 03 c8	 add	 rcx, rax
  000b5	48 8b c1	 mov	 rax, rcx
  000b8	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p2$[rsp]
  000bd	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  000c1	48 03 c1	 add	 rax, rcx
  000c4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR resultlo$[rsp]
  000c9	48 89 01	 mov	 QWORD PTR [rcx], rax

; 139  :     *resulthi  =  p3 + (p1 >> 32) + (p2 >> 32) + cy;

  000cc	48 8b 44 24 08	 mov	 rax, QWORD PTR p1$[rsp]
  000d1	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  000d5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR p3$[rsp]
  000da	48 03 c8	 add	 rcx, rax
  000dd	48 8b c1	 mov	 rax, rcx
  000e0	48 8b 4c 24 10	 mov	 rcx, QWORD PTR p2$[rsp]
  000e5	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  000e9	48 03 c1	 add	 rax, rcx
  000ec	8b 0c 24	 mov	 ecx, DWORD PTR cy$[rsp]
  000ef	48 03 c1	 add	 rax, rcx
  000f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR resulthi$[rsp]
  000f7	48 89 01	 mov	 QWORD PTR [rcx], rax

; 140  : }

  000fa	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000fe	c3		 ret	 0
mul_unsigned_long ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT mul_signed
_TEXT	SEGMENT
r$ = 0
resulthi$ = 32
resultlo$ = 40
op1$ = 48
op2$ = 56
mul_signed PROC						; COMDAT

; 114  : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 115  :     S64 r = (S64)(S32)op1 * (S32)op2;

  00018	48 63 44 24 30	 movsxd	 rax, DWORD PTR op1$[rsp]
  0001d	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR op2$[rsp]
  00022	48 0f af c1	 imul	 rax, rcx
  00026	48 89 04 24	 mov	 QWORD PTR r$[rsp], rax

; 116  :     *resulthi = (U32)((U64)r >> 32);

  0002a	48 8b 04 24	 mov	 rax, QWORD PTR r$[rsp]
  0002e	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR resulthi$[rsp]
  00037	89 01		 mov	 DWORD PTR [rcx], eax

; 117  :     *resultlo = (U32)((U64)r & 0xFFFFFFFF);

  00039	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0003e	48 8b 0c 24	 mov	 rcx, QWORD PTR r$[rsp]
  00042	48 23 c8	 and	 rcx, rax
  00045	48 8b c1	 mov	 rax, rcx
  00048	48 8b 4c 24 28	 mov	 rcx, QWORD PTR resultlo$[rsp]
  0004d	89 01		 mov	 DWORD PTR [rcx], eax

; 118  : }

  0004f	48 83 c4 18	 add	 rsp, 24
  00053	c3		 ret	 0
mul_signed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT sub_signed
_TEXT	SEGMENT
sop2$ = 0
sop1$ = 4
sres$ = 8
tv74 = 12
tv75 = 16
tv76 = 20
result$ = 48
op1$ = 56
op2$ = 64
sub_signed PROC						; COMDAT

; 90   : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 91   :     S32 sres, sop1, sop2;
; 92   : 
; 93   :     /* NOTE: cannot use casting here as signed fixed point overflow
; 94   :        leads to undefined behavior! (whereas unsigned doesn't)
; 95   :     */
; 96   :     *result = op1 - op2;

  00012	8b 44 24 40	 mov	 eax, DWORD PTR op2$[rsp]
  00016	8b 4c 24 38	 mov	 ecx, DWORD PTR op1$[rsp]
  0001a	2b c8		 sub	 ecx, eax
  0001c	8b c1		 mov	 eax, ecx
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00023	89 01		 mov	 DWORD PTR [rcx], eax

; 97   : 
; 98   :     sres = (S32) *result;

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  0002a	8b 00		 mov	 eax, DWORD PTR [rax]
  0002c	89 44 24 08	 mov	 DWORD PTR sres$[rsp], eax

; 99   :     sop1 = (S32) op1;

  00030	8b 44 24 38	 mov	 eax, DWORD PTR op1$[rsp]
  00034	89 44 24 04	 mov	 DWORD PTR sop1$[rsp], eax

; 100  :     sop2 = (S32) op2;

  00038	8b 44 24 40	 mov	 eax, DWORD PTR op2$[rsp]
  0003c	89 04 24	 mov	 DWORD PTR sop2$[rsp], eax

; 101  : 
; 102  :     return

  0003f	33 c0		 xor	 eax, eax
  00041	85 c0		 test	 eax, eax
  00043	75 64		 jne	 SHORT $LN4@sub_signed
  00045	83 3c 24 00	 cmp	 DWORD PTR sop2$[rsp], 0
  00049	7d 0e		 jge	 SHORT $LN3@sub_signed
  0004b	8b 04 24	 mov	 eax, DWORD PTR sop2$[rsp]
  0004e	05 ff ff ff 7f	 add	 eax, 2147483647		; 7fffffffH
  00053	39 44 24 04	 cmp	 DWORD PTR sop1$[rsp], eax
  00057	7f 50		 jg	 SHORT $LN4@sub_signed
$LN3@sub_signed:
  00059	83 3c 24 00	 cmp	 DWORD PTR sop2$[rsp], 0
  0005d	7e 0e		 jle	 SHORT $LN5@sub_signed
  0005f	8b 04 24	 mov	 eax, DWORD PTR sop2$[rsp]
  00062	2d 00 00 00 80	 sub	 eax, -2147483648	; ffffffff80000000H
  00067	39 44 24 04	 cmp	 DWORD PTR sop1$[rsp], eax
  0006b	7c 3c		 jl	 SHORT $LN4@sub_signed
$LN5@sub_signed:
  0006d	83 7c 24 08 00	 cmp	 DWORD PTR sres$[rsp], 0
  00072	7d 0a		 jge	 SHORT $LN8@sub_signed
  00074	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0007c	eb 21		 jmp	 SHORT $LN9@sub_signed
$LN8@sub_signed:
  0007e	83 7c 24 08 00	 cmp	 DWORD PTR sres$[rsp], 0
  00083	7e 0a		 jle	 SHORT $LN6@sub_signed
  00085	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR tv74[rsp], 2
  0008d	eb 08		 jmp	 SHORT $LN7@sub_signed
$LN6@sub_signed:
  0008f	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN7@sub_signed:
  00097	8b 44 24 0c	 mov	 eax, DWORD PTR tv74[rsp]
  0009b	89 44 24 10	 mov	 DWORD PTR tv75[rsp], eax
$LN9@sub_signed:
  0009f	8b 44 24 10	 mov	 eax, DWORD PTR tv75[rsp]
  000a3	89 44 24 14	 mov	 DWORD PTR tv76[rsp], eax
  000a7	eb 08		 jmp	 SHORT $LN10@sub_signed
$LN4@sub_signed:
  000a9	c7 44 24 14 03
	00 00 00	 mov	 DWORD PTR tv76[rsp], 3
$LN10@sub_signed:
  000b1	8b 44 24 14	 mov	 eax, DWORD PTR tv76[rsp]

; 103  :     (0
; 104  :         || (sop2 < 0 && sop1 > (INT_MAX + sop2))
; 105  :         || (sop2 > 0 && sop1 < (INT_MIN + sop2))
; 106  :     )
; 107  :     ? 3 : (sres < 0 ? 1 : (sres > 0 ? 2 : 0));
; 108  : }

  000b5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b9	c3		 ret	 0
sub_signed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT add_signed
_TEXT	SEGMENT
sop2$ = 0
sop1$ = 4
sres$ = 8
tv74 = 12
tv75 = 16
tv76 = 20
result$ = 48
op1$ = 56
op2$ = 64
add_signed PROC						; COMDAT

; 65   : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 66   :     S32 sres, sop1, sop2;
; 67   : 
; 68   :     /* NOTE: cannot use casting here as signed fixed point overflow
; 69   :        leads to undefined behavior! (whereas unsigned doesn't)
; 70   :     */
; 71   :     *result = op1 + op2;

  00012	8b 44 24 40	 mov	 eax, DWORD PTR op2$[rsp]
  00016	8b 4c 24 38	 mov	 ecx, DWORD PTR op1$[rsp]
  0001a	03 c8		 add	 ecx, eax
  0001c	8b c1		 mov	 eax, ecx
  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR result$[rsp]
  00023	89 01		 mov	 DWORD PTR [rcx], eax

; 72   : 
; 73   :     sres = (S32) *result;

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]
  0002a	8b 00		 mov	 eax, DWORD PTR [rax]
  0002c	89 44 24 08	 mov	 DWORD PTR sres$[rsp], eax

; 74   :     sop1 = (S32) op1;

  00030	8b 44 24 38	 mov	 eax, DWORD PTR op1$[rsp]
  00034	89 44 24 04	 mov	 DWORD PTR sop1$[rsp], eax

; 75   :     sop2 = (S32) op2;

  00038	8b 44 24 40	 mov	 eax, DWORD PTR op2$[rsp]
  0003c	89 04 24	 mov	 DWORD PTR sop2$[rsp], eax

; 76   : 
; 77   :     return

  0003f	33 c0		 xor	 eax, eax
  00041	85 c0		 test	 eax, eax
  00043	75 64		 jne	 SHORT $LN4@add_signed
  00045	83 3c 24 00	 cmp	 DWORD PTR sop2$[rsp], 0
  00049	7e 0e		 jle	 SHORT $LN3@add_signed
  0004b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00050	2b 04 24	 sub	 eax, DWORD PTR sop2$[rsp]
  00053	39 44 24 04	 cmp	 DWORD PTR sop1$[rsp], eax
  00057	7f 50		 jg	 SHORT $LN4@add_signed
$LN3@add_signed:
  00059	83 3c 24 00	 cmp	 DWORD PTR sop2$[rsp], 0
  0005d	7d 0e		 jge	 SHORT $LN5@add_signed
  0005f	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  00064	2b 04 24	 sub	 eax, DWORD PTR sop2$[rsp]
  00067	39 44 24 04	 cmp	 DWORD PTR sop1$[rsp], eax
  0006b	7c 3c		 jl	 SHORT $LN4@add_signed
$LN5@add_signed:
  0006d	83 7c 24 08 00	 cmp	 DWORD PTR sres$[rsp], 0
  00072	7d 0a		 jge	 SHORT $LN8@add_signed
  00074	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0007c	eb 21		 jmp	 SHORT $LN9@add_signed
$LN8@add_signed:
  0007e	83 7c 24 08 00	 cmp	 DWORD PTR sres$[rsp], 0
  00083	7e 0a		 jle	 SHORT $LN6@add_signed
  00085	c7 44 24 0c 02
	00 00 00	 mov	 DWORD PTR tv74[rsp], 2
  0008d	eb 08		 jmp	 SHORT $LN7@add_signed
$LN6@add_signed:
  0008f	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN7@add_signed:
  00097	8b 44 24 0c	 mov	 eax, DWORD PTR tv74[rsp]
  0009b	89 44 24 10	 mov	 DWORD PTR tv75[rsp], eax
$LN9@add_signed:
  0009f	8b 44 24 10	 mov	 eax, DWORD PTR tv75[rsp]
  000a3	89 44 24 14	 mov	 DWORD PTR tv76[rsp], eax
  000a7	eb 08		 jmp	 SHORT $LN10@add_signed
$LN4@add_signed:
  000a9	c7 44 24 14 03
	00 00 00	 mov	 DWORD PTR tv76[rsp], 3
$LN10@add_signed:
  000b1	8b 44 24 14	 mov	 eax, DWORD PTR tv76[rsp]

; 78   :     (0
; 79   :         || (sop2 > 0 && sop1 > (INT_MAX - sop2))
; 80   :         || (sop2 < 0 && sop1 < (INT_MIN - sop2))
; 81   :     )
; 82   :     ? 3 : (sres < 0 ? 1 : (sres > 0 ? 2 : 0));
; 83   : }

  000b5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b9	c3		 ret	 0
add_signed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT sub_logical
_TEXT	SEGMENT
tv68 = 0
tv66 = 4
result$ = 32
op1$ = 40
op2$ = 48
sub_logical PROC					; COMDAT

; 55   : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 56   :     *result = op1 - op2;

  00012	8b 44 24 30	 mov	 eax, DWORD PTR op2$[rsp]
  00016	8b 4c 24 28	 mov	 ecx, DWORD PTR op1$[rsp]
  0001a	2b c8		 sub	 ecx, eax
  0001c	8b c1		 mov	 eax, ecx
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00023	89 01		 mov	 DWORD PTR [rcx], eax

; 57   :     return (*result == 0 ? 0 : 1) | (op1 < *result ? 0 : 2);

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0002a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0002d	75 0a		 jne	 SHORT $LN3@sub_logica
  0002f	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
  00037	eb 08		 jmp	 SHORT $LN4@sub_logica
$LN3@sub_logica:
  00039	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
$LN4@sub_logica:
  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00046	8b 00		 mov	 eax, DWORD PTR [rax]
  00048	39 44 24 28	 cmp	 DWORD PTR op1$[rsp], eax
  0004c	73 09		 jae	 SHORT $LN5@sub_logica
  0004e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
  00055	eb 07		 jmp	 SHORT $LN6@sub_logica
$LN5@sub_logica:
  00057	c7 04 24 02 00
	00 00		 mov	 DWORD PTR tv68[rsp], 2
$LN6@sub_logica:
  0005e	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]
  00061	8b 4c 24 04	 mov	 ecx, DWORD PTR tv66[rsp]
  00065	0b c8		 or	 ecx, eax
  00067	8b c1		 mov	 eax, ecx

; 58   : }

  00069	48 83 c4 18	 add	 rsp, 24
  0006d	c3		 ret	 0
sub_logical ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT add_logical
_TEXT	SEGMENT
tv68 = 0
tv66 = 4
result$ = 32
op1$ = 40
op2$ = 48
add_logical PROC					; COMDAT

; 45   : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 46   :     *result = op1 + op2;

  00012	8b 44 24 30	 mov	 eax, DWORD PTR op2$[rsp]
  00016	8b 4c 24 28	 mov	 ecx, DWORD PTR op1$[rsp]
  0001a	03 c8		 add	 ecx, eax
  0001c	8b c1		 mov	 eax, ecx
  0001e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00023	89 01		 mov	 DWORD PTR [rcx], eax

; 47   :     return (*result == 0 ? 0 : 1) | (op1 > *result ? 2 : 0);

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0002a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0002d	75 0a		 jne	 SHORT $LN3@add_logica
  0002f	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
  00037	eb 08		 jmp	 SHORT $LN4@add_logica
$LN3@add_logica:
  00039	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
$LN4@add_logica:
  00041	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  00046	8b 00		 mov	 eax, DWORD PTR [rax]
  00048	39 44 24 28	 cmp	 DWORD PTR op1$[rsp], eax
  0004c	76 09		 jbe	 SHORT $LN5@add_logica
  0004e	c7 04 24 02 00
	00 00		 mov	 DWORD PTR tv68[rsp], 2
  00055	eb 07		 jmp	 SHORT $LN6@add_logica
$LN5@add_logica:
  00057	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
$LN6@add_logica:
  0005e	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]
  00061	8b 4c 24 04	 mov	 ecx, DWORD PTR tv66[rsp]
  00065	0b c8		 or	 ecx, eax
  00067	8b c1		 mov	 eax, ecx

; 48   : }

  00069	48 83 c4 18	 add	 rsp, 24
  0006d	c3		 ret	 0
add_logical ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s370_or_2K_storage_key

; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );
; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s370_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_2K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_2K_storage_key PROC				; COMDAT

; 231  :   inline void  ARCH_DEP( or_2K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 2 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 02	 mov	 r8b, 2
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s370__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s370_or_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s370__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	0f b6 44 24 60	 movzx	 eax, BYTE PTR K$[rsp]
  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 57		 jne	 SHORT $LN5@s370__or_s
  00022	33 c0		 xor	 eax, eax
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 50		 je	 SHORT $LN5@s370__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0003d	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00042	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  00047	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00051	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00054	0b c8		 or	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0005d	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  0005f	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00064	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00069	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006c	0b c8		 or	 ecx, eax
  0006e	8b c1		 mov	 eax, ecx
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00075	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  00077	eb 2c		 jmp	 SHORT $LN6@s370__or_s
$LN5@s370__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  00079	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00083	e8 00 00 00 00	 call	 _get_storekey_ptr
  00088	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  0008d	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00097	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0009a	0b c8		 or	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a3	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_s:

; 202  :     }
; 203  : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
s370__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
END
