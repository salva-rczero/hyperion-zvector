; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	fetch_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	fetch_f3_noswap
PUBLIC	mpc_point_ipa
PUBLIC	mpc_point_puk
PUBLIC	mpc_point_pus
PUBLIC	mpc_display_description
PUBLIC	mpc_display_stuff
PUBLIC	mpc_display_th
PUBLIC	mpc_display_rrh
PUBLIC	mpc_display_ph
PUBLIC	mpc_display_rrh_and_puk
PUBLIC	mpc_display_rrh_and_pix
PUBLIC	mpc_display_rrh_and_ipa
PUBLIC	mpc_display_rrh_and_pkt
PUBLIC	mpc_display_rrh_and_pdu
PUBLIC	mpc_display_osa_iea
PUBLIC	mpc_display_osa_iear
PUBLIC	mpc_display_osa_th_etc
PUBLIC	mpc_display_ptp_th_etc
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isprint:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_f3_noswap DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$fetch_f3_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$mpc_point_ipa DD imagerel $LN6
	DD	imagerel $LN6+134
	DD	imagerel $unwind$mpc_point_ipa
$pdata$mpc_point_puk DD imagerel $LN6
	DD	imagerel $LN6+134
	DD	imagerel $unwind$mpc_point_puk
$pdata$mpc_point_pus DD imagerel $LN12
	DD	imagerel $LN12+262
	DD	imagerel $unwind$mpc_point_pus
$pdata$mpc_display_description DD imagerel $LN6
	DD	imagerel $LN6+286
	DD	imagerel $unwind$mpc_display_description
$pdata$mpc_display_stuff DD imagerel $LN22
	DD	imagerel $LN22+1040
	DD	imagerel $unwind$mpc_display_stuff
$pdata$mpc_display_th DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$mpc_display_th
$pdata$mpc_display_rrh DD imagerel $LN3
	DD	imagerel $LN3+93
	DD	imagerel $unwind$mpc_display_rrh
$pdata$mpc_display_ph DD imagerel $LN3
	DD	imagerel $LN3+61
	DD	imagerel $unwind$mpc_display_ph
$pdata$mpc_display_rrh_and_puk DD imagerel $LN8
	DD	imagerel $LN8+649
	DD	imagerel $unwind$mpc_display_rrh_and_puk
$pdata$mpc_display_rrh_and_pix DD imagerel $LN3
	DD	imagerel $LN3+267
	DD	imagerel $unwind$mpc_display_rrh_and_pix
$pdata$mpc_display_rrh_and_ipa DD imagerel $LN6
	DD	imagerel $LN6+400
	DD	imagerel $unwind$mpc_display_rrh_and_ipa
$pdata$mpc_display_rrh_and_pkt DD imagerel $LN13
	DD	imagerel $LN13+563
	DD	imagerel $unwind$mpc_display_rrh_and_pkt
$pdata$mpc_display_rrh_and_pdu DD imagerel $LN13
	DD	imagerel $LN13+563
	DD	imagerel $unwind$mpc_display_rrh_and_pdu
$pdata$mpc_display_osa_iea DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$mpc_display_osa_iea
$pdata$mpc_display_osa_iear DD imagerel $LN3
	DD	imagerel $LN3+65
	DD	imagerel $unwind$mpc_display_osa_iear
$pdata$mpc_display_osa_th_etc DD imagerel $LN11
	DD	imagerel $LN11+328
	DD	imagerel $unwind$mpc_display_osa_th_etc
$pdata$mpc_display_ptp_th_etc DD imagerel $LN12
	DD	imagerel $LN12+379
	DD	imagerel $unwind$mpc_display_ptp_th_etc
pdata	ENDS
_DATA	SEGMENT
$SG159552 DB	'D', 00H
	ORG $+6
$SG159553 DB	'HHC03983%s %1d:%04X %s: %s', 0aH, 00H
$SG159556 DB	'D', 00H
	ORG $+2
$SG159554 DB	'mpc_display_description', 00H
$SG159555 DB	'mpc.c', 00H
	ORG $+2
$SG159557 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG159558 DB	'mpc_display_description', 00H
$SG159559 DB	'mpc.c', 00H
	ORG $+2
$SG159588 DB	'+%4.4X%c ', 00H
	ORG $+2
$SG159591 DB	'%2.2X', 00H
	ORG $+2
$SG159594 DB	'  ', 00H
	ORG $+1
$SG159596 DB	' ', 00H
	ORG $+2
$SG159599 DB	'D', 00H
	ORG $+2
$SG159600 DB	'HHC03981%s %1d:%04X %s: %s: %s %s  %s', 0aH, 00H
	ORG $+1
$SG159601 DB	'mpc_display_stuff', 00H
	ORG $+2
$SG159602 DB	'mpc.c', 00H
	ORG $+2
$SG159603 DB	'D', 00H
	ORG $+2
$SG159604 DB	'HHC03982%s %s: %s %s  %s', 0aH, 00H
	ORG $+2
$SG159616 DB	'TH ', 00H
$SG159605 DB	'mpc_display_stuff', 00H
	ORG $+2
$SG159606 DB	'mpc.c', 00H
	ORG $+2
$SG159626 DB	'RRH', 00H
$SG159635 DB	'PH ', 00H
$SG159671 DB	'RRH', 00H
$SG159672 DB	'PH ', 00H
$SG159673 DB	'PUK', 00H
$SG159675 DB	'???', 00H
$SG159677 DB	'???', 00H
$SG159679 DB	'???', 00H
$SG159680 DB	'PUS', 00H
$SG159702 DB	'RRH', 00H
$SG159703 DB	'PH ', 00H
$SG159704 DB	'PIX', 00H
$SG159734 DB	'RRH', 00H
$SG159735 DB	'PH ', 00H
$SG159738 DB	'IPA', 00H
$SG159740 DB	'Cmd', 00H
$SG159778 DB	'RRH', 00H
$SG159779 DB	'PH ', 00H
$SG159784 DB	'Pkt', 00H
$SG159822 DB	'RRH', 00H
$SG159823 DB	'PH ', 00H
$SG159828 DB	'PDU', 00H
$SG159839 DB	'IEA', 00H
$SG159850 DB	'IEAR', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:mpc_display_stuff
	DD	026H
	DD	03f7H
voltbl	ENDS
xdata	SEGMENT
$unwind$mpc_point_ipa DD 011301H
	DD	08213H
$unwind$mpc_point_puk DD 011301H
	DD	08213H
$unwind$mpc_point_pus DD 011301H
	DD	08213H
$unwind$mpc_display_description DD 010e01H
	DD	0e20eH
$unwind$mpc_display_stuff DD 032e19H
	DD	028011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$mpc_display_th DD 011301H
	DD	08213H
$unwind$mpc_display_rrh DD 011301H
	DD	08213H
$unwind$mpc_display_ph DD 011301H
	DD	06213H
$unwind$mpc_display_rrh_and_puk DD 011801H
	DD	0e218H
$unwind$mpc_display_rrh_and_pix DD 011801H
	DD	0a218H
$unwind$mpc_display_rrh_and_ipa DD 011801H
	DD	0c218H
$unwind$mpc_display_rrh_and_pkt DD 011801H
	DD	0c218H
$unwind$mpc_display_rrh_and_pdu DD 011801H
	DD	0c218H
$unwind$mpc_display_osa_iea DD 011801H
	DD	06218H
$unwind$mpc_display_osa_iear DD 011801H
	DD	06218H
$unwind$mpc_display_osa_th_etc DD 011801H
	DD	0a218H
$unwind$mpc_display_ptp_th_etc DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_f3_noswap DD 030b01H
	DD	07007220bH
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
uNumRRH$ = 48
iForRRH$ = 52
uOffRRH$ = 56
pMPC_RRH$ = 64
pDEVBLK$ = 96
pMPC_TH$ = 104
bDir$ = 112
iLimit$ = 120
mpc_display_ptp_th_etc PROC

; 611  : {

$LN12:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 612  :     MPC_RRH*   pMPC_RRH;
; 613  :     int        iForRRH;
; 614  :     U32        uOffRRH;
; 615  :     U16        uNumRRH;
; 616  : 
; 617  :     /* Display MPC_TH. */
; 618  :     mpc_display_th( pDEVBLK, pMPC_TH, bDir );

  00018	44 0f b6 44 24
	70		 movzx	 r8d, BYTE PTR bDir$[rsp]
  0001e	48 8b 54 24 68	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  00023	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00028	e8 00 00 00 00	 call	 mpc_display_th

; 619  : 
; 620  :     /* Get the number of MPC_RRHs and the displacement from    */
; 621  :     /* the start of the MPC_TH to the first (or only) MPC_RRH. */
; 622  :     FETCH_HW( uNumRRH, pMPC_TH->numrrh );

  0002d	48 8b 44 24 68	 mov	 rax, QWORD PTR pMPC_TH$[rsp]
  00032	48 83 c0 12	 add	 rax, 18
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 fetch_hw_noswap
  0003e	0f b7 c8	 movzx	 ecx, ax
  00041	e8 00 00 00 00	 call	 _byteswap_ushort
  00046	66 89 44 24 30	 mov	 WORD PTR uNumRRH$[rsp], ax

; 623  :     FETCH_FW( uOffRRH, pMPC_TH->offrrh );

  0004b	48 8b 44 24 68	 mov	 rax, QWORD PTR pMPC_TH$[rsp]
  00050	48 83 c0 08	 add	 rax, 8
  00054	48 8b c8	 mov	 rcx, rax
  00057	e8 00 00 00 00	 call	 fetch_fw_noswap
  0005c	8b c8		 mov	 ecx, eax
  0005e	e8 00 00 00 00	 call	 _byteswap_ulong
  00063	89 44 24 38	 mov	 DWORD PTR uOffRRH$[rsp], eax

; 624  : 
; 625  :     /* Process each of the MPC_RRHs. */
; 626  :     for( iForRRH = 1; iForRRH <= uNumRRH; iForRRH++ )

  00067	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR iForRRH$[rsp], 1
  0006f	eb 0a		 jmp	 SHORT $LN4@mpc_displa
$LN2@mpc_displa:
  00071	8b 44 24 34	 mov	 eax, DWORD PTR iForRRH$[rsp]
  00075	ff c0		 inc	 eax
  00077	89 44 24 34	 mov	 DWORD PTR iForRRH$[rsp], eax
$LN4@mpc_displa:
  0007b	0f b7 44 24 30	 movzx	 eax, WORD PTR uNumRRH$[rsp]
  00080	39 44 24 34	 cmp	 DWORD PTR iForRRH$[rsp], eax
  00084	0f 8f ec 00 00
	00		 jg	 $LN3@mpc_displa

; 627  :     {
; 628  : 
; 629  :         /* Point to the first or subsequent MPC_RRH. */
; 630  :         pMPC_RRH = (MPC_RRH*)((BYTE*)pMPC_TH + uOffRRH);

  0008a	8b 44 24 38	 mov	 eax, DWORD PTR uOffRRH$[rsp]
  0008e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  00093	48 03 c8	 add	 rcx, rax
  00096	48 8b c1	 mov	 rax, rcx
  00099	48 89 44 24 40	 mov	 QWORD PTR pMPC_RRH$[rsp], rax

; 631  : 
; 632  :         /* Display the MPC_RRH etc. */
; 633  :         if( pMPC_RRH->proto == PROTOCOL_LAYER2 &&

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  000a3	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  000a7	83 f8 08	 cmp	 eax, 8
  000aa	75 34		 jne	 SHORT $LN5@mpc_displa
  000ac	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  000b1	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000b5	3d 81 00 00 00	 cmp	 eax, 129		; 00000081H
  000ba	75 24		 jne	 SHORT $LN5@mpc_displa

; 634  :             pMPC_RRH->type == RRH_TYPE_CM )
; 635  :         {
; 636  :             /* Display MPC_RRH and following packet data. */
; 637  :             mpc_display_rrh_and_pkt( pDEVBLK, pMPC_TH, pMPC_RRH, bDir, iLimit );

  000bc	8b 44 24 78	 mov	 eax, DWORD PTR iLimit$[rsp]
  000c0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000c4	44 0f b6 4c 24
	70		 movzx	 r9d, BYTE PTR bDir$[rsp]
  000ca	4c 8b 44 24 40	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  000cf	48 8b 54 24 68	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  000d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000d9	e8 00 00 00 00	 call	 mpc_display_rrh_and_pkt

; 638  :         }

  000de	eb 79		 jmp	 SHORT $LN6@mpc_displa
$LN5@mpc_displa:

; 639  :         else if( pMPC_RRH->proto == PROTOCOL_LAYER2 &&

  000e0	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  000e5	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  000e9	83 f8 08	 cmp	 eax, 8
  000ec	75 2c		 jne	 SHORT $LN7@mpc_displa
  000ee	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  000f3	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000f7	3d c1 00 00 00	 cmp	 eax, 193		; 000000c1H
  000fc	75 1c		 jne	 SHORT $LN7@mpc_displa

; 640  :                  pMPC_RRH->type == RRH_TYPE_IPA )
; 641  :         {
; 642  :             /* Display MPC_RRH and following MPC_PIX etc. */
; 643  :             mpc_display_rrh_and_pix( pDEVBLK, pMPC_TH, pMPC_RRH, bDir );

  000fe	44 0f b6 4c 24
	70		 movzx	 r9d, BYTE PTR bDir$[rsp]
  00104	4c 8b 44 24 40	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  00109	48 8b 54 24 68	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  0010e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00113	e8 00 00 00 00	 call	 mpc_display_rrh_and_pix

; 644  :         }

  00118	eb 3f		 jmp	 SHORT $LN8@mpc_displa
$LN7@mpc_displa:

; 645  :         else if( pMPC_RRH->proto == PROTOCOL_UNKNOWN )

  0011a	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  0011f	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00123	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  00126	75 1c		 jne	 SHORT $LN9@mpc_displa

; 646  :         {
; 647  :             /* Display MPC_RRH and following MPC_PUK etc. */
; 648  :             mpc_display_rrh_and_puk( pDEVBLK, pMPC_TH, pMPC_RRH, bDir );

  00128	44 0f b6 4c 24
	70		 movzx	 r9d, BYTE PTR bDir$[rsp]
  0012e	4c 8b 44 24 40	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  00133	48 8b 54 24 68	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  00138	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0013d	e8 00 00 00 00	 call	 mpc_display_rrh_and_puk

; 649  :         }

  00142	eb 15		 jmp	 SHORT $LN10@mpc_displa
$LN9@mpc_displa:

; 650  :         else
; 651  :         {
; 652  :             /* Display MPC_RRH */
; 653  :             mpc_display_rrh( pDEVBLK, pMPC_RRH, bDir );

  00144	44 0f b6 44 24
	70		 movzx	 r8d, BYTE PTR bDir$[rsp]
  0014a	48 8b 54 24 40	 mov	 rdx, QWORD PTR pMPC_RRH$[rsp]
  0014f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00154	e8 00 00 00 00	 call	 mpc_display_rrh
$LN10@mpc_displa:
$LN8@mpc_displa:
$LN6@mpc_displa:

; 654  :         }
; 655  : 
; 656  :         /* Get the displacement from the start of the MPC_TH to the */
; 657  :         /* next MPC_RRH. pMPC_RRH->offrrh will contain zero if this */
; 658  :         /* is the last MPC_RRH.                                     */
; 659  :         FETCH_FW( uOffRRH, pMPC_RRH->offrrh );

  00159	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  0015e	48 8b c8	 mov	 rcx, rax
  00161	e8 00 00 00 00	 call	 fetch_fw_noswap
  00166	8b c8		 mov	 ecx, eax
  00168	e8 00 00 00 00	 call	 _byteswap_ulong
  0016d	89 44 24 38	 mov	 DWORD PTR uOffRRH$[rsp], eax

; 660  : 
; 661  :     }

  00171	e9 fb fe ff ff	 jmp	 $LN2@mpc_displa
$LN3@mpc_displa:

; 662  : 
; 663  :     return;
; 664  : }   /* End function  mpc_display_ptp_th_etc() */

  00176	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0017a	c3		 ret	 0
mpc_display_ptp_th_etc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
uNumRRH$ = 48
iForRRH$ = 52
uOffRRH$ = 56
pMPC_RRH$ = 64
pDEVBLK$ = 96
pMPC_TH$ = 104
bDir$ = 112
iLimit$ = 120
mpc_display_osa_th_etc PROC

; 552  : {

$LN11:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 553  :     MPC_RRH*   pMPC_RRH;
; 554  :     int        iForRRH;
; 555  :     U32        uOffRRH;
; 556  :     U16        uNumRRH;
; 557  : 
; 558  :     /* Display MPC_TH. */
; 559  :     mpc_display_th( pDEVBLK, pMPC_TH, bDir );

  00018	44 0f b6 44 24
	70		 movzx	 r8d, BYTE PTR bDir$[rsp]
  0001e	48 8b 54 24 68	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  00023	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00028	e8 00 00 00 00	 call	 mpc_display_th

; 560  : 
; 561  :     /* Get the number of MPC_RRHs and the displacement from    */
; 562  :     /* the start of the MPC_TH to the first (or only) MPC_RRH. */
; 563  :     FETCH_HW( uNumRRH, pMPC_TH->numrrh );

  0002d	48 8b 44 24 68	 mov	 rax, QWORD PTR pMPC_TH$[rsp]
  00032	48 83 c0 12	 add	 rax, 18
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 fetch_hw_noswap
  0003e	0f b7 c8	 movzx	 ecx, ax
  00041	e8 00 00 00 00	 call	 _byteswap_ushort
  00046	66 89 44 24 30	 mov	 WORD PTR uNumRRH$[rsp], ax

; 564  :     FETCH_FW( uOffRRH, pMPC_TH->offrrh );

  0004b	48 8b 44 24 68	 mov	 rax, QWORD PTR pMPC_TH$[rsp]
  00050	48 83 c0 08	 add	 rax, 8
  00054	48 8b c8	 mov	 rcx, rax
  00057	e8 00 00 00 00	 call	 fetch_fw_noswap
  0005c	8b c8		 mov	 ecx, eax
  0005e	e8 00 00 00 00	 call	 _byteswap_ulong
  00063	89 44 24 38	 mov	 DWORD PTR uOffRRH$[rsp], eax

; 565  : 
; 566  :     /* Process each of the MPC_RRHs. */
; 567  :     for( iForRRH = 1; iForRRH <= uNumRRH; iForRRH++ )

  00067	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR iForRRH$[rsp], 1
  0006f	eb 0a		 jmp	 SHORT $LN4@mpc_displa
$LN2@mpc_displa:
  00071	8b 44 24 34	 mov	 eax, DWORD PTR iForRRH$[rsp]
  00075	ff c0		 inc	 eax
  00077	89 44 24 34	 mov	 DWORD PTR iForRRH$[rsp], eax
$LN4@mpc_displa:
  0007b	0f b7 44 24 30	 movzx	 eax, WORD PTR uNumRRH$[rsp]
  00080	39 44 24 34	 cmp	 DWORD PTR iForRRH$[rsp], eax
  00084	0f 8f b9 00 00
	00		 jg	 $LN3@mpc_displa

; 568  :     {
; 569  : 
; 570  :         /* Point to the first or subsequent MPC_RRH. */
; 571  :         pMPC_RRH = (MPC_RRH*)((BYTE*)pMPC_TH + uOffRRH);

  0008a	8b 44 24 38	 mov	 eax, DWORD PTR uOffRRH$[rsp]
  0008e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  00093	48 03 c8	 add	 rcx, rax
  00096	48 8b c1	 mov	 rax, rcx
  00099	48 89 44 24 40	 mov	 QWORD PTR pMPC_RRH$[rsp], rax

; 572  : 
; 573  :         /* Display the MPC_RRH etc. */
; 574  :         if( pMPC_RRH->type == RRH_TYPE_CM ||

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  000a3	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000a7	3d 81 00 00 00	 cmp	 eax, 129		; 00000081H
  000ac	74 0e		 je	 SHORT $LN7@mpc_displa
  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  000b3	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000b7	83 f8 41	 cmp	 eax, 65			; 00000041H
  000ba	75 1c		 jne	 SHORT $LN5@mpc_displa
$LN7@mpc_displa:

; 575  :             pMPC_RRH->type == RRH_TYPE_ULP )
; 576  :         {
; 577  : 
; 578  :             /* Display MPC_RRH and following MPC_PUK etc. */
; 579  :             mpc_display_rrh_and_puk( pDEVBLK, pMPC_TH, pMPC_RRH, bDir );

  000bc	44 0f b6 4c 24
	70		 movzx	 r9d, BYTE PTR bDir$[rsp]
  000c2	4c 8b 44 24 40	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  000c7	48 8b 54 24 68	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  000cc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000d1	e8 00 00 00 00	 call	 mpc_display_rrh_and_puk

; 580  : 
; 581  :         }

  000d6	eb 4e		 jmp	 SHORT $LN6@mpc_displa
$LN5@mpc_displa:

; 582  :         else if( pMPC_RRH->type == RRH_TYPE_IPA )

  000d8	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  000dd	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000e1	3d c1 00 00 00	 cmp	 eax, 193		; 000000c1H
  000e6	75 1c		 jne	 SHORT $LN8@mpc_displa

; 583  :         {
; 584  : 
; 585  :             /* Display MPC_RRH and following MPC_IPA etc. */
; 586  :             mpc_display_rrh_and_ipa( pDEVBLK, pMPC_TH, pMPC_RRH, bDir );

  000e8	44 0f b6 4c 24
	70		 movzx	 r9d, BYTE PTR bDir$[rsp]
  000ee	4c 8b 44 24 40	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  000f3	48 8b 54 24 68	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  000f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000fd	e8 00 00 00 00	 call	 mpc_display_rrh_and_ipa

; 587  : 
; 588  :         }

  00102	eb 22		 jmp	 SHORT $LN9@mpc_displa
$LN8@mpc_displa:

; 589  :         else
; 590  :         {
; 591  : 
; 592  :             /* Display MPC_RRH and following PDU. */
; 593  :             mpc_display_rrh_and_pdu( pDEVBLK, pMPC_TH, pMPC_RRH, bDir, iLimit );

  00104	8b 44 24 78	 mov	 eax, DWORD PTR iLimit$[rsp]
  00108	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0010c	44 0f b6 4c 24
	70		 movzx	 r9d, BYTE PTR bDir$[rsp]
  00112	4c 8b 44 24 40	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  00117	48 8b 54 24 68	 mov	 rdx, QWORD PTR pMPC_TH$[rsp]
  0011c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00121	e8 00 00 00 00	 call	 mpc_display_rrh_and_pdu
$LN9@mpc_displa:
$LN6@mpc_displa:

; 594  : 
; 595  :         }
; 596  : 
; 597  :         /* Get the displacement from the start of the MPC_TH to the */
; 598  :         /* next MPC_RRH. pMPC_RRH->offrrh will contain zero if this */
; 599  :         /* is the last MPC_RRH.                                     */
; 600  :         FETCH_FW( uOffRRH, pMPC_RRH->offrrh );

  00126	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  0012b	48 8b c8	 mov	 rcx, rax
  0012e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00133	8b c8		 mov	 ecx, eax
  00135	e8 00 00 00 00	 call	 _byteswap_ulong
  0013a	89 44 24 38	 mov	 DWORD PTR uOffRRH$[rsp], eax

; 601  : 
; 602  :     }

  0013e	e9 2e ff ff ff	 jmp	 $LN2@mpc_displa
$LN3@mpc_displa:

; 603  : 
; 604  :     return;
; 605  : }   /* End function  mpc_display_osa_th_etc() */

  00143	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00147	c3		 ret	 0
mpc_display_osa_th_etc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
pDEVBLK$ = 64
pMPC_IEAR$ = 72
bDir$ = 80
iSize$ = 88
mpc_display_osa_iear PROC

; 540  : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 541  : 
; 542  :     /* Display MPC_IEAR. */
; 543  :     mpc_display_stuff( pDEVBLK, "IEAR", (BYTE*)pMPC_IEAR, iSize, bDir );

  00018	0f b6 44 24 50	 movzx	 eax, BYTE PTR bDir$[rsp]
  0001d	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00021	44 8b 4c 24 58	 mov	 r9d, DWORD PTR iSize$[rsp]
  00026	4c 8b 44 24 48	 mov	 r8, QWORD PTR pMPC_IEAR$[rsp]
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159850
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00037	e8 00 00 00 00	 call	 mpc_display_stuff

; 544  : 
; 545  :     return;
; 546  : }   /* End function  mpc_display_osa_iear() */

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
mpc_display_osa_iear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
pDEVBLK$ = 64
pMPC_IEA$ = 72
bDir$ = 80
iSize$ = 88
mpc_display_osa_iea PROC

; 528  : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 529  : 
; 530  :     /* Display MPC_IEA. */
; 531  :     mpc_display_stuff( pDEVBLK, "IEA", (BYTE*)pMPC_IEA, iSize, bDir );

  00018	0f b6 44 24 50	 movzx	 eax, BYTE PTR bDir$[rsp]
  0001d	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00021	44 8b 4c 24 58	 mov	 r9d, DWORD PTR iSize$[rsp]
  00026	4c 8b 44 24 48	 mov	 r8, QWORD PTR pMPC_IEA$[rsp]
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159839
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00037	e8 00 00 00 00	 call	 mpc_display_stuff

; 532  : 
; 533  :     return;
; 534  : }   /* End function  mpc_display_osa_iea() */

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
mpc_display_osa_iea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
uOffPH$ = 48
uNumPH$ = 52
iForPH$ = 56
iDone$ = 60
uLenData$ = 64
uOffData$ = 68
pMPC_PH$ = 72
pData$ = 80
pDEVBLK$ = 112
pMPC_TH$ = 120
pMPC_RRH$ = 128
bDir$ = 136
iLimit$ = 144
mpc_display_rrh_and_pdu PROC

; 472  : {

$LN13:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 473  :     MPC_PH*    pMPC_PH;
; 474  :     U16        uNumPH;
; 475  :     U16        uOffPH;
; 476  :     int        iForPH;
; 477  :     int        iDone;
; 478  :     U32        uLenData;
; 479  :     U32        uOffData;
; 480  :     BYTE*      pData;
; 481  : 
; 482  :     /* Display the MPC_RRH.*/
; 483  :     FETCH_HW( uOffPH, pMPC_RRH->offph );

  00018	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  00020	48 83 c0 10	 add	 rax, 16
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 fetch_hw_noswap
  0002c	0f b7 c8	 movzx	 ecx, ax
  0002f	e8 00 00 00 00	 call	 _byteswap_ushort
  00034	66 89 44 24 30	 mov	 WORD PTR uOffPH$[rsp], ax

; 484  :     mpc_display_stuff( pDEVBLK, "RRH", (BYTE*)pMPC_RRH, uOffPH, bDir );

  00039	0f b7 44 24 30	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0003e	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR bDir$[rsp]
  00046	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  0004a	44 8b c8	 mov	 r9d, eax
  0004d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159822
  0005c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00061	e8 00 00 00 00	 call	 mpc_display_stuff

; 485  : 
; 486  :     /* Display the MPC_PH(s). */
; 487  :     FETCH_HW( uNumPH, pMPC_RRH->numph );

  00066	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  0006e	48 83 c0 06	 add	 rax, 6
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 fetch_hw_noswap
  0007a	0f b7 c8	 movzx	 ecx, ax
  0007d	e8 00 00 00 00	 call	 _byteswap_ushort
  00082	66 89 44 24 34	 mov	 WORD PTR uNumPH$[rsp], ax

; 488  :     pMPC_PH = (MPC_PH*)((BYTE*)pMPC_RRH + uOffPH);

  00087	0f b7 44 24 30	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0008c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  00094	48 03 c8	 add	 rcx, rax
  00097	48 8b c1	 mov	 rax, rcx
  0009a	48 89 44 24 48	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 489  :     for( iForPH = 1; iForPH <= uNumPH; iForPH++ )

  0009f	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR iForPH$[rsp], 1
  000a7	eb 0a		 jmp	 SHORT $LN4@mpc_displa
$LN2@mpc_displa:
  000a9	8b 44 24 38	 mov	 eax, DWORD PTR iForPH$[rsp]
  000ad	ff c0		 inc	 eax
  000af	89 44 24 38	 mov	 DWORD PTR iForPH$[rsp], eax
$LN4@mpc_displa:
  000b3	0f b7 44 24 34	 movzx	 eax, WORD PTR uNumPH$[rsp]
  000b8	39 44 24 38	 cmp	 DWORD PTR iForPH$[rsp], eax
  000bc	7f 38		 jg	 SHORT $LN3@mpc_displa

; 490  :     {
; 491  :         mpc_display_stuff( pDEVBLK, "PH ", (BYTE*)pMPC_PH, SIZE_PH, bDir );

  000be	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bDir$[rsp]
  000c6	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  000ca	41 b9 08 00 00
	00		 mov	 r9d, 8
  000d0	4c 8b 44 24 48	 mov	 r8, QWORD PTR pMPC_PH$[rsp]
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159823
  000dc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000e1	e8 00 00 00 00	 call	 mpc_display_stuff

; 492  :         pMPC_PH = (MPC_PH*)((BYTE*)pMPC_PH + SIZE_PH);

  000e6	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  000eb	48 83 c0 08	 add	 rax, 8
  000ef	48 89 44 24 48	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 493  :     }

  000f4	eb b3		 jmp	 SHORT $LN2@mpc_displa
$LN3@mpc_displa:

; 494  : 
; 495  :     /* Display the data referenced by the MPC_PH(s).              */
; 496  :     /* if limit is negative or a silly number, don't display the  */
; 497  :     /* data. If limit is zero, display all of the data, otherwise */
; 498  :     /* limit the length of the data displayed.                    */
; 499  :     iDone = 0;

  000f6	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR iDone$[rsp], 0

; 500  :     if( iLimit >= 0 && iLimit <= 65535 )

  000fe	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR iLimit$[rsp], 0
  00106	0f 8c 22 01 00
	00		 jl	 $LN8@mpc_displa
  0010c	81 bc 24 90 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR iLimit$[rsp], 65535 ; 0000ffffH
  00117	0f 8f 11 01 00
	00		 jg	 $LN8@mpc_displa

; 501  :     {
; 502  :         pMPC_PH = (MPC_PH*)((BYTE*)pMPC_RRH + uOffPH);

  0011d	0f b7 44 24 30	 movzx	 eax, WORD PTR uOffPH$[rsp]
  00122	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  0012a	48 03 c8	 add	 rcx, rax
  0012d	48 8b c1	 mov	 rax, rcx
  00130	48 89 44 24 48	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 503  :         for( iForPH = 1; iForPH <= uNumPH; iForPH++ )

  00135	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR iForPH$[rsp], 1
  0013d	eb 0a		 jmp	 SHORT $LN7@mpc_displa
$LN5@mpc_displa:
  0013f	8b 44 24 38	 mov	 eax, DWORD PTR iForPH$[rsp]
  00143	ff c0		 inc	 eax
  00145	89 44 24 38	 mov	 DWORD PTR iForPH$[rsp], eax
$LN7@mpc_displa:
  00149	0f b7 44 24 34	 movzx	 eax, WORD PTR uNumPH$[rsp]
  0014e	39 44 24 38	 cmp	 DWORD PTR iForPH$[rsp], eax
  00152	0f 8f d6 00 00
	00		 jg	 $LN6@mpc_displa

; 504  :         {
; 505  :             FETCH_F3( uLenData, pMPC_PH->lendata );

  00158	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  0015d	48 ff c0	 inc	 rax
  00160	48 8b c8	 mov	 rcx, rax
  00163	e8 00 00 00 00	 call	 fetch_f3_noswap
  00168	8b c8		 mov	 ecx, eax
  0016a	e8 00 00 00 00	 call	 _byteswap_ulong
  0016f	89 44 24 40	 mov	 DWORD PTR uLenData$[rsp], eax

; 506  :             FETCH_FW( uOffData, pMPC_PH->offdata );

  00173	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  00178	48 83 c0 04	 add	 rax, 4
  0017c	48 8b c8	 mov	 rcx, rax
  0017f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00184	8b c8		 mov	 ecx, eax
  00186	e8 00 00 00 00	 call	 _byteswap_ulong
  0018b	89 44 24 44	 mov	 DWORD PTR uOffData$[rsp], eax

; 507  :             pData = (BYTE*)pMPC_TH + uOffData;

  0018f	8b 44 24 44	 mov	 eax, DWORD PTR uOffData$[rsp]
  00193	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  00198	48 03 c8	 add	 rcx, rax
  0019b	48 8b c1	 mov	 rax, rcx
  0019e	48 89 44 24 50	 mov	 QWORD PTR pData$[rsp], rax

; 508  :             if( iLimit > 0 )

  001a3	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR iLimit$[rsp], 0
  001ab	7e 47		 jle	 SHORT $LN9@mpc_displa

; 509  :             {
; 510  :                 if( iDone >= iLimit )

  001ad	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR iLimit$[rsp]
  001b4	39 44 24 3c	 cmp	 DWORD PTR iDone$[rsp], eax
  001b8	7c 02		 jl	 SHORT $LN10@mpc_displa

; 511  :                     break;

  001ba	eb 72		 jmp	 SHORT $LN6@mpc_displa
$LN10@mpc_displa:

; 512  :                 if( (int)uLenData > ( iLimit - iDone ) )

  001bc	8b 44 24 3c	 mov	 eax, DWORD PTR iDone$[rsp]
  001c0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR iLimit$[rsp]
  001c7	2b c8		 sub	 ecx, eax
  001c9	8b c1		 mov	 eax, ecx
  001cb	39 44 24 40	 cmp	 DWORD PTR uLenData$[rsp], eax
  001cf	7e 13		 jle	 SHORT $LN11@mpc_displa

; 513  :                     uLenData = ( iLimit - iDone );

  001d1	8b 44 24 3c	 mov	 eax, DWORD PTR iDone$[rsp]
  001d5	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR iLimit$[rsp]
  001dc	2b c8		 sub	 ecx, eax
  001de	8b c1		 mov	 eax, ecx
  001e0	89 44 24 40	 mov	 DWORD PTR uLenData$[rsp], eax
$LN11@mpc_displa:

; 514  :                 iDone += uLenData;

  001e4	8b 44 24 40	 mov	 eax, DWORD PTR uLenData$[rsp]
  001e8	8b 4c 24 3c	 mov	 ecx, DWORD PTR iDone$[rsp]
  001ec	03 c8		 add	 ecx, eax
  001ee	8b c1		 mov	 eax, ecx
  001f0	89 44 24 3c	 mov	 DWORD PTR iDone$[rsp], eax
$LN9@mpc_displa:

; 515  :             }
; 516  :             mpc_display_stuff( pDEVBLK, "PDU", pData, uLenData, bDir );

  001f4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bDir$[rsp]
  001fc	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00200	44 8b 4c 24 40	 mov	 r9d, DWORD PTR uLenData$[rsp]
  00205	4c 8b 44 24 50	 mov	 r8, QWORD PTR pData$[rsp]
  0020a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159828
  00211	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00216	e8 00 00 00 00	 call	 mpc_display_stuff

; 517  :             pMPC_PH = (MPC_PH*)((BYTE*)pMPC_PH + SIZE_PH);

  0021b	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  00220	48 83 c0 08	 add	 rax, 8
  00224	48 89 44 24 48	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 518  :         }

  00229	e9 11 ff ff ff	 jmp	 $LN5@mpc_displa
$LN6@mpc_displa:
$LN8@mpc_displa:

; 519  :     }
; 520  : 
; 521  :     return;
; 522  : }   /* End function  mpc_display_rrh_and_pdu() */

  0022e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00232	c3		 ret	 0
mpc_display_rrh_and_pdu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
uOffPH$ = 48
uNumPH$ = 52
iForPH$ = 56
iDone$ = 60
uLenData$ = 64
uOffData$ = 68
pMPC_PH$ = 72
pData$ = 80
pDEVBLK$ = 112
pMPC_TH$ = 120
pMPC_RRH$ = 128
bDir$ = 136
iLimit$ = 144
mpc_display_rrh_and_pkt PROC

; 416  : {

$LN13:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 417  :     MPC_PH*    pMPC_PH;
; 418  :     U16        uNumPH;
; 419  :     U16        uOffPH;
; 420  :     int        iForPH;
; 421  :     int        iDone;
; 422  :     U32        uLenData;
; 423  :     U32        uOffData;
; 424  :     BYTE*      pData;
; 425  : 
; 426  :     /* Display the MPC_RRH.*/
; 427  :     FETCH_HW( uOffPH, pMPC_RRH->offph );

  00018	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  00020	48 83 c0 10	 add	 rax, 16
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 fetch_hw_noswap
  0002c	0f b7 c8	 movzx	 ecx, ax
  0002f	e8 00 00 00 00	 call	 _byteswap_ushort
  00034	66 89 44 24 30	 mov	 WORD PTR uOffPH$[rsp], ax

; 428  :     mpc_display_stuff( pDEVBLK, "RRH", (BYTE*)pMPC_RRH, uOffPH, bDir );

  00039	0f b7 44 24 30	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0003e	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR bDir$[rsp]
  00046	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  0004a	44 8b c8	 mov	 r9d, eax
  0004d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159778
  0005c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00061	e8 00 00 00 00	 call	 mpc_display_stuff

; 429  : 
; 430  :     /* Display the MPC_PH(s). */
; 431  :     FETCH_HW( uNumPH, pMPC_RRH->numph );

  00066	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  0006e	48 83 c0 06	 add	 rax, 6
  00072	48 8b c8	 mov	 rcx, rax
  00075	e8 00 00 00 00	 call	 fetch_hw_noswap
  0007a	0f b7 c8	 movzx	 ecx, ax
  0007d	e8 00 00 00 00	 call	 _byteswap_ushort
  00082	66 89 44 24 34	 mov	 WORD PTR uNumPH$[rsp], ax

; 432  :     pMPC_PH = (MPC_PH*)((BYTE*)pMPC_RRH + uOffPH);

  00087	0f b7 44 24 30	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0008c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  00094	48 03 c8	 add	 rcx, rax
  00097	48 8b c1	 mov	 rax, rcx
  0009a	48 89 44 24 48	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 433  :     for( iForPH = 1; iForPH <= uNumPH; iForPH++ )

  0009f	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR iForPH$[rsp], 1
  000a7	eb 0a		 jmp	 SHORT $LN4@mpc_displa
$LN2@mpc_displa:
  000a9	8b 44 24 38	 mov	 eax, DWORD PTR iForPH$[rsp]
  000ad	ff c0		 inc	 eax
  000af	89 44 24 38	 mov	 DWORD PTR iForPH$[rsp], eax
$LN4@mpc_displa:
  000b3	0f b7 44 24 34	 movzx	 eax, WORD PTR uNumPH$[rsp]
  000b8	39 44 24 38	 cmp	 DWORD PTR iForPH$[rsp], eax
  000bc	7f 38		 jg	 SHORT $LN3@mpc_displa

; 434  :     {
; 435  :         mpc_display_stuff( pDEVBLK, "PH ", (BYTE*)pMPC_PH, SIZE_PH, bDir );

  000be	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bDir$[rsp]
  000c6	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  000ca	41 b9 08 00 00
	00		 mov	 r9d, 8
  000d0	4c 8b 44 24 48	 mov	 r8, QWORD PTR pMPC_PH$[rsp]
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159779
  000dc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000e1	e8 00 00 00 00	 call	 mpc_display_stuff

; 436  :         pMPC_PH = (MPC_PH*)((BYTE*)pMPC_PH + SIZE_PH);

  000e6	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  000eb	48 83 c0 08	 add	 rax, 8
  000ef	48 89 44 24 48	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 437  :     }

  000f4	eb b3		 jmp	 SHORT $LN2@mpc_displa
$LN3@mpc_displa:

; 438  : 
; 439  :     /* Display the data referenced by the MPC_PH(s).              */
; 440  :     /* if limit is negative or a silly number, don't display the  */
; 441  :     /* data. If limit is zero, display all of the data, otherwise */
; 442  :     /* limit the length of the data displayed.                    */
; 443  :     iDone = 0;

  000f6	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR iDone$[rsp], 0

; 444  :     if( iLimit >= 0 && iLimit <= 65535 )

  000fe	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR iLimit$[rsp], 0
  00106	0f 8c 22 01 00
	00		 jl	 $LN8@mpc_displa
  0010c	81 bc 24 90 00
	00 00 ff ff 00
	00		 cmp	 DWORD PTR iLimit$[rsp], 65535 ; 0000ffffH
  00117	0f 8f 11 01 00
	00		 jg	 $LN8@mpc_displa

; 445  :     {
; 446  :         pMPC_PH = (MPC_PH*)((BYTE*)pMPC_RRH + uOffPH);

  0011d	0f b7 44 24 30	 movzx	 eax, WORD PTR uOffPH$[rsp]
  00122	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  0012a	48 03 c8	 add	 rcx, rax
  0012d	48 8b c1	 mov	 rax, rcx
  00130	48 89 44 24 48	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 447  :         for( iForPH = 1; iForPH <= uNumPH; iForPH++ )

  00135	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR iForPH$[rsp], 1
  0013d	eb 0a		 jmp	 SHORT $LN7@mpc_displa
$LN5@mpc_displa:
  0013f	8b 44 24 38	 mov	 eax, DWORD PTR iForPH$[rsp]
  00143	ff c0		 inc	 eax
  00145	89 44 24 38	 mov	 DWORD PTR iForPH$[rsp], eax
$LN7@mpc_displa:
  00149	0f b7 44 24 34	 movzx	 eax, WORD PTR uNumPH$[rsp]
  0014e	39 44 24 38	 cmp	 DWORD PTR iForPH$[rsp], eax
  00152	0f 8f d6 00 00
	00		 jg	 $LN6@mpc_displa

; 448  :         {
; 449  :             FETCH_F3( uLenData, pMPC_PH->lendata );

  00158	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  0015d	48 ff c0	 inc	 rax
  00160	48 8b c8	 mov	 rcx, rax
  00163	e8 00 00 00 00	 call	 fetch_f3_noswap
  00168	8b c8		 mov	 ecx, eax
  0016a	e8 00 00 00 00	 call	 _byteswap_ulong
  0016f	89 44 24 40	 mov	 DWORD PTR uLenData$[rsp], eax

; 450  :             FETCH_FW( uOffData, pMPC_PH->offdata );

  00173	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  00178	48 83 c0 04	 add	 rax, 4
  0017c	48 8b c8	 mov	 rcx, rax
  0017f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00184	8b c8		 mov	 ecx, eax
  00186	e8 00 00 00 00	 call	 _byteswap_ulong
  0018b	89 44 24 44	 mov	 DWORD PTR uOffData$[rsp], eax

; 451  :             pData = (BYTE*)pMPC_TH + uOffData;

  0018f	8b 44 24 44	 mov	 eax, DWORD PTR uOffData$[rsp]
  00193	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  00198	48 03 c8	 add	 rcx, rax
  0019b	48 8b c1	 mov	 rax, rcx
  0019e	48 89 44 24 50	 mov	 QWORD PTR pData$[rsp], rax

; 452  :             if( iLimit > 0 )

  001a3	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR iLimit$[rsp], 0
  001ab	7e 47		 jle	 SHORT $LN9@mpc_displa

; 453  :             {
; 454  :                 if( iDone >= iLimit )

  001ad	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR iLimit$[rsp]
  001b4	39 44 24 3c	 cmp	 DWORD PTR iDone$[rsp], eax
  001b8	7c 02		 jl	 SHORT $LN10@mpc_displa

; 455  :                     break;

  001ba	eb 72		 jmp	 SHORT $LN6@mpc_displa
$LN10@mpc_displa:

; 456  :                 if( (int)uLenData > ( iLimit - iDone ) )

  001bc	8b 44 24 3c	 mov	 eax, DWORD PTR iDone$[rsp]
  001c0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR iLimit$[rsp]
  001c7	2b c8		 sub	 ecx, eax
  001c9	8b c1		 mov	 eax, ecx
  001cb	39 44 24 40	 cmp	 DWORD PTR uLenData$[rsp], eax
  001cf	7e 13		 jle	 SHORT $LN11@mpc_displa

; 457  :                     uLenData = ( iLimit - iDone );

  001d1	8b 44 24 3c	 mov	 eax, DWORD PTR iDone$[rsp]
  001d5	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR iLimit$[rsp]
  001dc	2b c8		 sub	 ecx, eax
  001de	8b c1		 mov	 eax, ecx
  001e0	89 44 24 40	 mov	 DWORD PTR uLenData$[rsp], eax
$LN11@mpc_displa:

; 458  :                 iDone += uLenData;

  001e4	8b 44 24 40	 mov	 eax, DWORD PTR uLenData$[rsp]
  001e8	8b 4c 24 3c	 mov	 ecx, DWORD PTR iDone$[rsp]
  001ec	03 c8		 add	 ecx, eax
  001ee	8b c1		 mov	 eax, ecx
  001f0	89 44 24 3c	 mov	 DWORD PTR iDone$[rsp], eax
$LN9@mpc_displa:

; 459  :             }
; 460  :             mpc_display_stuff( pDEVBLK, "Pkt", pData, uLenData, bDir );

  001f4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bDir$[rsp]
  001fc	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00200	44 8b 4c 24 40	 mov	 r9d, DWORD PTR uLenData$[rsp]
  00205	4c 8b 44 24 50	 mov	 r8, QWORD PTR pData$[rsp]
  0020a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159784
  00211	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00216	e8 00 00 00 00	 call	 mpc_display_stuff

; 461  :             pMPC_PH = (MPC_PH*)((BYTE*)pMPC_PH + SIZE_PH);

  0021b	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  00220	48 83 c0 08	 add	 rax, 8
  00224	48 89 44 24 48	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 462  :         }

  00229	e9 11 ff ff ff	 jmp	 $LN5@mpc_displa
$LN6@mpc_displa:
$LN8@mpc_displa:

; 463  :     }
; 464  : 
; 465  :     return;
; 466  : }   /* End function  mpc_display_rrh_and_pkt() */

  0022e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00232	c3		 ret	 0
mpc_display_rrh_and_pkt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
uOffPH$ = 48
uLenData$ = 52
iLenIPA$ = 56
iLenCmd$ = 60
uOffData$ = 64
pMPC_PH$ = 72
pMPC_IPA$ = 80
pMPC_IPA_CMD$ = 88
pDEVBLK$ = 112
pMPC_TH$ = 120
pMPC_RRH$ = 128
bDir$ = 136
mpc_display_rrh_and_ipa PROC

; 370  : {

$LN6:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 371  :     MPC_PH*    pMPC_PH;
; 372  :     MPC_IPA*   pMPC_IPA;
; 373  :     BYTE*      pMPC_IPA_CMD;
; 374  :     U32        uOffData;
; 375  :     U32        uLenData;
; 376  :     U16        uOffPH;
; 377  :     int        iLenIPA;
; 378  :     int        iLenCmd;
; 379  : 
; 380  :     // Display the MPC_RRH.
; 381  :     FETCH_HW( uOffPH, pMPC_RRH->offph );

  00018	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  00020	48 83 c0 10	 add	 rax, 16
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 fetch_hw_noswap
  0002c	0f b7 c8	 movzx	 ecx, ax
  0002f	e8 00 00 00 00	 call	 _byteswap_ushort
  00034	66 89 44 24 30	 mov	 WORD PTR uOffPH$[rsp], ax

; 382  :     mpc_display_stuff( pDEVBLK, "RRH", (BYTE*)pMPC_RRH, uOffPH, bDir );

  00039	0f b7 44 24 30	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0003e	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR bDir$[rsp]
  00046	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  0004a	44 8b c8	 mov	 r9d, eax
  0004d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159734
  0005c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00061	e8 00 00 00 00	 call	 mpc_display_stuff

; 383  : 
; 384  :     // Point to and display the MPC_PH.
; 385  :     pMPC_PH = (MPC_PH*)((BYTE*)pMPC_RRH + uOffPH);

  00066	0f b7 44 24 30	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0006b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 48	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 386  :     mpc_display_stuff( pDEVBLK, "PH ", (BYTE*)pMPC_PH, SIZE_PH, bDir );

  0007e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bDir$[rsp]
  00086	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  0008a	41 b9 08 00 00
	00		 mov	 r9d, 8
  00090	4c 8b 44 24 48	 mov	 r8, QWORD PTR pMPC_PH$[rsp]
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159735
  0009c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000a1	e8 00 00 00 00	 call	 mpc_display_stuff

; 387  : 
; 388  :     /* Point to and display the MPC_IPA (and commands, if any). */
; 389  :     FETCH_F3( uLenData, pMPC_PH->lendata );

  000a6	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  000ab	48 ff c0	 inc	 rax
  000ae	48 8b c8	 mov	 rcx, rax
  000b1	e8 00 00 00 00	 call	 fetch_f3_noswap
  000b6	8b c8		 mov	 ecx, eax
  000b8	e8 00 00 00 00	 call	 _byteswap_ulong
  000bd	89 44 24 34	 mov	 DWORD PTR uLenData$[rsp], eax

; 390  :     FETCH_FW( uOffData, pMPC_PH->offdata );

  000c1	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  000c6	48 83 c0 04	 add	 rax, 4
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 fetch_fw_noswap
  000d2	8b c8		 mov	 ecx, eax
  000d4	e8 00 00 00 00	 call	 _byteswap_ulong
  000d9	89 44 24 40	 mov	 DWORD PTR uOffData$[rsp], eax

; 391  :     if( uLenData > sizeof(MPC_IPA) )

  000dd	8b 44 24 34	 mov	 eax, DWORD PTR uLenData$[rsp]
  000e1	48 83 f8 14	 cmp	 rax, 20
  000e5	76 16		 jbe	 SHORT $LN2@mpc_displa

; 392  :     {
; 393  :         iLenIPA = sizeof(MPC_IPA);

  000e7	c7 44 24 38 14
	00 00 00	 mov	 DWORD PTR iLenIPA$[rsp], 20

; 394  :         iLenCmd = uLenData - sizeof(MPC_IPA);

  000ef	8b 44 24 34	 mov	 eax, DWORD PTR uLenData$[rsp]
  000f3	48 83 e8 14	 sub	 rax, 20
  000f7	89 44 24 3c	 mov	 DWORD PTR iLenCmd$[rsp], eax

; 395  :     }

  000fb	eb 10		 jmp	 SHORT $LN3@mpc_displa
$LN2@mpc_displa:

; 396  :     else
; 397  :     {
; 398  :         iLenIPA = uLenData;

  000fd	8b 44 24 34	 mov	 eax, DWORD PTR uLenData$[rsp]
  00101	89 44 24 38	 mov	 DWORD PTR iLenIPA$[rsp], eax

; 399  :         iLenCmd = 0;

  00105	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR iLenCmd$[rsp], 0
$LN3@mpc_displa:

; 400  :     }
; 401  :     pMPC_IPA = (MPC_IPA*)((BYTE*)pMPC_TH + uOffData);

  0010d	8b 44 24 40	 mov	 eax, DWORD PTR uOffData$[rsp]
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  00116	48 03 c8	 add	 rcx, rax
  00119	48 8b c1	 mov	 rax, rcx
  0011c	48 89 44 24 50	 mov	 QWORD PTR pMPC_IPA$[rsp], rax

; 402  :     mpc_display_stuff( pDEVBLK, "IPA", (BYTE*)pMPC_IPA, iLenIPA, bDir );

  00121	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bDir$[rsp]
  00129	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  0012d	44 8b 4c 24 38	 mov	 r9d, DWORD PTR iLenIPA$[rsp]
  00132	4c 8b 44 24 50	 mov	 r8, QWORD PTR pMPC_IPA$[rsp]
  00137	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159738
  0013e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00143	e8 00 00 00 00	 call	 mpc_display_stuff

; 403  :     if( iLenCmd )

  00148	83 7c 24 3c 00	 cmp	 DWORD PTR iLenCmd$[rsp], 0
  0014d	74 3c		 je	 SHORT $LN4@mpc_displa

; 404  :     {
; 405  :         pMPC_IPA_CMD = (BYTE*)pMPC_IPA + iLenIPA;

  0014f	48 63 44 24 38	 movsxd	 rax, DWORD PTR iLenIPA$[rsp]
  00154	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_IPA$[rsp]
  00159	48 03 c8	 add	 rcx, rax
  0015c	48 8b c1	 mov	 rax, rcx
  0015f	48 89 44 24 58	 mov	 QWORD PTR pMPC_IPA_CMD$[rsp], rax

; 406  :         mpc_display_stuff( pDEVBLK, "Cmd", (BYTE*)pMPC_IPA_CMD, iLenCmd, bDir );

  00164	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bDir$[rsp]
  0016c	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00170	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR iLenCmd$[rsp]
  00175	4c 8b 44 24 58	 mov	 r8, QWORD PTR pMPC_IPA_CMD$[rsp]
  0017a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159740
  00181	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00186	e8 00 00 00 00	 call	 mpc_display_stuff
$LN4@mpc_displa:

; 407  :     }
; 408  : 
; 409  :     return;
; 410  : }   /* End function  mpc_display_rrh_and_ipa() */

  0018b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018f	c3		 ret	 0
mpc_display_rrh_and_ipa ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
uOffPH$ = 48
uOffData$ = 52
uLenData$ = 56
pMPC_PH$ = 64
pMPC_PIX$ = 72
pDEVBLK$ = 96
pMPC_TH$ = 104
pMPC_RRH$ = 112
bDir$ = 120
mpc_display_rrh_and_pix PROC

; 342  : {

$LN3:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 343  :     MPC_PH*    pMPC_PH;
; 344  :     MPC_PIX*   pMPC_PIX;
; 345  :     U32        uOffData;
; 346  :     U32        uLenData;
; 347  :     U16        uOffPH;
; 348  : 
; 349  :     // Display the MPC_RRH.
; 350  :     FETCH_HW( uOffPH, pMPC_RRH->offph );

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  0001d	48 83 c0 10	 add	 rax, 16
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 fetch_hw_noswap
  00029	0f b7 c8	 movzx	 ecx, ax
  0002c	e8 00 00 00 00	 call	 _byteswap_ushort
  00031	66 89 44 24 30	 mov	 WORD PTR uOffPH$[rsp], ax

; 351  :     mpc_display_stuff( pDEVBLK, "RRH", (BYTE*)pMPC_RRH, uOffPH, bDir );

  00036	0f b7 44 24 30	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0003b	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR bDir$[rsp]
  00040	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  00044	44 8b c8	 mov	 r9d, eax
  00047	4c 8b 44 24 70	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159702
  00053	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00058	e8 00 00 00 00	 call	 mpc_display_stuff

; 352  : 
; 353  :     // Point to and display the MPC_PH.
; 354  :     pMPC_PH = (MPC_PH*)((BYTE*)pMPC_RRH + uOffPH);

  0005d	0f b7 44 24 30	 movzx	 eax, WORD PTR uOffPH$[rsp]
  00062	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  00067	48 03 c8	 add	 rcx, rax
  0006a	48 8b c1	 mov	 rax, rcx
  0006d	48 89 44 24 40	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 355  :     mpc_display_stuff( pDEVBLK, "PH ", (BYTE*)pMPC_PH, SIZE_PH, bDir );

  00072	0f b6 44 24 78	 movzx	 eax, BYTE PTR bDir$[rsp]
  00077	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  0007b	41 b9 08 00 00
	00		 mov	 r9d, 8
  00081	4c 8b 44 24 40	 mov	 r8, QWORD PTR pMPC_PH$[rsp]
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159703
  0008d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00092	e8 00 00 00 00	 call	 mpc_display_stuff

; 356  : 
; 357  :     // Point to and display the MPC_PIX.
; 358  :     FETCH_F3( uLenData, pMPC_PH->lendata );

  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  0009c	48 ff c0	 inc	 rax
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	e8 00 00 00 00	 call	 fetch_f3_noswap
  000a7	8b c8		 mov	 ecx, eax
  000a9	e8 00 00 00 00	 call	 _byteswap_ulong
  000ae	89 44 24 38	 mov	 DWORD PTR uLenData$[rsp], eax

; 359  :     FETCH_FW( uOffData, pMPC_PH->offdata );

  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  000b7	48 83 c0 04	 add	 rax, 4
  000bb	48 8b c8	 mov	 rcx, rax
  000be	e8 00 00 00 00	 call	 fetch_fw_noswap
  000c3	8b c8		 mov	 ecx, eax
  000c5	e8 00 00 00 00	 call	 _byteswap_ulong
  000ca	89 44 24 34	 mov	 DWORD PTR uOffData$[rsp], eax

; 360  :     pMPC_PIX = (MPC_PIX*)((BYTE*)pMPC_TH + uOffData);

  000ce	8b 44 24 34	 mov	 eax, DWORD PTR uOffData$[rsp]
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  000d7	48 03 c8	 add	 rcx, rax
  000da	48 8b c1	 mov	 rax, rcx
  000dd	48 89 44 24 48	 mov	 QWORD PTR pMPC_PIX$[rsp], rax

; 361  :     mpc_display_stuff( pDEVBLK, "PIX", (BYTE*)pMPC_PIX, uLenData, bDir );

  000e2	0f b6 44 24 78	 movzx	 eax, BYTE PTR bDir$[rsp]
  000e7	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  000eb	44 8b 4c 24 38	 mov	 r9d, DWORD PTR uLenData$[rsp]
  000f0	4c 8b 44 24 48	 mov	 r8, QWORD PTR pMPC_PIX$[rsp]
  000f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159704
  000fc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00101	e8 00 00 00 00	 call	 mpc_display_stuff

; 362  : 
; 363  :     return;
; 364  : }   /* End function  mpc_display_rrh_and_pix() */

  00106	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0010a	c3		 ret	 0
mpc_display_rrh_and_pix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
uLenPUS$ = 48
iTotLenPUS$ = 52
uOffPH$ = 56
uLenPUK$ = 60
uTotLenPUS$ = 64
pMPC_PUS$ = 72
pMPC_PUK$ = 80
uOffData$ = 88
pMPC_PH$ = 96
pDEVBLK$ = 128
pMPC_TH$ = 136
pMPC_RRH$ = 144
bDir$ = 152
mpc_display_rrh_and_puk PROC

; 264  : {

$LN8:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 265  :     MPC_PH*    pMPC_PH;
; 266  :     MPC_PUK*   pMPC_PUK;
; 267  :     MPC_PUS*   pMPC_PUS;
; 268  :     int        iTotLenPUS;
; 269  :     U32        uOffData;
; 270  :     U16        uTotLenPUS;
; 271  :     U16        uLenPUS;
; 272  :     U16        uLenPUK;
; 273  :     U16        uOffPH;
; 274  : 
; 275  :     // Display the MPC_RRH.
; 276  :     FETCH_HW( uOffPH, pMPC_RRH->offph );

  00018	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  00020	48 83 c0 10	 add	 rax, 16
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 fetch_hw_noswap
  0002c	0f b7 c8	 movzx	 ecx, ax
  0002f	e8 00 00 00 00	 call	 _byteswap_ushort
  00034	66 89 44 24 38	 mov	 WORD PTR uOffPH$[rsp], ax

; 277  :     mpc_display_stuff( pDEVBLK, "RRH", (BYTE*)pMPC_RRH, uOffPH, bDir );

  00039	0f b7 44 24 38	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0003e	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR bDir$[rsp]
  00046	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  0004a	44 8b c8	 mov	 r9d, eax
  0004d	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159671
  0005c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00064	e8 00 00 00 00	 call	 mpc_display_stuff

; 278  : 
; 279  :     // Point to and display the MPC_PH.
; 280  :     pMPC_PH = (MPC_PH*)((BYTE*)pMPC_RRH + uOffPH);

  00069	0f b7 44 24 38	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0006e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  00076	48 03 c8	 add	 rcx, rax
  00079	48 8b c1	 mov	 rax, rcx
  0007c	48 89 44 24 60	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 281  :     mpc_display_stuff( pDEVBLK, "PH ", (BYTE*)pMPC_PH, SIZE_PH, bDir );

  00081	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR bDir$[rsp]
  00089	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  0008d	41 b9 08 00 00
	00		 mov	 r9d, 8
  00093	4c 8b 44 24 60	 mov	 r8, QWORD PTR pMPC_PH$[rsp]
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159672
  0009f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000a7	e8 00 00 00 00	 call	 mpc_display_stuff

; 282  : 
; 283  :     // Get the length of and point to the data referenced by the
; 284  :     // MPC_PH. The data contain a MPC_PUK and one or more MPC_PUSs.
; 285  :     FETCH_FW( uOffData, pMPC_PH->offdata );

  000ac	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  000b1	48 83 c0 04	 add	 rax, 4
  000b5	48 8b c8	 mov	 rcx, rax
  000b8	e8 00 00 00 00	 call	 fetch_fw_noswap
  000bd	8b c8		 mov	 ecx, eax
  000bf	e8 00 00 00 00	 call	 _byteswap_ulong
  000c4	89 44 24 58	 mov	 DWORD PTR uOffData$[rsp], eax

; 286  :     pMPC_PUK = (MPC_PUK*)((BYTE*)pMPC_TH + uOffData);

  000c8	8b 44 24 58	 mov	 eax, DWORD PTR uOffData$[rsp]
  000cc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  000d4	48 03 c8	 add	 rcx, rax
  000d7	48 8b c1	 mov	 rax, rcx
  000da	48 89 44 24 50	 mov	 QWORD PTR pMPC_PUK$[rsp], rax

; 287  : 
; 288  :     // Display the MPC_PUK.
; 289  :     FETCH_HW( uLenPUK, pMPC_PUK->length );

  000df	48 8b 44 24 50	 mov	 rax, QWORD PTR pMPC_PUK$[rsp]
  000e4	48 8b c8	 mov	 rcx, rax
  000e7	e8 00 00 00 00	 call	 fetch_hw_noswap
  000ec	0f b7 c8	 movzx	 ecx, ax
  000ef	e8 00 00 00 00	 call	 _byteswap_ushort
  000f4	66 89 44 24 3c	 mov	 WORD PTR uLenPUK$[rsp], ax

; 290  :     mpc_display_stuff( pDEVBLK, "PUK", (BYTE*)pMPC_PUK, uLenPUK, bDir );

  000f9	0f b7 44 24 3c	 movzx	 eax, WORD PTR uLenPUK$[rsp]
  000fe	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR bDir$[rsp]
  00106	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  0010a	44 8b c8	 mov	 r9d, eax
  0010d	4c 8b 44 24 50	 mov	 r8, QWORD PTR pMPC_PUK$[rsp]
  00112	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159673
  00119	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00121	e8 00 00 00 00	 call	 mpc_display_stuff

; 291  : 
; 292  :     // Get the total length of the following MPC_PUSs, then point to
; 293  :     // the first MPC_PUS.
; 294  :     FETCH_HW( uTotLenPUS, pMPC_PUK->lenpus );

  00126	48 8b 44 24 50	 mov	 rax, QWORD PTR pMPC_PUK$[rsp]
  0012b	48 83 c0 04	 add	 rax, 4
  0012f	48 8b c8	 mov	 rcx, rax
  00132	e8 00 00 00 00	 call	 fetch_hw_noswap
  00137	0f b7 c8	 movzx	 ecx, ax
  0013a	e8 00 00 00 00	 call	 _byteswap_ushort
  0013f	66 89 44 24 40	 mov	 WORD PTR uTotLenPUS$[rsp], ax

; 295  :     iTotLenPUS = uTotLenPUS;

  00144	0f b7 44 24 40	 movzx	 eax, WORD PTR uTotLenPUS$[rsp]
  00149	89 44 24 34	 mov	 DWORD PTR iTotLenPUS$[rsp], eax

; 296  :     pMPC_PUS = (MPC_PUS*)((BYTE*)pMPC_PUK + uLenPUK);

  0014d	0f b7 44 24 3c	 movzx	 eax, WORD PTR uLenPUK$[rsp]
  00152	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pMPC_PUK$[rsp]
  00157	48 03 c8	 add	 rcx, rax
  0015a	48 8b c1	 mov	 rax, rcx
  0015d	48 89 44 24 48	 mov	 QWORD PTR pMPC_PUS$[rsp], rax
$LN2@mpc_displa:

; 297  : 
; 298  :     // Display all of the MPC_PUSs.
; 299  :     while( iTotLenPUS > 0 )

  00162	83 7c 24 34 00	 cmp	 DWORD PTR iTotLenPUS$[rsp], 0
  00167	0f 8e 17 01 00
	00		 jle	 $LN3@mpc_displa

; 300  :     {
; 301  :         // Ensure there are at least the first 4-bytes of the MPC_PUS.
; 302  :         if( iTotLenPUS < 4 )

  0016d	83 7c 24 34 04	 cmp	 DWORD PTR iTotLenPUS$[rsp], 4
  00172	7d 2f		 jge	 SHORT $LN4@mpc_displa

; 303  :         {
; 304  :             mpc_display_stuff( pDEVBLK, "???", (BYTE*)pMPC_PUS, iTotLenPUS, bDir );

  00174	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR bDir$[rsp]
  0017c	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00180	44 8b 4c 24 34	 mov	 r9d, DWORD PTR iTotLenPUS$[rsp]
  00185	4c 8b 44 24 48	 mov	 r8, QWORD PTR pMPC_PUS$[rsp]
  0018a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159675
  00191	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00199	e8 00 00 00 00	 call	 mpc_display_stuff

; 305  :             break;

  0019e	e9 e1 00 00 00	 jmp	 $LN3@mpc_displa
$LN4@mpc_displa:

; 306  :         }
; 307  : 
; 308  :         // Get the length of the MPC_PUS.
; 309  :         FETCH_HW( uLenPUS, pMPC_PUS->length );

  001a3	48 8b 44 24 48	 mov	 rax, QWORD PTR pMPC_PUS$[rsp]
  001a8	48 8b c8	 mov	 rcx, rax
  001ab	e8 00 00 00 00	 call	 fetch_hw_noswap
  001b0	0f b7 c8	 movzx	 ecx, ax
  001b3	e8 00 00 00 00	 call	 _byteswap_ushort
  001b8	66 89 44 24 30	 mov	 WORD PTR uLenPUS$[rsp], ax

; 310  :         if( uLenPUS == 0 )                     /* Better safe than sorry */

  001bd	0f b7 44 24 30	 movzx	 eax, WORD PTR uLenPUS$[rsp]
  001c2	85 c0		 test	 eax, eax
  001c4	75 2f		 jne	 SHORT $LN5@mpc_displa

; 311  :         {
; 312  :             mpc_display_stuff( pDEVBLK, "???", (BYTE*)pMPC_PUS, iTotLenPUS, bDir );

  001c6	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR bDir$[rsp]
  001ce	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001d2	44 8b 4c 24 34	 mov	 r9d, DWORD PTR iTotLenPUS$[rsp]
  001d7	4c 8b 44 24 48	 mov	 r8, QWORD PTR pMPC_PUS$[rsp]
  001dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159677
  001e3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001eb	e8 00 00 00 00	 call	 mpc_display_stuff

; 313  :             break;

  001f0	e9 8f 00 00 00	 jmp	 $LN3@mpc_displa
$LN5@mpc_displa:

; 314  :         }
; 315  : 
; 316  :         // Ensure there is the whole of the MPC_PUS.
; 317  :         if( iTotLenPUS < uLenPUS )

  001f5	0f b7 44 24 30	 movzx	 eax, WORD PTR uLenPUS$[rsp]
  001fa	39 44 24 34	 cmp	 DWORD PTR iTotLenPUS$[rsp], eax
  001fe	7d 2c		 jge	 SHORT $LN6@mpc_displa

; 318  :         {
; 319  :             mpc_display_stuff( pDEVBLK, "???", (BYTE*)pMPC_PUS, iTotLenPUS, bDir );

  00200	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR bDir$[rsp]
  00208	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  0020c	44 8b 4c 24 34	 mov	 r9d, DWORD PTR iTotLenPUS$[rsp]
  00211	4c 8b 44 24 48	 mov	 r8, QWORD PTR pMPC_PUS$[rsp]
  00216	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159679
  0021d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00225	e8 00 00 00 00	 call	 mpc_display_stuff

; 320  :             break;

  0022a	eb 58		 jmp	 SHORT $LN3@mpc_displa
$LN6@mpc_displa:

; 321  :         }
; 322  : 
; 323  :         // Display the MPC_PUS.
; 324  :         mpc_display_stuff( pDEVBLK, "PUS", (BYTE*)pMPC_PUS, uLenPUS, bDir );

  0022c	0f b7 44 24 30	 movzx	 eax, WORD PTR uLenPUS$[rsp]
  00231	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR bDir$[rsp]
  00239	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  0023d	44 8b c8	 mov	 r9d, eax
  00240	4c 8b 44 24 48	 mov	 r8, QWORD PTR pMPC_PUS$[rsp]
  00245	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159680
  0024c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00254	e8 00 00 00 00	 call	 mpc_display_stuff

; 325  : 
; 326  :         // Point to the next MPC_PUS
; 327  :         pMPC_PUS = (MPC_PUS*)((BYTE*)pMPC_PUS + uLenPUS);

  00259	0f b7 44 24 30	 movzx	 eax, WORD PTR uLenPUS$[rsp]
  0025e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pMPC_PUS$[rsp]
  00263	48 03 c8	 add	 rcx, rax
  00266	48 8b c1	 mov	 rax, rcx
  00269	48 89 44 24 48	 mov	 QWORD PTR pMPC_PUS$[rsp], rax

; 328  :         iTotLenPUS -= uLenPUS;

  0026e	0f b7 44 24 30	 movzx	 eax, WORD PTR uLenPUS$[rsp]
  00273	8b 4c 24 34	 mov	 ecx, DWORD PTR iTotLenPUS$[rsp]
  00277	2b c8		 sub	 ecx, eax
  00279	8b c1		 mov	 eax, ecx
  0027b	89 44 24 34	 mov	 DWORD PTR iTotLenPUS$[rsp], eax

; 329  :     }

  0027f	e9 de fe ff ff	 jmp	 $LN2@mpc_displa
$LN3@mpc_displa:

; 330  : 
; 331  :     return;
; 332  : }   /* End function  mpc_display_rrh_and_puk() */

  00284	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00288	c3		 ret	 0
mpc_display_rrh_and_puk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
pDEVBLK$ = 64
pMPC_PH$ = 72
bDir$ = 80
mpc_display_ph PROC

; 248  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 249  : 
; 250  :     // Display the MPC_PH.
; 251  :     mpc_display_stuff( pDEVBLK, "PH ", (BYTE*)pMPC_PH, SIZE_PH, bDir );

  00013	0f b6 44 24 50	 movzx	 eax, BYTE PTR bDir$[rsp]
  00018	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  0001c	41 b9 08 00 00
	00		 mov	 r9d, 8
  00022	4c 8b 44 24 48	 mov	 r8, QWORD PTR pMPC_PH$[rsp]
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159635
  0002e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00033	e8 00 00 00 00	 call	 mpc_display_stuff

; 252  : 
; 253  :     return;
; 254  : }   /* End function  mpc_display_ph() */

  00038	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003c	c3		 ret	 0
mpc_display_ph ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
uOffPH$ = 48
pDEVBLK$ = 80
pMPC_RRH$ = 88
bDir$ = 96
mpc_display_rrh PROC

; 234  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 235  :     U16    uOffPH;
; 236  : 
; 237  :     // Display the MPC_RRH.
; 238  :     FETCH_HW( uOffPH, pMPC_RRH->offph );

  00013	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  00018	48 83 c0 10	 add	 rax, 16
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 fetch_hw_noswap
  00024	0f b7 c8	 movzx	 ecx, ax
  00027	e8 00 00 00 00	 call	 _byteswap_ushort
  0002c	66 89 44 24 30	 mov	 WORD PTR uOffPH$[rsp], ax

; 239  :     mpc_display_stuff( pDEVBLK, "RRH", (BYTE*)pMPC_RRH, uOffPH, bDir );

  00031	0f b7 44 24 30	 movzx	 eax, WORD PTR uOffPH$[rsp]
  00036	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR bDir$[rsp]
  0003b	88 4c 24 20	 mov	 BYTE PTR [rsp+32], cl
  0003f	44 8b c8	 mov	 r9d, eax
  00042	4c 8b 44 24 58	 mov	 r8, QWORD PTR pMPC_RRH$[rsp]
  00047	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159626
  0004e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00053	e8 00 00 00 00	 call	 mpc_display_stuff

; 240  : 
; 241  :     return;
; 242  : }   /* End function  mpc_display_rrh() */

  00058	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005c	c3		 ret	 0
mpc_display_rrh ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
uOffRRH$ = 48
pDEVBLK$ = 80
pMPC_TH$ = 88
bDir$ = 96
mpc_display_th PROC

; 220  : {

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 221  :     U32    uOffRRH;
; 222  : 
; 223  :     // Display the MPC_TH.
; 224  :     FETCH_FW( uOffRRH, pMPC_TH->offrrh );

  00013	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_TH$[rsp]
  00018	48 83 c0 08	 add	 rax, 8
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00024	8b c8		 mov	 ecx, eax
  00026	e8 00 00 00 00	 call	 _byteswap_ulong
  0002b	89 44 24 30	 mov	 DWORD PTR uOffRRH$[rsp], eax

; 225  :     mpc_display_stuff( pDEVBLK, "TH ", (BYTE*)pMPC_TH, uOffRRH, bDir );

  0002f	0f b6 44 24 60	 movzx	 eax, BYTE PTR bDir$[rsp]
  00034	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00038	44 8b 4c 24 30	 mov	 r9d, DWORD PTR uOffRRH$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR pMPC_TH$[rsp]
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159616
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0004e	e8 00 00 00 00	 call	 mpc_display_stuff

; 226  : 
; 227  :     return;
; 228  : }   /* End function  mpc_display_th() */

  00053	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00057	c3		 ret	 0
mpc_display_th ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
c$ = 112
e$ = 113
i$ = 116
offset$ = 120
tv175 = 124
tv179 = 128
$T1 = 136
$T2 = 144
$T3 = 152
print_ebcdic$ = 160
print_ascii$ = 184
print_line$ = 208
tmp$ = 272
__$ArrayPad$ = 304
pDEVBLK$ = 336
cWhat$ = 344
pAddr$ = 352
iLen$ = 360
bDir$ = 368
mpc_display_stuff PROC

; 150  : {

$LN22:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 151  :     int           offset;
; 152  :     unsigned int  i;
; 153  :     u_char        c = '\0';

  0002e	c6 44 24 70 00	 mov	 BYTE PTR c$[rsp], 0

; 154  :     u_char        e = '\0';

  00033	c6 44 24 71 00	 mov	 BYTE PTR e$[rsp], 0

; 155  :     char          print_ascii[17];
; 156  :     char          print_ebcdic[17];
; 157  :     char          print_line[64];
; 158  :     char          tmp[32];
; 159  : 
; 160  :     for( offset = 0; offset < iLen; )

  00038	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR offset$[rsp], 0
$LN2@mpc_displa:
  00040	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR iLen$[rsp]
  00047	39 44 24 78	 cmp	 DWORD PTR offset$[rsp], eax
  0004b	0f 8d a6 03 00
	00		 jge	 $LN3@mpc_displa

; 161  :     {
; 162  :         memset( print_ascii, ' ', sizeof(print_ascii)-1 );    /* set to spaces */

  00051	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR print_ascii$[rsp]
  00059	48 8b f8	 mov	 rdi, rax
  0005c	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00061	b9 10 00 00 00	 mov	 ecx, 16
  00066	f3 aa		 rep stosb

; 163  :         print_ascii[sizeof(print_ascii)-1] = '\0';            /* with null termination */

  00068	b8 01 00 00 00	 mov	 eax, 1
  0006d	48 6b c0 10	 imul	 rax, rax, 16
  00071	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  00079	48 83 bc 24 88
	00 00 00 11	 cmp	 QWORD PTR $T1[rsp], 17
  00082	73 02		 jae	 SHORT $LN16@mpc_displa
  00084	eb 05		 jmp	 SHORT $LN17@mpc_displa
$LN16@mpc_displa:
  00086	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN17@mpc_displa:
  0008b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  00093	c6 84 04 b8 00
	00 00 00	 mov	 BYTE PTR print_ascii$[rsp+rax], 0

; 164  :         memset( print_ebcdic, ' ', sizeof(print_ebcdic)-1 );  /* set to spaces */

  0009b	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR print_ebcdic$[rsp]
  000a3	48 8b f8	 mov	 rdi, rax
  000a6	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000ab	b9 10 00 00 00	 mov	 ecx, 16
  000b0	f3 aa		 rep stosb

; 165  :         print_ebcdic[sizeof(print_ebcdic)-1] = '\0';          /* with null termination */

  000b2	b8 01 00 00 00	 mov	 eax, 1
  000b7	48 6b c0 10	 imul	 rax, rax, 16
  000bb	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T2[rsp], rax
  000c3	48 83 bc 24 90
	00 00 00 11	 cmp	 QWORD PTR $T2[rsp], 17
  000cc	73 02		 jae	 SHORT $LN18@mpc_displa
  000ce	eb 05		 jmp	 SHORT $LN19@mpc_displa
$LN18@mpc_displa:
  000d0	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN19@mpc_displa:
  000d5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T2[rsp]
  000dd	c6 84 04 a0 00
	00 00 00	 mov	 BYTE PTR print_ebcdic$[rsp+rax], 0

; 166  :         memset( print_line, 0, sizeof( print_line ) );

  000e5	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR print_line$[rsp]
  000ed	48 8b f8	 mov	 rdi, rax
  000f0	33 c0		 xor	 eax, eax
  000f2	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000f7	f3 aa		 rep stosb

; 167  : 
; 168  :         MSGBUF( print_line, "+%4.4X%c ", offset, bDir );

  000f9	0f b6 84 24 70
	01 00 00	 movzx	 eax, BYTE PTR bDir$[rsp]
  00101	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00105	44 8b 4c 24 78	 mov	 r9d, DWORD PTR offset$[rsp]
  0010a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159588
  00111	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00116	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR print_line$[rsp]
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 169  : 
; 170  :         for( i = 0; i < 16; i++ )

  00124	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0012c	eb 0a		 jmp	 SHORT $LN7@mpc_displa
$LN5@mpc_displa:
  0012e	8b 44 24 74	 mov	 eax, DWORD PTR i$[rsp]
  00132	ff c0		 inc	 eax
  00134	89 44 24 74	 mov	 DWORD PTR i$[rsp], eax
$LN7@mpc_displa:
  00138	83 7c 24 74 10	 cmp	 DWORD PTR i$[rsp], 16
  0013d	0f 83 5f 01 00
	00		 jae	 $LN6@mpc_displa

; 171  :         {
; 172  :             c = *pAddr++;

  00143	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pAddr$[rsp]
  0014b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0014e	88 44 24 70	 mov	 BYTE PTR c$[rsp], al
  00152	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pAddr$[rsp]
  0015a	48 ff c0	 inc	 rax
  0015d	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR pAddr$[rsp], rax

; 173  : 
; 174  :             if( offset < iLen )

  00165	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR iLen$[rsp]
  0016c	39 44 24 78	 cmp	 DWORD PTR offset$[rsp], eax
  00170	0f 8d dc 00 00
	00		 jge	 $LN8@mpc_displa

; 175  :             {
; 176  :                 MSGBUF(tmp, "%2.2X", c );

  00176	0f b6 44 24 70	 movzx	 eax, BYTE PTR c$[rsp]
  0017b	44 8b c8	 mov	 r9d, eax
  0017e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159591
  00185	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0018a	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR tmp$[rsp]
  00192	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 177  :                 tmp[sizeof(tmp)-1] = '\0';

  00198	b8 01 00 00 00	 mov	 eax, 1
  0019d	48 6b c0 1f	 imul	 rax, rax, 31
  001a1	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR $T3[rsp], rax
  001a9	48 83 bc 24 98
	00 00 00 20	 cmp	 QWORD PTR $T3[rsp], 32	; 00000020H
  001b2	73 02		 jae	 SHORT $LN20@mpc_displa
  001b4	eb 05		 jmp	 SHORT $LN21@mpc_displa
$LN20@mpc_displa:
  001b6	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN21@mpc_displa:
  001bb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T3[rsp]
  001c3	c6 84 04 10 01
	00 00 00	 mov	 BYTE PTR tmp$[rsp+rax], 0

; 178  :                 STRLCAT( print_line, tmp );

  001cb	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  001d1	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR tmp$[rsp]
  001d9	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR print_line$[rsp]
  001e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 179  : 
; 180  :                 print_ebcdic[i] = print_ascii[i] = '.';

  001e7	8b 44 24 74	 mov	 eax, DWORD PTR i$[rsp]
  001eb	c6 84 04 b8 00
	00 00 2e	 mov	 BYTE PTR print_ascii$[rsp+rax], 46 ; 0000002eH
  001f3	8b 44 24 74	 mov	 eax, DWORD PTR i$[rsp]
  001f7	c6 84 04 a0 00
	00 00 2e	 mov	 BYTE PTR print_ebcdic$[rsp+rax], 46 ; 0000002eH

; 181  :                 e = guest_to_host( c );

  001ff	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR c$[rsp]
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  0020a	88 44 24 71	 mov	 BYTE PTR e$[rsp], al

; 182  : 
; 183  :                 if( isprint( e ) )

  0020e	0f b6 44 24 71	 movzx	 eax, BYTE PTR e$[rsp]
  00213	8b c8		 mov	 ecx, eax
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  0021b	85 c0		 test	 eax, eax
  0021d	74 10		 je	 SHORT $LN10@mpc_displa

; 184  :                     print_ebcdic[i] = e;

  0021f	8b 44 24 74	 mov	 eax, DWORD PTR i$[rsp]
  00223	0f b6 4c 24 71	 movzx	 ecx, BYTE PTR e$[rsp]
  00228	88 8c 04 a0 00
	00 00		 mov	 BYTE PTR print_ebcdic$[rsp+rax], cl
$LN10@mpc_displa:

; 185  :                 if( isprint( c ) )

  0022f	0f b6 44 24 70	 movzx	 eax, BYTE PTR c$[rsp]
  00234	8b c8		 mov	 ecx, eax
  00236	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  0023c	85 c0		 test	 eax, eax
  0023e	74 10		 je	 SHORT $LN11@mpc_displa

; 186  :                     print_ascii[i] = c;

  00240	8b 44 24 74	 mov	 eax, DWORD PTR i$[rsp]
  00244	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR c$[rsp]
  00249	88 8c 04 b8 00
	00 00		 mov	 BYTE PTR print_ascii$[rsp+rax], cl
$LN11@mpc_displa:

; 187  :             }

  00250	eb 1b		 jmp	 SHORT $LN9@mpc_displa
$LN8@mpc_displa:

; 188  :             else
; 189  :             {
; 190  :                 STRLCAT( print_line, "  " );

  00252	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00258	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159594
  0025f	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR print_line$[rsp]
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN9@mpc_displa:

; 191  :             }
; 192  : 
; 193  :             offset++;

  0026d	8b 44 24 78	 mov	 eax, DWORD PTR offset$[rsp]
  00271	ff c0		 inc	 eax
  00273	89 44 24 78	 mov	 DWORD PTR offset$[rsp], eax

; 194  :             if( ( offset & 3 ) == 0 )

  00277	8b 44 24 78	 mov	 eax, DWORD PTR offset$[rsp]
  0027b	83 e0 03	 and	 eax, 3
  0027e	85 c0		 test	 eax, eax
  00280	75 1b		 jne	 SHORT $LN12@mpc_displa

; 195  :             {
; 196  :                 STRLCAT( print_line, " " );

  00282	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00288	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159596
  0028f	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR print_line$[rsp]
  00297	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN12@mpc_displa:

; 197  :             }
; 198  :         }

  0029d	e9 8c fe ff ff	 jmp	 $LN5@mpc_displa
$LN6@mpc_displa:

; 199  : 
; 200  :         if( pDEVBLK )

  002a2	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR pDEVBLK$[rsp], 0
  002ab	0f 84 c6 00 00
	00		 je	 $LN13@mpc_displa

; 201  :         {
; 202  :             // HHC03981 "%1d:%04X %s: %s: %s %s  %s"
; 203  :             WRMSG(HHC03981, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  002b1	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002b9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002bd	89 44 24 7c	 mov	 DWORD PTR tv175[rsp], eax
  002c1	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002c9	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  002cd	d1 f9		 sar	 ecx, 1
  002cf	89 8c 24 80 00
	00 00		 mov	 DWORD PTR tv179[rsp], ecx
  002d6	b9 01 00 00 00	 mov	 ecx, 1
  002db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002e1	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR print_ebcdic$[rsp]
  002e9	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  002ee	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR print_ascii$[rsp]
  002f6	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  002fb	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR print_line$[rsp]
  00303	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00308	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR cWhat$[rsp]
  00310	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00315	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0031d	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00321	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00326	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv175[rsp]
  0032a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0032e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv179[rsp]
  00335	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00339	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159599
  00340	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00345	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159600
  0034c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00351	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00356	41 b9 03 00 00
	00		 mov	 r9d, 3
  0035c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159601
  00363	ba cc 00 00 00	 mov	 edx, 204		; 000000ccH
  00368	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159602
  0036f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 204  :                                  cWhat, print_line, print_ascii, print_ebcdic );
; 205  :         }

  00375	eb 7b		 jmp	 SHORT $LN14@mpc_displa
$LN13@mpc_displa:

; 206  :         else
; 207  :         {
; 208  :             // HHC03982 "%s: %s %s  %s"
; 209  :             WRMSG(HHC03982, "D", cWhat, print_line, print_ascii, print_ebcdic );

  00377	b9 01 00 00 00	 mov	 ecx, 1
  0037c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00382	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR print_ebcdic$[rsp]
  0038a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0038f	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR print_ascii$[rsp]
  00397	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0039c	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR print_line$[rsp]
  003a4	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003a9	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR cWhat$[rsp]
  003b1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159603
  003bd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159604
  003c9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003d3	41 b9 03 00 00
	00		 mov	 r9d, 3
  003d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159605
  003e0	ba d1 00 00 00	 mov	 edx, 209		; 000000d1H
  003e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159606
  003ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@mpc_displa:

; 210  :         }
; 211  :     }

  003f2	e9 49 fc ff ff	 jmp	 $LN2@mpc_displa
$LN3@mpc_displa:
$LN15@mpc_displa:

; 212  : 
; 213  :     return;
; 214  : }   /* End function  mpc_display_stuff() */

  003f7	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003ff	48 33 cc	 xor	 rcx, rsp
  00402	e8 00 00 00 00	 call	 __security_check_cookie
  00407	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  0040e	5f		 pop	 rdi
  0040f	c3		 ret	 0
mpc_display_stuff ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
tv70 = 96
tv74 = 100
pDEVBLK$ = 128
pDesc$ = 136
mpc_display_description PROC

; 125  : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 126  : 
; 127  :     /* Display description, if one has been provided. */
; 128  :     if( pDesc )

  0000e	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR pDesc$[rsp], 0
  00017	0f 84 fc 00 00
	00		 je	 $LN2@mpc_displa

; 129  :     {
; 130  :         if( pDEVBLK )

  0001d	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pDEVBLK$[rsp], 0
  00026	0f 84 99 00 00
	00		 je	 $LN3@mpc_displa

; 131  :         {
; 132  :             // HHC03983 "%1d:%04X %s: %s
; 133  :             WRMSG(HHC03983, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname, pDesc );

  0002c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00034	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00038	89 44 24 60	 mov	 DWORD PTR tv70[rsp], eax
  0003c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00044	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00048	d1 f9		 sar	 ecx, 1
  0004a	89 4c 24 64	 mov	 DWORD PTR tv74[rsp], ecx
  0004e	b9 01 00 00 00	 mov	 ecx, 1
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00059	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pDesc$[rsp]
  00061	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00066	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0006e	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00072	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00077	8b 4c 24 60	 mov	 ecx, DWORD PTR tv70[rsp]
  0007b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0007f	8b 4c 24 64	 mov	 ecx, DWORD PTR tv74[rsp]
  00083	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159552
  0008e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159553
  0009a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0009f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a4	41 b9 03 00 00
	00		 mov	 r9d, 3
  000aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159554
  000b1	ba 85 00 00 00	 mov	 edx, 133		; 00000085H
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159555
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 134  :         }

  000c3	eb 54		 jmp	 SHORT $LN4@mpc_displa
$LN3@mpc_displa:

; 135  :         else
; 136  :         {
; 137  :             // HHC03984 "%s"
; 138  :             WRMSG(HHC03984, "D", pDesc );

  000c5	b9 01 00 00 00	 mov	 ecx, 1
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pDesc$[rsp]
  000d8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159556
  000e4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159557
  000f0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fa	41 b9 03 00 00
	00		 mov	 r9d, 3
  00100	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159558
  00107	ba 8a 00 00 00	 mov	 edx, 138		; 0000008aH
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159559
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@mpc_displa:
$LN2@mpc_displa:

; 139  :         }
; 140  :     }
; 141  : 
; 142  :     return;
; 143  : }   /* End function  mpc_display_description() */

  00119	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0011d	c3		 ret	 0
mpc_display_description ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
uLenPUS$ = 32
uTotLenPUS$ = 36
uLenPUK$ = 40
iTotLenPUS$ = 44
pMPC_PUS$ = 48
pDEVBLK$ = 80
pMPC_PUK$ = 88
bType$ = 96
mpc_point_pus PROC

; 77   : {

$LN12:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@mpc_point_:

; 78   :     MPC_PUS*   pMPC_PUS;
; 79   :     int        iTotLenPUS;
; 80   :     U16        uTotLenPUS;
; 81   :     U16        uLenPUS;
; 82   :     U16        uLenPUK;
; 83   : 
; 84   :     UNREFERENCED( pDEVBLK );

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@mpc_point_

; 85   : 
; 86   :     /* Get the length of the MPC_PUK, the total length of the */
; 87   :     /* following MPC_PUSs, then point to the first MPC_PUS.   */
; 88   :     FETCH_HW( uLenPUK, pMPC_PUK->length );

  00019	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUK$[rsp]
  0001e	48 8b c8	 mov	 rcx, rax
  00021	e8 00 00 00 00	 call	 fetch_hw_noswap
  00026	0f b7 c8	 movzx	 ecx, ax
  00029	e8 00 00 00 00	 call	 _byteswap_ushort
  0002e	66 89 44 24 28	 mov	 WORD PTR uLenPUK$[rsp], ax

; 89   :     FETCH_HW( uTotLenPUS, pMPC_PUK->lenpus );

  00033	48 8b 44 24 58	 mov	 rax, QWORD PTR pMPC_PUK$[rsp]
  00038	48 83 c0 04	 add	 rax, 4
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	e8 00 00 00 00	 call	 fetch_hw_noswap
  00044	0f b7 c8	 movzx	 ecx, ax
  00047	e8 00 00 00 00	 call	 _byteswap_ushort
  0004c	66 89 44 24 24	 mov	 WORD PTR uTotLenPUS$[rsp], ax

; 90   :     iTotLenPUS = uTotLenPUS;

  00051	0f b7 44 24 24	 movzx	 eax, WORD PTR uTotLenPUS$[rsp]
  00056	89 44 24 2c	 mov	 DWORD PTR iTotLenPUS$[rsp], eax

; 91   :     pMPC_PUS = (MPC_PUS*)((BYTE*)pMPC_PUK + uLenPUK);

  0005a	0f b7 44 24 28	 movzx	 eax, WORD PTR uLenPUK$[rsp]
  0005f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pMPC_PUK$[rsp]
  00064	48 03 c8	 add	 rcx, rax
  00067	48 8b c1	 mov	 rax, rcx
  0006a	48 89 44 24 30	 mov	 QWORD PTR pMPC_PUS$[rsp], rax
$LN5@mpc_point_:

; 92   : 
; 93   :     /* Find the required MPC_PUS. */
; 94   :     while( iTotLenPUS > 0 )

  0006f	83 7c 24 2c 00	 cmp	 DWORD PTR iTotLenPUS$[rsp], 0
  00074	0f 8e 85 00 00
	00		 jle	 $LN6@mpc_point_

; 95   :     {
; 96   :         /* Ensure there are at least the first 4-bytes of an MPC_PUS. */
; 97   :         if( iTotLenPUS < 4 )

  0007a	83 7c 24 2c 04	 cmp	 DWORD PTR iTotLenPUS$[rsp], 4
  0007f	7d 04		 jge	 SHORT $LN7@mpc_point_

; 98   :             return NULL;

  00081	33 c0		 xor	 eax, eax
  00083	eb 7c		 jmp	 SHORT $LN1@mpc_point_
$LN7@mpc_point_:

; 99   : 
; 100  :         /* Get the length of the MPC_PUS. */
; 101  :         FETCH_HW( uLenPUS, pMPC_PUS->length );

  00085	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PUS$[rsp]
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	e8 00 00 00 00	 call	 fetch_hw_noswap
  00092	0f b7 c8	 movzx	 ecx, ax
  00095	e8 00 00 00 00	 call	 _byteswap_ushort
  0009a	66 89 44 24 20	 mov	 WORD PTR uLenPUS$[rsp], ax

; 102  :         if( uLenPUS == 0 )                  /* Better safe than sorry */

  0009f	0f b7 44 24 20	 movzx	 eax, WORD PTR uLenPUS$[rsp]
  000a4	85 c0		 test	 eax, eax
  000a6	75 04		 jne	 SHORT $LN8@mpc_point_

; 103  :             return NULL;

  000a8	33 c0		 xor	 eax, eax
  000aa	eb 55		 jmp	 SHORT $LN1@mpc_point_
$LN8@mpc_point_:

; 104  : 
; 105  :         /* Ensure there is the whole of the MPC_PUS. */
; 106  :         if( iTotLenPUS < uLenPUS )

  000ac	0f b7 44 24 20	 movzx	 eax, WORD PTR uLenPUS$[rsp]
  000b1	39 44 24 2c	 cmp	 DWORD PTR iTotLenPUS$[rsp], eax
  000b5	7d 04		 jge	 SHORT $LN9@mpc_point_

; 107  :             return NULL;

  000b7	33 c0		 xor	 eax, eax
  000b9	eb 46		 jmp	 SHORT $LN1@mpc_point_
$LN9@mpc_point_:

; 108  : 
; 109  :         /* Check for the required MPC_PUS. */
; 110  :         if( pMPC_PUS->type == bType )

  000bb	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PUS$[rsp]
  000c0	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000c4	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR bType$[rsp]
  000c9	3b c1		 cmp	 eax, ecx
  000cb	75 07		 jne	 SHORT $LN10@mpc_point_

; 111  :             return pMPC_PUS;

  000cd	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PUS$[rsp]
  000d2	eb 2d		 jmp	 SHORT $LN1@mpc_point_
$LN10@mpc_point_:

; 112  : 
; 113  :         /* Point to the next MPC_PUS. */
; 114  :         pMPC_PUS = (MPC_PUS*)((BYTE*)pMPC_PUS + uLenPUS);

  000d4	0f b7 44 24 20	 movzx	 eax, WORD PTR uLenPUS$[rsp]
  000d9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pMPC_PUS$[rsp]
  000de	48 03 c8	 add	 rcx, rax
  000e1	48 8b c1	 mov	 rax, rcx
  000e4	48 89 44 24 30	 mov	 QWORD PTR pMPC_PUS$[rsp], rax

; 115  :         iTotLenPUS -= uLenPUS;

  000e9	0f b7 44 24 20	 movzx	 eax, WORD PTR uLenPUS$[rsp]
  000ee	8b 4c 24 2c	 mov	 ecx, DWORD PTR iTotLenPUS$[rsp]
  000f2	2b c8		 sub	 ecx, eax
  000f4	8b c1		 mov	 eax, ecx
  000f6	89 44 24 2c	 mov	 DWORD PTR iTotLenPUS$[rsp], eax

; 116  :     }

  000fa	e9 70 ff ff ff	 jmp	 $LN5@mpc_point_
$LN6@mpc_point_:

; 117  : 
; 118  :     return NULL;

  000ff	33 c0		 xor	 eax, eax
$LN1@mpc_point_:

; 119  : }   /* End function  mpc_point_pus() */

  00101	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00105	c3		 ret	 0
mpc_point_pus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
uOffPH$ = 32
uOffData$ = 36
pMPC_PH$ = 40
pMPC_PUK$ = 48
pDEVBLK$ = 80
pMPC_TH$ = 88
pMPC_RRH$ = 96
mpc_point_puk PROC

; 49   : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@mpc_point_:

; 50   :     MPC_PH*    pMPC_PH;
; 51   :     MPC_PUK*   pMPC_PUK;
; 52   :     U32        uOffData;
; 53   :     U16        uOffPH;
; 54   : 
; 55   :     UNREFERENCED( pDEVBLK );

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@mpc_point_

; 56   : 
; 57   :     // Point to the MPC_PH.
; 58   :     FETCH_HW( uOffPH, pMPC_RRH->offph );

  00019	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  0001e	48 83 c0 10	 add	 rax, 16
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_hw_noswap
  0002a	0f b7 c8	 movzx	 ecx, ax
  0002d	e8 00 00 00 00	 call	 _byteswap_ushort
  00032	66 89 44 24 20	 mov	 WORD PTR uOffPH$[rsp], ax

; 59   :     pMPC_PH = (MPC_PH*)((BYTE*)pMPC_RRH + uOffPH);

  00037	0f b7 44 24 20	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0003c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  00041	48 03 c8	 add	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	48 89 44 24 28	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 60   : 
; 61   :     // Get the length of and point to the data referenced by the
; 62   :     // MPC_PH. The data contain a MPC_PUK and one or more MPC_PUSs.
; 63   :     FETCH_FW( uOffData, pMPC_PH->offdata );

  0004c	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  00051	48 83 c0 04	 add	 rax, 4
  00055	48 8b c8	 mov	 rcx, rax
  00058	e8 00 00 00 00	 call	 fetch_fw_noswap
  0005d	8b c8		 mov	 ecx, eax
  0005f	e8 00 00 00 00	 call	 _byteswap_ulong
  00064	89 44 24 24	 mov	 DWORD PTR uOffData$[rsp], eax

; 64   :     pMPC_PUK = (MPC_PUK*)((BYTE*)pMPC_TH + uOffData);

  00068	8b 44 24 24	 mov	 eax, DWORD PTR uOffData$[rsp]
  0006c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  00071	48 03 c8	 add	 rcx, rax
  00074	48 8b c1	 mov	 rax, rcx
  00077	48 89 44 24 30	 mov	 QWORD PTR pMPC_PUK$[rsp], rax

; 65   : 
; 66   :     return pMPC_PUK;

  0007c	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_PUK$[rsp]

; 67   : }   /* End function  mpc_point_puk() */

  00081	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00085	c3		 ret	 0
mpc_point_puk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\mpc.c
_TEXT	SEGMENT
uOffPH$ = 32
uOffData$ = 36
pMPC_PH$ = 40
pMPC_IPA$ = 48
pDEVBLK$ = 80
pMPC_TH$ = 88
pMPC_RRH$ = 96
mpc_point_ipa PROC

; 25   : {

$LN6:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@mpc_point_:

; 26   :     MPC_PH*    pMPC_PH;
; 27   :     MPC_IPA*   pMPC_IPA;
; 28   :     U32        uOffData;
; 29   :     U16        uOffPH;
; 30   : 
; 31   :     UNREFERENCED( pDEVBLK );

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@mpc_point_

; 32   : 
; 33   :     // Point to the MPC_PH.
; 34   :     FETCH_HW( uOffPH, pMPC_RRH->offph );

  00019	48 8b 44 24 60	 mov	 rax, QWORD PTR pMPC_RRH$[rsp]
  0001e	48 83 c0 10	 add	 rax, 16
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_hw_noswap
  0002a	0f b7 c8	 movzx	 ecx, ax
  0002d	e8 00 00 00 00	 call	 _byteswap_ushort
  00032	66 89 44 24 20	 mov	 WORD PTR uOffPH$[rsp], ax

; 35   :     pMPC_PH = (MPC_PH*)((BYTE*)pMPC_RRH + uOffPH);

  00037	0f b7 44 24 20	 movzx	 eax, WORD PTR uOffPH$[rsp]
  0003c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pMPC_RRH$[rsp]
  00041	48 03 c8	 add	 rcx, rax
  00044	48 8b c1	 mov	 rax, rcx
  00047	48 89 44 24 28	 mov	 QWORD PTR pMPC_PH$[rsp], rax

; 36   : 
; 37   :     // Get the length of and point to the data referenced by the
; 38   :     // MPC_PH. The data contain a MPC_IPA.
; 39   :     FETCH_FW( uOffData, pMPC_PH->offdata );

  0004c	48 8b 44 24 28	 mov	 rax, QWORD PTR pMPC_PH$[rsp]
  00051	48 83 c0 04	 add	 rax, 4
  00055	48 8b c8	 mov	 rcx, rax
  00058	e8 00 00 00 00	 call	 fetch_fw_noswap
  0005d	8b c8		 mov	 ecx, eax
  0005f	e8 00 00 00 00	 call	 _byteswap_ulong
  00064	89 44 24 24	 mov	 DWORD PTR uOffData$[rsp], eax

; 40   :     pMPC_IPA = (MPC_IPA*)((BYTE*)pMPC_TH + uOffData);

  00068	8b 44 24 24	 mov	 eax, DWORD PTR uOffData$[rsp]
  0006c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pMPC_TH$[rsp]
  00071	48 03 c8	 add	 rcx, rax
  00074	48 8b c1	 mov	 rax, rcx
  00077	48 89 44 24 30	 mov	 QWORD PTR pMPC_IPA$[rsp], rax

; 41   : 
; 42   :     return pMPC_IPA;

  0007c	48 8b 44 24 30	 mov	 rax, QWORD PTR pMPC_IPA$[rsp]

; 43   : }   /* End function  mpc_point_ipa() */

  00081	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00085	c3		 ret	 0
mpc_point_ipa ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_f3_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 48
fetch_f3_noswap PROC					; COMDAT

; 780  :     inline U32 fetch_f3_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 18	 sub	 rsp, 24

; 781  :       U32 value;
; 782  :       memcpy(((BYTE *)&value), (BYTE *)ptr, 3);

  0000b	48 8d 04 24	 lea	 rax, QWORD PTR value$[rsp]
  0000f	48 8b f8	 mov	 rdi, rax
  00012	48 8b 74 24 30	 mov	 rsi, QWORD PTR ptr$[rsp]
  00017	b9 03 00 00 00	 mov	 ecx, 3
  0001c	f3 a4		 rep movsb

; 783  :       value <<= 8;

  0001e	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]
  00021	c1 e0 08	 shl	 eax, 8
  00024	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 784  :       return value;

  00027	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 785  :     }

  0002a	48 83 c4 18	 add	 rsp, 24
  0002e	5f		 pop	 rdi
  0002f	5e		 pop	 rsi
  00030	c3		 ret	 0
fetch_f3_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
END
