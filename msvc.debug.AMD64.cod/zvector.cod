; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	fetch_fw_noswap
PUBLIC	z900_vector_load
PUBLIC	z900_vector_store
PUBLIC	z900_vector_load_multiple
PUBLIC	z900_vector_store_multiple
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_xcheck
PUBLIC	z900_per3_zero_xcheck2
PUBLIC	z900_maddr_l
PUBLIC	z900_vstorec
PUBLIC	z900_vfetchc
EXTRN	_byteswap_ulong:PROC
EXTRN	longjmp:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	z900_logical_to_main_l:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$z900_vector_load DD imagerel $LN10
	DD	imagerel $LN10+440
	DD	imagerel $unwind$z900_vector_load
$pdata$z900_vector_store DD imagerel $LN10
	DD	imagerel $LN10+440
	DD	imagerel $unwind$z900_vector_store
$pdata$z900_vector_load_multiple DD imagerel $LN11
	DD	imagerel $LN11+465
	DD	imagerel $unwind$z900_vector_load_multiple
$pdata$z900_vector_store_multiple DD imagerel $LN11
	DD	imagerel $LN11+465
	DD	imagerel $unwind$z900_vector_store_multiple
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck DD imagerel $LN6
	DD	imagerel $LN6+108
	DD	imagerel $unwind$z900_per3_zero_xcheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck2 DD imagerel $LN18
	DD	imagerel $LN18+485
	DD	imagerel $unwind$z900_per3_zero_xcheck2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+445
	DD	imagerel $unwind$z900_vfetchc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck2 DD 011201H
	DD	0a212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
xdata	SEGMENT
$unwind$z900_vector_load DD 010e01H
	DD	0a20eH
$unwind$z900_vector_store DD 010e01H
	DD	0a20eH
$unwind$z900_vector_load_multiple DD 010e01H
	DD	0c20eH
$unwind$z900_vector_store_multiple DD 010e01H
	DD	0c20eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002c	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00031	2b d1		 sub	 edx, ecx
  00033	8b ca		 mov	 ecx, edx
  00035	3b c1		 cmp	 eax, ecx
  00037	7f 0a		 jg	 SHORT $LN7@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN8@z900_vfetc
$LN7@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00050	74 63		 je	 SHORT $LN2@z900_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00052	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 98		 cdqe
  0005b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00098	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	48 98		 cdqe
  000a1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a6	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	f3 a4		 rep movsb

; 640  :     }

  000b0	e9 01 01 00 00	 jmp	 $LN3@z900_vfetc
$LN2@z900_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000bd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000c3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c8	48 2b c8	 sub	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000e3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000ef	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f7	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0010a	e8 00 00 00 00	 call	 z900_maddr_l
  0010f	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00114	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00119	ff c0		 inc	 eax
  0011b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0011f	48 98		 cdqe
  00121	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00126	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  0012e	48 03 d1	 add	 rdx, rcx
  00131	48 8b ca	 mov	 rcx, rdx
  00134	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00143	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0014b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0014f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00153	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0015b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00163	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0016b	48 8b d0	 mov	 rdx, rax
  0016e	e8 00 00 00 00	 call	 z900_maddr_l
  00173	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  00178	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0017d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00182	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  00187	48 8b c8	 mov	 rcx, rax
  0018a	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0018c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00191	ff c0		 inc	 eax
  00193	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00197	48 98		 cdqe
  00199	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0019e	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001a3	48 03 d1	 add	 rdx, rcx
  001a6	48 8b ca	 mov	 rcx, rdx
  001a9	48 8b f9	 mov	 rdi, rcx
  001ac	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	f3 a4		 rep movsb
$LN3@z900_vfetc:

; 649  :     }
; 650  : }

  001b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	c3		 ret	 0
z900_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck2
_TEXT	SEGMENT
tv81 = 32
tv131 = 40
tv150 = 48
tv181 = 56
tv166 = 64
regs$ = 96
x2$ = 104
b2$ = 112
z900_per3_zero_xcheck2 PROC				; COMDAT

; 765  : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 766  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 767  :     if (0
; 768  :         || (!b2 && x2 && GR_A( x2, regs ) == 0)
; 769  :         || (!x2 && b2 && GR_A( b2, regs ) == 0)
; 770  :         || ( b2 && x2 && (0

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	0f 85 ba 01 00
	00		 jne	 $LN3@z900_per3_
  0001c	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00021	75 54		 jne	 SHORT $LN4@z900_per3_
  00023	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  00028	74 4d		 je	 SHORT $LN4@z900_per3_
  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0002f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 19		 je	 SHORT $LN8@z900_per3_
  0003c	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00041	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00046	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0004e	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
  00053	eb 16		 jmp	 SHORT $LN9@z900_per3_
$LN8@z900_per3_:
  00055	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00066	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
$LN9@z900_per3_:
  0006b	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv81[rsp], 0
  00071	0f 84 5f 01 00
	00		 je	 $LN3@z900_per3_
$LN4@z900_per3_:
  00077	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  0007c	75 54		 jne	 SHORT $LN5@z900_per3_
  0007e	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 4d		 je	 SHORT $LN5@z900_per3_
  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00090	83 e0 01	 and	 eax, 1
  00093	85 c0		 test	 eax, eax
  00095	74 19		 je	 SHORT $LN10@z900_per3_
  00097	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a9	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
  000ae	eb 16		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  000b0	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000ba	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c1	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
$LN11@z900_per3_:
  000c6	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv131[rsp], 0
  000cc	0f 84 04 01 00
	00		 je	 $LN3@z900_per3_
$LN5@z900_per3_:
  000d2	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  000d7	0f 84 03 01 00
	00		 je	 $LN2@z900_per3_
  000dd	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  000e2	0f 84 f8 00 00
	00		 je	 $LN2@z900_per3_
  000e8	33 c0		 xor	 eax, eax
  000ea	85 c0		 test	 eax, eax
  000ec	0f 85 e4 00 00
	00		 jne	 $LN6@z900_per3_
  000f2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 19		 je	 SHORT $LN12@z900_per3_
  00104	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00109	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00116	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
  0011b	eb 16		 jmp	 SHORT $LN13@z900_per3_
$LN12@z900_per3_:
  0011d	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0012e	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
$LN13@z900_per3_:
  00133	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv150[rsp], 0
  00139	0f 84 97 00 00
	00		 je	 $LN6@z900_per3_
  0013f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00144	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0014a	83 e0 01	 and	 eax, 1
  0014d	85 c0		 test	 eax, eax
  0014f	74 19		 je	 SHORT $LN14@z900_per3_
  00151	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00156	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0015b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00163	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
  00168	eb 16		 jmp	 SHORT $LN15@z900_per3_
$LN14@z900_per3_:
  0016a	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00174	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0017b	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
$LN15@z900_per3_:
  00180	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00185	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0018b	83 e0 01	 and	 eax, 1
  0018e	85 c0		 test	 eax, eax
  00190	74 19		 je	 SHORT $LN16@z900_per3_
  00192	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00197	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0019c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001a4	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
  001a9	eb 16		 jmp	 SHORT $LN17@z900_per3_
$LN16@z900_per3_:
  001ab	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  001b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001bc	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
$LN17@z900_per3_:
  001c1	48 8b 44 24 38	 mov	 rax, QWORD PTR tv181[rsp]
  001c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv166[rsp]
  001cb	48 03 c8	 add	 rcx, rax
  001ce	48 8b c1	 mov	 rax, rcx
  001d1	48 85 c0	 test	 rax, rax
  001d4	75 0a		 jne	 SHORT $LN2@z900_per3_
$LN6@z900_per3_:
$LN3@z900_per3_:

; 771  :                           || GR_A( b2, regs ) == 0
; 772  :                           || GR_A( b2, regs ) + GR_A( x2, regs ) == 0
; 773  :                          )
; 774  :            )
; 775  :     )
; 776  :         ARCH_DEP( per3_zero )( regs );

  001d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 777  : #else
; 778  :     UNREFERENCED( regs );
; 779  :     UNREFERENCED( x2 );
; 780  :     UNREFERENCED( b2 );
; 781  : #endif
; 782  : }

  001e0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e4	c3		 ret	 0
z900_per3_zero_xcheck2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck
_TEXT	SEGMENT
tv79 = 32
regs$ = 64
b1$ = 72
z900_per3_zero_xcheck PROC				; COMDAT

; 754  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 755  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 756  :     if (b1 && GR_A( b1, regs ) == 0)

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  00012	74 53		 je	 SHORT $LN2@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 19		 je	 SHORT $LN4@z900_per3_
  00026	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00030	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00038	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  0003d	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  0003f	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00050	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN5@z900_per3_:
  00055	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  0005b	75 0a		 jne	 SHORT $LN2@z900_per3_

; 757  :         ARCH_DEP( per3_zero )( regs );

  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 758  : #else
; 759  :     UNREFERENCED( regs );
; 760  :     UNREFERENCED( b1 );
; 761  : #endif
; 762  : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
z900_per3_zero_xcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zvector.c
_TEXT	SEGMENT
temp$1 = 48
b2$ = 52
len$ = 56
_rxb$2 = 60
v1$ = 64
v3$ = 68
m4$ = 72
effective_addr2$ = 80
inst$ = 112
regs$ = 120
z900_vector_store_multiple PROC

; 71   : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 72   :     int     v1, v3, b2, m4;
; 73   :     VADR    effective_addr2;        /* Effective address         */
; 74   : 
; 75   :     VRS_A(inst, regs, v1, v3, b2, effective_addr2, m4);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 ff c0	 inc	 rax
  00016	48 8b c8	 mov	 rcx, rax
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  00029	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0002d	83 e0 0f	 and	 eax, 15
  00030	89 44 24 3c	 mov	 DWORD PTR _rxb$2[rsp], eax
  00034	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00038	c1 e8 1c	 shr	 eax, 28
  0003b	83 e0 0f	 and	 eax, 15
  0003e	8b 4c 24 3c	 mov	 ecx, DWORD PTR _rxb$2[rsp]
  00042	83 e1 08	 and	 ecx, 8
  00045	d1 e1		 shl	 ecx, 1
  00047	0b c1		 or	 eax, ecx
  00049	89 44 24 40	 mov	 DWORD PTR v1$[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 18	 shr	 eax, 24
  00054	83 e0 0f	 and	 eax, 15
  00057	8b 4c 24 3c	 mov	 ecx, DWORD PTR _rxb$2[rsp]
  0005b	83 e1 04	 and	 ecx, 4
  0005e	c1 e1 02	 shl	 ecx, 2
  00061	0b c1		 or	 eax, ecx
  00063	89 44 24 44	 mov	 DWORD PTR v3$[rsp], eax
  00067	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0006b	c1 e8 14	 shr	 eax, 20
  0006e	83 e0 0f	 and	 eax, 15
  00071	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00075	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00079	c1 e8 08	 shr	 eax, 8
  0007c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00081	8b c0		 mov	 eax, eax
  00083	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00088	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0008c	c1 e8 04	 shr	 eax, 4
  0008f	83 e0 0f	 and	 eax, 15
  00092	89 44 24 48	 mov	 DWORD PTR m4$[rsp], eax
  00096	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009b	74 22		 je	 SHORT $LN5@z900_vecto
  0009d	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a7	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000b4	48 03 c8	 add	 rcx, rax
  000b7	48 8b c1	 mov	 rax, rcx
  000ba	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_vecto:
  000bf	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000cb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d0	48 23 c8	 and	 rcx, rax
  000d3	48 8b c1	 mov	 rax, rcx
  000d6	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_vecto:
  000db	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e4	48 83 c0 06	 add	 rax, 6
  000e8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ed	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f1	33 c0		 xor	 eax, eax
  000f3	83 f8 06	 cmp	 eax, 6
  000f6	74 0c		 je	 SHORT $LN6@z900_vecto
  000f8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@z900_vecto:
  00104	33 c0		 xor	 eax, eax
  00106	85 c0		 test	 eax, eax
  00108	75 d1		 jne	 SHORT $LN4@z900_vecto

; 76   :     ZVECTOR_CHECK(regs);

  0010a	b8 08 00 00 00	 mov	 eax, 8
  0010f	48 6b c0 01	 imul	 rax, rax, 1
  00113	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00118	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00120	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00126	48 85 c0	 test	 rax, rax
  00129	75 24		 jne	 SHORT $LN7@z900_vecto
  0012b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00130	c7 80 08 07 00
	00 fe 00 00 00	 mov	 DWORD PTR [rax+1800], 254 ; 000000feH
  0013a	ba 07 00 00 00	 mov	 edx, 7
  0013f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00149	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN7@z900_vecto:

; 77   :     PER_ZEROADDR_XCHECK(regs, b2);

  0014f	8b 54 24 34	 mov	 edx, DWORD PTR b2$[rsp]
  00153	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 78   :     int len = (1 + v3 - v1) * sizeof(QWORD);

  0015d	8b 44 24 44	 mov	 eax, DWORD PTR v3$[rsp]
  00161	ff c0		 inc	 eax
  00163	2b 44 24 40	 sub	 eax, DWORD PTR v1$[rsp]
  00167	48 98		 cdqe
  00169	48 6b c0 10	 imul	 rax, rax, 16
  0016d	89 44 24 38	 mov	 DWORD PTR len$[rsp], eax

; 79   :     if (len < 0 || len > 16 * sizeof(QWORD))

  00171	83 7c 24 38 00	 cmp	 DWORD PTR len$[rsp], 0
  00176	7c 0d		 jl	 SHORT $LN9@z900_vecto
  00178	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$[rsp]
  0017d	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  00183	76 0f		 jbe	 SHORT $LN8@z900_vecto
$LN9@z900_vecto:

; 80   :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00185	ba 06 00 00 00	 mov	 edx, 6
  0018a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018f	e8 00 00 00 00	 call	 z900_program_interrupt
$LN8@z900_vecto:

; 81   :     
; 82   :     ARCH_DEP(vstorec) (&regs->vr[(v1)], len - 1, effective_addr2, b2, regs);

  00194	8b 44 24 38	 mov	 eax, DWORD PTR len$[rsp]
  00198	ff c8		 dec	 eax
  0019a	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR v1$[rsp]
  0019f	48 6b c9 10	 imul	 rcx, rcx, 16
  001a3	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  001a8	48 8d 8c 0a c4
	03 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+964]
  001b0	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  001b5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001ba	44 8b 4c 24 34	 mov	 r9d, DWORD PTR b2$[rsp]
  001bf	4c 8b 44 24 50	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  001c4	0f b6 d0	 movzx	 edx, al
  001c7	e8 00 00 00 00	 call	 z900_vstorec

; 83   : }

  001cc	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001d0	c3		 ret	 0
z900_vector_store_multiple ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zvector.c
_TEXT	SEGMENT
temp$1 = 48
b2$ = 52
len$ = 56
_rxb$2 = 60
v1$ = 64
v3$ = 68
m4$ = 72
effective_addr2$ = 80
inst$ = 112
regs$ = 120
z900_vector_load_multiple PROC

; 54   : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 55   :     int     v1, v3, b2, m4;
; 56   :     VADR    effective_addr2;        /* Effective address         */
; 57   : 
; 58   :     VRS_A(inst, regs, v1, v3, b2, effective_addr2, m4);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 ff c0	 inc	 rax
  00016	48 8b c8	 mov	 rcx, rax
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  00029	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0002d	83 e0 0f	 and	 eax, 15
  00030	89 44 24 3c	 mov	 DWORD PTR _rxb$2[rsp], eax
  00034	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00038	c1 e8 1c	 shr	 eax, 28
  0003b	83 e0 0f	 and	 eax, 15
  0003e	8b 4c 24 3c	 mov	 ecx, DWORD PTR _rxb$2[rsp]
  00042	83 e1 08	 and	 ecx, 8
  00045	d1 e1		 shl	 ecx, 1
  00047	0b c1		 or	 eax, ecx
  00049	89 44 24 40	 mov	 DWORD PTR v1$[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 18	 shr	 eax, 24
  00054	83 e0 0f	 and	 eax, 15
  00057	8b 4c 24 3c	 mov	 ecx, DWORD PTR _rxb$2[rsp]
  0005b	83 e1 04	 and	 ecx, 4
  0005e	c1 e1 02	 shl	 ecx, 2
  00061	0b c1		 or	 eax, ecx
  00063	89 44 24 44	 mov	 DWORD PTR v3$[rsp], eax
  00067	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0006b	c1 e8 14	 shr	 eax, 20
  0006e	83 e0 0f	 and	 eax, 15
  00071	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00075	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00079	c1 e8 08	 shr	 eax, 8
  0007c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00081	8b c0		 mov	 eax, eax
  00083	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00088	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0008c	c1 e8 04	 shr	 eax, 4
  0008f	83 e0 0f	 and	 eax, 15
  00092	89 44 24 48	 mov	 DWORD PTR m4$[rsp], eax
  00096	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  0009b	74 22		 je	 SHORT $LN5@z900_vecto
  0009d	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a7	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000b4	48 03 c8	 add	 rcx, rax
  000b7	48 8b c1	 mov	 rax, rcx
  000ba	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_vecto:
  000bf	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000cb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d0	48 23 c8	 and	 rcx, rax
  000d3	48 8b c1	 mov	 rax, rcx
  000d6	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_vecto:
  000db	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e4	48 83 c0 06	 add	 rax, 6
  000e8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ed	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f1	33 c0		 xor	 eax, eax
  000f3	83 f8 06	 cmp	 eax, 6
  000f6	74 0c		 je	 SHORT $LN6@z900_vecto
  000f8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN6@z900_vecto:
  00104	33 c0		 xor	 eax, eax
  00106	85 c0		 test	 eax, eax
  00108	75 d1		 jne	 SHORT $LN4@z900_vecto

; 59   :     ZVECTOR_CHECK(regs);

  0010a	b8 08 00 00 00	 mov	 eax, 8
  0010f	48 6b c0 01	 imul	 rax, rax, 1
  00113	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00118	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00120	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00126	48 85 c0	 test	 rax, rax
  00129	75 24		 jne	 SHORT $LN7@z900_vecto
  0012b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00130	c7 80 08 07 00
	00 fe 00 00 00	 mov	 DWORD PTR [rax+1800], 254 ; 000000feH
  0013a	ba 07 00 00 00	 mov	 edx, 7
  0013f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00144	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00149	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN7@z900_vecto:

; 60   :     PER_ZEROADDR_XCHECK(regs, b2);

  0014f	8b 54 24 34	 mov	 edx, DWORD PTR b2$[rsp]
  00153	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	e8 00 00 00 00	 call	 z900_per3_zero_xcheck

; 61   :     int len = (1 + v3 - v1) * sizeof(QWORD);

  0015d	8b 44 24 44	 mov	 eax, DWORD PTR v3$[rsp]
  00161	ff c0		 inc	 eax
  00163	2b 44 24 40	 sub	 eax, DWORD PTR v1$[rsp]
  00167	48 98		 cdqe
  00169	48 6b c0 10	 imul	 rax, rax, 16
  0016d	89 44 24 38	 mov	 DWORD PTR len$[rsp], eax

; 62   :     if (len < 0 || len > 16 * sizeof(QWORD))

  00171	83 7c 24 38 00	 cmp	 DWORD PTR len$[rsp], 0
  00176	7c 0d		 jl	 SHORT $LN9@z900_vecto
  00178	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$[rsp]
  0017d	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  00183	76 0f		 jbe	 SHORT $LN8@z900_vecto
$LN9@z900_vecto:

; 63   :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00185	ba 06 00 00 00	 mov	 edx, 6
  0018a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018f	e8 00 00 00 00	 call	 z900_program_interrupt
$LN8@z900_vecto:

; 64   : 
; 65   :     ARCH_DEP(vfetchc) (&regs->vr[(v1)], len - 1, effective_addr2, b2, regs);

  00194	8b 44 24 38	 mov	 eax, DWORD PTR len$[rsp]
  00198	ff c8		 dec	 eax
  0019a	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR v1$[rsp]
  0019f	48 6b c9 10	 imul	 rcx, rcx, 16
  001a3	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  001a8	48 8d 8c 0a c4
	03 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+964]
  001b0	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  001b5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001ba	44 8b 4c 24 34	 mov	 r9d, DWORD PTR b2$[rsp]
  001bf	4c 8b 44 24 50	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  001c4	0f b6 d0	 movzx	 edx, al
  001c7	e8 00 00 00 00	 call	 z900_vfetchc

; 66   : }

  001cc	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001d0	c3		 ret	 0
z900_vector_load_multiple ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zvector.c
_TEXT	SEGMENT
temp$1 = 48
b2$ = 52
x2$ = 56
_rxb$2 = 60
v1$ = 64
m3$ = 68
effective_addr2$ = 72
inst$ = 96
regs$ = 104
z900_vector_store PROC

; 40   : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 41   :     int     v1, m3, x2, b2;
; 42   :     VADR    effective_addr2;        /* Effective address         */
; 43   : 
; 44   :     VRX(inst, regs, v1, x2, b2, effective_addr2, m3);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 ff c0	 inc	 rax
  00016	48 8b c8	 mov	 rcx, rax
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  00029	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0002d	83 e0 0f	 and	 eax, 15
  00030	89 44 24 3c	 mov	 DWORD PTR _rxb$2[rsp], eax
  00034	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00038	c1 e8 1c	 shr	 eax, 28
  0003b	83 e0 0f	 and	 eax, 15
  0003e	8b 4c 24 3c	 mov	 ecx, DWORD PTR _rxb$2[rsp]
  00042	83 e1 08	 and	 ecx, 8
  00045	d1 e1		 shl	 ecx, 1
  00047	0b c1		 or	 eax, ecx
  00049	89 44 24 40	 mov	 DWORD PTR v1$[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 18	 shr	 eax, 24
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 38	 mov	 DWORD PTR x2$[rsp], eax
  0005b	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0005f	c1 e8 14	 shr	 eax, 20
  00062	83 e0 0f	 and	 eax, 15
  00065	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00069	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0006d	c1 e8 08	 shr	 eax, 8
  00070	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00075	8b c0		 mov	 eax, eax
  00077	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0007c	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00080	c1 e8 04	 shr	 eax, 4
  00083	83 e0 0f	 and	 eax, 15
  00086	89 44 24 44	 mov	 DWORD PTR m3$[rsp], eax
  0008a	83 7c 24 38 00	 cmp	 DWORD PTR x2$[rsp], 0
  0008f	74 22		 je	 SHORT $LN5@z900_vecto
  00091	48 63 44 24 38	 movsxd	 rax, DWORD PTR x2$[rsp]
  00096	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a8	48 03 c8	 add	 rcx, rax
  000ab	48 8b c1	 mov	 rax, rcx
  000ae	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_vecto:
  000b3	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000b8	74 22		 je	 SHORT $LN6@z900_vecto
  000ba	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000bf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000cc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d1	48 03 c8	 add	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_vecto:
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000e8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000ed	48 23 c8	 and	 rcx, rax
  000f0	48 8b c1	 mov	 rax, rcx
  000f3	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_vecto:
  000f8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00101	48 83 c0 06	 add	 rax, 6
  00105	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0010a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0010e	33 c0		 xor	 eax, eax
  00110	83 f8 06	 cmp	 eax, 6
  00113	74 0c		 je	 SHORT $LN7@z900_vecto
  00115	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@z900_vecto:
  00121	33 c0		 xor	 eax, eax
  00123	85 c0		 test	 eax, eax
  00125	75 d1		 jne	 SHORT $LN4@z900_vecto

; 45   :     ZVECTOR_CHECK(regs);

  00127	b8 08 00 00 00	 mov	 eax, 8
  0012c	48 6b c0 01	 imul	 rax, rax, 1
  00130	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00135	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013d	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00143	48 85 c0	 test	 rax, rax
  00146	75 24		 jne	 SHORT $LN8@z900_vecto
  00148	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014d	c7 80 08 07 00
	00 fe 00 00 00	 mov	 DWORD PTR [rax+1800], 254 ; 000000feH
  00157	ba 07 00 00 00	 mov	 edx, 7
  0015c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00166	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@z900_vecto:

; 46   :     PER_ZEROADDR_XCHECK2(regs, x2, b2);

  0016c	44 8b 44 24 34	 mov	 r8d, DWORD PTR b2$[rsp]
  00171	8b 54 24 38	 mov	 edx, DWORD PTR x2$[rsp]
  00175	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017a	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 47   : 
; 48   :     ARCH_DEP(vstorec) (&regs->vr[(v1)], sizeof(QWORD) - 1, effective_addr2, b2, regs);

  0017f	48 63 44 24 40	 movsxd	 rax, DWORD PTR v1$[rsp]
  00184	48 6b c0 10	 imul	 rax, rax, 16
  00188	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8d 84 01 c4
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax+964]
  00195	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0019f	44 8b 4c 24 34	 mov	 r9d, DWORD PTR b2$[rsp]
  001a4	4c 8b 44 24 48	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  001a9	b2 0f		 mov	 dl, 15
  001ab	48 8b c8	 mov	 rcx, rax
  001ae	e8 00 00 00 00	 call	 z900_vstorec

; 49   : }

  001b3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b7	c3		 ret	 0
z900_vector_store ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zvector.c
_TEXT	SEGMENT
temp$1 = 48
b2$ = 52
x2$ = 56
_rxb$2 = 60
v1$ = 64
m3$ = 68
effective_addr2$ = 72
inst$ = 96
regs$ = 104
z900_vector_load PROC

; 24   : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 25   :     int     v1, m3, x2, b2;
; 26   :     VADR    effective_addr2;        /* Effective address         */
; 27   : 
; 28   :     VRX(inst, regs, v1, x2, b2, effective_addr2, m3);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 ff c0	 inc	 rax
  00016	48 8b c8	 mov	 rcx, rax
  00019	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 _byteswap_ulong
  00025	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  00029	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0002d	83 e0 0f	 and	 eax, 15
  00030	89 44 24 3c	 mov	 DWORD PTR _rxb$2[rsp], eax
  00034	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00038	c1 e8 1c	 shr	 eax, 28
  0003b	83 e0 0f	 and	 eax, 15
  0003e	8b 4c 24 3c	 mov	 ecx, DWORD PTR _rxb$2[rsp]
  00042	83 e1 08	 and	 ecx, 8
  00045	d1 e1		 shl	 ecx, 1
  00047	0b c1		 or	 eax, ecx
  00049	89 44 24 40	 mov	 DWORD PTR v1$[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 18	 shr	 eax, 24
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 38	 mov	 DWORD PTR x2$[rsp], eax
  0005b	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0005f	c1 e8 14	 shr	 eax, 20
  00062	83 e0 0f	 and	 eax, 15
  00065	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00069	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0006d	c1 e8 08	 shr	 eax, 8
  00070	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00075	8b c0		 mov	 eax, eax
  00077	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0007c	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00080	c1 e8 04	 shr	 eax, 4
  00083	83 e0 0f	 and	 eax, 15
  00086	89 44 24 44	 mov	 DWORD PTR m3$[rsp], eax
  0008a	83 7c 24 38 00	 cmp	 DWORD PTR x2$[rsp], 0
  0008f	74 22		 je	 SHORT $LN5@z900_vecto
  00091	48 63 44 24 38	 movsxd	 rax, DWORD PTR x2$[rsp]
  00096	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0009b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a8	48 03 c8	 add	 rcx, rax
  000ab	48 8b c1	 mov	 rax, rcx
  000ae	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN5@z900_vecto:
  000b3	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000b8	74 22		 je	 SHORT $LN6@z900_vecto
  000ba	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000bf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000cc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d1	48 03 c8	 add	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN6@z900_vecto:
  000dc	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000e8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000ed	48 23 c8	 and	 rcx, rax
  000f0	48 8b c1	 mov	 rax, rcx
  000f3	48 89 44 24 48	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN4@z900_vecto:
  000f8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00101	48 83 c0 06	 add	 rax, 6
  00105	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0010a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0010e	33 c0		 xor	 eax, eax
  00110	83 f8 06	 cmp	 eax, 6
  00113	74 0c		 je	 SHORT $LN7@z900_vecto
  00115	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN7@z900_vecto:
  00121	33 c0		 xor	 eax, eax
  00123	85 c0		 test	 eax, eax
  00125	75 d1		 jne	 SHORT $LN4@z900_vecto

; 29   : 
; 30   :     ZVECTOR_CHECK(regs);

  00127	b8 08 00 00 00	 mov	 eax, 8
  0012c	48 6b c0 01	 imul	 rax, rax, 1
  00130	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00135	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0013d	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00143	48 85 c0	 test	 rax, rax
  00146	75 24		 jne	 SHORT $LN8@z900_vecto
  00148	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0014d	c7 80 08 07 00
	00 fe 00 00 00	 mov	 DWORD PTR [rax+1800], 254 ; 000000feH
  00157	ba 07 00 00 00	 mov	 edx, 7
  0015c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00166	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@z900_vecto:

; 31   :     PER_ZEROADDR_XCHECK2(regs, x2, b2);

  0016c	44 8b 44 24 34	 mov	 r8d, DWORD PTR b2$[rsp]
  00171	8b 54 24 38	 mov	 edx, DWORD PTR x2$[rsp]
  00175	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0017a	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 32   : 
; 33   :     ARCH_DEP(vfetchc) (&regs->vr[(v1)], sizeof(QWORD) - 1, effective_addr2, b2, regs);

  0017f	48 63 44 24 40	 movsxd	 rax, DWORD PTR v1$[rsp]
  00184	48 6b c0 10	 imul	 rax, rax, 16
  00188	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8d 84 01 c4
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax+964]
  00195	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0019a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0019f	44 8b 4c 24 34	 mov	 r9d, DWORD PTR b2$[rsp]
  001a4	4c 8b 44 24 48	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  001a9	b2 0f		 mov	 dl, 15
  001ab	48 8b c8	 mov	 rcx, rax
  001ae	e8 00 00 00 00	 call	 z900_vfetchc

; 34   : 
; 35   : }

  001b3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b7	c3		 ret	 0
z900_vector_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
END
