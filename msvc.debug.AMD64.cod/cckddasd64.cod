; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
_DATA	SEGMENT
$SG172069 DB	'none', 00H
	ORG $+3
$SG172070 DB	'zlib', 00H
	ORG $+3
$SG172071 DB	'bzip2', 00H
_DATA	ENDS
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	cckd64_dasd_init_handler
PUBLIC	cckd64_dasd_close_device
PUBLIC	cckd64_read_track
PUBLIC	cckd64_update_track
PUBLIC	cfba64_read_block
PUBLIC	cfba64_write_block
PUBLIC	cckd64_dasd_start
PUBLIC	cckd64_dasd_end
PUBLIC	cckd64_open
PUBLIC	cckd64_close
PUBLIC	cckd64_read
PUBLIC	cckd64_write
PUBLIC	cckd64_ftruncate
PUBLIC	cckd64_used
PUBLIC	cfba64_used
PUBLIC	cckd64_read_trk
PUBLIC	cckd64_flush_cache
PUBLIC	cckd64_flush_cache_scan
PUBLIC	cckd64_flush_cache_all
PUBLIC	cckd64_purge_cache
PUBLIC	cckd64_purge_cache_scan
PUBLIC	cckd64_writer_write
PUBLIC	cckd64_get_space
PUBLIC	cckd64_rel_space
PUBLIC	cckd64_flush_space
PUBLIC	cckd64_read_chdr
PUBLIC	cckd64_write_chdr
PUBLIC	cckd64_read_l1
PUBLIC	cckd64_write_l1
PUBLIC	cckd64_write_l1ent
PUBLIC	cckd64_read_init
PUBLIC	cckd64_read_fsp
PUBLIC	cckd64_write_fsp
PUBLIC	cckd64_read_l2
PUBLIC	cckd64_purge_l2
PUBLIC	cckd64_purge_l2_scan
PUBLIC	cckd64_steal_l2
PUBLIC	cckd64_write_l2
PUBLIC	cckd64_read_l2ent
PUBLIC	cckd64_write_l2ent
PUBLIC	cckd64_read_trkimg
PUBLIC	cckd64_write_trkimg
PUBLIC	cckd64_harden
PUBLIC	cckd64_null_trk
PUBLIC	cckd64_check_null_trk
PUBLIC	cckd64_cchh
PUBLIC	cckd64_validate
PUBLIC	cckd64_sf_init
PUBLIC	cckd64_sf_new
PUBLIC	cckd64_gcstart
PUBLIC	cckd64_gcol_dev
PUBLIC	cckd64_gc_state
PUBLIC	cckd64_gc_rpt_state
PUBLIC	cckd64_gc_percolate
PUBLIC	cckd64_gc_l2
PUBLIC	cckd64_uncompress
PUBLIC	cckd64_sf_add
PUBLIC	cckd64_sf_remove
PUBLIC	cckd64_sf_comp
PUBLIC	cckd64_sf_chk
PUBLIC	cckd64_sf_stats
EXTRN	__imp__errno:PROC
EXTRN	strcmp:PROC
EXTRN	__imp_free:PROC
EXTRN	abs:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp__chsize_s:PROC
EXTRN	__imp__commit:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp_unlink:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp__fstat64:PROC
EXTRN	__imp__stat64:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_destroy_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_destroy_condition:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_broadcast_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_set_lock_name:PROC
EXTRN	__imp_timed_wait_condition_relative_usecs_impl:PROC
EXTRN	__imp_trimloc:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_get_file_accmode_flags:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	cache_busy:PROC
EXTRN	cache_waiters:PROC
EXTRN	cache_busy_percent:PROC
EXTRN	cache_lookup:PROC
EXTRN	cache_scan:PROC
EXTRN	cache_lock:PROC
EXTRN	cache_unlock:PROC
EXTRN	cache_wait:PROC
EXTRN	cache_getkey:PROC
EXTRN	cache_setkey:PROC
EXTRN	cache_getflag:PROC
EXTRN	cache_setflag:PROC
EXTRN	cache_setage:PROC
EXTRN	cache_getbuf:PROC
EXTRN	cache_setbuf:PROC
EXTRN	cache_getlen:PROC
EXTRN	cache_getval:PROC
EXTRN	cache_setval:PROC
EXTRN	cache_release:PROC
EXTRN	shared_update_notify:PROC
EXTRN	ckd_build_sense:PROC
EXTRN	cckd_dasd_close_device:PROC
EXTRN	cckd64_swapend:PROC
EXTRN	cckd64_swapend_chdr:PROC
EXTRN	cckd64_swapend_l1:PROC
EXTRN	cckd64_swapend_l2:PROC
EXTRN	cckd64_comp:PROC
EXTRN	cckd64_chkdsk:PROC
EXTRN	cckd_def_opt_bigend:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	dh_devid_typ:PROC
EXTRN	is_dh_devid_typ:PROC
EXTRN	cckd_dasd_init:PROC
EXTRN	cckd_dasd_term_if_appropriate:PROC
EXTRN	cckd_dasd_start:PROC
EXTRN	cckd_dasd_end:PROC
EXTRN	cckd_read:PROC
EXTRN	cckd_malloc:PROC
EXTRN	cckd_calloc:PROC
EXTRN	cckd_realloc:PROC
EXTRN	cckd_free:PROC
EXTRN	cckd_used:PROC
EXTRN	cfba_used:PROC
EXTRN	cckd_read_trk:PROC
EXTRN	cckd_readahead:PROC
EXTRN	cckd_flush_cache:PROC
EXTRN	cckd_purge_cache:PROC
EXTRN	cckd_writer:PROC
EXTRN	cckd_writer_write:PROC
EXTRN	cckd_get_space:PROC
EXTRN	cckd_rel_space:PROC
EXTRN	cckd_flush_space:PROC
EXTRN	cckd_read_chdr:PROC
EXTRN	cckd_write_chdr:PROC
EXTRN	cckd_read_l1:PROC
EXTRN	cckd_write_l1:PROC
EXTRN	cckd_write_l1ent:PROC
EXTRN	cckd_read_init:PROC
EXTRN	cckd_read_fsp:PROC
EXTRN	cckd_write_fsp:PROC
EXTRN	cckd_read_l2:PROC
EXTRN	cckd_purge_l2:PROC
EXTRN	cckd_steal_l2:PROC
EXTRN	cckd_steal_l2_scan:PROC
EXTRN	cckd_write_l2:PROC
EXTRN	cckd_read_l2ent:PROC
EXTRN	cckd_write_l2ent:PROC
EXTRN	cckd_write_trkimg:PROC
EXTRN	cckd_harden:PROC
EXTRN	cckd_trklen:PROC
EXTRN	cckd_null_trk:PROC
EXTRN	cckd_check_null_trk:PROC
EXTRN	cckd_sf_name:PROC
EXTRN	cckd_sf_init:PROC
EXTRN	cckd_sf_new:PROC
EXTRN	cckd_lock_devchain:PROC
EXTRN	cckd_unlock_devchain:PROC
EXTRN	cckd_gcol:PROC
EXTRN	cckd_gcol_dev:PROC
EXTRN	cckd_gc_state:PROC
EXTRN	cckd_gc_rpt_state:PROC
EXTRN	cckd_gc_percolate:PROC
EXTRN	cckd_find_device_by_devnum:PROC
EXTRN	cckd_uncompress_zlib:PROC
EXTRN	cckd_uncompress_bzip2:PROC
EXTRN	cckd_compress:PROC
EXTRN	cckd_trace:PROC
EXTRN	cckd_print_itrace:PROC
EXTRN	cckd_sf_remove:PROC
EXTRN	cckd_sf_comp:PROC
EXTRN	cckd_sf_chk:PROC
EXTRN	cckd_sf_stats:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	ckd_dasd_device_hndinfo:BYTE
EXTRN	fba_dasd_device_hndinfo:BYTE
EXTRN	__imp_sysblk:BYTE
EXTRN	cckd_dasd_device_hndinfo:BYTE
EXTRN	cfba_dasd_device_hndinfo:BYTE
EXTRN	cckdblk:BYTE
EXTRN	gctab:BYTE
EXTRN	compname:BYTE
EXTRN	empty64_l2:BYTE
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
$SG169627 DB	01H DUP (?)
$SG170687 DB	01H DUP (?)
$SG171118 DB	01H DUP (?)
$SG171123 DB	01H DUP (?)
$SG171134 DB	01H DUP (?)
$SG171401 DB	01H DUP (?)
$SG171424 DB	01H DUP (?)
$SG171437 DB	01H DUP (?)
$SG171444 DB	01H DUP (?)
$SG171490 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$cckd64_dasd_init_handler DD imagerel $LN40
	DD	imagerel $LN40+1434
	DD	imagerel $unwind$cckd64_dasd_init_handler
$pdata$cckd64_dasd_close_device DD imagerel $LN32
	DD	imagerel $LN32+1695
	DD	imagerel $unwind$cckd64_dasd_close_device
$pdata$cckd64_read_track DD imagerel $LN12
	DD	imagerel $LN12+1180
	DD	imagerel $unwind$cckd64_read_track
$pdata$cckd64_update_track DD imagerel $LN10
	DD	imagerel $LN10+640
	DD	imagerel $unwind$cckd64_update_track
$pdata$cfba64_read_block DD imagerel $LN11
	DD	imagerel $LN11+1025
	DD	imagerel $unwind$cfba64_read_block
$pdata$cfba64_write_block DD imagerel $LN10
	DD	imagerel $LN10+385
	DD	imagerel $unwind$cfba64_write_block
$pdata$cckd64_dasd_start DD imagerel $LN17
	DD	imagerel $LN17+848
	DD	imagerel $unwind$cckd64_dasd_start
$pdata$cckd64_dasd_end DD imagerel $LN10
	DD	imagerel $LN10+468
	DD	imagerel $unwind$cckd64_dasd_end
$pdata$cckd64_open DD imagerel $LN18
	DD	imagerel $LN18+1028
	DD	imagerel $unwind$cckd64_open
$pdata$cckd64_close DD imagerel $LN10
	DD	imagerel $LN10+546
	DD	imagerel $unwind$cckd64_close
$pdata$cckd64_read DD imagerel $LN19
	DD	imagerel $LN19+1219
	DD	imagerel $unwind$cckd64_read
$pdata$cckd64_write DD imagerel $LN19
	DD	imagerel $LN19+1227
	DD	imagerel $unwind$cckd64_write
$pdata$cckd64_ftruncate DD imagerel $LN8
	DD	imagerel $LN8+460
	DD	imagerel $unwind$cckd64_ftruncate
$pdata$cckd64_used DD imagerel $LN15
	DD	imagerel $LN15+401
	DD	imagerel $unwind$cckd64_used
$pdata$cfba64_used DD imagerel $LN15
	DD	imagerel $LN15+390
	DD	imagerel $unwind$cfba64_used
$pdata$cckd64_read_trk DD imagerel $LN35
	DD	imagerel $LN35+3065
	DD	imagerel $unwind$cckd64_read_trk
$pdata$cckd64_flush_cache DD imagerel $LN11
	DD	imagerel $LN11+620
	DD	imagerel $unwind$cckd64_flush_cache
$pdata$cckd64_flush_cache_scan DD imagerel $LN10
	DD	imagerel $LN10+310
	DD	imagerel $unwind$cckd64_flush_cache_scan
$pdata$cckd64_flush_cache_all DD imagerel $LN7
	DD	imagerel $LN7+183
	DD	imagerel $unwind$cckd64_flush_cache_all
$pdata$cckd64_purge_cache DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$cckd64_purge_cache
$pdata$cckd64_purge_cache_scan DD imagerel $LN10
	DD	imagerel $LN10+189
	DD	imagerel $unwind$cckd64_purge_cache_scan
$pdata$cckd64_writer_write DD imagerel $LN28
	DD	imagerel $LN28+2215
	DD	imagerel $unwind$cckd64_writer_write
$pdata$cckd64_get_space DD imagerel $LN34
	DD	imagerel $LN34+2331
	DD	imagerel $unwind$cckd64_get_space
$pdata$cckd64_rel_space DD imagerel $LN27
	DD	imagerel $LN27+1696
	DD	imagerel $unwind$cckd64_rel_space
$pdata$cckd64_flush_space DD imagerel $LN25
	DD	imagerel $LN25+2212
	DD	imagerel $unwind$cckd64_flush_space
$pdata$cckd64_read_chdr DD imagerel $LN12
	DD	imagerel $LN12+629
	DD	imagerel $unwind$cckd64_read_chdr
$pdata$cckd64_write_chdr DD imagerel $LN5
	DD	imagerel $LN5+299
	DD	imagerel $unwind$cckd64_write_chdr
$pdata$cckd64_read_l1 DD imagerel $LN18
	DD	imagerel $LN18+883
	DD	imagerel $unwind$cckd64_read_l1
$pdata$cckd64_write_l1 DD imagerel $LN5
	DD	imagerel $LN5+225
	DD	imagerel $unwind$cckd64_write_l1
$pdata$cckd64_write_l1ent DD imagerel $LN5
	DD	imagerel $LN5+230
	DD	imagerel $unwind$cckd64_write_l1ent
$pdata$cckd64_read_init DD imagerel $LN18
	DD	imagerel $LN18+670
	DD	imagerel $unwind$cckd64_read_init
$pdata$cckd64_read_fsp DD imagerel $LN29
	DD	imagerel $LN29+1789
	DD	imagerel $unwind$cckd64_read_fsp
$pdata$cckd64_write_fsp DD imagerel $LN30
	DD	imagerel $LN30+1376
	DD	imagerel $unwind$cckd64_write_fsp
$pdata$cckd64_read_l2 DD imagerel $LN19
	DD	imagerel $LN19+1647
	DD	imagerel $unwind$cckd64_read_l2
$pdata$cckd64_purge_l2 DD imagerel $LN4
	DD	imagerel $LN4+199
	DD	imagerel $unwind$cckd64_purge_l2
$pdata$cckd64_purge_l2_scan DD imagerel $LN11
	DD	imagerel $LN11+259
	DD	imagerel $unwind$cckd64_purge_l2_scan
$pdata$cckd64_steal_l2 DD imagerel $LN7
	DD	imagerel $LN7+253
	DD	imagerel $unwind$cckd64_steal_l2
$pdata$cckd64_write_l2 DD imagerel $LN13
	DD	imagerel $LN13+597
	DD	imagerel $unwind$cckd64_write_l2
$pdata$cckd64_read_l2ent DD imagerel $LN18
	DD	imagerel $LN18+791
	DD	imagerel $unwind$cckd64_read_l2ent
$pdata$cckd64_write_l2ent DD imagerel $LN9
	DD	imagerel $LN9+555
	DD	imagerel $unwind$cckd64_write_l2ent
$pdata$cckd64_read_trkimg DD imagerel $LN10
	DD	imagerel $LN10+512
	DD	imagerel $unwind$cckd64_read_trkimg
$pdata$cckd64_write_trkimg DD imagerel $LN12
	DD	imagerel $LN12+1251
	DD	imagerel $unwind$cckd64_write_trkimg
$pdata$cckd64_harden DD imagerel $LN12
	DD	imagerel $LN12+371
	DD	imagerel $unwind$cckd64_harden
$pdata$cckd64_null_trk DD imagerel $LN18
	DD	imagerel $LN18+1171
	DD	imagerel $unwind$cckd64_null_trk
$pdata$cckd64_check_null_trk DD imagerel $LN11
	DD	imagerel $LN11+367
	DD	imagerel $unwind$cckd64_check_null_trk
$pdata$cckd64_cchh DD imagerel $LN44
	DD	imagerel $LN44+2775
	DD	imagerel $unwind$cckd64_cchh
$pdata$cckd64_validate DD imagerel $LN23
	DD	imagerel $LN23+1661
	DD	imagerel $unwind$cckd64_validate
$pdata$cckd64_sf_init DD imagerel $LN46
	DD	imagerel $LN46+1948
	DD	imagerel $unwind$cckd64_sf_init
$pdata$cckd64_sf_new DD imagerel $LN21
	DD	imagerel $LN21+1674
	DD	imagerel $unwind$cckd64_sf_new
$pdata$cckd64_gcstart DD imagerel $LN13
	DD	imagerel $LN13+791
	DD	imagerel $unwind$cckd64_gcstart
$pdata$cckd64_gcol_dev DD imagerel $LN20
	DD	imagerel $LN20+1091
	DD	imagerel $unwind$cckd64_gcol_dev
$pdata$cckd64_gc_state DD imagerel $LN15
	DD	imagerel $LN15+457
	DD	imagerel $unwind$cckd64_gc_state
$pdata$cckd64_gc_rpt_state DD imagerel $LN24
	DD	imagerel $LN24+880
	DD	imagerel $unwind$cckd64_gc_rpt_state
$pdata$cckd64_gc_percolate DD imagerel $LN95
	DD	imagerel $LN95+5250
	DD	imagerel $unwind$cckd64_gc_percolate
$pdata$cckd64_uncompress DD imagerel $LN27
	DD	imagerel $LN27+2017
	DD	imagerel $unwind$cckd64_uncompress
$pdata$cckd64_sf_add DD imagerel $LN38
	DD	imagerel $LN38+1866
	DD	imagerel $unwind$cckd64_sf_add
$pdata$cckd64_sf_remove DD imagerel $LN111
	DD	imagerel $LN111+6603
	DD	imagerel $unwind$cckd64_sf_remove
$pdata$cckd64_sf_comp DD imagerel $LN27
	DD	imagerel $LN27+1341
	DD	imagerel $unwind$cckd64_sf_comp
$pdata$cckd64_sf_chk DD imagerel $LN27
	DD	imagerel $LN27+1436
	DD	imagerel $unwind$cckd64_sf_chk
$pdata$cckd64_sf_stats DD imagerel $LN80
	DD	imagerel $LN80+4336
	DD	imagerel $unwind$cckd64_sf_stats
$pdata$cckd64_gc_perc_error DD imagerel cckd64_gc_perc_error
	DD	imagerel cckd64_gc_perc_error+94
	DD	imagerel $unwind$cckd64_gc_perc_error
$pdata$cckd64_gc_perc_space_error DD imagerel cckd64_gc_perc_space_error
	DD	imagerel cckd64_gc_perc_space_error+722
	DD	imagerel $unwind$cckd64_gc_perc_space_error
pdata	ENDS
_DATA	SEGMENT
	ORG $+2
$SG169527 DB	'CCKDBLK ', 00H
	ORG $+3
$SG169528 DB	'ext', 00H
$SG169530 DB	'cckddasd64.c:55', 00H
$SG169531 DB	'&cckd->cckdiolock', 00H
	ORG $+2
$SG169542 DB	'E', 00H
	ORG $+2
$SG169532 DB	'&cckd->cckdiolock %1d:%04X', 00H
	ORG $+1
$SG169589 DB	'W', 00H
	ORG $+2
$SG169533 DB	'cckddasd64.c:59', 00H
$SG169534 DB	'&cckd->filelock', 00H
$SG169535 DB	'&cckd->filelock %1d:%04X', 00H
	ORG $+3
$SG169595 DB	'newbuf', 00H
	ORG $+1
$SG169600 DB	'l1', 00H
	ORG $+1
$SG169536 DB	'cckddasd64.c:63', 00H
$SG169537 DB	'cckddasd64.c:66', 00H
$SG169548 DB	'cckddasd64.c:102', 00H
	ORG $+7
$SG169543 DB	'HHC00300%s %1d:%04X CCKD file: error initializing shadow'
	DB	' files', 0aH, 00H
$SG169544 DB	'cckd64_dasd_init_handler', 00H
	ORG $+3
$SG169607 DB	'ext', 00H
$SG169545 DB	'cckddasd64.c', 00H
	ORG $+3
$SG169577 DB	'cckddasd64.c:138', 00H
	ORG $+3
$SG169671 DB	'open()', 00H
	ORG $+1
$SG169672 DB	'E', 00H
	ORG $+2
$SG169578 DB	'cckddasd64.c:142', 00H
	ORG $+3
$SG169692 DB	'E', 00H
	ORG $+2
$SG169579 DB	'cckddasd64.c:144', 00H
	ORG $+3
$SG169716 DB	'E', 00H
	ORG $+2
$SG169580 DB	'cckddasd64.c:146', 00H
	ORG $+3
$SG169723 DB	'read()', 00H
	ORG $+1
$SG169724 DB	'E', 00H
	ORG $+2
$SG169581 DB	'cckddasd64.c:149', 00H
	ORG $+3
$SG169729 DB	'read()', 00H
	ORG $+1
$SG169730 DB	'E', 00H
	ORG $+2
$SG169583 DB	'cckddasd64.c:157', 00H
	ORG $+3
$SG169753 DB	'E', 00H
	ORG $+2
$SG169587 DB	'closing device while wrpending=%d cckdioact=%d', 00H
	ORG $+1
$SG169588 DB	'cckd64_dasd_close_device', 00H
	ORG $+7
$SG169592 DB	'cckddasd64.c', 00H
	ORG $+3
$SG169593 DB	'cckddasd64.c:177', 00H
	ORG $+7
$SG169590 DB	'HHC00381%s %1d:%04X CCKD file %s: closing device while w'
	DB	'rpending=%d cckdioact=%d', 0aH, 00H
	ORG $+2
$SG169761 DB	'E', 00H
	ORG $+2
$SG169591 DB	'cckd64_dasd_close_device', 00H
	ORG $+3
$SG169767 DB	'E', 00H
	ORG $+2
$SG169596 DB	'cckddasd64.c:185', 00H
	ORG $+3
$SG169783 DB	'E', 00H
	ORG $+2
$SG169599 DB	'cckddasd64.c:203', 00H
	ORG $+3
$SG170003 DB	'write', 00H
	ORG $+2
$SG170059 DB	'I', 00H
	ORG $+2
$SG169604 DB	'cckddasd64.c:228', 00H
	ORG $+3
$SG170069 DB	'E', 00H
	ORG $+2
$SG169605 DB	'cckddasd64.c:231', 00H
	ORG $+3
$SG170180 DB	'I', 00H
	ORG $+2
$SG169606 DB	'cckddasd64.c:232', 00H
	ORG $+3
$SG170190 DB	'E', 00H
	ORG $+2
$SG169623 DB	'start i/o file[%d] bufcur %d cache[%d]', 00H
	ORG $+1
$SG169624 DB	'cckd64_dasd_start', 00H
	ORG $+2
$SG170251 DB	'E', 00H
	ORG $+2
$SG169625 DB	'cckddasd64.c:278', 00H
	ORG $+3
$SG170315 DB	'ifb', 00H
$SG169628 DB	'start i/o waiting for merge%s', 00H
	ORG $+2
$SG169629 DB	'cckd64_dasd_start', 00H
	ORG $+2
$SG170436 DB	'l1', 00H
	ORG $+1
$SG169630 DB	'cckddasd64.c:285', 00H
	ORG $+3
$SG170438 DB	'l1', 00H
	ORG $+1
$SG169636 DB	'cckddasd64.c:310', 00H
	ORG $+3
$SG170507 DB	'E', 00H
	ORG $+2
$SG169637 DB	'cckddasd64.c:318', 00H
	ORG $+3
$SG170550 DB	'ifb', 00H
$SG169644 DB	'end i/o bufcur %d cache[%d] waiters %d', 00H
	ORG $+1
$SG169645 DB	'cckd64_dasd_end', 00H
$SG169646 DB	'cckddasd64.c:351', 00H
	ORG $+3
$SG170552 DB	'ifb', 00H
$SG169652 DB	'cckddasd64.c:367', 00H
	ORG $+3
$SG170559 DB	'fsp', 00H
$SG169653 DB	'cckddasd64.c:369', 00H
	ORG $+7
$SG169673 DB	'HHC00301%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s: %s', 0aH, 00H
$SG169674 DB	'cckd64_open', 00H
$SG170563 DB	'fsp', 00H
$SG169675 DB	'cckddasd64.c', 00H
	ORG $+3
$SG169676 DB	'file[%d] fd[%d] open %s error flags %8.8x mode %8.8x', 00H
	ORG $+3
$SG169677 DB	'cckd64_open', 00H
$SG170611 DB	'fsp', 00H
$SG169678 DB	'file[%d] fd[%d] open %s, flags %8.8x mode %8.8x', 00H
$SG169679 DB	'cckd64_open', 00H
$SG170615 DB	'fsp', 00H
$SG169687 DB	'file[%d] fd[%d] close %s', 00H
	ORG $+3
$SG170618 DB	'ifb', 00H
$SG169688 DB	'cckd64_close', 00H
	ORG $+3
$SG169691 DB	'close()', 00H
$SG169693 DB	'HHC00301%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s: %s', 0aH, 00H
$SG169694 DB	'cckd64_close', 00H
	ORG $+3
$SG169695 DB	'cckddasd64.c', 00H
	ORG $+3
$SG169712 DB	'file[%d] fd[%d] read, off 0x%16.16llx len %d', 00H
	ORG $+3
$SG169713 DB	'cckd64_read', 00H
$SG170975 DB	'trk', 00H
$SG169715 DB	'lseek()', 00H
$SG169728 DB	'read incomplete: read %d, expected %d', 00H
	ORG $+2
$SG169717 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169718 DB	'cckd64_read', 00H
$SG171037 DB	'E', 00H
	ORG $+2
$SG169719 DB	'cckddasd64.c', 00H
	ORG $+3
$SG169749 DB	'file[%d] fd[%d] write, off 0x%16.16llx len %d', 00H
	ORG $+2
$SG169752 DB	'lseek()', 00H
$SG169725 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169726 DB	'cckd64_read', 00H
$SG171047 DB	'E', 00H
	ORG $+2
$SG169727 DB	'cckddasd64.c', 00H
	ORG $+3
$SG169760 DB	'write()', 00H
$SG169731 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169732 DB	'cckd64_read', 00H
$SG171055 DB	'trk', 00H
$SG169733 DB	'cckddasd64.c', 00H
	ORG $+3
$SG169750 DB	'cckd64_write', 00H
	ORG $+3
$SG169765 DB	'write incomplete: write %d, expected %d', 00H
$SG169754 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169755 DB	'cckd64_write', 00H
	ORG $+3
$SG169756 DB	'cckddasd64.c', 00H
	ORG $+3
$SG169766 DB	'write()', 00H
$SG169762 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169763 DB	'cckd64_write', 00H
	ORG $+3
$SG169764 DB	'cckddasd64.c', 00H
	ORG $+3
$SG169780 DB	'cckd64_ftruncate', 00H
	ORG $+7
$SG169768 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169769 DB	'cckd64_write', 00H
	ORG $+3
$SG169770 DB	'cckddasd64.c', 00H
	ORG $+3
$SG169779 DB	'file[%d] fd[%d] ftruncate, off 0x%16.16llx', 00H
	ORG $+1
$SG171056 DB	'blk', 00H
$SG169782 DB	'ftruncate()', 00H
$SG170002 DB	'read', 00H
	ORG $+7
$SG169784 DB	'HHC00302%s %1d:%04X CCKD file[%d] %s: error in function '
	DB	'%s at offset 0x%16.16llX: %s', 0aH, 00H
	ORG $+2
$SG169785 DB	'cckd64_ftruncate', 00H
	ORG $+3
$SG170976 DB	'blkgrp', 00H
	ORG $+1
$SG171057 DB	'trk', 00H
$SG169786 DB	'cckddasd64.c', 00H
	ORG $+3
$SG169808 DB	'read  trk   %d uncompressed len %d', 00H
	ORG $+1
$SG171058 DB	'blk', 00H
$SG169809 DB	'cckd64_read_track', 00H
	ORG $+2
$SG171059 DB	'E', 00H
	ORG $+2
$SG169811 DB	'asynchronous', 00H
	ORG $+3
$SG169812 DB	'read  trk   %d (%s)', 00H
$SG171063 DB	'trk', 00H
$SG169813 DB	'cckd64_read_track', 00H
	ORG $+2
$SG171064 DB	'blk', 00H
$SG169839 DB	'updt  trk   %d offset %lld length %d', 00H
	ORG $+3
$SG169840 DB	'cckd64_update_track', 00H
$SG171065 DB	'trk', 00H
$SG169862 DB	'cckddasd64.c:736', 00H
	ORG $+3
$SG171066 DB	'blk', 00H
$SG169866 DB	'cckddasd64.c:753', 00H
	ORG $+3
$SG171067 DB	'E', 00H
	ORG $+2
$SG169896 DB	'read bkgrp  %d uncompressed len %d', 00H
	ORG $+1
$SG171111 DB	'trk', 00H
$SG169897 DB	'cfba64_read_block', 00H
	ORG $+2
$SG171112 DB	'blkgrp', 00H
	ORG $+1
$SG171173 DB	'E', 00H
	ORG $+2
$SG169898 DB	'asynchronous', 00H
	ORG $+3
$SG169899 DB	'read blkgrp  %d (%s)', 00H
	ORG $+3
$SG169900 DB	'cfba64_read_block', 00H
	ORG $+2
$SG171182 DB	'E', 00H
	ORG $+2
$SG169948 DB	'cckddasd64.c:907', 00H
	ORG $+3
$SG171193 DB	'E', 00H
	ORG $+2
$SG169952 DB	'cckddasd64.c:924', 00H
	ORG $+3
$SG171220 DB	'(none)', 00H
	ORG $+1
$SG171224 DB	'E', 00H
	ORG $+2
$SG169989 DB	'%d rdtrk     %d', 00H
$SG169990 DB	'cckd64_read_trk', 00H
$SG169992 DB	'cckddasd64.c:959', 00H
	ORG $+3
$SG171229 DB	'E', 00H
	ORG $+2
$SG169999 DB	'cckddasd64.c:995', 00H
	ORG $+3
$SG171237 DB	'l1', 00H
	ORG $+1
$SG170000 DB	'%d rdtrk[%d] %d cache hit buf %p:%2.2x%2.2x%2.2x%2.2x%2.'
	DB	'2x', 00H
	ORG $+1
$SG171239 DB	'l1', 00H
	ORG $+1
$SG170001 DB	'cckd64_read_trk', 00H
$SG170004 DB	'%d rdtrk[%d] %d waiting for %s', 00H
	ORG $+1
$SG170005 DB	'cckd64_read_trk', 00H
$SG170006 DB	'cckddasd64.c:1016', 00H
	ORG $+2
$SG171259 DB	'I', 00H
	ORG $+2
$SG170007 DB	'%d rdtrk[%d] %d io wait complete', 00H
	ORG $+3
$SG171263 DB	'I', 00H
	ORG $+2
$SG170008 DB	'cckd64_read_trk', 00H
$SG170009 DB	'cckddasd64.c:1023', 00H
	ORG $+2
$SG171268 DB	'E', 00H
	ORG $+2
$SG170011 DB	'%d rdtrk[%d] %d cache miss', 00H
	ORG $+1
$SG171275 DB	'W', 00H
	ORG $+2
$SG170012 DB	'cckd64_read_trk', 00H
$SG170014 DB	'%d rdtrk[%d] %d no available cache entry', 00H
	ORG $+3
$SG171284 DB	'(null)', 00H
	ORG $+1
$SG171285 DB	'E', 00H
	ORG $+2
$SG170015 DB	'cckd64_read_trk', 00H
$SG170017 DB	'cckddasd64.c:1044', 00H
	ORG $+2
$SG171290 DB	'I', 00H
	ORG $+2
$SG170019 DB	'cckddasd64.c:1052', 00H
	ORG $+2
$SG171386 DB	'I', 00H
	ORG $+2
$SG170021 DB	'%d rdtrk[%d] %d dropping %4.4X:%d from cache', 00H
	ORG $+3
$SG170022 DB	'cckd64_read_trk', 00H
$SG170025 DB	'%d rdtrk[%d] %d buf %p len %d', 00H
	ORG $+2
$SG170026 DB	'cckd64_read_trk', 00H
$SG170028 DB	'cckddasd64.c:1089', 00H
	ORG $+2
$SG171390 DB	'I', 00H
	ORG $+2
$SG170031 DB	'cckddasd64.c:1099', 00H
	ORG $+2
$SG171396 DB	'W', 00H
	ORG $+2
$SG170032 DB	'cckddasd64.c:1103', 00H
	ORG $+2
$SG171409 DB	'W', 00H
	ORG $+2
$SG170033 DB	'cckddasd64.c:1107', 00H
	ORG $+2
$SG171419 DB	'E', 00H
	ORG $+2
$SG170035 DB	'%d rdtrk[%d] %d signalling read complete', 00H
	ORG $+3
$SG171400 DB	'force', 00H
	ORG $+2
$SG171426 DB	'E', 00H
	ORG $+2
$SG170036 DB	'cckd64_read_trk', 00H
$SG170037 DB	'cckddasd64.c:1118', 00H
	ORG $+2
$SG171439 DB	'E', 00H
	ORG $+2
$SG170038 DB	'cckddasd64.c:1121', 00H
	ORG $+2
$SG171446 DB	'E', 00H
	ORG $+2
$SG170040 DB	'%d rdtrk[%d] %d complete buf %p:%2.2x%2.2x%2.2x%2.2x%2.2'
	DB	'x', 00H
	ORG $+2
$SG171477 DB	'l1', 00H
	ORG $+1
$SG170041 DB	'cckd64_read_trk', 00H
$SG170050 DB	'cckddasd64.c:1155', 00H
	ORG $+2
$SG171479 DB	'merged', 00H
	ORG $+1
$SG171482 DB	'I', 00H
	ORG $+2
$SG170054 DB	'cckddasd64.c:1164', 00H
	ORG $+2
$SG171496 DB	'E', 00H
	ORG $+2
$SG170058 DB	'cckd_writer()', 00H
	ORG $+2
$SG170060 DB	'HHC00107%s Starting thread %s, active=%d, started=%d, ma'
	DB	'x=%d', 0aH, 00H
	ORG $+2
$SG170061 DB	'cckd64_flush_cache', 00H
	ORG $+1
$SG171500 DB	'E', 00H
	ORG $+2
$SG170062 DB	'cckddasd64.c', 00H
	ORG $+3
$SG170063 DB	'cckddasd64.c:1176', 00H
	ORG $+2
$SG171523 DB	'I', 00H
	ORG $+2
$SG170064 DB	'cckddasd64.c:1178', 00H
	ORG $+2
$SG171527 DB	'I', 00H
	ORG $+2
$SG170065 DB	'cckd_writer', 00H
$SG171533 DB	'W', 00H
	ORG $+2
$SG170066 DB	'cckddasd64.c:1180', 00H
	ORG $+2
$SG171540 DB	'W', 00H
	ORG $+2
$SG170068 DB	'cckd_writer()', 00H
	ORG $+2
$SG170071 DB	'cckd64_flush_cache', 00H
	ORG $+5
$SG170070 DB	'HHC00106%s Error in function create_thread() for %s %d o'
	DB	'f %d: %s', 0aH, 00H
	ORG $+2
$SG171572 DB	'I', 00H
	ORG $+2
$SG170072 DB	'cckddasd64.c', 00H
	ORG $+3
$SG170073 DB	'cckddasd64.c:1193', 00H
	ORG $+2
$SG171576 DB	'I', 00H
	ORG $+2
$SG170096 DB	'flush file[%d] cache[%d] %4.4X trk %d', 00H
	ORG $+2
$SG170097 DB	'cckd64_flush_cache_scan', 00H
$SG170105 DB	'cckddasd64.c:1227', 00H
	ORG $+2
$SG171582 DB	'W', 00H
	ORG $+2
$SG170107 DB	'cckddasd64.c:1230', 00H
	ORG $+2
$SG171589 DB	'W', 00H
	ORG $+2
$SG170133 DB	'purge cache[%d] %4.4X trk %d purged', 00H
$SG171631 DB	'  ', 00H
	ORG $+1
$SG170134 DB	'cckd64_purge_cache_scan', 00H
$SG170162 DB	'%d wrtrk[%d] %d len %d buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x', 00H
$SG170163 DB	'cckd64_writer_write', 00H
$SG171633 DB	'ro', 00H
	ORG $+1
$SG170168 DB	'%d wrtrk[%d] %d comp %s parm %d', 00H
$SG170169 DB	'cckd64_writer_write', 00H
$SG171635 DB	'rd', 00H
	ORG $+1
$SG170170 DB	'%d wrtrk[%d] %d compressed length %d', 00H
	ORG $+3
$SG170171 DB	'cckd64_writer_write', 00H
$SG171637 DB	'rw', 00H
	ORG $+1
$SG170172 DB	'cckddasd64.c:1351', 00H
	ORG $+2
$SG171640 DB	'I', 00H
	ORG $+2
$SG170174 DB	'cckddasd64.c:1363', 00H
	ORG $+2
$SG171644 DB	'I', 00H
	ORG $+2
$SG170175 DB	'cckddasd64.c:1366', 00H
	ORG $+2
$SG171650 DB	'W', 00H
	ORG $+2
$SG170179 DB	'cckd_gcol()', 00H
$SG171656 DB	'E', 00H
	ORG $+2
$SG170181 DB	'HHC00107%s Starting thread %s, active=%d, started=%d, ma'
	DB	'x=%d', 0aH, 00H
	ORG $+2
$SG170182 DB	'cckd64_writer_write', 00H
$SG171662 DB	'I', 00H
	ORG $+2
$SG170183 DB	'cckddasd64.c', 00H
	ORG $+3
$SG170184 DB	'cckddasd64.c:1380', 00H
	ORG $+2
$SG171668 DB	'I', 00H
	ORG $+2
$SG170185 DB	'cckddasd64.c:1382', 00H
	ORG $+2
$SG171672 DB	'I', 00H
	ORG $+2
$SG170186 DB	'cckd_gcol', 00H
	ORG $+2
$SG171676 DB	'64', 00H
	ORG $+1
$SG170187 DB	'cckddasd64.c:1384', 00H
	ORG $+2
$SG171677 DB	'32', 00H
	ORG $+1
$SG170189 DB	'cckd_gcol()', 00H
	ORG $+4
$SG170191 DB	'HHC00106%s Error in function create_thread() for %s %d o'
	DB	'f %d: %s', 0aH, 00H
	ORG $+2
$SG171678 DB	'I', 00H
	ORG $+2
$SG170192 DB	'cckd64_writer_write', 00H
$SG171684 DB	'I', 00H
	ORG $+2
$SG170193 DB	'cckddasd64.c', 00H
	ORG $+3
$SG170194 DB	'cckddasd64.c:1396', 00H
	ORG $+2
$SG171688 DB	'I', 00H
	ORG $+2
$SG170195 DB	'cckddasd64.c:1398', 00H
	ORG $+2
$SG171692 DB	'64', 00H
	ORG $+1
$SG170198 DB	'writer[%d] cache[%2.2d] %d signalling write complete', 00H
	ORG $+3
$SG170199 DB	'cckd64_writer_write', 00H
$SG171693 DB	'32', 00H
	ORG $+1
$SG170200 DB	'cckddasd64.c:1418', 00H
	ORG $+2
$SG171694 DB	'I', 00H
	ORG $+2
$SG170201 DB	'cckddasd64.c:1421', 00H
	ORG $+2
$SG171699 DB	'I', 00H
	ORG $+2
$SG170202 DB	'%d wrtrk[%2.2d] %d complete flags:%8.8x', 00H
$SG170203 DB	'cckd64_writer_write', 00H
$SG171703 DB	'64', 00H
	ORG $+1
$SG170245 DB	'get_space len %d largest %lld flags 0x%2.2x', 00H
$SG171704 DB	'32', 00H
	ORG $+1
$SG170246 DB	'cckd64_get_space', 00H
	ORG $+7
$SG170253 DB	'cckd64_get_space', 00H
	ORG $+7
$SG170252 DB	'HHC00304%s %1d:%04X CCKD file[%d] %s: get space error, s'
	DB	'ize exceeds %lldM', 0aH, 00H
	ORG $+1
$SG171705 DB	'I', 00H
	ORG $+2
$SG170254 DB	'cckddasd64.c', 00H
	ORG $+3
$SG170255 DB	'get_space atend 0x%16.16llx len %d', 00H
	ORG $+1
$SG171729 DB	'I', 00H
	ORG $+2
$SG170256 DB	'cckd64_get_space', 00H
	ORG $+3
$SG171402 DB	'merge', 00H
	ORG $+2
$SG171739 DB	'E', 00H
	ORG $+2
$SG170272 DB	'get_space found 0x%16.16llx len %d size %d', 00H
	ORG $+1
$SG171755 DB	'64', 00H
	ORG $+1
$SG170273 DB	'cckd64_get_space', 00H
	ORG $+3
$SG171756 DB	'W', 00H
	ORG $+2
$SG170307 DB	'rel_space offset 0x%16.16llx len %d size %d', 00H
$SG171761 DB	'64', 00H
	ORG $+1
$SG170308 DB	'cckd64_rel_space', 00H
	ORG $+3
$SG171762 DB	'W', 00H
	ORG $+2
$SG170340 DB	'flush_space nbr %lld', 00H
	ORG $+3
$SG170341 DB	'cckd64_flush_space', 00H
	ORG $+1
$SG171767 DB	'64', 00H
	ORG $+1
$SG170350 DB	'rel_flush_space nbr %lld (after merge)', 00H
	ORG $+1
$SG170351 DB	'cckd64_flush_space', 00H
	ORG $+1
$SG171768 DB	'I', 00H
	ORG $+2
$SG170353 DB	'file[%d] rel_flush_space atend 0x%16.16llx len %lld', 00H
$SG171866 DB	'E', 00H
	ORG $+2
$SG170354 DB	'cckd64_flush_space', 00H
	ORG $+1
$SG171951 DB	'64', 00H
	ORG $+1
$SG170371 DB	'file[%d] read_chdr', 00H
	ORG $+1
$SG171952 DB	'I', 00H
	ORG $+2
$SG170372 DB	'cckd64_read_chdr', 00H
	ORG $+3
$SG171813 DB	'newbuf', 00H
	ORG $+1
$SG171997 DB	'64', 00H
	ORG $+1
$SG170391 DB	'file[%d] write_chdr', 00H
$SG171998 DB	'I', 00H
	ORG $+2
$SG170392 DB	'cckd64_write_chdr', 00H
	ORG $+2
$SG172026 DB	'64', 00H
	ORG $+1
$SG170434 DB	'file[%d] read_l1 offset 0x%llx', 00H
	ORG $+1
$SG170435 DB	'cckd64_read_l1', 00H
	ORG $+1
$SG170464 DB	'file[%d] write_l1 0x%llx len %d', 00H
$SG170465 DB	'cckd64_write_l1', 00H
$SG170484 DB	'file[%d] write_l1ent[%d] , 0x%16.16llx', 00H
	ORG $+1
$SG170485 DB	'cckd64_write_l1ent', 00H
	ORG $+1
$SG172027 DB	'I', 00H
	ORG $+2
$SG170497 DB	'file[%d] read_init', 00H
	ORG $+1
$SG172089 DB	'E', 00H
	ORG $+2
$SG170498 DB	'cckd64_read_init', 00H
	ORG $+3
$SG172075 DB	'newbuf', 00H
	ORG $+1
$SG172094 DB	'E', 00H
	ORG $+2
$SG170508 DB	'HHC00305%s %1d:%04X CCKD file[%d] %s: device header id e'
	DB	'rror', 0aH, 00H
	ORG $+2
$SG170509 DB	'cckd64_read_init', 00H
	ORG $+7
$SG170510 DB	'cckddasd64.c', 00H
	ORG $+3
$SG170548 DB	'file[%d] read_fsp number %lld', 00H
	ORG $+2
$SG170549 DB	'cckd64_read_fsp', 00H
$SG170557 DB	'FREE_BLK', 00H
	ORG $+7
$SG170602 DB	'file[%d] write_fsp number %lld', 00H
	ORG $+1
$SG170603 DB	'cckd64_write_fsp', 00H
	ORG $+7
$SG170614 DB	'FREE_BLK', 00H
	ORG $+7
$SG170657 DB	'file[%d] read_l2 %d active %d %d %d', 00H
	ORG $+4
$SG170658 DB	'cckd64_read_l2', 00H
	ORG $+1
$SG170662 DB	'l2[%d,%d] cache[%d] hit', 00H
$SG170663 DB	'cckd64_read_l2', 00H
	ORG $+1
$SG170664 DB	'l2[%d,%d] cache[%d] miss', 00H
	ORG $+7
$SG170665 DB	'cckd64_read_l2', 00H
	ORG $+1
$SG170671 DB	'l2[%d,%d] cache[%d] null fmt[%d]', 00H
	ORG $+7
$SG170672 DB	'cckd64_read_l2', 00H
	ORG $+1
$SG170675 DB	'l2[%d,%d] cache[%d] null 0xff', 00H
	ORG $+2
$SG170676 DB	'cckd64_read_l2', 00H
	ORG $+1
$SG170679 DB	'file[%d] cache[%d] l2[%d] read offset 0x%16.16llx', 00H
	ORG $+6
$SG170680 DB	'cckd64_read_l2', 00H
	ORG $+1
$SG170688 DB	'purge_l2%s', 00H
	ORG $+5
$SG170689 DB	'cckd64_purge_l2', 00H
$SG170715 DB	'purge l2cache[%d] %4.4X sfx %hd ix %d purged', 00H
	ORG $+3
$SG170716 DB	'cckd64_purge_l2_scan', 00H
	ORG $+3
$SG170762 DB	'file[%d] write_l2 %d', 00H
	ORG $+3
$SG170763 DB	'cckd64_write_l2', 00H
$SG170799 DB	'file[%d] l2[%d,%d] trk[%d] read_l2ent 0x%llx', 00H
	ORG $+3
$SG170800 DB	'cckd64_read_l2ent', 00H
	ORG $+6
$SG170804 DB	'file[%d] l2[%d,%d] trk[%d] read_l2ent 0x%llx %hd %hd', 00H
	ORG $+3
$SG170805 DB	'cckd64_read_l2ent', 00H
	ORG $+6
$SG170832 DB	'file[%d] l2[%d,%d] trk[%d] write_l2ent 0x%llx %hd %hd', 00H
	ORG $+2
$SG170833 DB	'cckd64_write_l2ent', 00H
	ORG $+5
$SG170851 DB	'trk[%d] read_trkimg', 00H
	ORG $+4
$SG170852 DB	'cckd64_read_trkimg', 00H
	ORG $+5
$SG170891 DB	'file[%d] trk[%d] write_trkimg len %d buf %p:%2.2x%2.2x%2'
	DB	'.2x%2.2x%2.2x', 00H
	ORG $+2
$SG170892 DB	'cckd64_write_trkimg', 00H
	ORG $+4
$SG170895 DB	'file[%d] trk[%d] write_trkimg oldl2 0x%llx %hd %hd', 00H
	ORG $+5
$SG170896 DB	'cckd64_write_trkimg', 00H
	ORG $+4
$SG170912 DB	'file[%d] harden', 00H
$SG170913 DB	'cckd64_harden', 00H
	ORG $+2
$SG170977 DB	'null_trk %s %d format %d size %d', 00H
	ORG $+7
$SG170978 DB	'cckd64_null_trk', 00H
$SG171221 DB	'file[%d] sf_new %s', 00H
	ORG $+5
$SG171038 DB	'HHC00307%s %1d:%04X CCKD file[%d] %s: invalid byte 0 trk'
	DB	' %d, buf %2.2x%2.2x%2.2x%2.2x%2.2x', 0aH, 00H
	ORG $+4
$SG171039 DB	'cckd64_cchh', 00H
	ORG $+4
$SG171040 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171048 DB	'HHC00308%s %1d:%04X CCKD file[%d] %s: invalid byte 0 blk'
	DB	'grp %d, buf %2.2x%2.2x%2.2x%2.2x%2.2x', 0aH, 00H
	ORG $+1
$SG171049 DB	'cckd64_cchh', 00H
	ORG $+4
$SG171050 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171060 DB	'HHC00309%s %1d:%04X CCKD file[%d] %s: invalid %s hdr %s '
	DB	'%d: %s compression unsupported', 0aH, 00H
$SG171061 DB	'cckd64_cchh', 00H
	ORG $+4
$SG171062 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171114 DB	'cckd64_validate', 00H
$SG171225 DB	'HHC00313%s %1d:%04X CCKD file[%d]: no shadow file name', 0aH
	DB	00H
$SG171068 DB	'HHC00310%s %1d:%04X CCKD file[%d] %s: invalid %s hdr %s '
	DB	'%d buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x', 0aH, 00H
	ORG $+3
$SG171069 DB	'cckd64_cchh', 00H
	ORG $+4
$SG171070 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171113 DB	'validating %s %d len %d %2.2x%2.2x%2.2x%2.2x%2.2x %2.2x%'
	DB	'2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x', 00H
	ORG $+5
$SG171119 DB	'validation failed: bad length%s', 00H
$SG171120 DB	'cckd64_validate', 00H
$SG171124 DB	'validation failed: bad r0%s', 00H
	ORG $+4
$SG171125 DB	'cckd64_validate', 00H
$SG171129 DB	'validation failed: bad r%d %2.2x%2.2x%2.2x%2.2x%2.2x%2.2'
	DB	'x%2.2x%2.2x', 00H
	ORG $+4
$SG171130 DB	'cckd64_validate', 00H
$SG171135 DB	'validation failed: no eot%s', 00H
	ORG $+4
$SG171136 DB	'cckd64_validate', 00H
$SG171260 DB	'HHC00315%s %1d:%04X CCKD file: adding shadow files...', 0aH
	DB	00H
	ORG $+1
$SG171174 DB	'HHC00311%s %1d:%04X CCKD file[%d] %s: shadow file name c'
	DB	'ollides with %1d:%04X file[%d] %s', 0aH, 00H
	ORG $+5
$SG171175 DB	'cckd64_sf_init', 00H
	ORG $+1
$SG171176 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171183 DB	'HHC00351%s %1d:%04X CCKD file[%d] %s: cckd/64 format dif'
	DB	'fers from base', 0aH, 00H
$SG171184 DB	'cckd64_sf_init', 00H
	ORG $+1
$SG171185 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171195 DB	'cckd64_sf_init', 00H
	ORG $+1
$SG171264 DB	'HHC00316%s CCKD file number of devices processed: %d', 0aH
	DB	00H
	ORG $+2
$SG171194 DB	'HHC00312%s %1d:%04X CCKD file[%d] %s: error re-opening r'
	DB	'eadonly: %s', 0aH, 00H
	ORG $+3
$SG171196 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171222 DB	'cckd64_sf_new', 00H
	ORG $+2
$SG171226 DB	'cckd64_sf_new', 00H
	ORG $+2
$SG171227 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171231 DB	'cckd64_sf_new', 00H
	ORG $+2
$SG171272 DB	'cckddasd64.c:3384', 00H
	ORG $+6
$SG171230 DB	'HHC00314%s %1d:%04X CCKD file[%d] %s:  max shadow files '
	DB	'exceeded', 0aH, 00H
	ORG $+6
$SG171232 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171261 DB	'cckd64_sf_add', 00H
	ORG $+2
$SG171262 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171265 DB	'cckd64_sf_add', 00H
	ORG $+2
$SG171266 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171269 DB	'HHC00317%s %1d:%04X CCKD file: device is not a cckd devi'
	DB	'ce', 0aH, 00H
	ORG $+4
$SG171270 DB	'cckd64_sf_add', 00H
	ORG $+2
$SG171271 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171274 DB	'cckddasd64.c:3387', 00H
	ORG $+6
$SG171276 DB	'HHC00318%s %1d:%04X CCKD file[%d] %s: error adding shado'
	DB	'w file, sf command busy on device', 0aH, 00H
	ORG $+5
$SG171277 DB	'cckd64_sf_add', 00H
	ORG $+2
$SG171278 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171280 DB	'cckddasd64.c:3396', 00H
	ORG $+6
$SG171281 DB	'cckddasd64.c:3402', 00H
	ORG $+6
$SG171282 DB	'cckddasd64.c:3405', 00H
	ORG $+6
$SG171287 DB	'cckd64_sf_add', 00H
	ORG $+2
$SG171294 DB	'cckddasd64.c:3428', 00H
	ORG $+6
$SG171286 DB	'HHC00319%s %1d:%04X CCKD file[%d] %s: error adding shado'
	DB	'w file', 0aH, 00H
$SG171288 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171291 DB	'HHC00320%s %1d:%04X CCKD file[%d] %s: shadow file succes'
	DB	'fully added', 0aH, 00H
	ORG $+3
$SG171292 DB	'cckd64_sf_add', 00H
	ORG $+2
$SG171293 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171295 DB	'cckddasd64.c:3430', 00H
	ORG $+6
$SG171297 DB	'cckddasd64.c:3433', 00H
	ORG $+6
$SG171298 DB	'cckddasd64.c:3434', 00H
	ORG $+6
$SG171387 DB	'HHC00321%s %1d:%04X CCKD file: merging shadow files...', 0aH
	DB	00H
$SG171388 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171389 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171391 DB	'HHC00316%s CCKD file number of devices processed: %d', 0aH
	DB	00H
	ORG $+2
$SG171392 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171393 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171397 DB	'HHC00317%s %1d:%04X CCKD file: device is not a cckd devi'
	DB	'ce', 0aH, 00H
	ORG $+4
$SG171398 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171399 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171403 DB	'nomerge', 00H
$SG171404 DB	'merge starting: %s %s', 00H
	ORG $+2
$SG171405 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171406 DB	'cckddasd64.c:3506', 00H
	ORG $+6
$SG171408 DB	'cckddasd64.c:3510', 00H
	ORG $+6
$SG171410 DB	'HHC00322%s %1d:%04X CCKD file[%d] %s: error merging shad'
	DB	'ow file, sf command busy on device', 0aH, 00H
	ORG $+4
$SG171411 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171412 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171414 DB	'cckddasd64.c:3520', 00H
	ORG $+6
$SG171415 DB	'cckddasd64.c:3528', 00H
	ORG $+6
$SG171416 DB	'cckddasd64.c:3530', 00H
	ORG $+6
$SG171418 DB	'cckddasd64.c:3534', 00H
	ORG $+6
$SG171420 DB	'HHC00323%s %1d:%04X CCKD file[%d] %s: cannot remove base'
	DB	' file', 0aH, 00H
	ORG $+1
$SG171421 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171422 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171425 DB	'not hardened', 00H
	ORG $+3
$SG171427 DB	'HHC00324%s %1d:%04X CCKD file[%d] %s: shadow file not me'
	DB	'rged: file[%d] %s%s', 0aH, 00H
	ORG $+3
$SG171428 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171429 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171436 DB	', try ''force''', 00H
	ORG $+2
$SG171438 DB	'cannot be opened read-write', 00H
	ORG $+4
$SG171441 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171440 DB	'HHC00324%s %1d:%04X CCKD file[%d] %s: shadow file not me'
	DB	'rged: file[%d] %s%s', 0aH, 00H
	ORG $+3
$SG171442 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171445 DB	'check failed', 00H
	ORG $+3
$SG171447 DB	'HHC00324%s %1d:%04X CCKD file[%d] %s: shadow file not me'
	DB	'rged: file[%d] %s%s', 0aH, 00H
	ORG $+3
$SG171448 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171449 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171451 DB	'merging to file[%d]', 00H
	ORG $+4
$SG171452 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171480 DB	're-added', 00H
	ORG $+7
$SG171481 DB	'removed', 00H
$SG171483 DB	'HHC00325%s %1d:%04X CCKD file[%d] %s: shadow file succes'
	DB	'sfully %s', 0aH, 00H
	ORG $+5
$SG171484 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171485 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171486 DB	'cckddasd64.c:3743', 00H
	ORG $+6
$SG171487 DB	'cckddasd64.c:3745', 00H
	ORG $+6
$SG171489 DB	'cckddasd64.c:3752', 00H
	ORG $+6
$SG171491 DB	'merge complete%s', 00H
	ORG $+7
$SG171492 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171493 DB	'cckddasd64.c:3755', 00H
	ORG $+6
$SG171497 DB	'HHC00326%s %1d:%04X CCKD file[%d] %s: shadow file not me'
	DB	'rged, error during merge', 0aH, 00H
	ORG $+6
$SG171498 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171499 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171501 DB	'HHC00327%s %1d:%04X CCKD file[%d] %s: shadow file not me'
	DB	'rged, error processing trk(%d)', 0aH, 00H
$SG171502 DB	'cckd64_sf_remove', 00H
	ORG $+7
$SG171503 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171524 DB	'HHC00328%s %1d:%04X CCKD file: compressing shadow files.'
	DB	'..', 0aH, 00H
	ORG $+4
$SG171525 DB	'cckd64_sf_comp', 00H
	ORG $+1
$SG171526 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171528 DB	'HHC00316%s CCKD file number of devices processed: %d', 0aH
	DB	00H
	ORG $+2
$SG171529 DB	'cckd64_sf_comp', 00H
	ORG $+1
$SG171530 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171534 DB	'HHC00317%s %1d:%04X CCKD file: device is not a cckd devi'
	DB	'ce', 0aH, 00H
	ORG $+4
$SG171535 DB	'cckd64_sf_comp', 00H
	ORG $+1
$SG171536 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171537 DB	'cckddasd64.c:3823', 00H
	ORG $+6
$SG171539 DB	'cckddasd64.c:3827', 00H
	ORG $+6
$SG171542 DB	'cckd64_sf_comp', 00H
	ORG $+1
$SG171545 DB	'cckddasd64.c:3837', 00H
	ORG $+6
$SG171541 DB	'HHC00329%s %1d:%04X CCKD file[%d] %s: error compressing '
	DB	'shadow file, sf command busy on device', 0aH, 00H
$SG171543 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171546 DB	'cckddasd64.c:3845', 00H
	ORG $+6
$SG171547 DB	'cckddasd64.c:3848', 00H
	ORG $+6
$SG171548 DB	'cckddasd64.c:3859', 00H
	ORG $+6
$SG171549 DB	'cckddasd64.c:3861', 00H
	ORG $+6
$SG171551 DB	'cckddasd64.c:3865', 00H
	ORG $+6
$SG171552 DB	'cckddasd64.c:3867', 00H
	ORG $+6
$SG171573 DB	'HHC00330%s %1d:%04X CCKD file: checking level %d...', 0aH
	DB	00H
	ORG $+3
$SG171574 DB	'cckd64_sf_chk', 00H
	ORG $+2
$SG171575 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171577 DB	'HHC00316%s CCKD file number of devices processed: %d', 0aH
	DB	00H
	ORG $+2
$SG171578 DB	'cckd64_sf_chk', 00H
	ORG $+2
$SG171579 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171583 DB	'HHC00317%s %1d:%04X CCKD file: device is not a cckd devi'
	DB	'ce', 0aH, 00H
	ORG $+4
$SG171584 DB	'cckd64_sf_chk', 00H
	ORG $+2
$SG171585 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171586 DB	'cckddasd64.c:3921', 00H
	ORG $+6
$SG171588 DB	'cckddasd64.c:3925', 00H
	ORG $+6
$SG171590 DB	'HHC00331%s %1d:%04X CCKD file[%d] %s: shadow file check '
	DB	'failed, sf command busy on device', 0aH, 00H
	ORG $+5
$SG171591 DB	'cckd64_sf_chk', 00H
	ORG $+2
$SG171592 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171594 DB	'cckddasd64.c:3938', 00H
	ORG $+6
$SG171595 DB	'cckddasd64.c:3949', 00H
	ORG $+6
$SG171596 DB	'cckddasd64.c:3952', 00H
	ORG $+6
$SG171597 DB	'cckddasd64.c:3963', 00H
	ORG $+6
$SG171598 DB	'cckddasd64.c:3965', 00H
	ORG $+6
$SG171600 DB	'cckddasd64.c:3969', 00H
	ORG $+6
$SG171601 DB	'cckddasd64.c:3971', 00H
	ORG $+6
$SG171641 DB	'HHC00332%s %1d:%04X CCKD file: display cckd statistics', 0aH
	DB	00H
$SG171642 DB	'cckd64_sf_stats', 00H
$SG171643 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171645 DB	'HHC00316%s CCKD file number of devices processed: %d', 0aH
	DB	00H
	ORG $+2
$SG171646 DB	'cckd64_sf_stats', 00H
$SG171647 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171651 DB	'HHC00317%s %1d:%04X CCKD file: device is not a cckd devi'
	DB	'ce', 0aH, 00H
	ORG $+4
$SG171652 DB	'cckd64_sf_stats', 00H
$SG171653 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171655 DB	'fstat()', 00H
$SG171657 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG171658 DB	'cckd64_sf_stats', 00H
$SG171659 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171664 DB	'cckd64_sf_stats', 00H
$SG171689 DB	'HHC00338%s %1d:%04X %s', 0aH, 00H
$SG171663 DB	'HHC00333%s %1d:%04X   32/64       size free  nbr st   re'
	DB	'ads  writes l2reads    hits switches', 0aH, 00H
	ORG $+2
$SG171665 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171669 DB	'HHC00334%s %1d:%04X                                     '
	DB	'                 readaheads   misses', 0aH, 00H
	ORG $+2
$SG171670 DB	'cckd64_sf_stats', 00H
$SG171671 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171673 DB	'HHC00335%s %1d:%04X ------------------------------------'
	DB	'------------------------------------', 0aH, 00H
	ORG $+2
$SG171674 DB	'cckd64_sf_stats', 00H
$SG171675 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171679 DB	'HHC00336%s %1d:%04X [*] %s %11.11lld %3.3lld%% %4.4lld  '
	DB	'  %7.7d %7.7d %7.7d %7.7d  %7.7d', 0aH, 00H
	ORG $+6
$SG171680 DB	'cckd64_sf_stats', 00H
$SG171681 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171685 DB	'HHC00337%s %1d:%04X                                     '
	DB	'                    %7.7d  %7.7d', 0aH, 00H
	ORG $+6
$SG171686 DB	'cckd64_sf_stats', 00H
$SG171687 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171690 DB	'cckd64_sf_stats', 00H
$SG171691 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171695 DB	'HHC00339%s %1d:%04X [0] %s %11.11lld %3.3lld%% %4.4lld %'
	DB	's %7.7d %7.7d %7.7d', 0aH, 00H
	ORG $+3
$SG171696 DB	'cckd64_sf_stats', 00H
$SG171697 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171700 DB	'HHC00340%s %1d:%04X %s', 0aH, 00H
$SG171701 DB	'cckd64_sf_stats', 00H
$SG171702 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171707 DB	'cckd64_sf_stats', 00H
$SG171720 DB	'cckddasd64.c:4127', 00H
	ORG $+6
$SG171706 DB	'HHC00341%s %1d:%04X [%d] %s %11.11lld %3.3lld%% %4.4lld '
	DB	'%s %7.7d %7.7d %7.7d', 0aH, 00H
	ORG $+2
$SG171708 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171722 DB	'cckddasd64.c:4136', 00H
	ORG $+6
$SG171724 DB	'cckddasd64.c:4145', 00H
	ORG $+6
$SG171728 DB	'cckd_gcol() by command line', 00H
	ORG $+4
$SG171730 DB	'HHC00107%s Starting thread %s, active=%d, started=%d, ma'
	DB	'x=%d', 0aH, 00H
	ORG $+2
$SG171731 DB	'cckd64_gcstart', 00H
	ORG $+1
$SG171732 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171733 DB	'cckddasd64.c:4158', 00H
	ORG $+6
$SG171734 DB	'cckddasd64.c:4160', 00H
	ORG $+6
$SG171735 DB	'cckd_gcol', 00H
	ORG $+6
$SG171736 DB	'cckddasd64.c:4162', 00H
	ORG $+6
$SG171738 DB	'cckd_gcol() by command line', 00H
	ORG $+4
$SG171741 DB	'cckd64_gcstart', 00H
	ORG $+1
$SG171743 DB	'cckddasd64.c:4174', 00H
	ORG $+6
$SG171740 DB	'HHC00106%s Error in function create_thread() for %s %d o'
	DB	'f %d: %s', 0aH, 00H
	ORG $+6
$SG171742 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171757 DB	'HHC00387%s %1d:%04X CCKD%s image %s is SEVERELY fragment'
	DB	'ed!', 0aH, 00H
	ORG $+3
$SG171758 DB	'cckd64_gc_rpt_state', 00H
	ORG $+4
$SG171759 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171763 DB	'HHC00388%s %1d:%04X CCKD%s image %s is moderately fragme'
	DB	'nted', 0aH, 00H
	ORG $+2
$SG171764 DB	'cckd64_gc_rpt_state', 00H
	ORG $+4
$SG171765 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171769 DB	'HHC00389%s %1d:%04X CCKD%s image %s is slightly fragment'
	DB	'ed', 0aH, 00H
	ORG $+4
$SG171770 DB	'cckd64_gc_rpt_state', 00H
	ORG $+4
$SG171771 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171806 DB	'cckddasd64.c:4285', 00H
	ORG $+6
$SG171809 DB	'cckddasd64.c:4290', 00H
	ORG $+6
$SG171811 DB	'cckddasd64.c:4297', 00H
	ORG $+6
$SG171816 DB	'cckddasd64.c:4311', 00H
	ORG $+6
$SG171823 DB	'cckddasd64.c:4328', 00H
	ORG $+6
$SG171824 DB	'cckddasd64.c:4334', 00H
	ORG $+6
$SG171825 DB	'cckddasd64.c:4342', 00H
	ORG $+6
$SG171826 DB	'cckddasd64.c:4347', 00H
	ORG $+6
$SG171828 DB	'cckddasd64.c:4352', 00H
	ORG $+6
$SG171829 DB	'cckddasd64.c:4357', 00H
	ORG $+6
$SG171831 DB	'cckddasd64.c:4363', 00H
	ORG $+6
$SG171832 DB	'cckddasd64.c:4367', 00H
	ORG $+6
$SG171846 DB	'gcperc exiting due to error, moved %llu', 00H
$SG171847 DB	'cckddasd64.c:4378', 00H
	ORG $+6
$SG171867 DB	'HHC00342%s %1d:%04X CCKD file[%d] %s: %s(%d): offset 0x%'
	DB	'16.16llx unknown space %2.2x%2.2x%2.2x%2.2x%2.2x', 0aH, 00H
	ORG $+6
$SG171868 DB	'cckd64_gc_perc_space_error', 00H
	ORG $+5
$SG171869 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171953 DB	'HHC00385%s Skipping garbage collection for CCKD%s file[%'
	DB	'd] %1d:%04X %s due to space errors', 0aH, 00H
	ORG $+4
$SG171954 DB	'cckd64_gc_percolate', 00H
	ORG $+4
$SG171955 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171956 DB	'cckddasd64.c:4433', 00H
	ORG $+6
$SG171959 DB	'cckddasd64.c:4436', 00H
	ORG $+6
$SG171960 DB	'gcperc size %d 1st 0x%llx nbr %lld largest %llu', 00H
$SG171961 DB	'cckd64_gc_percolate', 00H
	ORG $+4
$SG171962 DB	'gcperc free[%4d]:%16.16llx end %16.16llx len %10lld%cpen'
	DB	'd %d', 00H
	ORG $+3
$SG171963 DB	'cckd64_gc_percolate', 00H
	ORG $+4
$SG171964 DB	'cckddasd64.c:4456', 00H
	ORG $+6
$SG171966 DB	'cckddasd64.c:4464', 00H
	ORG $+6
$SG171968 DB	'cckddasd64.c:4470', 00H
	ORG $+6
$SG171985 DB	'gcperc no applicable space, moved %llu', 00H
	ORG $+1
$SG171986 DB	'cckd64_gc_percolate', 00H
	ORG $+4
$SG171987 DB	'cckddasd64.c:4553', 00H
	ORG $+6
$SG171990 DB	'gcperc selected space 0x%16.16llx len %lld', 00H
	ORG $+5
$SG171991 DB	'cckd64_gc_percolate', 00H
	ORG $+4
$SG171993 DB	'cckddasd64.c', 00H
	ORG $+3
$SG171999 DB	'HHC00384%s Collecting garbage for CCKD%s file[%d] %1d:%0'
	DB	'4X %s...', 0aH, 00H
	ORG $+6
$SG172000 DB	'cckd64_gc_percolate', 00H
	ORG $+4
$SG172001 DB	'cckddasd64.c', 00H
	ORG $+3
$SG172005 DB	'gcperc move l2tab[%lld] at pos 0x%16.16llx len %lld', 00H
	ORG $+4
$SG172006 DB	'cckd64_gc_percolate', 00H
	ORG $+4
$SG172008 DB	'cckddasd64.c', 00H
	ORG $+3
$SG172010 DB	'cckddasd64.c', 00H
	ORG $+3
$SG172012 DB	'cckddasd64.c', 00H
	ORG $+3
$SG172014 DB	'cckddasd64.c', 00H
	ORG $+3
$SG172016 DB	'cckddasd64.c', 00H
	ORG $+3
$SG172018 DB	'gcperc move trk %d at pos 0x%16.16llx len %hu', 00H
	ORG $+2
$SG172019 DB	'cckd64_gc_percolate', 00H
	ORG $+4
$SG172021 DB	'cckddasd64.c', 00H
	ORG $+3
$SG172022 DB	'cckddasd64.c:4632', 00H
	ORG $+6
$SG172023 DB	'gcperc moved %d 1st 0x%llx nbr %llu', 00H
	ORG $+4
$SG172024 DB	'cckd64_gc_percolate', 00H
	ORG $+4
$SG172028 DB	'HHC00386%s Collected %u bytes of garbage for CCKD%s file'
	DB	'[%d] %1d:%04X %s...', 0aH, 00H
	ORG $+3
$SG172029 DB	'cckd64_gc_percolate', 00H
	ORG $+4
$SG172030 DB	'cckddasd64.c', 00H
	ORG $+3
?compress@?1??cckd64_uncompress@@9@9 DQ FLAT:$SG172069	; `cckd64_uncompress'::`2'::compress
	DQ	FLAT:$SG172070
	DQ	FLAT:$SG172071
$SG172072 DB	'uncompress comp %d len %d maxlen %d trk %d', 00H
	ORG $+5
$SG172073 DB	'cckd64_uncompress', 00H
	ORG $+6
$SG172084 DB	'newbuf2', 00H
$SG172090 DB	'HHC00343%s %1d:%04X CCKD file[%d] %s: uncompress error t'
	DB	'rk %d: %2.2x%2.2x%2.2x%2.2x%2.2x', 0aH, 00H
	ORG $+6
$SG172091 DB	'cckd64_uncompress', 00H
	ORG $+6
$SG172092 DB	'cckddasd64.c', 00H
	ORG $+3
$SG172096 DB	'cckd64_uncompress', 00H
	ORG $+6
$SG172095 DB	'HHC00344%s %1d:%04X CCKD file[%d] %s: compression %s not'
	DB	' supported', 0aH, 00H
	ORG $+4
$SG172097 DB	'cckddasd64.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_sf_stats
	DD	017H
	DD	010d7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_sf_remove
	DD	01dH
	DD	019b2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_gc_percolate
	DD	021H
	DD	0146aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_sf_new
	DD	018H
	DD	0670H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_sf_init
	DD	016H
	DD	0784H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_validate
	DD	02fH
	DD	065bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_check_null_trk
	DD	02bH
	DD	0157H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_write_trkimg
	DD	025H
	DD	04cbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_read_trkimg
	DD	022H
	DD	01eeH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_read_fsp
	DD	016H
	DD	06e5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_read_init
	DD	016H
	DD	0286H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_writer_write
	DD	01fH
	DD	088fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cfba64_used
	DD	013H
	DD	0174H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_used
	DD	013H
	DD	017fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_write
	DD	024H
	DD	04b3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_read
	DD	024H
	DD	04abH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_open
	DD	024H
	DD	03ecH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cckd64_dasd_init_handler
	DD	01fH
	DD	0582H
voltbl	ENDS
xdata	SEGMENT
$unwind$cckd64_dasd_init_handler DD 022719H
	DD	0170115H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$cckd64_dasd_close_device DD 020c01H
	DD	015010cH
$unwind$cckd64_read_track DD 011201H
	DD	0a212H
$unwind$cckd64_update_track DD 031901H
	DD	07015a219H
	DD	06014H
$unwind$cfba64_read_block DD 011201H
	DD	0c212H
$unwind$cfba64_write_block DD 031901H
	DD	070158219H
	DD	06014H
$unwind$cckd64_dasd_start DD 010901H
	DD	0c209H
$unwind$cckd64_dasd_end DD 010901H
	DD	0a209H
$unwind$cckd64_open DD 022c19H
	DD	039011aH
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$unwind$cckd64_close DD 021001H
	DD	0150110H
$unwind$cckd64_read DD 022c19H
	DD	02b011aH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$cckd64_write DD 022c19H
	DD	02b011aH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$cckd64_ftruncate DD 021501H
	DD	0130115H
$unwind$cckd64_used DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$cfba64_used DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$cckd64_read_trk DD 031b01H
	DD	01a011bH
	DD	07014H
$unwind$cckd64_flush_cache DD 020c01H
	DD	011010cH
$unwind$cckd64_flush_cache_scan DD 011701H
	DD	0c217H
$unwind$cckd64_flush_cache_all DD 010401H
	DD	06204H
$unwind$cckd64_purge_cache DD 010901H
	DD	04209H
$unwind$cckd64_purge_cache_scan DD 011701H
	DD	0a217H
$unwind$cckd64_writer_write DD 022719H
	DD	0201f0115H
	DD	imagerel __GSHandlerCheck
	DD	0100e0H
$unwind$cckd64_get_space DD 021601H
	DD	0170116H
$unwind$cckd64_rel_space DD 021b01H
	DD	013011bH
$unwind$cckd64_flush_space DD 010901H
	DD	0e209H
$unwind$cckd64_read_chdr DD 020a01H
	DD	07006720aH
$unwind$cckd64_write_chdr DD 010901H
	DD	08209H
$unwind$cckd64_read_l1 DD 020a01H
	DD	07006b20aH
$unwind$cckd64_write_l1 DD 010901H
	DD	0a209H
$unwind$cckd64_write_l1ent DD 010d01H
	DD	0c20dH
$unwind$cckd64_read_init DD 021e19H
	DD	053010cH
	DD	imagerel __GSHandlerCheck
	DD	0280H
$unwind$cckd64_read_fsp DD 021e19H
	DD	015010cH
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$cckd64_write_fsp DD 020c01H
	DD	011010cH
$unwind$cckd64_read_l2 DD 021601H
	DD	0700ff216H
$unwind$cckd64_purge_l2 DD 010901H
	DD	08209H
$unwind$cckd64_purge_l2_scan DD 011701H
	DD	0c217H
$unwind$cckd64_steal_l2 DD 010401H
	DD	08204H
$unwind$cckd64_write_l2 DD 010901H
	DD	0c209H
$unwind$cckd64_read_l2ent DD 021601H
	DD	0130116H
$unwind$cckd64_write_l2ent DD 041801H
	DD	0110118H
	DD	060107011H
$unwind$cckd64_read_trkimg DD 012719H
	DD	0c218H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$cckd64_write_trkimg DD 022d19H
	DD	01b011bH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$cckd64_harden DD 010901H
	DD	08209H
$unwind$cckd64_null_trk DD 031c01H
	DD	012011cH
	DD	07015H
$unwind$cckd64_check_null_trk DD 023319H
	DD	020090121H
	DD	imagerel __GSHandlerCheck
	DD	010030H
$unwind$cckd64_cchh DD 021601H
	DD	02f0116H
$unwind$cckd64_validate DD 093719H
	DD	01c0125H
	DD	0e01cf01eH
	DD	07018c01aH
	DD	050166017H
	DD	03015H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$cckd64_sf_init DD 021e19H
	DD	08b010cH
	DD	imagerel __GSHandlerCheck
	DD	0440H
$unwind$cckd64_sf_new DD 042019H
	DD	059010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	02b0H
$unwind$cckd64_gcstart DD 020701H
	DD	0130107H
$unwind$cckd64_gcol_dev DD 010e01H
	DD	0a20eH
$unwind$cckd64_gc_state DD 010901H
	DD	08209H
$unwind$cckd64_gc_rpt_state DD 020c01H
	DD	017010cH
$unwind$cckd64_gc_percolate DD 022919H
	DD	080310117H
	DD	imagerel __GSHandlerCheck
	DD	040170H
$unwind$cckd64_uncompress DD 021b01H
	DD	01f011bH
$unwind$cckd64_sf_add DD 020c01H
	DD	019010cH
$unwind$cckd64_sf_remove DD 032519H
	DD	024340113H
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	012190H
$unwind$cckd64_sf_comp DD 020c01H
	DD	015010cH
$unwind$cckd64_sf_chk DD 020c01H
	DD	015010cH
$unwind$cckd64_sf_stats DD 031f19H
	DD	042010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0208H
$unwind$cckd64_gc_perc_error DD 011801H
	DD	06218H
$unwind$cckd64_gc_perc_space_error DD 021b01H
	DD	01d011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
tv136 = 160
tv142 = 164
tv67 = 168
tv72 = 172
tv77 = 176
tv82 = 180
tv86 = 184
tv88 = 192
tv91 = 200
tv94 = 208
dev$ = 240
cckd$ = 248
upos$ = 256
i$ = 264
buf$ = 272
moved$ = 280
file$ = 288
line$ = 296
cckd64_gc_perc_space_error PROC

; 4385 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 4386 :     // "%1d:%04X CCKD file[%d] %s: %s(%d): offset 0x%16.16"PRIx64" unknown space %2.2x%2.2x%2.2x%2.2x%2.2x"
; 4387 : 
; 4388 :     WRMSG( HHC00342, "E", LCSS_DEVNUM,

  0001b	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00024	74 15		 je	 SHORT $LN3@cckd64_gc_
  00026	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00032	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv136[rsp], eax
  00039	eb 0b		 jmp	 SHORT $LN4@cckd64_gc_
$LN3@cckd64_gc_:
  0003b	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv136[rsp], 0
$LN4@cckd64_gc_:
  00046	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0004f	74 17		 je	 SHORT $LN5@cckd64_gc_
  00051	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00059	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0005d	d1 f8		 sar	 eax, 1
  0005f	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv142[rsp], eax
  00066	eb 0b		 jmp	 SHORT $LN6@cckd64_gc_
$LN5@cckd64_gc_:
  00068	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv142[rsp], 0
$LN6@cckd64_gc_:
  00073	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR i$[rsp]
  0007b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00083	48 03 c8	 add	 rcx, rax
  00086	48 8b c1	 mov	 rax, rcx
  00089	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0008d	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv67[rsp], eax
  00094	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR i$[rsp]
  0009c	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000a4	48 03 d1	 add	 rdx, rcx
  000a7	48 8b ca	 mov	 rcx, rdx
  000aa	0f b6 49 03	 movzx	 ecx, BYTE PTR [rcx+3]
  000ae	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR tv72[rsp], ecx
  000b5	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR i$[rsp]
  000bd	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  000c5	4c 03 c2	 add	 r8, rdx
  000c8	49 8b d0	 mov	 rdx, r8
  000cb	0f b6 52 02	 movzx	 edx, BYTE PTR [rdx+2]
  000cf	89 94 24 b0 00
	00 00		 mov	 DWORD PTR tv77[rsp], edx
  000d6	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR i$[rsp]
  000de	4c 8b 8c 24 10
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  000e6	4d 03 c8	 add	 r9, r8
  000e9	4d 8b c1	 mov	 r8, r9
  000ec	45 0f b6 40 01	 movzx	 r8d, BYTE PTR [r8+1]
  000f1	44 89 84 24 b4
	00 00 00	 mov	 DWORD PTR tv82[rsp], r8d
  000f9	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR i$[rsp]
  00101	4c 8b 94 24 10
	01 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  00109	4d 03 d1	 add	 r10, r9
  0010c	4d 8b ca	 mov	 r9, r10
  0010f	45 0f b6 09	 movzx	 r9d, BYTE PTR [r9]
  00113	44 89 8c 24 b8
	00 00 00	 mov	 DWORD PTR tv86[rsp], r9d
  0011b	4c 8b 94 24 08
	01 00 00	 mov	 r10, QWORD PTR i$[rsp]
  00123	4c 8b 9c 24 00
	01 00 00	 mov	 r11, QWORD PTR upos$[rsp]
  0012b	4d 03 da	 add	 r11, r10
  0012e	4d 8b d3	 mov	 r10, r11
  00131	4c 89 94 24 c0
	00 00 00	 mov	 QWORD PTR tv88[rsp], r10
  00139	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00141	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trimloc
  00147	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv91[rsp], rax
  0014f	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00157	8b 51 3c	 mov	 edx, DWORD PTR [rcx+60]
  0015a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00162	e8 00 00 00 00	 call	 cckd_sf_name
  00167	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv94[rsp], rax
  0016f	b9 01 00 00 00	 mov	 ecx, 1
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0017a	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv67[rsp]
  00181	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  00188	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv72[rsp]
  0018f	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  00196	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv77[rsp]
  0019d	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  001a4	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv82[rsp]
  001ab	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  001af	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv86[rsp]
  001b6	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  001ba	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv88[rsp]
  001c2	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  001c7	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR line$[rsp]
  001ce	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  001d2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv91[rsp]
  001da	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001df	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv94[rsp]
  001e7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001ec	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  001f4	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  001f7	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001fb	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv136[rsp]
  00202	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00206	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv142[rsp]
  0020d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171866
  00218	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0021d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171867
  00224	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00229	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00234	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171868
  0023b	ba 26 11 00 00	 mov	 edx, 4390		; 00001126H
  00240	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171869
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4389 :             cckd->sfn, cckd_sf_name( dev, cckd->sfn ), TRIMLOC( file ), line,
; 4390 :             upos + i, buf[i], buf[i+1],buf[i+2], buf[i+3], buf[i+4]);
; 4391 : 
; 4392 :     cckd->cdevhdr[ cckd->sfn ].cdh_opts |= CCKD_OPT_SPERRS;

  0024d	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00255	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00259	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00260	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00268	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  00270	83 c8 20	 or	 eax, 32			; 00000020H
  00273	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0027b	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  0027f	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00286	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR cckd$[rsp]
  0028e	88 84 0a e3 01
	00 00		 mov	 BYTE PTR [rdx+rcx+483], al

; 4393 :     cckd_print_itrace();

  00295	e8 00 00 00 00	 call	 cckd_print_itrace

; 4394 :     return cckd64_gc_perc_error( dev, cckd, moved, file, line );

  0029a	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR line$[rsp]
  002a1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002a5	4c 8b 8c 24 20
	01 00 00	 mov	 r9, QWORD PTR file$[rsp]
  002ad	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR moved$[rsp]
  002b5	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR cckd$[rsp]
  002bd	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002c5	e8 00 00 00 00	 call	 cckd64_gc_perc_error

; 4395 : }

  002ca	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  002d1	c3		 ret	 0
cckd64_gc_perc_space_error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
dev$ = 64
cckd$ = 72
moved$ = 80
file$ = 88
line$ = 96
cckd64_gc_perc_error PROC

; 4376 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4377 :     cckd_trace( file, line, dev, "gcperc exiting due to error, moved %"PRIu64, moved );

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR moved$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171846
  00029	4c 8b 44 24 40	 mov	 r8, QWORD PTR dev$[rsp]
  0002e	8b 54 24 60	 mov	 edx, DWORD PTR line$[rsp]
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR file$[rsp]
  00037	e8 00 00 00 00	 call	 cckd_trace

; 4378 :     release_lock( &cckd->filelock );

  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  00041	48 83 c0 10	 add	 rax, 16
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171847
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4379 :     return (int) moved;

  00055	8b 44 24 50	 mov	 eax, DWORD PTR moved$[rsp]

; 4380 : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
cckd64_gc_perc_error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
dev$ = 144
i$ = 152
cckd$ = 160
n$1 = 168
usize$ = 176
tv149 = 184
tv155 = 188
tv216 = 192
tv222 = 196
tv240 = 200
tv246 = 204
tv260 = 208
tv266 = 212
tv335 = 216
tv341 = 220
tv363 = 224
tv369 = 228
tv385 = 232
tv391 = 236
tv451 = 240
tv472 = 244
tv478 = 248
tv557 = 252
tv563 = 256
tv445 = 260
tv77 = 264
tv83 = 268
ufree$ = 272
free_count$ = 280
tv323 = 288
tv330 = 296
tv433 = 304
tv440 = 312
tv539 = 320
tv551 = 328
tv173 = 336
tv380 = 344
tv403 = 352
tv407 = 360
tv411 = 368
tv422 = 376
tv465 = 384
tv493 = 392
tv498 = 400
tv503 = 408
tv517 = 416
tv543 = 424
st$ = 432
ost$ = 488
__$ArrayPad$ = 520
data$ = 544
cckd64_sf_stats PROC

; 3983 : {

$LN80:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 10 02
	00 00		 sub	 rsp, 528		; 00000210H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3984 : DEVBLK         *dev = data;             /* -> DEVBLK                 */

  0001f	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00027	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax

; 3985 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 3986 : struct stat     st = {0};               /* File information          */

  0002f	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR st$[rsp]
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00041	f3 aa		 rep stosb

; 3987 : int             i;                      /* Index                     */
; 3988 : char           *ost[] = {"  ", "ro", "rd", "rw"};

  00043	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171631
  0004a	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR ost$[rsp], rax
  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171633
  00059	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR ost$[rsp+8], rax
  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171635
  00068	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR ost$[rsp+16], rax
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171637
  00077	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR ost$[rsp+24], rax

; 3989 : U64             usize=0,ufree=0;        /* Total size, free space    */

  0007f	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR usize$[rsp], 0
  0008b	48 c7 84 24 10
	01 00 00 00 00
	00 00		 mov	 QWORD PTR ufree$[rsp], 0

; 3990 : S64             free_count=0;           /* Total number free spaces  */

  00097	48 c7 84 24 18
	01 00 00 00 00
	00 00		 mov	 QWORD PTR free_count$[rsp], 0

; 3991 : 
; 3992 :     /* NULL DEVBLK == all devices? */
; 3993 :     if (!dev)

  000a3	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000ac	0f 85 8c 01 00
	00		 jne	 $LN11@cckd64_sf_

; 3994 :     {
; 3995 :     int n = 0;

  000b2	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR n$1[rsp], 0

; 3996 :         for (dev=sysblk.firstdev; dev; dev=dev->nextdev)

  000bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c4	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  000cb	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax
  000d3	eb 14		 jmp	 SHORT $LN4@cckd64_sf_
$LN2@cckd64_sf_:
  000d5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000dd	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000e1	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd64_sf_:
  000e9	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000f2	0f 84 ed 00 00
	00		 je	 $LN3@cckd64_sf_

; 3997 :         {
; 3998 :             if (dev->cckd_ext)  /* Is this a compressed device? */

  000f8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00100	48 83 b8 08 13
	00 00 00	 cmp	 QWORD PTR [rax+4872], 0
  00108	0f 84 d2 00 00
	00		 je	 $LN12@cckd64_sf_

; 3999 :             {
; 4000 :                 // "%1d:%04X CCKD file: display cckd statistics"
; 4001 :                 WRMSG( HHC00332, "I", LCSS_DEVNUM );

  0010e	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00117	74 15		 je	 SHORT $LN24@cckd64_sf_
  00119	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00121	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00125	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv77[rsp], eax
  0012c	eb 0b		 jmp	 SHORT $LN25@cckd64_sf_
$LN24@cckd64_sf_:
  0012e	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv77[rsp], 0
$LN25@cckd64_sf_:
  00139	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00142	74 17		 je	 SHORT $LN26@cckd64_sf_
  00144	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00150	d1 f8		 sar	 eax, 1
  00152	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv83[rsp], eax
  00159	eb 0b		 jmp	 SHORT $LN27@cckd64_sf_
$LN26@cckd64_sf_:
  0015b	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv83[rsp], 0
$LN27@cckd64_sf_:
  00166	b9 01 00 00 00	 mov	 ecx, 1
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00171	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv77[rsp]
  00178	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0017c	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv83[rsp]
  00183	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171640
  0018e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171641
  0019a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0019f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a4	41 b9 03 00 00
	00		 mov	 r9d, 3
  001aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171642
  001b1	ba a1 0f 00 00	 mov	 edx, 4001		; 00000fa1H
  001b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171643
  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4002 :                 cckd64_sf_stats( dev );

  001c3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001cb	e8 00 00 00 00	 call	 cckd64_sf_stats

; 4003 :                 n++;

  001d0	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR n$1[rsp]
  001d7	ff c0		 inc	 eax
  001d9	89 84 24 a8 00
	00 00		 mov	 DWORD PTR n$1[rsp], eax
$LN12@cckd64_sf_:

; 4004 :             }
; 4005 :         }

  001e0	e9 f0 fe ff ff	 jmp	 $LN2@cckd64_sf_
$LN3@cckd64_sf_:

; 4006 :         // "CCKD file number of devices processed: %d"
; 4007 :         WRMSG( HHC00316, "I", n );

  001e5	b9 01 00 00 00	 mov	 ecx, 1
  001ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001f0	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR n$1[rsp]
  001f7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171644
  00202	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171645
  0020e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00213	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00218	41 b9 03 00 00
	00		 mov	 r9d, 3
  0021e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171646
  00225	ba a7 0f 00 00	 mov	 edx, 4007		; 00000fa7H
  0022a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171647
  00231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4008 :         return NULL;

  00237	33 c0		 xor	 eax, eax
  00239	e9 99 0e 00 00	 jmp	 $LN1@cckd64_sf_
$LN11@cckd64_sf_:

; 4009 :     }
; 4010 : 
; 4011 :     if (!dev->cckd64)

  0023e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00246	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0024d	24 01		 and	 al, 1
  0024f	0f b6 c0	 movzx	 eax, al
  00252	85 c0		 test	 eax, eax
  00254	75 12		 jne	 SHORT $LN13@cckd64_sf_

; 4012 :         return cckd_sf_stats( data );

  00256	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0025e	e8 00 00 00 00	 call	 cckd_sf_stats
  00263	e9 6f 0e 00 00	 jmp	 $LN1@cckd64_sf_
$LN13@cckd64_sf_:

; 4013 : 
; 4014 :     if (!(cckd = dev->cckd_ext))

  00268	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00270	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00277	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax
  0027f	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR cckd$[rsp], 0
  00288	0f 85 bc 00 00
	00		 jne	 $LN14@cckd64_sf_

; 4015 :     {
; 4016 :         // "%1d:%04X CCKD file: device is not a cckd device"
; 4017 :         WRMSG( HHC00317, "W", LCSS_DEVNUM );

  0028e	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00297	74 15		 je	 SHORT $LN28@cckd64_sf_
  00299	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002a5	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv149[rsp], eax
  002ac	eb 0b		 jmp	 SHORT $LN29@cckd64_sf_
$LN28@cckd64_sf_:
  002ae	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv149[rsp], 0
$LN29@cckd64_sf_:
  002b9	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002c2	74 17		 je	 SHORT $LN30@cckd64_sf_
  002c4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002cc	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002d0	d1 f8		 sar	 eax, 1
  002d2	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv155[rsp], eax
  002d9	eb 0b		 jmp	 SHORT $LN31@cckd64_sf_
$LN30@cckd64_sf_:
  002db	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv155[rsp], 0
$LN31@cckd64_sf_:
  002e6	b9 01 00 00 00	 mov	 ecx, 1
  002eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f1	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv149[rsp]
  002f8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002fc	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv155[rsp]
  00303	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00307	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171650
  0030e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00313	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171651
  0031a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0031f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00324	41 b9 03 00 00
	00		 mov	 r9d, 3
  0032a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171652
  00331	ba b1 0f 00 00	 mov	 edx, 4017		; 00000fb1H
  00336	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171653
  0033d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4018 :         return NULL;

  00343	33 c0		 xor	 eax, eax
  00345	e9 8d 0d 00 00	 jmp	 $LN1@cckd64_sf_
$LN14@cckd64_sf_:

; 4019 :     }
; 4020 : 
; 4021 :     /* Calculate totals */
; 4022 :     if (fstat( cckd->fd[0], &st ) != 0)

  0034a	b8 04 00 00 00	 mov	 eax, 4
  0034f	48 6b c0 00	 imul	 rax, rax, 0
  00353	48 8d 94 24 b0
	01 00 00	 lea	 rdx, QWORD PTR st$[rsp]
  0035b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00363	8b 8c 01 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+240]
  0036a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fstat64
  00370	85 c0		 test	 eax, eax
  00372	0f 84 8a 00 00
	00		 je	 $LN15@cckd64_sf_

; 4023 :     {
; 4024 :         // "Error in function %s: %s"
; 4025 :         WRMSG( HHC00075, "E", "fstat()", strerror( errno ));

  00378	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0037e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00380	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00386	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv173[rsp], rax
  0038e	b9 01 00 00 00	 mov	 ecx, 1
  00393	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00399	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv173[rsp]
  003a1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171655
  003ad	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171656
  003b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171657
  003c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  003d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171658
  003dc	ba b9 0f 00 00	 mov	 edx, 4025		; 00000fb9H
  003e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171659
  003e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4026 :         memset( &st, 0, sizeof( st ));

  003ee	48 8d 84 24 b0
	01 00 00	 lea	 rax, QWORD PTR st$[rsp]
  003f6	48 8b f8	 mov	 rdi, rax
  003f9	33 c0		 xor	 eax, eax
  003fb	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00400	f3 aa		 rep stosb
$LN15@cckd64_sf_:

; 4027 :     }
; 4028 :     for (i=0; i <= cckd->sfn; i++)

  00402	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  0040d	eb 10		 jmp	 SHORT $LN7@cckd64_sf_
$LN5@cckd64_sf_:
  0040f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00416	ff c0		 inc	 eax
  00418	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN7@cckd64_sf_:
  0041f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00427	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0042a	39 84 24 98 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00431	0f 8f c0 00 00
	00		 jg	 $LN6@cckd64_sf_

; 4029 :     {
; 4030 :         if (!i) usize = st.st_size;

  00437	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR i$[rsp], 0
  0043f	75 12		 jne	 SHORT $LN16@cckd64_sf_
  00441	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR st$[rsp+24]
  00449	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR usize$[rsp], rax
  00451	eb 35		 jmp	 SHORT $LN17@cckd64_sf_
$LN16@cckd64_sf_:

; 4031 :         else usize += cckd->cdevhdr[i].cdh_size;

  00453	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0045b	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00462	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0046a	48 8b 84 01 f0
	01 00 00	 mov	 rax, QWORD PTR [rcx+rax+496]
  00472	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR usize$[rsp]
  0047a	48 03 c8	 add	 rcx, rax
  0047d	48 8b c1	 mov	 rax, rcx
  00480	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR usize$[rsp], rax
$LN17@cckd64_sf_:

; 4032 :         ufree += cckd->cdevhdr[i].free_total;

  00488	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00490	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00497	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0049f	48 8b 84 01 08
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+520]
  004a7	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR ufree$[rsp]
  004af	48 03 c8	 add	 rcx, rax
  004b2	48 8b c1	 mov	 rax, rcx
  004b5	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR ufree$[rsp], rax

; 4033 :         free_count += cckd->cdevhdr[i].free_num;

  004bd	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  004c5	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004cc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  004d4	48 8b 84 01 18
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+536]
  004dc	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR free_count$[rsp]
  004e4	48 03 c8	 add	 rcx, rax
  004e7	48 8b c1	 mov	 rax, rcx
  004ea	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR free_count$[rsp], rax

; 4034 :     }

  004f2	e9 18 ff ff ff	 jmp	 $LN5@cckd64_sf_
$LN6@cckd64_sf_:

; 4035 : 
; 4036 :     /* header */
; 4037 : 
; 4038 :     // "%1d:%04X   32/64       size free  nbr st   reads  writes l2reads    hits switches"
; 4039 :     WRMSG (HHC00333, "I", LCSS_DEVNUM);

  004f7	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00500	74 15		 je	 SHORT $LN32@cckd64_sf_
  00502	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0050a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0050e	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv216[rsp], eax
  00515	eb 0b		 jmp	 SHORT $LN33@cckd64_sf_
$LN32@cckd64_sf_:
  00517	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv216[rsp], 0
$LN33@cckd64_sf_:
  00522	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0052b	74 17		 je	 SHORT $LN34@cckd64_sf_
  0052d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00535	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00539	d1 f8		 sar	 eax, 1
  0053b	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv222[rsp], eax
  00542	eb 0b		 jmp	 SHORT $LN35@cckd64_sf_
$LN34@cckd64_sf_:
  00544	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv222[rsp], 0
$LN35@cckd64_sf_:
  0054f	b9 01 00 00 00	 mov	 ecx, 1
  00554	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0055a	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv216[rsp]
  00561	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00565	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv222[rsp]
  0056c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00570	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171662
  00577	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0057c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171663
  00583	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00588	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0058d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00593	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171664
  0059a	ba c7 0f 00 00	 mov	 edx, 4039		; 00000fc7H
  0059f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171665
  005a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4040 : 
; 4041 :     if (cckd->readaheads || cckd->misses)

  005ac	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  005b4	83 b8 e4 00 00
	00 00		 cmp	 DWORD PTR [rax+228], 0
  005bb	75 15		 jne	 SHORT $LN19@cckd64_sf_
  005bd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  005c5	83 b8 ec 00 00
	00 00		 cmp	 DWORD PTR [rax+236], 0
  005cc	0f 84 b5 00 00
	00		 je	 $LN18@cckd64_sf_
$LN19@cckd64_sf_:

; 4042 :     // "%1d:%04X                                                      readaheads   misses"
; 4043 :     WRMSG (HHC00334, "I", LCSS_DEVNUM);

  005d2	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005db	74 15		 je	 SHORT $LN36@cckd64_sf_
  005dd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005e5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005e9	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv240[rsp], eax
  005f0	eb 0b		 jmp	 SHORT $LN37@cckd64_sf_
$LN36@cckd64_sf_:
  005f2	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv240[rsp], 0
$LN37@cckd64_sf_:
  005fd	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00606	74 17		 je	 SHORT $LN38@cckd64_sf_
  00608	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00610	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00614	d1 f8		 sar	 eax, 1
  00616	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv246[rsp], eax
  0061d	eb 0b		 jmp	 SHORT $LN39@cckd64_sf_
$LN38@cckd64_sf_:
  0061f	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv246[rsp], 0
$LN39@cckd64_sf_:
  0062a	b9 01 00 00 00	 mov	 ecx, 1
  0062f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00635	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv240[rsp]
  0063c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00640	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv246[rsp]
  00647	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0064b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171668
  00652	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00657	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171669
  0065e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00663	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00668	41 b9 03 00 00
	00		 mov	 r9d, 3
  0066e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171670
  00675	ba cb 0f 00 00	 mov	 edx, 4043		; 00000fcbH
  0067a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171671
  00681	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@cckd64_sf_:

; 4044 : 
; 4045 :     // "%1d:%04X ------------------------------------------------------------------------"
; 4046 :     WRMSG (HHC00335, "I", LCSS_DEVNUM);

  00687	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00690	74 15		 je	 SHORT $LN40@cckd64_sf_
  00692	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0069a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0069e	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv260[rsp], eax
  006a5	eb 0b		 jmp	 SHORT $LN41@cckd64_sf_
$LN40@cckd64_sf_:
  006a7	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv260[rsp], 0
$LN41@cckd64_sf_:
  006b2	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006bb	74 17		 je	 SHORT $LN42@cckd64_sf_
  006bd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006c5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  006c9	d1 f8		 sar	 eax, 1
  006cb	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv266[rsp], eax
  006d2	eb 0b		 jmp	 SHORT $LN43@cckd64_sf_
$LN42@cckd64_sf_:
  006d4	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv266[rsp], 0
$LN43@cckd64_sf_:
  006df	b9 01 00 00 00	 mov	 ecx, 1
  006e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006ea	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv260[rsp]
  006f1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006f5	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv266[rsp]
  006fc	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00700	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171672
  00707	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0070c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171673
  00713	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00718	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0071d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00723	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171674
  0072a	ba ce 0f 00 00	 mov	 edx, 4046		; 00000fceH
  0072f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171675
  00736	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4047 : 
; 4048 :     /* total statistics */
; 4049 : 
; 4050 :     // "%1d:%04X [*] %s %11.11"PRId64" %3.3"PRId64"%% %4.4"PRId64"    %7.7d %7.7d %7.7d %7.7d  %7.7d"
; 4051 :     WRMSG( HHC00336, "I", LCSS_DEVNUM, dev->cckd64 ? "64" : "32", usize

  0073c	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR usize$[rsp], 0
  00745	74 1d		 je	 SHORT $LN44@cckd64_sf_
  00747	48 6b 84 24 10
	01 00 00 64	 imul	 rax, QWORD PTR ufree$[rsp], 100 ; 00000064H
  00750	33 d2		 xor	 edx, edx
  00752	48 f7 b4 24 b0
	00 00 00	 div	 QWORD PTR usize$[rsp]
  0075a	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv323[rsp], rax
  00762	eb 0c		 jmp	 SHORT $LN45@cckd64_sf_
$LN44@cckd64_sf_:
  00764	48 c7 84 24 20
	01 00 00 e7 03
	00 00		 mov	 QWORD PTR tv323[rsp], 999 ; 000003e7H
$LN45@cckd64_sf_:
  00770	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00778	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0077f	24 01		 and	 al, 1
  00781	0f b6 c0	 movzx	 eax, al
  00784	85 c0		 test	 eax, eax
  00786	74 11		 je	 SHORT $LN46@cckd64_sf_
  00788	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171676
  0078f	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv330[rsp], rax
  00797	eb 0f		 jmp	 SHORT $LN47@cckd64_sf_
$LN46@cckd64_sf_:
  00799	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171677
  007a0	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv330[rsp], rax
$LN47@cckd64_sf_:
  007a8	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  007b1	74 15		 je	 SHORT $LN48@cckd64_sf_
  007b3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007bb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  007bf	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv335[rsp], eax
  007c6	eb 0b		 jmp	 SHORT $LN49@cckd64_sf_
$LN48@cckd64_sf_:
  007c8	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv335[rsp], 0
$LN49@cckd64_sf_:
  007d3	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  007dc	74 17		 je	 SHORT $LN50@cckd64_sf_
  007de	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007e6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  007ea	d1 f8		 sar	 eax, 1
  007ec	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv341[rsp], eax
  007f3	eb 0b		 jmp	 SHORT $LN51@cckd64_sf_
$LN50@cckd64_sf_:
  007f5	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv341[rsp], 0
$LN51@cckd64_sf_:
  00800	b9 01 00 00 00	 mov	 ecx, 1
  00805	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0080b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00813	8b 89 e8 00 00
	00		 mov	 ecx, DWORD PTR [rcx+232]
  00819	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  00820	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00828	8b 89 e0 00 00
	00		 mov	 ecx, DWORD PTR [rcx+224]
  0082e	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  00835	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0083d	8b 89 dc 00 00
	00		 mov	 ecx, DWORD PTR [rcx+220]
  00843	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00847	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0084f	8b 89 d8 00 00
	00		 mov	 ecx, DWORD PTR [rcx+216]
  00855	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00859	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00861	8b 89 d4 00 00
	00		 mov	 ecx, DWORD PTR [rcx+212]
  00867	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0086b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR free_count$[rsp]
  00873	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00878	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv323[rsp]
  00880	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00885	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR usize$[rsp]
  0088d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00892	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv330[rsp]
  0089a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0089f	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv335[rsp]
  008a6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  008aa	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv341[rsp]
  008b1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171678
  008bc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171679
  008c8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008cd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008d2	41 b9 03 00 00
	00		 mov	 r9d, 3
  008d8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171680
  008df	ba dc 0f 00 00	 mov	 edx, 4060		; 00000fdcH
  008e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171681
  008eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4052 : 
; 4053 :         , usize ? (ufree * 100) / usize : 999
; 4054 :         , free_count
; 4055 :         , cckd->totreads
; 4056 :         , cckd->totwrites
; 4057 :         , cckd->totl2reads
; 4058 :         , cckd->cachehits
; 4059 :         , cckd->switches
; 4060 :     );
; 4061 : 
; 4062 :     if (cckd->readaheads || cckd->misses)

  008f1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  008f9	83 b8 e4 00 00
	00 00		 cmp	 DWORD PTR [rax+228], 0
  00900	75 15		 jne	 SHORT $LN21@cckd64_sf_
  00902	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0090a	83 b8 ec 00 00
	00 00		 cmp	 DWORD PTR [rax+236], 0
  00911	0f 84 d9 00 00
	00		 je	 $LN20@cckd64_sf_
$LN21@cckd64_sf_:

; 4063 :     // "%1d:%04X                                                         %7.7d  %7.7d"
; 4064 :     WRMSG (HHC00337, "I", LCSS_DEVNUM,

  00917	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00920	74 15		 je	 SHORT $LN52@cckd64_sf_
  00922	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0092a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0092e	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv363[rsp], eax
  00935	eb 0b		 jmp	 SHORT $LN53@cckd64_sf_
$LN52@cckd64_sf_:
  00937	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv363[rsp], 0
$LN53@cckd64_sf_:
  00942	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0094b	74 17		 je	 SHORT $LN54@cckd64_sf_
  0094d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00955	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00959	d1 f8		 sar	 eax, 1
  0095b	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv369[rsp], eax
  00962	eb 0b		 jmp	 SHORT $LN55@cckd64_sf_
$LN54@cckd64_sf_:
  00964	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv369[rsp], 0
$LN55@cckd64_sf_:
  0096f	b9 01 00 00 00	 mov	 ecx, 1
  00974	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0097a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00982	8b 89 ec 00 00
	00		 mov	 ecx, DWORD PTR [rcx+236]
  00988	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0098c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00994	8b 89 e4 00 00
	00		 mov	 ecx, DWORD PTR [rcx+228]
  0099a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0099e	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv363[rsp]
  009a5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  009a9	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv369[rsp]
  009b0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  009b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171684
  009bb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171685
  009c7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009d1	41 b9 03 00 00
	00		 mov	 r9d, 3
  009d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171686
  009de	ba e1 0f 00 00	 mov	 edx, 4065		; 00000fe1H
  009e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171687
  009ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN20@cckd64_sf_:

; 4065 :             cckd->readaheads, cckd->misses);
; 4066 : 
; 4067 :     /* base file statistics */
; 4068 : 
; 4069 :     // "%1d:%04X %s"
; 4070 :     WRMSG (HHC00338, "I", LCSS_DEVNUM, dev->filename);

  009f0	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  009f9	74 15		 je	 SHORT $LN56@cckd64_sf_
  009fb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a03	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00a07	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv385[rsp], eax
  00a0e	eb 0b		 jmp	 SHORT $LN57@cckd64_sf_
$LN56@cckd64_sf_:
  00a10	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv385[rsp], 0
$LN57@cckd64_sf_:
  00a1b	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00a24	74 17		 je	 SHORT $LN58@cckd64_sf_
  00a26	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a2e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00a32	d1 f8		 sar	 eax, 1
  00a34	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv391[rsp], eax
  00a3b	eb 0b		 jmp	 SHORT $LN59@cckd64_sf_
$LN58@cckd64_sf_:
  00a3d	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv391[rsp], 0
$LN59@cckd64_sf_:
  00a48	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a50	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00a56	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv380[rsp], rax
  00a5e	b9 01 00 00 00	 mov	 ecx, 1
  00a63	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a69	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv380[rsp]
  00a71	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a76	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv385[rsp]
  00a7d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a81	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv391[rsp]
  00a88	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a8c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171688
  00a93	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a98	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171689
  00a9f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00aa4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00aa9	41 b9 03 00 00
	00		 mov	 r9d, 3
  00aaf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171690
  00ab6	ba e6 0f 00 00	 mov	 edx, 4070		; 00000fe6H
  00abb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171691
  00ac2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4071 : 
; 4072 :     // "%1d:%04X [0] %s %11.11"PRId64" %3.3"PRId64"%% %4.4"PRId64" %s %7.7d %7.7d %7.7d"
; 4073 :     WRMSG( HHC00339, "I", LCSS_DEVNUM, dev->cckd64 ? "64" : "32", st.st_size

  00ac8	48 83 bc 24 c8
	01 00 00 00	 cmp	 QWORD PTR st$[rsp+24], 0
  00ad1	74 2e		 je	 SHORT $LN60@cckd64_sf_
  00ad3	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00ad8	48 6b c0 00	 imul	 rax, rax, 0
  00adc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00ae4	48 6b 84 01 08
	02 00 00 64	 imul	 rax, QWORD PTR [rcx+rax+520], 100 ; 00000064H
  00aed	48 99		 cdq
  00aef	48 f7 bc 24 c8
	01 00 00	 idiv	 QWORD PTR st$[rsp+24]
  00af7	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv433[rsp], rax
  00aff	eb 0c		 jmp	 SHORT $LN61@cckd64_sf_
$LN60@cckd64_sf_:
  00b01	48 c7 84 24 30
	01 00 00 e7 03
	00 00		 mov	 QWORD PTR tv433[rsp], 999 ; 000003e7H
$LN61@cckd64_sf_:
  00b0d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b15	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00b1c	24 01		 and	 al, 1
  00b1e	0f b6 c0	 movzx	 eax, al
  00b21	85 c0		 test	 eax, eax
  00b23	74 11		 je	 SHORT $LN62@cckd64_sf_
  00b25	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171692
  00b2c	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv440[rsp], rax
  00b34	eb 0f		 jmp	 SHORT $LN63@cckd64_sf_
$LN62@cckd64_sf_:
  00b36	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171693
  00b3d	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv440[rsp], rax
$LN63@cckd64_sf_:
  00b45	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00b4e	74 15		 je	 SHORT $LN64@cckd64_sf_
  00b50	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b58	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b5c	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv445[rsp], eax
  00b63	eb 0b		 jmp	 SHORT $LN65@cckd64_sf_
$LN64@cckd64_sf_:
  00b65	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv445[rsp], 0
$LN65@cckd64_sf_:
  00b70	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00b79	74 17		 je	 SHORT $LN66@cckd64_sf_
  00b7b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b83	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00b87	d1 f8		 sar	 eax, 1
  00b89	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv451[rsp], eax
  00b90	eb 0b		 jmp	 SHORT $LN67@cckd64_sf_
$LN66@cckd64_sf_:
  00b92	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv451[rsp], 0
$LN67@cckd64_sf_:
  00b9d	b8 04 00 00 00	 mov	 eax, 4
  00ba2	48 6b c0 00	 imul	 rax, rax, 0
  00ba6	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv403[rsp], rax
  00bae	b9 04 00 00 00	 mov	 ecx, 4
  00bb3	48 6b c9 00	 imul	 rcx, rcx, 0
  00bb7	48 89 8c 24 68
	01 00 00	 mov	 QWORD PTR tv407[rsp], rcx
  00bbf	ba 04 00 00 00	 mov	 edx, 4
  00bc4	48 6b d2 00	 imul	 rdx, rdx, 0
  00bc8	48 89 94 24 70
	01 00 00	 mov	 QWORD PTR tv411[rsp], rdx
  00bd0	bf 01 00 00 00	 mov	 edi, 1
  00bd5	48 6b ff 00	 imul	 rdi, rdi, 0
  00bd9	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR cckd$[rsp]
  00be1	41 0f b6 bc 38
	1d 01 00 00	 movzx	 edi, BYTE PTR [r8+rdi+285]
  00bea	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00bf0	4d 6b c0 00	 imul	 r8, r8, 0
  00bf4	4c 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv422[rsp], r8
  00bfc	b9 01 00 00 00	 mov	 ecx, 1
  00c01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c07	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00c0f	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR tv403[rsp]
  00c17	8b 8c 11 4c 01
	00 00		 mov	 ecx, DWORD PTR [rcx+rdx+332]
  00c1e	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  00c25	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00c2d	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR tv407[rsp]
  00c35	8b 8c 11 70 01
	00 00		 mov	 ecx, DWORD PTR [rcx+rdx+368]
  00c3c	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00c40	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00c48	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR tv411[rsp]
  00c50	8b 8c 11 28 01
	00 00		 mov	 ecx, DWORD PTR [rcx+rdx+296]
  00c57	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00c5b	48 8b 8c fc e8
	01 00 00	 mov	 rcx, QWORD PTR ost$[rsp+rdi*8]
  00c63	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00c68	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00c70	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR tv422[rsp]
  00c78	48 8b 8c 11 18
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rdx+536]
  00c80	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00c85	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv433[rsp]
  00c8d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00c92	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR st$[rsp+24]
  00c9a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00c9f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv440[rsp]
  00ca7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00cac	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv445[rsp]
  00cb3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00cb7	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv451[rsp]
  00cbe	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00cc2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171694
  00cc9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00cce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171695
  00cd5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00cda	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cdf	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ce5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171696
  00cec	ba f2 0f 00 00	 mov	 edx, 4082		; 00000ff2H
  00cf1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171697
  00cf8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4074 : 
; 4075 :         , st.st_size ?
; 4076 :           ((S64)(cckd->cdevhdr[0].free_total * 100) / st.st_size) : 999
; 4077 :         ,        cckd->cdevhdr[0].free_num
; 4078 :         , ost[cckd->open[0]]
; 4079 :         , cckd->reads[0]
; 4080 :         , cckd->writes[0]
; 4081 :         , cckd->L2_reads[0]
; 4082 :     );
; 4083 : 
; 4084 :     if (dev->dasdsfn != NULL && CCKD_MAX_SF > 0)

  00cfe	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d06	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  00d0e	0f 84 e7 00 00
	00		 je	 $LN22@cckd64_sf_
  00d14	33 c0		 xor	 eax, eax
  00d16	83 f8 01	 cmp	 eax, 1
  00d19	0f 84 dc 00 00
	00		 je	 $LN22@cckd64_sf_

; 4085 :         // "%1d:%04X %s"
; 4086 :         WRMSG (HHC00340, "I", LCSS_DEVNUM, cckd_sf_name(dev, -1));

  00d1f	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d28	74 15		 je	 SHORT $LN68@cckd64_sf_
  00d2a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d32	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00d36	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv472[rsp], eax
  00d3d	eb 0b		 jmp	 SHORT $LN69@cckd64_sf_
$LN68@cckd64_sf_:
  00d3f	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv472[rsp], 0
$LN69@cckd64_sf_:
  00d4a	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d53	74 17		 je	 SHORT $LN70@cckd64_sf_
  00d55	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d5d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00d61	d1 f8		 sar	 eax, 1
  00d63	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv478[rsp], eax
  00d6a	eb 0b		 jmp	 SHORT $LN71@cckd64_sf_
$LN70@cckd64_sf_:
  00d6c	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv478[rsp], 0
$LN71@cckd64_sf_:
  00d77	ba ff ff ff ff	 mov	 edx, -1
  00d7c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d84	e8 00 00 00 00	 call	 cckd_sf_name
  00d89	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR tv465[rsp], rax
  00d91	b9 01 00 00 00	 mov	 ecx, 1
  00d96	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d9c	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR tv465[rsp]
  00da4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00da9	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv472[rsp]
  00db0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00db4	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv478[rsp]
  00dbb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00dbf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171699
  00dc6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00dcb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171700
  00dd2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00dd7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ddc	41 b9 03 00 00
	00		 mov	 r9d, 3
  00de2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171701
  00de9	ba f6 0f 00 00	 mov	 edx, 4086		; 00000ff6H
  00dee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171702
  00df5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN22@cckd64_sf_:

; 4087 : 
; 4088 :     /* shadow file statistics */
; 4089 :     for (i = 1; i <= cckd->sfn; i++)

  00dfb	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR i$[rsp], 1
  00e06	eb 10		 jmp	 SHORT $LN10@cckd64_sf_
$LN8@cckd64_sf_:
  00e08	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00e0f	ff c0		 inc	 eax
  00e11	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN10@cckd64_sf_:
  00e18	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00e20	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00e23	39 84 24 98 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00e2a	0f 8f a5 02 00
	00		 jg	 $LN9@cckd64_sf_

; 4090 :     {
; 4091 :         // "%1d:%04X [%d] %s %11.11"PRId64" %3.3"PRId64"%% %4.4"PRId64" %s %7.7d %7.7d %7.7d"
; 4092 :         WRMSG( HHC00341, "I", LCSS_DEVNUM, i, dev->cckd64 ? "64" : "32", (S64)cckd->cdevhdr[i].cdh_size

  00e30	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00e38	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00e3f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00e47	48 83 bc 01 f0
	01 00 00 00	 cmp	 QWORD PTR [rcx+rax+496], 0
  00e50	74 4b		 je	 SHORT $LN72@cckd64_sf_
  00e52	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00e5a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00e61	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00e69	48 6b 84 01 08
	02 00 00 64	 imul	 rax, QWORD PTR [rcx+rax+520], 100 ; 00000064H
  00e72	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00e7a	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00e81	33 d2		 xor	 edx, edx
  00e83	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR cckd$[rsp]
  00e8b	48 f7 b4 0f f0
	01 00 00	 div	 QWORD PTR [rdi+rcx+496]
  00e93	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv539[rsp], rax
  00e9b	eb 0c		 jmp	 SHORT $LN73@cckd64_sf_
$LN72@cckd64_sf_:
  00e9d	48 c7 84 24 40
	01 00 00 e7 03
	00 00		 mov	 QWORD PTR tv539[rsp], 999 ; 000003e7H
$LN73@cckd64_sf_:
  00ea9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00eb1	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00eb8	24 01		 and	 al, 1
  00eba	0f b6 c0	 movzx	 eax, al
  00ebd	85 c0		 test	 eax, eax
  00ebf	74 11		 je	 SHORT $LN74@cckd64_sf_
  00ec1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171703
  00ec8	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv551[rsp], rax
  00ed0	eb 0f		 jmp	 SHORT $LN75@cckd64_sf_
$LN74@cckd64_sf_:
  00ed2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171704
  00ed9	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv551[rsp], rax
$LN75@cckd64_sf_:
  00ee1	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00eea	74 15		 je	 SHORT $LN76@cckd64_sf_
  00eec	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ef4	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ef8	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv557[rsp], eax
  00eff	eb 0b		 jmp	 SHORT $LN77@cckd64_sf_
$LN76@cckd64_sf_:
  00f01	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv557[rsp], 0
$LN77@cckd64_sf_:
  00f0c	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00f15	74 17		 je	 SHORT $LN78@cckd64_sf_
  00f17	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f1f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00f23	d1 f8		 sar	 eax, 1
  00f25	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv563[rsp], eax
  00f2c	eb 0b		 jmp	 SHORT $LN79@cckd64_sf_
$LN78@cckd64_sf_:
  00f2e	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv563[rsp], 0
$LN79@cckd64_sf_:
  00f39	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00f41	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv493[rsp], rax
  00f49	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00f51	48 89 8c 24 90
	01 00 00	 mov	 QWORD PTR tv498[rsp], rcx
  00f59	48 63 94 24 98
	00 00 00	 movsxd	 rdx, DWORD PTR i$[rsp]
  00f61	48 89 94 24 98
	01 00 00	 mov	 QWORD PTR tv503[rsp], rdx
  00f69	48 63 bc 24 98
	00 00 00	 movsxd	 rdi, DWORD PTR i$[rsp]
  00f71	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR cckd$[rsp]
  00f79	41 0f b6 bc 38
	1d 01 00 00	 movzx	 edi, BYTE PTR [r8+rdi+285]
  00f82	4c 63 84 24 98
	00 00 00	 movsxd	 r8, DWORD PTR i$[rsp]
  00f8a	4d 69 c0 00 02
	00 00		 imul	 r8, r8, 512		; 00000200H
  00f91	4c 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv517[rsp], r8
  00f99	4c 63 8c 24 98
	00 00 00	 movsxd	 r9, DWORD PTR i$[rsp]
  00fa1	4d 69 c9 00 02
	00 00		 imul	 r9, r9, 512		; 00000200H
  00fa8	4c 89 8c 24 a8
	01 00 00	 mov	 QWORD PTR tv543[rsp], r9
  00fb0	b9 01 00 00 00	 mov	 ecx, 1
  00fb5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00fbb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00fc3	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR tv493[rsp]
  00fcb	8b 8c 91 4c 01
	00 00		 mov	 ecx, DWORD PTR [rcx+rdx*4+332]
  00fd2	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  00fd9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00fe1	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR tv498[rsp]
  00fe9	8b 8c 91 70 01
	00 00		 mov	 ecx, DWORD PTR [rcx+rdx*4+368]
  00ff0	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  00ff7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00fff	48 8b 94 24 98
	01 00 00	 mov	 rdx, QWORD PTR tv503[rsp]
  01007	8b 8c 91 28 01
	00 00		 mov	 ecx, DWORD PTR [rcx+rdx*4+296]
  0100e	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  01012	48 8b 8c fc e8
	01 00 00	 mov	 rcx, QWORD PTR ost$[rsp+rdi*8]
  0101a	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  0101f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  01027	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR tv517[rsp]
  0102f	48 8b 8c 11 18
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rdx+536]
  01037	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  0103c	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv539[rsp]
  01044	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  01049	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  01051	48 8b 94 24 a8
	01 00 00	 mov	 rdx, QWORD PTR tv543[rsp]
  01059	48 8b 8c 11 f0
	01 00 00	 mov	 rcx, QWORD PTR [rcx+rdx+496]
  01061	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01066	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv551[rsp]
  0106e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01073	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  0107a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0107e	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv557[rsp]
  01085	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01089	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv563[rsp]
  01090	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171705
  0109b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171706
  010a7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010b1	41 b9 03 00 00
	00		 mov	 r9d, 3
  010b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171707
  010be	ba 05 10 00 00	 mov	 edx, 4101		; 00001005H
  010c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171708
  010ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4093 : 
; 4094 :             , cckd->cdevhdr[i].cdh_size ?
; 4095 :               ((S64)(cckd->cdevhdr[i].free_total * 100) / cckd->cdevhdr[i].cdh_size) : 999
; 4096 :             ,        cckd->cdevhdr[i].free_num
; 4097 :             , ost[cckd->open[i]]
; 4098 :             , cckd->reads[i]
; 4099 :             , cckd->writes[i]
; 4100 :             , cckd->L2_reads[i]
; 4101 :         );
; 4102 :     }

  010d0	e9 33 fd ff ff	 jmp	 $LN8@cckd64_sf_
$LN9@cckd64_sf_:

; 4103 : 
; 4104 :     return NULL;

  010d5	33 c0		 xor	 eax, eax
$LN1@cckd64_sf_:

; 4105 : } /* end function cckd64_sf_stats */

  010d7	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  010df	48 33 cc	 xor	 rcx, rsp
  010e2	e8 00 00 00 00	 call	 __security_check_cookie
  010e7	48 81 c4 10 02
	00 00		 add	 rsp, 528		; 00000210H
  010ee	5f		 pop	 rdi
  010ef	c3		 ret	 0
cckd64_sf_stats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
dev$ = 96
cckd$ = 104
level$ = 112
n$1 = 116
tv74 = 120
tv80 = 124
tv147 = 128
tv153 = 132
tv186 = 136
tv192 = 140
rc$ = 144
tv173 = 152
data$ = 176
cckd64_sf_chk PROC

; 3879 : {

$LN27:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 3880 : DEVBLK         *dev = data;             /* -> DEVBLK                 */

  0000c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00014	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax

; 3881 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 3882 : int             rc;                     /* Return code               */
; 3883 : int             level = 2;              /* Check level               */

  00019	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR level$[rsp], 2

; 3884 : 
; 3885 :     /* NULL DEVBLK == all devices? */
; 3886 :     if (!dev)

  00021	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00027	0f 85 82 01 00
	00		 jne	 $LN7@cckd64_sf_

; 3887 :     {
; 3888 :     int n = 0;

  0002d	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0

; 3889 :         level = cckdblk.sflevel;

  00035	8b 05 14 00 00
	00		 mov	 eax, DWORD PTR cckdblk+20
  0003b	89 44 24 70	 mov	 DWORD PTR level$[rsp], eax

; 3890 :         cckdblk.sflevel = 0;

  0003f	c7 05 14 00 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+20, 0

; 3891 :         for (dev=sysblk.firstdev; dev; dev=dev->nextdev)

  00049	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00050	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00057	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
  0005c	eb 0e		 jmp	 SHORT $LN4@cckd64_sf_
$LN2@cckd64_sf_:
  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00063	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00067	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd64_sf_:
  0006c	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00072	0f 84 e1 00 00
	00		 je	 $LN3@cckd64_sf_

; 3892 :         {
; 3893 :             if ((cckd = dev->cckd_ext)) /* Compressed device? */

  00078	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0007d	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00084	48 89 44 24 68	 mov	 QWORD PTR cckd$[rsp], rax
  00089	48 83 7c 24 68
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  0008f	0f 84 bf 00 00
	00		 je	 $LN8@cckd64_sf_

; 3894 :             {
; 3895 :                 // "%1d:%04X CCKD file: checking level %d..."
; 3896 :                 WRMSG( HHC00330, "I", LCSS_DEVNUM, level );

  00095	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0009b	74 0f		 je	 SHORT $LN15@cckd64_sf_
  0009d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000a2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000a6	89 44 24 78	 mov	 DWORD PTR tv74[rsp], eax
  000aa	eb 08		 jmp	 SHORT $LN16@cckd64_sf_
$LN15@cckd64_sf_:
  000ac	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN16@cckd64_sf_:
  000b4	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000ba	74 11		 je	 SHORT $LN17@cckd64_sf_
  000bc	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000c1	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000c5	d1 f8		 sar	 eax, 1
  000c7	89 44 24 7c	 mov	 DWORD PTR tv80[rsp], eax
  000cb	eb 08		 jmp	 SHORT $LN18@cckd64_sf_
$LN17@cckd64_sf_:
  000cd	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@cckd64_sf_:
  000d5	b9 01 00 00 00	 mov	 ecx, 1
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e0	8b 4c 24 70	 mov	 ecx, DWORD PTR level$[rsp]
  000e4	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000e8	8b 4c 24 78	 mov	 ecx, DWORD PTR tv74[rsp]
  000ec	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f0	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv80[rsp]
  000f4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171572
  000ff	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171573
  0010b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00110	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00115	41 b9 03 00 00
	00		 mov	 r9d, 3
  0011b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171574
  00122	ba 38 0f 00 00	 mov	 edx, 3896		; 00000f38H
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171575
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3897 :                 cckd->sflevel = level;

  00134	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00139	8b 4c 24 70	 mov	 ecx, DWORD PTR level$[rsp]
  0013d	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 3898 :                 cckd64_sf_chk( dev );

  00140	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00145	e8 00 00 00 00	 call	 cckd64_sf_chk

; 3899 :                 n++;

  0014a	8b 44 24 74	 mov	 eax, DWORD PTR n$1[rsp]
  0014e	ff c0		 inc	 eax
  00150	89 44 24 74	 mov	 DWORD PTR n$1[rsp], eax
$LN8@cckd64_sf_:

; 3900 :             }
; 3901 :         }

  00154	e9 05 ff ff ff	 jmp	 $LN2@cckd64_sf_
$LN3@cckd64_sf_:

; 3902 :         // "CCKD file number of devices processed: %d"
; 3903 :         WRMSG( HHC00316, "I", n );

  00159	b9 01 00 00 00	 mov	 ecx, 1
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00164	8b 4c 24 74	 mov	 ecx, DWORD PTR n$1[rsp]
  00168	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0016c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171576
  00173	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00178	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171577
  0017f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00184	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00189	41 b9 03 00 00
	00		 mov	 r9d, 3
  0018f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171578
  00196	ba 3f 0f 00 00	 mov	 edx, 3903		; 00000f3fH
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171579
  001a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3904 :         return NULL;

  001a8	33 c0		 xor	 eax, eax
  001aa	e9 e5 03 00 00	 jmp	 $LN1@cckd64_sf_
$LN7@cckd64_sf_:

; 3905 :     }
; 3906 : 
; 3907 :     if (!dev->cckd64)

  001af	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001b4	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  001bb	24 01		 and	 al, 1
  001bd	0f b6 c0	 movzx	 eax, al
  001c0	85 c0		 test	 eax, eax
  001c2	75 12		 jne	 SHORT $LN9@cckd64_sf_

; 3908 :         return cckd_sf_chk( data );

  001c4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  001cc	e8 00 00 00 00	 call	 cckd_sf_chk
  001d1	e9 be 03 00 00	 jmp	 $LN1@cckd64_sf_
$LN9@cckd64_sf_:

; 3909 : 
; 3910 :     if (!(cckd = dev->cckd_ext))

  001d6	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001db	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  001e2	48 89 44 24 68	 mov	 QWORD PTR cckd$[rsp], rax
  001e7	48 83 7c 24 68
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  001ed	0f 85 b0 00 00
	00		 jne	 $LN10@cckd64_sf_

; 3911 :     {
; 3912 :         // "%1d:%04X CCKD file: device is not a cckd device"
; 3913 :         WRMSG( HHC00317, "W",  LCSS_DEVNUM );

  001f3	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001f9	74 12		 je	 SHORT $LN19@cckd64_sf_
  001fb	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00200	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00204	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv147[rsp], eax
  0020b	eb 0b		 jmp	 SHORT $LN20@cckd64_sf_
$LN19@cckd64_sf_:
  0020d	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv147[rsp], 0
$LN20@cckd64_sf_:
  00218	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0021e	74 14		 je	 SHORT $LN21@cckd64_sf_
  00220	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00225	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00229	d1 f8		 sar	 eax, 1
  0022b	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv153[rsp], eax
  00232	eb 0b		 jmp	 SHORT $LN22@cckd64_sf_
$LN21@cckd64_sf_:
  00234	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv153[rsp], 0
$LN22@cckd64_sf_:
  0023f	b9 01 00 00 00	 mov	 ecx, 1
  00244	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0024a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv147[rsp]
  00251	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00255	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv153[rsp]
  0025c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00260	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171582
  00267	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0026c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171583
  00273	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00278	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00283	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171584
  0028a	ba 49 0f 00 00	 mov	 edx, 3913		; 00000f49H
  0028f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171585
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3914 :         return NULL;

  0029c	33 c0		 xor	 eax, eax
  0029e	e9 f1 02 00 00	 jmp	 $LN1@cckd64_sf_
$LN10@cckd64_sf_:

; 3915 :     }
; 3916 : 
; 3917 :     level = cckd->sflevel;

  002a3	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002a8	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  002ab	89 44 24 70	 mov	 DWORD PTR level$[rsp], eax

; 3918 :     cckd->sflevel = 0;

  002af	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002b4	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 3919 : 
; 3920 :     /* schedule updated track entries to be written */
; 3921 :     obtain_lock( &cckd->cckdiolock );

  002bb	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002c0	48 83 c0 18	 add	 rax, 24
  002c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171586
  002cb	48 8b c8	 mov	 rcx, rax
  002ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3922 :     {
; 3923 :         if (cckd->merging)

  002d4	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002d9	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002dc	c1 e8 05	 shr	 eax, 5
  002df	83 e0 01	 and	 eax, 1
  002e2	85 c0		 test	 eax, eax
  002e4	0f 84 fc 00 00
	00		 je	 $LN11@cckd64_sf_

; 3924 :         {
; 3925 :             release_lock( &cckd->cckdiolock );

  002ea	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002ef	48 83 c0 18	 add	 rax, 24
  002f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171588
  002fa	48 8b c8	 mov	 rcx, rax
  002fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3926 :             // "%1d:%04X CCKD file[%d] %s: shadow file check failed, sf command busy on device"
; 3927 :             WRMSG( HHC00331, "W", LCSS_DEVNUM, cckd->sfn, cckd_sf_name( dev, cckd->sfn ));

  00303	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00309	74 12		 je	 SHORT $LN23@cckd64_sf_
  0030b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00310	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00314	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv186[rsp], eax
  0031b	eb 0b		 jmp	 SHORT $LN24@cckd64_sf_
$LN23@cckd64_sf_:
  0031d	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv186[rsp], 0
$LN24@cckd64_sf_:
  00328	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0032e	74 14		 je	 SHORT $LN25@cckd64_sf_
  00330	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00335	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00339	d1 f8		 sar	 eax, 1
  0033b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv192[rsp], eax
  00342	eb 0b		 jmp	 SHORT $LN26@cckd64_sf_
$LN25@cckd64_sf_:
  00344	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv192[rsp], 0
$LN26@cckd64_sf_:
  0034f	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00354	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00357	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0035c	e8 00 00 00 00	 call	 cckd_sf_name
  00361	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv173[rsp], rax
  00369	b9 01 00 00 00	 mov	 ecx, 1
  0036e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00374	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv173[rsp]
  0037c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00381	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00386	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00389	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0038d	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv186[rsp]
  00394	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00398	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv192[rsp]
  0039f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171589
  003aa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171590
  003b6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003c0	41 b9 03 00 00
	00		 mov	 r9d, 3
  003c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171591
  003cd	ba 57 0f 00 00	 mov	 edx, 3927		; 00000f57H
  003d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171592
  003d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3928 :             return NULL;

  003df	33 c0		 xor	 eax, eax
  003e1	e9 ae 01 00 00	 jmp	 $LN1@cckd64_sf_
$LN11@cckd64_sf_:

; 3929 :         }
; 3930 : 
; 3931 :         cckd->merging = 1;

  003e6	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003eb	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003ee	83 c8 20	 or	 eax, 32			; 00000020H
  003f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  003f6	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3932 :         cckd64_flush_cache( dev );

  003f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003fe	e8 00 00 00 00	 call	 cckd64_flush_cache
$LN5@cckd64_sf_:

; 3933 : 
; 3934 :         while (cckd->wrpending || cckd->cckdioact)

  00403	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00408	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  0040c	75 12		 jne	 SHORT $LN12@cckd64_sf_
  0040e	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00413	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00416	c1 e8 02	 shr	 eax, 2
  00419	83 e0 01	 and	 eax, 1
  0041c	85 c0		 test	 eax, eax
  0041e	74 52		 je	 SHORT $LN6@cckd64_sf_
$LN12@cckd64_sf_:

; 3935 :         {
; 3936 :             cckd->cckdwaiters++;

  00420	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00425	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00428	ff c0		 inc	 eax
  0042a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  0042f	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 3937 :             {
; 3938 :                 wait_condition( &cckd->cckdiocond, &cckd->cckdiolock );

  00432	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00437	48 83 c0 18	 add	 rax, 24
  0043b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00440	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00444	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171594
  0044b	48 8b d0	 mov	 rdx, rax
  0044e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 3939 :             }
; 3940 :             cckd->cckdwaiters--;

  00454	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00459	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0045c	ff c8		 dec	 eax
  0045e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00463	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 3941 : 
; 3942 :             cckd64_flush_cache( dev );

  00466	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0046b	e8 00 00 00 00	 call	 cckd64_flush_cache

; 3943 :         }

  00470	eb 91		 jmp	 SHORT $LN5@cckd64_sf_
$LN6@cckd64_sf_:

; 3944 :         cckd64_purge_cache( dev );

  00472	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00477	e8 00 00 00 00	 call	 cckd64_purge_cache

; 3945 :         cckd64_purge_l2( dev );

  0047c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00481	e8 00 00 00 00	 call	 cckd64_purge_l2

; 3946 :         dev->bufcur = -1;

  00486	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0048b	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 3947 :         dev->cache  = -1;

  00495	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0049a	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1

; 3948 :     }
; 3949 :     release_lock( &cckd->cckdiolock );

  004a4	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004a9	48 83 c0 18	 add	 rax, 24
  004ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171595
  004b4	48 8b c8	 mov	 rcx, rax
  004b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3950 : 
; 3951 :     /* obtain control of the file */
; 3952 :     obtain_lock( &cckd->filelock );

  004bd	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004c2	48 83 c0 10	 add	 rax, 16
  004c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171596
  004cd	48 8b c8	 mov	 rcx, rax
  004d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3953 :     {
; 3954 :         /* harden the current file */
; 3955 :         cckd64_harden( dev );

  004d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  004db	e8 00 00 00 00	 call	 cckd64_harden

; 3956 : 
; 3957 :         /* Call the chkdsk function */
; 3958 :         rc = cckd64_chkdsk( dev, level );

  004e0	8b 54 24 70	 mov	 edx, DWORD PTR level$[rsp]
  004e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  004e9	e8 00 00 00 00	 call	 cckd64_chkdsk
  004ee	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3959 : 
; 3960 :         /* Perform initial read */
; 3961 :         rc = cckd64_read_init( dev );

  004f5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  004fa	e8 00 00 00 00	 call	 cckd64_read_init
  004ff	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3962 :     }
; 3963 :     release_lock( &cckd->filelock );

  00506	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0050b	48 83 c0 10	 add	 rax, 16
  0050f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171597
  00516	48 8b c8	 mov	 rcx, rax
  00519	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3964 : 
; 3965 :     obtain_lock( &cckd->cckdiolock );

  0051f	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00524	48 83 c0 18	 add	 rax, 24
  00528	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171598
  0052f	48 8b c8	 mov	 rcx, rax
  00532	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3966 :     {
; 3967 :         cckd->merging = 0;

  00538	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0053d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00540	83 e0 df	 and	 eax, -33		; ffffffdfH
  00543	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00548	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3968 :         if (cckd->cckdwaiters)

  0054b	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00550	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00554	74 19		 je	 SHORT $LN13@cckd64_sf_

; 3969 :             broadcast_condition( &cckd->cckdiocond );

  00556	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0055b	48 83 c0 20	 add	 rax, 32			; 00000020H
  0055f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171600
  00566	48 8b c8	 mov	 rcx, rax
  00569	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN13@cckd64_sf_:

; 3970 :     }
; 3971 :     release_lock( &cckd->cckdiolock );

  0056f	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00574	48 83 c0 18	 add	 rax, 24
  00578	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171601
  0057f	48 8b c8	 mov	 rcx, rax
  00582	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3972 : 
; 3973 :     /* Display the shadow file statistics */
; 3974 :     cckd64_sf_stats( dev );

  00588	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0058d	e8 00 00 00 00	 call	 cckd64_sf_stats

; 3975 : 
; 3976 :     return NULL;

  00592	33 c0		 xor	 eax, eax
$LN1@cckd64_sf_:

; 3977 : } /* end function cckd64_sf_chk */

  00594	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0059b	c3		 ret	 0
cckd64_sf_chk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
dev$ = 96
cckd$ = 104
n$1 = 112
tv73 = 116
tv79 = 120
tv145 = 124
tv151 = 128
tv182 = 132
tv188 = 136
rc$ = 140
tv169 = 144
data$ = 176
cckd64_sf_comp PROC

; 3788 : {

$LN27:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 3789 : DEVBLK         *dev = data;             /* -> DEVBLK                 */

  0000c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00014	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax

; 3790 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 3791 : int             rc;                     /* Return code               */
; 3792 : 
; 3793 :     /* NULL DEVBLK == all devices? */
; 3794 :     if (!dev)

  00019	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0001f	0f 85 50 01 00
	00		 jne	 $LN7@cckd64_sf_

; 3795 :     {
; 3796 :     int n = 0;

  00025	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0

; 3797 :         for (dev=sysblk.firstdev; dev; dev=dev->nextdev)

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00034	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  0003b	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
  00040	eb 0e		 jmp	 SHORT $LN4@cckd64_sf_
$LN2@cckd64_sf_:
  00042	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00047	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0004b	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd64_sf_:
  00050	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00056	0f 84 c3 00 00
	00		 je	 $LN3@cckd64_sf_

; 3798 :         {
; 3799 :             if (dev->cckd_ext)  /* Is this a compressed device? */

  0005c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00061	48 83 b8 08 13
	00 00 00	 cmp	 QWORD PTR [rax+4872], 0
  00069	0f 84 ab 00 00
	00		 je	 $LN8@cckd64_sf_

; 3800 :             {
; 3801 :                 // "%1d:%04X CCKD file: compressing shadow files..."
; 3802 :                 WRMSG( HHC00328, "I", LCSS_DEVNUM );

  0006f	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00075	74 0f		 je	 SHORT $LN15@cckd64_sf_
  00077	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0007c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00080	89 44 24 74	 mov	 DWORD PTR tv73[rsp], eax
  00084	eb 08		 jmp	 SHORT $LN16@cckd64_sf_
$LN15@cckd64_sf_:
  00086	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN16@cckd64_sf_:
  0008e	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00094	74 11		 je	 SHORT $LN17@cckd64_sf_
  00096	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0009b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0009f	d1 f8		 sar	 eax, 1
  000a1	89 44 24 78	 mov	 DWORD PTR tv79[rsp], eax
  000a5	eb 08		 jmp	 SHORT $LN18@cckd64_sf_
$LN17@cckd64_sf_:
  000a7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN18@cckd64_sf_:
  000af	b9 01 00 00 00	 mov	 ecx, 1
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ba	8b 4c 24 74	 mov	 ecx, DWORD PTR tv73[rsp]
  000be	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c2	8b 4c 24 78	 mov	 ecx, DWORD PTR tv79[rsp]
  000c6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171523
  000d1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171524
  000dd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171525
  000f4	ba da 0e 00 00	 mov	 edx, 3802		; 00000edaH
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171526
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3803 :                 cckd64_sf_comp( dev );

  00106	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0010b	e8 00 00 00 00	 call	 cckd64_sf_comp

; 3804 :                 n++;

  00110	8b 44 24 70	 mov	 eax, DWORD PTR n$1[rsp]
  00114	ff c0		 inc	 eax
  00116	89 44 24 70	 mov	 DWORD PTR n$1[rsp], eax
$LN8@cckd64_sf_:

; 3805 :             }
; 3806 :         }

  0011a	e9 23 ff ff ff	 jmp	 $LN2@cckd64_sf_
$LN3@cckd64_sf_:

; 3807 :         // "CCKD file number of devices processed: %d"
; 3808 :         WRMSG ( HHC00316, "I", n );

  0011f	b9 01 00 00 00	 mov	 ecx, 1
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012a	8b 4c 24 70	 mov	 ecx, DWORD PTR n$1[rsp]
  0012e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171527
  00139	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171528
  00145	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00155	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171529
  0015c	ba e0 0e 00 00	 mov	 edx, 3808		; 00000ee0H
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171530
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3809 :         return NULL;

  0016e	33 c0		 xor	 eax, eax
  00170	e9 c0 03 00 00	 jmp	 $LN1@cckd64_sf_
$LN7@cckd64_sf_:

; 3810 :     }
; 3811 : 
; 3812 :     if (!dev->cckd64)

  00175	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0017a	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00181	24 01		 and	 al, 1
  00183	0f b6 c0	 movzx	 eax, al
  00186	85 c0		 test	 eax, eax
  00188	75 12		 jne	 SHORT $LN9@cckd64_sf_

; 3813 :         return cckd_sf_comp( data );

  0018a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  00192	e8 00 00 00 00	 call	 cckd_sf_comp
  00197	e9 99 03 00 00	 jmp	 $LN1@cckd64_sf_
$LN9@cckd64_sf_:

; 3814 : 
; 3815 :     if (!(cckd = dev->cckd_ext))

  0019c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001a1	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  001a8	48 89 44 24 68	 mov	 QWORD PTR cckd$[rsp], rax
  001ad	48 83 7c 24 68
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  001b3	0f 85 a7 00 00
	00		 jne	 $LN10@cckd64_sf_

; 3816 :     {
; 3817 :         // "%1d:%04X CCKD file: device is not a cckd device"
; 3818 :         WRMSG( HHC00317, "W",  LCSS_DEVNUM );

  001b9	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001bf	74 0f		 je	 SHORT $LN19@cckd64_sf_
  001c1	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001c6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001ca	89 44 24 7c	 mov	 DWORD PTR tv145[rsp], eax
  001ce	eb 08		 jmp	 SHORT $LN20@cckd64_sf_
$LN19@cckd64_sf_:
  001d0	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN20@cckd64_sf_:
  001d8	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001de	74 14		 je	 SHORT $LN21@cckd64_sf_
  001e0	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001e5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001e9	d1 f8		 sar	 eax, 1
  001eb	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv151[rsp], eax
  001f2	eb 0b		 jmp	 SHORT $LN22@cckd64_sf_
$LN21@cckd64_sf_:
  001f4	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv151[rsp], 0
$LN22@cckd64_sf_:
  001ff	b9 01 00 00 00	 mov	 ecx, 1
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0020a	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv145[rsp]
  0020e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00212	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv151[rsp]
  00219	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0021d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171533
  00224	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171534
  00230	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00235	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00240	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171535
  00247	ba ea 0e 00 00	 mov	 edx, 3818		; 00000eeaH
  0024c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171536
  00253	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3819 :         return NULL;

  00259	33 c0		 xor	 eax, eax
  0025b	e9 d5 02 00 00	 jmp	 $LN1@cckd64_sf_
$LN10@cckd64_sf_:

; 3820 :     }
; 3821 : 
; 3822 :     /* schedule updated track entries to be written */
; 3823 :     obtain_lock( &cckd->cckdiolock );

  00260	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00265	48 83 c0 18	 add	 rax, 24
  00269	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171537
  00270	48 8b c8	 mov	 rcx, rax
  00273	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3824 :     {
; 3825 :         if (cckd->merging)

  00279	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0027e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00281	c1 e8 05	 shr	 eax, 5
  00284	83 e0 01	 and	 eax, 1
  00287	85 c0		 test	 eax, eax
  00289	0f 84 fc 00 00
	00		 je	 $LN11@cckd64_sf_

; 3826 :         {
; 3827 :             release_lock( &cckd->cckdiolock );

  0028f	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00294	48 83 c0 18	 add	 rax, 24
  00298	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171539
  0029f	48 8b c8	 mov	 rcx, rax
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3828 :             // "%1d:%04X CCKD file[%d] %s: error compressing shadow file, sf command busy on device"
; 3829 :             WRMSG( HHC00329, "W",  LCSS_DEVNUM, cckd->sfn, cckd_sf_name(dev, cckd->sfn) );

  002a8	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002ae	74 12		 je	 SHORT $LN23@cckd64_sf_
  002b0	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002b5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002b9	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv182[rsp], eax
  002c0	eb 0b		 jmp	 SHORT $LN24@cckd64_sf_
$LN23@cckd64_sf_:
  002c2	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv182[rsp], 0
$LN24@cckd64_sf_:
  002cd	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002d3	74 14		 je	 SHORT $LN25@cckd64_sf_
  002d5	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002da	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002de	d1 f8		 sar	 eax, 1
  002e0	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv188[rsp], eax
  002e7	eb 0b		 jmp	 SHORT $LN26@cckd64_sf_
$LN25@cckd64_sf_:
  002e9	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv188[rsp], 0
$LN26@cckd64_sf_:
  002f4	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002f9	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  002fc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00301	e8 00 00 00 00	 call	 cckd_sf_name
  00306	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv169[rsp], rax
  0030e	b9 01 00 00 00	 mov	 ecx, 1
  00313	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00319	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv169[rsp]
  00321	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00326	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  0032b	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  0032e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00332	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv182[rsp]
  00339	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0033d	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv188[rsp]
  00344	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00348	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171540
  0034f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00354	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171541
  0035b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00360	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00365	41 b9 03 00 00
	00		 mov	 r9d, 3
  0036b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171542
  00372	ba f5 0e 00 00	 mov	 edx, 3829		; 00000ef5H
  00377	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171543
  0037e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3830 :             return NULL;

  00384	33 c0		 xor	 eax, eax
  00386	e9 aa 01 00 00	 jmp	 $LN1@cckd64_sf_
$LN11@cckd64_sf_:

; 3831 :         }
; 3832 :         cckd->merging = 1;

  0038b	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00390	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00393	83 c8 20	 or	 eax, 32			; 00000020H
  00396	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  0039b	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3833 :         cckd64_flush_cache( dev );

  0039e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003a3	e8 00 00 00 00	 call	 cckd64_flush_cache
$LN5@cckd64_sf_:

; 3834 :         while (cckd->wrpending || cckd->cckdioact)

  003a8	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003ad	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  003b1	75 12		 jne	 SHORT $LN12@cckd64_sf_
  003b3	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003b8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003bb	c1 e8 02	 shr	 eax, 2
  003be	83 e0 01	 and	 eax, 1
  003c1	85 c0		 test	 eax, eax
  003c3	74 52		 je	 SHORT $LN6@cckd64_sf_
$LN12@cckd64_sf_:

; 3835 :         {
; 3836 :             cckd->cckdwaiters++;

  003c5	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003ca	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  003cd	ff c0		 inc	 eax
  003cf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  003d4	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 3837 :             wait_condition( &cckd->cckdiocond, &cckd->cckdiolock );

  003d7	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003dc	48 83 c0 18	 add	 rax, 24
  003e0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  003e5	48 83 c1 20	 add	 rcx, 32			; 00000020H
  003e9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171545
  003f0	48 8b d0	 mov	 rdx, rax
  003f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 3838 :             cckd->cckdwaiters--;

  003f9	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003fe	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00401	ff c8		 dec	 eax
  00403	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00408	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 3839 :             cckd64_flush_cache( dev );

  0040b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00410	e8 00 00 00 00	 call	 cckd64_flush_cache

; 3840 :         }

  00415	eb 91		 jmp	 SHORT $LN5@cckd64_sf_
$LN6@cckd64_sf_:

; 3841 :         cckd64_purge_cache( dev );

  00417	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0041c	e8 00 00 00 00	 call	 cckd64_purge_cache

; 3842 :         cckd64_purge_l2( dev );

  00421	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00426	e8 00 00 00 00	 call	 cckd64_purge_l2

; 3843 :         dev->bufcur = dev->cache = -1;

  0042b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00430	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0043a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0043f	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 3844 :     }
; 3845 :     release_lock( &cckd->cckdiolock );

  00449	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0044e	48 83 c0 18	 add	 rax, 24
  00452	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171546
  00459	48 8b c8	 mov	 rcx, rax
  0045c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3846 : 
; 3847 :     /* obtain control of the file */
; 3848 :     obtain_lock( &cckd->filelock );

  00462	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00467	48 83 c0 10	 add	 rax, 16
  0046b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171547
  00472	48 8b c8	 mov	 rcx, rax
  00475	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3849 :     {
; 3850 :         /* harden the current file */
; 3851 :         cckd64_harden( dev );

  0047b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00480	e8 00 00 00 00	 call	 cckd64_harden

; 3852 : 
; 3853 :         /* Call the compress function */
; 3854 :         rc = cckd64_comp( dev );

  00485	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0048a	e8 00 00 00 00	 call	 cckd64_comp
  0048f	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3855 : 
; 3856 :         /* Perform initial read */
; 3857 :         rc = cckd64_read_init( dev );

  00496	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0049b	e8 00 00 00 00	 call	 cckd64_read_init
  004a0	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3858 :     }
; 3859 :     release_lock( &cckd->filelock );

  004a7	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004ac	48 83 c0 10	 add	 rax, 16
  004b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171548
  004b7	48 8b c8	 mov	 rcx, rax
  004ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3860 : 
; 3861 :     obtain_lock( &cckd->cckdiolock );

  004c0	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004c5	48 83 c0 18	 add	 rax, 24
  004c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171549
  004d0	48 8b c8	 mov	 rcx, rax
  004d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3862 :     {
; 3863 :         cckd->merging = 0;

  004d9	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004de	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  004e1	83 e0 df	 and	 eax, -33		; ffffffdfH
  004e4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  004e9	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3864 :         if (cckd->cckdwaiters)

  004ec	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004f1	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  004f5	74 19		 je	 SHORT $LN13@cckd64_sf_

; 3865 :             broadcast_condition( &cckd->cckdiocond );

  004f7	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  004fc	48 83 c0 20	 add	 rax, 32			; 00000020H
  00500	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171551
  00507	48 8b c8	 mov	 rcx, rax
  0050a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN13@cckd64_sf_:

; 3866 :     }
; 3867 :     release_lock( &cckd->cckdiolock );

  00510	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00515	48 83 c0 18	 add	 rax, 24
  00519	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171552
  00520	48 8b c8	 mov	 rcx, rax
  00523	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3868 : 
; 3869 :     /* Display the shadow file statistics */
; 3870 :     cckd64_sf_stats( dev );

  00529	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0052e	e8 00 00 00 00	 call	 cckd64_sf_stats

; 3871 : 
; 3872 :     return NULL;

  00533	33 c0		 xor	 eax, eax
$LN1@cckd64_sf_:

; 3873 : } /* end function cckd64_sf_comp */

  00535	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0053c	c3		 ret	 0
cckd64_sf_comp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
dev$ = 112
cckd$ = 120
to_sfx$ = 128
from_sfx$ = 132
i$ = 136
j$ = 140
pos$ = 144
len$ = 152
merge$ = 156
l2updated$ = 160
force$ = 164
size$ = 168
trk$ = 172
n$1 = 176
add$ = 180
tv169 = 184
tv188 = 188
tv228 = 192
tv234 = 196
tv326 = 200
tv332 = 204
tv370 = 208
tv376 = 212
tv427 = 216
tv433 = 220
tv461 = 224
tv467 = 228
tv815 = 232
tv821 = 236
tv901 = 240
tv907 = 244
tv927 = 248
tv933 = 252
tv79 = 256
tv85 = 260
tv163 = 264
rc$ = 268
fix$ = 272
tv199 = 280
tv202 = 288
tv415 = 296
tv803 = 304
tv805 = 312
tv215 = 320
tv281 = 328
tv361 = 336
tv419 = 344
tv453 = 352
tv807 = 360
tv893 = 368
tv919 = 376
new_l2$ = 384
to_l2$ = 400
from_l2$ = 4496
buf$ = 8592
__$ArrayPad$ = 74128
data$ = 74160
cckd64_sf_remove PROC

; 3444 : {

$LN111:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	b8 a0 21 01 00	 mov	 eax, 74144		; 000121a0H
  0000b	e8 00 00 00 00	 call	 __chkstk
  00010	48 2b e0	 sub	 rsp, rax
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 90
	21 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3445 : DEVBLK         *dev = data;             /* -> DEVBLK                 */

  00025	48 8b 84 24 b0
	21 01 00	 mov	 rax, QWORD PTR data$[rsp]
  0002d	48 89 44 24 70	 mov	 QWORD PTR dev$[rsp], rax

; 3446 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 3447 : int             rc;                     /* Return code               */
; 3448 : int             from_sfx, to_sfx;       /* From/to file index        */
; 3449 : int             fix;                    /* nullfmt index             */
; 3450 : int             add = 0;                /* 1=Add shadow file back    */

  00032	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR add$[rsp], 0

; 3451 : int             l2updated = 0;          /* 1=L2 table was updated    */

  0003d	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR l2updated$[rsp], 0

; 3452 : int             i,j;                    /* Loop indexes              */
; 3453 : int             merge, force;           /* Flags                     */
; 3454 : U64             pos;                    /* File offset               */
; 3455 : unsigned int    len;                    /* Length to read/write      */
; 3456 : int             size;                   /* Image size                */
; 3457 : int             trk = -1;               /* Track being read/written  */

  00048	c7 84 24 ac 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR trk$[rsp], -1

; 3458 : CCKD64_L2ENT    from_l2[256],           /* Level 2 tables            */
; 3459 :                 to_l2[256];
; 3460 : CCKD64_L2ENT    new_l2;                 /* New level 2 table entry   */
; 3461 : BYTE            buf[64*1024];           /* Buffer                    */
; 3462 : 
; 3463 :     /* NULL DEVBLK == all devices? */
; 3464 :     if (!dev)

  00053	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00059	0f 85 06 02 00
	00		 jne	 $LN13@cckd64_sf_

; 3465 :     {
; 3466 :     int n = 0;

  0005f	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR n$1[rsp], 0

; 3467 :         merge = cckdblk.sfmerge;

  0006a	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00070	c1 e8 03	 shr	 eax, 3
  00073	83 e0 01	 and	 eax, 1
  00076	89 84 24 9c 00
	00 00		 mov	 DWORD PTR merge$[rsp], eax

; 3468 :         force = cckdblk.sfforce;

  0007d	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00083	c1 e8 04	 shr	 eax, 4
  00086	83 e0 01	 and	 eax, 1
  00089	89 84 24 a4 00
	00 00		 mov	 DWORD PTR force$[rsp], eax

; 3469 :         cckdblk.sfmerge = cckdblk.sfforce = 0;

  00090	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  00096	83 e0 ef	 and	 eax, -17		; ffffffefH
  00099	89 05 10 00 00
	00		 mov	 DWORD PTR cckdblk+16, eax
  0009f	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  000a5	83 e0 f7	 and	 eax, -9			; fffffff7H
  000a8	89 05 10 00 00
	00		 mov	 DWORD PTR cckdblk+16, eax

; 3470 :         for (dev=sysblk.firstdev; dev; dev=dev->nextdev)

  000ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b5	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  000bc	48 89 44 24 70	 mov	 QWORD PTR dev$[rsp], rax
  000c1	eb 0e		 jmp	 SHORT $LN4@cckd64_sf_
$LN2@cckd64_sf_:
  000c3	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000c8	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000cc	48 89 44 24 70	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd64_sf_:
  000d1	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000d7	0f 84 2f 01 00
	00		 je	 $LN3@cckd64_sf_

; 3471 :         {
; 3472 :             if ((cckd = dev->cckd_ext)) /* Compressed device? */

  000dd	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000e2	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  000e9	48 89 44 24 78	 mov	 QWORD PTR cckd$[rsp], rax
  000ee	48 83 7c 24 78
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  000f4	0f 84 0d 01 00
	00		 je	 $LN14@cckd64_sf_

; 3473 :             {
; 3474 :                 // "%1d:%04X CCKD file: merging shadow files..."
; 3475 :                 WRMSG( HHC00321, "I", LCSS_DEVNUM );

  000fa	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00100	74 12		 je	 SHORT $LN59@cckd64_sf_
  00102	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00107	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0010b	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv79[rsp], eax
  00112	eb 0b		 jmp	 SHORT $LN60@cckd64_sf_
$LN59@cckd64_sf_:
  00114	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv79[rsp], 0
$LN60@cckd64_sf_:
  0011f	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00125	74 14		 je	 SHORT $LN61@cckd64_sf_
  00127	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0012c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00130	d1 f8		 sar	 eax, 1
  00132	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv85[rsp], eax
  00139	eb 0b		 jmp	 SHORT $LN62@cckd64_sf_
$LN61@cckd64_sf_:
  0013b	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv85[rsp], 0
$LN62@cckd64_sf_:
  00146	b9 01 00 00 00	 mov	 ecx, 1
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00151	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv79[rsp]
  00158	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0015c	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv85[rsp]
  00163	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171386
  0016e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171387
  0017a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0017f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00184	41 b9 03 00 00
	00		 mov	 r9d, 3
  0018a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171388
  00191	ba 93 0d 00 00	 mov	 edx, 3475		; 00000d93H
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171389
  0019d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3476 :                 cckd->sfmerge = merge;

  001a3	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR merge$[rsp]
  001aa	83 e0 01	 and	 eax, 1
  001ad	c1 e0 09	 shl	 eax, 9
  001b0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001b5	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  001b8	0f ba f1 09	 btr	 ecx, 9
  001bc	0b c8		 or	 ecx, eax
  001be	8b c1		 mov	 eax, ecx
  001c0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001c5	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3477 :                 cckd->sfforce = force;

  001c8	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR force$[rsp]
  001cf	83 e0 01	 and	 eax, 1
  001d2	c1 e0 0a	 shl	 eax, 10
  001d5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001da	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  001dd	0f ba f1 0a	 btr	 ecx, 10
  001e1	0b c8		 or	 ecx, eax
  001e3	8b c1		 mov	 eax, ecx
  001e5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ea	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3478 :                 cckd64_sf_remove( dev );

  001ed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001f2	e8 00 00 00 00	 call	 cckd64_sf_remove

; 3479 :                 n++;

  001f7	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR n$1[rsp]
  001fe	ff c0		 inc	 eax
  00200	89 84 24 b0 00
	00 00		 mov	 DWORD PTR n$1[rsp], eax
$LN14@cckd64_sf_:

; 3480 :             }
; 3481 :         }

  00207	e9 b7 fe ff ff	 jmp	 $LN2@cckd64_sf_
$LN3@cckd64_sf_:

; 3482 :         // "CCKD file number of devices processed: %d"
; 3483 :         WRMSG( HHC00316, "I", n );

  0020c	b9 01 00 00 00	 mov	 ecx, 1
  00211	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00217	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR n$1[rsp]
  0021e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00222	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171390
  00229	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0022e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171391
  00235	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0023a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00245	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171392
  0024c	ba 9b 0d 00 00	 mov	 edx, 3483		; 00000d9bH
  00251	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171393
  00258	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3484 :         return NULL;

  0025e	33 c0		 xor	 eax, eax
  00260	e9 4d 17 00 00	 jmp	 $LN1@cckd64_sf_
$LN13@cckd64_sf_:

; 3485 :     }
; 3486 : 
; 3487 :     if (!dev->cckd64)

  00265	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0026a	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00271	24 01		 and	 al, 1
  00273	0f b6 c0	 movzx	 eax, al
  00276	85 c0		 test	 eax, eax
  00278	75 12		 jne	 SHORT $LN15@cckd64_sf_

; 3488 :         return cckd_sf_remove( data );

  0027a	48 8b 8c 24 b0
	21 01 00	 mov	 rcx, QWORD PTR data$[rsp]
  00282	e8 00 00 00 00	 call	 cckd_sf_remove
  00287	e9 26 17 00 00	 jmp	 $LN1@cckd64_sf_
$LN15@cckd64_sf_:

; 3489 : 
; 3490 :     if (!(cckd = dev->cckd_ext))

  0028c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00291	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00298	48 89 44 24 78	 mov	 QWORD PTR cckd$[rsp], rax
  0029d	48 83 7c 24 78
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  002a3	0f 85 b0 00 00
	00		 jne	 $LN16@cckd64_sf_

; 3491 :     {
; 3492 :         // "%1d:%04X CCKD file: device is not a cckd device"
; 3493 :         WRMSG( HHC00317, "W", LCSS_DEVNUM );

  002a9	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002af	74 12		 je	 SHORT $LN63@cckd64_sf_
  002b1	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002b6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002ba	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv163[rsp], eax
  002c1	eb 0b		 jmp	 SHORT $LN64@cckd64_sf_
$LN63@cckd64_sf_:
  002c3	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv163[rsp], 0
$LN64@cckd64_sf_:
  002ce	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002d4	74 14		 je	 SHORT $LN65@cckd64_sf_
  002d6	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002db	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002df	d1 f8		 sar	 eax, 1
  002e1	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv169[rsp], eax
  002e8	eb 0b		 jmp	 SHORT $LN66@cckd64_sf_
$LN65@cckd64_sf_:
  002ea	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv169[rsp], 0
$LN66@cckd64_sf_:
  002f5	b9 01 00 00 00	 mov	 ecx, 1
  002fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00300	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv163[rsp]
  00307	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0030b	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv169[rsp]
  00312	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00316	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171396
  0031d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00322	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171397
  00329	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0032e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00333	41 b9 03 00 00
	00		 mov	 r9d, 3
  00339	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171398
  00340	ba a5 0d 00 00	 mov	 edx, 3493		; 00000da5H
  00345	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171399
  0034c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3494 :         return NULL;

  00352	33 c0		 xor	 eax, eax
  00354	e9 59 16 00 00	 jmp	 $LN1@cckd64_sf_
$LN16@cckd64_sf_:

; 3495 :     }
; 3496 : 
; 3497 :     /* Set flags */
; 3498 :     merge = cckd->sfmerge || cckd->sfforce;

  00359	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0035e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00361	c1 e8 09	 shr	 eax, 9
  00364	83 e0 01	 and	 eax, 1
  00367	85 c0		 test	 eax, eax
  00369	75 1f		 jne	 SHORT $LN67@cckd64_sf_
  0036b	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00370	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00373	c1 e8 0a	 shr	 eax, 10
  00376	83 e0 01	 and	 eax, 1
  00379	85 c0		 test	 eax, eax
  0037b	75 0d		 jne	 SHORT $LN67@cckd64_sf_
  0037d	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv188[rsp], 0
  00388	eb 0b		 jmp	 SHORT $LN68@cckd64_sf_
$LN67@cckd64_sf_:
  0038a	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv188[rsp], 1
$LN68@cckd64_sf_:
  00395	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR tv188[rsp]
  0039c	89 84 24 9c 00
	00 00		 mov	 DWORD PTR merge$[rsp], eax

; 3499 :     force = cckd->sfforce;

  003a3	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  003a8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003ab	c1 e8 0a	 shr	 eax, 10
  003ae	83 e0 01	 and	 eax, 1
  003b1	89 84 24 a4 00
	00 00		 mov	 DWORD PTR force$[rsp], eax

; 3500 :     cckd->sfmerge = cckd->sfforce = 0;

  003b8	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  003bd	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003c0	0f ba f0 0a	 btr	 eax, 10
  003c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  003c9	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  003cc	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  003d1	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003d4	0f ba f0 09	 btr	 eax, 9
  003d8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  003dd	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3501 : 
; 3502 :     CCKD_TRACE( "merge starting: %s %s",

  003e0	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR force$[rsp], 0
  003e8	74 11		 je	 SHORT $LN69@cckd64_sf_
  003ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171400
  003f1	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv199[rsp], rax
  003f9	eb 0f		 jmp	 SHORT $LN70@cckd64_sf_
$LN69@cckd64_sf_:
  003fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171401
  00402	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv199[rsp], rax
$LN70@cckd64_sf_:
  0040a	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR merge$[rsp], 0
  00412	74 11		 je	 SHORT $LN71@cckd64_sf_
  00414	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171402
  0041b	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv202[rsp], rax
  00423	eb 0f		 jmp	 SHORT $LN72@cckd64_sf_
$LN71@cckd64_sf_:
  00425	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171403
  0042c	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv202[rsp], rax
$LN72@cckd64_sf_:
  00434	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR tv199[rsp]
  0043c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00441	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR tv202[rsp]
  00449	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0044e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171404
  00455	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  0045a	ba af 0d 00 00	 mov	 edx, 3503		; 00000dafH
  0045f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171405
  00466	e8 00 00 00 00	 call	 cckd_trace

; 3503 :                 merge ? "merge" : "nomerge", force ? "force" : "");
; 3504 : 
; 3505 :     /* Schedule updated track entries to be written */
; 3506 :     obtain_lock( &cckd->cckdiolock );

  0046b	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00470	48 83 c0 18	 add	 rax, 24
  00474	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171406
  0047b	48 8b c8	 mov	 rcx, rax
  0047e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3507 :     {
; 3508 :         if (cckd->merging)

  00484	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00489	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0048c	c1 e8 05	 shr	 eax, 5
  0048f	83 e0 01	 and	 eax, 1
  00492	85 c0		 test	 eax, eax
  00494	0f 84 fc 00 00
	00		 je	 $LN17@cckd64_sf_

; 3509 :         {
; 3510 :             release_lock( &cckd->cckdiolock );

  0049a	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0049f	48 83 c0 18	 add	 rax, 24
  004a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171408
  004aa	48 8b c8	 mov	 rcx, rax
  004ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3511 :             // "%1d:%04X CCKD file[%d] %s: error merging shadow file, sf command busy on device"
; 3512 :             WRMSG( HHC00322, "W", LCSS_DEVNUM, cckd->sfn, cckd_sf_name(dev, cckd->sfn) );

  004b3	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  004b9	74 12		 je	 SHORT $LN73@cckd64_sf_
  004bb	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  004c0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004c4	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv228[rsp], eax
  004cb	eb 0b		 jmp	 SHORT $LN74@cckd64_sf_
$LN73@cckd64_sf_:
  004cd	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv228[rsp], 0
$LN74@cckd64_sf_:
  004d8	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  004de	74 14		 je	 SHORT $LN75@cckd64_sf_
  004e0	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  004e5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  004e9	d1 f8		 sar	 eax, 1
  004eb	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv234[rsp], eax
  004f2	eb 0b		 jmp	 SHORT $LN76@cckd64_sf_
$LN75@cckd64_sf_:
  004f4	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv234[rsp], 0
$LN76@cckd64_sf_:
  004ff	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00504	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00507	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0050c	e8 00 00 00 00	 call	 cckd_sf_name
  00511	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv215[rsp], rax
  00519	b9 01 00 00 00	 mov	 ecx, 1
  0051e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00524	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv215[rsp]
  0052c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00531	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00536	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00539	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0053d	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv228[rsp]
  00544	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00548	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv234[rsp]
  0054f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00553	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171409
  0055a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0055f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171410
  00566	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0056b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00570	41 b9 03 00 00
	00		 mov	 r9d, 3
  00576	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171411
  0057d	ba b8 0d 00 00	 mov	 edx, 3512		; 00000db8H
  00582	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171412
  00589	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3513 :             return NULL;

  0058f	33 c0		 xor	 eax, eax
  00591	e9 1c 14 00 00	 jmp	 $LN1@cckd64_sf_
$LN17@cckd64_sf_:

; 3514 :         }
; 3515 :         cckd->merging = 1;

  00596	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0059b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0059e	83 c8 20	 or	 eax, 32			; 00000020H
  005a1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  005a6	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3516 :         cckd64_flush_cache (dev);

  005a9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  005ae	e8 00 00 00 00	 call	 cckd64_flush_cache
$LN5@cckd64_sf_:

; 3517 :         while (cckd->wrpending || cckd->cckdioact)

  005b3	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  005b8	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  005bc	75 12		 jne	 SHORT $LN18@cckd64_sf_
  005be	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  005c3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  005c6	c1 e8 02	 shr	 eax, 2
  005c9	83 e0 01	 and	 eax, 1
  005cc	85 c0		 test	 eax, eax
  005ce	74 52		 je	 SHORT $LN6@cckd64_sf_
$LN18@cckd64_sf_:

; 3518 :         {
; 3519 :             cckd->cckdwaiters++;

  005d0	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  005d5	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  005d8	ff c0		 inc	 eax
  005da	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  005df	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 3520 :             wait_condition( &cckd->cckdiocond, &cckd->cckdiolock );

  005e2	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  005e7	48 83 c0 18	 add	 rax, 24
  005eb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  005f0	48 83 c1 20	 add	 rcx, 32			; 00000020H
  005f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171414
  005fb	48 8b d0	 mov	 rdx, rax
  005fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 3521 :             cckd->cckdwaiters--;

  00604	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00609	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0060c	ff c8		 dec	 eax
  0060e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00613	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 3522 :             cckd64_flush_cache( dev );

  00616	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0061b	e8 00 00 00 00	 call	 cckd64_flush_cache

; 3523 :         }

  00620	eb 91		 jmp	 SHORT $LN5@cckd64_sf_
$LN6@cckd64_sf_:

; 3524 :         cckd64_purge_cache( dev );

  00622	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00627	e8 00 00 00 00	 call	 cckd64_purge_cache

; 3525 :         cckd64_purge_l2( dev );

  0062c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00631	e8 00 00 00 00	 call	 cckd64_purge_l2

; 3526 :         dev->bufcur = dev->cache = -1;

  00636	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0063b	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00645	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0064a	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 3527 :     }
; 3528 :     release_lock( &cckd->cckdiolock );

  00654	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00659	48 83 c0 18	 add	 rax, 24
  0065d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171415
  00664	48 8b c8	 mov	 rcx, rax
  00667	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3529 : 
; 3530 :     obtain_lock( &cckd->filelock );

  0066d	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00672	48 83 c0 10	 add	 rax, 16
  00676	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171416
  0067d	48 8b c8	 mov	 rcx, rax
  00680	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3531 : 
; 3532 :     if (!cckd->sfn)

  00686	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0068b	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  0068f	0f 85 0f 01 00
	00		 jne	 $LN19@cckd64_sf_

; 3533 :     {
; 3534 :         release_lock( &cckd->filelock );

  00695	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0069a	48 83 c0 10	 add	 rax, 16
  0069e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171418
  006a5	48 8b c8	 mov	 rcx, rax
  006a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3535 :         // "%1d:%04X CCKD file[%d] %s: cannot remove base file"
; 3536 :         WRMSG( HHC00323, "E", LCSS_DEVNUM, cckd->sfn, cckd_sf_name(dev, cckd->sfn) );

  006ae	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  006b4	74 12		 je	 SHORT $LN77@cckd64_sf_
  006b6	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  006bb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006bf	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv326[rsp], eax
  006c6	eb 0b		 jmp	 SHORT $LN78@cckd64_sf_
$LN77@cckd64_sf_:
  006c8	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv326[rsp], 0
$LN78@cckd64_sf_:
  006d3	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  006d9	74 14		 je	 SHORT $LN79@cckd64_sf_
  006db	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  006e0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  006e4	d1 f8		 sar	 eax, 1
  006e6	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv332[rsp], eax
  006ed	eb 0b		 jmp	 SHORT $LN80@cckd64_sf_
$LN79@cckd64_sf_:
  006ef	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv332[rsp], 0
$LN80@cckd64_sf_:
  006fa	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  006ff	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00702	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00707	e8 00 00 00 00	 call	 cckd_sf_name
  0070c	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv281[rsp], rax
  00714	b9 01 00 00 00	 mov	 ecx, 1
  00719	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0071f	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv281[rsp]
  00727	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0072c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00731	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00734	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00738	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv326[rsp]
  0073f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00743	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv332[rsp]
  0074a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0074e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171419
  00755	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0075a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171420
  00761	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00766	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0076b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00771	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171421
  00778	ba d0 0d 00 00	 mov	 edx, 3536		; 00000dd0H
  0077d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171422
  00784	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3537 :         cckd->merging = 0;

  0078a	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0078f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00792	83 e0 df	 and	 eax, -33		; ffffffdfH
  00795	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0079a	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3538 :         return NULL;

  0079d	33 c0		 xor	 eax, eax
  0079f	e9 0e 12 00 00	 jmp	 $LN1@cckd64_sf_
$LN19@cckd64_sf_:

; 3539 :     }
; 3540 : 
; 3541 :     from_sfx = cckd->sfn;

  007a4	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  007a9	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  007ac	89 84 24 84 00
	00 00		 mov	 DWORD PTR from_sfx$[rsp], eax

; 3542 :     to_sfx   = cckd->sfn - 1;

  007b3	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  007b8	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  007bb	ff c8		 dec	 eax
  007bd	89 84 24 80 00
	00 00		 mov	 DWORD PTR to_sfx$[rsp], eax

; 3543 :     fix = cckd->cdevhdr[ to_sfx ].cdh_nullfmt;

  007c4	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  007cc	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  007d3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  007d8	0f b6 84 01 28
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+552]
  007e0	89 84 24 10 01
	00 00		 mov	 DWORD PTR fix$[rsp], eax

; 3544 : 
; 3545 :     /* Harden the `from' file */
; 3546 :     if (cckd_harden( dev ) < 0)

  007e7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  007ec	e8 00 00 00 00	 call	 cckd_harden
  007f1	85 c0		 test	 eax, eax
  007f3	0f 8d 03 01 00
	00		 jge	 $LN20@cckd64_sf_

; 3547 :     {
; 3548 :         // "%1d:%04X CCKD file[%d] %s: shadow file not merged: file[%d] %s%s"
; 3549 :         WRMSG( HHC00324, "E", LCSS_DEVNUM, from_sfx, cckd_sf_name( dev, cckd->sfx ),

  007f9	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  007ff	74 12		 je	 SHORT $LN81@cckd64_sf_
  00801	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00806	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0080a	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv370[rsp], eax
  00811	eb 0b		 jmp	 SHORT $LN82@cckd64_sf_
$LN81@cckd64_sf_:
  00813	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv370[rsp], 0
$LN82@cckd64_sf_:
  0081e	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00824	74 14		 je	 SHORT $LN83@cckd64_sf_
  00826	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0082b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0082f	d1 f8		 sar	 eax, 1
  00831	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv376[rsp], eax
  00838	eb 0b		 jmp	 SHORT $LN84@cckd64_sf_
$LN83@cckd64_sf_:
  0083a	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv376[rsp], 0
$LN84@cckd64_sf_:
  00845	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0084a	8b 50 40	 mov	 edx, DWORD PTR [rax+64]
  0084d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00852	e8 00 00 00 00	 call	 cckd_sf_name
  00857	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv361[rsp], rax
  0085f	b9 01 00 00 00	 mov	 ecx, 1
  00864	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0086a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171424
  00871	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00876	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171425
  0087d	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00882	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  00889	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0088d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv361[rsp]
  00895	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0089a	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  008a1	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  008a5	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv370[rsp]
  008ac	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  008b0	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv376[rsp]
  008b7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171426
  008c2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171427
  008ce	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008d8	41 b9 03 00 00
	00		 mov	 r9d, 3
  008de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171428
  008e5	ba de 0d 00 00	 mov	 edx, 3550		; 00000ddeH
  008ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171429
  008f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3550 :                from_sfx, "not hardened", "" );
; 3551 :         goto sf_remove_exit;

  008f7	e9 ef 0c 00 00	 jmp	 $sf_remove_exit$112
$LN20@cckd64_sf_:

; 3552 :     }
; 3553 : 
; 3554 :     /* Attempt to re-open the `to' file read-write */
; 3555 :     cckd64_close( dev, to_sfx );

  008fc	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  00903	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00908	e8 00 00 00 00	 call	 cckd64_close

; 3556 :     if (to_sfx > 0 || !dev->ckdrdonly || force)

  0090d	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR to_sfx$[rsp], 0
  00915	7f 1f		 jg	 SHORT $LN22@cckd64_sf_
  00917	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0091c	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00922	c1 e8 12	 shr	 eax, 18
  00925	83 e0 01	 and	 eax, 1
  00928	85 c0		 test	 eax, eax
  0092a	74 0a		 je	 SHORT $LN22@cckd64_sf_
  0092c	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR force$[rsp], 0
  00934	74 1d		 je	 SHORT $LN21@cckd64_sf_
$LN22@cckd64_sf_:

; 3557 :         cckd64_open( dev, to_sfx, O_RDWR|O_BINARY, 1 );

  00936	41 b9 01 00 00
	00		 mov	 r9d, 1
  0093c	41 b8 02 80 00
	00		 mov	 r8d, 32770		; 00008002H
  00942	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  00949	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0094e	e8 00 00 00 00	 call	 cckd64_open
$LN21@cckd64_sf_:

; 3558 :     if (cckd->fd[to_sfx] < 0)

  00953	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  0095b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00960	83 bc 81 f0 00
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+240], 0
  00968	0f 8d 86 01 00
	00		 jge	 $LN23@cckd64_sf_

; 3559 :     {
; 3560 :         /* `from' file can't be opened read-write */
; 3561 :         cckd64_open( dev, to_sfx, O_RDONLY|O_BINARY, 0 );

  0096e	45 33 c9	 xor	 r9d, r9d
  00971	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00977	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  0097e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00983	e8 00 00 00 00	 call	 cckd64_open

; 3562 :         if (merge)

  00988	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR merge$[rsp], 0
  00990	0f 84 4e 01 00
	00		 je	 $LN25@cckd64_sf_

; 3563 :         {
; 3564 :             // "%1d:%04X CCKD file[%d] %s: shadow file not merged: file[%d] %s%s"
; 3565 :             WRMSG( HHC00324, "E", LCSS_DEVNUM, from_sfx, cckd_sf_name( dev, from_sfx ),

  00996	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR to_sfx$[rsp], 0
  0099e	75 30		 jne	 SHORT $LN85@cckd64_sf_
  009a0	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  009a5	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  009ab	c1 e8 12	 shr	 eax, 18
  009ae	83 e0 01	 and	 eax, 1
  009b1	85 c0		 test	 eax, eax
  009b3	74 1b		 je	 SHORT $LN85@cckd64_sf_
  009b5	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR force$[rsp], 0
  009bd	75 11		 jne	 SHORT $LN85@cckd64_sf_
  009bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171436
  009c6	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv415[rsp], rax
  009ce	eb 0f		 jmp	 SHORT $LN86@cckd64_sf_
$LN85@cckd64_sf_:
  009d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171437
  009d7	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv415[rsp], rax
$LN86@cckd64_sf_:
  009df	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  009e5	74 12		 je	 SHORT $LN87@cckd64_sf_
  009e7	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  009ec	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  009f0	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv427[rsp], eax
  009f7	eb 0b		 jmp	 SHORT $LN88@cckd64_sf_
$LN87@cckd64_sf_:
  009f9	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv427[rsp], 0
$LN88@cckd64_sf_:
  00a04	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00a0a	74 14		 je	 SHORT $LN89@cckd64_sf_
  00a0c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00a11	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00a15	d1 f8		 sar	 eax, 1
  00a17	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv433[rsp], eax
  00a1e	eb 0b		 jmp	 SHORT $LN90@cckd64_sf_
$LN89@cckd64_sf_:
  00a20	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv433[rsp], 0
$LN90@cckd64_sf_:
  00a2b	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  00a32	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00a37	e8 00 00 00 00	 call	 cckd_sf_name
  00a3c	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv419[rsp], rax
  00a44	b9 01 00 00 00	 mov	 ecx, 1
  00a49	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a4f	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv415[rsp]
  00a57	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00a5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171438
  00a63	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00a68	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR to_sfx$[rsp]
  00a6f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00a73	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv419[rsp]
  00a7b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00a80	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  00a87	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00a8b	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv427[rsp]
  00a92	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a96	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv433[rsp]
  00a9d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00aa1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171439
  00aa8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00aad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171440
  00ab4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ab9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00abe	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ac4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171441
  00acb	ba ef 0d 00 00	 mov	 edx, 3567		; 00000defH
  00ad0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171442
  00ad7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3566 :                                  to_sfx, "cannot be opened read-write",
; 3567 :                                  to_sfx == 0 && dev->ckdrdonly && !force ? ", try 'force'" : "" );
; 3568 :             goto sf_remove_exit;

  00add	e9 09 0b 00 00	 jmp	 $sf_remove_exit$112

; 3569 :         }

  00ae2	eb 0b		 jmp	 SHORT $LN26@cckd64_sf_
$LN25@cckd64_sf_:

; 3570 :         else
; 3571 :            add = 1;

  00ae4	c7 84 24 b4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR add$[rsp], 1
$LN26@cckd64_sf_:

; 3572 :     }

  00aef	e9 34 01 00 00	 jmp	 $LN24@cckd64_sf_
$LN23@cckd64_sf_:

; 3573 :     else
; 3574 :     {
; 3575 :         /* `from' file opened read-write */
; 3576 :         cckd->sfn = to_sfx;

  00af4	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00af9	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR to_sfx$[rsp]
  00b00	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 3577 : 
; 3578 :         if (cckd64_chkdsk( dev, 0 ) < 0)

  00b03	33 d2		 xor	 edx, edx
  00b05	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00b0a	e8 00 00 00 00	 call	 cckd64_chkdsk
  00b0f	85 c0		 test	 eax, eax
  00b11	0f 8d 11 01 00
	00		 jge	 $LN27@cckd64_sf_

; 3579 :         {
; 3580 :             cckd->sfn = from_sfx;

  00b17	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00b1c	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  00b23	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 3581 :             // "%1d:%04X CCKD file[%d] %s: shadow file not merged: file[%d] %s%s"
; 3582 :             WRMSG( HHC00324, "E", LCSS_DEVNUM, to_sfx, cckd_sf_name( dev, to_sfx ),

  00b26	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00b2c	74 12		 je	 SHORT $LN91@cckd64_sf_
  00b2e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00b33	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b37	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv461[rsp], eax
  00b3e	eb 0b		 jmp	 SHORT $LN92@cckd64_sf_
$LN91@cckd64_sf_:
  00b40	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv461[rsp], 0
$LN92@cckd64_sf_:
  00b4b	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00b51	74 14		 je	 SHORT $LN93@cckd64_sf_
  00b53	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00b58	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00b5c	d1 f8		 sar	 eax, 1
  00b5e	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv467[rsp], eax
  00b65	eb 0b		 jmp	 SHORT $LN94@cckd64_sf_
$LN93@cckd64_sf_:
  00b67	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv467[rsp], 0
$LN94@cckd64_sf_:
  00b72	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  00b79	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00b7e	e8 00 00 00 00	 call	 cckd_sf_name
  00b83	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv453[rsp], rax
  00b8b	b9 01 00 00 00	 mov	 ecx, 1
  00b90	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b96	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171444
  00b9d	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00ba2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171445
  00ba9	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00bae	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR to_sfx$[rsp]
  00bb5	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00bb9	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv453[rsp]
  00bc1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00bc6	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR to_sfx$[rsp]
  00bcd	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00bd1	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv461[rsp]
  00bd8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00bdc	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv467[rsp]
  00be3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00be7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171446
  00bee	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bf3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171447
  00bfa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00bff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c04	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c0a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171448
  00c11	ba ff 0d 00 00	 mov	 edx, 3583		; 00000dffH
  00c16	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171449
  00c1d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3583 :                                  to_sfx, "check failed", "" );
; 3584 :             goto sf_remove_exit;

  00c23	e9 c3 09 00 00	 jmp	 $sf_remove_exit$112
$LN27@cckd64_sf_:
$LN24@cckd64_sf_:

; 3585 :         }
; 3586 :     }
; 3587 : 
; 3588 :     cckd->sfn = to_sfx;

  00c28	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00c2d	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR to_sfx$[rsp]
  00c34	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 3589 : 
; 3590 :     /* Perform backwards merge */
; 3591 :     if (merge)

  00c37	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR merge$[rsp], 0
  00c3f	0f 84 be 06 00
	00		 je	 $LN28@cckd64_sf_

; 3592 :     {
; 3593 :         CCKD_TRACE( "merging to file[%d]", to_sfx );

  00c45	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR to_sfx$[rsp]
  00c4c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00c50	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171451
  00c57	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00c5c	ba 09 0e 00 00	 mov	 edx, 3593		; 00000e09H
  00c61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171452
  00c68	e8 00 00 00 00	 call	 cckd_trace

; 3594 : 
; 3595 :         /* Make the target file the active file */
; 3596 :         cckd->sfn = to_sfx;

  00c6d	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00c72	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR to_sfx$[rsp]
  00c79	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 3597 :         cckd->cdevhdr[to_sfx].cdh_opts |= (CCKD_OPT_OPENED | CCKD_OPT_OPENRW);

  00c7c	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  00c84	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00c8b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00c90	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  00c98	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  00c9d	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR to_sfx$[rsp]
  00ca5	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00cac	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00cb1	88 84 0a e3 01
	00 00		 mov	 BYTE PTR [rdx+rcx+483], al

; 3598 : 
; 3599 :         /* Loop for each level 1 table entry */
; 3600 :         for (i = 0; i < cckd->cdevhdr[from_sfx].num_L1tab; i++)

  00cb8	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00cc3	eb 10		 jmp	 SHORT $LN9@cckd64_sf_
$LN7@cckd64_sf_:
  00cc5	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00ccc	ff c0		 inc	 eax
  00cce	89 84 24 88 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN9@cckd64_sf_:
  00cd5	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  00cdd	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00ce4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00ce9	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  00cf0	39 84 24 88 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00cf7	0f 8d e6 05 00
	00		 jge	 $LN8@cckd64_sf_

; 3601 :         {
; 3602 :             l2updated = 0;

  00cfd	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR l2updated$[rsp], 0

; 3603 :             /* Continue if from L2 doesn't exist */
; 3604 :             if (cckd->L1tab[from_sfx][i] == CCKD64_MAXSIZE
; 3605 :              || (cckd->L1tab[from_sfx][i] == 0 && cckd->L1tab[to_sfx][i] == 0))

  00d08	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  00d10	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00d18	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00d1d	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00d25	48 83 3c c8 ff	 cmp	 QWORD PTR [rax+rcx*8], -1
  00d2a	74 48		 je	 SHORT $LN30@cckd64_sf_
  00d2c	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  00d34	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00d3c	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00d41	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00d49	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  00d4e	75 29		 jne	 SHORT $LN29@cckd64_sf_
  00d50	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  00d58	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00d60	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00d65	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00d6d	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  00d72	75 05		 jne	 SHORT $LN29@cckd64_sf_
$LN30@cckd64_sf_:

; 3606 :                 continue;

  00d74	e9 4c ff ff ff	 jmp	 $LN7@cckd64_sf_
$LN29@cckd64_sf_:

; 3607 : 
; 3608 :             trk = i*256;

  00d79	69 84 24 88 00
	00 00 00 01 00
	00		 imul	 eax, DWORD PTR i$[rsp], 256 ; 00000100H
  00d84	89 84 24 ac 00
	00 00		 mov	 DWORD PTR trk$[rsp], eax

; 3609 : 
; 3610 :             /* Read `from' l2 table */
; 3611 :             if (cckd->L1tab[from_sfx][i] == 0)

  00d8b	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  00d93	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00d9b	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00da0	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00da8	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  00dad	75 16		 jne	 SHORT $LN31@cckd64_sf_

; 3612 :                 memset( &from_l2, 0, CCKD64_L2TAB_SIZE );

  00daf	48 8d 84 24 90
	11 00 00	 lea	 rax, QWORD PTR from_l2$[rsp]
  00db7	48 8b f8	 mov	 rdi, rax
  00dba	33 c0		 xor	 eax, eax
  00dbc	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00dc1	f3 aa		 rep stosb
  00dc3	eb 5b		 jmp	 SHORT $LN32@cckd64_sf_
$LN31@cckd64_sf_:

; 3613 :             else
; 3614 :             {
; 3615 :                 pos = cckd->L1tab[from_sfx][i];

  00dc5	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  00dcd	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00dd5	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00dda	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00de2	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00de6	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax

; 3616 :                 if (cckd64_read( dev, from_sfx, pos, &from_l2, CCKD64_L2TAB_SIZE ) < 0)

  00dee	c7 44 24 20 00
	10 00 00	 mov	 DWORD PTR [rsp+32], 4096 ; 00001000H
  00df6	4c 8d 8c 24 90
	11 00 00	 lea	 r9, QWORD PTR from_l2$[rsp]
  00dfe	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pos$[rsp]
  00e06	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  00e0d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00e12	e8 00 00 00 00	 call	 cckd64_read
  00e17	85 c0		 test	 eax, eax
  00e19	7d 05		 jge	 SHORT $LN33@cckd64_sf_

; 3617 :                     goto sf_merge_error;

  00e1b	e9 c3 08 00 00	 jmp	 $sf_merge_error$113
$LN33@cckd64_sf_:
$LN32@cckd64_sf_:

; 3618 :             }
; 3619 : 
; 3620 :             /* Read `to' l2 table */
; 3621 :             if (cckd->L1tab[to_sfx][i] == 0)

  00e20	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  00e28	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00e30	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00e35	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00e3d	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  00e42	75 19		 jne	 SHORT $LN34@cckd64_sf_

; 3622 :                 memset( &to_l2, 0, CCKD64_L2TAB_SIZE );

  00e44	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR to_l2$[rsp]
  00e4c	48 8b f8	 mov	 rdi, rax
  00e4f	33 c0		 xor	 eax, eax
  00e51	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00e56	f3 aa		 rep stosb
  00e58	e9 98 00 00 00	 jmp	 $LN35@cckd64_sf_
$LN34@cckd64_sf_:

; 3623 :             else if (cckd->L1tab[to_sfx][i] == CCKD64_MAXSIZE)

  00e5d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  00e65	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00e6d	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00e72	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00e7a	48 83 3c c8 ff	 cmp	 QWORD PTR [rax+rcx*8], -1
  00e7f	75 19		 jne	 SHORT $LN36@cckd64_sf_

; 3624 :                 memset (&to_l2, 0xff, CCKD64_L2TAB_SIZE);

  00e81	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR to_l2$[rsp]
  00e89	48 8b f8	 mov	 rdi, rax
  00e8c	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00e91	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00e96	f3 aa		 rep stosb
  00e98	eb 5b		 jmp	 SHORT $LN37@cckd64_sf_
$LN36@cckd64_sf_:

; 3625 :             else
; 3626 :             {
; 3627 :                 pos = cckd->L1tab[to_sfx][i];

  00e9a	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  00ea2	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00eaa	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  00eaf	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00eb7	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00ebb	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax

; 3628 :                 if (cckd64_read( dev, to_sfx, pos, &to_l2, CCKD64_L2TAB_SIZE ) < 0)

  00ec3	c7 44 24 20 00
	10 00 00	 mov	 DWORD PTR [rsp+32], 4096 ; 00001000H
  00ecb	4c 8d 8c 24 90
	01 00 00	 lea	 r9, QWORD PTR to_l2$[rsp]
  00ed3	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pos$[rsp]
  00edb	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  00ee2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00ee7	e8 00 00 00 00	 call	 cckd64_read
  00eec	85 c0		 test	 eax, eax
  00eee	7d 05		 jge	 SHORT $LN38@cckd64_sf_

; 3629 :                     goto sf_merge_error;

  00ef0	e9 ee 07 00 00	 jmp	 $sf_merge_error$113
$LN38@cckd64_sf_:
$LN37@cckd64_sf_:
$LN35@cckd64_sf_:

; 3630 :             }
; 3631 : 
; 3632 :             /* Loop for each level 2 table entry */
; 3633 :             for (j = 0; j < 256; j++)

  00ef5	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  00f00	eb 10		 jmp	 SHORT $LN12@cckd64_sf_
$LN10@cckd64_sf_:
  00f02	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  00f09	ff c0		 inc	 eax
  00f0b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR j$[rsp], eax
$LN12@cckd64_sf_:
  00f12	81 bc 24 8c 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR j$[rsp], 256	; 00000100H
  00f1d	0f 8d 5e 02 00
	00		 jge	 $LN11@cckd64_sf_

; 3634 :             {
; 3635 :                 trk = i*256 + j;

  00f23	69 84 24 88 00
	00 00 00 01 00
	00		 imul	 eax, DWORD PTR i$[rsp], 256 ; 00000100H
  00f2e	03 84 24 8c 00
	00 00		 add	 eax, DWORD PTR j$[rsp]
  00f35	89 84 24 ac 00
	00 00		 mov	 DWORD PTR trk$[rsp], eax

; 3636 :                 /* Continue if from L2 entry doesn't exist */
; 3637 :                 if (from_l2[j].L2_trkoff == CCKD64_MAXSIZE
; 3638 :                  || (from_l2[j].L2_trkoff == 0 && to_l2[j].L2_trkoff == 0))

  00f3c	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00f44	48 6b c0 10	 imul	 rax, rax, 16
  00f48	48 83 bc 04 90
	11 00 00 ff	 cmp	 QWORD PTR from_l2$[rsp+rax], -1
  00f51	74 2e		 je	 SHORT $LN40@cckd64_sf_
  00f53	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00f5b	48 6b c0 10	 imul	 rax, rax, 16
  00f5f	48 83 bc 04 90
	11 00 00 00	 cmp	 QWORD PTR from_l2$[rsp+rax], 0
  00f68	75 1c		 jne	 SHORT $LN39@cckd64_sf_
  00f6a	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00f72	48 6b c0 10	 imul	 rax, rax, 16
  00f76	48 83 bc 04 90
	01 00 00 00	 cmp	 QWORD PTR to_l2$[rsp+rax], 0
  00f7f	75 05		 jne	 SHORT $LN39@cckd64_sf_
$LN40@cckd64_sf_:

; 3639 :                     continue;

  00f81	e9 7c ff ff ff	 jmp	 $LN10@cckd64_sf_
$LN39@cckd64_sf_:

; 3640 : 
; 3641 :                 /* Read the `from' track/blkgrp image */
; 3642 :                 len = (unsigned int)from_l2[j].L2_len;

  00f86	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00f8e	48 6b c0 10	 imul	 rax, rax, 16
  00f92	0f b7 84 04 98
	11 00 00	 movzx	 eax, WORD PTR from_l2$[rsp+rax+8]
  00f9a	89 84 24 98 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 3643 :                 if (len > CKD_NULLTRK_FMTMAX)

  00fa1	83 bc 24 98 00
	00 00 02	 cmp	 DWORD PTR len$[rsp], 2
  00fa9	0f 86 f6 00 00
	00		 jbe	 $LN41@cckd64_sf_

; 3644 :                 {
; 3645 :                     pos = from_l2[j].L2_trkoff;

  00faf	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  00fb7	48 6b c0 10	 imul	 rax, rax, 16
  00fbb	48 8b 84 04 90
	11 00 00	 mov	 rax, QWORD PTR from_l2$[rsp+rax]
  00fc3	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax

; 3646 :                     if (cckd64_read( dev, from_sfx, pos, buf, len ) < 0)

  00fcb	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00fd2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00fd6	4c 8d 8c 24 90
	21 00 00	 lea	 r9, QWORD PTR buf$[rsp]
  00fde	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pos$[rsp]
  00fe6	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  00fed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00ff2	e8 00 00 00 00	 call	 cckd64_read
  00ff7	85 c0		 test	 eax, eax
  00ff9	7d 05		 jge	 SHORT $LN43@cckd64_sf_

; 3647 :                         goto sf_merge_error;

  00ffb	e9 e3 06 00 00	 jmp	 $sf_merge_error$113
$LN43@cckd64_sf_:

; 3648 : 
; 3649 :                     /* Get space for the `to' track/blkgrp image */
; 3650 :                     size = len;

  01000	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  01007	89 84 24 a8 00
	00 00		 mov	 DWORD PTR size$[rsp], eax

; 3651 :                     if ((S64)(pos = cckd64_get_space (dev, &size, CCKD_SIZE_EXACT)) < 0)

  0100e	41 b8 01 00 00
	00		 mov	 r8d, 1
  01014	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR size$[rsp]
  0101c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01021	e8 00 00 00 00	 call	 cckd64_get_space
  01026	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax
  0102e	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR pos$[rsp], 0
  01037	7d 05		 jge	 SHORT $LN44@cckd64_sf_

; 3652 :                         goto sf_merge_error;

  01039	e9 a5 06 00 00	 jmp	 $sf_merge_error$113
$LN44@cckd64_sf_:

; 3653 : 
; 3654 :                     new_l2.L2_trkoff = pos;

  0103e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pos$[rsp]
  01046	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR new_l2$[rsp], rax

; 3655 :                     new_l2.L2_len    = (U16)len;

  0104e	0f b7 84 24 98
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  01056	66 89 84 24 88
	01 00 00	 mov	 WORD PTR new_l2$[rsp+8], ax

; 3656 :                     new_l2.L2_size   = (U16)size;

  0105e	0f b7 84 24 a8
	00 00 00	 movzx	 eax, WORD PTR size$[rsp]
  01066	66 89 84 24 8a
	01 00 00	 mov	 WORD PTR new_l2$[rsp+10], ax

; 3657 : 
; 3658 :                     /* Write the `to' track/blkgrp image */
; 3659 :                     if (cckd64_write( dev, to_sfx, pos, buf, len ) < 0)

  0106e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  01075	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01079	4c 8d 8c 24 90
	21 00 00	 lea	 r9, QWORD PTR buf$[rsp]
  01081	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pos$[rsp]
  01089	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  01090	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01095	e8 00 00 00 00	 call	 cckd64_write
  0109a	85 c0		 test	 eax, eax
  0109c	7d 05		 jge	 SHORT $LN45@cckd64_sf_

; 3660 :                         goto sf_merge_error;

  0109e	e9 40 06 00 00	 jmp	 $sf_merge_error$113
$LN45@cckd64_sf_:

; 3661 :                 }

  010a3	eb 2c		 jmp	 SHORT $LN42@cckd64_sf_
$LN41@cckd64_sf_:

; 3662 :                 else
; 3663 :                 {
; 3664 :                     new_l2.L2_trkoff = 0;

  010a5	48 c7 84 24 80
	01 00 00 00 00
	00 00		 mov	 QWORD PTR new_l2$[rsp], 0

; 3665 :                     new_l2.L2_len = new_l2.L2_size = (U16)len;

  010b1	0f b7 84 24 98
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  010b9	66 89 84 24 8a
	01 00 00	 mov	 WORD PTR new_l2$[rsp+10], ax
  010c1	0f b7 84 24 8a
	01 00 00	 movzx	 eax, WORD PTR new_l2$[rsp+10]
  010c9	66 89 84 24 88
	01 00 00	 mov	 WORD PTR new_l2$[rsp+8], ax
$LN42@cckd64_sf_:

; 3666 :                 }
; 3667 : 
; 3668 :                 /* Release space occupied by old `to' entry */
; 3669 :                 cckd64_rel_space( dev, to_l2[j].L2_trkoff, (int)to_l2[j].L2_len,

  010d1	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  010d9	48 6b c0 10	 imul	 rax, rax, 16
  010dd	0f b7 84 04 9a
	01 00 00	 movzx	 eax, WORD PTR to_l2$[rsp+rax+10]
  010e5	48 63 8c 24 8c
	00 00 00	 movsxd	 rcx, DWORD PTR j$[rsp]
  010ed	48 6b c9 10	 imul	 rcx, rcx, 16
  010f1	0f b7 8c 0c 98
	01 00 00	 movzx	 ecx, WORD PTR to_l2$[rsp+rcx+8]
  010f9	48 63 94 24 8c
	00 00 00	 movsxd	 rdx, DWORD PTR j$[rsp]
  01101	48 6b d2 10	 imul	 rdx, rdx, 16
  01105	44 8b c8	 mov	 r9d, eax
  01108	44 8b c1	 mov	 r8d, ecx
  0110b	48 8b 94 14 90
	01 00 00	 mov	 rdx, QWORD PTR to_l2$[rsp+rdx]
  01113	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01118	e8 00 00 00 00	 call	 cckd64_rel_space

; 3670 :                                                            (int)to_l2[j].L2_size );
; 3671 : 
; 3672 :                 /* Update `to' l2 table entry */
; 3673 :                 l2updated = 1;

  0111d	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR l2updated$[rsp], 1

; 3674 :                 to_l2[j].L2_trkoff  = new_l2.L2_trkoff;

  01128	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  01130	48 6b c0 10	 imul	 rax, rax, 16
  01134	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR new_l2$[rsp]
  0113c	48 89 8c 04 90
	01 00 00	 mov	 QWORD PTR to_l2$[rsp+rax], rcx

; 3675 :                 to_l2[j].L2_len  = new_l2.L2_len;

  01144	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  0114c	48 6b c0 10	 imul	 rax, rax, 16
  01150	0f b7 8c 24 88
	01 00 00	 movzx	 ecx, WORD PTR new_l2$[rsp+8]
  01158	66 89 8c 04 98
	01 00 00	 mov	 WORD PTR to_l2$[rsp+rax+8], cx

; 3676 :                 to_l2[j].L2_size = new_l2.L2_size;

  01160	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR j$[rsp]
  01168	48 6b c0 10	 imul	 rax, rax, 16
  0116c	0f b7 8c 24 8a
	01 00 00	 movzx	 ecx, WORD PTR new_l2$[rsp+10]
  01174	66 89 8c 04 9a
	01 00 00	 mov	 WORD PTR to_l2$[rsp+rax+10], cx

; 3677 :             } /* for each level 2 table entry */

  0117c	e9 81 fd ff ff	 jmp	 $LN10@cckd64_sf_
$LN11@cckd64_sf_:

; 3678 : 
; 3679 :             /* Update the `to' level 2 table */
; 3680 :             if (l2updated)

  01181	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR l2updated$[rsp], 0
  01189	0f 84 4f 01 00
	00		 je	 $LN46@cckd64_sf_

; 3681 :             {
; 3682 :                 l2updated = 0;

  0118f	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR l2updated$[rsp], 0

; 3683 :                 pos = cckd->L1tab[to_sfx][i];

  0119a	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  011a2	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  011aa	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  011af	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  011b7	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  011bb	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax

; 3684 :                 if (memcmp( &to_l2, &empty64_l2[fix], CCKD64_L2TAB_SIZE ) == 0)

  011c3	48 63 84 24 10
	01 00 00	 movsxd	 rax, DWORD PTR fix$[rsp]
  011cb	48 69 c0 00 10
	00 00		 imul	 rax, rax, 4096		; 00001000H
  011d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:empty64_l2
  011d9	48 03 c8	 add	 rcx, rax
  011dc	48 8b c1	 mov	 rax, rcx
  011df	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  011e5	48 8b d0	 mov	 rdx, rax
  011e8	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR to_l2$[rsp]
  011f0	e8 00 00 00 00	 call	 memcmp
  011f5	85 c0		 test	 eax, eax
  011f7	75 2f		 jne	 SHORT $LN47@cckd64_sf_

; 3685 :                 {
; 3686 :                     cckd64_rel_space( dev, pos, CCKD64_L2TAB_SIZE, CCKD64_L2TAB_SIZE );

  011f9	41 b9 00 10 00
	00		 mov	 r9d, 4096		; 00001000H
  011ff	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  01205	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pos$[rsp]
  0120d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01212	e8 00 00 00 00	 call	 cckd64_rel_space

; 3687 :                     pos = 0;

  01217	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pos$[rsp], 0

; 3688 :                 }

  01223	e9 83 00 00 00	 jmp	 $LN48@cckd64_sf_
$LN47@cckd64_sf_:

; 3689 :                 else
; 3690 :                 {
; 3691 :                     size = CCKD64_L2TAB_SIZE;

  01228	c7 84 24 a8 00
	00 00 00 10 00
	00		 mov	 DWORD PTR size$[rsp], 4096 ; 00001000H

; 3692 :                     if (pos == CCKD64_NOSIZE || pos == CCKD64_MAXSIZE)

  01233	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR pos$[rsp], 0
  0123c	74 0b		 je	 SHORT $LN50@cckd64_sf_
  0123e	48 83 bc 24 90
	00 00 00 ff	 cmp	 QWORD PTR pos$[rsp], -1
  01247	75 30		 jne	 SHORT $LN49@cckd64_sf_
$LN50@cckd64_sf_:

; 3693 :                         if ((S64)(pos = cckd64_get_space( dev, &size, CCKD_L2SPACE )) < 0)

  01249	41 b8 04 00 00
	00		 mov	 r8d, 4
  0124f	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR size$[rsp]
  01257	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0125c	e8 00 00 00 00	 call	 cckd64_get_space
  01261	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax
  01269	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR pos$[rsp], 0
  01272	7d 05		 jge	 SHORT $LN51@cckd64_sf_

; 3694 :                             goto sf_merge_error;

  01274	e9 6a 04 00 00	 jmp	 $sf_merge_error$113
$LN51@cckd64_sf_:
$LN49@cckd64_sf_:

; 3695 :                     if (cckd64_write( dev, to_sfx, pos, &to_l2, CCKD64_L2TAB_SIZE ) < 0)

  01279	c7 44 24 20 00
	10 00 00	 mov	 DWORD PTR [rsp+32], 4096 ; 00001000H
  01281	4c 8d 8c 24 90
	01 00 00	 lea	 r9, QWORD PTR to_l2$[rsp]
  01289	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pos$[rsp]
  01291	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  01298	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0129d	e8 00 00 00 00	 call	 cckd64_write
  012a2	85 c0		 test	 eax, eax
  012a4	7d 05		 jge	 SHORT $LN52@cckd64_sf_

; 3696 :                         goto sf_merge_error;

  012a6	e9 38 04 00 00	 jmp	 $sf_merge_error$113
$LN52@cckd64_sf_:
$LN48@cckd64_sf_:

; 3697 :                 } /* `to' level 2 table not null */
; 3698 : 
; 3699 :                 /* Update the level 1 table index */
; 3700 :                 cckd->L1tab[to_sfx][i] = pos;

  012ab	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  012b3	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  012bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  012c0	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  012c8	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pos$[rsp]
  012d0	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 3701 : 
; 3702 :                 /* Flush free space */
; 3703 :                 cckd64_flush_space( dev );

  012d4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  012d9	e8 00 00 00 00	 call	 cckd64_flush_space
$LN46@cckd64_sf_:

; 3704 : 
; 3705 :             } /* Update level 2 table */
; 3706 : 
; 3707 :         } /* For each level 1 table entry */

  012de	e9 e2 f9 ff ff	 jmp	 $LN7@cckd64_sf_
$LN8@cckd64_sf_:

; 3708 : 
; 3709 :         /* Validate the merge */
; 3710 :         cckd64_harden( dev );

  012e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  012e8	e8 00 00 00 00	 call	 cckd64_harden

; 3711 :         cckd64_chkdsk( dev, 0 );

  012ed	33 d2		 xor	 edx, edx
  012ef	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  012f4	e8 00 00 00 00	 call	 cckd64_chkdsk

; 3712 :         cckd64_read_init( dev );

  012f9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  012fe	e8 00 00 00 00	 call	 cckd64_read_init
$LN28@cckd64_sf_:

; 3713 : 
; 3714 :     } /* if merge */
; 3715 : 
; 3716 :     /* Remove the old file */
; 3717 :     cckd64_close( dev, from_sfx );

  01303	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  0130a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0130f	e8 00 00 00 00	 call	 cckd64_close

; 3718 :     cckd->L1tab[from_sfx] = cckd_free( dev, "l1", cckd->L1tab[ from_sfx ]);

  01314	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  0131c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  01321	4c 8b 84 c1 98
	01 00 00	 mov	 r8, QWORD PTR [rcx+rax*8+408]
  01329	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171477
  01330	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01335	e8 00 00 00 00	 call	 cckd_free
  0133a	48 63 8c 24 84
	00 00 00	 movsxd	 rcx, DWORD PTR from_sfx$[rsp]
  01342	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  01347	48 89 84 ca 98
	01 00 00	 mov	 QWORD PTR [rdx+rcx*8+408], rax

; 3719 :     memset( &cckd->cdevhdr[from_sfx], 0, CCKD64_DEVHDR_SIZE );

  0134f	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  01357	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0135e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  01363	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  0136b	48 8b f8	 mov	 rdi, rax
  0136e	33 c0		 xor	 eax, eax
  01370	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  01375	f3 aa		 rep stosb

; 3720 :     rc = unlink (cckd_sf_name (dev, from_sfx));

  01377	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  0137e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01383	e8 00 00 00 00	 call	 cckd_sf_name
  01388	48 8b c8	 mov	 rcx, rax
  0138b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_unlink
  01391	89 84 24 0c 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3721 : 
; 3722 :     /* adjust the stats */
; 3723 :     cckd->reads   [to_sfx] += cckd->reads   [from_sfx];

  01398	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  013a0	48 63 8c 24 84
	00 00 00	 movsxd	 rcx, DWORD PTR from_sfx$[rsp]
  013a8	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  013ad	8b 84 82 28 01
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+296]
  013b4	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  013b9	03 84 8a 28 01
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+296]
  013c0	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR to_sfx$[rsp]
  013c8	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  013cd	89 84 8a 28 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+296], eax

; 3724 :     cckd->writes  [to_sfx] += cckd->writes  [from_sfx];

  013d4	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  013dc	48 63 8c 24 84
	00 00 00	 movsxd	 rcx, DWORD PTR from_sfx$[rsp]
  013e4	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  013e9	8b 84 82 70 01
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+368]
  013f0	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  013f5	03 84 8a 70 01
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+368]
  013fc	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR to_sfx$[rsp]
  01404	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  01409	89 84 8a 70 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+368], eax

; 3725 :     cckd->L2_reads[to_sfx] += cckd->L2_reads[from_sfx];

  01410	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  01418	48 63 8c 24 84
	00 00 00	 movsxd	 rcx, DWORD PTR from_sfx$[rsp]
  01420	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  01425	8b 84 82 4c 01
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+332]
  0142c	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  01431	03 84 8a 4c 01
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+332]
  01438	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR to_sfx$[rsp]
  01440	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  01445	89 84 8a 4c 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+332], eax

; 3726 : 
; 3727 :     cckd->reads   [from_sfx] = 0;

  0144c	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  01454	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  01459	c7 84 81 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+296], 0

; 3728 :     cckd->writes  [from_sfx] = 0;

  01464	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  0146c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  01471	c7 84 81 70 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+368], 0

; 3729 :     cckd->L2_reads[from_sfx] = 0;

  0147c	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR from_sfx$[rsp]
  01484	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  01489	c7 84 81 4c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+332], 0

; 3730 : 
; 3731 :     /* Add the file back if necessary */
; 3732 :     if (add) rc = cckd64_sf_new( dev ) ;

  01494	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR add$[rsp], 0
  0149c	74 11		 je	 SHORT $LN53@cckd64_sf_
  0149e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  014a3	e8 00 00 00 00	 call	 cckd64_sf_new
  014a8	89 84 24 0c 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax
$LN53@cckd64_sf_:

; 3733 : 
; 3734 :     // "%1d:%04X CCKD file[%d] %s: shadow file successfully %s"
; 3735 :     WRMSG( HHC00325, "I", LCSS_DEVNUM, from_sfx, cckd_sf_name( dev, from_sfx ),

  014af	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR merge$[rsp], 0
  014b7	74 11		 je	 SHORT $LN97@cckd64_sf_
  014b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171479
  014c0	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv805[rsp], rax
  014c8	eb 3a		 jmp	 SHORT $LN98@cckd64_sf_
$LN97@cckd64_sf_:
  014ca	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR add$[rsp], 0
  014d2	74 11		 je	 SHORT $LN95@cckd64_sf_
  014d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171480
  014db	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv803[rsp], rax
  014e3	eb 0f		 jmp	 SHORT $LN96@cckd64_sf_
$LN95@cckd64_sf_:
  014e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171481
  014ec	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv803[rsp], rax
$LN96@cckd64_sf_:
  014f4	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tv803[rsp]
  014fc	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv805[rsp], rax
$LN98@cckd64_sf_:
  01504	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0150a	74 12		 je	 SHORT $LN99@cckd64_sf_
  0150c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  01511	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01515	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv815[rsp], eax
  0151c	eb 0b		 jmp	 SHORT $LN100@cckd64_sf_
$LN99@cckd64_sf_:
  0151e	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv815[rsp], 0
$LN100@cckd64_sf_:
  01529	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0152f	74 14		 je	 SHORT $LN101@cckd64_sf_
  01531	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  01536	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0153a	d1 f8		 sar	 eax, 1
  0153c	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv821[rsp], eax
  01543	eb 0b		 jmp	 SHORT $LN102@cckd64_sf_
$LN101@cckd64_sf_:
  01545	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv821[rsp], 0
$LN102@cckd64_sf_:
  01550	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  01557	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0155c	e8 00 00 00 00	 call	 cckd_sf_name
  01561	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv807[rsp], rax
  01569	b9 01 00 00 00	 mov	 ecx, 1
  0156e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01574	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv805[rsp]
  0157c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01581	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv807[rsp]
  01589	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0158e	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  01595	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01599	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv815[rsp]
  015a0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  015a4	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv821[rsp]
  015ab	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  015af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171482
  015b6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  015bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171483
  015c2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  015c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  015cc	41 b9 03 00 00
	00		 mov	 r9d, 3
  015d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171484
  015d9	ba 98 0e 00 00	 mov	 edx, 3736		; 00000e98H
  015de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171485
  015e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$sf_remove_exit$112:

; 3736 :                    merge ? "merged" : add ? "re-added" : "removed" );
; 3737 : 
; 3738 : sf_remove_exit:
; 3739 : 
; 3740 :     /* Re-read the l1 to set L2_bounds, L2ok */
; 3741 :     cckd64_read_l1( dev );

  015eb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  015f0	e8 00 00 00 00	 call	 cckd64_read_l1

; 3742 : 
; 3743 :     release_lock (&cckd->filelock);

  015f5	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  015fa	48 83 c0 10	 add	 rax, 16
  015fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171486
  01605	48 8b c8	 mov	 rcx, rax
  01608	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3744 : 
; 3745 :     obtain_lock( &cckd->cckdiolock );

  0160e	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  01613	48 83 c0 18	 add	 rax, 24
  01617	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171487
  0161e	48 8b c8	 mov	 rcx, rax
  01621	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3746 :     {
; 3747 :         cckd64_purge_cache( dev);

  01627	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0162c	e8 00 00 00 00	 call	 cckd64_purge_cache

; 3748 :         cckd64_purge_l2( dev );

  01631	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01636	e8 00 00 00 00	 call	 cckd64_purge_l2

; 3749 :         dev->bufcur = dev->cache = -1;

  0163b	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  01640	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0164a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0164f	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 3750 :         cckd->merging = 0;

  01659	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0165e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  01661	83 e0 df	 and	 eax, -33		; ffffffdfH
  01664	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  01669	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3751 :         if (cckd->cckdwaiters)

  0166c	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  01671	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  01675	74 19		 je	 SHORT $LN54@cckd64_sf_

; 3752 :             broadcast_condition( &cckd->cckdiocond );

  01677	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0167c	48 83 c0 20	 add	 rax, 32			; 00000020H
  01680	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171489
  01687	48 8b c8	 mov	 rcx, rax
  0168a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN54@cckd64_sf_:

; 3753 :         CCKD_TRACE( "merge complete%s", "" );

  01690	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171490
  01697	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0169c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171491
  016a3	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  016a8	ba a9 0e 00 00	 mov	 edx, 3753		; 00000ea9H
  016ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171492
  016b4	e8 00 00 00 00	 call	 cckd_trace

; 3754 :     }
; 3755 :     release_lock( &cckd->cckdiolock );

  016b9	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  016be	48 83 c0 18	 add	 rax, 24
  016c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171493
  016c9	48 8b c8	 mov	 rcx, rax
  016cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3756 : 
; 3757 :     cckd64_sf_stats( dev );

  016d2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  016d7	e8 00 00 00 00	 call	 cckd64_sf_stats

; 3758 :     return NULL;

  016dc	33 c0		 xor	 eax, eax
  016de	e9 cf 02 00 00	 jmp	 $LN1@cckd64_sf_
$sf_merge_error$113:

; 3759 : 
; 3760 : sf_merge_error:
; 3761 : 
; 3762 :     if (trk < 0)

  016e3	83 bc 24 ac 00
	00 00 00	 cmp	 DWORD PTR trk$[rsp], 0
  016eb	0f 8d df 00 00
	00		 jge	 $LN55@cckd64_sf_

; 3763 :         // "%1d:%04X CCKD file[%d] %s: shadow file not merged, error during merge"
; 3764 :         WRMSG( HHC00326, "E", LCSS_DEVNUM, from_sfx, cckd_sf_name( dev, from_sfx ));

  016f1	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  016f7	74 12		 je	 SHORT $LN103@cckd64_sf_
  016f9	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  016fe	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01702	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv901[rsp], eax
  01709	eb 0b		 jmp	 SHORT $LN104@cckd64_sf_
$LN103@cckd64_sf_:
  0170b	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv901[rsp], 0
$LN104@cckd64_sf_:
  01716	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0171c	74 14		 je	 SHORT $LN105@cckd64_sf_
  0171e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  01723	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01727	d1 f8		 sar	 eax, 1
  01729	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv907[rsp], eax
  01730	eb 0b		 jmp	 SHORT $LN106@cckd64_sf_
$LN105@cckd64_sf_:
  01732	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv907[rsp], 0
$LN106@cckd64_sf_:
  0173d	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  01744	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01749	e8 00 00 00 00	 call	 cckd_sf_name
  0174e	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv893[rsp], rax
  01756	b9 01 00 00 00	 mov	 ecx, 1
  0175b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01761	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv893[rsp]
  01769	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0176e	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  01775	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01779	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv901[rsp]
  01780	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01784	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv907[rsp]
  0178b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0178f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171496
  01796	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0179b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171497
  017a2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  017a7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  017ac	41 b9 03 00 00
	00		 mov	 r9d, 3
  017b2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171498
  017b9	ba b4 0e 00 00	 mov	 edx, 3764		; 00000eb4H
  017be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171499
  017c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  017cb	e9 e5 00 00 00	 jmp	 $LN56@cckd64_sf_
$LN55@cckd64_sf_:

; 3765 :     else
; 3766 :         // "%1d:%04X CCKD file[%d] %s: shadow file not merged, error processing trk(%d)"
; 3767 :         WRMSG( HHC00327, "E", LCSS_DEVNUM, from_sfx, cckd_sf_name( dev, from_sfx ), trk );

  017d0	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  017d6	74 12		 je	 SHORT $LN107@cckd64_sf_
  017d8	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  017dd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  017e1	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv927[rsp], eax
  017e8	eb 0b		 jmp	 SHORT $LN108@cckd64_sf_
$LN107@cckd64_sf_:
  017ea	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv927[rsp], 0
$LN108@cckd64_sf_:
  017f5	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  017fb	74 14		 je	 SHORT $LN109@cckd64_sf_
  017fd	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  01802	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01806	d1 f8		 sar	 eax, 1
  01808	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv933[rsp], eax
  0180f	eb 0b		 jmp	 SHORT $LN110@cckd64_sf_
$LN109@cckd64_sf_:
  01811	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv933[rsp], 0
$LN110@cckd64_sf_:
  0181c	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR from_sfx$[rsp]
  01823	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01828	e8 00 00 00 00	 call	 cckd_sf_name
  0182d	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv919[rsp], rax
  01835	b9 01 00 00 00	 mov	 ecx, 1
  0183a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01840	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  01847	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0184b	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv919[rsp]
  01853	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01858	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  0185f	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01863	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv927[rsp]
  0186a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0186e	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv933[rsp]
  01875	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01879	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171500
  01880	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01885	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171501
  0188c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01891	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01896	41 b9 03 00 00
	00		 mov	 r9d, 3
  0189c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171502
  018a3	ba b7 0e 00 00	 mov	 edx, 3767		; 00000eb7H
  018a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171503
  018af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN56@cckd64_sf_:

; 3768 : 
; 3769 :     if (l2updated && cckd->L1tab[ to_sfx ][i] && cckd->L1tab[ to_sfx ][i] != CCKD64_SHADOW_NO_OFFSET)

  018b5	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR l2updated$[rsp], 0
  018bd	0f 84 a9 00 00
	00		 je	 $LN57@cckd64_sf_
  018c3	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  018cb	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  018d3	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  018d8	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  018e0	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  018e5	0f 84 81 00 00
	00		 je	 $LN57@cckd64_sf_
  018eb	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  018f3	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  018fb	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  01900	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  01908	48 83 3c c8 ff	 cmp	 QWORD PTR [rax+rcx*8], -1
  0190d	74 5d		 je	 SHORT $LN57@cckd64_sf_

; 3770 :     {
; 3771 :         l2updated = 0;

  0190f	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR l2updated$[rsp], 0

; 3772 :         pos = cckd->L1tab[to_sfx][i];

  0191a	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR to_sfx$[rsp]
  01922	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  0192a	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  0192f	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  01937	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  0193b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pos$[rsp], rax

; 3773 :         cckd64_write( dev, to_sfx, pos, &to_l2, CCKD64_L2TAB_SIZE );

  01943	c7 44 24 20 00
	10 00 00	 mov	 DWORD PTR [rsp+32], 4096 ; 00001000H
  0194b	4c 8d 8c 24 90
	01 00 00	 lea	 r9, QWORD PTR to_l2$[rsp]
  01953	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pos$[rsp]
  0195b	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR to_sfx$[rsp]
  01962	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01967	e8 00 00 00 00	 call	 cckd64_write
$LN57@cckd64_sf_:

; 3774 :     }
; 3775 :     cckd64_harden( dev );

  0196c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01971	e8 00 00 00 00	 call	 cckd64_harden

; 3776 :     cckd64_chkdsk( dev, 2 );

  01976	ba 02 00 00 00	 mov	 edx, 2
  0197b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01980	e8 00 00 00 00	 call	 cckd64_chkdsk

; 3777 :     cckd->sfn = from_sfx;

  01985	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0198a	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR from_sfx$[rsp]
  01991	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 3778 :     cckd64_harden( dev );

  01994	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  01999	e8 00 00 00 00	 call	 cckd64_harden

; 3779 :     cckd64_chkdsk( dev, 2 );

  0199e	ba 02 00 00 00	 mov	 edx, 2
  019a3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  019a8	e8 00 00 00 00	 call	 cckd64_chkdsk

; 3780 :     goto sf_remove_exit;

  019ad	e9 39 fc ff ff	 jmp	 $sf_remove_exit$112
$LN1@cckd64_sf_:

; 3781 : 
; 3782 : } /* end function cckd64_sf_remove */

  019b2	48 8b 8c 24 90
	21 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  019ba	48 33 cc	 xor	 rcx, rsp
  019bd	e8 00 00 00 00	 call	 __security_check_cookie
  019c2	48 81 c4 a0 21
	01 00		 add	 rsp, 74144		; 000121a0H
  019c9	5f		 pop	 rdi
  019ca	c3		 ret	 0
cckd64_sf_remove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
dev$ = 96
cckd$ = 104
n$1 = 112
tv73 = 116
tv79 = 120
tv139 = 124
tv145 = 128
tv176 = 132
tv182 = 136
tv250 = 140
tv256 = 144
tv291 = 148
tv297 = 152
tv245 = 156
tv242 = 160
tv163 = 168
tv275 = 176
data$ = 208
cckd64_sf_add PROC

; 3358 : {

$LN38:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 3359 : DEVBLK         *dev = data;             /* -> DEVBLK                 */

  0000c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00014	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax

; 3360 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 3361 : 
; 3362 :     if (dev == NULL)

  00019	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0001f	0f 85 50 01 00
	00		 jne	 $LN7@cckd64_sf_

; 3363 :     {
; 3364 :     int n = 0;

  00025	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0

; 3365 :         for (dev=sysblk.firstdev; dev; dev=dev->nextdev)

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00034	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  0003b	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
  00040	eb 0e		 jmp	 SHORT $LN4@cckd64_sf_
$LN2@cckd64_sf_:
  00042	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00047	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0004b	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd64_sf_:
  00050	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00056	0f 84 c3 00 00
	00		 je	 $LN3@cckd64_sf_

; 3366 :             if (dev->cckd_ext)

  0005c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00061	48 83 b8 08 13
	00 00 00	 cmp	 QWORD PTR [rax+4872], 0
  00069	0f 84 ab 00 00
	00		 je	 $LN8@cckd64_sf_

; 3367 :             {
; 3368 :                 WRMSG (HHC00315, "I", LCSS_DEVNUM );

  0006f	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00075	74 0f		 je	 SHORT $LN16@cckd64_sf_
  00077	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0007c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00080	89 44 24 74	 mov	 DWORD PTR tv73[rsp], eax
  00084	eb 08		 jmp	 SHORT $LN17@cckd64_sf_
$LN16@cckd64_sf_:
  00086	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN17@cckd64_sf_:
  0008e	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00094	74 11		 je	 SHORT $LN18@cckd64_sf_
  00096	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0009b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0009f	d1 f8		 sar	 eax, 1
  000a1	89 44 24 78	 mov	 DWORD PTR tv79[rsp], eax
  000a5	eb 08		 jmp	 SHORT $LN19@cckd64_sf_
$LN18@cckd64_sf_:
  000a7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN19@cckd64_sf_:
  000af	b9 01 00 00 00	 mov	 ecx, 1
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ba	8b 4c 24 74	 mov	 ecx, DWORD PTR tv73[rsp]
  000be	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c2	8b 4c 24 78	 mov	 ecx, DWORD PTR tv79[rsp]
  000c6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171259
  000d1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171260
  000dd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171261
  000f4	ba 28 0d 00 00	 mov	 edx, 3368		; 00000d28H
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171262
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3369 :                 cckd64_sf_add (dev);

  00106	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0010b	e8 00 00 00 00	 call	 cckd64_sf_add

; 3370 :                 n++;

  00110	8b 44 24 70	 mov	 eax, DWORD PTR n$1[rsp]
  00114	ff c0		 inc	 eax
  00116	89 44 24 70	 mov	 DWORD PTR n$1[rsp], eax
$LN8@cckd64_sf_:

; 3371 :             }

  0011a	e9 23 ff ff ff	 jmp	 $LN2@cckd64_sf_
$LN3@cckd64_sf_:

; 3372 :         WRMSG(HHC00316, "I", n );

  0011f	b9 01 00 00 00	 mov	 ecx, 1
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012a	8b 4c 24 70	 mov	 ecx, DWORD PTR n$1[rsp]
  0012e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171263
  00139	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171264
  00145	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00155	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171265
  0015c	ba 2c 0d 00 00	 mov	 edx, 3372		; 00000d2cH
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171266
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3373 :         return NULL;

  0016e	33 c0		 xor	 eax, eax
  00170	e9 cd 05 00 00	 jmp	 $LN1@cckd64_sf_
$LN7@cckd64_sf_:

; 3374 :     }
; 3375 : 
; 3376 :     cckd = dev->cckd_ext;

  00175	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0017a	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00181	48 89 44 24 68	 mov	 QWORD PTR cckd$[rsp], rax

; 3377 :     if (!cckd)

  00186	48 83 7c 24 68
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  0018c	0f 85 a7 00 00
	00		 jne	 $LN9@cckd64_sf_

; 3378 :     {
; 3379 :         WRMSG (HHC00317, "E", LCSS_DEVNUM);

  00192	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00198	74 0f		 je	 SHORT $LN20@cckd64_sf_
  0019a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0019f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001a3	89 44 24 7c	 mov	 DWORD PTR tv139[rsp], eax
  001a7	eb 08		 jmp	 SHORT $LN21@cckd64_sf_
$LN20@cckd64_sf_:
  001a9	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
$LN21@cckd64_sf_:
  001b1	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  001b7	74 14		 je	 SHORT $LN22@cckd64_sf_
  001b9	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001be	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001c2	d1 f8		 sar	 eax, 1
  001c4	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv145[rsp], eax
  001cb	eb 0b		 jmp	 SHORT $LN23@cckd64_sf_
$LN22@cckd64_sf_:
  001cd	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv145[rsp], 0
$LN23@cckd64_sf_:
  001d8	b9 01 00 00 00	 mov	 ecx, 1
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e3	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv139[rsp]
  001e7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001eb	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv145[rsp]
  001f2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171268
  001fd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171269
  00209	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0020e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00213	41 b9 03 00 00
	00		 mov	 r9d, 3
  00219	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171270
  00220	ba 33 0d 00 00	 mov	 edx, 3379		; 00000d33H
  00225	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171271
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3380 :         return NULL;

  00232	33 c0		 xor	 eax, eax
  00234	e9 09 05 00 00	 jmp	 $LN1@cckd64_sf_
$LN9@cckd64_sf_:

; 3381 :     }
; 3382 : 
; 3383 :     /* Schedule updated track entries to be written */
; 3384 :     obtain_lock (&cckd->cckdiolock);

  00239	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0023e	48 83 c0 18	 add	 rax, 24
  00242	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171272
  00249	48 8b c8	 mov	 rcx, rax
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3385 :     if (cckd->merging)

  00252	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00257	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0025a	c1 e8 05	 shr	 eax, 5
  0025d	83 e0 01	 and	 eax, 1
  00260	85 c0		 test	 eax, eax
  00262	0f 84 fc 00 00
	00		 je	 $LN10@cckd64_sf_

; 3386 :     {
; 3387 :         release_lock (&cckd->cckdiolock);

  00268	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0026d	48 83 c0 18	 add	 rax, 24
  00271	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171274
  00278	48 8b c8	 mov	 rcx, rax
  0027b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3388 :         WRMSG (HHC00318, "W", LCSS_DEVNUM, cckd->sfn, cckd_sf_name (dev, cckd->sfn));

  00281	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00287	74 12		 je	 SHORT $LN24@cckd64_sf_
  00289	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0028e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00292	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv176[rsp], eax
  00299	eb 0b		 jmp	 SHORT $LN25@cckd64_sf_
$LN24@cckd64_sf_:
  0029b	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv176[rsp], 0
$LN25@cckd64_sf_:
  002a6	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002ac	74 14		 je	 SHORT $LN26@cckd64_sf_
  002ae	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002b3	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002b7	d1 f8		 sar	 eax, 1
  002b9	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv182[rsp], eax
  002c0	eb 0b		 jmp	 SHORT $LN27@cckd64_sf_
$LN26@cckd64_sf_:
  002c2	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv182[rsp], 0
$LN27@cckd64_sf_:
  002cd	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  002d2	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  002d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002da	e8 00 00 00 00	 call	 cckd_sf_name
  002df	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv163[rsp], rax
  002e7	b9 01 00 00 00	 mov	 ecx, 1
  002ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv163[rsp]
  002fa	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002ff	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00304	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00307	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0030b	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv176[rsp]
  00312	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00316	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv182[rsp]
  0031d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00321	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171275
  00328	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0032d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171276
  00334	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00339	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0033e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00344	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171277
  0034b	ba 3c 0d 00 00	 mov	 edx, 3388		; 00000d3cH
  00350	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171278
  00357	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3389 :         return NULL;

  0035d	33 c0		 xor	 eax, eax
  0035f	e9 de 03 00 00	 jmp	 $LN1@cckd64_sf_
$LN10@cckd64_sf_:

; 3390 :     }
; 3391 :     cckd->merging = 1;

  00364	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00369	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0036c	83 c8 20	 or	 eax, 32			; 00000020H
  0036f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00374	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3392 :     cckd64_flush_cache (dev);

  00377	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0037c	e8 00 00 00 00	 call	 cckd64_flush_cache
$LN5@cckd64_sf_:

; 3393 :     while (cckd->wrpending || cckd->cckdioact)

  00381	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00386	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  0038a	75 12		 jne	 SHORT $LN11@cckd64_sf_
  0038c	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00391	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00394	c1 e8 02	 shr	 eax, 2
  00397	83 e0 01	 and	 eax, 1
  0039a	85 c0		 test	 eax, eax
  0039c	74 52		 je	 SHORT $LN6@cckd64_sf_
$LN11@cckd64_sf_:

; 3394 :     {
; 3395 :         cckd->cckdwaiters++;

  0039e	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003a3	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  003a6	ff c0		 inc	 eax
  003a8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  003ad	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 3396 :         wait_condition (&cckd->cckdiocond, &cckd->cckdiolock);

  003b0	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003b5	48 83 c0 18	 add	 rax, 24
  003b9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  003be	48 83 c1 20	 add	 rcx, 32			; 00000020H
  003c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171280
  003c9	48 8b d0	 mov	 rdx, rax
  003cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 3397 :         cckd->cckdwaiters--;

  003d2	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  003d7	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  003da	ff c8		 dec	 eax
  003dc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  003e1	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 3398 :         cckd64_flush_cache (dev);

  003e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003e9	e8 00 00 00 00	 call	 cckd64_flush_cache

; 3399 :     }

  003ee	eb 91		 jmp	 SHORT $LN5@cckd64_sf_
$LN6@cckd64_sf_:

; 3400 :     cckd64_purge_cache (dev); cckd64_purge_l2 (dev);

  003f0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003f5	e8 00 00 00 00	 call	 cckd64_purge_cache
  003fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003ff	e8 00 00 00 00	 call	 cckd64_purge_l2

; 3401 :     dev->bufcur = dev->cache = -1;

  00404	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00409	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00413	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00418	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 3402 :     release_lock (&cckd->cckdiolock);

  00422	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00427	48 83 c0 18	 add	 rax, 24
  0042b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171281
  00432	48 8b c8	 mov	 rcx, rax
  00435	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3403 : 
; 3404 :     /* Obtain control of the file */
; 3405 :     obtain_lock( &cckd->filelock );

  0043b	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00440	48 83 c0 10	 add	 rax, 16
  00444	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171282
  0044b	48 8b c8	 mov	 rcx, rax
  0044e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3406 :     {
; 3407 :         /* Harden the current file */
; 3408 :         cckd64_harden (dev);

  00454	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00459	e8 00 00 00 00	 call	 cckd64_harden

; 3409 : 
; 3410 :         /* Create a new shadow file */
; 3411 :         if (cckd64_sf_new (dev) < 0) {

  0045e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00463	e8 00 00 00 00	 call	 cckd64_sf_new
  00468	85 c0		 test	 eax, eax
  0046a	0f 8d 21 01 00
	00		 jge	 $LN12@cckd64_sf_

; 3412 :             WRMSG (HHC00319, "E", LCSS_DEVNUM, cckd->sfn+1,

  00470	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00475	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00478	ff c0		 inc	 eax
  0047a	8b d0		 mov	 edx, eax
  0047c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00481	e8 00 00 00 00	 call	 cckd_sf_name
  00486	48 85 c0	 test	 rax, rax
  00489	74 20		 je	 SHORT $LN28@cckd64_sf_
  0048b	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00490	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00493	ff c0		 inc	 eax
  00495	8b d0		 mov	 edx, eax
  00497	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0049c	e8 00 00 00 00	 call	 cckd_sf_name
  004a1	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv242[rsp], rax
  004a9	eb 0f		 jmp	 SHORT $LN29@cckd64_sf_
$LN28@cckd64_sf_:
  004ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171284
  004b2	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv242[rsp], rax
$LN29@cckd64_sf_:
  004ba	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  004c0	74 12		 je	 SHORT $LN30@cckd64_sf_
  004c2	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  004c7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004cb	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv250[rsp], eax
  004d2	eb 0b		 jmp	 SHORT $LN31@cckd64_sf_
$LN30@cckd64_sf_:
  004d4	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv250[rsp], 0
$LN31@cckd64_sf_:
  004df	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  004e5	74 14		 je	 SHORT $LN32@cckd64_sf_
  004e7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  004ec	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  004f0	d1 f8		 sar	 eax, 1
  004f2	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv256[rsp], eax
  004f9	eb 0b		 jmp	 SHORT $LN33@cckd64_sf_
$LN32@cckd64_sf_:
  004fb	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv256[rsp], 0
$LN33@cckd64_sf_:
  00506	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0050b	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0050e	ff c0		 inc	 eax
  00510	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv245[rsp], eax
  00517	b9 01 00 00 00	 mov	 ecx, 1
  0051c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00522	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv242[rsp]
  0052a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0052f	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv245[rsp]
  00536	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0053a	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv250[rsp]
  00541	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00545	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv256[rsp]
  0054c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00550	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171285
  00557	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0055c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171286
  00563	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00568	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0056d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00573	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171287
  0057a	ba 55 0d 00 00	 mov	 edx, 3413		; 00000d55H
  0057f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171288
  00586	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3413 :                      cckd_sf_name(dev, cckd->sfn+1)?cckd_sf_name(dev, cckd->sfn+1):"(null)");
; 3414 :             goto cckd_sf_add_exit;

  0058c	e9 19 01 00 00	 jmp	 $cckd_sf_add_exit$39
$LN12@cckd64_sf_:

; 3415 :         }
; 3416 : 
; 3417 :         /* Re-open the previous file if opened read-write */
; 3418 :         if (cckd->open[cckd->sfn-1] == CCKD_OPEN_RW)

  00591	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00596	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00599	ff c8		 dec	 eax
  0059b	48 98		 cdqe
  0059d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  005a2	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  005aa	83 f8 03	 cmp	 eax, 3
  005ad	75 1f		 jne	 SHORT $LN13@cckd64_sf_

; 3419 :             cckd64_open (dev, cckd->sfn-1, O_RDONLY|O_BINARY, 0);

  005af	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  005b4	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  005b7	ff c8		 dec	 eax
  005b9	45 33 c9	 xor	 r9d, r9d
  005bc	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  005c2	8b d0		 mov	 edx, eax
  005c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  005c9	e8 00 00 00 00	 call	 cckd64_open
$LN13@cckd64_sf_:

; 3420 : 
; 3421 :         WRMSG (HHC00320, "I", LCSS_DEVNUM, cckd->sfn, cckd_sf_name (dev, cckd->sfn));

  005ce	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  005d4	74 12		 je	 SHORT $LN34@cckd64_sf_
  005d6	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  005db	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005df	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv291[rsp], eax
  005e6	eb 0b		 jmp	 SHORT $LN35@cckd64_sf_
$LN34@cckd64_sf_:
  005e8	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv291[rsp], 0
$LN35@cckd64_sf_:
  005f3	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  005f9	74 14		 je	 SHORT $LN36@cckd64_sf_
  005fb	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00600	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00604	d1 f8		 sar	 eax, 1
  00606	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv297[rsp], eax
  0060d	eb 0b		 jmp	 SHORT $LN37@cckd64_sf_
$LN36@cckd64_sf_:
  0060f	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv297[rsp], 0
$LN37@cckd64_sf_:
  0061a	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0061f	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00622	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00627	e8 00 00 00 00	 call	 cckd_sf_name
  0062c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv275[rsp], rax
  00634	b9 01 00 00 00	 mov	 ecx, 1
  00639	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0063f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv275[rsp]
  00647	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0064c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00651	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00654	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00658	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv291[rsp]
  0065f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00663	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv297[rsp]
  0066a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0066e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171290
  00675	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0067a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171291
  00681	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00686	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0068b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00691	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171292
  00698	ba 5d 0d 00 00	 mov	 edx, 3421		; 00000d5dH
  0069d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171293
  006a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$cckd_sf_add_exit$39:

; 3422 : 
; 3423 : cckd_sf_add_exit:
; 3424 : 
; 3425 :         /* Re-read the l1 to set L2_bounds, L2ok */
; 3426 :         cckd64_read_l1 (dev);

  006aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  006af	e8 00 00 00 00	 call	 cckd64_read_l1

; 3427 :     }
; 3428 :     release_lock( &cckd->filelock );

  006b4	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  006b9	48 83 c0 10	 add	 rax, 16
  006bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171294
  006c4	48 8b c8	 mov	 rcx, rax
  006c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3429 : 
; 3430 :     obtain_lock (&cckd->cckdiolock);

  006cd	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  006d2	48 83 c0 18	 add	 rax, 24
  006d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171295
  006dd	48 8b c8	 mov	 rcx, rax
  006e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3431 :     cckd->merging = 0;

  006e6	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  006eb	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  006ee	83 e0 df	 and	 eax, -33		; ffffffdfH
  006f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  006f6	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 3432 :     if (cckd->cckdwaiters)

  006f9	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  006fe	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00702	74 19		 je	 SHORT $LN14@cckd64_sf_

; 3433 :         broadcast_condition (&cckd->cckdiocond);

  00704	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00709	48 83 c0 20	 add	 rax, 32			; 00000020H
  0070d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171297
  00714	48 8b c8	 mov	 rcx, rax
  00717	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN14@cckd64_sf_:

; 3434 :     release_lock (&cckd->cckdiolock);

  0071d	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00722	48 83 c0 18	 add	 rax, 24
  00726	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171298
  0072d	48 8b c8	 mov	 rcx, rax
  00730	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3435 : 
; 3436 :     cckd64_sf_stats (dev);

  00736	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0073b	e8 00 00 00 00	 call	 cckd64_sf_stats

; 3437 :     return NULL;

  00740	33 c0		 xor	 eax, eax
$LN1@cckd64_sf_:

; 3438 : } /* end function cckd64_sf_add */

  00742	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00749	c3		 ret	 0
cckd64_sf_add ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
comp$ = 144
newlen$ = 148
cckd$ = 152
to$ = 160
tv95 = 168
tv245 = 172
tv251 = 176
tv281 = 180
tv287 = 184
tv216 = 188
tv220 = 192
tv224 = 196
tv228 = 200
tv232 = 204
tv235 = 208
tv298 = 216
tv267 = 224
tv271 = 232
dev$ = 256
from$ = 264
len$ = 272
maxlen$ = 280
trk$ = 288
cckd64_uncompress PROC

; 4811 : {

$LN27:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 4812 : CCKD64_EXT     *cckd;
; 4813 : BYTE           *to = NULL;                /* Uncompressed buffer     */

  0001b	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR to$[rsp], 0

; 4814 : int             newlen;                   /* Uncompressed length     */
; 4815 : BYTE            comp;                     /* Compression type        */
; 4816 : static char    *compress[] = {"none", "zlib", "bzip2"};
; 4817 : 
; 4818 :     cckd = dev->cckd_ext;

  00027	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00036	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 4819 : 
; 4820 :     CCKD_TRACE( "uncompress comp %d len %d maxlen %d trk %d",

  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	48 6b c0 00	 imul	 rax, rax, 0
  00047	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  0004f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00053	83 e0 03	 and	 eax, 3
  00056	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  0005d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00061	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR maxlen$[rsp]
  00068	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0006c	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00073	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00077	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0007b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172072
  00082	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0008a	ba d5 12 00 00	 mov	 edx, 4821		; 000012d5H
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172073
  00096	e8 00 00 00 00	 call	 cckd_trace

; 4821 :                 from[0] & CCKD_COMPRESS_MASK, len, maxlen, trk);
; 4822 : 
; 4823 :     /* Extract compression type */
; 4824 :     comp = (from[0] & CCKD_COMPRESS_MASK);

  0009b	b8 01 00 00 00	 mov	 eax, 1
  000a0	48 6b c0 00	 imul	 rax, rax, 0
  000a4	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  000ac	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b0	83 e0 03	 and	 eax, 3
  000b3	88 84 24 90 00
	00 00		 mov	 BYTE PTR comp$[rsp], al

; 4825 : 
; 4826 :     /* Get a buffer to uncompress into */
; 4827 :     if (comp != CCKD_COMPRESS_NONE && cckd->newbuf == NULL)

  000ba	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  000c2	85 c0		 test	 eax, eax
  000c4	74 50		 je	 SHORT $LN4@cckd64_unc
  000c6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  000ce	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000d3	75 41		 jne	 SHORT $LN4@cckd64_unc

; 4828 :     {
; 4829 :         cckd->newbuf = cckd_malloc (dev, "newbuf", maxlen);

  000d5	48 63 84 24 18
	01 00 00	 movsxd	 rax, DWORD PTR maxlen$[rsp]
  000dd	4c 8b c0	 mov	 r8, rax
  000e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172075
  000e7	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000ef	e8 00 00 00 00	 call	 cckd_malloc
  000f4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  000fc	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 4830 :         if (cckd->newbuf == NULL)

  00100	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00108	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0010d	75 07		 jne	 SHORT $LN5@cckd64_unc

; 4831 :             return NULL;

  0010f	33 c0		 xor	 eax, eax
  00111	e9 c3 06 00 00	 jmp	 $LN1@cckd64_unc
$LN5@cckd64_unc:
$LN4@cckd64_unc:

; 4832 :     }
; 4833 : 
; 4834 :     /* Uncompress the track image */
; 4835 :     switch (comp) {

  00116	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  0011e	88 84 24 a8 00
	00 00		 mov	 BYTE PTR tv95[rsp], al
  00125	80 bc 24 a8 00
	00 00 00	 cmp	 BYTE PTR tv95[rsp], 0
  0012d	74 1d		 je	 SHORT $LN6@cckd64_unc
  0012f	80 bc 24 a8 00
	00 00 01	 cmp	 BYTE PTR tv95[rsp], 1
  00137	74 44		 je	 SHORT $LN7@cckd64_unc
  00139	80 bc 24 a8 00
	00 00 02	 cmp	 BYTE PTR tv95[rsp], 2
  00141	0f 84 83 00 00
	00		 je	 $LN8@cckd64_unc
  00147	e9 cb 00 00 00	 jmp	 $LN9@cckd64_unc
$LN6@cckd64_unc:

; 4836 : 
; 4837 :     case CCKD_COMPRESS_NONE:
; 4838 :         newlen = cckd_trklen (dev, from);

  0014c	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR from$[rsp]
  00154	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0015c	e8 00 00 00 00	 call	 cckd_trklen
  00161	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 4839 :         to = from;

  00168	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR from$[rsp]
  00170	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR to$[rsp], rax

; 4840 :         break;

  00178	e9 a5 00 00 00	 jmp	 $LN2@cckd64_unc
$LN7@cckd64_unc:

; 4841 :     case CCKD_COMPRESS_ZLIB:
; 4842 :         to = cckd->newbuf;

  0017d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00185	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00189	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR to$[rsp], rax

; 4843 :         newlen = cckd_uncompress_zlib (dev, to, from, len, maxlen);

  00191	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR maxlen$[rsp]
  00198	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0019c	44 8b 8c 24 10
	01 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  001a4	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR from$[rsp]
  001ac	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  001b4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001bc	e8 00 00 00 00	 call	 cckd_uncompress_zlib
  001c1	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 4844 :         break;

  001c8	eb 58		 jmp	 SHORT $LN2@cckd64_unc
$LN8@cckd64_unc:

; 4845 :     case CCKD_COMPRESS_BZIP2:
; 4846 :         to = cckd->newbuf;

  001ca	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  001d2	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001d6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR to$[rsp], rax

; 4847 :         newlen = cckd_uncompress_bzip2 (dev, to, from, len, maxlen);

  001de	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR maxlen$[rsp]
  001e5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001e9	44 8b 8c 24 10
	01 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  001f1	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR from$[rsp]
  001f9	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  00201	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00209	e8 00 00 00 00	 call	 cckd_uncompress_bzip2
  0020e	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 4848 :         break;

  00215	eb 0b		 jmp	 SHORT $LN2@cckd64_unc
$LN9@cckd64_unc:

; 4849 :     default:
; 4850 :         newlen = -1;

  00217	c7 84 24 94 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR newlen$[rsp], -1
$LN2@cckd64_unc:

; 4851 :         break;
; 4852 :     }
; 4853 : 
; 4854 :     /* Validate the uncompressed track image */
; 4855 :     newlen = cckd64_validate (dev, to, trk, newlen);

  00222	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR newlen$[rsp]
  0022a	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00232	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  0023a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00242	e8 00 00 00 00	 call	 cckd64_validate
  00247	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 4856 : 
; 4857 :     /* Return if successful */
; 4858 :     if (newlen > 0)

  0024e	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR newlen$[rsp], 0
  00256	7e 4c		 jle	 SHORT $LN10@cckd64_unc

; 4859 :     {
; 4860 :         if (to != from)

  00258	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR from$[rsp]
  00260	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR to$[rsp], rax
  00268	74 2d		 je	 SHORT $LN11@cckd64_unc

; 4861 :         {
; 4862 :             cckd->newbuf = from;

  0026a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00272	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  0027a	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 4863 :             cckd->bufused = 1;

  0027e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00286	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00289	83 c8 08	 or	 eax, 8
  0028c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00294	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN11@cckd64_unc:

; 4864 :         }
; 4865 :         return to;

  00297	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR to$[rsp]
  0029f	e9 35 05 00 00	 jmp	 $LN1@cckd64_unc
$LN10@cckd64_unc:

; 4866 :     }
; 4867 : 
; 4868 :     /* Get a buffer now if we haven't gotten one */
; 4869 :     if (cckd->newbuf == NULL)

  002a4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  002ac	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  002b1	75 41		 jne	 SHORT $LN12@cckd64_unc

; 4870 :     {
; 4871 :         cckd->newbuf = cckd_malloc (dev, "newbuf2", maxlen);

  002b3	48 63 84 24 18
	01 00 00	 movsxd	 rax, DWORD PTR maxlen$[rsp]
  002bb	4c 8b c0	 mov	 r8, rax
  002be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172084
  002c5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002cd	e8 00 00 00 00	 call	 cckd_malloc
  002d2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  002da	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 4872 :         if (cckd->newbuf == NULL)

  002de	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  002e6	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  002eb	75 07		 jne	 SHORT $LN13@cckd64_unc

; 4873 :             return NULL;

  002ed	33 c0		 xor	 eax, eax
  002ef	e9 e5 04 00 00	 jmp	 $LN1@cckd64_unc
$LN13@cckd64_unc:
$LN12@cckd64_unc:

; 4874 :     }
; 4875 : 
; 4876 :     /* Try each uncompression routine in turn */
; 4877 : 
; 4878 :     /* uncompressed */
; 4879 :     newlen = cckd_trklen   (dev, from);

  002f4	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR from$[rsp]
  002fc	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00304	e8 00 00 00 00	 call	 cckd_trklen
  00309	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 4880 :     newlen = cckd64_validate (dev, from, trk, newlen);

  00310	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR newlen$[rsp]
  00318	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00320	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR from$[rsp]
  00328	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00330	e8 00 00 00 00	 call	 cckd64_validate
  00335	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 4881 :     if (newlen > 0)

  0033c	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR newlen$[rsp], 0
  00344	7e 0d		 jle	 SHORT $LN14@cckd64_unc

; 4882 :         return from;

  00346	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR from$[rsp]
  0034e	e9 86 04 00 00	 jmp	 $LN1@cckd64_unc
$LN14@cckd64_unc:

; 4883 : 
; 4884 :     /* zlib compression */
; 4885 :     to = cckd->newbuf;

  00353	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0035b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0035f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR to$[rsp], rax

; 4886 :     newlen = cckd_uncompress_zlib (dev, to, from, len, maxlen);

  00367	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR maxlen$[rsp]
  0036e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00372	44 8b 8c 24 10
	01 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  0037a	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR from$[rsp]
  00382	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  0038a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00392	e8 00 00 00 00	 call	 cckd_uncompress_zlib
  00397	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 4887 :     newlen = cckd64_validate      (dev, to, trk, newlen);

  0039e	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR newlen$[rsp]
  003a6	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  003ae	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  003b6	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003be	e8 00 00 00 00	 call	 cckd64_validate
  003c3	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 4888 :     if (newlen > 0)

  003ca	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR newlen$[rsp], 0
  003d2	7e 3a		 jle	 SHORT $LN15@cckd64_unc

; 4889 :     {
; 4890 :         cckd->newbuf = from;

  003d4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  003dc	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  003e4	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 4891 :         cckd->bufused = 1;

  003e8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  003f0	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003f3	83 c8 08	 or	 eax, 8
  003f6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  003fe	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4892 :         return to;

  00401	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR to$[rsp]
  00409	e9 cb 03 00 00	 jmp	 $LN1@cckd64_unc
$LN15@cckd64_unc:

; 4893 :     }
; 4894 : 
; 4895 :     /* bzip2 compression */
; 4896 :     to = cckd->newbuf;

  0040e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00416	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0041a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR to$[rsp], rax

; 4897 :     newlen = cckd_uncompress_bzip2 (dev, to, from, len, maxlen);

  00422	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR maxlen$[rsp]
  00429	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0042d	44 8b 8c 24 10
	01 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  00435	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR from$[rsp]
  0043d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  00445	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0044d	e8 00 00 00 00	 call	 cckd_uncompress_bzip2
  00452	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 4898 :     newlen = cckd64_validate       (dev, to, trk, newlen);

  00459	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR newlen$[rsp]
  00461	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00469	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR to$[rsp]
  00471	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00479	e8 00 00 00 00	 call	 cckd64_validate
  0047e	89 84 24 94 00
	00 00		 mov	 DWORD PTR newlen$[rsp], eax

; 4899 :     if (newlen > 0)

  00485	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR newlen$[rsp], 0
  0048d	7e 3a		 jle	 SHORT $LN16@cckd64_unc

; 4900 :     {
; 4901 :         cckd->newbuf = from;

  0048f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00497	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  0049f	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 4902 :         cckd->bufused = 1;

  004a3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  004ab	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  004ae	83 c8 08	 or	 eax, 8
  004b1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  004b9	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4903 :         return to;

  004bc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR to$[rsp]
  004c4	e9 10 03 00 00	 jmp	 $LN1@cckd64_unc
$LN16@cckd64_unc:

; 4904 :     }
; 4905 : 
; 4906 :     /* Unable to uncompress */
; 4907 :     WRMSG (HHC00343, "E",

  004c9	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  004d2	74 15		 je	 SHORT $LN19@cckd64_unc
  004d4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004dc	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004e0	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv245[rsp], eax
  004e7	eb 0b		 jmp	 SHORT $LN20@cckd64_unc
$LN19@cckd64_unc:
  004e9	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv245[rsp], 0
$LN20@cckd64_unc:
  004f4	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  004fd	74 17		 je	 SHORT $LN21@cckd64_unc
  004ff	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00507	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0050b	d1 f8		 sar	 eax, 1
  0050d	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv251[rsp], eax
  00514	eb 0b		 jmp	 SHORT $LN22@cckd64_unc
$LN21@cckd64_unc:
  00516	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv251[rsp], 0
$LN22@cckd64_unc:
  00521	b8 01 00 00 00	 mov	 eax, 1
  00526	48 6b c0 04	 imul	 rax, rax, 4
  0052a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR from$[rsp]
  00532	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00536	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv216[rsp], eax
  0053d	b9 01 00 00 00	 mov	 ecx, 1
  00542	48 6b c9 03	 imul	 rcx, rcx, 3
  00546	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR from$[rsp]
  0054e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00552	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv220[rsp], ecx
  00559	ba 01 00 00 00	 mov	 edx, 1
  0055e	48 6b d2 02	 imul	 rdx, rdx, 2
  00562	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR from$[rsp]
  0056a	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  0056f	89 94 24 c4 00
	00 00		 mov	 DWORD PTR tv224[rsp], edx
  00576	41 b8 01 00 00
	00		 mov	 r8d, 1
  0057c	4d 6b c0 01	 imul	 r8, r8, 1
  00580	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR from$[rsp]
  00588	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  0058d	44 89 84 24 c8
	00 00 00	 mov	 DWORD PTR tv228[rsp], r8d
  00595	41 b9 01 00 00
	00		 mov	 r9d, 1
  0059b	4d 6b c9 00	 imul	 r9, r9, 0
  0059f	4c 8b 94 24 08
	01 00 00	 mov	 r10, QWORD PTR from$[rsp]
  005a7	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  005ac	44 89 8c 24 cc
	00 00 00	 mov	 DWORD PTR tv232[rsp], r9d
  005b4	4c 8b 94 24 98
	00 00 00	 mov	 r10, QWORD PTR cckd$[rsp]
  005bc	41 8b 52 3c	 mov	 edx, DWORD PTR [r10+60]
  005c0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005c8	e8 00 00 00 00	 call	 cckd_sf_name
  005cd	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv235[rsp], rax
  005d5	b9 01 00 00 00	 mov	 ecx, 1
  005da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005e0	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv216[rsp]
  005e7	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  005ee	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv220[rsp]
  005f5	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  005f9	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv224[rsp]
  00600	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00604	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv228[rsp]
  0060b	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0060f	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv232[rsp]
  00616	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0061a	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00621	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00625	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv235[rsp]
  0062d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00632	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0063a	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  0063d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00641	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv245[rsp]
  00648	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0064c	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv251[rsp]
  00653	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00657	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172089
  0065e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00663	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172090
  0066a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0066f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00674	41 b9 03 00 00
	00		 mov	 r9d, 3
  0067a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172091
  00681	ba 2d 13 00 00	 mov	 edx, 4909		; 0000132dH
  00686	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172092
  0068d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4908 :             LCSS_DEVNUM, cckd->sfn, cckd_sf_name(dev, cckd->sfn), trk,
; 4909 :             from[0], from[1], from[2], from[3], from[4]);
; 4910 :     if (comp & ~cckdblk.comps)

  00693	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  0069b	0f b6 0d 1c 00
	00 00		 movzx	 ecx, BYTE PTR cckdblk+28
  006a2	f7 d1		 not	 ecx
  006a4	23 c1		 and	 eax, ecx
  006a6	85 c0		 test	 eax, eax
  006a8	0f 84 29 01 00
	00		 je	 $LN17@cckd64_unc

; 4911 :         WRMSG (HHC00344, "E",

  006ae	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006b7	74 15		 je	 SHORT $LN23@cckd64_unc
  006b9	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006c1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006c5	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv281[rsp], eax
  006cc	eb 0b		 jmp	 SHORT $LN24@cckd64_unc
$LN23@cckd64_unc:
  006ce	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv281[rsp], 0
$LN24@cckd64_unc:
  006d9	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006e2	74 17		 je	 SHORT $LN25@cckd64_unc
  006e4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006ec	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  006f0	d1 f8		 sar	 eax, 1
  006f2	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv287[rsp], eax
  006f9	eb 0b		 jmp	 SHORT $LN26@cckd64_unc
$LN25@cckd64_unc:
  006fb	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv287[rsp], 0
$LN26@cckd64_unc:
  00706	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR comp$[rsp]
  0070e	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv267[rsp], rax
  00716	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?compress@?1??cckd64_uncompress@@9@9
  0071d	48 89 8c 24 d8
	00 00 00	 mov	 QWORD PTR tv298[rsp], rcx
  00725	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR cckd$[rsp]
  0072d	8b 52 3c	 mov	 edx, DWORD PTR [rdx+60]
  00730	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00738	e8 00 00 00 00	 call	 cckd_sf_name
  0073d	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv271[rsp], rax
  00745	b9 01 00 00 00	 mov	 ecx, 1
  0074a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00750	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR tv298[rsp]
  00758	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv267[rsp]
  00760	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00764	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00769	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv271[rsp]
  00771	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00776	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0077e	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00781	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00785	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv281[rsp]
  0078c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00790	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv287[rsp]
  00797	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0079b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172094
  007a2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172095
  007ae	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007b8	41 b9 03 00 00
	00		 mov	 r9d, 3
  007be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172096
  007c5	ba 30 13 00 00	 mov	 edx, 4912		; 00001330H
  007ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172097
  007d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@cckd64_unc:

; 4912 :                 LCSS_DEVNUM, cckd->sfn, cckd_sf_name(dev, cckd->sfn), compress[comp]);
; 4913 :     return NULL;

  007d7	33 c0		 xor	 eax, eax
$LN1@cckd64_unc:

; 4914 : }

  007d9	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  007e0	c3		 ret	 0
cckd64_uncompress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
dev$ = 8
buf$ = 16
cckd64_gc_l2 PROC

; 4664 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@cckd64_gc_:

; 4665 : #if 1 // (deprecate this function!)
; 4666 : 
; 4667 :     UNREFERENCED( dev );

  0000a	33 c0		 xor	 eax, eax
  0000c	85 c0		 test	 eax, eax
  0000e	75 fa		 jne	 SHORT $LN4@cckd64_gc_
$LN7@cckd64_gc_:

; 4668 :     UNREFERENCED( buf );

  00010	33 c0		 xor	 eax, eax
  00012	85 c0		 test	 eax, eax
  00014	75 fa		 jne	 SHORT $LN7@cckd64_gc_

; 4669 : 
; 4670 :     return 0;

  00016	33 c0		 xor	 eax, eax

; 4671 : 
; 4672 : #else // (deprecate this function!)
; 4673 : 
; 4674 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 4675 : int             sfx;                    /* Shadow file index         */
; 4676 : int             i, j;                   /* Work variables            */
; 4677 : int             trk;                    /* Track number              */
; 4678 : int             len;                    /* Track length              */
; 4679 : U64             pos, fpos;              /* File offsets              */
; 4680 : 
; 4681 :     if (!dev->cckd64)
; 4682 :         return cckd_gc_l2( dev, buf );
; 4683 : 
; 4684 :     cckd = dev->cckd_ext;
; 4685 : 
; 4686 :     obtain_lock (&cckd->filelock);
; 4687 :     sfx = cckd->sfn;
; 4688 : 
; 4689 :     if (cckd->L2ok || cckd->cdevhdr[cckd->sfn].free_total == 0)
; 4690 :         goto cckd_gc_l2_exit;
; 4691 : 
; 4692 :     /* Find any level 2 table out of bounds */
; 4693 :     for (i = 0; i < cckd->cdevhdr[sfx].num_L1tab; i++)
; 4694 :         if (cckd->L1tab[sfx][i] != CCKD64_NOSIZE && cckd->L1tab[sfx][i] != CCKD64_MAXSIZE
; 4695 :          && cckd->L2_bounds - CCKD64_L2TAB_SIZE < cckd->L1tab[sfx][i])
; 4696 :             break;
; 4697 : 
; 4698 :     /* Return OK if no l2 tables out of bounds */
; 4699 :     if (i >= cckd->cdevhdr[sfx].num_L1tab)
; 4700 :         goto cckd_gc_l2_exit_ok;
; 4701 : 
; 4702 :     /* Relocate all track images within the bounds */
; 4703 :     pos = CCKD64_L1TAB_POS + (cckd->cdevhdr[sfx].num_L1tab * CCKD64_L1ENT_SIZE);
; 4704 :     i = cckd->free_idx1st;
; 4705 :     fpos = cckd->cdevhdr[sfx].free_off;
; 4706 :     while (pos < cckd->L2_bounds)
; 4707 :     {
; 4708 :         if (i >= 0 && pos == fpos)
; 4709 :         {
; 4710 :             pos += cckd->ifb[i].ifb_len;
; 4711 :             fpos = cckd->ifb[i].ifb_offnxt;
; 4712 :             i = cckd->ifb[i].ifb_idxnxt;
; 4713 :             j = 0;
; 4714 :         }
; 4715 :         else
; 4716 :         {
; 4717 :             for (j = 0; j < cckd->cdevhdr[sfx].num_L1tab; j++)
; 4718 :                 if (pos == cckd->L1tab[sfx][j])
; 4719 :                 {
; 4720 :                     pos += CCKD64_L2TAB_SIZE;
; 4721 :                     break;
; 4722 :                 }
; 4723 :         }
; 4724 :         if (j >= cckd->cdevhdr[sfx].num_L1tab)
; 4725 :         {
; 4726 :             /* Found a track to relocate */
; 4727 :             if (cckd64_read (dev, sfx, pos, buf, CKD_TRKHDR_SIZE) < 0)
; 4728 :                 goto cckd_gc_l2_exit;
; 4729 :             if ((trk = cckd64_cchh (dev, buf, -1)) < 0)
; 4730 :                 goto cckd_gc_l2_exit;
; 4731 :             CCKD_TRACE( "gc_l2 relocate trk[%d] offset 0x%"PRIx64, trk, pos);
; 4732 :             if ((len = cckd64_read_trkimg (dev, buf, trk, NULL)) < 0)
; 4733 :                goto cckd_gc_l2_exit;
; 4734 :             if (cckd64_write_trkimg (dev, buf, len, trk, CCKD_SIZE_EXACT) < 0)
; 4735 :                goto cckd_gc_l2_exit;
; 4736 :             /* Start over */
; 4737 :             pos = CCKD64_L1TAB_POS + (cckd->cdevhdr[sfx].num_L1tab * CCKD64_L1ENT_SIZE);
; 4738 :             i = cckd->free_idx1st;
; 4739 :             fpos = cckd->cdevhdr[sfx].free_off;
; 4740 :         }
; 4741 :     }
; 4742 : 
; 4743 :     do {
; 4744 :         /* Find a level 2 table to relocate */
; 4745 : 
; 4746 :         i = cckd->free_idx1st;
; 4747 :         fpos = cckd->cdevhdr[sfx].free_off;
; 4748 : 
; 4749 :         CCKD_TRACE( "gc_l2 first free[%d] pos 0x%"PRIx64" len %"PRId64" pending %d",
; 4750 :                     i, fpos, (U64)(i >= 0 ? cckd->ifb[i].ifb_len : -1),
; 4751 :                     (int)(i >= 0 ? cckd->ifb[i].ifb_pending : -1 ));
; 4752 : 
; 4753 :         if (i < 0 || fpos >= cckd->L2_bounds || cckd->ifb[i].ifb_pending)
; 4754 :             goto cckd_gc_l2_exit;
; 4755 : 
; 4756 :         CCKD_TRACE( "gc_l2 bounds 0x%"PRIx64" sfx %d num_L1tab %d",
; 4757 :             cckd->L2_bounds, sfx, cckd->cdevhdr[sfx].num_L1tab );
; 4758 : 
; 4759 :         if ( cckd->ifb[i].ifb_len <  CCKD64_L2TAB_SIZE
; 4760 :          || (cckd->ifb[i].ifb_len != CCKD64_L2TAB_SIZE
; 4761 :           && cckd->ifb[i].ifb_len <  CCKD64_L2TAB_SIZE + CCKD64_FREEBLK_SIZE)
; 4762 :         )
; 4763 :         {
; 4764 :             for (i=0; i < cckd->cdevhdr[sfx].num_L1tab; i++)
; 4765 :             {
; 4766 :                 if (fpos + cckd->ifb[i].ifb_len == cckd->L1tab[sfx][i])
; 4767 :                     break;
; 4768 :             }
; 4769 :         }
; 4770 :         else
; 4771 :         {
; 4772 :             for (i=0; i < cckd->cdevhdr[sfx].num_L1tab; i++)
; 4773 :             {
; 4774 :                 if (cckd->L2_bounds - CCKD64_L2TAB_SIZE < cckd->L1tab[sfx][i]
; 4775 :                  && cckd->L1tab[sfx][i] != CCKD64_MAXSIZE)
; 4776 :                     break;
; 4777 :             }
; 4778 :         }
; 4779 : 
; 4780 :         if (i < cckd->cdevhdr[sfx].num_L1tab)
; 4781 :         {
; 4782 :             CCKD_TRACE( "gc_l2 relocate l2[%d] pos 0x%"PRIx64,
; 4783 :                         i, cckd->L1tab[sfx][i] );
; 4784 : 
; 4785 :             if (cckd64_read_l2( dev, sfx, i ) < 0)
; 4786 :                 goto cckd_gc_l2_exit;
; 4787 : 
; 4788 :             if (cckd64_write_l2( dev ) < 0)
; 4789 :                 goto cckd_gc_l2_exit;
; 4790 :         }
; 4791 :     }
; 4792 :     while (i < cckd->cdevhdr[sfx].num_L1tab);
; 4793 : 
; 4794 : cckd_gc_l2_exit:
; 4795 :     release_lock (&cckd->filelock);
; 4796 :     return 0;
; 4797 : 
; 4798 : cckd_gc_l2_exit_ok:
; 4799 :     CCKD_TRACE( "gc_l2 ok%s", "" );
; 4800 :     cckd->L2ok = 1;
; 4801 :     goto cckd_gc_l2_exit;
; 4802 : 
; 4803 : #endif // (deprecate this function!)
; 4804 : }

  00018	c3		 ret	 0
cckd64_gc_l2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
cckd$ = 112
i$ = 120
didmsg$ = 128
sfx$ = 136
moved$ = 144
upos$ = 152
trk$ = 160
flen$ = 168
ulen$ = 176
fpos$ = 184
j$ = 192
tv91 = 200
tv129 = 204
tv203 = 208
tv501 = 212
tv530 = 216
tv536 = 220
rc$ = 224
tv758 = 228
tv764 = 232
a$ = 240
after$ = 248
k$ = 256
len$ = 264
flags$ = 272
tv379 = 280
tv419 = 288
tv720 = 296
tv722 = 304
L1idx$ = 312
l2x$ = 316
tv83 = 320
tv522 = 328
tv750 = 336
l2$ = 344
buf$ = 368
__$ArrayPad$ = 262512
dev$ = 262544
size$ = 262552
cckd64_gc_percolate PROC

; 4402 : {

$LN95:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	b8 88 01 04 00	 mov	 eax, 262536		; 00040188H
  0000f	e8 00 00 00 00	 call	 __chkstk
  00014	48 2b e0	 sub	 rsp, rax
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 70
	01 04 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4403 : CCKD64_EXT*     cckd;                   /* -> cckd extension         */
; 4404 : bool            didmsg = false;         /* HHC00384 issued           */

  00029	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR didmsg$[rsp], 0

; 4405 : int             rc;                     /* Return code               */
; 4406 : U64             moved = 0;              /* Space moved               */

  00031	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR moved$[rsp], 0

; 4407 : S64             after = 0, a;           /* New space after old       */

  0003d	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR after$[rsp], 0

; 4408 : S64             sfx;                    /* File index                */
; 4409 : S64             i, j, k;                /* Indexes                   */
; 4410 : int             flags;                  /* Write trkimg flags        */
; 4411 : U64             fpos, upos;             /* File offsets              */
; 4412 : U64             flen, ulen, len;        /* Lengths                   */
; 4413 : int             trk;                    /* Track number              */
; 4414 : int             L1idx, l2x;             /* Table Indexes             */
; 4415 : CCKD64_L2ENT    l2;                     /* Copied level 2 entry      */
; 4416 : BYTE            buf[256*1024];          /* Buffer                    */
; 4417 : 
; 4418 :     if (!dev->cckd64)

  00049	48 8b 84 24 90
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  00051	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00058	24 01		 and	 al, 1
  0005a	0f b6 c0	 movzx	 eax, al
  0005d	85 c0		 test	 eax, eax
  0005f	75 1a		 jne	 SHORT $LN30@cckd64_gc_

; 4419 :         return cckd_gc_percolate( dev, size );

  00061	48 8b 94 24 98
	01 04 00	 mov	 rdx, QWORD PTR size$[rsp]
  00069	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00071	e8 00 00 00 00	 call	 cckd_gc_percolate
  00076	e9 ef 13 00 00	 jmp	 $LN1@cckd64_gc_
$LN30@cckd64_gc_:

; 4420 : 
; 4421 :     cckd = dev->cckd_ext;

  0007b	48 8b 84 24 90
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  00083	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0008a	48 89 44 24 70	 mov	 QWORD PTR cckd$[rsp], rax

; 4422 :     size = size << SHIFT_1K;

  0008f	48 8b 84 24 98
	01 04 00	 mov	 rax, QWORD PTR size$[rsp]
  00097	48 c1 e0 0a	 shl	 rax, 10
  0009b	48 89 84 24 98
	01 04 00	 mov	 QWORD PTR size$[rsp], rax

; 4423 : 
; 4424 :     if (cckd->cdevhdr[ cckd->sfn ].cdh_opts & CCKD_OPT_SPERRS)

  000a3	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  000a8	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  000ac	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000b3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  000b8	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  000c0	83 e0 20	 and	 eax, 32			; 00000020H
  000c3	85 c0		 test	 eax, eax
  000c5	0f 84 10 01 00
	00		 je	 $LN31@cckd64_gc_

; 4425 :     {
; 4426 :         // "Skipping garbage collection for CCKD%s file[%d] %1d:%04X %s due to space errors"
; 4427 :         if (cckdblk.gcmsgs)

  000cb	83 3d 4c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+588, 0
  000d2	0f 84 f7 00 00
	00		 je	 $LN32@cckd64_gc_

; 4428 :             WRMSG( HHC00385, "I", "64", cckd->sfn, LCSS_DEVNUM, cckd_sf_name( dev, cckd->sfn ));

  000d8	48 83 bc 24 90
	01 04 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000e1	74 15		 je	 SHORT $LN71@cckd64_gc_
  000e3	48 8b 84 24 90
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  000eb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000ef	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv91[rsp], eax
  000f6	eb 0b		 jmp	 SHORT $LN72@cckd64_gc_
$LN71@cckd64_gc_:
  000f8	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv91[rsp], 0
$LN72@cckd64_gc_:
  00103	48 83 bc 24 90
	01 04 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0010c	74 17		 je	 SHORT $LN73@cckd64_gc_
  0010e	48 8b 84 24 90
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  00116	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0011a	d1 f8		 sar	 eax, 1
  0011c	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv129[rsp], eax
  00123	eb 0b		 jmp	 SHORT $LN74@cckd64_gc_
$LN73@cckd64_gc_:
  00125	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv129[rsp], 0
$LN74@cckd64_gc_:
  00130	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00135	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00138	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00140	e8 00 00 00 00	 call	 cckd_sf_name
  00145	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv83[rsp], rax
  0014d	b9 01 00 00 00	 mov	 ecx, 1
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00158	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv83[rsp]
  00160	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00165	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv91[rsp]
  0016c	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00170	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv129[rsp]
  00177	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0017b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00180	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00183	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171951
  0018e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171952
  0019a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171953
  001a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b0	41 b9 03 00 00
	00		 mov	 r9d, 3
  001b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171954
  001bd	ba 4c 11 00 00	 mov	 edx, 4428		; 0000114cH
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171955
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN32@cckd64_gc_:

; 4429 :         return (int) moved;

  001cf	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR moved$[rsp]
  001d6	e9 8f 12 00 00	 jmp	 $LN1@cckd64_gc_
$LN31@cckd64_gc_:

; 4430 :     }
; 4431 : 
; 4432 :     /* Debug */
; 4433 :     OBTAIN_TRACE_LOCK();

  001db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171956
  001e2	48 8d 0d f0 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+752
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4434 :     if (cckdblk.itracen)

  001ef	83 3d 10 03 00
	00 00		 cmp	 DWORD PTR cckdblk+784, 0
  001f6	0f 84 0b 02 00
	00		 je	 $LN33@cckd64_gc_

; 4435 :     {
; 4436 :         RELEASE_TRACE_LOCK();

  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171959
  00203	48 8d 0d f0 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+752
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4437 : 
; 4438 :         CCKD_TRACE( "gcperc size %d 1st 0x%"PRIx64" nbr %"PRId64" largest %"PRIu64,

  00210	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00215	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00219	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00220	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00225	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  00229	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00230	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  00235	48 63 52 3c	 movsxd	 rdx, DWORD PTR [rdx+60]
  00239	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  00240	4c 8b 44 24 70	 mov	 r8, QWORD PTR cckd$[rsp]
  00245	49 8b 84 00 10
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+528]
  0024d	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00252	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00257	48 8b 84 08 18
	02 00 00	 mov	 rax, QWORD PTR [rax+rcx+536]
  0025f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00264	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00269	48 8b 84 10 00
	02 00 00	 mov	 rax, QWORD PTR [rax+rdx+512]
  00271	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00276	48 8b 84 24 98
	01 04 00	 mov	 rax, QWORD PTR size$[rsp]
  0027e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00283	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171960
  0028a	4c 8b 84 24 90
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  00292	ba 59 11 00 00	 mov	 edx, 4441		; 00001159H
  00297	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171961
  0029e	e8 00 00 00 00	 call	 cckd_trace

; 4439 :                     size, cckd->cdevhdr[cckd->sfn].free_off,
; 4440 :                     cckd->cdevhdr[cckd->sfn].free_num,
; 4441 :                     cckd->cdevhdr[cckd->sfn].free_largest);
; 4442 : 
; 4443 :         fpos = cckd->cdevhdr[cckd->sfn].free_off;

  002a3	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  002a8	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  002ac	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  002b3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  002b8	48 8b 84 01 00
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+512]
  002c0	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 4444 : 
; 4445 :         for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  002c8	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  002cd	48 63 40 7c	 movsxd	 rax, DWORD PTR [rax+124]
  002d1	48 89 44 24 78	 mov	 QWORD PTR i$[rsp], rax
  002d6	eb 19		 jmp	 SHORT $LN4@cckd64_gc_
$LN2@cckd64_gc_:
  002d8	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  002de	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  002e3	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  002e7	48 63 44 01 14	 movsxd	 rax, DWORD PTR [rcx+rax+20]
  002ec	48 89 44 24 78	 mov	 QWORD PTR i$[rsp], rax
$LN4@cckd64_gc_:
  002f1	48 83 7c 24 78
	00		 cmp	 QWORD PTR i$[rsp], 0
  002f7	0f 8c 08 01 00
	00		 jl	 $LN3@cckd64_gc_

; 4446 :         {
; 4447 :             CCKD_TRACE( "gcperc free[%4d]:%16.16"PRIx64" end %16.16"PRIx64" len %10"PRId64"%cpend %d",

  002fd	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  00303	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00308	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0030c	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00311	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR fpos$[rsp]
  00319	48 03 c8	 add	 rcx, rax
  0031c	48 8b c1	 mov	 rax, rcx
  0031f	48 6b 4c 24 78
	20		 imul	 rcx, QWORD PTR i$[rsp], 32 ; 00000020H
  00325	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  0032a	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0032e	48 3b 04 0a	 cmp	 rax, QWORD PTR [rdx+rcx]
  00332	75 0d		 jne	 SHORT $LN75@cckd64_gc_
  00334	c7 84 24 d0 00
	00 00 2a 00 00
	00		 mov	 DWORD PTR tv203[rsp], 42 ; 0000002aH
  0033f	eb 0b		 jmp	 SHORT $LN76@cckd64_gc_
$LN75@cckd64_gc_:
  00341	c7 84 24 d0 00
	00 00 20 00 00
	00		 mov	 DWORD PTR tv203[rsp], 32 ; 00000020H
$LN76@cckd64_gc_:
  0034c	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  00352	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00357	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0035b	48 6b 54 24 78
	20		 imul	 rdx, QWORD PTR i$[rsp], 32 ; 00000020H
  00361	4c 8b 44 24 70	 mov	 r8, QWORD PTR cckd$[rsp]
  00366	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0036a	4c 6b 4c 24 78
	20		 imul	 r9, QWORD PTR i$[rsp], 32 ; 00000020H
  00370	4c 8b 54 24 70	 mov	 r10, QWORD PTR cckd$[rsp]
  00375	4d 8b 52 70	 mov	 r10, QWORD PTR [r10+112]
  00379	4f 8b 4c 0a 08	 mov	 r9, QWORD PTR [r10+r9+8]
  0037e	4c 8b 94 24 b8
	00 00 00	 mov	 r10, QWORD PTR fpos$[rsp]
  00386	4d 03 d1	 add	 r10, r9
  00389	4d 8b ca	 mov	 r9, r10
  0038c	8b 44 01 18	 mov	 eax, DWORD PTR [rcx+rax+24]
  00390	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00394	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv203[rsp]
  0039b	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0039f	49 8b 44 10 08	 mov	 rax, QWORD PTR [r8+rdx+8]
  003a4	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  003a9	4c 89 4c 24 30	 mov	 QWORD PTR [rsp+48], r9
  003ae	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR fpos$[rsp]
  003b6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003bb	48 8b 44 24 78	 mov	 rax, QWORD PTR i$[rsp]
  003c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003c5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171962
  003cc	4c 8b 84 24 90
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  003d4	ba 62 11 00 00	 mov	 edx, 4450		; 00001162H
  003d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171963
  003e0	e8 00 00 00 00	 call	 cckd_trace

; 4448 :                         i, fpos, (fpos+cckd->ifb[i].ifb_len), cckd->ifb[i].ifb_len,
; 4449 :                         fpos+cckd->ifb[i].ifb_len == cckd->ifb[i].ifb_offnxt ?
; 4450 :                                 '*' : ' ', cckd->ifb[i].ifb_pending);
; 4451 : 
; 4452 :             fpos = cckd->ifb[i].ifb_offnxt;

  003e5	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  003eb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  003f0	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003f4	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  003f8	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 4453 :         }

  00400	e9 d3 fe ff ff	 jmp	 $LN2@cckd64_gc_
$LN3@cckd64_gc_:

; 4454 :     }

  00405	eb 14		 jmp	 SHORT $LN34@cckd64_gc_
$LN33@cckd64_gc_:

; 4455 :     else
; 4456 :         RELEASE_TRACE_LOCK();

  00407	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171964
  0040e	48 8d 0d f0 02
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+752
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN34@cckd64_gc_:

; 4457 : 
; 4458 :     if (!cckd->L2ok)

  0041b	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00420	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00423	c1 e8 08	 shr	 eax, 8
  00426	83 e0 01	 and	 eax, 1
  00429	85 c0		 test	 eax, eax
  0042b	75 15		 jne	 SHORT $LN35@cckd64_gc_

; 4459 :         cckd64_gc_l2(dev, buf);

  0042d	48 8d 94 24 70
	01 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00435	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0043d	e8 00 00 00 00	 call	 cckd64_gc_l2
$LN35@cckd64_gc_:
$LN5@cckd64_gc_:

; 4460 : 
; 4461 :     /* garbage collection cycle... */
; 4462 :     while (moved < size && after < 4)

  00442	48 8b 84 24 98
	01 04 00	 mov	 rax, QWORD PTR size$[rsp]
  0044a	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR moved$[rsp], rax
  00452	0f 83 8b 0e 00
	00		 jae	 $LN6@cckd64_gc_
  00458	48 83 bc 24 f8
	00 00 00 04	 cmp	 QWORD PTR after$[rsp], 4
  00461	0f 8d 7c 0e 00
	00		 jge	 $LN6@cckd64_gc_

; 4463 :     {
; 4464 :         obtain_lock( &cckd->filelock );

  00467	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0046c	48 83 c0 10	 add	 rax, 16
  00470	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171966
  00477	48 8b c8	 mov	 rcx, rax
  0047a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4465 :         sfx = cckd->sfn;

  00480	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00485	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00489	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR sfx$[rsp], rax

; 4466 : 
; 4467 :         /* Exit if no more free space */
; 4468 :         if (cckd->cdevhdr[sfx].free_total == 0)

  00491	48 69 84 24 88
	00 00 00 00 02
	00 00		 imul	 rax, QWORD PTR sfx$[rsp], 512 ; 00000200H
  0049d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  004a2	48 83 bc 01 08
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax+520], 0
  004ab	75 25		 jne	 SHORT $LN36@cckd64_gc_

; 4469 :         {
; 4470 :             release_lock( &cckd->filelock );

  004ad	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  004b2	48 83 c0 10	 add	 rax, 16
  004b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171968
  004bd	48 8b c8	 mov	 rcx, rax
  004c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4471 :             return (int) moved;

  004c6	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR moved$[rsp]
  004cd	e9 98 0f 00 00	 jmp	 $LN1@cckd64_gc_
$LN36@cckd64_gc_:

; 4472 :         }
; 4473 : 
; 4474 :         /* Make sure the free space chain is built */
; 4475 :         if (!cckd->ifb) cckd64_read_fsp (dev);

  004d2	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  004d7	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  004dc	75 0d		 jne	 SHORT $LN37@cckd64_gc_
  004de	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004e6	e8 00 00 00 00	 call	 cckd64_read_fsp
$LN37@cckd64_gc_:

; 4476 : 
; 4477 :         /* Find a space to start with */
; 4478 :         k = -1;

  004eb	48 c7 84 24 00
	01 00 00 ff ff
	ff ff		 mov	 QWORD PTR k$[rsp], -1

; 4479 :         upos = ulen = flen = 0;

  004f7	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR flen$[rsp], 0
  00503	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR flen$[rsp]
  0050b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ulen$[rsp], rax
  00513	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ulen$[rsp]
  0051b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR upos$[rsp], rax

; 4480 :         fpos = cckd->cdevhdr[sfx].free_off;

  00523	48 69 84 24 88
	00 00 00 00 02
	00 00		 imul	 rax, QWORD PTR sfx$[rsp], 512 ; 00000200H
  0052f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00534	48 8b 84 01 00
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+512]
  0053c	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 4481 : 
; 4482 :         /* First non-pending free space */
; 4483 :         for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  00544	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00549	48 63 40 7c	 movsxd	 rax, DWORD PTR [rax+124]
  0054d	48 89 44 24 78	 mov	 QWORD PTR i$[rsp], rax
  00552	eb 19		 jmp	 SHORT $LN9@cckd64_gc_
$LN7@cckd64_gc_:
  00554	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  0055a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  0055f	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00563	48 63 44 01 14	 movsxd	 rax, DWORD PTR [rcx+rax+20]
  00568	48 89 44 24 78	 mov	 QWORD PTR i$[rsp], rax
$LN9@cckd64_gc_:
  0056d	48 83 7c 24 78
	00		 cmp	 QWORD PTR i$[rsp], 0
  00573	7c 5f		 jl	 SHORT $LN8@cckd64_gc_

; 4484 :         {
; 4485 :             if (!cckd->ifb[i].ifb_pending)

  00575	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  0057b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00580	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00584	83 7c 01 18 00	 cmp	 DWORD PTR [rcx+rax+24], 0
  00589	75 2c		 jne	 SHORT $LN38@cckd64_gc_

; 4486 :             {
; 4487 :                 flen += cckd->ifb[i].ifb_len;

  0058b	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  00591	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00596	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0059a	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  0059f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR flen$[rsp]
  005a7	48 03 c8	 add	 rcx, rax
  005aa	48 8b c1	 mov	 rax, rcx
  005ad	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR flen$[rsp], rax

; 4488 :                 break;

  005b5	eb 1d		 jmp	 SHORT $LN8@cckd64_gc_
$LN38@cckd64_gc_:

; 4489 :             }
; 4490 :             fpos = cckd->ifb[i].ifb_offnxt;

  005b7	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  005bd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  005c2	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  005c6	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  005ca	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 4491 :         }

  005d2	eb 80		 jmp	 SHORT $LN7@cckd64_gc_
$LN8@cckd64_gc_:

; 4492 : 
; 4493 :         /* Continue to largest if non-zero `after' */
; 4494 :         for ( ; i >= 0 && after; i = cckd->ifb[i].ifb_idxnxt)

  005d4	eb 19		 jmp	 SHORT $LN12@cckd64_gc_
$LN10@cckd64_gc_:
  005d6	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  005dc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  005e1	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  005e5	48 63 44 01 14	 movsxd	 rax, DWORD PTR [rcx+rax+20]
  005ea	48 89 44 24 78	 mov	 QWORD PTR i$[rsp], rax
$LN12@cckd64_gc_:
  005ef	48 83 7c 24 78
	00		 cmp	 QWORD PTR i$[rsp], 0
  005f5	0f 8c ad 00 00
	00		 jl	 $LN11@cckd64_gc_
  005fb	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR after$[rsp], 0
  00604	0f 84 9e 00 00
	00		 je	 $LN11@cckd64_gc_

; 4495 :         {
; 4496 :             k = i;

  0060a	48 8b 44 24 78	 mov	 rax, QWORD PTR i$[rsp]
  0060f	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR k$[rsp], rax

; 4497 :             if (!cckd->ifb[i].ifb_pending) flen += cckd->ifb[i].ifb_len;

  00617	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  0061d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00622	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00626	83 7c 01 18 00	 cmp	 DWORD PTR [rcx+rax+24], 0
  0062b	75 2a		 jne	 SHORT $LN39@cckd64_gc_
  0062d	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  00633	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00638	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0063c	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00641	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR flen$[rsp]
  00649	48 03 c8	 add	 rcx, rax
  0064c	48 8b c1	 mov	 rax, rcx
  0064f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR flen$[rsp], rax
$LN39@cckd64_gc_:

; 4498 :             if (cckd->ifb[i].ifb_len == cckd->cdevhdr[sfx].free_largest)

  00657	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  0065d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00662	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00666	48 69 94 24 88
	00 00 00 00 02
	00 00		 imul	 rdx, QWORD PTR sfx$[rsp], 512 ; 00000200H
  00672	4c 8b 44 24 70	 mov	 r8, QWORD PTR cckd$[rsp]
  00677	49 8b 94 10 10
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+528]
  0067f	48 39 54 01 08	 cmp	 QWORD PTR [rcx+rax+8], rdx
  00684	75 02		 jne	 SHORT $LN40@cckd64_gc_

; 4499 :                 break;

  00686	eb 20		 jmp	 SHORT $LN11@cckd64_gc_
$LN40@cckd64_gc_:

; 4500 :             fpos = cckd->ifb[i].ifb_offnxt;

  00688	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  0068e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00693	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00697	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0069b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 4501 :         }

  006a3	e9 2e ff ff ff	 jmp	 $LN10@cckd64_gc_
$LN11@cckd64_gc_:

; 4502 : 
; 4503 :         /* Skip following free spaces */
; 4504 :         for ( ; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  006a8	eb 19		 jmp	 SHORT $LN15@cckd64_gc_
$LN13@cckd64_gc_:
  006aa	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  006b0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  006b5	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  006b9	48 63 44 01 14	 movsxd	 rax, DWORD PTR [rcx+rax+20]
  006be	48 89 44 24 78	 mov	 QWORD PTR i$[rsp], rax
$LN15@cckd64_gc_:
  006c3	48 83 7c 24 78
	00		 cmp	 QWORD PTR i$[rsp], 0
  006c9	0f 8c 99 00 00
	00		 jl	 $LN14@cckd64_gc_

; 4505 :         {
; 4506 :             if (!cckd->ifb[i].ifb_pending) flen += cckd->ifb[i].ifb_len;

  006cf	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  006d5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  006da	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  006de	83 7c 01 18 00	 cmp	 DWORD PTR [rcx+rax+24], 0
  006e3	75 2a		 jne	 SHORT $LN41@cckd64_gc_
  006e5	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  006eb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  006f0	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  006f4	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  006f9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR flen$[rsp]
  00701	48 03 c8	 add	 rcx, rax
  00704	48 8b c1	 mov	 rax, rcx
  00707	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR flen$[rsp], rax
$LN41@cckd64_gc_:

; 4507 :             if (fpos + cckd->ifb[i].ifb_len != cckd->ifb[i].ifb_offnxt) break;

  0070f	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  00715	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  0071a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0071e	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00723	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR fpos$[rsp]
  0072b	48 03 c8	 add	 rcx, rax
  0072e	48 8b c1	 mov	 rax, rcx
  00731	48 6b 4c 24 78
	20		 imul	 rcx, QWORD PTR i$[rsp], 32 ; 00000020H
  00737	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  0073c	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00740	48 3b 04 0a	 cmp	 rax, QWORD PTR [rdx+rcx]
  00744	74 02		 je	 SHORT $LN42@cckd64_gc_
  00746	eb 20		 jmp	 SHORT $LN14@cckd64_gc_
$LN42@cckd64_gc_:

; 4508 :             fpos = cckd->ifb[i].ifb_offnxt;

  00748	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  0074e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00753	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00757	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0075b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 4509 :         }

  00763	e9 42 ff ff ff	 jmp	 $LN13@cckd64_gc_
$LN14@cckd64_gc_:

; 4510 : 
; 4511 :         /* Space preceding largest if largest is at the end */
; 4512 :         if (i < 0 && k >= 0)

  00768	48 83 7c 24 78
	00		 cmp	 QWORD PTR i$[rsp], 0
  0076e	0f 8d 89 01 00
	00		 jge	 $LN43@cckd64_gc_
  00774	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR k$[rsp], 0
  0077d	0f 8c 7a 01 00
	00		 jl	 $LN43@cckd64_gc_

; 4513 :         {
; 4514 :             if (!cckd->ifb[k].ifb_pending) flen -= cckd->ifb[i].ifb_len;

  00783	48 6b 84 24 00
	01 00 00 20	 imul	 rax, QWORD PTR k$[rsp], 32 ; 00000020H
  0078c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00791	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00795	83 7c 01 18 00	 cmp	 DWORD PTR [rcx+rax+24], 0
  0079a	75 2a		 jne	 SHORT $LN44@cckd64_gc_
  0079c	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  007a2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  007a7	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  007ab	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  007b0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR flen$[rsp]
  007b8	48 2b c8	 sub	 rcx, rax
  007bb	48 8b c1	 mov	 rax, rcx
  007be	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR flen$[rsp], rax
$LN44@cckd64_gc_:

; 4515 :             for (i = cckd->ifb[k].ifb_idxprv; i >= 0; i = cckd->ifb[i].ifb_idxprv)

  007c6	48 6b 84 24 00
	01 00 00 20	 imul	 rax, QWORD PTR k$[rsp], 32 ; 00000020H
  007cf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  007d4	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  007d8	48 63 44 01 10	 movsxd	 rax, DWORD PTR [rcx+rax+16]
  007dd	48 89 44 24 78	 mov	 QWORD PTR i$[rsp], rax
  007e2	eb 19		 jmp	 SHORT $LN18@cckd64_gc_
$LN16@cckd64_gc_:
  007e4	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  007ea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  007ef	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  007f3	48 63 44 01 10	 movsxd	 rax, DWORD PTR [rcx+rax+16]
  007f8	48 89 44 24 78	 mov	 QWORD PTR i$[rsp], rax
$LN18@cckd64_gc_:
  007fd	48 83 7c 24 78
	00		 cmp	 QWORD PTR i$[rsp], 0
  00803	0f 8c f4 00 00
	00		 jl	 $LN17@cckd64_gc_

; 4516 :             {
; 4517 :                 fpos = cckd->ifb[i].ifb_idxprv >= 0

  00809	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  0080f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00814	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00818	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  0081d	7c 2f		 jl	 SHORT $LN77@cckd64_gc_
  0081f	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  00825	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  0082a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0082e	48 63 44 01 10	 movsxd	 rax, DWORD PTR [rcx+rax+16]
  00833	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00837	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  0083c	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00840	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00844	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv379[rsp], rax
  0084c	eb 21		 jmp	 SHORT $LN78@cckd64_gc_
$LN77@cckd64_gc_:
  0084e	48 69 84 24 88
	00 00 00 00 02
	00 00		 imul	 rax, QWORD PTR sfx$[rsp], 512 ; 00000200H
  0085a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  0085f	48 8b 84 01 00
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+512]
  00867	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv379[rsp], rax
$LN78@cckd64_gc_:
  0086f	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR tv379[rsp]
  00877	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 4518 :                      ? cckd->ifb[cckd->ifb[i].ifb_idxprv].ifb_offnxt
; 4519 :                      : cckd->cdevhdr[sfx].free_off;
; 4520 :                 if (fpos + cckd->ifb[i].ifb_len < cckd->ifb[i].ifb_offnxt) break;

  0087f	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  00885	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  0088a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0088e	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00893	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR fpos$[rsp]
  0089b	48 03 c8	 add	 rcx, rax
  0089e	48 8b c1	 mov	 rax, rcx
  008a1	48 6b 4c 24 78
	20		 imul	 rcx, QWORD PTR i$[rsp], 32 ; 00000020H
  008a7	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  008ac	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  008b0	48 3b 04 0a	 cmp	 rax, QWORD PTR [rdx+rcx]
  008b4	73 02		 jae	 SHORT $LN45@cckd64_gc_
  008b6	eb 45		 jmp	 SHORT $LN17@cckd64_gc_
$LN45@cckd64_gc_:

; 4521 :                 if (!cckd->ifb[i].ifb_pending) flen -= cckd->ifb[i].ifb_len;

  008b8	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  008be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  008c3	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  008c7	83 7c 01 18 00	 cmp	 DWORD PTR [rcx+rax+24], 0
  008cc	75 2a		 jne	 SHORT $LN46@cckd64_gc_
  008ce	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  008d4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  008d9	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  008dd	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  008e2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR flen$[rsp]
  008ea	48 2b c8	 sub	 rcx, rax
  008ed	48 8b c1	 mov	 rax, rcx
  008f0	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR flen$[rsp], rax
$LN46@cckd64_gc_:

; 4522 :             }

  008f8	e9 e7 fe ff ff	 jmp	 $LN16@cckd64_gc_
$LN17@cckd64_gc_:
$LN43@cckd64_gc_:

; 4523 :         }
; 4524 : 
; 4525 :         /* Calculate the offset/length of the used space.
; 4526 :          * If only imbedded free space is left, then start
; 4527 :          * with the first used space that is not an l2 table.
; 4528 :          */
; 4529 :         if (i >= 0)

  008fd	48 83 7c 24 78
	00		 cmp	 QWORD PTR i$[rsp], 0
  00903	0f 8c a1 00 00
	00		 jl	 $LN47@cckd64_gc_

; 4530 :         {
; 4531 :             upos = fpos + cckd->ifb[i].ifb_len;

  00909	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  0090f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00914	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00918	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  0091d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR fpos$[rsp]
  00925	48 03 c8	 add	 rcx, rax
  00928	48 8b c1	 mov	 rax, rcx
  0092b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR upos$[rsp], rax

; 4532 :             ulen = (cckd->ifb[i].ifb_offnxt ? cckd->ifb[i].ifb_offnxt : cckd->cdevhdr[sfx].cdh_size) - upos;

  00933	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  00939	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  0093e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00942	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00947	74 1d		 je	 SHORT $LN79@cckd64_gc_
  00949	48 6b 44 24 78
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  0094f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00954	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00958	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0095c	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv419[rsp], rax
  00964	eb 21		 jmp	 SHORT $LN80@cckd64_gc_
$LN79@cckd64_gc_:
  00966	48 69 84 24 88
	00 00 00 00 02
	00 00		 imul	 rax, QWORD PTR sfx$[rsp], 512 ; 00000200H
  00972	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00977	48 8b 84 01 f0
	01 00 00	 mov	 rax, QWORD PTR [rcx+rax+496]
  0097f	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv419[rsp], rax
$LN80@cckd64_gc_:
  00987	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR upos$[rsp]
  0098f	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv419[rsp]
  00997	48 2b c8	 sub	 rcx, rax
  0099a	48 8b c1	 mov	 rax, rcx
  0099d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ulen$[rsp], rax

; 4533 :         }

  009a5	e9 41 01 00 00	 jmp	 $LN48@cckd64_gc_
$LN47@cckd64_gc_:

; 4534 :         else if (!cckd->cdevhdr[sfx].free_num && cckd->cdevhdr[sfx].free_imbed)

  009aa	48 69 84 24 88
	00 00 00 00 02
	00 00		 imul	 rax, QWORD PTR sfx$[rsp], 512 ; 00000200H
  009b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  009bb	48 83 bc 01 18
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax+536], 0
  009c4	0f 85 21 01 00
	00		 jne	 $LN49@cckd64_gc_
  009ca	48 69 84 24 88
	00 00 00 00 02
	00 00		 imul	 rax, QWORD PTR sfx$[rsp], 512 ; 00000200H
  009d6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  009db	48 83 bc 01 20
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax+544], 0
  009e4	0f 84 01 01 00
	00		 je	 $LN49@cckd64_gc_

; 4535 :         {
; 4536 :             upos = (CCKD64_L1TAB_POS + cckd->cdevhdr[sfx].num_L1tab * CCKD64_L1ENT_SIZE);

  009ea	48 69 84 24 88
	00 00 00 00 02
	00 00		 imul	 rax, QWORD PTR sfx$[rsp], 512 ; 00000200H
  009f6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  009fb	48 63 84 01 e4
	01 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+484]
  00a03	48 8d 04 c5 00
	04 00 00	 lea	 rax, QWORD PTR [rax*8+1024]
  00a0b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR upos$[rsp], rax
$LN19@cckd64_gc_:

; 4537 :             while (1)

  00a13	33 c0		 xor	 eax, eax
  00a15	83 f8 01	 cmp	 eax, 1
  00a18	0f 84 a1 00 00
	00		 je	 $LN20@cckd64_gc_

; 4538 :             {
; 4539 :                 for (i = 0; i < cckd->cdevhdr[sfx].num_L1tab; i++)

  00a1e	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00a27	eb 0d		 jmp	 SHORT $LN23@cckd64_gc_
$LN21@cckd64_gc_:
  00a29	48 8b 44 24 78	 mov	 rax, QWORD PTR i$[rsp]
  00a2e	48 ff c0	 inc	 rax
  00a31	48 89 44 24 78	 mov	 QWORD PTR i$[rsp], rax
$LN23@cckd64_gc_:
  00a36	48 69 84 24 88
	00 00 00 00 02
	00 00		 imul	 rax, QWORD PTR sfx$[rsp], 512 ; 00000200H
  00a42	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00a47	48 63 84 01 e4
	01 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+484]
  00a4f	48 39 44 24 78	 cmp	 QWORD PTR i$[rsp], rax
  00a54	7d 2c		 jge	 SHORT $LN22@cckd64_gc_

; 4540 :                     if (cckd->L1tab[sfx][i] == upos)

  00a56	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00a5b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR sfx$[rsp]
  00a63	48 8b 84 c8 98
	01 00 00	 mov	 rax, QWORD PTR [rax+rcx*8+408]
  00a6b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i$[rsp]
  00a70	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR upos$[rsp]
  00a78	48 39 14 c8	 cmp	 QWORD PTR [rax+rcx*8], rdx
  00a7c	75 02		 jne	 SHORT $LN50@cckd64_gc_

; 4541 :                        break;

  00a7e	eb 02		 jmp	 SHORT $LN22@cckd64_gc_
$LN50@cckd64_gc_:
  00a80	eb a7		 jmp	 SHORT $LN21@cckd64_gc_
$LN22@cckd64_gc_:

; 4542 :                 if (i >= cckd->cdevhdr[sfx].num_L1tab)

  00a82	48 69 84 24 88
	00 00 00 00 02
	00 00		 imul	 rax, QWORD PTR sfx$[rsp], 512 ; 00000200H
  00a8e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00a93	48 63 84 01 e4
	01 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+484]
  00a9b	48 39 44 24 78	 cmp	 QWORD PTR i$[rsp], rax
  00aa0	7c 02		 jl	 SHORT $LN51@cckd64_gc_

; 4543 :                     break;

  00aa2	eb 1b		 jmp	 SHORT $LN20@cckd64_gc_
$LN51@cckd64_gc_:

; 4544 :                 upos += CCKD64_L2TAB_SIZE;

  00aa4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR upos$[rsp]
  00aac	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00ab2	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR upos$[rsp], rax

; 4545 :             }

  00aba	e9 54 ff ff ff	 jmp	 $LN19@cckd64_gc_
$LN20@cckd64_gc_:

; 4546 :             ulen = cckd->cdevhdr[sfx].cdh_size - upos;

  00abf	48 69 84 24 88
	00 00 00 00 02
	00 00		 imul	 rax, QWORD PTR sfx$[rsp], 512 ; 00000200H
  00acb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00ad0	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR upos$[rsp]
  00ad8	48 8b 84 01 f0
	01 00 00	 mov	 rax, QWORD PTR [rcx+rax+496]
  00ae0	48 2b c2	 sub	 rax, rdx
  00ae3	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ulen$[rsp], rax
$LN49@cckd64_gc_:
$LN48@cckd64_gc_:

; 4547 :         }
; 4548 : 
; 4549 :         /* Return if no applicable used space */
; 4550 :         if (ulen == 0)

  00aeb	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR ulen$[rsp], 0
  00af4	75 52		 jne	 SHORT $LN52@cckd64_gc_

; 4551 :         {
; 4552 :             CCKD_TRACE( "gcperc no applicable space, moved %"PRIu64, moved);

  00af6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR moved$[rsp]
  00afe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b03	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171985
  00b0a	4c 8b 84 24 90
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  00b12	ba c8 11 00 00	 mov	 edx, 4552		; 000011c8H
  00b17	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171986
  00b1e	e8 00 00 00 00	 call	 cckd_trace

; 4553 :             release_lock( &cckd->filelock );

  00b23	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00b28	48 83 c0 10	 add	 rax, 16
  00b2c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171987
  00b33	48 8b c8	 mov	 rcx, rax
  00b36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4554 :             return (int) moved;

  00b3c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR moved$[rsp]
  00b43	e9 22 09 00 00	 jmp	 $LN1@cckd64_gc_
$LN52@cckd64_gc_:

; 4555 :         }
; 4556 : 
; 4557 :         /* Reduce ulen size to minimize `after' relocations */
; 4558 :         if (ulen > flen + 65536) ulen = flen + 65536;

  00b48	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR flen$[rsp]
  00b50	48 05 00 00 01
	00		 add	 rax, 65536		; 00010000H
  00b56	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR ulen$[rsp], rax
  00b5e	76 16		 jbe	 SHORT $LN53@cckd64_gc_
  00b60	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR flen$[rsp]
  00b68	48 05 00 00 01
	00		 add	 rax, 65536		; 00010000H
  00b6e	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ulen$[rsp], rax
$LN53@cckd64_gc_:

; 4559 :         if (ulen > sizeof(buf))  ulen = sizeof(buf);

  00b76	48 81 bc 24 b0
	00 00 00 00 00
	04 00		 cmp	 QWORD PTR ulen$[rsp], 262144 ; 00040000H
  00b82	76 0c		 jbe	 SHORT $LN54@cckd64_gc_
  00b84	48 c7 84 24 b0
	00 00 00 00 00
	04 00		 mov	 QWORD PTR ulen$[rsp], 262144 ; 00040000H
$LN54@cckd64_gc_:

; 4560 : 
; 4561 :         CCKD_TRACE( "gcperc selected space 0x%16.16"PRIx64" len %"PRId64, upos, ulen);

  00b90	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ulen$[rsp]
  00b98	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00b9d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR upos$[rsp]
  00ba5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00baa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171990
  00bb1	4c 8b 84 24 90
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  00bb9	ba d1 11 00 00	 mov	 edx, 4561		; 000011d1H
  00bbe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171991
  00bc5	e8 00 00 00 00	 call	 cckd_trace

; 4562 : 
; 4563 :         if (cckd64_read (dev, (int) sfx, upos, buf, (unsigned int) ulen) < 0)

  00bca	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR ulen$[rsp]
  00bd1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00bd5	4c 8d 8c 24 70
	01 00 00	 lea	 r9, QWORD PTR buf$[rsp]
  00bdd	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR upos$[rsp]
  00be5	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  00bec	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bf4	e8 00 00 00 00	 call	 cckd64_read
  00bf9	85 c0		 test	 eax, eax
  00bfb	7d 2e		 jge	 SHORT $LN55@cckd64_gc_

; 4564 :             return GC64_PERC_ERROR();

  00bfd	c7 44 24 20 d4
	11 00 00	 mov	 DWORD PTR [rsp+32], 4564 ; 000011d4H
  00c05	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171993
  00c0c	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR moved$[rsp]
  00c14	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  00c19	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c21	e8 00 00 00 00	 call	 cckd64_gc_perc_error
  00c26	e9 3f 08 00 00	 jmp	 $LN1@cckd64_gc_
$LN55@cckd64_gc_:

; 4565 : 
; 4566 :         /* Process each space in the buffer */
; 4567 :         flags = cckd->cdevhdr[sfx].free_num < 100 ? CCKD_SIZE_EXACT : CCKD_SIZE_ANY;

  00c2b	48 69 84 24 88
	00 00 00 00 02
	00 00		 imul	 rax, QWORD PTR sfx$[rsp], 512 ; 00000200H
  00c37	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00c3c	48 83 bc 01 18
	02 00 00 64	 cmp	 QWORD PTR [rcx+rax+536], 100 ; 00000064H
  00c45	7d 0d		 jge	 SHORT $LN81@cckd64_gc_
  00c47	c7 84 24 d4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv501[rsp], 1
  00c52	eb 0b		 jmp	 SHORT $LN82@cckd64_gc_
$LN81@cckd64_gc_:
  00c54	c7 84 24 d4 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv501[rsp], 2
$LN82@cckd64_gc_:
  00c5f	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv501[rsp]
  00c66	89 84 24 10 01
	00 00		 mov	 DWORD PTR flags$[rsp], eax

; 4568 :         for (i = a = 0; (U64)i + CKD_TRKHDR_SIZE <= ulen; i += len)

  00c6d	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR a$[rsp], 0
  00c79	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00c81	48 89 44 24 78	 mov	 QWORD PTR i$[rsp], rax
  00c86	eb 18		 jmp	 SHORT $LN26@cckd64_gc_
$LN24@cckd64_gc_:
  00c88	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR len$[rsp]
  00c90	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i$[rsp]
  00c95	48 03 c8	 add	 rcx, rax
  00c98	48 8b c1	 mov	 rax, rcx
  00c9b	48 89 44 24 78	 mov	 QWORD PTR i$[rsp], rax
$LN26@cckd64_gc_:
  00ca0	48 8b 44 24 78	 mov	 rax, QWORD PTR i$[rsp]
  00ca5	48 83 c0 05	 add	 rax, 5
  00ca9	48 3b 84 24 b0
	00 00 00	 cmp	 rax, QWORD PTR ulen$[rsp]
  00cb1	0f 87 59 05 00
	00		 ja	 $LN25@cckd64_gc_

; 4569 :         {
; 4570 :             /* Check for level 2 table */
; 4571 :             for (j = 0; j < cckd->cdevhdr[sfx].num_L1tab; j++)

  00cb7	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR j$[rsp], 0
  00cc3	eb 13		 jmp	 SHORT $LN29@cckd64_gc_
$LN27@cckd64_gc_:
  00cc5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00ccd	48 ff c0	 inc	 rax
  00cd0	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR j$[rsp], rax
$LN29@cckd64_gc_:
  00cd8	48 69 84 24 88
	00 00 00 00 02
	00 00		 imul	 rax, QWORD PTR sfx$[rsp], 512 ; 00000200H
  00ce4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00ce9	48 63 84 01 e4
	01 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+484]
  00cf1	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR j$[rsp], rax
  00cf9	7d 3a		 jge	 SHORT $LN28@cckd64_gc_

; 4572 :                 if (cckd->L1tab[sfx][j] == (upos + i)) break;

  00cfb	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00d00	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR sfx$[rsp]
  00d08	48 8b 84 c8 98
	01 00 00	 mov	 rax, QWORD PTR [rax+rcx*8+408]
  00d10	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i$[rsp]
  00d15	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR upos$[rsp]
  00d1d	48 03 d1	 add	 rdx, rcx
  00d20	48 8b ca	 mov	 rcx, rdx
  00d23	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR j$[rsp]
  00d2b	48 39 0c d0	 cmp	 QWORD PTR [rax+rdx*8], rcx
  00d2f	75 02		 jne	 SHORT $LN56@cckd64_gc_
  00d31	eb 02		 jmp	 SHORT $LN28@cckd64_gc_
$LN56@cckd64_gc_:
  00d33	eb 90		 jmp	 SHORT $LN27@cckd64_gc_
$LN28@cckd64_gc_:

; 4573 : 
; 4574 :             if (!didmsg)

  00d35	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR didmsg$[rsp]
  00d3d	85 c0		 test	 eax, eax
  00d3f	0f 85 0c 01 00
	00		 jne	 $LN57@cckd64_gc_

; 4575 :             {
; 4576 :                 // "Collecting garbage for CCKD%s file[%d] %1d:%04X %s..."
; 4577 :                 if (cckdblk.gcmsgs)

  00d45	83 3d 4c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+588, 0
  00d4c	0f 84 f7 00 00
	00		 je	 $LN58@cckd64_gc_

; 4578 :                     WRMSG( HHC00384, "I", "64", cckd->sfn, LCSS_DEVNUM, cckd_sf_name( dev, cckd->sfn ));

  00d52	48 83 bc 24 90
	01 04 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d5b	74 15		 je	 SHORT $LN83@cckd64_gc_
  00d5d	48 8b 84 24 90
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d65	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00d69	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv530[rsp], eax
  00d70	eb 0b		 jmp	 SHORT $LN84@cckd64_gc_
$LN83@cckd64_gc_:
  00d72	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv530[rsp], 0
$LN84@cckd64_gc_:
  00d7d	48 83 bc 24 90
	01 04 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d86	74 17		 je	 SHORT $LN85@cckd64_gc_
  00d88	48 8b 84 24 90
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d90	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00d94	d1 f8		 sar	 eax, 1
  00d96	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv536[rsp], eax
  00d9d	eb 0b		 jmp	 SHORT $LN86@cckd64_gc_
$LN85@cckd64_gc_:
  00d9f	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv536[rsp], 0
$LN86@cckd64_gc_:
  00daa	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00daf	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00db2	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00dba	e8 00 00 00 00	 call	 cckd_sf_name
  00dbf	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv522[rsp], rax
  00dc7	b9 01 00 00 00	 mov	 ecx, 1
  00dcc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00dd2	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv522[rsp]
  00dda	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00ddf	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv530[rsp]
  00de6	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00dea	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv536[rsp]
  00df1	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00df5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00dfa	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00dfd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e01	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171997
  00e08	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e0d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171998
  00e14	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e19	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171999
  00e20	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e25	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e2a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e30	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172000
  00e37	ba e2 11 00 00	 mov	 edx, 4578		; 000011e2H
  00e3c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172001
  00e43	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN58@cckd64_gc_:

; 4579 :                 didmsg = true;

  00e49	c6 84 24 80 00
	00 00 01	 mov	 BYTE PTR didmsg$[rsp], 1
$LN57@cckd64_gc_:

; 4580 :             }
; 4581 : 
; 4582 :             if (j < cckd->cdevhdr[sfx].num_L1tab)

  00e51	48 69 84 24 88
	00 00 00 00 02
	00 00		 imul	 rax, QWORD PTR sfx$[rsp], 512 ; 00000200H
  00e5d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00e62	48 63 84 01 e4
	01 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+484]
  00e6a	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR j$[rsp], rax
  00e72	0f 8d 12 01 00
	00		 jge	 $LN59@cckd64_gc_

; 4583 :             {
; 4584 :                 /* Moving a level 2 table */
; 4585 :                 len = CCKD64_L2TAB_SIZE;

  00e78	48 c7 84 24 08
	01 00 00 00 10
	00 00		 mov	 QWORD PTR len$[rsp], 4096 ; 00001000H

; 4586 :                 if (i + len > ulen) break;

  00e84	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR len$[rsp]
  00e8c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i$[rsp]
  00e91	48 03 c8	 add	 rcx, rax
  00e94	48 8b c1	 mov	 rax, rcx
  00e97	48 3b 84 24 b0
	00 00 00	 cmp	 rax, QWORD PTR ulen$[rsp]
  00e9f	76 05		 jbe	 SHORT $LN61@cckd64_gc_
  00ea1	e9 6a 03 00 00	 jmp	 $LN25@cckd64_gc_
$LN61@cckd64_gc_:

; 4587 :                 CCKD_TRACE( "gcperc move l2tab[%"PRId64"] at pos 0x%16.16"PRIx64" len %"PRId64,

  00ea6	48 8b 44 24 78	 mov	 rax, QWORD PTR i$[rsp]
  00eab	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR upos$[rsp]
  00eb3	48 03 c8	 add	 rcx, rax
  00eb6	48 8b c1	 mov	 rax, rcx
  00eb9	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  00ec1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ec6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00ecb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00ed3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ed8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172005
  00edf	4c 8b 84 24 90
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  00ee7	ba ec 11 00 00	 mov	 edx, 4588		; 000011ecH
  00eec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172006
  00ef3	e8 00 00 00 00	 call	 cckd_trace

; 4588 :                             j, upos + i, len);
; 4589 : 
; 4590 :                 /* Make the level 2 table active */
; 4591 :                 if (cckd64_read_l2 (dev, (int)sfx, (int)j) < 0)

  00ef8	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR j$[rsp]
  00f00	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  00f07	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f0f	e8 00 00 00 00	 call	 cckd64_read_l2
  00f14	85 c0		 test	 eax, eax
  00f16	7d 2e		 jge	 SHORT $LN62@cckd64_gc_

; 4592 :                     return GC64_PERC_ERROR();

  00f18	c7 44 24 20 f0
	11 00 00	 mov	 DWORD PTR [rsp+32], 4592 ; 000011f0H
  00f20	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172008
  00f27	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR moved$[rsp]
  00f2f	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  00f34	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f3c	e8 00 00 00 00	 call	 cckd64_gc_perc_error
  00f41	e9 24 05 00 00	 jmp	 $LN1@cckd64_gc_
$LN62@cckd64_gc_:

; 4593 : 
; 4594 :                 /* Write the level 2 table */
; 4595 :                 if (cckd64_write_l2 (dev) < 0)

  00f46	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f4e	e8 00 00 00 00	 call	 cckd64_write_l2
  00f53	85 c0		 test	 eax, eax
  00f55	7d 2e		 jge	 SHORT $LN63@cckd64_gc_

; 4596 :                     return GC64_PERC_ERROR();

  00f57	c7 44 24 20 f4
	11 00 00	 mov	 DWORD PTR [rsp+32], 4596 ; 000011f4H
  00f5f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172010
  00f66	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR moved$[rsp]
  00f6e	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  00f73	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f7b	e8 00 00 00 00	 call	 cckd64_gc_perc_error
  00f80	e9 e5 04 00 00	 jmp	 $LN1@cckd64_gc_
$LN63@cckd64_gc_:

; 4597 :             }

  00f85	e9 81 02 00 00	 jmp	 $LN60@cckd64_gc_
$LN59@cckd64_gc_:

; 4598 :             else
; 4599 :             {
; 4600 :                 /* Moving a track image */
; 4601 :                 if ((trk = cckd64_cchh (dev, buf + i, -1)) < 0)

  00f8a	48 8b 44 24 78	 mov	 rax, QWORD PTR i$[rsp]
  00f8f	48 8d 84 04 70
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  00f97	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00f9d	48 8b d0	 mov	 rdx, rax
  00fa0	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fa8	e8 00 00 00 00	 call	 cckd64_cchh
  00fad	89 84 24 a0 00
	00 00		 mov	 DWORD PTR trk$[rsp], eax
  00fb4	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR trk$[rsp], 0
  00fbc	7d 52		 jge	 SHORT $LN64@cckd64_gc_

; 4602 :                     return GC64_PERC_SPACE_ERROR();

  00fbe	c7 44 24 38 fa
	11 00 00	 mov	 DWORD PTR [rsp+56], 4602 ; 000011faH
  00fc6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172012
  00fcd	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00fd2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR moved$[rsp]
  00fda	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00fdf	48 8d 84 24 70
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00fe7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fec	4c 8b 4c 24 78	 mov	 r9, QWORD PTR i$[rsp]
  00ff1	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR upos$[rsp]
  00ff9	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  00ffe	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01006	e8 00 00 00 00	 call	 cckd64_gc_perc_space_error
  0100b	e9 5a 04 00 00	 jmp	 $LN1@cckd64_gc_
$LN64@cckd64_gc_:

; 4603 : 
; 4604 :                 L1idx = trk >> 8;

  01010	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  01017	c1 f8 08	 sar	 eax, 8
  0101a	89 84 24 38 01
	00 00		 mov	 DWORD PTR L1idx$[rsp], eax

; 4605 :                 l2x = trk & 0xff;

  01021	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  01028	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0102d	89 84 24 3c 01
	00 00		 mov	 DWORD PTR l2x$[rsp], eax

; 4606 : 
; 4607 :                 /* Read the lookup entry for the track */
; 4608 :                 if (cckd64_read_l2ent (dev, &l2, trk) < 0)

  01034	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  0103c	48 8d 94 24 58
	01 00 00	 lea	 rdx, QWORD PTR l2$[rsp]
  01044	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0104c	e8 00 00 00 00	 call	 cckd64_read_l2ent
  01051	85 c0		 test	 eax, eax
  01053	7d 2e		 jge	 SHORT $LN65@cckd64_gc_

; 4609 :                     return GC64_PERC_ERROR();

  01055	c7 44 24 20 01
	12 00 00	 mov	 DWORD PTR [rsp+32], 4609 ; 00001201H
  0105d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172014
  01064	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR moved$[rsp]
  0106c	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  01071	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01079	e8 00 00 00 00	 call	 cckd64_gc_perc_error
  0107e	e9 e7 03 00 00	 jmp	 $LN1@cckd64_gc_
$LN65@cckd64_gc_:

; 4610 :                 if (l2.L2_trkoff != (upos + i))

  01083	48 8b 44 24 78	 mov	 rax, QWORD PTR i$[rsp]
  01088	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR upos$[rsp]
  01090	48 03 c8	 add	 rcx, rax
  01093	48 8b c1	 mov	 rax, rcx
  01096	48 39 84 24 58
	01 00 00	 cmp	 QWORD PTR l2$[rsp], rax
  0109e	74 52		 je	 SHORT $LN66@cckd64_gc_

; 4611 :                     return GC64_PERC_SPACE_ERROR();

  010a0	c7 44 24 38 03
	12 00 00	 mov	 DWORD PTR [rsp+56], 4611 ; 00001203H
  010a8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172016
  010af	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  010b4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR moved$[rsp]
  010bc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  010c1	48 8d 84 24 70
	01 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  010c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010ce	4c 8b 4c 24 78	 mov	 r9, QWORD PTR i$[rsp]
  010d3	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR upos$[rsp]
  010db	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  010e0	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010e8	e8 00 00 00 00	 call	 cckd64_gc_perc_space_error
  010ed	e9 78 03 00 00	 jmp	 $LN1@cckd64_gc_
$LN66@cckd64_gc_:

; 4612 :                 len = l2.L2_size;

  010f2	0f b7 84 24 62
	01 00 00	 movzx	 eax, WORD PTR l2$[rsp+10]
  010fa	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR len$[rsp], rax

; 4613 :                 if ((U64)i + l2.L2_len > ulen) break;

  01102	0f b7 84 24 60
	01 00 00	 movzx	 eax, WORD PTR l2$[rsp+8]
  0110a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i$[rsp]
  0110f	48 03 c8	 add	 rcx, rax
  01112	48 8b c1	 mov	 rax, rcx
  01115	48 3b 84 24 b0
	00 00 00	 cmp	 rax, QWORD PTR ulen$[rsp]
  0111d	76 05		 jbe	 SHORT $LN67@cckd64_gc_
  0111f	e9 ec 00 00 00	 jmp	 $LN25@cckd64_gc_
$LN67@cckd64_gc_:

; 4614 : 
; 4615 :                 CCKD_TRACE( "gcperc move trk %d at pos 0x%16.16"PRIx64" len %hu",

  01124	0f b7 84 24 60
	01 00 00	 movzx	 eax, WORD PTR l2$[rsp+8]
  0112c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i$[rsp]
  01131	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR upos$[rsp]
  01139	48 03 d1	 add	 rdx, rcx
  0113c	48 8b ca	 mov	 rcx, rdx
  0113f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  01143	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01148	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0114f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01153	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172018
  0115a	4c 8b 84 24 90
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  01162	ba 08 12 00 00	 mov	 edx, 4616		; 00001208H
  01167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172019
  0116e	e8 00 00 00 00	 call	 cckd_trace

; 4616 :                             trk, upos + i, l2.L2_len);
; 4617 : 
; 4618 :                 /* Relocate the track image somewhere else */
; 4619 :                 if ((rc = cckd64_write_trkimg (dev, buf + i, (int)l2.L2_len, trk, flags)) < 0)

  01173	0f b7 84 24 60
	01 00 00	 movzx	 eax, WORD PTR l2$[rsp+8]
  0117b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i$[rsp]
  01180	48 8d 8c 0c 70
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rcx]
  01188	8b 94 24 10 01
	00 00		 mov	 edx, DWORD PTR flags$[rsp]
  0118f	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  01193	44 8b 8c 24 a0
	00 00 00	 mov	 r9d, DWORD PTR trk$[rsp]
  0119b	44 8b c0	 mov	 r8d, eax
  0119e	48 8b d1	 mov	 rdx, rcx
  011a1	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011a9	e8 00 00 00 00	 call	 cckd64_write_trkimg
  011ae	89 84 24 e0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  011b5	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  011bd	7d 2e		 jge	 SHORT $LN68@cckd64_gc_

; 4620 :                     return GC64_PERC_ERROR();

  011bf	c7 44 24 20 0c
	12 00 00	 mov	 DWORD PTR [rsp+32], 4620 ; 0000120cH
  011c7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172021
  011ce	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR moved$[rsp]
  011d6	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  011db	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011e3	e8 00 00 00 00	 call	 cckd64_gc_perc_error
  011e8	e9 7d 02 00 00	 jmp	 $LN1@cckd64_gc_
$LN68@cckd64_gc_:

; 4621 :                 a += rc;

  011ed	48 63 84 24 e0
	00 00 00	 movsxd	 rax, DWORD PTR rc$[rsp]
  011f5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  011fd	48 03 c8	 add	 rcx, rax
  01200	48 8b c1	 mov	 rax, rcx
  01203	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR a$[rsp], rax
$LN60@cckd64_gc_:

; 4622 :             }
; 4623 :         } /* for each space in the used space */

  0120b	e9 78 fa ff ff	 jmp	 $LN24@cckd64_gc_
$LN25@cckd64_gc_:

; 4624 : 
; 4625 :         /* Set `after' to 1 if first time space was relocated after */
; 4626 :         after += after ? a : (a > 0);

  01210	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR after$[rsp], 0
  01219	74 12		 je	 SHORT $LN89@cckd64_gc_
  0121b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  01223	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv722[rsp], rax
  0122b	eb 35		 jmp	 SHORT $LN90@cckd64_gc_
$LN89@cckd64_gc_:
  0122d	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR a$[rsp], 0
  01236	7e 0e		 jle	 SHORT $LN87@cckd64_gc_
  01238	48 c7 84 24 28
	01 00 00 01 00
	00 00		 mov	 QWORD PTR tv720[rsp], 1
  01244	eb 0c		 jmp	 SHORT $LN88@cckd64_gc_
$LN87@cckd64_gc_:
  01246	48 c7 84 24 28
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv720[rsp], 0
$LN88@cckd64_gc_:
  01252	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR tv720[rsp]
  0125a	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv722[rsp], rax
$LN90@cckd64_gc_:
  01262	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tv722[rsp]
  0126a	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR after$[rsp]
  01272	48 03 c8	 add	 rcx, rax
  01275	48 8b c1	 mov	 rax, rcx
  01278	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR after$[rsp], rax

; 4627 :         moved += i;

  01280	48 8b 44 24 78	 mov	 rax, QWORD PTR i$[rsp]
  01285	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR moved$[rsp]
  0128d	48 03 c8	 add	 rcx, rax
  01290	48 8b c1	 mov	 rax, rcx
  01293	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR moved$[rsp], rax

; 4628 : 
; 4629 :         cckdblk.stats_gcolmoves++;

  0129b	48 8b 05 e0 02
	00 00		 mov	 rax, QWORD PTR cckdblk+736
  012a2	48 ff c0	 inc	 rax
  012a5	48 89 05 e0 02
	00 00		 mov	 QWORD PTR cckdblk+736, rax

; 4630 :         cckdblk.stats_gcolbytes += i;

  012ac	48 8b 44 24 78	 mov	 rax, QWORD PTR i$[rsp]
  012b1	48 8b 0d e8 02
	00 00		 mov	 rcx, QWORD PTR cckdblk+744
  012b8	48 03 c8	 add	 rcx, rax
  012bb	48 8b c1	 mov	 rax, rcx
  012be	48 89 05 e8 02
	00 00		 mov	 QWORD PTR cckdblk+744, rax

; 4631 : 
; 4632 :         release_lock( &cckd->filelock );

  012c5	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  012ca	48 83 c0 10	 add	 rax, 16
  012ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172022
  012d5	48 8b c8	 mov	 rcx, rax
  012d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4633 : 
; 4634 :     } /* while (moved < size) */

  012de	e9 5f f1 ff ff	 jmp	 $LN5@cckd64_gc_
$LN6@cckd64_gc_:

; 4635 : 
; 4636 :     CCKD_TRACE( "gcperc moved %d 1st 0x%"PRIx64" nbr %"PRIu64, moved,

  012e3	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  012e8	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  012ec	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  012f3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  012f8	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  012fc	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  01303	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  01308	48 8b 84 02 18
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax+536]
  01310	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  01315	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0131a	48 8b 84 08 00
	02 00 00	 mov	 rax, QWORD PTR [rax+rcx+512]
  01322	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01327	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR moved$[rsp]
  0132f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01334	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172023
  0133b	4c 8b 84 24 90
	01 04 00	 mov	 r8, QWORD PTR dev$[rsp]
  01343	ba 1d 12 00 00	 mov	 edx, 4637		; 0000121dH
  01348	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172024
  0134f	e8 00 00 00 00	 call	 cckd_trace

; 4637 :                 cckd->cdevhdr[cckd->sfn].free_off, cckd->cdevhdr[cckd->sfn].free_num);
; 4638 :     // "Collected %u bytes of garbage for CCKD%s file[%d] %1d:%04X %s..."
; 4639 :     if (cckdblk.gcmsgs)

  01354	83 3d 4c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+588, 0
  0135b	0f 84 02 01 00
	00		 je	 $LN69@cckd64_gc_

; 4640 :         WRMSG( HHC00386, "I", (unsigned int) moved, "64", cckd->sfn, LCSS_DEVNUM, cckd_sf_name( dev, cckd->sfn ));

  01361	48 83 bc 24 90
	01 04 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0136a	74 15		 je	 SHORT $LN91@cckd64_gc_
  0136c	48 8b 84 24 90
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  01374	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01378	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv758[rsp], eax
  0137f	eb 0b		 jmp	 SHORT $LN92@cckd64_gc_
$LN91@cckd64_gc_:
  01381	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv758[rsp], 0
$LN92@cckd64_gc_:
  0138c	48 83 bc 24 90
	01 04 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01395	74 17		 je	 SHORT $LN93@cckd64_gc_
  01397	48 8b 84 24 90
	01 04 00	 mov	 rax, QWORD PTR dev$[rsp]
  0139f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  013a3	d1 f8		 sar	 eax, 1
  013a5	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv764[rsp], eax
  013ac	eb 0b		 jmp	 SHORT $LN94@cckd64_gc_
$LN93@cckd64_gc_:
  013ae	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv764[rsp], 0
$LN94@cckd64_gc_:
  013b9	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  013be	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  013c1	48 8b 8c 24 90
	01 04 00	 mov	 rcx, QWORD PTR dev$[rsp]
  013c9	e8 00 00 00 00	 call	 cckd_sf_name
  013ce	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv750[rsp], rax
  013d6	b9 01 00 00 00	 mov	 ecx, 1
  013db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013e1	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv750[rsp]
  013e9	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  013ee	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv758[rsp]
  013f5	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  013f9	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv764[rsp]
  01400	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01404	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  01409	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  0140c	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01410	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172026
  01417	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0141c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR moved$[rsp]
  01423	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01427	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172027
  0142e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01433	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172028
  0143a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0143f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01444	41 b9 03 00 00
	00		 mov	 r9d, 3
  0144a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172029
  01451	ba 20 12 00 00	 mov	 edx, 4640		; 00001220H
  01456	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172030
  0145d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN69@cckd64_gc_:

; 4641 :     return (int) moved;

  01463	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR moved$[rsp]
$LN1@cckd64_gc_:

; 4642 : } /* end function cckd64_gc_percolate */

  0146a	48 8b 8c 24 70
	01 04 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01472	48 33 cc	 xor	 rcx, rsp
  01475	e8 00 00 00 00	 call	 __security_check_cookie
  0147a	48 81 c4 88 01
	04 00		 add	 rsp, 262536		; 00040188H
  01481	c3		 ret	 0
cckd64_gc_percolate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
tv74 = 96
tv86 = 100
tv92 = 104
tv146 = 108
tv152 = 112
tv174 = 116
tv180 = 120
cckd$ = 128
gc$ = 136
tv75 = 144
tv135 = 152
tv163 = 160
dev$ = 192
cckd64_gc_rpt_state PROC

; 4182 : {

$LN24:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 4183 :     CCKD64_EXT*  cckd;
; 4184 :     int          gc;
; 4185 : 
; 4186 :     if (!dev->cckd64)

  0000c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00014	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0001b	24 01		 and	 al, 1
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	75 12		 jne	 SHORT $LN4@cckd64_gc_

; 4187 :     {
; 4188 :         cckd_gc_rpt_state( dev );

  00024	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 cckd_gc_rpt_state

; 4189 :         return;

  00031	e9 32 03 00 00	 jmp	 $LN1@cckd64_gc_
$LN4@cckd64_gc_:

; 4190 :     }
; 4191 : 
; 4192 :     cckd = dev->cckd_ext;

  00036	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003e	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00045	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 4193 : 
; 4194 :     /* Retrieve and report garbage collector state, but ONLY if
; 4195 :        the image is over 100MB in size. This prevents "scaring"
; 4196 :        the user about SEVERELY fragmented files when the file
; 4197 :        is too small to be much of a concern, as is usually the
; 4198 :        case with e.g. shadow files.
; 4199 :     */
; 4200 :     if (cckd->cdevhdr->cdh_size < (100 * _1M))

  0004d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00055	48 81 b8 f0 01
	00 00 00 00 40
	06		 cmp	 QWORD PTR [rax+496], 104857600 ; 06400000H
  00060	73 05		 jae	 SHORT $LN5@cckd64_gc_

; 4201 :         return;

  00062	e9 01 03 00 00	 jmp	 $LN1@cckd64_gc_
$LN5@cckd64_gc_:

; 4202 : 
; 4203 :     gc = cckd_gc_state( dev );

  00067	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0006f	e8 00 00 00 00	 call	 cckd_gc_state
  00074	89 84 24 88 00
	00 00		 mov	 DWORD PTR gc$[rsp], eax

; 4204 : 
; 4205 :     switch (gc)

  0007b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR gc$[rsp]
  00082	89 44 24 60	 mov	 DWORD PTR tv74[rsp], eax
  00086	83 7c 24 60 00	 cmp	 DWORD PTR tv74[rsp], 0
  0008b	74 22		 je	 SHORT $LN6@cckd64_gc_
  0008d	83 7c 24 60 01	 cmp	 DWORD PTR tv74[rsp], 1
  00092	74 1b		 je	 SHORT $LN7@cckd64_gc_
  00094	83 7c 24 60 02	 cmp	 DWORD PTR tv74[rsp], 2
  00099	0f 84 fa 00 00
	00		 je	 $LN8@cckd64_gc_
  0009f	83 7c 24 60 03	 cmp	 DWORD PTR tv74[rsp], 3
  000a4	0f 84 d9 01 00
	00		 je	 $LN9@cckd64_gc_
  000aa	e9 b9 02 00 00	 jmp	 $LN10@cckd64_gc_
$LN6@cckd64_gc_:
$LN7@cckd64_gc_:

; 4206 :     {
; 4207 :         case 0:     // critical!
; 4208 :         case 1:     // severe
; 4209 : 
; 4210 :             // "%1d:%04X CCKD%s image %s is SEVERELY fragmented!"
; 4211 :             WRMSG( HHC00387, "W", LCSS_DEVNUM, "64",

  000af	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000b8	74 12		 je	 SHORT $LN12@cckd64_gc_
  000ba	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000c6	89 44 24 64	 mov	 DWORD PTR tv86[rsp], eax
  000ca	eb 08		 jmp	 SHORT $LN13@cckd64_gc_
$LN12@cckd64_gc_:
  000cc	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN13@cckd64_gc_:
  000d4	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000dd	74 14		 je	 SHORT $LN14@cckd64_gc_
  000df	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000eb	d1 f8		 sar	 eax, 1
  000ed	89 44 24 68	 mov	 DWORD PTR tv92[rsp], eax
  000f1	eb 08		 jmp	 SHORT $LN15@cckd64_gc_
$LN14@cckd64_gc_:
  000f3	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN15@cckd64_gc_:
  000fb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00103	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00106	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0010e	e8 00 00 00 00	 call	 cckd_sf_name
  00113	48 8b c8	 mov	 rcx, rax
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trimloc
  0011c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  00124	b9 01 00 00 00	 mov	 ecx, 1
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv75[rsp]
  00137	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171755
  00143	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00148	8b 4c 24 64	 mov	 ecx, DWORD PTR tv86[rsp]
  0014c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00150	8b 4c 24 68	 mov	 ecx, DWORD PTR tv92[rsp]
  00154	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171756
  0015f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171757
  0016b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00170	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00175	41 b9 03 00 00
	00		 mov	 r9d, 3
  0017b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171758
  00182	ba 74 10 00 00	 mov	 edx, 4212		; 00001074H
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171759
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4212 :                 TRIMLOC( cckd_sf_name( dev, cckd->sfn )));
; 4213 :             break;

  00194	e9 cf 01 00 00	 jmp	 $LN2@cckd64_gc_
$LN8@cckd64_gc_:

; 4214 : 
; 4215 :         case 2:     // moderate
; 4216 : 
; 4217 :             // "%1d:%04X CCKD%s image %s is moderately fragmented"
; 4218 :             WRMSG( HHC00388, "W", LCSS_DEVNUM, "64",

  00199	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001a2	74 12		 je	 SHORT $LN16@cckd64_gc_
  001a4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ac	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001b0	89 44 24 6c	 mov	 DWORD PTR tv146[rsp], eax
  001b4	eb 08		 jmp	 SHORT $LN17@cckd64_gc_
$LN16@cckd64_gc_:
  001b6	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv146[rsp], 0
$LN17@cckd64_gc_:
  001be	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001c7	74 14		 je	 SHORT $LN18@cckd64_gc_
  001c9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d1	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001d5	d1 f8		 sar	 eax, 1
  001d7	89 44 24 70	 mov	 DWORD PTR tv152[rsp], eax
  001db	eb 08		 jmp	 SHORT $LN19@cckd64_gc_
$LN18@cckd64_gc_:
  001dd	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN19@cckd64_gc_:
  001e5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  001ed	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  001f0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f8	e8 00 00 00 00	 call	 cckd_sf_name
  001fd	48 8b c8	 mov	 rcx, rax
  00200	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trimloc
  00206	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv135[rsp], rax
  0020e	b9 01 00 00 00	 mov	 ecx, 1
  00213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00219	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv135[rsp]
  00221	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171761
  0022d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00232	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv146[rsp]
  00236	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0023a	8b 4c 24 70	 mov	 ecx, DWORD PTR tv152[rsp]
  0023e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00242	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171762
  00249	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0024e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171763
  00255	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0025a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00265	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171764
  0026c	ba 7b 10 00 00	 mov	 edx, 4219		; 0000107bH
  00271	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171765
  00278	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4219 :                 TRIMLOC( cckd_sf_name( dev, cckd->sfn )));
; 4220 :             break;

  0027e	e9 e5 00 00 00	 jmp	 $LN2@cckd64_gc_
$LN9@cckd64_gc_:

; 4221 : 
; 4222 :         case 3:     // light
; 4223 : 
; 4224 :             // "%1d:%04X CCKD%s image %s is slightly fragmented"
; 4225 :             WRMSG( HHC00389, "I", LCSS_DEVNUM, "64",

  00283	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0028c	74 12		 je	 SHORT $LN20@cckd64_gc_
  0028e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00296	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0029a	89 44 24 74	 mov	 DWORD PTR tv174[rsp], eax
  0029e	eb 08		 jmp	 SHORT $LN21@cckd64_gc_
$LN20@cckd64_gc_:
  002a0	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN21@cckd64_gc_:
  002a8	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002b1	74 14		 je	 SHORT $LN22@cckd64_gc_
  002b3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002bb	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002bf	d1 f8		 sar	 eax, 1
  002c1	89 44 24 78	 mov	 DWORD PTR tv180[rsp], eax
  002c5	eb 08		 jmp	 SHORT $LN23@cckd64_gc_
$LN22@cckd64_gc_:
  002c7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN23@cckd64_gc_:
  002cf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  002d7	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  002da	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e2	e8 00 00 00 00	 call	 cckd_sf_name
  002e7	48 8b c8	 mov	 rcx, rax
  002ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trimloc
  002f0	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv163[rsp], rax
  002f8	b9 01 00 00 00	 mov	 ecx, 1
  002fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00303	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv163[rsp]
  0030b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00310	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171767
  00317	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0031c	8b 4c 24 74	 mov	 ecx, DWORD PTR tv174[rsp]
  00320	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00324	8b 4c 24 78	 mov	 ecx, DWORD PTR tv180[rsp]
  00328	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171768
  00333	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00338	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171769
  0033f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00344	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00349	41 b9 03 00 00
	00		 mov	 r9d, 3
  0034f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171770
  00356	ba 82 10 00 00	 mov	 edx, 4226		; 00001082H
  0035b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171771
  00362	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@cckd64_gc_:
$LN2@cckd64_gc_:
$LN1@cckd64_gc_:

; 4226 :                 TRIMLOC( cckd_sf_name( dev, cckd->sfn )));
; 4227 :             break;
; 4228 : 
; 4229 :         default:    // less than light
; 4230 : 
; 4231 :             break;  // (don't bother reporting it)
; 4232 :     }
; 4233 : }

  00368	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0036f	c3		 ret	 0
cckd64_gc_rpt_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
gc$ = 32
size$ = 40
cckd$ = 48
fsiz$ = 56
dev$ = 80
cckd64_gc_state PROC

; 4239 : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4240 :     CCKD64_EXT*  cckd;                  /* -> cckd extension         */
; 4241 :     S64          size, fsiz;            /* File size, free size      */
; 4242 :     int          gc;                    /* Garbage collection state  */
; 4243 : 
; 4244 :     if (!dev->cckd64)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 0f		 jne	 SHORT $LN2@cckd64_gc_

; 4245 :         return cckd_gc_state( dev );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd_gc_state
  00028	e9 97 01 00 00	 jmp	 $LN1@cckd64_gc_
$LN2@cckd64_gc_:

; 4246 : 
; 4247 :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 30	 mov	 QWORD PTR cckd$[rsp], rax

; 4248 : 
; 4249 :     /* Determine garbage state */
; 4250 :     size = (S64) cckd->cdevhdr[ cckd->sfn ].cdh_size;

  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00043	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00047	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00053	48 8b 84 01 f0
	01 00 00	 mov	 rax, QWORD PTR [rcx+rax+496]
  0005b	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 4251 :     fsiz = (S64) cckd->cdevhdr[ cckd->sfn ].free_total;

  00060	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00065	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00069	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00070	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00075	48 8b 84 01 08
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+520]
  0007d	48 89 44 24 38	 mov	 QWORD PTR fsiz$[rsp], rax

; 4252 : 
; 4253 :     if      (fsiz >= (size = size/2)) gc = 0; // critical   50% - 100%

  00082	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  00087	48 99		 cdq
  00089	48 2b c2	 sub	 rax, rdx
  0008c	48 d1 f8	 sar	 rax, 1
  0008f	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax
  00094	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  00099	48 39 44 24 38	 cmp	 QWORD PTR fsiz$[rsp], rax
  0009e	7c 0d		 jl	 SHORT $LN3@cckd64_gc_
  000a0	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR gc$[rsp], 0
  000a8	e9 80 00 00 00	 jmp	 $LN4@cckd64_gc_
$LN3@cckd64_gc_:

; 4254 :     else if (fsiz >= (size = size/2)) gc = 1; // severe     25% - 50%

  000ad	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000b2	48 99		 cdq
  000b4	48 2b c2	 sub	 rax, rdx
  000b7	48 d1 f8	 sar	 rax, 1
  000ba	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax
  000bf	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000c4	48 39 44 24 38	 cmp	 QWORD PTR fsiz$[rsp], rax
  000c9	7c 0a		 jl	 SHORT $LN5@cckd64_gc_
  000cb	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR gc$[rsp], 1
  000d3	eb 58		 jmp	 SHORT $LN6@cckd64_gc_
$LN5@cckd64_gc_:

; 4255 :     else if (fsiz >= (size = size/2)) gc = 2; // moderate 12.5% - 25%

  000d5	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000da	48 99		 cdq
  000dc	48 2b c2	 sub	 rax, rdx
  000df	48 d1 f8	 sar	 rax, 1
  000e2	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax
  000e7	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000ec	48 39 44 24 38	 cmp	 QWORD PTR fsiz$[rsp], rax
  000f1	7c 0a		 jl	 SHORT $LN7@cckd64_gc_
  000f3	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR gc$[rsp], 2
  000fb	eb 30		 jmp	 SHORT $LN8@cckd64_gc_
$LN7@cckd64_gc_:

; 4256 :     else if (fsiz >= (size = size/2)) gc = 3; // light     6.3% - 12.5%

  000fd	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  00102	48 99		 cdq
  00104	48 2b c2	 sub	 rax, rdx
  00107	48 d1 f8	 sar	 rax, 1
  0010a	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax
  0010f	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  00114	48 39 44 24 38	 cmp	 QWORD PTR fsiz$[rsp], rax
  00119	7c 0a		 jl	 SHORT $LN9@cckd64_gc_
  0011b	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR gc$[rsp], 3
  00123	eb 08		 jmp	 SHORT $LN10@cckd64_gc_
$LN9@cckd64_gc_:

; 4257 :     else                              gc = 4; // none        0% - 6.3%

  00125	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR gc$[rsp], 4
$LN10@cckd64_gc_:
$LN8@cckd64_gc_:
$LN6@cckd64_gc_:
$LN4@cckd64_gc_:

; 4258 : 
; 4259 :     /* Adjust the state based on the number of free spaces */
; 4260 :     if (cckd->cdevhdr[ cckd->sfn ].free_num >  800 && gc > 0) gc--;

  0012d	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00132	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00136	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0013d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00142	48 81 bc 01 18
	02 00 00 20 03
	00 00		 cmp	 QWORD PTR [rcx+rax+536], 800 ; 00000320H
  0014e	7e 11		 jle	 SHORT $LN11@cckd64_gc_
  00150	83 7c 24 20 00	 cmp	 DWORD PTR gc$[rsp], 0
  00155	7e 0a		 jle	 SHORT $LN11@cckd64_gc_
  00157	8b 44 24 20	 mov	 eax, DWORD PTR gc$[rsp]
  0015b	ff c8		 dec	 eax
  0015d	89 44 24 20	 mov	 DWORD PTR gc$[rsp], eax
$LN11@cckd64_gc_:

; 4261 :     if (cckd->cdevhdr[ cckd->sfn ].free_num > 1800 && gc > 0) gc--;

  00161	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00166	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0016a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00171	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00176	48 81 bc 01 18
	02 00 00 08 07
	00 00		 cmp	 QWORD PTR [rcx+rax+536], 1800 ; 00000708H
  00182	7e 11		 jle	 SHORT $LN12@cckd64_gc_
  00184	83 7c 24 20 00	 cmp	 DWORD PTR gc$[rsp], 0
  00189	7e 0a		 jle	 SHORT $LN12@cckd64_gc_
  0018b	8b 44 24 20	 mov	 eax, DWORD PTR gc$[rsp]
  0018f	ff c8		 dec	 eax
  00191	89 44 24 20	 mov	 DWORD PTR gc$[rsp], eax
$LN12@cckd64_gc_:

; 4262 :     if (cckd->cdevhdr[ cckd->sfn ].free_num > 3000)           gc = 0;

  00195	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  0019a	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0019e	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  001aa	48 81 bc 01 18
	02 00 00 b8 0b
	00 00		 cmp	 QWORD PTR [rcx+rax+536], 3000 ; 00000bb8H
  001b6	7e 08		 jle	 SHORT $LN13@cckd64_gc_
  001b8	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR gc$[rsp], 0
$LN13@cckd64_gc_:

; 4263 : 
; 4264 :     return gc;

  001c0	8b 44 24 20	 mov	 eax, DWORD PTR gc$[rsp]
$LN1@cckd64_gc_:

; 4265 : }

  001c4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c8	c3		 ret	 0
cckd64_gc_state ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
gc$ = 32
rc$ = 36
cckd$ = 40
size$ = 48
tv258 = 56
tv262 = 64
tv172 = 72
dev$ = 96
tv_now$ = 104
cckd64_gcol_dev PROC

; 4271 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4272 : int             rc;                     /* Return code               */
; 4273 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 4274 : U64             size;                   /* Percolate size            */
; 4275 : int             gc;                     /* Garbage collection state  */
; 4276 : 
; 4277 :     if (!dev->cckd64)

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00013	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0001a	24 01		 and	 al, 1
  0001c	0f b6 c0	 movzx	 eax, al
  0001f	85 c0		 test	 eax, eax
  00021	75 14		 jne	 SHORT $LN4@cckd64_gco

; 4278 :     {
; 4279 :         cckd_gcol_dev( dev, tv_now );

  00023	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv_now$[rsp]
  00028	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0002d	e8 00 00 00 00	 call	 cckd_gcol_dev

; 4280 :         return;

  00032	e9 07 04 00 00	 jmp	 $LN1@cckd64_gco
$LN4@cckd64_gco:

; 4281 :     }
; 4282 : 
; 4283 :     cckd = dev->cckd_ext;

  00037	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00043	48 89 44 24 28	 mov	 QWORD PTR cckd$[rsp], rax

; 4284 : 
; 4285 :     obtain_lock (&cckd->cckdiolock);

  00048	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0004d	48 83 c0 18	 add	 rax, 24
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171806
  00058	48 8b c8	 mov	 rcx, rax
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4286 :     {
; 4287 :         /* Bypass if merging or stopping */
; 4288 :         if (cckd->merging || cckd->stopping)

  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00066	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00069	c1 e8 05	 shr	 eax, 5
  0006c	83 e0 01	 and	 eax, 1
  0006f	85 c0		 test	 eax, eax
  00071	75 12		 jne	 SHORT $LN6@cckd64_gco
  00073	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00078	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0007b	c1 e8 06	 shr	 eax, 6
  0007e	83 e0 01	 and	 eax, 1
  00081	85 c0		 test	 eax, eax
  00083	74 1e		 je	 SHORT $LN5@cckd64_gco
$LN6@cckd64_gco:

; 4289 :         {
; 4290 :             release_lock (&cckd->cckdiolock);

  00085	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0008a	48 83 c0 18	 add	 rax, 24
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171809
  00095	48 8b c8	 mov	 rcx, rax
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4291 :             return;

  0009e	e9 9b 03 00 00	 jmp	 $LN1@cckd64_gco
$LN5@cckd64_gco:

; 4292 :         }
; 4293 : 
; 4294 :         /* Bypass if not opened read-write */
; 4295 :         if (cckd->open[cckd->sfn] != CCKD_OPEN_RW)

  000a3	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  000a8	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  000ac	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  000b1	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  000b9	83 f8 03	 cmp	 eax, 3
  000bc	74 1e		 je	 SHORT $LN7@cckd64_gco

; 4296 :         {
; 4297 :             release_lock (&cckd->cckdiolock);

  000be	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  000c3	48 83 c0 18	 add	 rax, 24
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171811
  000ce	48 8b c8	 mov	 rcx, rax
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4298 :             return;

  000d7	e9 62 03 00 00	 jmp	 $LN1@cckd64_gco
$LN7@cckd64_gco:

; 4299 :         }
; 4300 : 
; 4301 :         /* Free newbuf if it hasn't been used */
; 4302 :         if (!cckd->cckdioact && !cckd->bufused && cckd->newbuf)

  000dc	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  000e1	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000e4	c1 e8 02	 shr	 eax, 2
  000e7	83 e0 01	 and	 eax, 1
  000ea	85 c0		 test	 eax, eax
  000ec	75 41		 jne	 SHORT $LN8@cckd64_gco
  000ee	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  000f3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000f6	c1 e8 03	 shr	 eax, 3
  000f9	83 e0 01	 and	 eax, 1
  000fc	85 c0		 test	 eax, eax
  000fe	75 2f		 jne	 SHORT $LN8@cckd64_gco
  00100	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00105	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0010a	74 23		 je	 SHORT $LN8@cckd64_gco

; 4303 :             cckd->newbuf = cckd_free (dev, "newbuf", cckd->newbuf);

  0010c	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00111	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00115	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171813
  0011c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00121	e8 00 00 00 00	 call	 cckd_free
  00126	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  0012b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN8@cckd64_gco:

; 4304 : 
; 4305 :         cckd->bufused = 0;

  0012f	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00134	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00137	83 e0 f7	 and	 eax, -9			; fffffff7H
  0013a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  0013f	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 4306 : 
; 4307 :         /* If OPENED bit not on then flush if updated */
; 4308 :         if (!(cckd->cdevhdr[cckd->sfn].cdh_opts & CCKD_OPT_OPENED))

  00142	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00147	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0014b	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00152	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  00157	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  0015f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00164	85 c0		 test	 eax, eax
  00166	75 3a		 jne	 SHORT $LN9@cckd64_gco

; 4309 :         {
; 4310 :             if (cckd->updated) cckd64_flush_cache (dev);

  00168	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0016d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00170	c1 e8 04	 shr	 eax, 4
  00173	83 e0 01	 and	 eax, 1
  00176	85 c0		 test	 eax, eax
  00178	74 0a		 je	 SHORT $LN10@cckd64_gco
  0017a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0017f	e8 00 00 00 00	 call	 cckd64_flush_cache
$LN10@cckd64_gco:

; 4311 :             release_lock (&cckd->cckdiolock);

  00184	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00189	48 83 c0 18	 add	 rax, 24
  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171816
  00194	48 8b c8	 mov	 rcx, rax
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4312 :             return;

  0019d	e9 9c 02 00 00	 jmp	 $LN1@cckd64_gco
$LN9@cckd64_gco:

; 4313 :         }
; 4314 : 
; 4315 :         /* Determine garbage state */
; 4316 :         gc = cckd64_gc_state( dev );

  001a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001a7	e8 00 00 00 00	 call	 cckd64_gc_state
  001ac	89 44 24 20	 mov	 DWORD PTR gc$[rsp], eax

; 4317 : 
; 4318 :         /* Set the size */
; 4319 :         if (cckdblk.gcparm > 0) size = gctab[gc] << cckdblk.gcparm;

  001b0	83 3d 48 00 00
	00 00		 cmp	 DWORD PTR cckdblk+72, 0
  001b7	7e 2d		 jle	 SHORT $LN11@cckd64_gco
  001b9	48 63 44 24 20	 movsxd	 rax, DWORD PTR gc$[rsp]
  001be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gctab
  001c5	48 89 4c 24 38	 mov	 QWORD PTR tv258[rsp], rcx
  001ca	8b 15 48 00 00
	00		 mov	 edx, DWORD PTR cckdblk+72
  001d0	0f b6 ca	 movzx	 ecx, dl
  001d3	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv258[rsp]
  001d8	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  001db	d3 e0		 shl	 eax, cl
  001dd	48 98		 cdqe
  001df	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax
  001e4	eb 5a		 jmp	 SHORT $LN12@cckd64_gco
$LN11@cckd64_gco:

; 4320 :         else if (cckdblk.gcparm < 0) size = gctab[gc] >> abs(cckdblk.gcparm);

  001e6	83 3d 48 00 00
	00 00		 cmp	 DWORD PTR cckdblk+72, 0
  001ed	7d 3c		 jge	 SHORT $LN13@cckd64_gco
  001ef	48 63 44 24 20	 movsxd	 rax, DWORD PTR gc$[rsp]
  001f4	48 89 44 24 48	 mov	 QWORD PTR tv172[rsp], rax
  001f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gctab
  00200	48 89 4c 24 40	 mov	 QWORD PTR tv262[rsp], rcx
  00205	8b 0d 48 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+72
  0020b	e8 00 00 00 00	 call	 abs
  00210	0f b6 c8	 movzx	 ecx, al
  00213	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv262[rsp]
  00218	48 8b 44 24 48	 mov	 rax, QWORD PTR tv172[rsp]
  0021d	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00220	d3 f8		 sar	 eax, cl
  00222	48 98		 cdqe
  00224	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax
  00229	eb 15		 jmp	 SHORT $LN14@cckd64_gco
$LN13@cckd64_gco:

; 4321 :         else size = gctab[gc];

  0022b	48 63 44 24 20	 movsxd	 rax, DWORD PTR gc$[rsp]
  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:gctab
  00237	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  0023b	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax
$LN14@cckd64_gco:
$LN12@cckd64_gco:

; 4322 : 
; 4323 :         if (size > cckd->cdevhdr[cckd->sfn].cdh_used >> SHIFT_1K)

  00240	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00245	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00249	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00250	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  00255	48 8b 84 01 f8
	01 00 00	 mov	 rax, QWORD PTR [rcx+rax+504]
  0025d	48 c1 e8 0a	 shr	 rax, 10
  00261	48 39 44 24 30	 cmp	 QWORD PTR size$[rsp], rax
  00266	76 26		 jbe	 SHORT $LN15@cckd64_gco

; 4324 :             size = cckd->cdevhdr[cckd->sfn].cdh_used >> SHIFT_1K;

  00268	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0026d	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00271	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00278	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  0027d	48 8b 84 01 f8
	01 00 00	 mov	 rax, QWORD PTR [rcx+rax+504]
  00285	48 c1 e8 0a	 shr	 rax, 10
  00289	48 89 44 24 30	 mov	 QWORD PTR size$[rsp], rax
$LN15@cckd64_gco:

; 4325 :         if (size < 64)

  0028e	48 83 7c 24 30
	40		 cmp	 QWORD PTR size$[rsp], 64 ; 00000040H
  00294	73 09		 jae	 SHORT $LN16@cckd64_gco

; 4326 :             size = 64;

  00296	48 c7 44 24 30
	40 00 00 00	 mov	 QWORD PTR size$[rsp], 64 ; 00000040H
$LN16@cckd64_gco:

; 4327 :     }
; 4328 :     release_lock (&cckd->cckdiolock);

  0029f	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  002a4	48 83 c0 18	 add	 rax, 24
  002a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171823
  002af	48 8b c8	 mov	 rcx, rax
  002b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4329 : 
; 4330 :     /* Call the garbage collector */
; 4331 :     cckd64_gc_percolate( dev, size );

  002b8	48 8b 54 24 30	 mov	 rdx, QWORD PTR size$[rsp]
  002bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002c2	e8 00 00 00 00	 call	 cckd64_gc_percolate

; 4332 : 
; 4333 :     /* Schedule any updated tracks to be written */
; 4334 :     obtain_lock (&cckd->cckdiolock);

  002c7	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  002cc	48 83 c0 18	 add	 rax, 24
  002d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171824
  002d7	48 8b c8	 mov	 rcx, rax
  002da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4335 :     {
; 4336 :         cckd64_flush_cache (dev);

  002e0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002e5	e8 00 00 00 00	 call	 cckd64_flush_cache
$LN2@cckd64_gco:

; 4337 : 
; 4338 :         while (cckdblk.fsync && cckd->wrpending)

  002ea	83 3d 5c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+604, 0
  002f1	74 53		 je	 SHORT $LN3@cckd64_gco
  002f3	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  002f8	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  002fc	74 48		 je	 SHORT $LN3@cckd64_gco

; 4339 :         {
; 4340 :             cckd->cckdwaiters++;

  002fe	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00303	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00306	ff c0		 inc	 eax
  00308	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  0030d	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 4341 :             {
; 4342 :                 wait_condition (&cckd->cckdiocond, &cckd->cckdiolock);

  00310	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00315	48 83 c0 18	 add	 rax, 24
  00319	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  0031e	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00322	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171825
  00329	48 8b d0	 mov	 rdx, rax
  0032c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 4343 :             }
; 4344 :             cckd->cckdwaiters--;

  00332	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00337	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0033a	ff c8		 dec	 eax
  0033c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  00341	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 4345 :         }

  00344	eb a4		 jmp	 SHORT $LN2@cckd64_gco
$LN3@cckd64_gco:

; 4346 :     }
; 4347 :     release_lock (&cckd->cckdiolock);

  00346	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0034b	48 83 c0 18	 add	 rax, 24
  0034f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171826
  00356	48 8b c8	 mov	 rcx, rax
  00359	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4348 : 
; 4349 :     /* Sync the file */
; 4350 :     if (cckdblk.fsync && cckd->lastsync + 10 <= tv_now->tv_sec)

  0035f	83 3d 5c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+604, 0
  00366	74 7a		 je	 SHORT $LN17@cckd64_gco
  00368	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0036d	8b 80 8c 00 00
	00		 mov	 eax, DWORD PTR [rax+140]
  00373	83 c0 0a	 add	 eax, 10
  00376	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv_now$[rsp]
  0037b	3b 01		 cmp	 eax, DWORD PTR [rcx]
  0037d	7f 63		 jg	 SHORT $LN17@cckd64_gco

; 4351 :     {
; 4352 :         obtain_lock (&cckd->filelock);

  0037f	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00384	48 83 c0 10	 add	 rax, 16
  00388	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171828
  0038f	48 8b c8	 mov	 rcx, rax
  00392	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4353 :         {
; 4354 :             rc = fdatasync (cckd->fd[cckd->sfn]);

  00398	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0039d	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  003a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  003a6	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  003ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__commit
  003b3	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 4355 :             cckd->lastsync = tv_now->tv_sec;

  003b7	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  003bc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv_now$[rsp]
  003c1	8b 09		 mov	 ecx, DWORD PTR [rcx]
  003c3	89 88 8c 00 00
	00		 mov	 DWORD PTR [rax+140], ecx

; 4356 :         }
; 4357 :         release_lock (&cckd->filelock);

  003c9	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  003ce	48 83 c0 10	 add	 rax, 16
  003d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171829
  003d9	48 8b c8	 mov	 rcx, rax
  003dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN17@cckd64_gco:

; 4358 :     }
; 4359 : 
; 4360 :     /* Flush the free space */
; 4361 :     if (cckd->cdevhdr[cckd->sfn].free_num)

  003e2	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  003e7	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  003eb	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  003f2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cckd$[rsp]
  003f7	48 83 bc 01 18
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax+536], 0
  00400	74 3c		 je	 SHORT $LN18@cckd64_gco

; 4362 :     {
; 4363 :         obtain_lock (&cckd->filelock);

  00402	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00407	48 83 c0 10	 add	 rax, 16
  0040b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171831
  00412	48 8b c8	 mov	 rcx, rax
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4364 :         {
; 4365 :             cckd64_flush_space (dev);

  0041b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00420	e8 00 00 00 00	 call	 cckd64_flush_space

; 4366 :         }
; 4367 :         release_lock (&cckd->filelock);

  00425	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0042a	48 83 c0 10	 add	 rax, 16
  0042e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171832
  00435	48 8b c8	 mov	 rcx, rax
  00438	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN18@cckd64_gco:
$LN1@cckd64_gco:

; 4368 :     }
; 4369 : }

  0043e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00442	c3		 ret	 0
cckd64_gcol_dev ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
flag$ = 96
rc$ = 100
tv172 = 104
tid$ = 108
cckd$ = 112
dev$ = 120
tv168 = 128
cckd64_gcstart PROC

; 4111 : {

$LN13:
  00000	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 4112 :     DEVBLK*      dev;
; 4113 :     CCKD64_EXT*  cckd;
; 4114 :     TID tid;
; 4115 :     int flag = 0;

  00007	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR flag$[rsp], 0

; 4116 :     int rc;
; 4117 : 
; 4118 :     cckd_lock_devchain(0);

  0000f	33 c9		 xor	 ecx, ecx
  00011	e8 00 00 00 00	 call	 cckd_lock_devchain

; 4119 :     {
; 4120 :         for (dev = cckdblk.dev1st; dev; dev = cckd->devnext)

  00016	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  0001d	48 89 44 24 78	 mov	 QWORD PTR dev$[rsp], rax
  00022	eb 0d		 jmp	 SHORT $LN4@cckd64_gcs
$LN2@cckd64_gcs:
  00024	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00029	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002c	48 89 44 24 78	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd64_gcs:
  00031	48 83 7c 24 78
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00037	0f 84 cf 00 00
	00		 je	 $LN3@cckd64_gcs

; 4121 :         {
; 4122 :             cckd = dev->cckd_ext;

  0003d	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00042	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00049	48 89 44 24 70	 mov	 QWORD PTR cckd$[rsp], rax

; 4123 : 
; 4124 :             if (!dev->cckd64)

  0004e	48 8b 44 24 78	 mov	 rax, QWORD PTR dev$[rsp]
  00053	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0005a	24 01		 and	 al, 1
  0005c	0f b6 c0	 movzx	 eax, al
  0005f	85 c0		 test	 eax, eax
  00061	75 02		 jne	 SHORT $LN5@cckd64_gcs

; 4125 :                 continue;

  00063	eb bf		 jmp	 SHORT $LN2@cckd64_gcs
$LN5@cckd64_gcs:

; 4126 : 
; 4127 :             obtain_lock( &cckd->filelock );

  00065	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0006a	48 83 c0 10	 add	 rax, 16
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171720
  00075	48 8b c8	 mov	 rcx, rax
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4128 :             {
; 4129 :                 if (cckd->cdevhdr[ cckd->sfn ].free_total)

  0007e	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00083	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00087	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0008e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00093	48 83 bc 01 08
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax+520], 0
  0009c	74 50		 je	 SHORT $LN6@cckd64_gcs

; 4130 :                 {
; 4131 :                     cckd->cdevhdr[ cckd->sfn ].cdh_opts |= (CCKD_OPT_OPENED | CCKD_OPT_OPENRW);

  0009e	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  000a3	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  000a7	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000ae	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  000b3	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  000bb	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  000c0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  000c5	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  000c9	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  000d0	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  000d5	88 84 0a e3 01
	00 00		 mov	 BYTE PTR [rdx+rcx+483], al

; 4132 :                     cckd64_write_chdr( dev );

  000dc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dev$[rsp]
  000e1	e8 00 00 00 00	 call	 cckd64_write_chdr

; 4133 :                     flag = 1;

  000e6	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR flag$[rsp], 1
$LN6@cckd64_gcs:

; 4134 :                 }
; 4135 :             }
; 4136 :             release_lock( &cckd->filelock );

  000ee	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  000f3	48 83 c0 10	 add	 rax, 16
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171722
  000fe	48 8b c8	 mov	 rcx, rax
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4137 :         }

  00107	e9 18 ff ff ff	 jmp	 $LN2@cckd64_gcs
$LN3@cckd64_gcs:

; 4138 :     }
; 4139 :     cckd_unlock_devchain();

  0010c	e8 00 00 00 00	 call	 cckd_unlock_devchain

; 4140 : 
; 4141 :     /* Schedule the garbage collector */
; 4142 :     if (flag && cckdblk.gcs < cckdblk.gcmax)

  00111	83 7c 24 60 00	 cmp	 DWORD PTR flag$[rsp], 0
  00116	0f 84 f3 01 00
	00		 je	 $LN7@cckd64_gcs
  0011c	8b 05 40 00 00
	00		 mov	 eax, DWORD PTR cckdblk+64
  00122	39 05 38 00 00
	00		 cmp	 DWORD PTR cckdblk+56, eax
  00128	0f 8d e1 01 00
	00		 jge	 $LN7@cckd64_gcs

; 4143 :     {
; 4144 :         /* ensure read integrity for gc count */
; 4145 :         obtain_lock( &cckdblk.gclock );

  0012e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171724
  00135	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4146 :         {
; 4147 :             if (cckdblk.gcs < cckdblk.gcmax)

  00142	8b 05 40 00 00
	00		 mov	 eax, DWORD PTR cckdblk+64
  00148	39 05 38 00 00
	00		 cmp	 DWORD PTR cckdblk+56, eax
  0014e	0f 8d a7 01 00
	00		 jge	 $LN8@cckd64_gcs

; 4148 :             {
; 4149 :                 /* Schedule a new garbage collector thread  */
; 4150 :                 if (!cckdblk.batch || cckdblk.batchml > 1)

  00154	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  0015a	83 e0 01	 and	 eax, 1
  0015d	85 c0		 test	 eax, eax
  0015f	74 09		 je	 SHORT $LN10@cckd64_gcs
  00161	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  00168	7e 71		 jle	 SHORT $LN9@cckd64_gcs
$LN10@cckd64_gcs:

; 4151 :                     // "Starting thread %s, active=%d, started=%d, max=%d"
; 4152 :                     WRMSG( HHC00107, "I", CCKD_GC_THREAD_NAME "() by command line",

  0016a	b9 01 00 00 00	 mov	 ecx, 1
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00175	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+64
  0017b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0017f	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+56
  00185	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00189	8b 0d 3c 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+60
  0018f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171728
  0019a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171729
  001a6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171730
  001b2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bc	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171731
  001c9	ba 39 10 00 00	 mov	 edx, 4153		; 00001039H
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171732
  001d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@cckd64_gcs:

; 4153 :                         cckdblk.gca, cckdblk.gcs, cckdblk.gcmax );
; 4154 : 
; 4155 :                 ++cckdblk.gcs;

  001db	8b 05 38 00 00
	00		 mov	 eax, DWORD PTR cckdblk+56
  001e1	ff c0		 inc	 eax
  001e3	89 05 38 00 00
	00		 mov	 DWORD PTR cckdblk+56, eax

; 4156 : 
; 4157 :                 /* Release lock across thread create to prevent interlock  */
; 4158 :                 release_lock( &cckdblk.gclock );

  001e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171733
  001f0	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  001f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4159 :                 {
; 4160 :                     rc = create_thread( &tid, JOINABLE, cckd_gcol, NULL, CCKD_GC_THREAD_NAME );

  001fd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00204	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  0020a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171734
  00211	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171735
  0021d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00222	45 33 c9	 xor	 r9d, r9d
  00225	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cckd_gcol
  0022c	48 8b d0	 mov	 rdx, rax
  0022f	48 8d 4c 24 6c	 lea	 rcx, QWORD PTR tid$[rsp]
  00234	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  0023a	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 4161 :                 }
; 4162 :                 obtain_lock( &cckdblk.gclock );

  0023e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171736
  00245	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4163 : 
; 4164 :                 if (rc)

  00252	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  00257	0f 84 9e 00 00
	00		 je	 $LN11@cckd64_gcs

; 4165 :                 {
; 4166 :                     // "Error in function create_thread() for %s %d of %d: %s"
; 4167 :                     WRMSG( HHC00106, "E", CCKD_GC_THREAD_NAME "() by command line",

  0025d	8b 4c 24 64	 mov	 ecx, DWORD PTR rc$[rsp]
  00261	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00267	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv168[rsp], rax
  0026f	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+56
  00275	ff c9		 dec	 ecx
  00277	89 4c 24 68	 mov	 DWORD PTR tv172[rsp], ecx
  0027b	b9 01 00 00 00	 mov	 ecx, 1
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00286	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv168[rsp]
  0028e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00293	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+64
  00299	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0029d	8b 4c 24 68	 mov	 ecx, DWORD PTR tv172[rsp]
  002a1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171738
  002ac	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171739
  002b8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171740
  002c4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ce	41 b9 03 00 00
	00		 mov	 r9d, 3
  002d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171741
  002db	ba 48 10 00 00	 mov	 edx, 4168		; 00001048H
  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171742
  002e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4168 :                         cckdblk.gcs-1, cckdblk.gcmax, strerror( rc ));
; 4169 : 
; 4170 :                     --cckdblk.gcs;

  002ed	8b 05 38 00 00
	00		 mov	 eax, DWORD PTR cckdblk+56
  002f3	ff c8		 dec	 eax
  002f5	89 05 38 00 00
	00		 mov	 DWORD PTR cckdblk+56, eax
$LN11@cckd64_gcs:
$LN8@cckd64_gcs:

; 4171 :                 }
; 4172 :             }
; 4173 :         }
; 4174 :         release_lock( &cckdblk.gclock );

  002fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171743
  00302	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  00309	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN7@cckd64_gcs:

; 4175 :     }
; 4176 : }

  0030f	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00316	c3		 ret	 0
cckd64_gcstart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
cckd$ = 96
l1size$ = 104
tv131 = 108
tv137 = 112
tv159 = 116
tv165 = 120
tv94 = 124
tv154 = 128
tv82 = 136
tv247 = 144
tv289 = 152
tv297 = 160
devhdr$ = 176
__$ArrayPad$ = 688
dev$ = 736
cckd64_sf_new PROC

; 3263 : {

$LN21:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec c8 02
	00 00		 sub	 rsp, 712		; 000002c8H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3264 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 3265 : int             l1size;                 /* Size of level 1 table     */
; 3266 : CKD_DEVHDR      devhdr;                 /* Device header             */
; 3267 : 
; 3268 :     if (!dev->cckd64)

  00020	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00028	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0002f	24 01		 and	 al, 1
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	75 12		 jne	 SHORT $LN2@cckd64_sf_

; 3269 :         return cckd_sf_new( dev );

  00038	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00040	e8 00 00 00 00	 call	 cckd_sf_new
  00045	e9 26 06 00 00	 jmp	 $LN1@cckd64_sf_
$LN2@cckd64_sf_:

; 3270 : 
; 3271 :     cckd = dev->cckd_ext;

  0004a	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00059	48 89 44 24 60	 mov	 QWORD PTR cckd$[rsp], rax

; 3272 : 
; 3273 :     CCKD_TRACE( "file[%d] sf_new %s", cckd->sfn+1,

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00063	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00066	ff c0		 inc	 eax
  00068	8b d0		 mov	 edx, eax
  0006a	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00072	e8 00 00 00 00	 call	 cckd_sf_name
  00077	48 85 c0	 test	 rax, rax
  0007a	74 23		 je	 SHORT $LN11@cckd64_sf_
  0007c	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00081	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00084	ff c0		 inc	 eax
  00086	8b d0		 mov	 edx, eax
  00088	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00090	e8 00 00 00 00	 call	 cckd_sf_name
  00095	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
  0009d	eb 0f		 jmp	 SHORT $LN12@cckd64_sf_
$LN11@cckd64_sf_:
  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171220
  000a6	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
$LN12@cckd64_sf_:
  000ae	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  000b3	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  000b6	ff c0		 inc	 eax
  000b8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv82[rsp]
  000c0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000c5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000c9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171221
  000d0	4c 8b 84 24 e0
	02 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000d8	ba cb 0c 00 00	 mov	 edx, 3275		; 00000ccbH
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171222
  000e4	e8 00 00 00 00	 call	 cckd_trace

; 3274 :                 cckd_sf_name(dev, cckd->sfn+1) ?
; 3275 :                 (char *)cckd_sf_name(dev, cckd->sfn+1) : "(none)");
; 3276 : 
; 3277 :     /* Error if no shadow file name */
; 3278 :     if (dev->dasdsfn == NULL)

  000e9	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f1	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  000f9	0f 85 c3 00 00
	00		 jne	 $LN3@cckd64_sf_

; 3279 :     {
; 3280 :         WRMSG (HHC00313, "E", LCSS_DEVNUM, cckd->sfn+1);

  000ff	48 83 bc 24 e0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00108	74 12		 je	 SHORT $LN13@cckd64_sf_
  0010a	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00112	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00116	89 44 24 6c	 mov	 DWORD PTR tv131[rsp], eax
  0011a	eb 08		 jmp	 SHORT $LN14@cckd64_sf_
$LN13@cckd64_sf_:
  0011c	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN14@cckd64_sf_:
  00124	48 83 bc 24 e0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0012d	74 14		 je	 SHORT $LN15@cckd64_sf_
  0012f	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00137	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0013b	d1 f8		 sar	 eax, 1
  0013d	89 44 24 70	 mov	 DWORD PTR tv137[rsp], eax
  00141	eb 08		 jmp	 SHORT $LN16@cckd64_sf_
$LN15@cckd64_sf_:
  00143	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN16@cckd64_sf_:
  0014b	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00150	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00153	ff c0		 inc	 eax
  00155	89 44 24 7c	 mov	 DWORD PTR tv94[rsp], eax
  00159	b9 01 00 00 00	 mov	 ecx, 1
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00164	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv94[rsp]
  00168	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0016c	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv131[rsp]
  00170	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00174	8b 4c 24 70	 mov	 ecx, DWORD PTR tv137[rsp]
  00178	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171224
  00183	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00188	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171225
  0018f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00194	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00199	41 b9 03 00 00
	00		 mov	 r9d, 3
  0019f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171226
  001a6	ba d0 0c 00 00	 mov	 edx, 3280		; 00000cd0H
  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171227
  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3281 :         return -1;

  001b8	b8 ff ff ff ff	 mov	 eax, -1
  001bd	e9 ae 04 00 00	 jmp	 $LN1@cckd64_sf_
$LN3@cckd64_sf_:

; 3282 :     }
; 3283 : 
; 3284 :     /* Error if max number of shadow files exceeded */
; 3285 :     if (cckd->sfn+1 == CCKD_MAX_SF)

  001c2	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  001c7	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  001ca	ff c0		 inc	 eax
  001cc	83 f8 08	 cmp	 eax, 8
  001cf	0f 85 dd 00 00
	00		 jne	 $LN4@cckd64_sf_

; 3286 :     {
; 3287 :         WRMSG (HHC00314, "E", LCSS_DEVNUM, cckd->sfn+1, dev->dasdsfn);

  001d5	48 83 bc 24 e0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001de	74 12		 je	 SHORT $LN17@cckd64_sf_
  001e0	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001ec	89 44 24 74	 mov	 DWORD PTR tv159[rsp], eax
  001f0	eb 08		 jmp	 SHORT $LN18@cckd64_sf_
$LN17@cckd64_sf_:
  001f2	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN18@cckd64_sf_:
  001fa	48 83 bc 24 e0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00203	74 14		 je	 SHORT $LN19@cckd64_sf_
  00205	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00211	d1 f8		 sar	 eax, 1
  00213	89 44 24 78	 mov	 DWORD PTR tv165[rsp], eax
  00217	eb 08		 jmp	 SHORT $LN20@cckd64_sf_
$LN19@cckd64_sf_:
  00219	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
$LN20@cckd64_sf_:
  00221	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00226	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00229	ff c0		 inc	 eax
  0022b	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv154[rsp], eax
  00232	b9 01 00 00 00	 mov	 ecx, 1
  00237	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0023d	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00245	48 8b 89 70 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4464]
  0024c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00251	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv154[rsp]
  00258	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0025c	8b 4c 24 74	 mov	 ecx, DWORD PTR tv159[rsp]
  00260	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00264	8b 4c 24 78	 mov	 ecx, DWORD PTR tv165[rsp]
  00268	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0026c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171229
  00273	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00278	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171230
  0027f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00284	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00289	41 b9 03 00 00
	00		 mov	 r9d, 3
  0028f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171231
  00296	ba d7 0c 00 00	 mov	 edx, 3287		; 00000cd7H
  0029b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171232
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3288 :         return -1;

  002a8	b8 ff ff ff ff	 mov	 eax, -1
  002ad	e9 be 03 00 00	 jmp	 $LN1@cckd64_sf_
$LN4@cckd64_sf_:

; 3289 :     }
; 3290 : 
; 3291 :     /* Harden the current file */
; 3292 :     cckd64_harden (dev);

  002b2	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002ba	e8 00 00 00 00	 call	 cckd64_harden

; 3293 : 
; 3294 :     /* Open the new shadow file */
; 3295 :     if (cckd64_open(dev, cckd->sfn+1, O_RDWR|O_CREAT|O_EXCL|O_BINARY,
; 3296 :                                       S_IRUSR | S_IWUSR | S_IRGRP) < 0)

  002bf	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  002c4	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  002c7	ff c0		 inc	 eax
  002c9	41 b9 80 01 00
	00		 mov	 r9d, 384		; 00000180H
  002cf	41 b8 02 85 00
	00		 mov	 r8d, 34050		; 00008502H
  002d5	8b d0		 mov	 edx, eax
  002d7	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002df	e8 00 00 00 00	 call	 cckd64_open
  002e4	85 c0		 test	 eax, eax
  002e6	7d 0a		 jge	 SHORT $LN5@cckd64_sf_

; 3297 :         return -1;

  002e8	b8 ff ff ff ff	 mov	 eax, -1
  002ed	e9 7e 03 00 00	 jmp	 $LN1@cckd64_sf_
$LN5@cckd64_sf_:

; 3298 : 
; 3299 :     /* Read previous file's device header */
; 3300 :     if (cckd64_read (dev, cckd->sfn, 0, &devhdr, CKD_DEVHDR_SIZE) < 0)

  002f2	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  002fa	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR devhdr$[rsp]
  00302	45 33 c0	 xor	 r8d, r8d
  00305	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0030a	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  0030d	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00315	e8 00 00 00 00	 call	 cckd64_read
  0031a	85 c0		 test	 eax, eax
  0031c	7d 05		 jge	 SHORT $LN6@cckd64_sf_

; 3301 :         goto sf_new_error;

  0031e	e9 a0 02 00 00	 jmp	 $sf_new_error$22
$LN6@cckd64_sf_:

; 3302 : 
; 3303 :     /* Make sure identifier is CKD_S370 or FBA_S370 */
; 3304 :     devhdr.dh_devid[4] = 'S';

  00323	b8 01 00 00 00	 mov	 eax, 1
  00328	48 6b c0 04	 imul	 rax, rax, 4
  0032c	c6 84 04 b0 00
	00 00 53	 mov	 BYTE PTR devhdr$[rsp+rax], 83 ; 00000053H

; 3305 : 
; 3306 :     /* Write new file's device header */
; 3307 :     if (cckd64_write (dev, cckd->sfn+1, 0, &devhdr, CKD_DEVHDR_SIZE) < 0)

  00334	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00339	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0033c	ff c0		 inc	 eax
  0033e	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  00346	4c 8d 8c 24 b0
	00 00 00	 lea	 r9, QWORD PTR devhdr$[rsp]
  0034e	45 33 c0	 xor	 r8d, r8d
  00351	8b d0		 mov	 edx, eax
  00353	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0035b	e8 00 00 00 00	 call	 cckd64_write
  00360	85 c0		 test	 eax, eax
  00362	7d 05		 jge	 SHORT $LN7@cckd64_sf_

; 3308 :         goto sf_new_error;

  00364	e9 5a 02 00 00	 jmp	 $sf_new_error$22
$LN7@cckd64_sf_:

; 3309 : 
; 3310 :     /* Build the compressed device header */
; 3311 :     memcpy (&cckd->cdevhdr[cckd->sfn+1], &cckd->cdevhdr[cckd->sfn], CCKD64_DEVHDR_SIZE);

  00369	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0036e	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00372	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00379	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0037e	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00381	ff c1		 inc	 ecx
  00383	48 63 c9	 movsxd	 rcx, ecx
  00386	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  0038d	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00392	4c 8b 44 24 60	 mov	 r8, QWORD PTR cckd$[rsp]
  00397	48 8d bc 0a e0
	01 00 00	 lea	 rdi, QWORD PTR [rdx+rcx+480]
  0039f	49 8d b4 00 e0
	01 00 00	 lea	 rsi, QWORD PTR [r8+rax+480]
  003a7	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  003ac	f3 a4		 rep movsb

; 3312 :     l1size = cckd->cdevhdr[cckd->sfn+1].num_L1tab * CCKD64_L1ENT_SIZE;

  003ae	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  003b3	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  003b6	ff c0		 inc	 eax
  003b8	48 98		 cdqe
  003ba	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  003c1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  003c6	48 63 84 01 e4
	01 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+484]
  003ce	48 c1 e0 03	 shl	 rax, 3
  003d2	89 44 24 68	 mov	 DWORD PTR l1size$[rsp], eax

; 3313 :     cckd->cdevhdr[cckd->sfn+1].cdh_size =

  003d6	48 63 44 24 68	 movsxd	 rax, DWORD PTR l1size$[rsp]
  003db	48 05 00 04 00
	00		 add	 rax, 1024		; 00000400H
  003e1	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv247[rsp], rax
  003e9	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  003ee	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  003f1	ff c0		 inc	 eax
  003f3	48 98		 cdqe
  003f5	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  003fc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00401	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv247[rsp]
  00409	48 89 94 01 f8
	01 00 00	 mov	 QWORD PTR [rcx+rax+504], rdx
  00411	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00416	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00419	ff c0		 inc	 eax
  0041b	48 98		 cdqe
  0041d	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00424	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00429	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv247[rsp]
  00431	48 89 94 01 f0
	01 00 00	 mov	 QWORD PTR [rcx+rax+496], rdx

; 3314 :     cckd->cdevhdr[cckd->sfn+1].cdh_used = CKD_DEVHDR_SIZE + CCKD64_DEVHDR_SIZE + l1size;
; 3315 :     cckd->cdevhdr[cckd->sfn+1].free_off =

  00439	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0043e	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00441	ff c0		 inc	 eax
  00443	48 98		 cdqe
  00445	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0044c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00451	48 c7 84 01 20
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+544], 0
  0045d	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00462	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00465	ff c0		 inc	 eax
  00467	48 98		 cdqe
  00469	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00470	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00475	48 c7 84 01 18
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+536], 0
  00481	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00486	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00489	ff c0		 inc	 eax
  0048b	48 98		 cdqe
  0048d	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00494	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00499	48 c7 84 01 10
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+528], 0
  004a5	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  004aa	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  004ad	ff c0		 inc	 eax
  004af	48 98		 cdqe
  004b1	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004b8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  004bd	48 c7 84 01 08
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+520], 0
  004c9	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  004ce	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  004d1	ff c0		 inc	 eax
  004d3	48 98		 cdqe
  004d5	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004dc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  004e1	48 c7 84 01 00
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+512], 0

; 3316 :     cckd->cdevhdr[cckd->sfn+1].free_total =
; 3317 :     cckd->cdevhdr[cckd->sfn+1].free_largest =
; 3318 :     cckd->cdevhdr[cckd->sfn+1].free_num =
; 3319 :     cckd->cdevhdr[cckd->sfn+1].free_imbed = 0;
; 3320 : 
; 3321 :     /* Init the level 1 table */
; 3322 :     if ((cckd->L1tab[cckd->sfn+1] = cckd_malloc (dev, "l1", l1size)) == NULL)

  004ed	48 63 44 24 68	 movsxd	 rax, DWORD PTR l1size$[rsp]
  004f2	4c 8b c0	 mov	 r8, rax
  004f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171237
  004fc	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00504	e8 00 00 00 00	 call	 cckd_malloc
  00509	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv289[rsp], rax
  00511	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00516	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00519	ff c0		 inc	 eax
  0051b	48 98		 cdqe
  0051d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00522	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR tv289[rsp]
  0052a	48 89 94 c1 98
	01 00 00	 mov	 QWORD PTR [rcx+rax*8+408], rdx
  00532	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR tv289[rsp], 0
  0053b	75 05		 jne	 SHORT $LN8@cckd64_sf_

; 3323 :         goto sf_new_error;

  0053d	e9 81 00 00 00	 jmp	 $sf_new_error$22
$LN8@cckd64_sf_:

; 3324 :     memset (cckd->L1tab[cckd->sfn+1], 0xff, l1size);

  00542	48 63 44 24 68	 movsxd	 rax, DWORD PTR l1size$[rsp]
  00547	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv297[rsp], rax
  0054f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00554	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00557	ff c1		 inc	 ecx
  00559	48 63 c9	 movsxd	 rcx, ecx
  0055c	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00561	48 8b bc ca 98
	01 00 00	 mov	 rdi, QWORD PTR [rdx+rcx*8+408]
  00569	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0056e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv297[rsp]
  00576	f3 aa		 rep stosb

; 3325 : 
; 3326 :     /* Make the new file active */
; 3327 :     cckd->sfn++;

  00578	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0057d	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00580	ff c0		 inc	 eax
  00582	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00587	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 3328 : 
; 3329 :     /* Harden the new file */
; 3330 :     if (cckd64_harden (dev) < 0)

  0058a	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00592	e8 00 00 00 00	 call	 cckd64_harden
  00597	85 c0		 test	 eax, eax
  00599	7d 14		 jge	 SHORT $LN9@cckd64_sf_

; 3331 :     {
; 3332 :         cckd->sfn--;

  0059b	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  005a0	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  005a3	ff c8		 dec	 eax
  005a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  005aa	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 3333 :         goto sf_new_error;

  005ad	eb 14		 jmp	 SHORT $sf_new_error$22
$LN9@cckd64_sf_:

; 3334 :     }
; 3335 : 
; 3336 :     /* Re-read the l1 to set L2_bounds, L2ok */
; 3337 :     cckd64_read_l1 (dev);

  005af	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005b7	e8 00 00 00 00	 call	 cckd64_read_l1

; 3338 : 
; 3339 :     return 0;

  005bc	33 c0		 xor	 eax, eax
  005be	e9 ad 00 00 00	 jmp	 $LN1@cckd64_sf_
$sf_new_error$22:

; 3340 : 
; 3341 : sf_new_error:
; 3342 :     cckd->L1tab[cckd->sfn+1] = cckd_free(dev, "l1", cckd->L1tab[cckd->sfn+1]);

  005c3	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  005c8	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  005cb	ff c0		 inc	 eax
  005cd	48 98		 cdqe
  005cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  005d4	4c 8b 84 c1 98
	01 00 00	 mov	 r8, QWORD PTR [rcx+rax*8+408]
  005dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171239
  005e3	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005eb	e8 00 00 00 00	 call	 cckd_free
  005f0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  005f5	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  005f8	ff c1		 inc	 ecx
  005fa	48 63 c9	 movsxd	 rcx, ecx
  005fd	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00602	48 89 84 ca 98
	01 00 00	 mov	 QWORD PTR [rdx+rcx*8+408], rax

; 3343 :     cckd64_close (dev, cckd->sfn+1);

  0060a	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0060f	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00612	ff c0		 inc	 eax
  00614	8b d0		 mov	 edx, eax
  00616	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0061e	e8 00 00 00 00	 call	 cckd64_close

; 3344 :     cckd->open[cckd->sfn+1] = CCKD_OPEN_NONE;

  00623	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00628	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0062b	ff c0		 inc	 eax
  0062d	48 98		 cdqe
  0062f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00634	c6 84 01 1d 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+285], 0

; 3345 :     unlink (cckd_sf_name (dev, cckd->sfn+1));

  0063c	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00641	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00644	ff c0		 inc	 eax
  00646	8b d0		 mov	 edx, eax
  00648	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00650	e8 00 00 00 00	 call	 cckd_sf_name
  00655	48 8b c8	 mov	 rcx, rax
  00658	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_unlink

; 3346 : 
; 3347 :     /* Re-read the l1 to set L2_bounds, L2ok */
; 3348 :     cckd64_read_l1 (dev);

  0065e	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00666	e8 00 00 00 00	 call	 cckd64_read_l1

; 3349 : 
; 3350 :     return -1;

  0066b	b8 ff ff ff ff	 mov	 eax, -1
$LN1@cckd64_sf_:

; 3351 : 
; 3352 : } /* end function cckd64_sf_new */

  00670	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00678	48 33 cc	 xor	 rcx, rsp
  0067b	e8 00 00 00 00	 call	 __security_check_cookie
  00680	48 81 c4 c8 02
	00 00		 add	 rsp, 712		; 000002c8H
  00687	5f		 pop	 rdi
  00688	5e		 pop	 rsi
  00689	c3		 ret	 0
cckd64_sf_new ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
i$ = 128
cckd$ = 136
j$1 = 144
dev2$2 = 152
tv147 = 160
tv153 = 164
tv215 = 168
tv221 = 172
rc$ = 176
tv288 = 180
tv294 = 184
tv133 = 188
tv137 = 192
cckd2$3 = 200
tv86 = 208
tv95 = 216
tv139 = 224
tv276 = 232
tv280 = 240
st$ = 248
devhdr$ = 304
pathname$ = 816
__$ArrayPad$ = 1088
dev$ = 1120
cckd64_sf_init PROC

; 3154 : {

$LN46:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 04
	00 00		 sub	 rsp, 1112		; 00000458H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 40
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3155 : CKD_DEVHDR      devhdr;                 /* Device header             */
; 3156 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 3157 : int             rc;                     /* Return code               */
; 3158 : int             i;                      /* Index                     */
; 3159 : struct stat     st;                     /* stat() buffer             */
; 3160 : char            pathname[MAX_PATH];     /* file path in host format  */
; 3161 : 
; 3162 :     if (!dev->cckd64)

  0001e	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0002d	24 01		 and	 al, 1
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	75 12		 jne	 SHORT $LN17@cckd64_sf_

; 3163 :         return cckd_sf_init( dev );

  00036	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0003e	e8 00 00 00 00	 call	 cckd_sf_init
  00043	e9 3c 07 00 00	 jmp	 $LN1@cckd64_sf_
$LN17@cckd64_sf_:

; 3164 : 
; 3165 :     cckd = dev->cckd_ext;

  00048	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00050	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00057	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 3166 : 
; 3167 :     /* return if no shadow files */
; 3168 :     if (dev->dasdsfn == NULL) return 0;

  0005f	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00067	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  0006f	75 07		 jne	 SHORT $LN18@cckd64_sf_
  00071	33 c0		 xor	 eax, eax
  00073	e9 0c 07 00 00	 jmp	 $LN1@cckd64_sf_
$LN18@cckd64_sf_:

; 3169 : 
; 3170 :     /* Check for shadow file name collision */
; 3171 :     for (i = 1; i <= CCKD_MAX_SF && dev->dasdsfn != NULL; i++)

  00078	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR i$[rsp], 1
  00083	eb 10		 jmp	 SHORT $LN4@cckd64_sf_
$LN2@cckd64_sf_:
  00085	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0008c	ff c0		 inc	 eax
  0008e	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd64_sf_:
  00095	83 bc 24 80 00
	00 00 08	 cmp	 DWORD PTR i$[rsp], 8
  0009d	0f 8f 74 02 00
	00		 jg	 $LN3@cckd64_sf_
  000a3	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ab	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  000b3	0f 84 5e 02 00
	00		 je	 $LN3@cckd64_sf_

; 3172 :     {
; 3173 :      DEVBLK       *dev2;
; 3174 :      CCKD64_EXT   *cckd2;
; 3175 :      int           j;
; 3176 : 
; 3177 :         for (dev2 = cckdblk.dev1st; dev2; dev2 = cckd2->devnext)

  000b9	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  000c0	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR dev2$2[rsp], rax
  000c8	eb 13		 jmp	 SHORT $LN7@cckd64_sf_
$LN5@cckd64_sf_:
  000ca	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR cckd2$3[rsp]
  000d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d5	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR dev2$2[rsp], rax
$LN7@cckd64_sf_:
  000dd	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR dev2$2[rsp], 0
  000e6	0f 84 26 02 00
	00		 je	 $LN6@cckd64_sf_

; 3178 :         {
; 3179 :             cckd2 = dev2->cckd_ext;

  000ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev2$2[rsp]
  000f4	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  000fb	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR cckd2$3[rsp], rax

; 3180 :             if (dev2 == dev) continue;

  00103	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010b	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR dev2$2[rsp], rax
  00113	75 02		 jne	 SHORT $LN19@cckd64_sf_
  00115	eb b3		 jmp	 SHORT $LN5@cckd64_sf_
$LN19@cckd64_sf_:

; 3181 :             for (j = 0; j <= CCKD_MAX_SF && dev2->dasdsfn != NULL; j++)

  00117	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$1[rsp], 0
  00122	eb 10		 jmp	 SHORT $LN10@cckd64_sf_
$LN8@cckd64_sf_:
  00124	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR j$1[rsp]
  0012b	ff c0		 inc	 eax
  0012d	89 84 24 90 00
	00 00		 mov	 DWORD PTR j$1[rsp], eax
$LN10@cckd64_sf_:
  00134	83 bc 24 90 00
	00 00 08	 cmp	 DWORD PTR j$1[rsp], 8
  0013c	0f 8f cb 01 00
	00		 jg	 $LN9@cckd64_sf_
  00142	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev2$2[rsp]
  0014a	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  00152	0f 84 b5 01 00
	00		 je	 $LN9@cckd64_sf_

; 3182 :             {
; 3183 :                 if (strcmp (cckd_sf_name(dev, i),cckd_sf_name(dev2, j)) == 0)

  00158	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR j$1[rsp]
  0015f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev2$2[rsp]
  00167	e8 00 00 00 00	 call	 cckd_sf_name
  0016c	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv86[rsp], rax
  00174	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  0017b	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00183	e8 00 00 00 00	 call	 cckd_sf_name
  00188	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv86[rsp]
  00190	48 8b d1	 mov	 rdx, rcx
  00193	48 8b c8	 mov	 rcx, rax
  00196	e8 00 00 00 00	 call	 strcmp
  0019b	85 c0		 test	 eax, eax
  0019d	0f 85 65 01 00
	00		 jne	 $LN20@cckd64_sf_

; 3184 :                 {
; 3185 :                     // "%1d:%04X CCKD file[%d] %s: shadow file name collides with %1d:%04X file[%d] %s"
; 3186 :                     WRMSG (HHC00311, "E", LCSS_DEVNUM,  i, cckd_sf_name(dev,  i),

  001a3	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001ac	74 15		 je	 SHORT $LN34@cckd64_sf_
  001ae	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001b6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001ba	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv147[rsp], eax
  001c1	eb 0b		 jmp	 SHORT $LN35@cckd64_sf_
$LN34@cckd64_sf_:
  001c3	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv147[rsp], 0
$LN35@cckd64_sf_:
  001ce	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001d7	74 17		 je	 SHORT $LN36@cckd64_sf_
  001d9	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e1	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001e5	d1 f8		 sar	 eax, 1
  001e7	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv153[rsp], eax
  001ee	eb 0b		 jmp	 SHORT $LN37@cckd64_sf_
$LN36@cckd64_sf_:
  001f0	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv153[rsp], 0
$LN37@cckd64_sf_:
  001fb	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR j$1[rsp]
  00202	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev2$2[rsp]
  0020a	e8 00 00 00 00	 call	 cckd_sf_name
  0020f	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv95[rsp], rax
  00217	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR dev2$2[rsp]
  0021f	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00223	89 8c 24 bc 00
	00 00		 mov	 DWORD PTR tv133[rsp], ecx
  0022a	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR dev2$2[rsp]
  00232	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00236	d1 fa		 sar	 edx, 1
  00238	89 94 24 c0 00
	00 00		 mov	 DWORD PTR tv137[rsp], edx
  0023f	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00246	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0024e	e8 00 00 00 00	 call	 cckd_sf_name
  00253	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv139[rsp], rax
  0025b	b9 01 00 00 00	 mov	 ecx, 1
  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00266	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv95[rsp]
  0026e	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  00273	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR j$1[rsp]
  0027a	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0027e	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv133[rsp]
  00285	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00289	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv137[rsp]
  00290	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00294	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv139[rsp]
  0029c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002a1	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  002a8	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  002ac	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv147[rsp]
  002b3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002b7	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv153[rsp]
  002be	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171173
  002c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171174
  002d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002df	41 b9 03 00 00
	00		 mov	 r9d, 3
  002e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171175
  002ec	ba 73 0c 00 00	 mov	 edx, 3187		; 00000c73H
  002f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171176
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3187 :                                          SSID_TO_LCSS(dev2->ssid), dev2->devnum, j, cckd_sf_name(dev2, j));
; 3188 :                     return -1;

  002fe	b8 ff ff ff ff	 mov	 eax, -1
  00303	e9 7c 04 00 00	 jmp	 $LN1@cckd64_sf_
$LN20@cckd64_sf_:

; 3189 :                 }
; 3190 :             }

  00308	e9 17 fe ff ff	 jmp	 $LN8@cckd64_sf_
$LN9@cckd64_sf_:

; 3191 :         }

  0030d	e9 b8 fd ff ff	 jmp	 $LN5@cckd64_sf_
$LN6@cckd64_sf_:

; 3192 :     }

  00312	e9 6e fd ff ff	 jmp	 $LN2@cckd64_sf_
$LN3@cckd64_sf_:

; 3193 : 
; 3194 :     /* open all existing shadow files */
; 3195 :     for (cckd->sfn = 1; cckd->sfn <= CCKD_MAX_SF; cckd->sfn++)

  00317	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0031f	c7 40 3c 01 00
	00 00		 mov	 DWORD PTR [rax+60], 1
  00326	eb 18		 jmp	 SHORT $LN13@cckd64_sf_
$LN11@cckd64_sf_:
  00328	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00330	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00333	ff c0		 inc	 eax
  00335	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0033d	89 41 3c	 mov	 DWORD PTR [rcx+60], eax
$LN13@cckd64_sf_:
  00340	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00348	83 78 3c 08	 cmp	 DWORD PTR [rax+60], 8
  0034c	0f 8f 14 02 00
	00		 jg	 $LN12@cckd64_sf_

; 3196 :     {
; 3197 :         /* If no more shadow files remaining then we're done */
; 3198 :         hostpath( pathname, cckd_sf_name( dev, cckd->sfn ), sizeof( pathname ));

  00352	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0035a	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  0035d	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00365	e8 00 00 00 00	 call	 cckd_sf_name
  0036a	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00370	48 8b d0	 mov	 rdx, rax
  00373	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0037b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 3199 :         if (stat( pathname, &st ) < 0)

  00381	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR st$[rsp]
  00389	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00391	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64
  00397	85 c0		 test	 eax, eax
  00399	7d 05		 jge	 SHORT $LN21@cckd64_sf_

; 3200 :             break;

  0039b	e9 c6 01 00 00	 jmp	 $LN12@cckd64_sf_
$LN21@cckd64_sf_:

; 3201 : 
; 3202 :         /* Try to open the shadow file read-write then read-only */
; 3203 :         if (    cckd64_open( dev, cckd->sfn, O_RDWR   | O_BINARY, 1 ) < 0)

  003a0	41 b9 01 00 00
	00		 mov	 r9d, 1
  003a6	41 b8 02 80 00
	00		 mov	 r8d, 32770		; 00008002H
  003ac	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  003b4	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  003b7	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003bf	e8 00 00 00 00	 call	 cckd64_open
  003c4	85 c0		 test	 eax, eax
  003c6	7d 2a		 jge	 SHORT $LN22@cckd64_sf_

; 3204 :             if (cckd64_open( dev, cckd->sfn, O_RDONLY | O_BINARY, 0 ) < 0)

  003c8	45 33 c9	 xor	 r9d, r9d
  003cb	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  003d1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  003d9	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  003dc	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003e4	e8 00 00 00 00	 call	 cckd64_open
  003e9	85 c0		 test	 eax, eax
  003eb	7d 05		 jge	 SHORT $LN23@cckd64_sf_

; 3205 :                 break;

  003ed	e9 74 01 00 00	 jmp	 $LN12@cckd64_sf_
$LN23@cckd64_sf_:
$LN22@cckd64_sf_:

; 3206 : 
; 3207 :         /* Make sure shadow file type matches base image type */
; 3208 :         if (cckd_read( dev, cckd->sfn, 0, &devhdr, CKD_DEVHDR_SIZE ) < 0)

  003f2	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  003fa	4c 8d 8c 24 30
	01 00 00	 lea	 r9, QWORD PTR devhdr$[rsp]
  00402	45 33 c0	 xor	 r8d, r8d
  00405	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0040d	8b 50 3c	 mov	 edx, DWORD PTR [rax+60]
  00410	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00418	e8 00 00 00 00	 call	 cckd_read
  0041d	85 c0		 test	 eax, eax
  0041f	7d 0a		 jge	 SHORT $LN24@cckd64_sf_

; 3209 :             return -1;

  00421	b8 ff ff ff ff	 mov	 eax, -1
  00426	e9 59 03 00 00	 jmp	 $LN1@cckd64_sf_
$LN24@cckd64_sf_:

; 3210 :         if (!is_dh_devid_typ( devhdr.dh_devid, ANY64_SF_TYP ))

  0042b	ba 20 00 20 00	 mov	 edx, 2097184		; 00200020H
  00430	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  00438	e8 00 00 00 00	 call	 is_dh_devid_typ
  0043d	0f b6 c0	 movzx	 eax, al
  00440	85 c0		 test	 eax, eax
  00442	0f 85 db 00 00
	00		 jne	 $LN25@cckd64_sf_

; 3211 :         {
; 3212 :             // "%1d:%04X CCKD file[%d] %s: cckd/64 format differs from base"
; 3213 :             WRMSG( HHC00351, "E", LCSS_DEVNUM, cckd->sfn, pathname );

  00448	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00451	74 15		 je	 SHORT $LN38@cckd64_sf_
  00453	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0045b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0045f	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv215[rsp], eax
  00466	eb 0b		 jmp	 SHORT $LN39@cckd64_sf_
$LN38@cckd64_sf_:
  00468	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv215[rsp], 0
$LN39@cckd64_sf_:
  00473	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0047c	74 17		 je	 SHORT $LN40@cckd64_sf_
  0047e	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00486	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0048a	d1 f8		 sar	 eax, 1
  0048c	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv221[rsp], eax
  00493	eb 0b		 jmp	 SHORT $LN41@cckd64_sf_
$LN40@cckd64_sf_:
  00495	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv221[rsp], 0
$LN41@cckd64_sf_:
  004a0	b9 01 00 00 00	 mov	 ecx, 1
  004a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004ab	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  004b3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  004b8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  004c0	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  004c3	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  004c7	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv215[rsp]
  004ce	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004d2	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv221[rsp]
  004d9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171182
  004e4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171183
  004f0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004fa	41 b9 03 00 00
	00		 mov	 r9d, 3
  00500	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171184
  00507	ba 8d 0c 00 00	 mov	 edx, 3213		; 00000c8dH
  0050c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171185
  00513	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3214 :             return -1;

  00519	b8 ff ff ff ff	 mov	 eax, -1
  0051e	e9 61 02 00 00	 jmp	 $LN1@cckd64_sf_
$LN25@cckd64_sf_:

; 3215 :         }
; 3216 : 
; 3217 :         /* Call the chkdsk function */
; 3218 :         if ((rc = cckd64_chkdsk( dev, 0 )) < 0)

  00523	33 d2		 xor	 edx, edx
  00525	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0052d	e8 00 00 00 00	 call	 cckd64_chkdsk
  00532	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  00539	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00541	7d 0a		 jge	 SHORT $LN26@cckd64_sf_

; 3219 :             return -1;

  00543	b8 ff ff ff ff	 mov	 eax, -1
  00548	e9 37 02 00 00	 jmp	 $LN1@cckd64_sf_
$LN26@cckd64_sf_:

; 3220 : 
; 3221 :         /* Perform initial read */
; 3222 :         rc = cckd64_read_init( dev );

  0054d	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00555	e8 00 00 00 00	 call	 cckd64_read_init
  0055a	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3223 :     }

  00561	e9 c2 fd ff ff	 jmp	 $LN11@cckd64_sf_
$LN12@cckd64_sf_:

; 3224 : 
; 3225 :     /* Backup to the last opened file number */
; 3226 :     cckd->sfn--;

  00566	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0056e	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00571	ff c8		 dec	 eax
  00573	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0057b	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 3227 : 
; 3228 :     /* If the last file was opened read-only then create a new one */
; 3229 :     if (cckd->open[cckd->sfn] == CCKD_OPEN_RO)

  0057e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00586	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0058a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00592	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  0059a	83 f8 01	 cmp	 eax, 1
  0059d	75 52		 jne	 SHORT $LN27@cckd64_sf_

; 3230 :     {
; 3231 :         /* but ONLY IF not explicit batch utility READ-ONLY open */
; 3232 :         if (!(1

  0059f	33 c0		 xor	 eax, eax
  005a1	83 f8 01	 cmp	 eax, 1
  005a4	74 30		 je	 SHORT $LN29@cckd64_sf_
  005a6	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005ae	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005b4	c1 e8 0a	 shr	 eax, 10
  005b7	83 e0 01	 and	 eax, 1
  005ba	85 c0		 test	 eax, eax
  005bc	74 18		 je	 SHORT $LN29@cckd64_sf_
  005be	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005c6	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  005cc	c1 e8 12	 shr	 eax, 18
  005cf	83 e0 01	 and	 eax, 1
  005d2	85 c0		 test	 eax, eax
  005d4	75 1b		 jne	 SHORT $LN28@cckd64_sf_
$LN29@cckd64_sf_:

; 3233 :               && dev->batch
; 3234 :               && dev->ckdrdonly
; 3235 :         ))
; 3236 :         {
; 3237 :             /* NOT explicit batch utility read-only open: create new shadow file */
; 3238 :             if (cckd64_sf_new(dev) < 0)

  005d6	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005de	e8 00 00 00 00	 call	 cckd64_sf_new
  005e3	85 c0		 test	 eax, eax
  005e5	7d 0a		 jge	 SHORT $LN30@cckd64_sf_

; 3239 :                 return -1;

  005e7	b8 ff ff ff ff	 mov	 eax, -1
  005ec	e9 93 01 00 00	 jmp	 $LN1@cckd64_sf_
$LN30@cckd64_sf_:
$LN28@cckd64_sf_:
$LN27@cckd64_sf_:

; 3240 :         }
; 3241 :     }
; 3242 : 
; 3243 :     /* Re-open previous rdwr files rdonly */
; 3244 :     for (i = 0; i < cckd->sfn; i++)

  005f1	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  005fc	eb 10		 jmp	 SHORT $LN16@cckd64_sf_
$LN14@cckd64_sf_:
  005fe	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00605	ff c0		 inc	 eax
  00607	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN16@cckd64_sf_:
  0060e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00616	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00619	39 84 24 80 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00620	0f 8d 5c 01 00
	00		 jge	 $LN15@cckd64_sf_

; 3245 :     {
; 3246 :         if (cckd->open[i] == CCKD_OPEN_RO) continue;

  00626	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0062e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00636	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  0063e	83 f8 01	 cmp	 eax, 1
  00641	75 02		 jne	 SHORT $LN31@cckd64_sf_
  00643	eb b9		 jmp	 SHORT $LN14@cckd64_sf_
$LN31@cckd64_sf_:

; 3247 :         if (cckd64_open (dev, i, O_RDONLY|O_BINARY, 0) < 0)

  00645	45 33 c9	 xor	 r9d, r9d
  00648	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  0064e	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00655	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0065d	e8 00 00 00 00	 call	 cckd64_open
  00662	85 c0		 test	 eax, eax
  00664	0f 8d 13 01 00
	00		 jge	 $LN32@cckd64_sf_

; 3248 :         {
; 3249 :             // "%1d:%04X CCKD file[%d] %s: error re-opening readonly: %s"
; 3250 :             WRMSG (HHC00312, "E", LCSS_DEVNUM, i, cckd_sf_name(dev, i), strerror(errno));

  0066a	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00673	74 15		 je	 SHORT $LN42@cckd64_sf_
  00675	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0067d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00681	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv288[rsp], eax
  00688	eb 0b		 jmp	 SHORT $LN43@cckd64_sf_
$LN42@cckd64_sf_:
  0068a	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv288[rsp], 0
$LN43@cckd64_sf_:
  00695	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0069e	74 17		 je	 SHORT $LN44@cckd64_sf_
  006a0	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006a8	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  006ac	d1 f8		 sar	 eax, 1
  006ae	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv294[rsp], eax
  006b5	eb 0b		 jmp	 SHORT $LN45@cckd64_sf_
$LN44@cckd64_sf_:
  006b7	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv294[rsp], 0
$LN45@cckd64_sf_:
  006c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  006c8	8b 08		 mov	 ecx, DWORD PTR [rax]
  006ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  006d0	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv276[rsp], rax
  006d8	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  006df	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006e7	e8 00 00 00 00	 call	 cckd_sf_name
  006ec	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv280[rsp], rax
  006f4	b9 01 00 00 00	 mov	 ecx, 1
  006f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006ff	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv276[rsp]
  00707	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0070c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv280[rsp]
  00714	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00719	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00720	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00724	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv288[rsp]
  0072b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0072f	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv294[rsp]
  00736	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0073a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171193
  00741	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00746	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171194
  0074d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00752	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00757	41 b9 03 00 00
	00		 mov	 r9d, 3
  0075d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171195
  00764	ba b2 0c 00 00	 mov	 edx, 3250		; 00000cb2H
  00769	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171196
  00770	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3251 :             return -1;

  00776	b8 ff ff ff ff	 mov	 eax, -1
  0077b	eb 07		 jmp	 SHORT $LN1@cckd64_sf_
$LN32@cckd64_sf_:

; 3252 :         }
; 3253 :     }

  0077d	e9 7c fe ff ff	 jmp	 $LN14@cckd64_sf_
$LN15@cckd64_sf_:

; 3254 : 
; 3255 :     return 0;

  00782	33 c0		 xor	 eax, eax
$LN1@cckd64_sf_:

; 3256 : 
; 3257 : } /* end function cckd64_sf_init */

  00784	48 8b 8c 24 40
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0078c	48 33 cc	 xor	 rcx, rsp
  0078f	e8 00 00 00 00	 call	 __security_check_cookie
  00794	48 81 c4 58 04
	00 00		 add	 rsp, 1112		; 00000458H
  0079b	c3		 ret	 0
cckd64_sf_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
sz$ = 160
r$ = 164
vlen$ = 168
tv208 = 172
kl$ = 176
dl$ = 180
tv156 = 184
cckd$ = 192
rn$ = 200
__$ArrayPad$ = 208
dev$ = 288
buf$ = 296
trk$ = 304
len$ = 312
cckd64_validate PROC

; 3068 : {

$LN23:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	53		 push	 rbx
  00015	55		 push	 rbp
  00016	56		 push	 rsi
  00017	57		 push	 rdi
  00018	41 54		 push	 r12
  0001a	41 56		 push	 r14
  0001c	41 57		 push	 r15
  0001e	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002c	48 33 c4	 xor	 rax, rsp
  0002f	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3069 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 3070 : int             r;                      /* Record number             */
; 3071 : int             sz;                     /* Track size                */
; 3072 : int             vlen;                   /* Validation length         */
; 3073 : int             kl, dl;                 /* Key/Data lengths          */
; 3074 : CKD_RECHDR      rn;                     /* Record-n (r0, r1 ... rn)  */
; 3075 : 
; 3076 :     cckd = dev->cckd_ext;

  00037	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003f	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00046	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 3077 : 
; 3078 :     if (!buf || len < 0)

  0004e	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  00057	74 0a		 je	 SHORT $LN6@cckd64_val
  00059	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00061	7d 0a		 jge	 SHORT $LN5@cckd64_val
$LN6@cckd64_val:

; 3079 :         return -1;

  00063	b8 ff ff ff ff	 mov	 eax, -1
  00068	e9 ee 05 00 00	 jmp	 $LN1@cckd64_val
$LN5@cckd64_val:

; 3080 : 
; 3081 :     CCKD_TRACE( "validating %s %d len %d %2.2x%2.2x%2.2x%2.2x%2.2x "

  0006d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00075	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00078	83 e0 01	 and	 eax, 1
  0007b	85 c0		 test	 eax, eax
  0007d	74 11		 je	 SHORT $LN19@cckd64_val
  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171111
  00086	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv156[rsp], rax
  0008e	eb 0f		 jmp	 SHORT $LN20@cckd64_val
$LN19@cckd64_val:
  00090	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171112
  00097	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv156[rsp], rax
$LN20@cckd64_val:
  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 0c	 imul	 rax, rax, 12
  000a8	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  000b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	48 6b c9 0b	 imul	 rcx, rcx, 11
  000bd	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000c5	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000c9	ba 01 00 00 00	 mov	 edx, 1
  000ce	48 6b d2 0a	 imul	 rdx, rdx, 10
  000d2	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  000da	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  000df	41 b8 01 00 00
	00		 mov	 r8d, 1
  000e5	4d 6b c0 09	 imul	 r8, r8, 9
  000e9	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  000f1	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  000f6	41 b9 01 00 00
	00		 mov	 r9d, 1
  000fc	4d 6b c9 08	 imul	 r9, r9, 8
  00100	4c 8b 94 24 28
	01 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  00108	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  0010d	41 ba 01 00 00
	00		 mov	 r10d, 1
  00113	4d 6b d2 07	 imul	 r10, r10, 7
  00117	4c 8b 9c 24 28
	01 00 00	 mov	 r11, QWORD PTR buf$[rsp]
  0011f	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  00124	41 bb 01 00 00
	00		 mov	 r11d, 1
  0012a	4d 6b db 06	 imul	 r11, r11, 6
  0012e	48 8b 9c 24 28
	01 00 00	 mov	 rbx, QWORD PTR buf$[rsp]
  00136	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  0013b	41 bb 01 00 00
	00		 mov	 r11d, 1
  00141	4d 6b db 05	 imul	 r11, r11, 5
  00145	48 8b bc 24 28
	01 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  0014d	42 0f b6 3c 1f	 movzx	 edi, BYTE PTR [rdi+r11]
  00152	41 bb 01 00 00
	00		 mov	 r11d, 1
  00158	4d 6b db 04	 imul	 r11, r11, 4
  0015c	48 8b b4 24 28
	01 00 00	 mov	 rsi, QWORD PTR buf$[rsp]
  00164	42 0f b6 34 1e	 movzx	 esi, BYTE PTR [rsi+r11]
  00169	41 bb 01 00 00
	00		 mov	 r11d, 1
  0016f	4d 6b db 03	 imul	 r11, r11, 3
  00173	48 8b ac 24 28
	01 00 00	 mov	 rbp, QWORD PTR buf$[rsp]
  0017b	41 0f b6 2c 2b	 movzx	 ebp, BYTE PTR [r11+rbp]
  00180	41 bb 01 00 00
	00		 mov	 r11d, 1
  00186	4d 6b db 02	 imul	 r11, r11, 2
  0018a	4c 8b b4 24 28
	01 00 00	 mov	 r14, QWORD PTR buf$[rsp]
  00192	47 0f b6 1c 1e	 movzx	 r11d, BYTE PTR [r14+r11]
  00197	41 be 01 00 00
	00		 mov	 r14d, 1
  0019d	4d 6b f6 01	 imul	 r14, r14, 1
  001a1	4c 8b bc 24 28
	01 00 00	 mov	 r15, QWORD PTR buf$[rsp]
  001a9	47 0f b6 34 37	 movzx	 r14d, BYTE PTR [r15+r14]
  001ae	41 bf 01 00 00
	00		 mov	 r15d, 1
  001b4	4d 6b ff 00	 imul	 r15, r15, 0
  001b8	4c 8b a4 24 28
	01 00 00	 mov	 r12, QWORD PTR buf$[rsp]
  001c0	47 0f b6 3c 3c	 movzx	 r15d, BYTE PTR [r12+r15]
  001c5	89 84 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], eax
  001cc	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  001d3	89 94 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], edx
  001da	44 89 84 24 80
	00 00 00	 mov	 DWORD PTR [rsp+128], r8d
  001e2	44 89 4c 24 78	 mov	 DWORD PTR [rsp+120], r9d
  001e7	44 89 54 24 70	 mov	 DWORD PTR [rsp+112], r10d
  001ec	89 5c 24 68	 mov	 DWORD PTR [rsp+104], ebx
  001f0	89 7c 24 60	 mov	 DWORD PTR [rsp+96], edi
  001f4	89 74 24 58	 mov	 DWORD PTR [rsp+88], esi
  001f8	89 6c 24 50	 mov	 DWORD PTR [rsp+80], ebp
  001fc	44 89 5c 24 48	 mov	 DWORD PTR [rsp+72], r11d
  00201	44 89 74 24 40	 mov	 DWORD PTR [rsp+64], r14d
  00206	44 89 7c 24 38	 mov	 DWORD PTR [rsp+56], r15d
  0020b	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00212	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00216	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0021d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00221	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv156[rsp]
  00229	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171113
  00235	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0023d	ba 0e 0c 00 00	 mov	 edx, 3086		; 00000c0eH
  00242	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171114
  00249	e8 00 00 00 00	 call	 cckd_trace

; 3082 :                 "%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
; 3083 :                 cckd->ckddasd ? "trk" : "blkgrp", trk, len,
; 3084 :                 buf[0], buf[ 1], buf[ 2], buf[ 3], buf[4], // trkhdr
; 3085 :                 buf[5], buf[ 6], buf[ 7], buf[ 8],         // r0 (0-3)
; 3086 :                 buf[9], buf[10], buf[11], buf[12] );       // r0 (4-7)
; 3087 : 
; 3088 :     /* FBA dasd check */
; 3089 :     if (cckd->fbadasd)

  0024e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00256	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00259	d1 e8		 shr	 eax, 1
  0025b	83 e0 01	 and	 eax, 1
  0025e	85 c0		 test	 eax, eax
  00260	74 5c		 je	 SHORT $LN7@cckd64_val

; 3090 :     {
; 3091 :         if (!len || len == CKD_TRKHDR_SIZE + CFBA_BLKGRP_SIZE)

  00262	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  0026a	74 10		 je	 SHORT $LN9@cckd64_val
  0026c	48 63 84 24 38
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00274	48 3d 05 f0 00
	00		 cmp	 rax, 61445		; 0000f005H
  0027a	75 0c		 jne	 SHORT $LN8@cckd64_val
$LN9@cckd64_val:

; 3092 :             return len;

  0027c	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00283	e9 d3 03 00 00	 jmp	 $LN1@cckd64_val
$LN8@cckd64_val:

; 3093 :         CCKD_TRACE( "validation failed: bad length%s", "" );

  00288	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171118
  0028f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00294	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171119
  0029b	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  002a3	ba 15 0c 00 00	 mov	 edx, 3093		; 00000c15H
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171120
  002af	e8 00 00 00 00	 call	 cckd_trace

; 3094 :         return -1;

  002b4	b8 ff ff ff ff	 mov	 eax, -1
  002b9	e9 9d 03 00 00	 jmp	 $LN1@cckd64_val
$LN7@cckd64_val:

; 3095 :     }
; 3096 : 
; 3097 :     /* validate record 0 */
; 3098 : 
; 3099 :     memcpy( &rn, &buf[CKD_TRKHDR_SIZE], CKD_R0_SIZE );

  002be	b8 01 00 00 00	 mov	 eax, 1
  002c3	48 6b c0 05	 imul	 rax, rax, 5
  002c7	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  002cf	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  002d3	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR rn$[rsp], rax

; 3100 :     rn.cyl[0] &= 0x7f; /* fix for ovflow */

  002db	b8 01 00 00 00	 mov	 eax, 1
  002e0	48 6b c0 00	 imul	 rax, rax, 0
  002e4	0f b6 84 04 c8
	00 00 00	 movzx	 eax, BYTE PTR rn$[rsp+rax]
  002ec	83 e0 7f	 and	 eax, 127		; 0000007fH
  002ef	b9 01 00 00 00	 mov	 ecx, 1
  002f4	48 6b c9 00	 imul	 rcx, rcx, 0
  002f8	88 84 0c c8 00
	00 00		 mov	 BYTE PTR rn$[rsp+rcx], al

; 3101 : 
; 3102 :     if (0
; 3103 :         || rn.rec  != 0
; 3104 :         || rn.klen != 0
; 3105 :         || fetch_hw( rn.dlen ) != CKD_R0_DLEN

  002ff	33 c0		 xor	 eax, eax
  00301	85 c0		 test	 eax, eax
  00303	75 35		 jne	 SHORT $LN11@cckd64_val
  00305	0f b6 84 24 cc
	00 00 00	 movzx	 eax, BYTE PTR rn$[rsp+4]
  0030d	85 c0		 test	 eax, eax
  0030f	75 29		 jne	 SHORT $LN11@cckd64_val
  00311	0f b6 84 24 cd
	00 00 00	 movzx	 eax, BYTE PTR rn$[rsp+5]
  00319	85 c0		 test	 eax, eax
  0031b	75 1d		 jne	 SHORT $LN11@cckd64_val
  0031d	48 8d 8c 24 ce
	00 00 00	 lea	 rcx, QWORD PTR rn$[rsp+6]
  00325	e8 00 00 00 00	 call	 fetch_hw_noswap
  0032a	0f b7 c8	 movzx	 ecx, ax
  0032d	e8 00 00 00 00	 call	 _byteswap_ushort
  00332	0f b7 c0	 movzx	 eax, ax
  00335	83 f8 08	 cmp	 eax, 8
  00338	74 36		 je	 SHORT $LN10@cckd64_val
$LN11@cckd64_val:

; 3106 :     )
; 3107 :     {
; 3108 :         CCKD_TRACE( "validation failed: bad r0%s", "" );

  0033a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171123
  00341	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00346	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171124
  0034d	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00355	ba 24 0c 00 00	 mov	 edx, 3108		; 00000c24H
  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171125
  00361	e8 00 00 00 00	 call	 cckd_trace

; 3109 :         return -1;

  00366	b8 ff ff ff ff	 mov	 eax, -1
  0036b	e9 eb 02 00 00	 jmp	 $LN1@cckd64_val
$LN10@cckd64_val:

; 3110 :     }
; 3111 : 
; 3112 :     /* validate records 1 thru n */
; 3113 : 
; 3114 :     vlen = len > 0 ? len : dev->ckdtrksz;

  00370	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  00378	7e 10		 jle	 SHORT $LN21@cckd64_val
  0037a	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00381	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv208[rsp], eax
  00388	eb 15		 jmp	 SHORT $LN22@cckd64_val
$LN21@cckd64_val:
  0038a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00392	8b 80 c4 12 00
	00		 mov	 eax, DWORD PTR [rax+4804]
  00398	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv208[rsp], eax
$LN22@cckd64_val:
  0039f	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv208[rsp]
  003a6	89 84 24 a8 00
	00 00		 mov	 DWORD PTR vlen$[rsp], eax

; 3115 : 
; 3116 :     for (r = 1, sz = CKD_TRKHDR_SIZE + (CKD_R0_SIZE + CKD_R0_DLEN);

  003ad	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR r$[rsp], 1
  003b8	c7 84 24 a0 00
	00 00 15 00 00
	00		 mov	 DWORD PTR sz$[rsp], 21
  003c3	eb 3a		 jmp	 SHORT $LN4@cckd64_val
$LN2@cckd64_val:

; 3118 :         sz += CKD_RECHDR_SIZE + kl + dl, r++)

  003c5	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR kl$[rsp]
  003cd	48 63 8c 24 b4
	00 00 00	 movsxd	 rcx, DWORD PTR dl$[rsp]
  003d5	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  003da	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR sz$[rsp]
  003e2	48 03 c8	 add	 rcx, rax
  003e5	48 8b c1	 mov	 rax, rcx
  003e8	89 84 24 a0 00
	00 00		 mov	 DWORD PTR sz$[rsp], eax
  003ef	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR r$[rsp]
  003f6	ff c0		 inc	 eax
  003f8	89 84 24 a4 00
	00 00		 mov	 DWORD PTR r$[rsp], eax
$LN4@cckd64_val:

; 3117 :         sz +  CKD_ENDTRK_SIZE <= vlen;

  003ff	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR sz$[rsp]
  00407	48 83 c0 08	 add	 rax, 8
  0040b	48 63 8c 24 a8
	00 00 00	 movsxd	 rcx, DWORD PTR vlen$[rsp]
  00413	48 3b c1	 cmp	 rax, rcx
  00416	0f 8f c8 01 00
	00		 jg	 $LN3@cckd64_val

; 3119 :     {
; 3120 :         memcpy( &rn, &buf[sz], CKD_RECHDR_SIZE );

  0041c	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR sz$[rsp]
  00424	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0042c	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00430	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR rn$[rsp], rax

; 3121 : 
; 3122 :         if (memcmp( &rn, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  00438	41 b8 08 00 00
	00		 mov	 r8d, 8
  0043e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  00445	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR rn$[rsp]
  0044d	e8 00 00 00 00	 call	 memcmp
  00452	85 c0		 test	 eax, eax
  00454	75 05		 jne	 SHORT $LN12@cckd64_val

; 3123 :             break;

  00456	e9 89 01 00 00	 jmp	 $LN3@cckd64_val
$LN12@cckd64_val:

; 3124 : 
; 3125 :         kl = rn.klen;

  0045b	0f b6 84 24 cd
	00 00 00	 movzx	 eax, BYTE PTR rn$[rsp+5]
  00463	89 84 24 b0 00
	00 00		 mov	 DWORD PTR kl$[rsp], eax

; 3126 :         dl = fetch_hw( rn.dlen );

  0046a	48 8d 8c 24 ce
	00 00 00	 lea	 rcx, QWORD PTR rn$[rsp+6]
  00472	e8 00 00 00 00	 call	 fetch_hw_noswap
  00477	0f b7 c8	 movzx	 ecx, ax
  0047a	e8 00 00 00 00	 call	 _byteswap_ushort
  0047f	0f b7 c0	 movzx	 eax, ax
  00482	89 84 24 b4 00
	00 00		 mov	 DWORD PTR dl$[rsp], eax

; 3127 : 
; 3128 :         if (rn.rec == 0 || sz + CKD_RECHDR_SIZE + kl + dl >= vlen)

  00489	0f b6 84 24 cc
	00 00 00	 movzx	 eax, BYTE PTR rn$[rsp+4]
  00491	85 c0		 test	 eax, eax
  00493	74 31		 je	 SHORT $LN14@cckd64_val
  00495	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR sz$[rsp]
  0049d	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR kl$[rsp]
  004a5	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  004aa	48 63 8c 24 b4
	00 00 00	 movsxd	 rcx, DWORD PTR dl$[rsp]
  004b2	48 03 c1	 add	 rax, rcx
  004b5	48 63 8c 24 a8
	00 00 00	 movsxd	 rcx, DWORD PTR vlen$[rsp]
  004bd	48 3b c1	 cmp	 rax, rcx
  004c0	0f 8c 19 01 00
	00		 jl	 $LN13@cckd64_val
$LN14@cckd64_val:

; 3129 :         {
; 3130 :             CCKD_TRACE( "validation failed: bad r%d "

  004c6	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sz$[rsp]
  004cd	83 c0 07	 add	 eax, 7
  004d0	48 98		 cdqe
  004d2	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  004da	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004de	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR sz$[rsp]
  004e5	83 c1 06	 add	 ecx, 6
  004e8	48 63 c9	 movsxd	 rcx, ecx
  004eb	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  004f3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  004f7	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR sz$[rsp]
  004fe	83 c2 05	 add	 edx, 5
  00501	48 63 d2	 movsxd	 rdx, edx
  00504	48 8b 9c 24 28
	01 00 00	 mov	 rbx, QWORD PTR buf$[rsp]
  0050c	0f b6 14 13	 movzx	 edx, BYTE PTR [rbx+rdx]
  00510	8b 9c 24 a0 00
	00 00		 mov	 ebx, DWORD PTR sz$[rsp]
  00517	83 c3 04	 add	 ebx, 4
  0051a	48 63 db	 movsxd	 rbx, ebx
  0051d	48 8b bc 24 28
	01 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  00525	0f b6 1c 1f	 movzx	 ebx, BYTE PTR [rdi+rbx]
  00529	8b bc 24 a0 00
	00 00		 mov	 edi, DWORD PTR sz$[rsp]
  00530	83 c7 03	 add	 edi, 3
  00533	48 63 ff	 movsxd	 rdi, edi
  00536	48 8b b4 24 28
	01 00 00	 mov	 rsi, QWORD PTR buf$[rsp]
  0053e	0f b6 3c 3e	 movzx	 edi, BYTE PTR [rsi+rdi]
  00542	8b b4 24 a0 00
	00 00		 mov	 esi, DWORD PTR sz$[rsp]
  00549	83 c6 02	 add	 esi, 2
  0054c	48 63 f6	 movsxd	 rsi, esi
  0054f	48 8b ac 24 28
	01 00 00	 mov	 rbp, QWORD PTR buf$[rsp]
  00557	0f b6 34 2e	 movzx	 esi, BYTE PTR [rsi+rbp]
  0055b	8b ac 24 a0 00
	00 00		 mov	 ebp, DWORD PTR sz$[rsp]
  00562	ff c5		 inc	 ebp
  00564	48 63 ed	 movsxd	 rbp, ebp
  00567	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  0056f	41 0f b6 2c 28	 movzx	 ebp, BYTE PTR [r8+rbp]
  00574	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR sz$[rsp]
  0057c	4d 63 c0	 movsxd	 r8, r8d
  0057f	4c 8b 8c 24 28
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  00587	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  0058c	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00590	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00594	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  00598	89 5c 24 48	 mov	 DWORD PTR [rsp+72], ebx
  0059c	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  005a0	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  005a4	89 6c 24 30	 mov	 DWORD PTR [rsp+48], ebp
  005a8	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  005ad	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR r$[rsp]
  005b4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005b8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171129
  005bf	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  005c7	ba 3d 0c 00 00	 mov	 edx, 3133		; 00000c3dH
  005cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171130
  005d3	e8 00 00 00 00	 call	 cckd_trace

; 3131 :                         "%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",
; 3132 :                         r, buf[sz+0], buf[sz+1], buf[sz+2], buf[sz+3],
; 3133 :                            buf[sz+4], buf[sz+5], buf[sz+6], buf[sz+7] );
; 3134 :              return -1;

  005d8	b8 ff ff ff ff	 mov	 eax, -1
  005dd	eb 7c		 jmp	 SHORT $LN1@cckd64_val
$LN13@cckd64_val:

; 3135 :         }
; 3136 :     }

  005df	e9 e1 fd ff ff	 jmp	 $LN2@cckd64_val
$LN3@cckd64_val:

; 3137 : 
; 3138 :     sz += CKD_ENDTRK_SIZE;

  005e4	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR sz$[rsp]
  005ec	48 83 c0 08	 add	 rax, 8
  005f0	89 84 24 a0 00
	00 00		 mov	 DWORD PTR sz$[rsp], eax

; 3139 : 
; 3140 :     if ((len > 0 && sz != len) || sz > vlen)

  005f7	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  005ff	7e 10		 jle	 SHORT $LN17@cckd64_val
  00601	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00608	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR sz$[rsp], eax
  0060f	75 10		 jne	 SHORT $LN16@cckd64_val
$LN17@cckd64_val:
  00611	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR vlen$[rsp]
  00618	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR sz$[rsp], eax
  0061f	7e 33		 jle	 SHORT $LN15@cckd64_val
$LN16@cckd64_val:

; 3141 :     {
; 3142 :         CCKD_TRACE( "validation failed: no eot%s", "" );

  00621	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171134
  00628	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0062d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171135
  00634	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0063c	ba 46 0c 00 00	 mov	 edx, 3142		; 00000c46H
  00641	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171136
  00648	e8 00 00 00 00	 call	 cckd_trace

; 3143 :         return -1;

  0064d	b8 ff ff ff ff	 mov	 eax, -1
  00652	eb 07		 jmp	 SHORT $LN1@cckd64_val
$LN15@cckd64_val:

; 3144 :     }
; 3145 : 
; 3146 :     return sz;

  00654	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sz$[rsp]
$LN1@cckd64_val:

; 3147 : 
; 3148 : } /* end function cckd64_validate */

  0065b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00663	48 33 cc	 xor	 rcx, rsp
  00666	e8 00 00 00 00	 call	 __security_check_cookie
  0066b	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  00672	41 5f		 pop	 r15
  00674	41 5e		 pop	 r14
  00676	41 5c		 pop	 r12
  00678	5f		 pop	 rdi
  00679	5e		 pop	 rsi
  0067a	5d		 pop	 rbp
  0067b	5b		 pop	 rbx
  0067c	c3		 ret	 0
cckd64_validate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
badcomp$ = 160
t$ = 164
cckd$ = 168
cyl$ = 176
head$ = 180
tv170 = 184
tv176 = 188
tv253 = 192
tv259 = 196
tv313 = 200
tv319 = 204
tv372 = 208
tv378 = 212
tv141 = 216
tv145 = 220
tv149 = 224
tv153 = 228
tv157 = 232
tv224 = 236
tv228 = 240
tv232 = 244
tv236 = 248
tv240 = 252
tv332 = 256
tv336 = 260
tv340 = 264
tv344 = 268
tv348 = 272
tv138 = 276
tv296 = 280
tv301 = 288
tv355 = 296
tv360 = 304
tv160 = 312
tv243 = 320
tv389 = 328
tv288 = 336
tv303 = 344
tv362 = 352
dev$ = 384
buf$ = 392
trk$ = 400
cckd64_cchh PROC

; 2982 : {

$LN44:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H

; 2983 : CCKD64_EXT*     cckd;                   /* -> cckd extension         */
; 2984 : U16             cyl;                    /* Cylinder                  */
; 2985 : U16             head;                   /* Head                      */
; 2986 : int             t;                      /* Calculated track          */
; 2987 : BYTE            badcomp=0;              /* 1=Unsupported compression */

  00016	c6 84 24 a0 00
	00 00 00	 mov	 BYTE PTR badcomp$[rsp], 0

; 2988 : 
; 2989 :     cckd = dev->cckd_ext;

  0001e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0002d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 2990 : 
; 2991 :     /* CKD dasd header verification */
; 2992 :     if (cckd->ckddasd)

  00035	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0003d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00040	83 e0 01	 and	 eax, 1
  00043	85 c0		 test	 eax, eax
  00045	0f 84 76 03 00
	00		 je	 $LN2@cckd64_cch

; 2993 :     {
; 2994 :         cyl  = fetch_hw( buf + 1 );

  0004b	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00053	48 ff c0	 inc	 rax
  00056	48 8b c8	 mov	 rcx, rax
  00059	e8 00 00 00 00	 call	 fetch_hw_noswap
  0005e	0f b7 c8	 movzx	 ecx, ax
  00061	e8 00 00 00 00	 call	 _byteswap_ushort
  00066	66 89 84 24 b0
	00 00 00	 mov	 WORD PTR cyl$[rsp], ax

; 2995 :         head = fetch_hw( buf + 3 );

  0006e	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00076	48 83 c0 03	 add	 rax, 3
  0007a	48 8b c8	 mov	 rcx, rax
  0007d	e8 00 00 00 00	 call	 fetch_hw_noswap
  00082	0f b7 c8	 movzx	 ecx, ax
  00085	e8 00 00 00 00	 call	 _byteswap_ushort
  0008a	66 89 84 24 b4
	00 00 00	 mov	 WORD PTR head$[rsp], ax

; 2996 :         t    = cyl * dev->ckdheads + head;

  00092	0f b7 84 24 b0
	00 00 00	 movzx	 eax, WORD PTR cyl$[rsp]
  0009a	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a2	0f af 81 c0 12
	00 00		 imul	 eax, DWORD PTR [rcx+4800]
  000a9	0f b7 8c 24 b4
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  000b1	03 c1		 add	 eax, ecx
  000b3	89 84 24 a4 00
	00 00		 mov	 DWORD PTR t$[rsp], eax

; 2997 : 
; 2998 :         if (1
; 2999 :             && cyl  < dev->ckdcyls
; 3000 :             && head < dev->ckdheads
; 3001 :             && (trk == -1 || t == trk)

  000ba	33 c0		 xor	 eax, eax
  000bc	83 f8 01	 cmp	 eax, 1
  000bf	0f 84 f7 02 00
	00		 je	 $LN4@cckd64_cch
  000c5	0f b7 84 24 b0
	00 00 00	 movzx	 eax, WORD PTR cyl$[rsp]
  000cd	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000d5	3b 81 b8 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4792]
  000db	0f 8d db 02 00
	00		 jge	 $LN4@cckd64_cch
  000e1	0f b7 84 24 b4
	00 00 00	 movzx	 eax, WORD PTR head$[rsp]
  000e9	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000f1	3b 81 c0 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4800]
  000f7	0f 8d bf 02 00
	00		 jge	 $LN4@cckd64_cch
  000fd	83 bc 24 90 01
	00 00 ff	 cmp	 DWORD PTR trk$[rsp], -1
  00105	74 14		 je	 SHORT $LN5@cckd64_cch
  00107	8b 84 24 90 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0010e	39 84 24 a4 00
	00 00		 cmp	 DWORD PTR t$[rsp], eax
  00115	0f 85 a1 02 00
	00		 jne	 $LN4@cckd64_cch
$LN5@cckd64_cch:

; 3002 :         )
; 3003 :         {
; 3004 :             if (buf[0] & ~cckdblk.comps)

  0011b	b8 01 00 00 00	 mov	 eax, 1
  00120	48 6b c0 00	 imul	 rax, rax, 0
  00124	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0012c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00130	0f b6 0d 1c 00
	00 00		 movzx	 ecx, BYTE PTR cckdblk+28
  00137	f7 d1		 not	 ecx
  00139	23 c1		 and	 eax, ecx
  0013b	85 c0		 test	 eax, eax
  0013d	0f 84 3f 02 00
	00		 je	 $LN6@cckd64_cch

; 3005 :             {
; 3006 :                 if (buf[0] & ~CCKD_COMPRESS_MASK)

  00143	b8 01 00 00 00	 mov	 eax, 1
  00148	48 6b c0 00	 imul	 rax, rax, 0
  0014c	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00154	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00158	83 e0 fc	 and	 eax, -4
  0015b	85 c0		 test	 eax, eax
  0015d	0f 84 1f 02 00
	00		 je	 $LN7@cckd64_cch

; 3007 :                 {
; 3008 :                     if (cckdblk.bytemsgs++ < 10)

  00163	8b 05 18 03 00
	00		 mov	 eax, DWORD PTR cckdblk+792
  00169	89 84 24 14 01
	00 00		 mov	 DWORD PTR tv138[rsp], eax
  00170	8b 05 18 03 00
	00		 mov	 eax, DWORD PTR cckdblk+792
  00176	ff c0		 inc	 eax
  00178	89 05 18 03 00
	00		 mov	 DWORD PTR cckdblk+792, eax
  0017e	83 bc 24 14 01
	00 00 0a	 cmp	 DWORD PTR tv138[rsp], 10
  00186	0f 8d ca 01 00
	00		 jge	 $LN8@cckd64_cch

; 3009 :                         // "%1d:%04X CCKD file[%d] %s: invalid byte 0 trk %d, buf %2.2x%2.2x%2.2x%2.2x%2.2x"
; 3010 :                         WRMSG( HHC00307, "E", LCSS_DEVNUM, cckd->sfn,

  0018c	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00195	74 15		 je	 SHORT $LN20@cckd64_cch
  00197	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001a3	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv170[rsp], eax
  001aa	eb 0b		 jmp	 SHORT $LN21@cckd64_cch
$LN20@cckd64_cch:
  001ac	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv170[rsp], 0
$LN21@cckd64_cch:
  001b7	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001c0	74 17		 je	 SHORT $LN22@cckd64_cch
  001c2	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ca	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001ce	d1 f8		 sar	 eax, 1
  001d0	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv176[rsp], eax
  001d7	eb 0b		 jmp	 SHORT $LN23@cckd64_cch
$LN22@cckd64_cch:
  001d9	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv176[rsp], 0
$LN23@cckd64_cch:
  001e4	b8 01 00 00 00	 mov	 eax, 1
  001e9	48 6b c0 04	 imul	 rax, rax, 4
  001ed	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  001f5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001f9	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv141[rsp], eax
  00200	b9 01 00 00 00	 mov	 ecx, 1
  00205	48 6b c9 03	 imul	 rcx, rcx, 3
  00209	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00211	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00215	89 8c 24 dc 00
	00 00		 mov	 DWORD PTR tv145[rsp], ecx
  0021c	ba 01 00 00 00	 mov	 edx, 1
  00221	48 6b d2 02	 imul	 rdx, rdx, 2
  00225	4c 8b 84 24 88
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  0022d	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00232	89 94 24 e0 00
	00 00		 mov	 DWORD PTR tv149[rsp], edx
  00239	41 b8 01 00 00
	00		 mov	 r8d, 1
  0023f	4d 6b c0 01	 imul	 r8, r8, 1
  00243	4c 8b 8c 24 88
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  0024b	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00250	44 89 84 24 e4
	00 00 00	 mov	 DWORD PTR tv153[rsp], r8d
  00258	41 b9 01 00 00
	00		 mov	 r9d, 1
  0025e	4d 6b c9 00	 imul	 r9, r9, 0
  00262	4c 8b 94 24 88
	01 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  0026a	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  0026f	44 89 8c 24 e8
	00 00 00	 mov	 DWORD PTR tv157[rsp], r9d
  00277	4c 8b 94 24 a8
	00 00 00	 mov	 r10, QWORD PTR cckd$[rsp]
  0027f	41 8b 52 3c	 mov	 edx, DWORD PTR [r10+60]
  00283	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0028b	e8 00 00 00 00	 call	 cckd_sf_name
  00290	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv160[rsp], rax
  00298	b9 01 00 00 00	 mov	 ecx, 1
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a3	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv141[rsp]
  002aa	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  002b1	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv145[rsp]
  002b8	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  002bc	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv149[rsp]
  002c3	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  002c7	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv153[rsp]
  002ce	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  002d2	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv157[rsp]
  002d9	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  002dd	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR t$[rsp]
  002e4	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  002e8	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv160[rsp]
  002f0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002f5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  002fd	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00300	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00304	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv170[rsp]
  0030b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0030f	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv176[rsp]
  00316	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0031a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171037
  00321	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171038
  0032d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00332	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00337	41 b9 03 00 00
	00		 mov	 r9d, 3
  0033d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171039
  00344	ba c3 0b 00 00	 mov	 edx, 3011		; 00000bc3H
  00349	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171040
  00350	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@cckd64_cch:

; 3011 :                             cckd_sf_name( dev, cckd->sfn ), t, buf[0],buf[1],buf[2],buf[3],buf[4]);
; 3012 :                     buf[0] &= CCKD_COMPRESS_MASK;

  00356	b8 01 00 00 00	 mov	 eax, 1
  0035b	48 6b c0 00	 imul	 rax, rax, 0
  0035f	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00367	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0036b	83 e0 03	 and	 eax, 3
  0036e	b9 01 00 00 00	 mov	 ecx, 1
  00373	48 6b c9 00	 imul	 rcx, rcx, 0
  00377	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0037f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN7@cckd64_cch:
$LN6@cckd64_cch:

; 3013 :                 }
; 3014 :             }
; 3015 :             if (buf[0] & ~cckdblk.comps)

  00382	b8 01 00 00 00	 mov	 eax, 1
  00387	48 6b c0 00	 imul	 rax, rax, 0
  0038b	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00393	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00397	0f b6 0d 1c 00
	00 00		 movzx	 ecx, BYTE PTR cckdblk+28
  0039e	f7 d1		 not	 ecx
  003a0	23 c1		 and	 eax, ecx
  003a2	85 c0		 test	 eax, eax
  003a4	74 0a		 je	 SHORT $LN9@cckd64_cch

; 3016 :                 badcomp = 1;

  003a6	c6 84 24 a0 00
	00 00 01	 mov	 BYTE PTR badcomp$[rsp], 1
  003ae	eb 0c		 jmp	 SHORT $LN10@cckd64_cch
$LN9@cckd64_cch:

; 3017 :             else
; 3018 :                 return t;

  003b0	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR t$[rsp]
  003b7	e9 13 07 00 00	 jmp	 $LN1@cckd64_cch
$LN10@cckd64_cch:
$LN4@cckd64_cch:

; 3019 :         }
; 3020 :     }

  003bc	e9 d2 02 00 00	 jmp	 $LN3@cckd64_cch
$LN2@cckd64_cch:

; 3021 :     /* FBA dasd header verification */
; 3022 :     else
; 3023 :     {
; 3024 :         t = fetch_fw (buf + 1);

  003c1	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  003c9	48 ff c0	 inc	 rax
  003cc	48 8b c8	 mov	 rcx, rax
  003cf	e8 00 00 00 00	 call	 fetch_fw_noswap
  003d4	8b c8		 mov	 ecx, eax
  003d6	e8 00 00 00 00	 call	 _byteswap_ulong
  003db	89 84 24 a4 00
	00 00		 mov	 DWORD PTR t$[rsp], eax

; 3025 :         if (t < dev->fbanumblk && (trk == -1 || t == trk))

  003e2	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003ea	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  003f0	39 84 24 a4 00
	00 00		 cmp	 DWORD PTR t$[rsp], eax
  003f7	0f 8d 96 02 00
	00		 jge	 $LN11@cckd64_cch
  003fd	83 bc 24 90 01
	00 00 ff	 cmp	 DWORD PTR trk$[rsp], -1
  00405	74 14		 je	 SHORT $LN12@cckd64_cch
  00407	8b 84 24 90 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0040e	39 84 24 a4 00
	00 00		 cmp	 DWORD PTR t$[rsp], eax
  00415	0f 85 78 02 00
	00		 jne	 $LN11@cckd64_cch
$LN12@cckd64_cch:

; 3026 :         {
; 3027 :             if (buf[0] & ~cckdblk.comps)

  0041b	b8 01 00 00 00	 mov	 eax, 1
  00420	48 6b c0 00	 imul	 rax, rax, 0
  00424	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0042c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00430	0f b6 0d 1c 00
	00 00		 movzx	 ecx, BYTE PTR cckdblk+28
  00437	f7 d1		 not	 ecx
  00439	23 c1		 and	 eax, ecx
  0043b	85 c0		 test	 eax, eax
  0043d	0f 84 16 02 00
	00		 je	 $LN13@cckd64_cch

; 3028 :             {
; 3029 :                 if (buf[0] & ~CCKD_COMPRESS_MASK)

  00443	b8 01 00 00 00	 mov	 eax, 1
  00448	48 6b c0 00	 imul	 rax, rax, 0
  0044c	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00454	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00458	83 e0 fc	 and	 eax, -4
  0045b	85 c0		 test	 eax, eax
  0045d	0f 84 f6 01 00
	00		 je	 $LN14@cckd64_cch

; 3030 :                 {
; 3031 :                     // "%1d:%04X CCKD file[%d] %s: invalid byte 0 blkgrp %d, buf %2.2x%2.2x%2.2x%2.2x%2.2x"
; 3032 :                     WRMSG( HHC00308, "E", LCSS_DEVNUM, cckd->sfn,

  00463	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0046c	74 15		 je	 SHORT $LN24@cckd64_cch
  0046e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00476	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0047a	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv253[rsp], eax
  00481	eb 0b		 jmp	 SHORT $LN25@cckd64_cch
$LN24@cckd64_cch:
  00483	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv253[rsp], 0
$LN25@cckd64_cch:
  0048e	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00497	74 17		 je	 SHORT $LN26@cckd64_cch
  00499	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004a1	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  004a5	d1 f8		 sar	 eax, 1
  004a7	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv259[rsp], eax
  004ae	eb 0b		 jmp	 SHORT $LN27@cckd64_cch
$LN26@cckd64_cch:
  004b0	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv259[rsp], 0
$LN27@cckd64_cch:
  004bb	b8 01 00 00 00	 mov	 eax, 1
  004c0	48 6b c0 04	 imul	 rax, rax, 4
  004c4	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  004cc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004d0	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv224[rsp], eax
  004d7	b9 01 00 00 00	 mov	 ecx, 1
  004dc	48 6b c9 03	 imul	 rcx, rcx, 3
  004e0	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  004e8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  004ec	89 8c 24 f0 00
	00 00		 mov	 DWORD PTR tv228[rsp], ecx
  004f3	ba 01 00 00 00	 mov	 edx, 1
  004f8	48 6b d2 02	 imul	 rdx, rdx, 2
  004fc	4c 8b 84 24 88
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  00504	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00509	89 94 24 f4 00
	00 00		 mov	 DWORD PTR tv232[rsp], edx
  00510	41 b8 01 00 00
	00		 mov	 r8d, 1
  00516	4d 6b c0 01	 imul	 r8, r8, 1
  0051a	4c 8b 8c 24 88
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  00522	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00527	44 89 84 24 f8
	00 00 00	 mov	 DWORD PTR tv236[rsp], r8d
  0052f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00535	4d 6b c9 00	 imul	 r9, r9, 0
  00539	4c 8b 94 24 88
	01 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  00541	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  00546	44 89 8c 24 fc
	00 00 00	 mov	 DWORD PTR tv240[rsp], r9d
  0054e	4c 8b 94 24 a8
	00 00 00	 mov	 r10, QWORD PTR cckd$[rsp]
  00556	41 8b 52 3c	 mov	 edx, DWORD PTR [r10+60]
  0055a	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00562	e8 00 00 00 00	 call	 cckd_sf_name
  00567	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv243[rsp], rax
  0056f	b9 01 00 00 00	 mov	 ecx, 1
  00574	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0057a	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv224[rsp]
  00581	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  00588	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv228[rsp]
  0058f	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00593	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv232[rsp]
  0059a	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  0059e	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv236[rsp]
  005a5	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  005a9	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv240[rsp]
  005b0	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  005b4	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR t$[rsp]
  005bb	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  005bf	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv243[rsp]
  005c7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005cc	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  005d4	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  005d7	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  005db	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv253[rsp]
  005e2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005e6	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv259[rsp]
  005ed	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171047
  005f8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171048
  00604	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00609	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0060e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00614	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171049
  0061b	ba d9 0b 00 00	 mov	 edx, 3033		; 00000bd9H
  00620	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171050
  00627	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3033 :                             cckd_sf_name( dev, cckd->sfn ), t, buf[0],buf[1],buf[2],buf[3],buf[4]);
; 3034 :                     buf[0] &= CCKD_COMPRESS_MASK;

  0062d	b8 01 00 00 00	 mov	 eax, 1
  00632	48 6b c0 00	 imul	 rax, rax, 0
  00636	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0063e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00642	83 e0 03	 and	 eax, 3
  00645	b9 01 00 00 00	 mov	 ecx, 1
  0064a	48 6b c9 00	 imul	 rcx, rcx, 0
  0064e	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00656	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN14@cckd64_cch:
$LN13@cckd64_cch:

; 3035 :                 }
; 3036 :             }
; 3037 :             if (buf[0] & ~cckdblk.comps)

  00659	b8 01 00 00 00	 mov	 eax, 1
  0065e	48 6b c0 00	 imul	 rax, rax, 0
  00662	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0066a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0066e	0f b6 0d 1c 00
	00 00		 movzx	 ecx, BYTE PTR cckdblk+28
  00675	f7 d1		 not	 ecx
  00677	23 c1		 and	 eax, ecx
  00679	85 c0		 test	 eax, eax
  0067b	74 0a		 je	 SHORT $LN15@cckd64_cch

; 3038 :                 badcomp = 1;

  0067d	c6 84 24 a0 00
	00 00 01	 mov	 BYTE PTR badcomp$[rsp], 1
  00685	eb 0c		 jmp	 SHORT $LN16@cckd64_cch
$LN15@cckd64_cch:

; 3039 :             else
; 3040 :                 return t;

  00687	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR t$[rsp]
  0068e	e9 3c 04 00 00	 jmp	 $LN1@cckd64_cch
$LN16@cckd64_cch:
$LN11@cckd64_cch:
$LN3@cckd64_cch:

; 3041 :         }
; 3042 :     }
; 3043 : 
; 3044 :     if (badcomp)

  00693	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR badcomp$[rsp]
  0069b	85 c0		 test	 eax, eax
  0069d	0f 84 c4 01 00
	00		 je	 $LN17@cckd64_cch

; 3045 :     {
; 3046 :         // "%1d:%04X CCKD file[%d] %s: invalid %s hdr %s %d: %s compression unsupported"
; 3047 :         WRMSG( HHC00309, "E", LCSS_DEVNUM, cckd->sfn, cckd_sf_name( dev, cckd->sfn ),

  006a3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  006ab	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  006ae	83 e0 01	 and	 eax, 1
  006b1	85 c0		 test	 eax, eax
  006b3	74 11		 je	 SHORT $LN28@cckd64_cch
  006b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171055
  006bc	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv296[rsp], rax
  006c4	eb 0f		 jmp	 SHORT $LN29@cckd64_cch
$LN28@cckd64_cch:
  006c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171056
  006cd	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv296[rsp], rax
$LN29@cckd64_cch:
  006d5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  006dd	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  006e0	83 e0 01	 and	 eax, 1
  006e3	85 c0		 test	 eax, eax
  006e5	74 11		 je	 SHORT $LN30@cckd64_cch
  006e7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171057
  006ee	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv301[rsp], rax
  006f6	eb 0f		 jmp	 SHORT $LN31@cckd64_cch
$LN30@cckd64_cch:
  006f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171058
  006ff	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv301[rsp], rax
$LN31@cckd64_cch:
  00707	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00710	74 15		 je	 SHORT $LN32@cckd64_cch
  00712	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0071a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0071e	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv313[rsp], eax
  00725	eb 0b		 jmp	 SHORT $LN33@cckd64_cch
$LN32@cckd64_cch:
  00727	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv313[rsp], 0
$LN33@cckd64_cch:
  00732	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0073b	74 17		 je	 SHORT $LN34@cckd64_cch
  0073d	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00745	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00749	d1 f8		 sar	 eax, 1
  0074b	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv319[rsp], eax
  00752	eb 0b		 jmp	 SHORT $LN35@cckd64_cch
$LN34@cckd64_cch:
  00754	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv319[rsp], 0
$LN35@cckd64_cch:
  0075f	b8 01 00 00 00	 mov	 eax, 1
  00764	48 6b c0 00	 imul	 rax, rax, 0
  00768	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00770	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00774	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv288[rsp], rax
  0077c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compname
  00783	48 89 8c 24 48
	01 00 00	 mov	 QWORD PTR tv389[rsp], rcx
  0078b	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR cckd$[rsp]
  00793	8b 52 3c	 mov	 edx, DWORD PTR [rdx+60]
  00796	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0079e	e8 00 00 00 00	 call	 cckd_sf_name
  007a3	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv303[rsp], rax
  007ab	b9 01 00 00 00	 mov	 ecx, 1
  007b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007b6	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR tv389[rsp]
  007be	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv288[rsp]
  007c6	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  007ca	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  007cf	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR t$[rsp]
  007d6	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  007da	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv296[rsp]
  007e2	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  007e7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv301[rsp]
  007ef	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  007f4	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv303[rsp]
  007fc	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00801	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00809	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  0080c	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00810	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv313[rsp]
  00817	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0081b	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv319[rsp]
  00822	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00826	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171059
  0082d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00832	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171060
  00839	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0083e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00843	41 b9 03 00 00
	00		 mov	 r9d, 3
  00849	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171061
  00850	ba e9 0b 00 00	 mov	 edx, 3049		; 00000be9H
  00855	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171062
  0085c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3048 :                 cckd->ckddasd ? "trk" : "blk",
; 3049 :                 cckd->ckddasd ? "trk" : "blk", t, compname[buf[0]]);
; 3050 :     }

  00862	e9 63 02 00 00	 jmp	 $LN18@cckd64_cch
$LN17@cckd64_cch:

; 3051 :     else
; 3052 :     {
; 3053 :         // "%1d:%04X CCKD file[%d] %s: invalid %s hdr %s %d buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x"
; 3054 :         WRMSG( HHC00310, "E", LCSS_DEVNUM, cckd->sfn, cckd_sf_name( dev, cckd->sfn ),

  00867	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  0086f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00872	83 e0 01	 and	 eax, 1
  00875	85 c0		 test	 eax, eax
  00877	74 11		 je	 SHORT $LN36@cckd64_cch
  00879	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171063
  00880	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv355[rsp], rax
  00888	eb 0f		 jmp	 SHORT $LN37@cckd64_cch
$LN36@cckd64_cch:
  0088a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171064
  00891	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv355[rsp], rax
$LN37@cckd64_cch:
  00899	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  008a1	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  008a4	83 e0 01	 and	 eax, 1
  008a7	85 c0		 test	 eax, eax
  008a9	74 11		 je	 SHORT $LN38@cckd64_cch
  008ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171065
  008b2	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv360[rsp], rax
  008ba	eb 0f		 jmp	 SHORT $LN39@cckd64_cch
$LN38@cckd64_cch:
  008bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171066
  008c3	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv360[rsp], rax
$LN39@cckd64_cch:
  008cb	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  008d4	74 15		 je	 SHORT $LN40@cckd64_cch
  008d6	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008de	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  008e2	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv372[rsp], eax
  008e9	eb 0b		 jmp	 SHORT $LN41@cckd64_cch
$LN40@cckd64_cch:
  008eb	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv372[rsp], 0
$LN41@cckd64_cch:
  008f6	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  008ff	74 17		 je	 SHORT $LN42@cckd64_cch
  00901	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00909	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0090d	d1 f8		 sar	 eax, 1
  0090f	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv378[rsp], eax
  00916	eb 0b		 jmp	 SHORT $LN43@cckd64_cch
$LN42@cckd64_cch:
  00918	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv378[rsp], 0
$LN43@cckd64_cch:
  00923	b8 01 00 00 00	 mov	 eax, 1
  00928	48 6b c0 04	 imul	 rax, rax, 4
  0092c	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00934	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00938	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv332[rsp], eax
  0093f	b9 01 00 00 00	 mov	 ecx, 1
  00944	48 6b c9 03	 imul	 rcx, rcx, 3
  00948	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00950	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00954	89 8c 24 04 01
	00 00		 mov	 DWORD PTR tv336[rsp], ecx
  0095b	ba 01 00 00 00	 mov	 edx, 1
  00960	48 6b d2 02	 imul	 rdx, rdx, 2
  00964	4c 8b 84 24 88
	01 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  0096c	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00971	89 94 24 08 01
	00 00		 mov	 DWORD PTR tv340[rsp], edx
  00978	41 b8 01 00 00
	00		 mov	 r8d, 1
  0097e	4d 6b c0 01	 imul	 r8, r8, 1
  00982	4c 8b 8c 24 88
	01 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  0098a	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  0098f	44 89 84 24 0c
	01 00 00	 mov	 DWORD PTR tv344[rsp], r8d
  00997	41 b9 01 00 00
	00		 mov	 r9d, 1
  0099d	4d 6b c9 00	 imul	 r9, r9, 0
  009a1	4c 8b 94 24 88
	01 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  009a9	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  009ae	44 89 8c 24 10
	01 00 00	 mov	 DWORD PTR tv348[rsp], r9d
  009b6	4c 8b 94 24 a8
	00 00 00	 mov	 r10, QWORD PTR cckd$[rsp]
  009be	41 8b 52 3c	 mov	 edx, DWORD PTR [r10+60]
  009c2	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009ca	e8 00 00 00 00	 call	 cckd_sf_name
  009cf	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv362[rsp], rax
  009d7	b9 01 00 00 00	 mov	 ecx, 1
  009dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009e2	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv332[rsp]
  009e9	89 8c 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], ecx
  009f0	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv336[rsp]
  009f7	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  009fe	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv340[rsp]
  00a05	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  00a0c	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv344[rsp]
  00a13	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  00a1a	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv348[rsp]
  00a21	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00a25	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00a2d	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  00a32	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00a39	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00a3d	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv355[rsp]
  00a45	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00a4a	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv360[rsp]
  00a52	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00a57	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv362[rsp]
  00a5f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00a64	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00a6c	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00a6f	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00a73	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv372[rsp]
  00a7a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a7e	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv378[rsp]
  00a85	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a89	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171067
  00a90	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a95	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171068
  00a9c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00aa1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00aa6	41 b9 03 00 00
	00		 mov	 r9d, 3
  00aac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171069
  00ab3	ba f1 0b 00 00	 mov	 edx, 3057		; 00000bf1H
  00ab8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171070
  00abf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3055 :                 cckd->ckddasd ? "trk" : "blk",
; 3056 :                 cckd->ckddasd ? "trk" : "blk", trk,
; 3057 :                 buf, buf[0], buf[1], buf[2], buf[3], buf[4]);
; 3058 :         cckd_print_itrace();

  00ac5	e8 00 00 00 00	 call	 cckd_print_itrace
$LN18@cckd64_cch:

; 3059 :     }
; 3060 : 
; 3061 :     return -1;

  00aca	b8 ff ff ff ff	 mov	 eax, -1
$LN1@cckd64_cch:

; 3062 : } /* end function cckd64_cchh */

  00acf	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  00ad6	c3		 ret	 0
cckd64_cchh ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
rc$ = 32
cckd$ = 40
buf2$ = 48
__$ArrayPad$ = 65584
dev$ = 65616
buf$ = 65624
trk$ = 65632
len$ = 65640
cckd64_check_null_trk PROC

; 2952 : {

$LN11:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	b8 48 00 01 00	 mov	 eax, 65608		; 00010048H
  00019	e8 00 00 00 00	 call	 __chkstk
  0001e	48 2b e0	 sub	 rsp, rax
  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00028	48 33 c4	 xor	 rax, rsp
  0002b	48 89 84 24 30
	00 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2953 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2954 : int             rc;                     /* Return code               */
; 2955 : BYTE            buf2[65536];            /* Null track buffer         */
; 2956 : 
; 2957 :     if (!dev->cckd64)

  00033	48 8b 84 24 50
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00042	24 01		 and	 al, 1
  00044	0f b6 c0	 movzx	 eax, al
  00047	85 c0		 test	 eax, eax
  00049	75 2a		 jne	 SHORT $LN2@cckd64_che

; 2958 :         return cckd_check_null_trk( dev, buf, trk, len );

  0004b	44 8b 8c 24 68
	00 01 00	 mov	 r9d, DWORD PTR len$[rsp]
  00053	44 8b 84 24 60
	00 01 00	 mov	 r8d, DWORD PTR trk$[rsp]
  0005b	48 8b 94 24 58
	00 01 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00063	48 8b 8c 24 50
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0006b	e8 00 00 00 00	 call	 cckd_check_null_trk
  00070	e9 e2 00 00 00	 jmp	 $LN1@cckd64_che
$LN2@cckd64_che:

; 2959 : 
; 2960 :     cckd = dev->cckd_ext;

  00075	48 8b 84 24 50
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007d	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00084	48 89 44 24 28	 mov	 QWORD PTR cckd$[rsp], rax

; 2961 :     rc = len;

  00089	8b 84 24 68 00
	01 00		 mov	 eax, DWORD PTR len$[rsp]
  00090	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 2962 : 
; 2963 :     if (len == CKD_NULLTRK_SIZE0)

  00094	48 63 84 24 68
	00 01 00	 movsxd	 rax, DWORD PTR len$[rsp]
  0009c	48 83 f8 25	 cmp	 rax, 37			; 00000025H
  000a0	75 0d		 jne	 SHORT $LN3@cckd64_che

; 2964 :         rc = CKD_NULLTRK_FMT0;

  000a2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
  000aa	e9 a4 00 00 00	 jmp	 $LN4@cckd64_che
$LN3@cckd64_che:

; 2965 :     else if (len == CKD_NULLTRK_SIZE1)

  000af	48 63 84 24 68
	00 01 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000b7	48 83 f8 1d	 cmp	 rax, 29
  000bb	75 0d		 jne	 SHORT $LN5@cckd64_che

; 2966 :         rc = CKD_NULLTRK_FMT1;

  000bd	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
  000c5	e9 89 00 00 00	 jmp	 $LN6@cckd64_che
$LN5@cckd64_che:

; 2967 :     else if (len == CKD_NULLTRK_SIZE2 && dev->oslinux
; 2968 :           && (!cckd->notnull || cckdblk.linuxnull))

  000ca	48 63 84 24 68
	00 01 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000d2	48 3d 7d c0 00
	00		 cmp	 rax, 49277		; 0000c07dH
  000d8	75 79		 jne	 SHORT $LN7@cckd64_che
  000da	48 8b 84 24 50
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000e8	c1 e8 0d	 shr	 eax, 13
  000eb	83 e0 01	 and	 eax, 1
  000ee	85 c0		 test	 eax, eax
  000f0	74 61		 je	 SHORT $LN7@cckd64_che
  000f2	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  000f7	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000fa	c1 e8 07	 shr	 eax, 7
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 09		 je	 SHORT $LN8@cckd64_che
  00104	83 3d 58 02 00
	00 00		 cmp	 DWORD PTR cckdblk+600, 0
  0010b	74 46		 je	 SHORT $LN7@cckd64_che
$LN8@cckd64_che:

; 2969 :     {
; 2970 :          cckd64_null_trk (dev, buf2, trk, 0);

  0010d	45 33 c9	 xor	 r9d, r9d
  00110	44 8b 84 24 60
	00 01 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00118	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf2$[rsp]
  0011d	48 8b 8c 24 50
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00125	e8 00 00 00 00	 call	 cckd64_null_trk

; 2971 :          if (memcmp(buf, buf2, len) == 0)

  0012a	48 63 84 24 68
	00 01 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00132	4c 8b c0	 mov	 r8, rax
  00135	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf2$[rsp]
  0013a	48 8b 8c 24 58
	00 01 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00142	e8 00 00 00 00	 call	 memcmp
  00147	85 c0		 test	 eax, eax
  00149	75 08		 jne	 SHORT $LN9@cckd64_che

; 2972 :             rc = CKD_NULLTRK_FMT2;

  0014b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR rc$[rsp], 2
$LN9@cckd64_che:
$LN7@cckd64_che:
$LN6@cckd64_che:
$LN4@cckd64_che:

; 2973 :     }
; 2974 : 
; 2975 :     return rc;

  00153	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cckd64_che:

; 2976 : }

  00157	48 8b 8c 24 30
	00 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0015f	48 33 cc	 xor	 rcx, rsp
  00162	e8 00 00 00 00	 call	 __security_check_cookie
  00167	48 81 c4 48 00
	01 00		 add	 rsp, 65608		; 00010048H
  0016e	c3		 ret	 0
cckd64_check_null_trk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
r$ = 64
pos$ = 72
rechdr$ = 80
cyl$ = 88
head$ = 92
len$ = 96
i$ = 100
cckd$ = 104
trkhdr$ = 112
tv240 = 120
tv226 = 128
dev$ = 160
buf$ = 168
trk$ = 176
nullfmt$ = 184
cckd64_null_trk PROC

; 2842 : {

$LN18:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H

; 2843 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2844 : int             i;                      /* Loop counter              */
; 2845 : CKD_TRKHDR     *trkhdr;                 /* -> Track header           */
; 2846 : CKD_RECHDR     *rechdr;                 /* -> Record header          */
; 2847 : U32             cyl;                    /* Cylinder number           */
; 2848 : U32             head;                   /* Head number               */
; 2849 : BYTE            r;                      /* Record number             */
; 2850 : BYTE           *pos;                    /* -> Next position in buffer*/
; 2851 : int             len;                    /* Length of null track      */
; 2852 : 
; 2853 :     if (!dev->cckd64)

  0001c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00024	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0002b	24 01		 and	 al, 1
  0002d	0f b6 c0	 movzx	 eax, al
  00030	85 c0		 test	 eax, eax
  00032	75 2a		 jne	 SHORT $LN5@cckd64_nul

; 2854 :         return cckd_null_trk( dev, buf, trk, nullfmt );

  00034	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR nullfmt$[rsp]
  0003c	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00044	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0004c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00054	e8 00 00 00 00	 call	 cckd_null_trk
  00059	e9 2c 04 00 00	 jmp	 $LN1@cckd64_nul
$LN5@cckd64_nul:

; 2855 : 
; 2856 :     cckd = dev->cckd_ext;

  0005e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00066	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0006d	48 89 44 24 68	 mov	 QWORD PTR cckd$[rsp], rax

; 2857 : 
; 2858 :     if (nullfmt < 0 || nullfmt > CKD_NULLTRK_FMTMAX)

  00072	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR nullfmt$[rsp], 0
  0007a	7c 0a		 jl	 SHORT $LN8@cckd64_nul
  0007c	83 bc 24 b8 00
	00 00 02	 cmp	 DWORD PTR nullfmt$[rsp], 2
  00084	7e 26		 jle	 SHORT $LN6@cckd64_nul
$LN8@cckd64_nul:

; 2859 :         nullfmt = cckd->cdevhdr[cckd->sfn].cdh_nullfmt;

  00086	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0008b	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0008f	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00096	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  0009b	0f b6 84 01 28
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+552]
  000a3	89 84 24 b8 00
	00 00		 mov	 DWORD PTR nullfmt$[rsp], eax
  000aa	eb 37		 jmp	 SHORT $LN7@cckd64_nul
$LN6@cckd64_nul:

; 2860 : 
; 2861 :     // FIXME
; 2862 :     // Compatibility check for nullfmt bug and linux -- 18 May 2005
; 2863 :     // Remove at some reasonable date in the future
; 2864 :     else if (nullfmt == 0
; 2865 :      && cckd->cdevhdr[cckd->sfn].cdh_nullfmt == CKD_NULLTRK_FMT2)

  000ac	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR nullfmt$[rsp], 0
  000b4	75 2d		 jne	 SHORT $LN9@cckd64_nul
  000b6	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  000bb	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  000bf	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000c6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  000cb	0f b6 84 01 28
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+552]
  000d3	83 f8 02	 cmp	 eax, 2
  000d6	75 0b		 jne	 SHORT $LN9@cckd64_nul

; 2866 :         nullfmt = CKD_NULLTRK_FMT2;

  000d8	c7 84 24 b8 00
	00 00 02 00 00
	00		 mov	 DWORD PTR nullfmt$[rsp], 2
$LN9@cckd64_nul:
$LN7@cckd64_nul:

; 2867 : 
; 2868 :     if (cckd->ckddasd)

  000e3	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  000e8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000eb	83 e0 01	 and	 eax, 1
  000ee	85 c0		 test	 eax, eax
  000f0	0f 84 d8 02 00
	00		 je	 $LN10@cckd64_nul

; 2869 :     {
; 2870 : 
; 2871 :         /* cylinder and head calculations */
; 2872 :         cyl = trk / dev->ckdheads;

  000f6	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  000fd	99		 cdq
  000fe	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00106	f7 b9 c0 12 00
	00		 idiv	 DWORD PTR [rcx+4800]
  0010c	89 44 24 58	 mov	 DWORD PTR cyl$[rsp], eax

; 2873 :         head = trk % dev->ckdheads;

  00110	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00117	99		 cdq
  00118	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00120	f7 b9 c0 12 00
	00		 idiv	 DWORD PTR [rcx+4800]
  00126	8b c2		 mov	 eax, edx
  00128	89 44 24 5c	 mov	 DWORD PTR head$[rsp], eax

; 2874 : 
; 2875 :         /* Build the track header */
; 2876 :         trkhdr = (CKD_TRKHDR*)buf;

  0012c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00134	48 89 44 24 70	 mov	 QWORD PTR trkhdr$[rsp], rax

; 2877 :         trkhdr->bin = 0;

  00139	48 8b 44 24 70	 mov	 rax, QWORD PTR trkhdr$[rsp]
  0013e	c6 00 00	 mov	 BYTE PTR [rax], 0

; 2878 :         store_hw( &trkhdr->cyl,  (U16) cyl  );

  00141	0f b7 4c 24 58	 movzx	 ecx, WORD PTR cyl$[rsp]
  00146	e8 00 00 00 00	 call	 _byteswap_ushort
  0014b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  00150	48 ff c1	 inc	 rcx
  00153	0f b7 d0	 movzx	 edx, ax
  00156	e8 00 00 00 00	 call	 store_hw_noswap

; 2879 :         store_hw( &trkhdr->head, (U16) head );

  0015b	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR head$[rsp]
  00160	e8 00 00 00 00	 call	 _byteswap_ushort
  00165	48 8b 4c 24 70	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  0016a	48 83 c1 03	 add	 rcx, 3
  0016e	0f b7 d0	 movzx	 edx, ax
  00171	e8 00 00 00 00	 call	 store_hw_noswap

; 2880 :         pos = buf + CKD_TRKHDR_SIZE;

  00176	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0017e	48 83 c0 05	 add	 rax, 5
  00182	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 2881 : 
; 2882 :         /* Build record zero (R0): KL=0, DL=8 */
; 2883 :         r = 0;

  00187	c6 44 24 40 00	 mov	 BYTE PTR r$[rsp], 0

; 2884 :         rechdr = (CKD_RECHDR*)pos;

  0018c	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  00191	48 89 44 24 50	 mov	 QWORD PTR rechdr$[rsp], rax

; 2885 :         pos += CKD_RECHDR_SIZE;

  00196	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  0019b	48 83 c0 08	 add	 rax, 8
  0019f	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 2886 :         store_hw( &rechdr->cyl,  (U16) cyl  );

  001a4	0f b7 4c 24 58	 movzx	 ecx, WORD PTR cyl$[rsp]
  001a9	e8 00 00 00 00	 call	 _byteswap_ushort
  001ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  001b3	0f b7 d0	 movzx	 edx, ax
  001b6	e8 00 00 00 00	 call	 store_hw_noswap

; 2887 :         store_hw( &rechdr->head, (U16) head );

  001bb	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR head$[rsp]
  001c0	e8 00 00 00 00	 call	 _byteswap_ushort
  001c5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  001ca	48 83 c1 02	 add	 rcx, 2
  001ce	0f b7 d0	 movzx	 edx, ax
  001d1	e8 00 00 00 00	 call	 store_hw_noswap

; 2888 :         rechdr->rec = r;

  001d6	48 8b 44 24 50	 mov	 rax, QWORD PTR rechdr$[rsp]
  001db	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR r$[rsp]
  001e0	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 2889 :         rechdr->klen = 0;

  001e3	48 8b 44 24 50	 mov	 rax, QWORD PTR rechdr$[rsp]
  001e8	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 2890 :         store_hw( &rechdr->dlen, CKD_R0_DLEN );

  001ec	66 b9 08 00	 mov	 cx, 8
  001f0	e8 00 00 00 00	 call	 _byteswap_ushort
  001f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  001fa	48 83 c1 06	 add	 rcx, 6
  001fe	0f b7 d0	 movzx	 edx, ax
  00201	e8 00 00 00 00	 call	 store_hw_noswap

; 2891 :         memset( pos, 0,          CKD_R0_DLEN );

  00206	48 8b 7c 24 48	 mov	 rdi, QWORD PTR pos$[rsp]
  0020b	33 c0		 xor	 eax, eax
  0020d	b9 08 00 00 00	 mov	 ecx, 8
  00212	f3 aa		 rep stosb

; 2892 :         pos +=                   CKD_R0_DLEN;

  00214	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  00219	48 83 c0 08	 add	 rax, 8
  0021d	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 2893 :         r++;

  00222	0f b6 44 24 40	 movzx	 eax, BYTE PTR r$[rsp]
  00227	fe c0		 inc	 al
  00229	88 44 24 40	 mov	 BYTE PTR r$[rsp], al

; 2894 : 
; 2895 :         /* Specific null track formatting */
; 2896 :         if (nullfmt == CKD_NULLTRK_FMT0)

  0022d	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR nullfmt$[rsp], 0
  00235	0f 85 88 00 00
	00		 jne	 $LN12@cckd64_nul

; 2897 :         {
; 2898 :             rechdr = (CKD_RECHDR*)pos;

  0023b	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  00240	48 89 44 24 50	 mov	 QWORD PTR rechdr$[rsp], rax

; 2899 :             pos += CKD_RECHDR_SIZE;

  00245	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  0024a	48 83 c0 08	 add	 rax, 8
  0024e	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 2900 : 
; 2901 :             /* Build record one (R1): EOF record (KL=0, DL=0) */
; 2902 :             store_hw( &rechdr->cyl,  (U16) cyl  );

  00253	0f b7 4c 24 58	 movzx	 ecx, WORD PTR cyl$[rsp]
  00258	e8 00 00 00 00	 call	 _byteswap_ushort
  0025d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00262	0f b7 d0	 movzx	 edx, ax
  00265	e8 00 00 00 00	 call	 store_hw_noswap

; 2903 :             store_hw( &rechdr->head, (U16) head );

  0026a	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR head$[rsp]
  0026f	e8 00 00 00 00	 call	 _byteswap_ushort
  00274	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00279	48 83 c1 02	 add	 rcx, 2
  0027d	0f b7 d0	 movzx	 edx, ax
  00280	e8 00 00 00 00	 call	 store_hw_noswap

; 2904 :             rechdr->rec = r;

  00285	48 8b 44 24 50	 mov	 rax, QWORD PTR rechdr$[rsp]
  0028a	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR r$[rsp]
  0028f	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 2905 :             rechdr->klen = 0;

  00292	48 8b 44 24 50	 mov	 rax, QWORD PTR rechdr$[rsp]
  00297	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 2906 :             store_hw(&rechdr->dlen, 0);

  0029b	33 c9		 xor	 ecx, ecx
  0029d	e8 00 00 00 00	 call	 _byteswap_ushort
  002a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  002a7	48 83 c1 06	 add	 rcx, 6
  002ab	0f b7 d0	 movzx	 edx, ax
  002ae	e8 00 00 00 00	 call	 store_hw_noswap

; 2907 :             r++;

  002b3	0f b6 44 24 40	 movzx	 eax, BYTE PTR r$[rsp]
  002b8	fe c0		 inc	 al
  002ba	88 44 24 40	 mov	 BYTE PTR r$[rsp], al

; 2908 :         }

  002be	e9 d5 00 00 00	 jmp	 $LN13@cckd64_nul
$LN12@cckd64_nul:

; 2909 :         else if (nullfmt == CKD_NULLTRK_FMT2)

  002c3	83 bc 24 b8 00
	00 00 02	 cmp	 DWORD PTR nullfmt$[rsp], 2
  002cb	0f 85 c7 00 00
	00		 jne	 $LN14@cckd64_nul

; 2910 :         {
; 2911 :             /* Build 12 binary-0 data blocks, 4K each (KL=0, DL=4K) */
; 2912 :             for (i = 0; i < 12; i++)

  002d1	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002d9	eb 0a		 jmp	 SHORT $LN4@cckd64_nul
$LN2@cckd64_nul:
  002db	8b 44 24 64	 mov	 eax, DWORD PTR i$[rsp]
  002df	ff c0		 inc	 eax
  002e1	89 44 24 64	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd64_nul:
  002e5	83 7c 24 64 0c	 cmp	 DWORD PTR i$[rsp], 12
  002ea	0f 8d a8 00 00
	00		 jge	 $LN3@cckd64_nul

; 2913 :             {
; 2914 :                 rechdr = (CKD_RECHDR*)pos;

  002f0	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  002f5	48 89 44 24 50	 mov	 QWORD PTR rechdr$[rsp], rax

; 2915 :                 pos += CKD_RECHDR_SIZE;

  002fa	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  002ff	48 83 c0 08	 add	 rax, 8
  00303	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 2916 : 
; 2917 :                 store_hw( &rechdr->cyl,  (U16) cyl);

  00308	0f b7 4c 24 58	 movzx	 ecx, WORD PTR cyl$[rsp]
  0030d	e8 00 00 00 00	 call	 _byteswap_ushort
  00312	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00317	0f b7 d0	 movzx	 edx, ax
  0031a	e8 00 00 00 00	 call	 store_hw_noswap

; 2918 :                 store_hw( &rechdr->head, (U16) head);

  0031f	0f b7 4c 24 5c	 movzx	 ecx, WORD PTR head$[rsp]
  00324	e8 00 00 00 00	 call	 _byteswap_ushort
  00329	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0032e	48 83 c1 02	 add	 rcx, 2
  00332	0f b7 d0	 movzx	 edx, ax
  00335	e8 00 00 00 00	 call	 store_hw_noswap

; 2919 :                 rechdr->rec = r;

  0033a	48 8b 44 24 50	 mov	 rax, QWORD PTR rechdr$[rsp]
  0033f	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR r$[rsp]
  00344	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 2920 :                 rechdr->klen = 0;

  00347	48 8b 44 24 50	 mov	 rax, QWORD PTR rechdr$[rsp]
  0034c	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 2921 :                 store_hw( &rechdr->dlen, CKD_NULL_FMT2_DLEN );

  00350	66 b9 00 10	 mov	 cx, 4096		; 00001000H
  00354	e8 00 00 00 00	 call	 _byteswap_ushort
  00359	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0035e	48 83 c1 06	 add	 rcx, 6
  00362	0f b7 d0	 movzx	 edx, ax
  00365	e8 00 00 00 00	 call	 store_hw_noswap

; 2922 :                 r++;

  0036a	0f b6 44 24 40	 movzx	 eax, BYTE PTR r$[rsp]
  0036f	fe c0		 inc	 al
  00371	88 44 24 40	 mov	 BYTE PTR r$[rsp], al

; 2923 :                 memset( pos, 0,          CKD_NULL_FMT2_DLEN );

  00375	48 8b 7c 24 48	 mov	 rdi, QWORD PTR pos$[rsp]
  0037a	33 c0		 xor	 eax, eax
  0037c	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00381	f3 aa		 rep stosb

; 2924 :                 pos +=                   CKD_NULL_FMT2_DLEN;

  00383	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  00388	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0038e	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 2925 :             }

  00393	e9 43 ff ff ff	 jmp	 $LN2@cckd64_nul
$LN3@cckd64_nul:
$LN14@cckd64_nul:
$LN13@cckd64_nul:

; 2926 :         }
; 2927 : 
; 2928 :         /* Build the end of track marker */
; 2929 :         memcpy( pos, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  00398	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  0039d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR CKD_ENDTRK
  003a4	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2930 :         pos +=                    CKD_ENDTRK_SIZE;

  003a7	48 8b 44 24 48	 mov	 rax, QWORD PTR pos$[rsp]
  003ac	48 83 c0 08	 add	 rax, 8
  003b0	48 89 44 24 48	 mov	 QWORD PTR pos$[rsp], rax

; 2931 :         len = (int)(pos - buf);

  003b5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  003bd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pos$[rsp]
  003c2	48 2b c8	 sub	 rcx, rax
  003c5	48 8b c1	 mov	 rax, rcx
  003c8	89 44 24 60	 mov	 DWORD PTR len$[rsp], eax

; 2932 :     }

  003cc	eb 47		 jmp	 SHORT $LN11@cckd64_nul
$LN10@cckd64_nul:

; 2933 :     else
; 2934 :     {
; 2935 :         len = CKD_TRKHDR_SIZE + CFBA_BLKGRP_SIZE;

  003ce	c7 44 24 60 05
	f0 00 00	 mov	 DWORD PTR len$[rsp], 61445 ; 0000f005H

; 2936 :         memset( buf, 0, len );

  003d6	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$[rsp]
  003db	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv226[rsp], rax
  003e3	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  003eb	33 c0		 xor	 eax, eax
  003ed	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv226[rsp]
  003f5	f3 aa		 rep stosb

; 2937 :         store_fw( buf+1, trk );

  003f7	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  003fe	e8 00 00 00 00	 call	 _byteswap_ulong
  00403	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0040b	48 ff c1	 inc	 rcx
  0040e	8b d0		 mov	 edx, eax
  00410	e8 00 00 00 00	 call	 store_fw_noswap
$LN11@cckd64_nul:

; 2938 :     }
; 2939 : 
; 2940 :     CCKD_TRACE( "null_trk %s %d format %d size %d",

  00415	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0041a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0041d	83 e0 01	 and	 eax, 1
  00420	85 c0		 test	 eax, eax
  00422	74 0e		 je	 SHORT $LN16@cckd64_nul
  00424	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170975
  0042b	48 89 44 24 78	 mov	 QWORD PTR tv240[rsp], rax
  00430	eb 0c		 jmp	 SHORT $LN17@cckd64_nul
$LN16@cckd64_nul:
  00432	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170976
  00439	48 89 44 24 78	 mov	 QWORD PTR tv240[rsp], rax
$LN17@cckd64_nul:
  0043e	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00442	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00446	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR nullfmt$[rsp]
  0044d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00451	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00458	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0045c	48 8b 44 24 78	 mov	 rax, QWORD PTR tv240[rsp]
  00461	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00466	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170977
  0046d	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00475	ba 7d 0b 00 00	 mov	 edx, 2941		; 00000b7dH
  0047a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170978
  00481	e8 00 00 00 00	 call	 cckd_trace

; 2941 :                 cckd->ckddasd ? "trk" : "blkgrp", trk, nullfmt, len);
; 2942 : 
; 2943 :     return len;

  00486	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
$LN1@cckd64_nul:

; 2944 : 
; 2945 : } /* end function cckd64_null_trk */

  0048a	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00491	5f		 pop	 rdi
  00492	c3		 ret	 0
cckd64_null_trk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
rc$ = 48
cckd$ = 56
dev$ = 80
cckd64_harden PROC

; 2800 : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2801 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2802 : int             rc=0;                   /* Return code               */

  00009	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 2803 : 
; 2804 :     if (!dev->cckd64)

  00011	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00016	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0001d	24 01		 and	 al, 1
  0001f	0f b6 c0	 movzx	 eax, al
  00022	85 c0		 test	 eax, eax
  00024	75 0f		 jne	 SHORT $LN2@cckd64_har

; 2805 :         return cckd_harden( dev );

  00026	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0002b	e8 00 00 00 00	 call	 cckd_harden
  00030	e9 39 01 00 00	 jmp	 $LN1@cckd64_har
$LN2@cckd64_har:

; 2806 : 
; 2807 :     cckd = dev->cckd_ext;

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0003a	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00041	48 89 44 24 38	 mov	 QWORD PTR cckd$[rsp], rax

; 2808 : 
; 2809 :     if ((dev->ckdrdonly && cckd->sfn == 0)
; 2810 :      || cckd->open[cckd->sfn] != CCKD_OPEN_RW)

  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0004b	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00051	c1 e8 12	 shr	 eax, 18
  00054	83 e0 01	 and	 eax, 1
  00057	85 c0		 test	 eax, eax
  00059	74 0b		 je	 SHORT $LN5@cckd64_har
  0005b	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00060	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00064	74 1b		 je	 SHORT $LN4@cckd64_har
$LN5@cckd64_har:
  00066	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0006b	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0006f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00074	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  0007c	83 f8 03	 cmp	 eax, 3
  0007f	74 07		 je	 SHORT $LN3@cckd64_har
$LN4@cckd64_har:

; 2811 :         return 0;

  00081	33 c0		 xor	 eax, eax
  00083	e9 e6 00 00 00	 jmp	 $LN1@cckd64_har
$LN3@cckd64_har:

; 2812 : 
; 2813 :     CCKD_TRACE( "file[%d] harden", cckd->sfn);

  00088	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0008d	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00090	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00094	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170912
  0009b	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  000a0	ba fd 0a 00 00	 mov	 edx, 2813		; 00000afdH
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170913
  000ac	e8 00 00 00 00	 call	 cckd_trace

; 2814 : 
; 2815 :     /* Write the compressed device header */
; 2816 :     if (cckd64_write_chdr (dev) < 0)

  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000b6	e8 00 00 00 00	 call	 cckd64_write_chdr
  000bb	85 c0		 test	 eax, eax
  000bd	7d 08		 jge	 SHORT $LN6@cckd64_har

; 2817 :         rc = -1;

  000bf	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN6@cckd64_har:

; 2818 : 
; 2819 :     /* Write the level 1 table */
; 2820 :     if (cckd64_write_l1 (dev) < 0)

  000c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000cc	e8 00 00 00 00	 call	 cckd64_write_l1
  000d1	85 c0		 test	 eax, eax
  000d3	7d 08		 jge	 SHORT $LN7@cckd64_har

; 2821 :         rc = -1;

  000d5	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN7@cckd64_har:

; 2822 : 
; 2823 :     /* Write the free space chain */
; 2824 :     if (cckd64_write_fsp (dev) < 0)

  000dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000e2	e8 00 00 00 00	 call	 cckd64_write_fsp
  000e7	85 c0		 test	 eax, eax
  000e9	7d 08		 jge	 SHORT $LN8@cckd64_har

; 2825 :         rc = -1;

  000eb	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN8@cckd64_har:

; 2826 : 
; 2827 :     /* Re-write the compressed device header */
; 2828 :     cckd->cdevhdr[cckd->sfn].cdh_opts &= ~CCKD_OPT_OPENED;

  000f3	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  000f8	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  000fc	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00103	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00108	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  00110	0f ba f0 07	 btr	 eax, 7
  00114	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00119	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  0011d	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00124	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  00129	88 84 0a e3 01
	00 00		 mov	 BYTE PTR [rdx+rcx+483], al

; 2829 :     if (cckd64_write_chdr (dev) < 0)

  00130	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00135	e8 00 00 00 00	 call	 cckd64_write_chdr
  0013a	85 c0		 test	 eax, eax
  0013c	7d 08		 jge	 SHORT $LN9@cckd64_har

; 2830 :         rc = -1;

  0013e	c7 44 24 30 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN9@cckd64_har:

; 2831 : 
; 2832 :     if (cckdblk.fsync)

  00146	83 3d 5c 02 00
	00 00		 cmp	 DWORD PTR cckdblk+604, 0
  0014d	74 1b		 je	 SHORT $LN10@cckd64_har

; 2833 :         fdatasync (cckd->fd[cckd->sfn]);

  0014f	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00154	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00158	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0015d	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__commit
$LN10@cckd64_har:

; 2834 : 
; 2835 :     return rc;

  0016a	8b 44 24 30	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cckd64_har:

; 2836 : } /* cckd64_harden */

  0016e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00172	c3		 ret	 0
cckd64_harden ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
sfx$ = 112
cckd$ = 120
l2x$ = 128
size$ = 132
rc$ = 136
after$ = 140
L1idx$ = 144
off$ = 152
oldl2$ = 160
l2$ = 176
__$ArrayPad$ = 192
dev$ = 224
buf$ = 232
len$ = 240
trk$ = 248
flags$ = 256
cckd64_write_trkimg PROC

; 2712 : {

$LN12:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2713 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2714 : int             rc;                     /* Return code               */
; 2715 : U64             off;                    /* File offset               */
; 2716 : CCKD64_L2ENT    l2, oldl2;              /* Level 2 entries           */
; 2717 : int             sfx,L1idx,l2x;          /* Lookup table indices      */
; 2718 : int             after = 0;              /* 1=New track after old     */

  0002d	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR after$[rsp], 0

; 2719 : int             size;                   /* Size of new track         */
; 2720 : 
; 2721 :     if (!dev->cckd64)

  00038	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00040	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00047	24 01		 and	 al, 1
  00049	0f b6 c0	 movzx	 eax, al
  0004c	85 c0		 test	 eax, eax
  0004e	75 35		 jne	 SHORT $LN2@cckd64_wri

; 2722 :         return cckd_write_trkimg( dev, buf, len, trk, flags );

  00050	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00057	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0005b	44 8b 8c 24 f8
	00 00 00	 mov	 r9d, DWORD PTR trk$[rsp]
  00063	44 8b 84 24 f0
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0006b	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00073	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0007b	e8 00 00 00 00	 call	 cckd_write_trkimg
  00080	e9 46 04 00 00	 jmp	 $LN1@cckd64_wri
$LN2@cckd64_wri:

; 2723 : 
; 2724 :     cckd = dev->cckd_ext;

  00085	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008d	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00094	48 89 44 24 78	 mov	 QWORD PTR cckd$[rsp], rax

; 2725 : 
; 2726 :     sfx = cckd->sfn;

  00099	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0009e	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  000a1	89 44 24 70	 mov	 DWORD PTR sfx$[rsp], eax

; 2727 :     L1idx = trk >> 8;

  000a5	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  000ac	c1 f8 08	 sar	 eax, 8
  000af	89 84 24 90 00
	00 00		 mov	 DWORD PTR L1idx$[rsp], eax

; 2728 :     l2x = trk & 0xff;

  000b6	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  000bd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c2	89 84 24 80 00
	00 00		 mov	 DWORD PTR l2x$[rsp], eax

; 2729 : 
; 2730 :     CCKD_TRACE( "file[%d] trk[%d] write_trkimg len %d buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x",

  000c9	b8 01 00 00 00	 mov	 eax, 1
  000ce	48 6b c0 04	 imul	 rax, rax, 4
  000d2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  000da	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000de	b9 01 00 00 00	 mov	 ecx, 1
  000e3	48 6b c9 03	 imul	 rcx, rcx, 3
  000e7	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000ef	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000f3	ba 01 00 00 00	 mov	 edx, 1
  000f8	48 6b d2 02	 imul	 rdx, rdx, 2
  000fc	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  00104	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00109	41 b8 01 00 00
	00		 mov	 r8d, 1
  0010f	4d 6b c0 01	 imul	 r8, r8, 1
  00113	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  0011b	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00120	41 b9 01 00 00
	00		 mov	 r9d, 1
  00126	4d 6b c9 00	 imul	 r9, r9, 0
  0012a	4c 8b 94 24 e8
	00 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  00132	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  00137	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  0013b	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0013f	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  00143	44 89 44 24 48	 mov	 DWORD PTR [rsp+72], r8d
  00148	44 89 4c 24 40	 mov	 DWORD PTR [rsp+64], r9d
  0014d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00155	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0015a	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00161	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00165	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0016c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00170	8b 44 24 70	 mov	 eax, DWORD PTR sfx$[rsp]
  00174	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00178	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170891
  0017f	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00187	ba ab 0a 00 00	 mov	 edx, 2731		; 00000aabH
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170892
  00193	e8 00 00 00 00	 call	 cckd_trace

; 2731 :                 sfx, trk, len, buf, buf[0], buf[1], buf[2], buf[3], buf[4]);
; 2732 : 
; 2733 :     /* Validate the new track image */
; 2734 :     if (cckd64_cchh (dev, buf, trk) < 0)

  00198	44 8b 84 24 f8
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  001a0	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  001a8	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001b0	e8 00 00 00 00	 call	 cckd64_cchh
  001b5	85 c0		 test	 eax, eax
  001b7	7d 0a		 jge	 SHORT $LN3@cckd64_wri

; 2735 :         return -1;

  001b9	b8 ff ff ff ff	 mov	 eax, -1
  001be	e9 08 03 00 00	 jmp	 $LN1@cckd64_wri
$LN3@cckd64_wri:

; 2736 : 
; 2737 :     /* Get the level 2 table for the track in the active file */
; 2738 :     if (cckd64_read_l2 (dev, sfx, L1idx) < 0)

  001c3	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR L1idx$[rsp]
  001cb	8b 54 24 70	 mov	 edx, DWORD PTR sfx$[rsp]
  001cf	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001d7	e8 00 00 00 00	 call	 cckd64_read_l2
  001dc	85 c0		 test	 eax, eax
  001de	7d 0a		 jge	 SHORT $LN4@cckd64_wri

; 2739 :         return -1;

  001e0	b8 ff ff ff ff	 mov	 eax, -1
  001e5	e9 e1 02 00 00	 jmp	 $LN1@cckd64_wri
$LN4@cckd64_wri:

; 2740 : 
; 2741 :     /* Save the level 2 entry for the track */
; 2742 :     oldl2.L2_trkoff = cckd->L2tab[l2x].L2_trkoff;

  001ea	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR l2x$[rsp]
  001f2	48 6b c0 10	 imul	 rax, rax, 16
  001f6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001fb	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  001ff	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00203	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR oldl2$[rsp], rax

; 2743 :     oldl2.L2_len    = cckd->L2tab[l2x].L2_len;

  0020b	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR l2x$[rsp]
  00213	48 6b c0 10	 imul	 rax, rax, 16
  00217	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0021c	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00220	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  00225	66 89 84 24 a8
	00 00 00	 mov	 WORD PTR oldl2$[rsp+8], ax

; 2744 :     oldl2.L2_size   = cckd->L2tab[l2x].L2_size;

  0022d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR l2x$[rsp]
  00235	48 6b c0 10	 imul	 rax, rax, 16
  00239	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0023e	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00242	0f b7 44 01 0a	 movzx	 eax, WORD PTR [rcx+rax+10]
  00247	66 89 84 24 aa
	00 00 00	 mov	 WORD PTR oldl2$[rsp+10], ax

; 2745 :     CCKD_TRACE( "file[%d] trk[%d] write_trkimg oldl2 0x%"PRIx64" %hd %hd",

  0024f	0f b7 84 24 aa
	00 00 00	 movzx	 eax, WORD PTR oldl2$[rsp+10]
  00257	0f b7 8c 24 a8
	00 00 00	 movzx	 ecx, WORD PTR oldl2$[rsp+8]
  0025f	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00263	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00267	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR oldl2$[rsp]
  0026f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00274	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0027b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0027f	8b 44 24 70	 mov	 eax, DWORD PTR sfx$[rsp]
  00283	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00287	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170895
  0028e	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00296	ba ba 0a 00 00	 mov	 edx, 2746		; 00000abaH
  0029b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170896
  002a2	e8 00 00 00 00	 call	 cckd_trace

; 2746 :                 sfx, trk, oldl2.L2_trkoff, oldl2.L2_len, oldl2.L2_size);
; 2747 : 
; 2748 :     /* Check if writing a null track */
; 2749 :     len = cckd64_check_null_trk(dev, buf, trk, len);

  002a7	44 8b 8c 24 f0
	00 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  002af	44 8b 84 24 f8
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  002b7	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  002bf	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002c7	e8 00 00 00 00	 call	 cckd64_check_null_trk
  002cc	89 84 24 f0 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 2750 : 
; 2751 :     if (len > CKD_NULLTRK_FMTMAX)

  002d3	83 bc 24 f0 00
	00 00 02	 cmp	 DWORD PTR len$[rsp], 2
  002db	0f 8e 64 01 00
	00		 jle	 $LN5@cckd64_wri

; 2752 :     {
; 2753 :         /* Get space for the track image */
; 2754 :         size = len;

  002e1	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  002e8	89 84 24 84 00
	00 00		 mov	 DWORD PTR size$[rsp], eax

; 2755 :         if ((S64)(off = cckd64_get_space (dev, &size, flags)) < 0)

  002ef	44 8b 84 24 00
	01 00 00	 mov	 r8d, DWORD PTR flags$[rsp]
  002f7	48 8d 94 24 84
	00 00 00	 lea	 rdx, QWORD PTR size$[rsp]
  002ff	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00307	e8 00 00 00 00	 call	 cckd64_get_space
  0030c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR off$[rsp], rax
  00314	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR off$[rsp], 0
  0031d	7d 0a		 jge	 SHORT $LN7@cckd64_wri

; 2756 :             return -1;

  0031f	b8 ff ff ff ff	 mov	 eax, -1
  00324	e9 a2 01 00 00	 jmp	 $LN1@cckd64_wri
$LN7@cckd64_wri:

; 2757 : 
; 2758 :         l2.L2_trkoff = off;

  00329	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR off$[rsp]
  00331	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR l2$[rsp], rax

; 2759 :         l2.L2_len    = (U16)len;

  00339	0f b7 84 24 f0
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  00341	66 89 84 24 b8
	00 00 00	 mov	 WORD PTR l2$[rsp+8], ax

; 2760 :         l2.L2_size   = (U16)size;

  00349	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR size$[rsp]
  00351	66 89 84 24 ba
	00 00 00	 mov	 WORD PTR l2$[rsp+10], ax

; 2761 : 
; 2762 :         if (1
; 2763 :             && oldl2.L2_trkoff != CCKD64_NOSIZE
; 2764 :             && oldl2.L2_trkoff != CCKD64_MAXSIZE
; 2765 :             && oldl2.L2_trkoff < l2.L2_trkoff

  00359	33 c0		 xor	 eax, eax
  0035b	83 f8 01	 cmp	 eax, 1
  0035e	74 33		 je	 SHORT $LN8@cckd64_wri
  00360	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR oldl2$[rsp], 0
  00369	74 28		 je	 SHORT $LN8@cckd64_wri
  0036b	48 83 bc 24 a0
	00 00 00 ff	 cmp	 QWORD PTR oldl2$[rsp], -1
  00374	74 1d		 je	 SHORT $LN8@cckd64_wri
  00376	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR l2$[rsp]
  0037e	48 39 84 24 a0
	00 00 00	 cmp	 QWORD PTR oldl2$[rsp], rax
  00386	73 0b		 jae	 SHORT $LN8@cckd64_wri

; 2766 :         )
; 2767 :             after = 1;

  00388	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR after$[rsp], 1
$LN8@cckd64_wri:

; 2768 : 
; 2769 :         /* Write the track image */
; 2770 :         if ((rc = cckd64_write (dev, sfx, off, buf, len)) < 0)

  00393	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0039a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0039e	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  003a6	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR off$[rsp]
  003ae	8b 54 24 70	 mov	 edx, DWORD PTR sfx$[rsp]
  003b2	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003ba	e8 00 00 00 00	 call	 cckd64_write
  003bf	89 84 24 88 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  003c6	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  003ce	7d 0a		 jge	 SHORT $LN9@cckd64_wri

; 2771 :             return -1;

  003d0	b8 ff ff ff ff	 mov	 eax, -1
  003d5	e9 f1 00 00 00	 jmp	 $LN1@cckd64_wri
$LN9@cckd64_wri:

; 2772 : 
; 2773 :         cckd->writes[sfx]++;

  003da	48 63 44 24 70	 movsxd	 rax, DWORD PTR sfx$[rsp]
  003df	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  003e4	8b 84 81 70 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+368]
  003eb	ff c0		 inc	 eax
  003ed	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  003f2	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  003f7	89 84 8a 70 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+368], eax

; 2774 :         cckd->totwrites++;

  003fe	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00403	8b 80 d8 00 00
	00		 mov	 eax, DWORD PTR [rax+216]
  00409	ff c0		 inc	 eax
  0040b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00410	89 81 d8 00 00
	00		 mov	 DWORD PTR [rcx+216], eax

; 2775 :         cckdblk.stats_writes++;

  00416	48 8b 05 d0 02
	00 00		 mov	 rax, QWORD PTR cckdblk+720
  0041d	48 ff c0	 inc	 rax
  00420	48 89 05 d0 02
	00 00		 mov	 QWORD PTR cckdblk+720, rax

; 2776 :         cckdblk.stats_writebytes += rc;

  00427	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR rc$[rsp]
  0042f	48 8b 0d d8 02
	00 00		 mov	 rcx, QWORD PTR cckdblk+728
  00436	48 03 c8	 add	 rcx, rax
  00439	48 8b c1	 mov	 rax, rcx
  0043c	48 89 05 d8 02
	00 00		 mov	 QWORD PTR cckdblk+728, rax

; 2777 :     }

  00443	eb 2c		 jmp	 SHORT $LN6@cckd64_wri
$LN5@cckd64_wri:

; 2778 :     else
; 2779 :     {
; 2780 :         l2.L2_trkoff = 0;

  00445	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR l2$[rsp], 0

; 2781 :         l2.L2_len = l2.L2_size = (U16)len;

  00451	0f b7 84 24 f0
	00 00 00	 movzx	 eax, WORD PTR len$[rsp]
  00459	66 89 84 24 ba
	00 00 00	 mov	 WORD PTR l2$[rsp+10], ax
  00461	0f b7 84 24 ba
	00 00 00	 movzx	 eax, WORD PTR l2$[rsp+10]
  00469	66 89 84 24 b8
	00 00 00	 mov	 WORD PTR l2$[rsp+8], ax
$LN6@cckd64_wri:

; 2782 :     }
; 2783 : 
; 2784 :     /* Update the level 2 entry */
; 2785 :     if (cckd64_write_l2ent (dev, &l2, trk) < 0)

  00471	44 8b 84 24 f8
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00479	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR l2$[rsp]
  00481	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00489	e8 00 00 00 00	 call	 cckd64_write_l2ent
  0048e	85 c0		 test	 eax, eax
  00490	7d 07		 jge	 SHORT $LN10@cckd64_wri

; 2786 :         return -1;

  00492	b8 ff ff ff ff	 mov	 eax, -1
  00497	eb 32		 jmp	 SHORT $LN1@cckd64_wri
$LN10@cckd64_wri:

; 2787 : 
; 2788 :     /* Release the previous space */
; 2789 :     cckd64_rel_space (dev, oldl2.L2_trkoff, (int)oldl2.L2_len, (int)oldl2.L2_size);

  00499	0f b7 84 24 aa
	00 00 00	 movzx	 eax, WORD PTR oldl2$[rsp+10]
  004a1	0f b7 8c 24 a8
	00 00 00	 movzx	 ecx, WORD PTR oldl2$[rsp+8]
  004a9	44 8b c8	 mov	 r9d, eax
  004ac	44 8b c1	 mov	 r8d, ecx
  004af	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR oldl2$[rsp]
  004b7	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004bf	e8 00 00 00 00	 call	 cckd64_rel_space

; 2790 : 
; 2791 :     /* `after' is 1 if the new offset is after the old offset */
; 2792 :     return after;

  004c4	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR after$[rsp]
$LN1@cckd64_wri:

; 2793 : 
; 2794 : } /* end function cckd64_write_trkimg */

  004cb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004d3	48 33 cc	 xor	 rcx, rsp
  004d6	e8 00 00 00 00	 call	 __security_check_cookie
  004db	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  004e2	c3		 ret	 0
cckd64_write_trkimg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
sfx$ = 48
rc$ = 52
cckd$ = 56
l2$ = 64
__$ArrayPad$ = 80
dev$ = 112
buf$ = 120
trk$ = 128
unitstat$ = 136
cckd64_read_trkimg PROC

; 2660 : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2661 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2662 : int             rc;                     /* Return code               */
; 2663 : int             sfx;                    /* File index                */
; 2664 : CCKD64_L2ENT    l2;                     /* Level 2 entry             */
; 2665 : 
; 2666 :     cckd = dev->cckd_ext;

  00027	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0002c	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00033	48 89 44 24 38	 mov	 QWORD PTR cckd$[rsp], rax

; 2667 : 
; 2668 :     CCKD_TRACE( "trk[%d] read_trkimg", trk);

  00038	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0003f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00043	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170851
  0004a	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  0004f	ba 6c 0a 00 00	 mov	 edx, 2668		; 00000a6cH
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170852
  0005b	e8 00 00 00 00	 call	 cckd_trace

; 2669 : 
; 2670 :     /* Read level 2 entry for the track */
; 2671 :     if ((sfx = cckd64_read_l2ent (dev, &l2, trk)) < 0)

  00060	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00068	48 8d 54 24 40	 lea	 rdx, QWORD PTR l2$[rsp]
  0006d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00072	e8 00 00 00 00	 call	 cckd64_read_l2ent
  00077	89 44 24 30	 mov	 DWORD PTR sfx$[rsp], eax
  0007b	83 7c 24 30 00	 cmp	 DWORD PTR sfx$[rsp], 0
  00080	7d 05		 jge	 SHORT $LN2@cckd64_rea

; 2672 :         goto cckd_read_trkimg_error;

  00082	e9 1b 01 00 00	 jmp	 $cckd_read_trkimg_error$11
$LN2@cckd64_rea:

; 2673 : 
; 2674 :     /* Read the track image or build a null track image */
; 2675 :     if (l2.L2_trkoff != 0)

  00087	48 83 7c 24 40
	00		 cmp	 QWORD PTR l2$[rsp], 0
  0008d	0f 84 c9 00 00
	00		 je	 $LN3@cckd64_rea

; 2676 :     {
; 2677 :         rc = cckd64_read (dev, sfx, l2.L2_trkoff, buf, l2.L2_len);

  00093	0f b7 44 24 48	 movzx	 eax, WORD PTR l2$[rsp+8]
  00098	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0009c	4c 8b 4c 24 78	 mov	 r9, QWORD PTR buf$[rsp]
  000a1	4c 8b 44 24 40	 mov	 r8, QWORD PTR l2$[rsp]
  000a6	8b 54 24 30	 mov	 edx, DWORD PTR sfx$[rsp]
  000aa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000af	e8 00 00 00 00	 call	 cckd64_read
  000b4	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 2678 :         if (rc < 0)

  000b8	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bd	7d 05		 jge	 SHORT $LN5@cckd64_rea

; 2679 :             goto cckd_read_trkimg_error;

  000bf	e9 de 00 00 00	 jmp	 $cckd_read_trkimg_error$11
$LN5@cckd64_rea:

; 2680 : 
; 2681 :         cckd->reads[sfx]++;

  000c4	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000c9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000ce	8b 84 81 28 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+296]
  000d5	ff c0		 inc	 eax
  000d7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  000dc	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  000e1	89 84 8a 28 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+296], eax

; 2682 :         cckd->totreads++;

  000e8	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  000ed	8b 80 d4 00 00
	00		 mov	 eax, DWORD PTR [rax+212]
  000f3	ff c0		 inc	 eax
  000f5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000fa	89 81 d4 00 00
	00		 mov	 DWORD PTR [rcx+212], eax

; 2683 :         cckdblk.stats_reads++;

  00100	48 8b 05 c0 02
	00 00		 mov	 rax, QWORD PTR cckdblk+704
  00107	48 ff c0	 inc	 rax
  0010a	48 89 05 c0 02
	00 00		 mov	 QWORD PTR cckdblk+704, rax

; 2684 :         cckdblk.stats_readbytes += rc;

  00111	48 63 44 24 34	 movsxd	 rax, DWORD PTR rc$[rsp]
  00116	48 8b 0d c8 02
	00 00		 mov	 rcx, QWORD PTR cckdblk+712
  0011d	48 03 c8	 add	 rcx, rax
  00120	48 8b c1	 mov	 rax, rcx
  00123	48 89 05 c8 02
	00 00		 mov	 QWORD PTR cckdblk+712, rax

; 2685 :         if (cckd->notnull == 0 && trk > 1) cckd->notnull = 1;

  0012a	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0012f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00132	c1 e8 07	 shr	 eax, 7
  00135	83 e0 01	 and	 eax, 1
  00138	85 c0		 test	 eax, eax
  0013a	75 1e		 jne	 SHORT $LN6@cckd64_rea
  0013c	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR trk$[rsp], 1
  00144	7e 14		 jle	 SHORT $LN6@cckd64_rea
  00146	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0014b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0014e	0f ba e8 07	 bts	 eax, 7
  00152	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00157	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN6@cckd64_rea:

; 2686 :     }

  0015a	eb 23		 jmp	 SHORT $LN4@cckd64_rea
$LN3@cckd64_rea:

; 2687 :     else
; 2688 :         rc = cckd64_null_trk (dev, buf, trk, l2.L2_len);

  0015c	0f b7 44 24 48	 movzx	 eax, WORD PTR l2$[rsp+8]
  00161	44 8b c8	 mov	 r9d, eax
  00164	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR buf$[rsp]
  00171	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00176	e8 00 00 00 00	 call	 cckd64_null_trk
  0017b	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
$LN4@cckd64_rea:

; 2689 : 
; 2690 :     /* Validate the track image */
; 2691 :     if (cckd64_cchh (dev, buf, trk) < 0)

  0017f	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00187	48 8b 54 24 78	 mov	 rdx, QWORD PTR buf$[rsp]
  0018c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00191	e8 00 00 00 00	 call	 cckd64_cchh
  00196	85 c0		 test	 eax, eax
  00198	7d 02		 jge	 SHORT $LN7@cckd64_rea

; 2692 :         goto cckd_read_trkimg_error;

  0019a	eb 06		 jmp	 SHORT $cckd_read_trkimg_error$11
$LN7@cckd64_rea:

; 2693 : 
; 2694 :     return rc;

  0019c	8b 44 24 34	 mov	 eax, DWORD PTR rc$[rsp]
  001a0	eb 4c		 jmp	 SHORT $LN1@cckd64_rea
$cckd_read_trkimg_error$11:

; 2695 : 
; 2696 : cckd_read_trkimg_error:
; 2697 : 
; 2698 :     if (unitstat)

  001a2	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR unitstat$[rsp], 0
  001ab	74 27		 je	 SHORT $LN8@cckd64_rea

; 2699 :     {
; 2700 :         ckd_build_sense (dev, SENSE_EC, 0, 0, FORMAT_1, MESSAGE_0);

  001ad	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  001b2	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  001b7	45 33 c9	 xor	 r9d, r9d
  001ba	45 33 c0	 xor	 r8d, r8d
  001bd	b2 10		 mov	 dl, 16
  001bf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001c4	e8 00 00 00 00	 call	 ckd_build_sense

; 2701 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  001c9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  001d1	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN8@cckd64_rea:

; 2702 :     }
; 2703 : 
; 2704 :     return cckd64_null_trk (dev, buf, trk, 0);

  001d4	45 33 c9	 xor	 r9d, r9d
  001d7	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  001df	48 8b 54 24 78	 mov	 rdx, QWORD PTR buf$[rsp]
  001e4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001e9	e8 00 00 00 00	 call	 cckd64_null_trk
$LN1@cckd64_rea:

; 2705 : 
; 2706 : } /* end function cckd64_read_trkimg */

  001ee	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001f3	48 33 cc	 xor	 rcx, rsp
  001f6	e8 00 00 00 00	 call	 __security_check_cookie
  001fb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ff	c3		 ret	 0
cckd64_read_trkimg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
l2x$ = 96
sfx$ = 100
L1idx$ = 104
cckd$ = 112
off$ = 120
dev$ = 160
l2$ = 168
trk$ = 176
cckd64_write_l2ent PROC

; 2620 : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2621 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2622 : int             sfx,L1idx,l2x;          /* Lookup table indices      */
; 2623 : U64             off;                    /* L2 entry offset           */
; 2624 : 
; 2625 :     if (!dev->cckd64)

  00018	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00020	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00027	24 01		 and	 al, 1
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 22		 jne	 SHORT $LN2@cckd64_wri

; 2626 :         return cckd_write_l2ent( dev, (CCKD_L2ENT*) l2, trk );

  00030	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00038	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR l2$[rsp]
  00040	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00048	e8 00 00 00 00	 call	 cckd_write_l2ent
  0004d	e9 cf 01 00 00	 jmp	 $LN1@cckd64_wri
$LN2@cckd64_wri:

; 2627 : 
; 2628 :     cckd = dev->cckd_ext;

  00052	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005a	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00061	48 89 44 24 70	 mov	 QWORD PTR cckd$[rsp], rax

; 2629 : 
; 2630 :     /* Error return if no available level 2 table */
; 2631 :     if (!cckd->L2tab) return -1;

  00066	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0006b	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00070	75 0a		 jne	 SHORT $LN3@cckd64_wri
  00072	b8 ff ff ff ff	 mov	 eax, -1
  00077	e9 a5 01 00 00	 jmp	 $LN1@cckd64_wri
$LN3@cckd64_wri:

; 2632 : 
; 2633 :     sfx = cckd->sfn;

  0007c	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00081	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00084	89 44 24 64	 mov	 DWORD PTR sfx$[rsp], eax

; 2634 :     L1idx = trk >> 8;

  00088	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0008f	c1 f8 08	 sar	 eax, 8
  00092	89 44 24 68	 mov	 DWORD PTR L1idx$[rsp], eax

; 2635 :     l2x = trk & 0xff;

  00096	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0009d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a2	89 44 24 60	 mov	 DWORD PTR l2x$[rsp], eax

; 2636 : 
; 2637 :     /* Copy the new entry if passed */
; 2638 :     if (l2) memcpy (&cckd->L2tab[l2x], l2, CCKD64_L2ENT_SIZE);

  000a6	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR l2$[rsp], 0
  000af	74 25		 je	 SHORT $LN4@cckd64_wri
  000b1	48 63 44 24 60	 movsxd	 rax, DWORD PTR l2x$[rsp]
  000b6	48 6b c0 10	 imul	 rax, rax, 16
  000ba	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  000bf	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  000c3	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  000c7	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR l2$[rsp]
  000cf	b9 10 00 00 00	 mov	 ecx, 16
  000d4	f3 a4		 rep movsb
$LN4@cckd64_wri:

; 2639 : 
; 2640 :     CCKD_TRACE( "file[%d] l2[%d,%d] trk[%d] write_l2ent 0x%"PRIx64" %hd %hd",

  000d6	48 63 44 24 60	 movsxd	 rax, DWORD PTR l2x$[rsp]
  000db	48 6b c0 10	 imul	 rax, rax, 16
  000df	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  000e4	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  000e8	0f b7 44 01 0a	 movzx	 eax, WORD PTR [rcx+rax+10]
  000ed	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR l2x$[rsp]
  000f2	48 6b c9 10	 imul	 rcx, rcx, 16
  000f6	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  000fb	48 8b 52 48	 mov	 rdx, QWORD PTR [rdx+72]
  000ff	0f b7 4c 0a 08	 movzx	 ecx, WORD PTR [rdx+rcx+8]
  00104	48 63 54 24 60	 movsxd	 rdx, DWORD PTR l2x$[rsp]
  00109	48 6b d2 10	 imul	 rdx, rdx, 16
  0010d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR cckd$[rsp]
  00112	48 8b 7f 48	 mov	 rdi, QWORD PTR [rdi+72]
  00116	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  0011a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0011e	48 8b 04 17	 mov	 rax, QWORD PTR [rdi+rdx]
  00122	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00127	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0012e	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00132	8b 44 24 60	 mov	 eax, DWORD PTR l2x$[rsp]
  00136	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0013a	8b 44 24 68	 mov	 eax, DWORD PTR L1idx$[rsp]
  0013e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00142	8b 44 24 64	 mov	 eax, DWORD PTR sfx$[rsp]
  00146	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0014a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170832
  00151	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00159	ba 52 0a 00 00	 mov	 edx, 2642		; 00000a52H
  0015e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170833
  00165	e8 00 00 00 00	 call	 cckd_trace

; 2641 :                 sfx, L1idx, l2x, trk,
; 2642 :                 cckd->L2tab[l2x].L2_trkoff, cckd->L2tab[l2x].L2_len, cckd->L2tab[l2x].L2_size);
; 2643 : 
; 2644 :     /* If no level 2 table for this file, then write a new one */
; 2645 :     if (cckd->L1tab[sfx][L1idx] == CCKD64_NOSIZE || cckd->L1tab[sfx][L1idx] == CCKD64_MAXSIZE)

  0016a	48 63 44 24 64	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0016f	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  00174	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  00179	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00181	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  00186	74 1e		 je	 SHORT $LN6@cckd64_wri
  00188	48 63 44 24 64	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0018d	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  00192	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  00197	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  0019f	48 83 3c c8 ff	 cmp	 QWORD PTR [rax+rcx*8], -1
  001a4	75 0f		 jne	 SHORT $LN5@cckd64_wri
$LN6@cckd64_wri:

; 2646 :         return cckd64_write_l2 (dev);

  001a6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ae	e8 00 00 00 00	 call	 cckd64_write_l2
  001b3	eb 6c		 jmp	 SHORT $LN1@cckd64_wri
$LN5@cckd64_wri:

; 2647 : 
; 2648 :     /* Write the level 2 table entry */
; 2649 :     off = (cckd->L1tab[sfx][L1idx] + l2x * CCKD64_L2ENT_SIZE);

  001b5	48 63 44 24 64	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001ba	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  001bf	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  001c4	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  001cc	48 63 54 24 60	 movsxd	 rdx, DWORD PTR l2x$[rsp]
  001d1	48 6b d2 10	 imul	 rdx, rdx, 16
  001d5	48 03 14 c8	 add	 rdx, QWORD PTR [rax+rcx*8]
  001d9	48 8b c2	 mov	 rax, rdx
  001dc	48 89 44 24 78	 mov	 QWORD PTR off$[rsp], rax

; 2650 :     if (cckd64_write (dev, sfx, off, &cckd->L2tab[l2x], CCKD64_L2ENT_SIZE) < 0)

  001e1	48 63 44 24 60	 movsxd	 rax, DWORD PTR l2x$[rsp]
  001e6	48 6b c0 10	 imul	 rax, rax, 16
  001ea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ef	48 03 41 48	 add	 rax, QWORD PTR [rcx+72]
  001f3	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  001fb	4c 8b c8	 mov	 r9, rax
  001fe	4c 8b 44 24 78	 mov	 r8, QWORD PTR off$[rsp]
  00203	8b 54 24 64	 mov	 edx, DWORD PTR sfx$[rsp]
  00207	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0020f	e8 00 00 00 00	 call	 cckd64_write
  00214	85 c0		 test	 eax, eax
  00216	7d 07		 jge	 SHORT $LN7@cckd64_wri

; 2651 :         return -1;

  00218	b8 ff ff ff ff	 mov	 eax, -1
  0021d	eb 02		 jmp	 SHORT $LN1@cckd64_wri
$LN7@cckd64_wri:

; 2652 : 
; 2653 :     return 0;

  0021f	33 c0		 xor	 eax, eax
$LN1@cckd64_wri:

; 2654 : } /* end function cckd64_write_l2ent */

  00221	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00228	5f		 pop	 rdi
  00229	5e		 pop	 rsi
  0022a	c3		 ret	 0
cckd64_write_l2ent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
sfx$ = 96
l2x$ = 100
L1idx$ = 104
tv156 = 108
tv167 = 112
cckd$ = 120
tv177 = 128
dev$ = 160
l2$ = 168
trk$ = 176
cckd64_read_l2ent PROC

; 2568 : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2569 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2570 : int             sfx,L1idx,l2x;          /* Lookup table indices      */
; 2571 : 
; 2572 :     if (!dev->cckd64)

  00016	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00025	24 01		 and	 al, 1
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	75 22		 jne	 SHORT $LN5@cckd64_rea

; 2573 :         return cckd_read_l2ent( dev, (CCKD_L2ENT*) l2, trk );

  0002e	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00036	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR l2$[rsp]
  0003e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00046	e8 00 00 00 00	 call	 cckd_read_l2ent
  0004b	e9 bf 02 00 00	 jmp	 $LN1@cckd64_rea
$LN5@cckd64_rea:

; 2574 : 
; 2575 :     cckd = dev->cckd_ext;

  00050	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00058	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0005f	48 89 44 24 78	 mov	 QWORD PTR cckd$[rsp], rax

; 2576 : 
; 2577 :     L1idx = trk >> 8;

  00064	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0006b	c1 f8 08	 sar	 eax, 8
  0006e	89 44 24 68	 mov	 DWORD PTR L1idx$[rsp], eax

; 2578 :     l2x = trk & 0xff;

  00072	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00079	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0007e	89 44 24 64	 mov	 DWORD PTR l2x$[rsp], eax

; 2579 : 
; 2580 :     if (l2 != NULL) l2->L2_trkoff = l2->L2_len = l2->L2_size = 0;

  00082	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR l2$[rsp], 0
  0008b	74 2b		 je	 SHORT $LN6@cckd64_rea
  0008d	33 c0		 xor	 eax, eax
  0008f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR l2$[rsp]
  00097	66 89 41 0a	 mov	 WORD PTR [rcx+10], ax
  0009b	33 c0		 xor	 eax, eax
  0009d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR l2$[rsp]
  000a5	66 89 41 08	 mov	 WORD PTR [rcx+8], ax
  000a9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR l2$[rsp]
  000b1	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN6@cckd64_rea:

; 2581 : 
; 2582 :     for (sfx = cckd->sfn; sfx >= 0; sfx--)

  000b8	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  000bd	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  000c0	89 44 24 60	 mov	 DWORD PTR sfx$[rsp], eax
  000c4	eb 0a		 jmp	 SHORT $LN4@cckd64_rea
$LN2@cckd64_rea:
  000c6	8b 44 24 60	 mov	 eax, DWORD PTR sfx$[rsp]
  000ca	ff c8		 dec	 eax
  000cc	89 44 24 60	 mov	 DWORD PTR sfx$[rsp], eax
$LN4@cckd64_rea:
  000d0	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  000d5	0f 8c ca 00 00
	00		 jl	 $LN3@cckd64_rea

; 2583 :     {
; 2584 :         CCKD_TRACE( "file[%d] l2[%d,%d] trk[%d] read_l2ent 0x%"PRIx64,

  000db	48 63 44 24 60	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000e0	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000e5	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  000ea	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000f2	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000f6	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000fb	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00102	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00106	8b 44 24 64	 mov	 eax, DWORD PTR l2x$[rsp]
  0010a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0010e	8b 44 24 68	 mov	 eax, DWORD PTR L1idx$[rsp]
  00112	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00116	8b 44 24 60	 mov	 eax, DWORD PTR sfx$[rsp]
  0011a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0011e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170799
  00125	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0012d	ba 19 0a 00 00	 mov	 edx, 2585		; 00000a19H
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170800
  00139	e8 00 00 00 00	 call	 cckd_trace

; 2585 :                     sfx, L1idx, l2x, trk, cckd->L1tab[sfx][L1idx]);
; 2586 : 
; 2587 :         /* Continue if l2 table not in this file */
; 2588 :         if (cckd->L1tab[sfx][L1idx] == CCKD64_MAXSIZE)

  0013e	48 63 44 24 60	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00143	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  00148	48 8b 54 24 78	 mov	 rdx, QWORD PTR cckd$[rsp]
  0014d	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00155	48 83 3c c8 ff	 cmp	 QWORD PTR [rax+rcx*8], -1
  0015a	75 05		 jne	 SHORT $LN7@cckd64_rea

; 2589 :             continue;

  0015c	e9 65 ff ff ff	 jmp	 $LN2@cckd64_rea
$LN7@cckd64_rea:

; 2590 : 
; 2591 :         /* Read l2 table from this file */
; 2592 :         if (cckd64_read_l2 (dev, sfx, L1idx) < 0)

  00161	44 8b 44 24 68	 mov	 r8d, DWORD PTR L1idx$[rsp]
  00166	8b 54 24 60	 mov	 edx, DWORD PTR sfx$[rsp]
  0016a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00172	e8 00 00 00 00	 call	 cckd64_read_l2
  00177	85 c0		 test	 eax, eax
  00179	7d 0a		 jge	 SHORT $LN8@cckd64_rea

; 2593 :             return -1;

  0017b	b8 ff ff ff ff	 mov	 eax, -1
  00180	e9 8a 01 00 00	 jmp	 $LN1@cckd64_rea
$LN8@cckd64_rea:

; 2594 : 
; 2595 :         /* Exit loop if track is in this file */
; 2596 :         if (cckd->L2tab[l2x].L2_trkoff != CCKD64_MAXSIZE)

  00185	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  0018a	48 6b c0 10	 imul	 rax, rax, 16
  0018e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00193	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00197	48 83 3c 01 ff	 cmp	 QWORD PTR [rcx+rax], -1
  0019c	74 02		 je	 SHORT $LN9@cckd64_rea

; 2597 :             break;

  0019e	eb 05		 jmp	 SHORT $LN3@cckd64_rea
$LN9@cckd64_rea:

; 2598 :     }

  001a0	e9 21 ff ff ff	 jmp	 $LN2@cckd64_rea
$LN3@cckd64_rea:

; 2599 : 
; 2600 :     CCKD_TRACE( "file[%d] l2[%d,%d] trk[%d] read_l2ent 0x%"PRIx64" %hd %hd",

  001a5	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  001aa	7c 1d		 jl	 SHORT $LN12@cckd64_rea
  001ac	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  001b1	48 6b c0 10	 imul	 rax, rax, 16
  001b5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ba	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  001be	0f b7 44 01 0a	 movzx	 eax, WORD PTR [rcx+rax+10]
  001c3	89 44 24 6c	 mov	 DWORD PTR tv156[rsp], eax
  001c7	eb 08		 jmp	 SHORT $LN13@cckd64_rea
$LN12@cckd64_rea:
  001c9	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
$LN13@cckd64_rea:
  001d1	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  001d6	7c 1d		 jl	 SHORT $LN14@cckd64_rea
  001d8	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  001dd	48 6b c0 10	 imul	 rax, rax, 16
  001e1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  001e6	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  001ea	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  001ef	89 44 24 70	 mov	 DWORD PTR tv167[rsp], eax
  001f3	eb 08		 jmp	 SHORT $LN15@cckd64_rea
$LN14@cckd64_rea:
  001f5	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN15@cckd64_rea:
  001fd	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  00202	7c 20		 jl	 SHORT $LN16@cckd64_rea
  00204	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  00209	48 6b c0 10	 imul	 rax, rax, 16
  0020d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00212	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00216	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0021a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv177[rsp], rax
  00222	eb 0c		 jmp	 SHORT $LN17@cckd64_rea
$LN16@cckd64_rea:
  00224	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv177[rsp], 0
$LN17@cckd64_rea:
  00230	0f b7 44 24 6c	 movzx	 eax, WORD PTR tv156[rsp]
  00235	0f b7 4c 24 70	 movzx	 ecx, WORD PTR tv167[rsp]
  0023a	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  0023e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00242	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv177[rsp]
  0024a	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0024f	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00256	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0025a	8b 44 24 64	 mov	 eax, DWORD PTR l2x$[rsp]
  0025e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00262	8b 44 24 68	 mov	 eax, DWORD PTR L1idx$[rsp]
  00266	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0026a	8b 44 24 60	 mov	 eax, DWORD PTR sfx$[rsp]
  0026e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00272	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170804
  00279	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00281	ba 2b 0a 00 00	 mov	 edx, 2603		; 00000a2bH
  00286	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170805
  0028d	e8 00 00 00 00	 call	 cckd_trace

; 2601 :                 sfx, L1idx, l2x, trk, (U64)(sfx >= 0 ? cckd->L2tab[l2x].L2_trkoff : 0),
; 2602 :                 (U16)(sfx >= 0 ? cckd->L2tab[l2x].L2_len  : 0),
; 2603 :                 (U16)(sfx >= 0 ? cckd->L2tab[l2x].L2_size : 0));
; 2604 : 
; 2605 :     if (l2 != NULL && sfx >= 0)

  00292	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR l2$[rsp], 0
  0029b	74 6e		 je	 SHORT $LN10@cckd64_rea
  0029d	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  002a2	7c 67		 jl	 SHORT $LN10@cckd64_rea

; 2606 :     {
; 2607 :         l2->L2_trkoff  = cckd->L2tab[l2x].L2_trkoff;

  002a4	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  002a9	48 6b c0 10	 imul	 rax, rax, 16
  002ad	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  002b2	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  002b6	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR l2$[rsp]
  002be	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  002c2	48 89 02	 mov	 QWORD PTR [rdx], rax

; 2608 :         l2->L2_len  = cckd->L2tab[l2x].L2_len;

  002c5	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  002ca	48 6b c0 10	 imul	 rax, rax, 16
  002ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  002d3	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  002d7	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR l2$[rsp]
  002df	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  002e4	66 89 42 08	 mov	 WORD PTR [rdx+8], ax

; 2609 :         l2->L2_size = cckd->L2tab[l2x].L2_size;

  002e8	48 63 44 24 64	 movsxd	 rax, DWORD PTR l2x$[rsp]
  002ed	48 6b c0 10	 imul	 rax, rax, 16
  002f1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  002f6	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  002fa	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR l2$[rsp]
  00302	0f b7 44 01 0a	 movzx	 eax, WORD PTR [rcx+rax+10]
  00307	66 89 42 0a	 mov	 WORD PTR [rdx+10], ax
$LN10@cckd64_rea:

; 2610 :     }
; 2611 : 
; 2612 :     return sfx;

  0030b	8b 44 24 60	 mov	 eax, DWORD PTR sfx$[rsp]
$LN1@cckd64_rea:

; 2613 : 
; 2614 : } /* end function cckd64_read_l2ent */

  0030f	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00316	c3		 ret	 0
cckd64_read_l2ent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
sfx$ = 48
L1idx$ = 52
fix$ = 56
size$ = 60
cckd$ = 64
off$ = 72
old_off$ = 80
dev$ = 112
cckd64_write_l2 PROC

; 2512 : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2513 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2514 : int             sfx,L1idx;              /* Lookup table indices      */
; 2515 : U64             off, old_off;           /* New/old L2 file offsets   */
; 2516 : int             size = CCKD64_L2TAB_SIZE; /* L2 table size           */

  00009	c7 44 24 3c 00
	10 00 00	 mov	 DWORD PTR size$[rsp], 4096 ; 00001000H

; 2517 : int             fix;                    /* Null format type          */
; 2518 : 
; 2519 :     if (!dev->cckd64)

  00011	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00016	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0001d	24 01		 and	 al, 1
  0001f	0f b6 c0	 movzx	 eax, al
  00022	85 c0		 test	 eax, eax
  00024	75 0f		 jne	 SHORT $LN2@cckd64_wri

; 2520 :         return cckd_write_l2( dev );

  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0002b	e8 00 00 00 00	 call	 cckd_write_l2
  00030	e9 1b 02 00 00	 jmp	 $LN1@cckd64_wri
$LN2@cckd64_wri:

; 2521 : 
; 2522 :     cckd = dev->cckd_ext;

  00035	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0003a	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00041	48 89 44 24 40	 mov	 QWORD PTR cckd$[rsp], rax

; 2523 :     sfx = cckd->sfn;

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  0004b	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0004e	89 44 24 30	 mov	 DWORD PTR sfx$[rsp], eax

; 2524 :     L1idx = cckd->L1idx;

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00057	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0005a	89 44 24 34	 mov	 DWORD PTR L1idx$[rsp], eax

; 2525 :     fix = cckd->cdevhdr[sfx].cdh_nullfmt;

  0005e	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00063	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0006a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0006f	0f b6 84 01 28
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+552]
  00077	89 44 24 38	 mov	 DWORD PTR fix$[rsp], eax

; 2526 :     cckd->L2ok = 0;

  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00080	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00083	0f ba f0 08	 btr	 eax, 8
  00087	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0008c	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 2527 : 
; 2528 :     CCKD_TRACE( "file[%d] write_l2 %d", sfx, L1idx);

  0008f	8b 44 24 34	 mov	 eax, DWORD PTR L1idx$[rsp]
  00093	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00097	8b 44 24 30	 mov	 eax, DWORD PTR sfx$[rsp]
  0009b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0009f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170762
  000a6	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  000ab	ba e0 09 00 00	 mov	 edx, 2528		; 000009e0H
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170763
  000b7	e8 00 00 00 00	 call	 cckd_trace

; 2529 : 
; 2530 :     if (sfx < 0 || L1idx < 0) return -1;

  000bc	83 7c 24 30 00	 cmp	 DWORD PTR sfx$[rsp], 0
  000c1	7c 07		 jl	 SHORT $LN4@cckd64_wri
  000c3	83 7c 24 34 00	 cmp	 DWORD PTR L1idx$[rsp], 0
  000c8	7d 0a		 jge	 SHORT $LN3@cckd64_wri
$LN4@cckd64_wri:
  000ca	b8 ff ff ff ff	 mov	 eax, -1
  000cf	e9 7c 01 00 00	 jmp	 $LN1@cckd64_wri
$LN3@cckd64_wri:

; 2531 : 
; 2532 :     old_off = cckd->L1tab[sfx][L1idx];

  000d4	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000d9	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000de	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  000e3	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000eb	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000ef	48 89 44 24 50	 mov	 QWORD PTR old_off$[rsp], rax

; 2533 : 
; 2534 :     if (cckd->L1tab[sfx][L1idx] == CCKD64_NOSIZE || cckd->L1tab[sfx][L1idx] == CCKD64_MAXSIZE)

  000f4	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000f9	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000fe	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00103	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  0010b	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  00110	74 1e		 je	 SHORT $LN6@cckd64_wri
  00112	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00117	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  0011c	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00121	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00129	48 83 3c c8 ff	 cmp	 QWORD PTR [rax+rcx*8], -1
  0012e	75 18		 jne	 SHORT $LN5@cckd64_wri
$LN6@cckd64_wri:

; 2535 :         cckd->L2_bounds += CCKD64_L2TAB_SIZE;

  00130	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00135	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00139	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0013f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00144	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
$LN5@cckd64_wri:

; 2536 : 
; 2537 :     /* Write the L2 table if it's not empty */
; 2538 :     if (memcmp( cckd->L2tab, &empty64_l2[fix], CCKD64_L2TAB_SIZE ))

  00148	48 63 44 24 38	 movsxd	 rax, DWORD PTR fix$[rsp]
  0014d	48 69 c0 00 10
	00 00		 imul	 rax, rax, 4096		; 00001000H
  00154	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:empty64_l2
  0015b	48 03 c8	 add	 rcx, rax
  0015e	48 8b c1	 mov	 rax, rcx
  00161	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  00167	48 8b d0	 mov	 rdx, rax
  0016a	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  0016f	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  00173	e8 00 00 00 00	 call	 memcmp
  00178	85 c0		 test	 eax, eax
  0017a	74 5d		 je	 SHORT $LN7@cckd64_wri

; 2539 :     {
; 2540 :         if ((S64)(off = cckd64_get_space( dev, &size, CCKD_L2SPACE )) < 0)

  0017c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00182	48 8d 54 24 3c	 lea	 rdx, QWORD PTR size$[rsp]
  00187	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0018c	e8 00 00 00 00	 call	 cckd64_get_space
  00191	48 89 44 24 48	 mov	 QWORD PTR off$[rsp], rax
  00196	48 83 7c 24 48
	00		 cmp	 QWORD PTR off$[rsp], 0
  0019c	7d 0a		 jge	 SHORT $LN9@cckd64_wri

; 2541 :             return -1;

  0019e	b8 ff ff ff ff	 mov	 eax, -1
  001a3	e9 a8 00 00 00	 jmp	 $LN1@cckd64_wri
$LN9@cckd64_wri:

; 2542 :         if (cckd64_write( dev, sfx, off, cckd->L2tab, CCKD64_L2TAB_SIZE ) < 0)

  001a8	c7 44 24 20 00
	10 00 00	 mov	 DWORD PTR [rsp+32], 4096 ; 00001000H
  001b0	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  001b5	4c 8b 48 48	 mov	 r9, QWORD PTR [rax+72]
  001b9	4c 8b 44 24 48	 mov	 r8, QWORD PTR off$[rsp]
  001be	8b 54 24 30	 mov	 edx, DWORD PTR sfx$[rsp]
  001c2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001c7	e8 00 00 00 00	 call	 cckd64_write
  001cc	85 c0		 test	 eax, eax
  001ce	7d 07		 jge	 SHORT $LN10@cckd64_wri

; 2543 :             return -1;

  001d0	b8 ff ff ff ff	 mov	 eax, -1
  001d5	eb 79		 jmp	 SHORT $LN1@cckd64_wri
$LN10@cckd64_wri:

; 2544 :     }

  001d7	eb 21		 jmp	 SHORT $LN8@cckd64_wri
$LN7@cckd64_wri:

; 2545 :     else
; 2546 :     {
; 2547 :         off = 0;

  001d9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR off$[rsp], 0

; 2548 :         cckd->L2_bounds -= CCKD64_L2TAB_SIZE;

  001e2	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  001e7	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  001eb	48 2d 00 10 00
	00		 sub	 rax, 4096		; 00001000H
  001f1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  001f6	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
$LN8@cckd64_wri:

; 2549 :     }
; 2550 : 
; 2551 :     /* Free the old L2 space */
; 2552 :     cckd64_rel_space( dev, old_off, CCKD64_L2TAB_SIZE, CCKD64_L2TAB_SIZE );

  001fa	41 b9 00 10 00
	00		 mov	 r9d, 4096		; 00001000H
  00200	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  00206	48 8b 54 24 50	 mov	 rdx, QWORD PTR old_off$[rsp]
  0020b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00210	e8 00 00 00 00	 call	 cckd64_rel_space

; 2553 : 
; 2554 :     /* Update level 1 table */
; 2555 :     cckd->L1tab[sfx][L1idx] = off;

  00215	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0021a	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  0021f	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00224	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  0022c	48 8b 54 24 48	 mov	 rdx, QWORD PTR off$[rsp]
  00231	48 89 14 c8	 mov	 QWORD PTR [rax+rcx*8], rdx

; 2556 : 
; 2557 :     if (cckd64_write_l1ent( dev, L1idx ) < 0)

  00235	8b 54 24 34	 mov	 edx, DWORD PTR L1idx$[rsp]
  00239	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0023e	e8 00 00 00 00	 call	 cckd64_write_l1ent
  00243	85 c0		 test	 eax, eax
  00245	7d 07		 jge	 SHORT $LN11@cckd64_wri

; 2558 :         return -1;

  00247	b8 ff ff ff ff	 mov	 eax, -1
  0024c	eb 02		 jmp	 SHORT $LN1@cckd64_wri
$LN11@cckd64_wri:

; 2559 : 
; 2560 :     return 0;

  0024e	33 c0		 xor	 eax, eax
$LN1@cckd64_wri:

; 2561 : 
; 2562 : } /* end function cckd64_write_l2 */

  00250	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00254	c3		 ret	 0
cckd64_write_l2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
devnum$ = 32
sfx$ = 36
i$ = 40
L1idx$ = 44
cckd$ = 48
dev$ = 56
cckd64_steal_l2 PROC

; 2488 : {

$LN7:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2489 : DEVBLK         *dev;                    /* -> device block           */
; 2490 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2491 : int             i;                      /* Stolen cache index        */
; 2492 : U16             sfx;                    /* Cached suffix             */
; 2493 : U16             devnum;                 /* Cached device number      */
; 2494 : U32             L1idx;                  /* Cached level 1 index      */
; 2495 : 
; 2496 :     i = cache_scan (CACHE_L2, cckd_steal_l2_scan, NULL);

  00004	45 33 c0	 xor	 r8d, r8d
  00007	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cckd_steal_l2_scan
  0000e	b9 01 00 00 00	 mov	 ecx, 1
  00013	e8 00 00 00 00	 call	 cache_scan
  00018	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd64_ste:

; 2497 :     L2_CACHE_GETKEY(i, sfx, devnum, L1idx);

  0001c	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  00020	b9 01 00 00 00	 mov	 ecx, 1
  00025	e8 00 00 00 00	 call	 cache_getkey
  0002a	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  0002e	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00034	66 89 44 24 24	 mov	 WORD PTR sfx$[rsp], ax
  00039	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  0003d	b9 01 00 00 00	 mov	 ecx, 1
  00042	e8 00 00 00 00	 call	 cache_getkey
  00047	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0004b	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00051	66 89 44 24 20	 mov	 WORD PTR devnum$[rsp], ax
  00056	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  0005a	b9 01 00 00 00	 mov	 ecx, 1
  0005f	e8 00 00 00 00	 call	 cache_getkey
  00064	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00069	48 23 c1	 and	 rax, rcx
  0006c	89 44 24 2c	 mov	 DWORD PTR L1idx$[rsp], eax
  00070	33 c0		 xor	 eax, eax
  00072	85 c0		 test	 eax, eax
  00074	75 a6		 jne	 SHORT $LN4@cckd64_ste

; 2498 :     dev = cckd_find_device_by_devnum(devnum);

  00076	0f b7 4c 24 20	 movzx	 ecx, WORD PTR devnum$[rsp]
  0007b	e8 00 00 00 00	 call	 cckd_find_device_by_devnum
  00080	48 89 44 24 38	 mov	 QWORD PTR dev$[rsp], rax

; 2499 :     if (!dev->cckd64)

  00085	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  0008a	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00091	24 01		 and	 al, 1
  00093	0f b6 c0	 movzx	 eax, al
  00096	85 c0		 test	 eax, eax
  00098	75 07		 jne	 SHORT $LN5@cckd64_ste

; 2500 :         return cckd_steal_l2();

  0009a	e8 00 00 00 00	 call	 cckd_steal_l2
  0009f	eb 57		 jmp	 SHORT $LN1@cckd64_ste
$LN5@cckd64_ste:

; 2501 :     cckd = dev->cckd_ext;

  000a1	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  000a6	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  000ad	48 89 44 24 30	 mov	 QWORD PTR cckd$[rsp], rax

; 2502 :     cckd->L2_active = cckd->sfx = cckd->L1idx = -1;

  000b2	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  000b7	c7 40 44 ff ff
	ff ff		 mov	 DWORD PTR [rax+68], -1
  000be	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  000c3	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
  000ca	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  000cf	c7 40 50 ff ff
	ff ff		 mov	 DWORD PTR [rax+80], -1

; 2503 :     cckd->L2tab = NULL;

  000d6	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  000db	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 2504 :     cache_release(CACHE_L2, i, 0);

  000e3	45 33 c0	 xor	 r8d, r8d
  000e6	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  000ea	b9 01 00 00 00	 mov	 ecx, 1
  000ef	e8 00 00 00 00	 call	 cache_release

; 2505 :     return i;

  000f4	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
$LN1@cckd64_ste:

; 2506 : }

  000f8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fc	c3		 ret	 0
cckd64_steal_l2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
devnum$ = 64
sfx$ = 68
L1idx$ = 72
dev$ = 80
answer$ = 112
ix$ = 120
i$ = 128
data$ = 136
cckd64_purge_l2_scan PROC

; 2467 : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2468 : U16             sfx;                    /* Cached suffix             */
; 2469 : U16             devnum;                 /* Cached device number      */
; 2470 : U32             L1idx;                  /* Cached level 1 index      */
; 2471 : DEVBLK         *dev = data;             /* -> device block           */

  00017	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0001f	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd64_pur:

; 2472 : 
; 2473 :     UNREFERENCED(answer);

  00024	33 c0		 xor	 eax, eax
  00026	85 c0		 test	 eax, eax
  00028	75 fa		 jne	 SHORT $LN4@cckd64_pur
$LN7@cckd64_pur:

; 2474 :     L2_CACHE_GETKEY(i, sfx, devnum, L1idx);

  0002a	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	e8 00 00 00 00	 call	 cache_getkey
  0003b	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  0003f	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00045	66 89 44 24 44	 mov	 WORD PTR sfx$[rsp], ax
  0004a	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00051	b9 01 00 00 00	 mov	 ecx, 1
  00056	e8 00 00 00 00	 call	 cache_getkey
  0005b	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0005f	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00065	66 89 44 24 40	 mov	 WORD PTR devnum$[rsp], ax
  0006a	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00071	b9 01 00 00 00	 mov	 ecx, 1
  00076	e8 00 00 00 00	 call	 cache_getkey
  0007b	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00080	48 23 c1	 and	 rax, rcx
  00083	89 44 24 48	 mov	 DWORD PTR L1idx$[rsp], eax
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 9d		 jne	 SHORT $LN7@cckd64_pur

; 2475 :     if (dev == NULL || devnum == dev->devnum)

  0008d	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00093	74 12		 je	 SHORT $LN9@cckd64_pur
  00095	0f b7 44 24 40	 movzx	 eax, WORD PTR devnum$[rsp]
  0009a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0009f	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  000a3	3b c1		 cmp	 eax, ecx
  000a5	75 55		 jne	 SHORT $LN8@cckd64_pur
$LN9@cckd64_pur:

; 2476 :     {
; 2477 :         CCKD_TRACE( "purge l2cache[%d] %4.4X sfx %hd ix %d purged",

  000a7	0f b7 44 24 44	 movzx	 eax, WORD PTR sfx$[rsp]
  000ac	0f b7 4c 24 40	 movzx	 ecx, WORD PTR devnum$[rsp]
  000b1	8b 54 24 48	 mov	 edx, DWORD PTR L1idx$[rsp]
  000b5	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  000b9	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000bd	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  000c1	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  000c8	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000cc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170715
  000d3	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  000d8	ba ae 09 00 00	 mov	 edx, 2478		; 000009aeH
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170716
  000e4	e8 00 00 00 00	 call	 cckd_trace

; 2478 :                     i, devnum, sfx, L1idx);
; 2479 :         cache_release(ix, i, 0);

  000e9	45 33 c0	 xor	 r8d, r8d
  000ec	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  000f3	8b 4c 24 78	 mov	 ecx, DWORD PTR ix$[rsp]
  000f7	e8 00 00 00 00	 call	 cache_release
$LN8@cckd64_pur:

; 2480 :     }
; 2481 :     return 0;

  000fc	33 c0		 xor	 eax, eax

; 2482 : }

  000fe	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00102	c3		 ret	 0
cckd64_purge_l2_scan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
cckd$ = 48
dev$ = 80
cckd64_purge_l2 PROC

; 2447 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2448 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2449 : 
; 2450 :     if (!dev->cckd64)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 0f		 jne	 SHORT $LN2@cckd64_pur

; 2451 :     {
; 2452 :         cckd_purge_l2( dev );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd_purge_l2

; 2453 :         return;

  00028	e9 95 00 00 00	 jmp	 $LN1@cckd64_pur
$LN2@cckd64_pur:

; 2454 :     }
; 2455 : 
; 2456 :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 30	 mov	 QWORD PTR cckd$[rsp], rax

; 2457 : 
; 2458 :     CCKD_TRACE( "purge_l2%s", "");

  0003e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170687
  00045	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170688
  00051	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  00056	ba 9a 09 00 00	 mov	 edx, 2458		; 0000099aH
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170689
  00062	e8 00 00 00 00	 call	 cckd_trace

; 2459 : 
; 2460 :     cache_lock (CACHE_L2);

  00067	b9 01 00 00 00	 mov	 ecx, 1
  0006c	e8 00 00 00 00	 call	 cache_lock

; 2461 :     cckd->L2_active = cckd->sfx = cckd->L1idx = -1;

  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00076	c7 40 44 ff ff
	ff ff		 mov	 DWORD PTR [rax+68], -1
  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00082	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
  00089	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  0008e	c7 40 50 ff ff
	ff ff		 mov	 DWORD PTR [rax+80], -1

; 2462 :     cckd->L2tab = NULL;

  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  0009a	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 2463 :     cache_scan (CACHE_L2, cckd64_purge_l2_scan, dev);

  000a2	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cckd64_purge_l2_scan
  000ae	b9 01 00 00 00	 mov	 ecx, 1
  000b3	e8 00 00 00 00	 call	 cache_scan

; 2464 :     cache_unlock (CACHE_L2);

  000b8	b9 01 00 00 00	 mov	 ecx, 1
  000bd	e8 00 00 00 00	 call	 cache_unlock
$LN1@cckd64_pur:

; 2465 : }

  000c2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c6	c3		 ret	 0
cckd64_purge_l2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
nullfmt$ = 80
tv232 = 82
lru$ = 84
fnd$ = 88
i$ = 92
cckd$ = 96
buf$ = 104
off$ = 112
dev$ = 144
sfx$ = 152
L1idx$ = 160
cckd64_read_l2 PROC

; 2336 : {

$LN19:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 2337 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2338 : U64             off;                    /* L2 file offset            */
; 2339 : int             fnd;                    /* Found cache               */
; 2340 : int             lru;                    /* Oldest available cache    */
; 2341 : CCKD64_L2ENT   *buf;                    /* -> Cache buffer           */
; 2342 : int             i;                      /* Loop index                */
; 2343 : BYTE            nullfmt;                /* Null track format         */
; 2344 : 
; 2345 :     if (!dev->cckd64)

  00016	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00025	24 01		 and	 al, 1
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	75 21		 jne	 SHORT $LN5@cckd64_rea

; 2346 :         return cckd_read_l2( dev, sfx, L1idx );

  0002e	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR L1idx$[rsp]
  00036	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  0003d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00045	e8 00 00 00 00	 call	 cckd_read_l2
  0004a	e9 17 06 00 00	 jmp	 $LN1@cckd64_rea
$LN5@cckd64_rea:

; 2347 : 
; 2348 :     cckd = dev->cckd_ext;

  0004f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00057	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0005e	48 89 44 24 60	 mov	 QWORD PTR cckd$[rsp], rax

; 2349 :     nullfmt = cckd->cdevhdr[cckd->sfn].cdh_nullfmt;

  00063	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00068	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  0006c	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00073	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00078	0f b6 84 01 28
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+552]
  00080	88 44 24 50	 mov	 BYTE PTR nullfmt$[rsp], al

; 2350 : 
; 2351 :     CCKD_TRACE( "file[%d] read_l2 %d active %d %d %d",

  00084	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00089	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0008c	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00090	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00095	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00098	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0009c	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  000a1	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  000a4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000a8	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR L1idx$[rsp]
  000af	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000b3	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  000ba	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000be	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170657
  000c5	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000cd	ba 30 09 00 00	 mov	 edx, 2352		; 00000930H
  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170658
  000d9	e8 00 00 00 00	 call	 cckd_trace

; 2352 :                 sfx, L1idx, cckd->sfx, cckd->L1idx, cckd->L2_active);
; 2353 : 
; 2354 :     /* Return if table is already active */
; 2355 :     if (sfx == cckd->sfx && L1idx == cckd->L1idx) return 0;

  000de	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  000e3	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  000e6	39 84 24 98 00
	00 00		 cmp	 DWORD PTR sfx$[rsp], eax
  000ed	75 18		 jne	 SHORT $LN6@cckd64_rea
  000ef	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  000f4	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000f7	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR L1idx$[rsp], eax
  000fe	75 07		 jne	 SHORT $LN6@cckd64_rea
  00100	33 c0		 xor	 eax, eax
  00102	e9 5f 05 00 00	 jmp	 $LN1@cckd64_rea
$LN6@cckd64_rea:

; 2356 : 
; 2357 :     cache_lock(CACHE_L2);

  00107	b9 01 00 00 00	 mov	 ecx, 1
  0010c	e8 00 00 00 00	 call	 cache_lock

; 2358 : 
; 2359 :     /* Inactivate the previous entry */
; 2360 :     if (cckd->L2_active >= 0)

  00111	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00116	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  0011a	7c 1b		 jl	 SHORT $LN7@cckd64_rea

; 2361 :         cache_setflag(CACHE_L2, cckd->L2_active, ~L2_CACHE_ACTIVE, 0);

  0011c	45 33 c9	 xor	 r9d, r9d
  0011f	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  00125	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0012a	8b 50 50	 mov	 edx, DWORD PTR [rax+80]
  0012d	b9 01 00 00 00	 mov	 ecx, 1
  00132	e8 00 00 00 00	 call	 cache_setflag
$LN7@cckd64_rea:

; 2362 :     cckd->L2tab = NULL;

  00137	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0013c	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 2363 :     cckd->L2_active = cckd->sfx = cckd->L1idx = -1;

  00144	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00149	c7 40 44 ff ff
	ff ff		 mov	 DWORD PTR [rax+68], -1
  00150	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00155	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
  0015c	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00161	c7 40 50 ff ff
	ff ff		 mov	 DWORD PTR [rax+80], -1

; 2364 : 
; 2365 :     /* scan the cache array for the l2tab */
; 2366 :     fnd = cache_lookup (CACHE_L2, L2_CACHE_SETKEY(sfx, dev->devnum, L1idx), &lru);

  00168	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00170	48 c1 e0 30	 shl	 rax, 48			; 00000030H
  00174	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0017c	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00180	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  00184	48 0b c1	 or	 rax, rcx
  00187	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  0018f	48 0b c1	 or	 rax, rcx
  00192	4c 8d 44 24 54	 lea	 r8, QWORD PTR lru$[rsp]
  00197	48 8b d0	 mov	 rdx, rax
  0019a	b9 01 00 00 00	 mov	 ecx, 1
  0019f	e8 00 00 00 00	 call	 cache_lookup
  001a4	89 44 24 58	 mov	 DWORD PTR fnd$[rsp], eax

; 2367 : 
; 2368 :     /* check for level 2 cache hit */
; 2369 :     if (fnd >= 0)

  001a8	83 7c 24 58 00	 cmp	 DWORD PTR fnd$[rsp], 0
  001ad	0f 8c cc 00 00
	00		 jl	 $LN8@cckd64_rea

; 2370 :     {
; 2371 :         CCKD_TRACE( "l2[%d,%d] cache[%d] hit", sfx, L1idx, fnd);

  001b3	8b 44 24 58	 mov	 eax, DWORD PTR fnd$[rsp]
  001b7	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001bb	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR L1idx$[rsp]
  001c2	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001c6	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  001cd	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001d1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170662
  001d8	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  001e0	ba 43 09 00 00	 mov	 edx, 2371		; 00000943H
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170663
  001ec	e8 00 00 00 00	 call	 cckd_trace

; 2372 :         cache_setflag (CACHE_L2, fnd, 0, L2_CACHE_ACTIVE);

  001f1	41 b9 00 00 00
	80		 mov	 r9d, -2147483648	; 80000000H
  001f7	45 33 c0	 xor	 r8d, r8d
  001fa	8b 54 24 58	 mov	 edx, DWORD PTR fnd$[rsp]
  001fe	b9 01 00 00 00	 mov	 ecx, 1
  00203	e8 00 00 00 00	 call	 cache_setflag

; 2373 :         cache_setage (CACHE_L2, fnd);

  00208	8b 54 24 58	 mov	 edx, DWORD PTR fnd$[rsp]
  0020c	b9 01 00 00 00	 mov	 ecx, 1
  00211	e8 00 00 00 00	 call	 cache_setage

; 2374 :         cckdblk.stats_l2cachehits++;

  00216	48 8b 05 a8 02
	00 00		 mov	 rax, QWORD PTR cckdblk+680
  0021d	48 ff c0	 inc	 rax
  00220	48 89 05 a8 02
	00 00		 mov	 QWORD PTR cckdblk+680, rax

; 2375 :         cache_unlock (CACHE_L2);

  00227	b9 01 00 00 00	 mov	 ecx, 1
  0022c	e8 00 00 00 00	 call	 cache_unlock

; 2376 :         cckd->sfx = sfx;

  00231	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00236	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  0023d	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 2377 :         cckd->L1idx = L1idx;

  00240	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00245	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR L1idx$[rsp]
  0024c	89 48 44	 mov	 DWORD PTR [rax+68], ecx

; 2378 :         cckd->L2tab = cache_getbuf(CACHE_L2, fnd, 0);

  0024f	45 33 c0	 xor	 r8d, r8d
  00252	8b 54 24 58	 mov	 edx, DWORD PTR fnd$[rsp]
  00256	b9 01 00 00 00	 mov	 ecx, 1
  0025b	e8 00 00 00 00	 call	 cache_getbuf
  00260	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00265	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax

; 2379 :         cckd->L2_active = fnd;

  00269	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0026e	8b 4c 24 58	 mov	 ecx, DWORD PTR fnd$[rsp]
  00272	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 2380 :         return 1;

  00275	b8 01 00 00 00	 mov	 eax, 1
  0027a	e9 e7 03 00 00	 jmp	 $LN1@cckd64_rea
$LN8@cckd64_rea:

; 2381 :     }
; 2382 : 
; 2383 :     CCKD_TRACE( "l2[%d,%d] cache[%d] miss", sfx, L1idx, lru);

  0027f	8b 44 24 54	 mov	 eax, DWORD PTR lru$[rsp]
  00283	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00287	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR L1idx$[rsp]
  0028e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00292	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  00299	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0029d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170664
  002a4	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  002ac	ba 4f 09 00 00	 mov	 edx, 2383		; 0000094fH
  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170665
  002b8	e8 00 00 00 00	 call	 cckd_trace

; 2384 : 
; 2385 :     /* Steal an entry if all are busy */
; 2386 :     if (lru < 0) lru = cckd64_steal_l2();

  002bd	83 7c 24 54 00	 cmp	 DWORD PTR lru$[rsp], 0
  002c2	7d 09		 jge	 SHORT $LN9@cckd64_rea
  002c4	e8 00 00 00 00	 call	 cckd64_steal_l2
  002c9	89 44 24 54	 mov	 DWORD PTR lru$[rsp], eax
$LN9@cckd64_rea:

; 2387 : 
; 2388 :     /* Make the entry active */
; 2389 :     cache_setkey (CACHE_L2, lru, L2_CACHE_SETKEY(sfx, dev->devnum, L1idx));

  002cd	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  002d5	48 c1 e0 30	 shl	 rax, 48			; 00000030H
  002d9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e1	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002e5	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  002e9	48 0b c1	 or	 rax, rcx
  002ec	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  002f4	48 0b c1	 or	 rax, rcx
  002f7	4c 8b c0	 mov	 r8, rax
  002fa	8b 54 24 54	 mov	 edx, DWORD PTR lru$[rsp]
  002fe	b9 01 00 00 00	 mov	 ecx, 1
  00303	e8 00 00 00 00	 call	 cache_setkey

; 2390 :     cache_setflag (CACHE_L2, lru, 0, L2_CACHE_ACTIVE);

  00308	41 b9 00 00 00
	80		 mov	 r9d, -2147483648	; 80000000H
  0030e	45 33 c0	 xor	 r8d, r8d
  00311	8b 54 24 54	 mov	 edx, DWORD PTR lru$[rsp]
  00315	b9 01 00 00 00	 mov	 ecx, 1
  0031a	e8 00 00 00 00	 call	 cache_setflag

; 2391 :     cache_setage (CACHE_L2, lru);

  0031f	8b 54 24 54	 mov	 edx, DWORD PTR lru$[rsp]
  00323	b9 01 00 00 00	 mov	 ecx, 1
  00328	e8 00 00 00 00	 call	 cache_setage

; 2392 :     buf = cache_getbuf(CACHE_L2, lru, CCKD64_L2TAB_SIZE);

  0032d	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  00333	8b 54 24 54	 mov	 edx, DWORD PTR lru$[rsp]
  00337	b9 01 00 00 00	 mov	 ecx, 1
  0033c	e8 00 00 00 00	 call	 cache_getbuf
  00341	48 89 44 24 68	 mov	 QWORD PTR buf$[rsp], rax

; 2393 :     cckdblk.stats_l2cachemisses++;

  00346	48 8b 05 b0 02
	00 00		 mov	 rax, QWORD PTR cckdblk+688
  0034d	48 ff c0	 inc	 rax
  00350	48 89 05 b0 02
	00 00		 mov	 QWORD PTR cckdblk+688, rax

; 2394 :     cache_unlock (CACHE_L2);

  00357	b9 01 00 00 00	 mov	 ecx, 1
  0035c	e8 00 00 00 00	 call	 cache_unlock

; 2395 :     if (buf == NULL) return -1;

  00361	48 83 7c 24 68
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00367	75 0a		 jne	 SHORT $LN10@cckd64_rea
  00369	b8 ff ff ff ff	 mov	 eax, -1
  0036e	e9 f3 02 00 00	 jmp	 $LN1@cckd64_rea
$LN10@cckd64_rea:

; 2396 : 
; 2397 :     /* Check for null table */
; 2398 :     if (cckd->L1tab[sfx][L1idx] == 0)

  00373	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0037b	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  00383	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00388	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00390	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  00395	0f 85 bd 00 00
	00		 jne	 $LN11@cckd64_rea

; 2399 :     {
; 2400 :         memset(buf, 0, CCKD64_L2TAB_SIZE);

  0039b	48 8b 7c 24 68	 mov	 rdi, QWORD PTR buf$[rsp]
  003a0	33 c0		 xor	 eax, eax
  003a2	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  003a7	f3 aa		 rep stosb

; 2401 :         if (nullfmt)

  003a9	0f b6 44 24 50	 movzx	 eax, BYTE PTR nullfmt$[rsp]
  003ae	85 c0		 test	 eax, eax
  003b0	74 5a		 je	 SHORT $LN13@cckd64_rea

; 2402 :             for (i = 0; i < 256; i++)

  003b2	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003ba	eb 0a		 jmp	 SHORT $LN4@cckd64_rea
$LN2@cckd64_rea:
  003bc	8b 44 24 5c	 mov	 eax, DWORD PTR i$[rsp]
  003c0	ff c0		 inc	 eax
  003c2	89 44 24 5c	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd64_rea:
  003c6	81 7c 24 5c 00
	01 00 00	 cmp	 DWORD PTR i$[rsp], 256	; 00000100H
  003ce	7d 3c		 jge	 SHORT $LN3@cckd64_rea

; 2403 :                 buf[i].L2_len = buf[i].L2_size = nullfmt;

  003d0	0f b6 44 24 50	 movzx	 eax, BYTE PTR nullfmt$[rsp]
  003d5	66 89 44 24 52	 mov	 WORD PTR tv232[rsp], ax
  003da	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  003df	48 6b c0 10	 imul	 rax, rax, 16
  003e3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  003e8	0f b7 54 24 52	 movzx	 edx, WORD PTR tv232[rsp]
  003ed	66 89 54 01 0a	 mov	 WORD PTR [rcx+rax+10], dx
  003f2	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$[rsp]
  003f7	48 6b c0 10	 imul	 rax, rax, 16
  003fb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  00400	0f b7 54 24 52	 movzx	 edx, WORD PTR tv232[rsp]
  00405	66 89 54 01 08	 mov	 WORD PTR [rcx+rax+8], dx
  0040a	eb b0		 jmp	 SHORT $LN2@cckd64_rea
$LN3@cckd64_rea:
$LN13@cckd64_rea:

; 2404 :         CCKD_TRACE( "l2[%d,%d] cache[%d] null fmt[%d]", sfx, L1idx, lru, nullfmt);

  0040c	0f b6 44 24 50	 movzx	 eax, BYTE PTR nullfmt$[rsp]
  00411	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00415	8b 44 24 54	 mov	 eax, DWORD PTR lru$[rsp]
  00419	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0041d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR L1idx$[rsp]
  00424	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00428	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  0042f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00433	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170671
  0043a	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00442	ba 64 09 00 00	 mov	 edx, 2404		; 00000964H
  00447	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170672
  0044e	e8 00 00 00 00	 call	 cckd_trace

; 2405 :     }

  00453	e9 d4 01 00 00	 jmp	 $LN12@cckd64_rea
$LN11@cckd64_rea:

; 2406 :     else if (cckd->L1tab[sfx][L1idx] == CCKD64_MAXSIZE)

  00458	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00460	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  00468	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  0046d	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00475	48 83 3c c8 ff	 cmp	 QWORD PTR [rax+rcx*8], -1
  0047a	75 54		 jne	 SHORT $LN14@cckd64_rea

; 2407 :     {
; 2408 :         memset(buf, 0xff, CCKD64_L2TAB_SIZE);

  0047c	48 8b 7c 24 68	 mov	 rdi, QWORD PTR buf$[rsp]
  00481	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  00486	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0048b	f3 aa		 rep stosb

; 2409 :         CCKD_TRACE( "l2[%d,%d] cache[%d] null 0xff", sfx, L1idx, lru);

  0048d	8b 44 24 54	 mov	 eax, DWORD PTR lru$[rsp]
  00491	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00495	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR L1idx$[rsp]
  0049c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  004a0	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  004a7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  004ab	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170675
  004b2	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  004ba	ba 69 09 00 00	 mov	 edx, 2409		; 00000969H
  004bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170676
  004c6	e8 00 00 00 00	 call	 cckd_trace

; 2410 :     }

  004cb	e9 5c 01 00 00	 jmp	 $LN15@cckd64_rea
$LN14@cckd64_rea:

; 2411 :     /* Read the new level 2 table */
; 2412 :     else
; 2413 :     {
; 2414 :         off = cckd->L1tab[sfx][L1idx];

  004d0	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  004d8	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  004e0	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  004e5	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  004ed	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  004f1	48 89 44 24 70	 mov	 QWORD PTR off$[rsp], rax

; 2415 :         if (cckd64_read (dev, sfx, off, buf, CCKD64_L2TAB_SIZE) < 0)

  004f6	c7 44 24 20 00
	10 00 00	 mov	 DWORD PTR [rsp+32], 4096 ; 00001000H
  004fe	4c 8b 4c 24 68	 mov	 r9, QWORD PTR buf$[rsp]
  00503	4c 8b 44 24 70	 mov	 r8, QWORD PTR off$[rsp]
  00508	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  0050f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00517	e8 00 00 00 00	 call	 cckd64_read
  0051c	85 c0		 test	 eax, eax
  0051e	7d 32		 jge	 SHORT $LN16@cckd64_rea

; 2416 :         {
; 2417 :             cache_lock(CACHE_L2);

  00520	b9 01 00 00 00	 mov	 ecx, 1
  00525	e8 00 00 00 00	 call	 cache_lock

; 2418 :             cache_setflag(CACHE_L2, lru, 0, 0);

  0052a	45 33 c9	 xor	 r9d, r9d
  0052d	45 33 c0	 xor	 r8d, r8d
  00530	8b 54 24 54	 mov	 edx, DWORD PTR lru$[rsp]
  00534	b9 01 00 00 00	 mov	 ecx, 1
  00539	e8 00 00 00 00	 call	 cache_setflag

; 2419 :             cache_unlock(CACHE_L2);

  0053e	b9 01 00 00 00	 mov	 ecx, 1
  00543	e8 00 00 00 00	 call	 cache_unlock

; 2420 :             return -1;

  00548	b8 ff ff ff ff	 mov	 eax, -1
  0054d	e9 14 01 00 00	 jmp	 $LN1@cckd64_rea
$LN16@cckd64_rea:

; 2421 :         }
; 2422 : 
; 2423 :         if (cckd->swapend[sfx])

  00552	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0055a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0055f	0f b6 84 01 14
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+276]
  00567	85 c0		 test	 eax, eax
  00569	74 0a		 je	 SHORT $LN17@cckd64_rea

; 2424 :             cckd64_swapend_l2 (buf);

  0056b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  00570	e8 00 00 00 00	 call	 cckd64_swapend_l2
$LN17@cckd64_rea:

; 2425 : 
; 2426 :         CCKD_TRACE( "file[%d] cache[%d] l2[%d] read offset 0x%16.16"PRIx64,

  00575	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0057d	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  00585	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  0058a	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00592	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  00596	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0059b	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR L1idx$[rsp]
  005a2	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  005a6	8b 44 24 54	 mov	 eax, DWORD PTR lru$[rsp]
  005aa	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005ae	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  005b5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005b9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170679
  005c0	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  005c8	ba 7b 09 00 00	 mov	 edx, 2427		; 0000097bH
  005cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170680
  005d4	e8 00 00 00 00	 call	 cckd_trace

; 2427 :                     sfx, lru, L1idx, cckd->L1tab[sfx][L1idx]);
; 2428 : 
; 2429 :         cckd->L2_reads[sfx]++;

  005d9	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  005e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  005e6	8b 84 81 4c 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+332]
  005ed	ff c0		 inc	 eax
  005ef	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  005f7	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  005fc	89 84 8a 4c 01
	00 00		 mov	 DWORD PTR [rdx+rcx*4+332], eax

; 2430 :         cckd->totl2reads++;

  00603	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00608	8b 80 dc 00 00
	00		 mov	 eax, DWORD PTR [rax+220]
  0060e	ff c0		 inc	 eax
  00610	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00615	89 81 dc 00 00
	00		 mov	 DWORD PTR [rcx+220], eax

; 2431 :         cckdblk.stats_l2reads++;

  0061b	48 8b 05 b8 02
	00 00		 mov	 rax, QWORD PTR cckdblk+696
  00622	48 ff c0	 inc	 rax
  00625	48 89 05 b8 02
	00 00		 mov	 QWORD PTR cckdblk+696, rax
$LN15@cckd64_rea:
$LN12@cckd64_rea:

; 2432 :     }
; 2433 : 
; 2434 :     cckd->sfx = sfx;

  0062c	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00631	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  00638	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 2435 :     cckd->L1idx = L1idx;

  0063b	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00640	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR L1idx$[rsp]
  00647	89 48 44	 mov	 DWORD PTR [rax+68], ecx

; 2436 :     cckd->L2tab = buf;

  0064a	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0064f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR buf$[rsp]
  00654	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 2437 :     cckd->L2_active = lru;

  00658	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0065d	8b 4c 24 54	 mov	 ecx, DWORD PTR lru$[rsp]
  00661	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 2438 : 
; 2439 :     return 0;

  00664	33 c0		 xor	 eax, eax
$LN1@cckd64_rea:

; 2440 : 
; 2441 : } /* end function cckd64_read_l2 */

  00666	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0066d	5f		 pop	 rdi
  0066e	c3		 ret	 0
cckd64_read_l2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
cckd$ = 48
sfx$ = 56
i$ = 64
fpos$ = 72
fsp$ = 80
j$ = 88
n$ = 96
rc$ = 104
tv191 = 112
ppos$ = 120
dev$ = 144
cckd64_write_fsp PROC

; 2239 : {

$LN30:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2240 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2241 : U64             fpos;                   /* Free space offset         */
; 2242 : U64             ppos;                   /* Previous free space offset*/
; 2243 : int             sfx;                    /* File index                */
; 2244 : S64             i, j, n;                /* Work variables            */
; 2245 : int             rc;                     /* Return code               */
; 2246 : CCKD64_FREEBLK *fsp = NULL;             /* -> new format free space  */

  0000c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR fsp$[rsp], 0

; 2247 : 
; 2248 :     if (!dev->cckd64)

  00015	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00024	24 01		 and	 al, 1
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	75 12		 jne	 SHORT $LN14@cckd64_wri

; 2249 :         return cckd_write_fsp( dev );

  0002d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00035	e8 00 00 00 00	 call	 cckd_write_fsp
  0003a	e9 19 05 00 00	 jmp	 $LN1@cckd64_wri
$LN14@cckd64_wri:

; 2250 : 
; 2251 :     cckd = dev->cckd_ext;

  0003f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00047	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0004e	48 89 44 24 30	 mov	 QWORD PTR cckd$[rsp], rax

; 2252 :     sfx = cckd->sfn;

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00058	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0005b	89 44 24 38	 mov	 DWORD PTR sfx$[rsp], eax

; 2253 : 
; 2254 :     if (!cckd->ifb)

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00064	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00069	75 07		 jne	 SHORT $LN15@cckd64_wri

; 2255 :         return 0;

  0006b	33 c0		 xor	 eax, eax
  0006d	e9 e6 04 00 00	 jmp	 $LN1@cckd64_wri
$LN15@cckd64_wri:

; 2256 : 
; 2257 :     CCKD_TRACE( "file[%d] write_fsp number %"PRId64,

  00072	48 63 44 24 38	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00077	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0007e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00083	48 8b 84 01 18
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+536]
  0008b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00090	8b 44 24 38	 mov	 eax, DWORD PTR sfx$[rsp]
  00094	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00098	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170602
  0009f	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000a7	ba d2 08 00 00	 mov	 edx, 2258		; 000008d2H
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170603
  000b3	e8 00 00 00 00	 call	 cckd_trace

; 2258 :                 sfx, cckd->cdevhdr[sfx].free_num);
; 2259 : 
; 2260 :     /* get rid of pending free space */
; 2261 :     for (i = 0; i < CCKD_MAX_FREEPEND; i++)

  000b8	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  000c1	eb 0d		 jmp	 SHORT $LN4@cckd64_wri
$LN2@cckd64_wri:
  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR i$[rsp]
  000c8	48 ff c0	 inc	 rax
  000cb	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN4@cckd64_wri:
  000d0	48 83 7c 24 40
	04		 cmp	 QWORD PTR i$[rsp], 4
  000d6	7d 0f		 jge	 SHORT $LN3@cckd64_wri

; 2262 :         cckd64_flush_space(dev);

  000d8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000e0	e8 00 00 00 00	 call	 cckd64_flush_space
  000e5	eb dc		 jmp	 SHORT $LN2@cckd64_wri
$LN3@cckd64_wri:

; 2263 : 
; 2264 :     /* sanity checks */
; 2265 :     if (cckd->cdevhdr[sfx].free_num == 0 || cckd->cdevhdr[sfx].free_off == 0)

  000e7	48 63 44 24 38	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000ec	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000f3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  000f8	48 83 bc 01 18
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax+536], 0
  00101	74 1c		 je	 SHORT $LN17@cckd64_wri
  00103	48 63 44 24 38	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00108	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0010f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00114	48 83 bc 01 00
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax+512], 0
  0011d	75 64		 jne	 SHORT $LN16@cckd64_wri
$LN17@cckd64_wri:

; 2266 :     {
; 2267 :         cckd->cdevhdr[sfx].free_num = cckd->cdevhdr[sfx].free_off = 0;

  0011f	48 63 44 24 38	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00124	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0012b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00130	48 c7 84 01 00
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+512], 0
  0013c	48 63 44 24 38	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00141	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00148	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  0014d	48 c7 84 01 18
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+536], 0

; 2268 :         cckd->free_idx1st = cckd->free_idxlast = cckd->free_idxavail = -1;

  00159	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  0015e	c7 80 84 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+132], -1
  00168	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  0016d	c7 80 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+128], -1
  00177	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  0017c	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1
$LN16@cckd64_wri:

; 2269 :     }
; 2270 : 
; 2271 :     /* Write any free spaces */
; 2272 :     if (cckd->cdevhdr[sfx].free_off)

  00183	48 63 44 24 38	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00188	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0018f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00194	48 83 bc 01 00
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax+512], 0
  0019d	0f 84 57 03 00
	00		 je	 $LN18@cckd64_wri

; 2273 :     {
; 2274 :         /* size needed for new format free space */
; 2275 :         n = (cckd->cdevhdr[sfx].free_num+1) * CCKD64_FREEBLK_SIZE;

  001a3	48 63 44 24 38	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001a8	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  001b4	48 8b 84 01 18
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+536]
  001bc	48 ff c0	 inc	 rax
  001bf	48 6b c0 10	 imul	 rax, rax, 16
  001c3	48 89 44 24 60	 mov	 QWORD PTR n$[rsp], rax

; 2276 : 
; 2277 :         /* look for existing free space to fit new format free space */
; 2278 :         fpos = 0;

  001c8	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR fpos$[rsp], 0

; 2279 :         for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  001d1	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  001d6	48 63 40 7c	 movsxd	 rax, DWORD PTR [rax+124]
  001da	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  001df	eb 19		 jmp	 SHORT $LN7@cckd64_wri
$LN5@cckd64_wri:
  001e1	48 6b 44 24 40
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  001e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ec	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  001f0	48 63 44 01 14	 movsxd	 rax, DWORD PTR [rcx+rax+20]
  001f5	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN7@cckd64_wri:
  001fa	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  00200	7c 1f		 jl	 SHORT $LN6@cckd64_wri

; 2280 :             if ((U64)n <= cckd->ifb[i].ifb_len)

  00202	48 6b 44 24 40
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  00208	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  0020d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00211	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00216	48 39 44 24 60	 cmp	 QWORD PTR n$[rsp], rax
  0021b	77 02		 ja	 SHORT $LN19@cckd64_wri

; 2281 :                 break;

  0021d	eb 02		 jmp	 SHORT $LN6@cckd64_wri
$LN19@cckd64_wri:
  0021f	eb c0		 jmp	 SHORT $LN5@cckd64_wri
$LN6@cckd64_wri:

; 2282 :         if (i >= 0)

  00221	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  00227	7c 6a		 jl	 SHORT $LN20@cckd64_wri

; 2283 :             fpos = cckd->ifb[i].ifb_idxprv < 0

  00229	48 6b 44 24 40
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  0022f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00234	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00238	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  0023d	7d 20		 jge	 SHORT $LN28@cckd64_wri
  0023f	48 63 44 24 38	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00244	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0024b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00250	48 8b 84 01 00
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+512]
  00258	48 89 44 24 70	 mov	 QWORD PTR tv191[rsp], rax
  0025d	eb 2a		 jmp	 SHORT $LN29@cckd64_wri
$LN28@cckd64_wri:
  0025f	48 6b 44 24 40
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  00265	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  0026a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0026e	48 63 44 01 10	 movsxd	 rax, DWORD PTR [rcx+rax+16]
  00273	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00277	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  0027c	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00280	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00284	48 89 44 24 70	 mov	 QWORD PTR tv191[rsp], rax
$LN29@cckd64_wri:
  00289	48 8b 44 24 70	 mov	 rax, QWORD PTR tv191[rsp]
  0028e	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax
$LN20@cckd64_wri:

; 2284 :                  ? cckd->cdevhdr[sfx].free_off
; 2285 :                  : cckd->ifb[cckd->ifb[i].ifb_idxprv].ifb_offnxt;
; 2286 : 
; 2287 :         /* if no applicable space see if we can append to the file */
; 2288 :         if (fpos == 0 && cckd->cckd_maxsize - cckd->cdevhdr[sfx].cdh_size >= (U64)n)

  00293	48 83 7c 24 48
	00		 cmp	 QWORD PTR fpos$[rsp], 0
  00299	75 4d		 jne	 SHORT $LN21@cckd64_wri
  0029b	48 63 44 24 38	 movsxd	 rax, DWORD PTR sfx$[rsp]
  002a0	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  002a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  002ac	48 8b 54 24 30	 mov	 rdx, QWORD PTR cckd$[rsp]
  002b1	48 8b 84 02 f0
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax+496]
  002b9	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  002bd	48 2b c8	 sub	 rcx, rax
  002c0	48 8b c1	 mov	 rax, rcx
  002c3	48 3b 44 24 60	 cmp	 rax, QWORD PTR n$[rsp]
  002c8	72 1e		 jb	 SHORT $LN21@cckd64_wri

; 2289 :             fpos = cckd->cdevhdr[sfx].cdh_size;

  002ca	48 63 44 24 38	 movsxd	 rax, DWORD PTR sfx$[rsp]
  002cf	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  002d6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  002db	48 8b 84 01 f0
	01 00 00	 mov	 rax, QWORD PTR [rcx+rax+496]
  002e3	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax
$LN21@cckd64_wri:

; 2290 : 
; 2291 :         if (fpos && !(fsp = cckd_malloc( dev, "fsp", (size_t) n )))

  002e8	48 83 7c 24 48
	00		 cmp	 QWORD PTR fpos$[rsp], 0
  002ee	74 2f		 je	 SHORT $LN22@cckd64_wri
  002f0	4c 8b 44 24 60	 mov	 r8, QWORD PTR n$[rsp]
  002f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170611
  002fc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00304	e8 00 00 00 00	 call	 cckd_malloc
  00309	48 89 44 24 50	 mov	 QWORD PTR fsp$[rsp], rax
  0030e	48 83 7c 24 50
	00		 cmp	 QWORD PTR fsp$[rsp], 0
  00314	75 09		 jne	 SHORT $LN22@cckd64_wri

; 2292 :             fpos = 0;

  00316	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR fpos$[rsp], 0
$LN22@cckd64_wri:

; 2293 : 
; 2294 :         if (fpos)

  0031f	48 83 7c 24 48
	00		 cmp	 QWORD PTR fpos$[rsp], 0
  00325	0f 84 49 01 00
	00		 je	 $LN23@cckd64_wri

; 2295 :         {
; 2296 :             /* New format free space */
; 2297 :             memcpy (&fsp[0], "FREE_BLK", 8);

  0032b	b8 10 00 00 00	 mov	 eax, 16
  00330	48 6b c0 00	 imul	 rax, rax, 0
  00334	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fsp$[rsp]
  00339	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR $SG170614
  00340	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 2298 :             ppos = cckd->cdevhdr[sfx].free_off;

  00344	48 63 44 24 38	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00349	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00350	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00355	48 8b 84 01 00
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+512]
  0035d	48 89 44 24 78	 mov	 QWORD PTR ppos$[rsp], rax

; 2299 :             for (i = cckd->free_idx1st, j = 1; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  00362	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00367	48 63 40 7c	 movsxd	 rax, DWORD PTR [rax+124]
  0036b	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  00370	48 c7 44 24 58
	01 00 00 00	 mov	 QWORD PTR j$[rsp], 1
  00379	eb 19		 jmp	 SHORT $LN10@cckd64_wri
$LN8@cckd64_wri:
  0037b	48 6b 44 24 40
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  00381	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00386	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0038a	48 63 44 01 14	 movsxd	 rax, DWORD PTR [rcx+rax+20]
  0038f	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN10@cckd64_wri:
  00394	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  0039a	7c 5f		 jl	 SHORT $LN9@cckd64_wri

; 2300 :             {
; 2301 :                 fsp[j].fb_offnxt = ppos;

  0039c	48 6b 44 24 58
	10		 imul	 rax, QWORD PTR j$[rsp], 16
  003a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR fsp$[rsp]
  003a7	48 8b 54 24 78	 mov	 rdx, QWORD PTR ppos$[rsp]
  003ac	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 2302 :                 fsp[j++].fb_len = cckd->ifb[i].ifb_len;

  003b0	48 6b 44 24 40
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  003b6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  003bb	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003bf	48 6b 54 24 58
	10		 imul	 rdx, QWORD PTR j$[rsp], 16
  003c5	4c 8b 44 24 50	 mov	 r8, QWORD PTR fsp$[rsp]
  003ca	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  003cf	49 89 44 10 08	 mov	 QWORD PTR [r8+rdx+8], rax
  003d4	48 8b 44 24 58	 mov	 rax, QWORD PTR j$[rsp]
  003d9	48 ff c0	 inc	 rax
  003dc	48 89 44 24 58	 mov	 QWORD PTR j$[rsp], rax

; 2303 :                 ppos = cckd->ifb[i].ifb_offnxt;

  003e1	48 6b 44 24 40
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  003e7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  003ec	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003f0	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  003f4	48 89 44 24 78	 mov	 QWORD PTR ppos$[rsp], rax

; 2304 :             }

  003f9	eb 80		 jmp	 SHORT $LN8@cckd64_wri
$LN9@cckd64_wri:

; 2305 :             rc = cckd64_write (dev, sfx, fpos, fsp, (unsigned int)n);

  003fb	8b 44 24 60	 mov	 eax, DWORD PTR n$[rsp]
  003ff	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00403	4c 8b 4c 24 50	 mov	 r9, QWORD PTR fsp$[rsp]
  00408	4c 8b 44 24 48	 mov	 r8, QWORD PTR fpos$[rsp]
  0040d	8b 54 24 38	 mov	 edx, DWORD PTR sfx$[rsp]
  00411	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00419	e8 00 00 00 00	 call	 cckd64_write
  0041e	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 2306 :             fsp = cckd_free (dev, "fsp", fsp);

  00422	4c 8b 44 24 50	 mov	 r8, QWORD PTR fsp$[rsp]
  00427	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170615
  0042e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00436	e8 00 00 00 00	 call	 cckd_free
  0043b	48 89 44 24 50	 mov	 QWORD PTR fsp$[rsp], rax

; 2307 :             if (rc < 0)

  00440	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  00445	7d 0a		 jge	 SHORT $LN25@cckd64_wri

; 2308 :                 return -1;

  00447	b8 ff ff ff ff	 mov	 eax, -1
  0044c	e9 07 01 00 00	 jmp	 $LN1@cckd64_wri
$LN25@cckd64_wri:

; 2309 :             cckd->cdevhdr[sfx].free_off = fpos;

  00451	48 63 44 24 38	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00456	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0045d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00462	48 8b 54 24 48	 mov	 rdx, QWORD PTR fpos$[rsp]
  00467	48 89 94 01 00
	02 00 00	 mov	 QWORD PTR [rcx+rax+512], rdx

; 2310 :         } /* new format free space */

  0046f	e9 86 00 00 00	 jmp	 $LN24@cckd64_wri
$LN23@cckd64_wri:

; 2311 :         else
; 2312 :         {
; 2313 :             /* Old format free space */
; 2314 :             for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  00474	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00479	48 63 40 7c	 movsxd	 rax, DWORD PTR [rax+124]
  0047d	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
  00482	eb 19		 jmp	 SHORT $LN13@cckd64_wri
$LN11@cckd64_wri:
  00484	48 6b 44 24 40
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  0048a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  0048f	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00493	48 63 44 01 14	 movsxd	 rax, DWORD PTR [rcx+rax+20]
  00498	48 89 44 24 40	 mov	 QWORD PTR i$[rsp], rax
$LN13@cckd64_wri:
  0049d	48 83 7c 24 40
	00		 cmp	 QWORD PTR i$[rsp], 0
  004a3	7c 55		 jl	 SHORT $LN12@cckd64_wri

; 2315 :             {
; 2316 :                 if (cckd64_write (dev, sfx, fpos, &cckd->ifb[i], CCKD64_FREEBLK_SIZE) < 0)

  004a5	48 6b 44 24 40
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  004ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  004b0	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  004b4	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  004bc	4c 8b c8	 mov	 r9, rax
  004bf	4c 8b 44 24 48	 mov	 r8, QWORD PTR fpos$[rsp]
  004c4	8b 54 24 38	 mov	 edx, DWORD PTR sfx$[rsp]
  004c8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004d0	e8 00 00 00 00	 call	 cckd64_write
  004d5	85 c0		 test	 eax, eax
  004d7	7d 07		 jge	 SHORT $LN26@cckd64_wri

; 2317 :                     return -1;

  004d9	b8 ff ff ff ff	 mov	 eax, -1
  004de	eb 78		 jmp	 SHORT $LN1@cckd64_wri
$LN26@cckd64_wri:

; 2318 :                 fpos = cckd->ifb[i].ifb_offnxt;

  004e0	48 6b 44 24 40
	20		 imul	 rax, QWORD PTR i$[rsp], 32 ; 00000020H
  004e6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  004eb	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004ef	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  004f3	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax

; 2319 :             }

  004f8	eb 8a		 jmp	 SHORT $LN11@cckd64_wri
$LN12@cckd64_wri:
$LN24@cckd64_wri:
$LN18@cckd64_wri:

; 2320 :         } /* old format free space */
; 2321 :     } /* if (cckd->cdevhdr[sfx].free_off) */
; 2322 : 
; 2323 :     /* Free the free space array */
; 2324 :     cckd->ifb = cckd_free (dev, "ifb", cckd->ifb);

  004fa	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  004ff	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  00503	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170618
  0050a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00512	e8 00 00 00 00	 call	 cckd_free
  00517	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  0051c	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 2325 :     cckd->free_count = 0;

  00520	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00525	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [rax+120], 0

; 2326 :     cckd->free_idx1st = cckd->free_idxlast = cckd->free_idxavail = -1;

  0052c	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00531	c7 80 84 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+132], -1
  0053b	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00540	c7 80 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+128], -1
  0054a	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  0054f	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1

; 2327 : 
; 2328 :     return 0;

  00556	33 c0		 xor	 eax, eax
$LN1@cckd64_wri:

; 2329 : 
; 2330 : } /* end function cckd64_write_fsp */

  00558	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0055f	c3		 ret	 0
cckd64_write_fsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
i$ = 48
cckd$ = 56
sfx$ = 64
fpos$ = 72
fsp$1 = 80
tv366 = 88
tv139 = 96
tv142 = 104
n$2 = 112
ofree$3 = 120
freeblk$ = 128
__$ArrayPad$ = 144
dev$ = 176
cckd64_read_fsp PROC

; 2128 : {

$LN29:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2129 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2130 : U64             fpos;                   /* Free space offset         */
; 2131 : int             sfx;                    /* File index                */
; 2132 : int             i;                      /* Index                     */
; 2133 : CCKD64_FREEBLK  freeblk;                /* First freeblk read        */
; 2134 : 
; 2135 :     if (!dev->cckd64)

  0001e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0002d	24 01		 and	 al, 1
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	75 12		 jne	 SHORT $LN11@cckd64_rea

; 2136 :         return cckd_read_fsp( dev );

  00036	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0003e	e8 00 00 00 00	 call	 cckd_read_fsp
  00043	e9 9d 06 00 00	 jmp	 $LN1@cckd64_rea
$LN11@cckd64_rea:

; 2137 : 
; 2138 :     cckd = dev->cckd_ext;

  00048	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00050	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00057	48 89 44 24 38	 mov	 QWORD PTR cckd$[rsp], rax

; 2139 :     sfx = cckd->sfn;

  0005c	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00061	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00064	89 44 24 40	 mov	 DWORD PTR sfx$[rsp], eax

; 2140 : 
; 2141 :     CCKD_TRACE( "file[%d] read_fsp number %"PRId64,

  00068	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0006d	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00074	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00079	48 8b 84 01 18
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+536]
  00081	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00086	8b 44 24 40	 mov	 eax, DWORD PTR sfx$[rsp]
  0008a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0008e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170548
  00095	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0009d	ba 5e 08 00 00	 mov	 edx, 2142		; 0000085eH
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170549
  000a9	e8 00 00 00 00	 call	 cckd_trace

; 2142 :                 sfx, cckd->cdevhdr[sfx].free_num );
; 2143 : 
; 2144 :     cckd->ifb = cckd_free( dev, "ifb", cckd->ifb );

  000ae	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  000b3	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170550
  000be	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000c6	e8 00 00 00 00	 call	 cckd_free
  000cb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000d0	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 2145 : 
; 2146 :     cckd->free_count    =  0;

  000d4	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  000d9	c7 40 78 00 00
	00 00		 mov	 DWORD PTR [rax+120], 0

; 2147 :     cckd->free_idx1st   = -1;

  000e0	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  000e5	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1

; 2148 :     cckd->free_idxlast  = -1;

  000ec	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  000f1	c7 80 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+128], -1

; 2149 :     cckd->free_idxavail = -1;

  000fb	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00100	c7 80 84 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+132], -1

; 2150 : 
; 2151 :     /* Get storage for the internal free space chain
; 2152 :      * in a multiple of 1024 entries
; 2153 :      */
; 2154 :     i = (int) ROUND_UP( cckd->cdevhdr[sfx].free_num, CCKD_IFB_ENTS_INCR );

  0010a	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0010f	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00116	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0011b	48 83 bc 01 18
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax+536], 0
  00124	74 3d		 je	 SHORT $LN25@cckd64_rea
  00126	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0012b	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00132	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00137	48 8b 84 01 18
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+536]
  0013f	48 05 ff 03 00
	00		 add	 rax, 1023		; 000003ffH
  00145	48 99		 cdq
  00147	48 81 e2 ff 03
	00 00		 and	 rdx, 1023		; 000003ffH
  0014e	48 03 c2	 add	 rax, rdx
  00151	48 c1 f8 0a	 sar	 rax, 10
  00155	48 69 c0 00 04
	00 00		 imul	 rax, rax, 1024		; 00000400H
  0015c	48 89 44 24 60	 mov	 QWORD PTR tv139[rsp], rax
  00161	eb 09		 jmp	 SHORT $LN26@cckd64_rea
$LN25@cckd64_rea:
  00163	48 c7 44 24 60
	00 04 00 00	 mov	 QWORD PTR tv139[rsp], 1024 ; 00000400H
$LN26@cckd64_rea:
  0016c	8b 44 24 60	 mov	 eax, DWORD PTR tv139[rsp]
  00170	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax

; 2155 :     if (!(cckd->ifb = cckd_calloc( dev, "ifb", i, CCKD64_IFREEBLK_SIZE )))

  00174	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00179	41 b9 20 00 00
	00		 mov	 r9d, 32			; 00000020H
  0017f	4c 8b c0	 mov	 r8, rax
  00182	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170552
  00189	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00191	e8 00 00 00 00	 call	 cckd_calloc
  00196	48 89 44 24 68	 mov	 QWORD PTR tv142[rsp], rax
  0019b	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  001a0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv142[rsp]
  001a5	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
  001a9	48 83 7c 24 68
	00		 cmp	 QWORD PTR tv142[rsp], 0
  001af	75 0a		 jne	 SHORT $LN12@cckd64_rea

; 2156 :         return -1;

  001b1	b8 ff ff ff ff	 mov	 eax, -1
  001b6	e9 2a 05 00 00	 jmp	 $LN1@cckd64_rea
$LN12@cckd64_rea:

; 2157 : 
; 2158 :     cckd->free_count = i;

  001bb	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  001c0	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  001c4	89 48 78	 mov	 DWORD PTR [rax+120], ecx

; 2159 : 
; 2160 :     /* Build the doubly linked internal free space chain */
; 2161 :     if (cckd->cdevhdr[sfx].free_num)

  001c7	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001cc	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001d3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  001d8	48 83 bc 01 18
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax+536], 0
  001e1	0f 84 07 04 00
	00		 je	 $LN13@cckd64_rea

; 2162 :     {
; 2163 :         cckd->free_idx1st = 0;

  001e7	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  001ec	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0

; 2164 : 
; 2165 :         /* Read the first freeblk to determine old/new format */
; 2166 :         fpos = cckd->cdevhdr[sfx].free_off;

  001f3	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001f8	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001ff	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00204	48 8b 84 01 00
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+512]
  0020c	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax

; 2167 :         if (cckd64_read (dev, sfx, fpos, &freeblk, CCKD64_FREEBLK_SIZE) < 0)

  00211	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00219	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR freeblk$[rsp]
  00221	4c 8b 44 24 48	 mov	 r8, QWORD PTR fpos$[rsp]
  00226	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  0022a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00232	e8 00 00 00 00	 call	 cckd64_read
  00237	85 c0		 test	 eax, eax
  00239	7d 0a		 jge	 SHORT $LN14@cckd64_rea

; 2168 :             return -1;

  0023b	b8 ff ff ff ff	 mov	 eax, -1
  00240	e9 a0 04 00 00	 jmp	 $LN1@cckd64_rea
$LN14@cckd64_rea:

; 2169 : 
; 2170 :         if (memcmp(&freeblk, "FREE_BLK", 8) == 0)

  00245	41 b8 08 00 00
	00		 mov	 r8d, 8
  0024b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170557
  00252	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR freeblk$[rsp]
  0025a	e8 00 00 00 00	 call	 memcmp
  0025f	85 c0		 test	 eax, eax
  00261	0f 85 6a 02 00
	00		 jne	 $LN15@cckd64_rea

; 2171 :         {
; 2172 :             /* new format free space */
; 2173 :             CCKD64_FREEBLK *fsp;
; 2174 :             U64 ofree = cckd->cdevhdr[sfx].free_off;

  00267	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0026c	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00273	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00278	48 8b 84 01 00
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+512]
  00280	48 89 44 24 78	 mov	 QWORD PTR ofree$3[rsp], rax

; 2175 :             S64 n = cckd->cdevhdr[sfx].free_num * CCKD64_FREEBLK_SIZE;

  00285	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0028a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00291	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00296	48 6b 84 01 18
	02 00 00 10	 imul	 rax, QWORD PTR [rcx+rax+536], 16
  0029f	48 89 44 24 70	 mov	 QWORD PTR n$2[rsp], rax

; 2176 :             if (!(fsp = cckd_malloc( dev, "fsp", (size_t) n )))

  002a4	4c 8b 44 24 70	 mov	 r8, QWORD PTR n$2[rsp]
  002a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170559
  002b0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002b8	e8 00 00 00 00	 call	 cckd_malloc
  002bd	48 89 44 24 50	 mov	 QWORD PTR fsp$1[rsp], rax
  002c2	48 83 7c 24 50
	00		 cmp	 QWORD PTR fsp$1[rsp], 0
  002c8	75 0a		 jne	 SHORT $LN17@cckd64_rea

; 2177 :                 return -1;

  002ca	b8 ff ff ff ff	 mov	 eax, -1
  002cf	e9 11 04 00 00	 jmp	 $LN1@cckd64_rea
$LN17@cckd64_rea:

; 2178 :             fpos += CCKD64_FREEBLK_SIZE;

  002d4	48 8b 44 24 48	 mov	 rax, QWORD PTR fpos$[rsp]
  002d9	48 83 c0 10	 add	 rax, 16
  002dd	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax

; 2179 :             if (cckd64_read (dev, sfx, fpos, fsp, (unsigned int) n) < 0)

  002e2	8b 44 24 70	 mov	 eax, DWORD PTR n$2[rsp]
  002e6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002ea	4c 8b 4c 24 50	 mov	 r9, QWORD PTR fsp$1[rsp]
  002ef	4c 8b 44 24 48	 mov	 r8, QWORD PTR fpos$[rsp]
  002f4	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  002f8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00300	e8 00 00 00 00	 call	 cckd64_read
  00305	85 c0		 test	 eax, eax
  00307	7d 0a		 jge	 SHORT $LN18@cckd64_rea

; 2180 :                 return -1;

  00309	b8 ff ff ff ff	 mov	 eax, -1
  0030e	e9 d2 03 00 00	 jmp	 $LN1@cckd64_rea
$LN18@cckd64_rea:

; 2181 :             for (i = 0; i < cckd->cdevhdr[sfx].free_num; i++)

  00313	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0031b	eb 0a		 jmp	 SHORT $LN4@cckd64_rea
$LN2@cckd64_rea:
  0031d	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00321	ff c0		 inc	 eax
  00323	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd64_rea:
  00327	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0032c	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00331	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00338	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  0033d	48 3b 84 0a 18
	02 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+536]
  00345	0f 8d e1 00 00
	00		 jge	 $LN3@cckd64_rea

; 2182 :             {
; 2183 :                 if (i == 0)

  0034b	83 7c 24 30 00	 cmp	 DWORD PTR i$[rsp], 0
  00350	75 2d		 jne	 SHORT $LN19@cckd64_rea

; 2184 :                     cckd->cdevhdr[sfx].free_off = fsp[i].fb_offnxt;

  00352	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00357	48 6b c0 10	 imul	 rax, rax, 16
  0035b	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00360	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00367	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  0036c	4c 8b 44 24 50	 mov	 r8, QWORD PTR fsp$1[rsp]
  00371	49 8b 04 00	 mov	 rax, QWORD PTR [r8+rax]
  00375	48 89 84 0a 00
	02 00 00	 mov	 QWORD PTR [rdx+rcx+512], rax
  0037d	eb 2c		 jmp	 SHORT $LN20@cckd64_rea
$LN19@cckd64_rea:

; 2185 :                 else
; 2186 :                     cckd->ifb[i-1].ifb_offnxt = fsp[i].fb_offnxt;

  0037f	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00384	48 6b c0 10	 imul	 rax, rax, 16
  00388	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  0038c	ff c9		 dec	 ecx
  0038e	48 63 c9	 movsxd	 rcx, ecx
  00391	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00395	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  0039a	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0039e	4c 8b 44 24 50	 mov	 r8, QWORD PTR fsp$1[rsp]
  003a3	49 8b 04 00	 mov	 rax, QWORD PTR [r8+rax]
  003a7	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax
$LN20@cckd64_rea:

; 2187 :                 cckd->ifb[i].ifb_offnxt  = 0;

  003ab	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  003b0	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  003b4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  003b9	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003bd	48 c7 04 01 00
	00 00 00	 mov	 QWORD PTR [rcx+rax], 0

; 2188 :                 cckd->ifb[i].ifb_len  = fsp[i].fb_len;

  003c5	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  003ca	48 6b c0 10	 imul	 rax, rax, 16
  003ce	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003d3	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  003d7	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  003dc	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  003e0	4c 8b 44 24 50	 mov	 r8, QWORD PTR fsp$1[rsp]
  003e5	49 8b 44 00 08	 mov	 rax, QWORD PTR [r8+rax+8]
  003ea	48 89 44 0a 08	 mov	 QWORD PTR [rdx+rcx+8], rax

; 2189 :                 cckd->ifb[i].ifb_idxprv = i - 1;

  003ef	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  003f3	ff c8		 dec	 eax
  003f5	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003fa	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  003fe	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  00403	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00407	89 44 0a 10	 mov	 DWORD PTR [rdx+rcx+16], eax

; 2190 :                 cckd->ifb[i].ifb_idxnxt = i + 1;

  0040b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0040f	ff c0		 inc	 eax
  00411	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00416	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  0041a	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  0041f	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00423	89 44 0a 14	 mov	 DWORD PTR [rdx+rcx+20], eax

; 2191 :             }

  00427	e9 f1 fe ff ff	 jmp	 $LN2@cckd64_rea
$LN3@cckd64_rea:

; 2192 :             cckd->ifb[i-1].ifb_idxnxt = -1;

  0042c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00430	ff c8		 dec	 eax
  00432	48 98		 cdqe
  00434	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00438	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0043d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00441	c7 44 01 14 ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+20], -1

; 2193 :             cckd->free_idxlast = i-1;

  00449	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0044d	ff c8		 dec	 eax
  0044f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00454	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 2194 :             fsp = cckd_free (dev, "fsp", fsp);

  0045a	4c 8b 44 24 50	 mov	 r8, QWORD PTR fsp$1[rsp]
  0045f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170563
  00466	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0046e	e8 00 00 00 00	 call	 cckd_free
  00473	48 89 44 24 50	 mov	 QWORD PTR fsp$1[rsp], rax

; 2195 : 
; 2196 :             /* truncate if new format free space was at the end */
; 2197 :             if (ofree == cckd->cdevhdr[sfx].cdh_size)

  00478	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0047d	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00484	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00489	48 8b 84 01 f0
	01 00 00	 mov	 rax, QWORD PTR [rcx+rax+496]
  00491	48 39 44 24 78	 cmp	 QWORD PTR ofree$3[rsp], rax
  00496	75 34		 jne	 SHORT $LN21@cckd64_rea

; 2198 :             {
; 2199 :                 fpos = cckd->cdevhdr[sfx].cdh_size;

  00498	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0049d	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004a4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  004a9	48 8b 84 01 f0
	01 00 00	 mov	 rax, QWORD PTR [rcx+rax+496]
  004b1	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax

; 2200 :                 cckd64_ftruncate(dev, sfx, fpos);

  004b6	4c 8b 44 24 48	 mov	 r8, QWORD PTR fpos$[rsp]
  004bb	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  004bf	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004c7	e8 00 00 00 00	 call	 cckd64_ftruncate
$LN21@cckd64_rea:

; 2201 :             }
; 2202 :         } /* new format free space */

  004cc	e9 1d 01 00 00	 jmp	 $LN16@cckd64_rea
$LN15@cckd64_rea:

; 2203 :         else
; 2204 :         {
; 2205 :             /* old format free space */
; 2206 :             fpos = cckd->cdevhdr[sfx].free_off;

  004d1	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  004d6	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004dd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  004e2	48 8b 84 01 00
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+512]
  004ea	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax

; 2207 :             for (i = 0; i < cckd->cdevhdr[sfx].free_num; i++)

  004ef	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004f7	eb 0a		 jmp	 SHORT $LN7@cckd64_rea
$LN5@cckd64_rea:
  004f9	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004fd	ff c0		 inc	 eax
  004ff	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@cckd64_rea:
  00503	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00508	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0050d	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00514	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  00519	48 3b 84 0a 18
	02 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+536]
  00521	0f 8d 99 00 00
	00		 jge	 $LN6@cckd64_rea

; 2208 :             {
; 2209 :                 if (cckd64_read (dev, sfx, fpos, &cckd->ifb[i], CCKD64_FREEBLK_SIZE) < 0)

  00527	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0052c	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00530	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00535	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  00539	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00541	4c 8b c8	 mov	 r9, rax
  00544	4c 8b 44 24 48	 mov	 r8, QWORD PTR fpos$[rsp]
  00549	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  0054d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00555	e8 00 00 00 00	 call	 cckd64_read
  0055a	85 c0		 test	 eax, eax
  0055c	7d 0a		 jge	 SHORT $LN22@cckd64_rea

; 2210 :                     return -1;

  0055e	b8 ff ff ff ff	 mov	 eax, -1
  00563	e9 7d 01 00 00	 jmp	 $LN1@cckd64_rea
$LN22@cckd64_rea:

; 2211 :                 cckd->ifb[i].ifb_idxprv = i - 1;

  00568	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0056c	ff c8		 dec	 eax
  0056e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00573	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00577	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  0057c	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00580	89 44 0a 10	 mov	 DWORD PTR [rdx+rcx+16], eax

; 2212 :                 cckd->ifb[i].ifb_idxnxt = i + 1;

  00584	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00588	ff c0		 inc	 eax
  0058a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0058f	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00593	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  00598	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0059c	89 44 0a 14	 mov	 DWORD PTR [rdx+rcx+20], eax

; 2213 :                 fpos = cckd->ifb[i].ifb_offnxt;

  005a0	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  005a5	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  005a9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  005ae	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  005b2	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  005b6	48 89 44 24 48	 mov	 QWORD PTR fpos$[rsp], rax

; 2214 :             }

  005bb	e9 39 ff ff ff	 jmp	 $LN5@cckd64_rea
$LN6@cckd64_rea:

; 2215 :             cckd->ifb[i-1].ifb_idxnxt = -1;

  005c0	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005c4	ff c8		 dec	 eax
  005c6	48 98		 cdqe
  005c8	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  005cc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  005d1	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  005d5	c7 44 01 14 ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+20], -1

; 2216 :             cckd->free_idxlast = i-1;

  005dd	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005e1	ff c8		 dec	 eax
  005e3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  005e8	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax
$LN16@cckd64_rea:
$LN13@cckd64_rea:

; 2217 :         } /* old format free space */
; 2218 :     } /* if (cckd->cdevhdr[sfx].free_num) */
; 2219 : 
; 2220 :     /* Build singly linked chain of available free space entries */
; 2221 :     if (cckd->cdevhdr[sfx].free_num < cckd->free_count)

  005ee	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  005f3	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  005fa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  005ff	48 63 49 78	 movsxd	 rcx, DWORD PTR [rcx+120]
  00603	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  00608	48 39 8c 02 18
	02 00 00	 cmp	 QWORD PTR [rdx+rax+536], rcx
  00610	0f 8d 87 00 00
	00		 jge	 $LN23@cckd64_rea

; 2222 :     {
; 2223 :         cckd->free_idxavail = (int) cckd->cdevhdr[sfx].free_num;

  00616	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0061b	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00622	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00627	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  0062c	8b 84 02 18 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax+536]
  00633	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax

; 2224 :         for (i = cckd->free_idxavail; i < cckd->free_count; i++)

  00639	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  0063e	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00644	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00648	eb 0a		 jmp	 SHORT $LN10@cckd64_rea
$LN8@cckd64_rea:
  0064a	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0064e	ff c0		 inc	 eax
  00650	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@cckd64_rea:
  00654	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00659	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  0065c	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00660	7d 1e		 jge	 SHORT $LN9@cckd64_rea

; 2225 :             cckd->ifb[i].ifb_idxnxt = i + 1;

  00662	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00666	ff c0		 inc	 eax
  00668	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0066d	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00671	48 8b 54 24 38	 mov	 rdx, QWORD PTR cckd$[rsp]
  00676	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0067a	89 44 0a 14	 mov	 DWORD PTR [rdx+rcx+20], eax
  0067e	eb ca		 jmp	 SHORT $LN8@cckd64_rea
$LN9@cckd64_rea:

; 2226 :         cckd->ifb[i-1].ifb_idxnxt = -1;

  00680	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00684	ff c8		 dec	 eax
  00686	48 98		 cdqe
  00688	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0068c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00691	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00695	c7 44 01 14 ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+20], -1
$LN23@cckd64_rea:

; 2227 :     }
; 2228 : 
; 2229 :     /* Set minimum free space size */
; 2230 :     cckd->free_minsize = CCKD_MIN_FREESIZE( cckd->free_count );

  0069d	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  006a2	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  006a5	83 c0 60	 add	 eax, 96			; 00000060H
  006a8	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  006ad	7d 0a		 jge	 SHORT $LN27@cckd64_rea
  006af	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv366[rsp], 0
  006b7	eb 1b		 jmp	 SHORT $LN28@cckd64_rea
$LN27@cckd64_rea:
  006b9	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  006be	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  006c1	99		 cdq
  006c2	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  006c8	03 c2		 add	 eax, edx
  006ca	c1 f8 0a	 sar	 eax, 10
  006cd	6b c0 20	 imul	 eax, eax, 32		; 00000020H
  006d0	89 44 24 58	 mov	 DWORD PTR tv366[rsp], eax
$LN28@cckd64_rea:
  006d4	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  006d9	8b 4c 24 58	 mov	 ecx, DWORD PTR tv366[rsp]
  006dd	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx

; 2231 :     return 0;

  006e3	33 c0		 xor	 eax, eax
$LN1@cckd64_rea:

; 2232 : 
; 2233 : } /* end function cckd64_read_fsp */

  006e5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006ed	48 33 cc	 xor	 rcx, rsp
  006f0	e8 00 00 00 00	 call	 __security_check_cookie
  006f5	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  006fc	c3		 ret	 0
cckd64_read_fsp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
sfx$ = 96
imgtyp$ = 100
cckd$ = 104
tv152 = 112
tv158 = 116
tv144 = 120
devhdr$ = 128
__$ArrayPad$ = 640
dev$ = 672
cckd64_read_init PROC

; 2079 : {

$LN18:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 02
	00 00		 sub	 rsp, 664		; 00000298H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2080 :     CCKD64_EXT*     cckd;               /* -> cckd extension         */
; 2081 :     int             sfx;                /* File index                */
; 2082 :     CKD_DEVHDR      devhdr;             /* Device header             */
; 2083 :     U32             imgtyp;             /* Dasd device image type    */
; 2084 : 
; 2085 :     if (!dev->cckd64)

  0001e	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0002d	24 01		 and	 al, 1
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	75 12		 jne	 SHORT $LN2@cckd64_rea

; 2086 :         return cckd_read_init( dev );

  00036	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0003e	e8 00 00 00 00	 call	 cckd_read_init
  00043	e9 3e 02 00 00	 jmp	 $LN1@cckd64_rea
$LN2@cckd64_rea:

; 2087 : 
; 2088 :     cckd = dev->cckd_ext;

  00048	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00050	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00057	48 89 44 24 68	 mov	 QWORD PTR cckd$[rsp], rax

; 2089 :     sfx  = cckd->sfn;

  0005c	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00061	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00064	89 44 24 60	 mov	 DWORD PTR sfx$[rsp], eax

; 2090 : 
; 2091 :     CCKD_TRACE( "file[%d] read_init", sfx );

  00068	8b 44 24 60	 mov	 eax, DWORD PTR sfx$[rsp]
  0006c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00070	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170497
  00077	4c 8b 84 24 a0
	02 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0007f	ba 2b 08 00 00	 mov	 edx, 2091		; 0000082bH
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170498
  0008b	e8 00 00 00 00	 call	 cckd_trace

; 2092 : 
; 2093 :     /* Read the device header */
; 2094 :     if (cckd64_read( dev, sfx, 0, &devhdr, CKD_DEVHDR_SIZE ) < 0)

  00090	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  00098	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR devhdr$[rsp]
  000a0	45 33 c0	 xor	 r8d, r8d
  000a3	8b 54 24 60	 mov	 edx, DWORD PTR sfx$[rsp]
  000a7	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000af	e8 00 00 00 00	 call	 cckd64_read
  000b4	85 c0		 test	 eax, eax
  000b6	7d 0a		 jge	 SHORT $LN3@cckd64_rea

; 2095 :         return -1;

  000b8	b8 ff ff ff ff	 mov	 eax, -1
  000bd	e9 c4 01 00 00	 jmp	 $LN1@cckd64_rea
$LN3@cckd64_rea:

; 2096 : 
; 2097 :     /* Check the device hdr */
; 2098 :     imgtyp = dh_devid_typ( devhdr.dh_devid );

  000c2	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  000ca	e8 00 00 00 00	 call	 dh_devid_typ
  000cf	89 44 24 64	 mov	 DWORD PTR imgtyp$[rsp], eax

; 2099 : 
; 2100 :          if (!sfx && (imgtyp & CKD_C064_TYP)) cckd->ckddasd = 1;

  000d3	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  000d8	75 25		 jne	 SHORT $LN4@cckd64_rea
  000da	8b 44 24 64	 mov	 eax, DWORD PTR imgtyp$[rsp]
  000de	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  000e3	85 c0		 test	 eax, eax
  000e5	74 18		 je	 SHORT $LN4@cckd64_rea
  000e7	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  000ec	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000ef	83 c8 01	 or	 eax, 1
  000f2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  000f7	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  000fa	e9 55 01 00 00	 jmp	 $LN5@cckd64_rea
$LN4@cckd64_rea:

; 2101 :     else if (!sfx && (imgtyp & FBA_C064_TYP)) cckd->fbadasd = 1;

  000ff	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  00104	75 23		 jne	 SHORT $LN6@cckd64_rea
  00106	8b 44 24 64	 mov	 eax, DWORD PTR imgtyp$[rsp]
  0010a	83 e0 40	 and	 eax, 64			; 00000040H
  0010d	85 c0		 test	 eax, eax
  0010f	74 18		 je	 SHORT $LN6@cckd64_rea
  00111	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00116	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00119	83 c8 02	 or	 eax, 2
  0011c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cckd$[rsp]
  00121	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00124	e9 2b 01 00 00	 jmp	 $LN7@cckd64_rea
$LN6@cckd64_rea:

; 2102 :     else if (1
; 2103 :             && !(sfx && (imgtyp & CKD64_SF_TYP) && cckd->ckddasd)
; 2104 :             && !(sfx && (imgtyp & FBA64_SF_TYP) && cckd->fbadasd)

  00129	33 c0		 xor	 eax, eax
  0012b	83 f8 01	 cmp	 eax, 1
  0012e	0f 84 20 01 00
	00		 je	 $LN8@cckd64_rea
  00134	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  00139	74 20		 je	 SHORT $LN9@cckd64_rea
  0013b	8b 44 24 64	 mov	 eax, DWORD PTR imgtyp$[rsp]
  0013f	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00144	85 c0		 test	 eax, eax
  00146	74 13		 je	 SHORT $LN9@cckd64_rea
  00148	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  0014d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	0f 85 f9 00 00
	00		 jne	 $LN8@cckd64_rea
$LN9@cckd64_rea:
  0015b	83 7c 24 60 00	 cmp	 DWORD PTR sfx$[rsp], 0
  00160	74 20		 je	 SHORT $LN10@cckd64_rea
  00162	8b 44 24 64	 mov	 eax, DWORD PTR imgtyp$[rsp]
  00166	83 e0 20	 and	 eax, 32			; 00000020H
  00169	85 c0		 test	 eax, eax
  0016b	74 15		 je	 SHORT $LN10@cckd64_rea
  0016d	48 8b 44 24 68	 mov	 rax, QWORD PTR cckd$[rsp]
  00172	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00175	d1 e8		 shr	 eax, 1
  00177	83 e0 01	 and	 eax, 1
  0017a	85 c0		 test	 eax, eax
  0017c	0f 85 d2 00 00
	00		 jne	 $LN8@cckd64_rea
$LN10@cckd64_rea:

; 2105 :     )
; 2106 :     {
; 2107 :         // "%1d:%04X CCKD file[%d] %s: device header id error"
; 2108 :         WRMSG( HHC00305, "E", LCSS_DEVNUM,

  00182	48 83 bc 24 a0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0018b	74 12		 je	 SHORT $LN14@cckd64_rea
  0018d	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00195	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00199	89 44 24 70	 mov	 DWORD PTR tv152[rsp], eax
  0019d	eb 08		 jmp	 SHORT $LN15@cckd64_rea
$LN14@cckd64_rea:
  0019f	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN15@cckd64_rea:
  001a7	48 83 bc 24 a0
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001b0	74 14		 je	 SHORT $LN16@cckd64_rea
  001b2	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ba	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001be	d1 f8		 sar	 eax, 1
  001c0	89 44 24 74	 mov	 DWORD PTR tv158[rsp], eax
  001c4	eb 08		 jmp	 SHORT $LN17@cckd64_rea
$LN16@cckd64_rea:
  001c6	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
$LN17@cckd64_rea:
  001ce	8b 54 24 60	 mov	 edx, DWORD PTR sfx$[rsp]
  001d2	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001da	e8 00 00 00 00	 call	 cckd_sf_name
  001df	48 89 44 24 78	 mov	 QWORD PTR tv144[rsp], rax
  001e4	b9 01 00 00 00	 mov	 ecx, 1
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ef	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv144[rsp]
  001f4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001f9	8b 4c 24 60	 mov	 ecx, DWORD PTR sfx$[rsp]
  001fd	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00201	8b 4c 24 70	 mov	 ecx, DWORD PTR tv152[rsp]
  00205	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00209	8b 4c 24 74	 mov	 ecx, DWORD PTR tv158[rsp]
  0020d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170507
  00218	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0021d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170508
  00224	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00229	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00234	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170509
  0023b	ba 3d 08 00 00	 mov	 edx, 2109		; 0000083dH
  00240	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170510
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2109 :             sfx, cckd_sf_name( dev, sfx ));
; 2110 :         return -1;

  0024d	b8 ff ff ff ff	 mov	 eax, -1
  00252	eb 32		 jmp	 SHORT $LN1@cckd64_rea
$LN8@cckd64_rea:
$LN7@cckd64_rea:
$LN5@cckd64_rea:

; 2111 :     }
; 2112 : 
; 2113 :     /* Read the compressed header */
; 2114 :     if (cckd64_read_chdr( dev ) < 0)

  00254	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0025c	e8 00 00 00 00	 call	 cckd64_read_chdr
  00261	85 c0		 test	 eax, eax
  00263	7d 07		 jge	 SHORT $LN11@cckd64_rea

; 2115 :         return -1;

  00265	b8 ff ff ff ff	 mov	 eax, -1
  0026a	eb 1a		 jmp	 SHORT $LN1@cckd64_rea
$LN11@cckd64_rea:

; 2116 : 
; 2117 :     /* Read the level 1 table */
; 2118 :     if (cckd64_read_l1( dev ) < 0)

  0026c	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00274	e8 00 00 00 00	 call	 cckd64_read_l1
  00279	85 c0		 test	 eax, eax
  0027b	7d 07		 jge	 SHORT $LN12@cckd64_rea

; 2119 :         return -1;

  0027d	b8 ff ff ff ff	 mov	 eax, -1
  00282	eb 02		 jmp	 SHORT $LN1@cckd64_rea
$LN12@cckd64_rea:

; 2120 : 
; 2121 :     return 0;

  00284	33 c0		 xor	 eax, eax
$LN1@cckd64_rea:

; 2122 : } /* end function cckd64_read_init */

  00286	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0028e	48 33 cc	 xor	 rcx, rsp
  00291	e8 00 00 00 00	 call	 __security_check_cookie
  00296	48 81 c4 98 02
	00 00		 add	 rsp, 664		; 00000298H
  0029d	c3		 ret	 0
cckd64_read_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
sfx$ = 64
cckd$ = 72
off$ = 80
dev$ = 112
L1idx$ = 120
cckd64_write_l1ent PROC

; 2053 : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2054 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 2055 : int             sfx;                    /* File index                */
; 2056 : U64             off;                    /* Offset to l1 entry        */
; 2057 : 
; 2058 :     if (!dev->cckd64)

  0000d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00012	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00019	24 01		 and	 al, 1
  0001b	0f b6 c0	 movzx	 eax, al
  0001e	85 c0		 test	 eax, eax
  00020	75 13		 jne	 SHORT $LN2@cckd64_wri

; 2059 :         return cckd_write_l1ent( dev, L1idx );

  00022	8b 54 24 78	 mov	 edx, DWORD PTR L1idx$[rsp]
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0002b	e8 00 00 00 00	 call	 cckd_write_l1ent
  00030	e9 ac 00 00 00	 jmp	 $LN1@cckd64_wri
$LN2@cckd64_wri:

; 2060 : 
; 2061 :     cckd = dev->cckd_ext;

  00035	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0003a	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00041	48 89 44 24 48	 mov	 QWORD PTR cckd$[rsp], rax

; 2062 :     sfx = cckd->sfn;

  00046	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  0004b	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0004e	89 44 24 40	 mov	 DWORD PTR sfx$[rsp], eax

; 2063 :     off = (CCKD64_L1TAB_POS + L1idx * CCKD64_L1ENT_SIZE);

  00052	48 63 44 24 78	 movsxd	 rax, DWORD PTR L1idx$[rsp]
  00057	48 8d 04 c5 00
	04 00 00	 lea	 rax, QWORD PTR [rax*8+1024]
  0005f	48 89 44 24 50	 mov	 QWORD PTR off$[rsp], rax

; 2064 : 
; 2065 :     CCKD_TRACE( "file[%d] write_l1ent[%d] , 0x%16.16"PRIx64,

  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR off$[rsp]
  00069	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0006e	8b 44 24 78	 mov	 eax, DWORD PTR L1idx$[rsp]
  00072	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00076	8b 44 24 40	 mov	 eax, DWORD PTR sfx$[rsp]
  0007a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0007e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170484
  00085	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  0008a	ba 12 08 00 00	 mov	 edx, 2066		; 00000812H
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170485
  00096	e8 00 00 00 00	 call	 cckd_trace

; 2066 :                 sfx, L1idx, off);
; 2067 : 
; 2068 :     if (cckd64_write (dev, sfx, off, &cckd->L1tab[sfx][L1idx], CCKD64_L1ENT_SIZE) < 0)

  0009b	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000a0	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000a5	48 8b 54 24 48	 mov	 rdx, QWORD PTR cckd$[rsp]
  000aa	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000b2	48 8d 04 c8	 lea	 rax, QWORD PTR [rax+rcx*8]
  000b6	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  000be	4c 8b c8	 mov	 r9, rax
  000c1	4c 8b 44 24 50	 mov	 r8, QWORD PTR off$[rsp]
  000c6	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  000ca	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000cf	e8 00 00 00 00	 call	 cckd64_write
  000d4	85 c0		 test	 eax, eax
  000d6	7d 07		 jge	 SHORT $LN3@cckd64_wri

; 2069 :         return -1;

  000d8	b8 ff ff ff ff	 mov	 eax, -1
  000dd	eb 02		 jmp	 SHORT $LN1@cckd64_wri
$LN3@cckd64_wri:

; 2070 : 
; 2071 :     return 0;

  000df	33 c0		 xor	 eax, eax
$LN1@cckd64_wri:

; 2072 : 
; 2073 : } /* end function cckd64_write_l1ent */

  000e1	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000e5	c3		 ret	 0
cckd64_write_l1ent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
sfx$ = 64
len$ = 68
cckd$ = 72
dev$ = 96
cckd64_write_l1 PROC

; 2027 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2028 : CCKD64_EXT      *cckd;                  /* -> cckd extension         */
; 2029 : int             sfx;                    /* File index                */
; 2030 : int             len;                    /* Length of level 1 table   */
; 2031 : 
; 2032 :     if (!dev->cckd64)

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 0f		 jne	 SHORT $LN2@cckd64_wri

; 2033 :         return cckd_write_l1( dev );

  0001e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd_write_l1
  00028	e9 af 00 00 00	 jmp	 $LN1@cckd64_wri
$LN2@cckd64_wri:

; 2034 : 
; 2035 :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 48	 mov	 QWORD PTR cckd$[rsp], rax

; 2036 :     sfx = cckd->sfn;

  0003e	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  00043	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00046	89 44 24 40	 mov	 DWORD PTR sfx$[rsp], eax

; 2037 :     len = cckd->cdevhdr[sfx].num_L1tab * CCKD64_L1ENT_SIZE;

  0004a	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0004f	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00056	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cckd$[rsp]
  0005b	48 63 84 01 e4
	01 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+484]
  00063	48 c1 e0 03	 shl	 rax, 3
  00067	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 2038 : 
; 2039 :     CCKD_TRACE( "file[%d] write_l1 0x%"PRIx64" len %d",

  0006b	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  0006f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00073	48 c7 44 24 28
	00 04 00 00	 mov	 QWORD PTR [rsp+40], 1024 ; 00000400H
  0007c	8b 44 24 40	 mov	 eax, DWORD PTR sfx$[rsp]
  00080	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00084	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170464
  0008b	4c 8b 44 24 60	 mov	 r8, QWORD PTR dev$[rsp]
  00090	ba f8 07 00 00	 mov	 edx, 2040		; 000007f8H
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170465
  0009c	e8 00 00 00 00	 call	 cckd_trace

; 2040 :                 sfx, (U64)CCKD64_L1TAB_POS, len);
; 2041 : 
; 2042 :     if (cckd64_write (dev, sfx, CCKD64_L1TAB_POS, cckd->L1tab[sfx], len) < 0)

  000a1	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000a6	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  000aa	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000ae	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cckd$[rsp]
  000b3	4c 8b 8c c1 98
	01 00 00	 mov	 r9, QWORD PTR [rcx+rax*8+408]
  000bb	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  000c1	8b 54 24 40	 mov	 edx, DWORD PTR sfx$[rsp]
  000c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000ca	e8 00 00 00 00	 call	 cckd64_write
  000cf	85 c0		 test	 eax, eax
  000d1	7d 07		 jge	 SHORT $LN3@cckd64_wri

; 2043 :         return -1;

  000d3	b8 ff ff ff ff	 mov	 eax, -1
  000d8	eb 02		 jmp	 SHORT $LN1@cckd64_wri
$LN3@cckd64_wri:

; 2044 : 
; 2045 :     return 0;

  000da	33 c0		 xor	 eax, eax
$LN1@cckd64_wri:

; 2046 : 
; 2047 : } /* end function cckd64_write_l1 */

  000dc	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e0	c3		 ret	 0
cckd64_write_l1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
sfx$ = 48
i$ = 52
len$ = 56
cckd$ = 64
tv134 = 72
tv143 = 80
tv152 = 88
dev$ = 112
cckd64_read_l1 PROC

; 1971 : {

$LN18:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 1972 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 1973 : int             sfx;                    /* File index                */
; 1974 : int             len;                    /* Length of level 1 table   */
; 1975 : int             i;                      /* Work integer              */
; 1976 : 
; 1977 :     if (!dev->cckd64)

  0000a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0000f	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00016	24 01		 and	 al, 1
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 0f		 jne	 SHORT $LN8@cckd64_rea

; 1978 :         return cckd_read_l1( dev );

  0001f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00024	e8 00 00 00 00	 call	 cckd_read_l1
  00029	e9 3f 03 00 00	 jmp	 $LN1@cckd64_rea
$LN8@cckd64_rea:

; 1979 : 
; 1980 :     cckd = dev->cckd_ext;

  0002e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00033	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0003a	48 89 44 24 40	 mov	 QWORD PTR cckd$[rsp], rax

; 1981 :     sfx = cckd->sfn;

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00044	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00047	89 44 24 30	 mov	 DWORD PTR sfx$[rsp], eax

; 1982 : 
; 1983 :     CCKD_TRACE( "file[%d] read_l1 offset 0x%"PRIx64,

  0004b	48 c7 44 24 28
	00 04 00 00	 mov	 QWORD PTR [rsp+40], 1024 ; 00000400H
  00054	8b 44 24 30	 mov	 eax, DWORD PTR sfx$[rsp]
  00058	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0005c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170434
  00063	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00068	ba c0 07 00 00	 mov	 edx, 1984		; 000007c0H
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170435
  00074	e8 00 00 00 00	 call	 cckd_trace

; 1984 :                 sfx, (U64)CCKD64_L1TAB_POS);
; 1985 : 
; 1986 :     /* Free the old level 1 table if it exists */
; 1987 :     cckd->L1tab[sfx] = cckd_free (dev, "l1", cckd->L1tab[sfx]);

  00079	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00083	4c 8b 84 c1 98
	01 00 00	 mov	 r8, QWORD PTR [rcx+rax*8+408]
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170436
  00092	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00097	e8 00 00 00 00	 call	 cckd_free
  0009c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  000a1	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  000a6	48 89 84 ca 98
	01 00 00	 mov	 QWORD PTR [rdx+rcx*8+408], rax

; 1988 : 
; 1989 :     /* Allocate the level 1 table */
; 1990 :     len = cckd->cdevhdr[sfx].num_L1tab * CCKD64_L1ENT_SIZE;

  000ae	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000b3	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  000bf	48 63 84 01 e4
	01 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+484]
  000c7	48 c1 e0 03	 shl	 rax, 3
  000cb	89 44 24 38	 mov	 DWORD PTR len$[rsp], eax

; 1991 :     if ((cckd->L1tab[sfx] = cckd_malloc (dev, "l1", len)) == NULL)

  000cf	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$[rsp]
  000d4	4c 8b c0	 mov	 r8, rax
  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170438
  000de	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000e3	e8 00 00 00 00	 call	 cckd_malloc
  000e8	48 89 44 24 48	 mov	 QWORD PTR tv134[rsp], rax
  000ed	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000f2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  000f7	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv134[rsp]
  000fc	48 89 94 c1 98
	01 00 00	 mov	 QWORD PTR [rcx+rax*8+408], rdx
  00104	48 83 7c 24 48
	00		 cmp	 QWORD PTR tv134[rsp], 0
  0010a	75 0a		 jne	 SHORT $LN9@cckd64_rea

; 1992 :         return -1;

  0010c	b8 ff ff ff ff	 mov	 eax, -1
  00111	e9 57 02 00 00	 jmp	 $LN1@cckd64_rea
$LN9@cckd64_rea:

; 1993 :     if ( sfx )

  00116	83 7c 24 30 00	 cmp	 DWORD PTR sfx$[rsp], 0
  0011b	74 2a		 je	 SHORT $LN10@cckd64_rea

; 1994 :         memset(cckd->L1tab[sfx], 0xFF, len);

  0011d	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$[rsp]
  00122	48 89 44 24 50	 mov	 QWORD PTR tv143[rsp], rax
  00127	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0012c	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00131	48 8b bc ca 98
	01 00 00	 mov	 rdi, QWORD PTR [rdx+rcx*8+408]
  00139	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0013e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv143[rsp]
  00143	f3 aa		 rep stosb
  00145	eb 25		 jmp	 SHORT $LN11@cckd64_rea
$LN10@cckd64_rea:

; 1995 :     else
; 1996 :         memset(cckd->L1tab[sfx], 0, len);

  00147	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$[rsp]
  0014c	48 89 44 24 58	 mov	 QWORD PTR tv152[rsp], rax
  00151	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00156	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  0015b	48 8b bc ca 98
	01 00 00	 mov	 rdi, QWORD PTR [rdx+rcx*8+408]
  00163	33 c0		 xor	 eax, eax
  00165	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv152[rsp]
  0016a	f3 aa		 rep stosb
$LN11@cckd64_rea:

; 1997 : 
; 1998 :     /* Read the level 1 table */
; 1999 :     if (cckd64_read (dev, sfx, CCKD64_L1TAB_POS, cckd->L1tab[sfx], len) < 0)

  0016c	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00171	8b 4c 24 38	 mov	 ecx, DWORD PTR len$[rsp]
  00175	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00179	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0017e	4c 8b 8c c1 98
	01 00 00	 mov	 r9, QWORD PTR [rcx+rax*8+408]
  00186	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  0018c	8b 54 24 30	 mov	 edx, DWORD PTR sfx$[rsp]
  00190	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00195	e8 00 00 00 00	 call	 cckd64_read
  0019a	85 c0		 test	 eax, eax
  0019c	7d 0a		 jge	 SHORT $LN12@cckd64_rea

; 2000 :         return -1;

  0019e	b8 ff ff ff ff	 mov	 eax, -1
  001a3	e9 c5 01 00 00	 jmp	 $LN1@cckd64_rea
$LN12@cckd64_rea:

; 2001 : 
; 2002 :     /* Fix endianness */
; 2003 :     if (cckd->swapend[sfx])

  001a8	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  001b2	0f b6 84 01 14
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+276]
  001ba	85 c0		 test	 eax, eax
  001bc	74 2f		 je	 SHORT $LN13@cckd64_rea

; 2004 :         cckd64_swapend_l1 (cckd->L1tab[sfx], cckd->cdevhdr[sfx].num_L1tab);

  001be	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001c3	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001ca	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  001cf	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  001d4	8b 94 02 e4 01
	00 00		 mov	 edx, DWORD PTR [rdx+rax+484]
  001db	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  001e0	48 8b 8c c8 98
	01 00 00	 mov	 rcx, QWORD PTR [rax+rcx*8+408]
  001e8	e8 00 00 00 00	 call	 cckd64_swapend_l1
$LN13@cckd64_rea:

; 2005 : 
; 2006 :     /* Determine bounds */
; 2007 :     cckd->L2_bounds = CCKD64_L1TAB_POS + len;

  001ed	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$[rsp]
  001f2	48 05 00 04 00
	00		 add	 rax, 1024		; 00000400H
  001f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  001fd	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 2008 :     for (i = 0; i < cckd->cdevhdr[sfx].num_L1tab; i++)

  00201	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00209	eb 0a		 jmp	 SHORT $LN4@cckd64_rea
$LN2@cckd64_rea:
  0020b	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0020f	ff c0		 inc	 eax
  00211	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd64_rea:
  00215	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0021a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00221	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00226	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  0022d	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  00231	7d 56		 jge	 SHORT $LN3@cckd64_rea

; 2009 :         if (cckd->L1tab[sfx][i] != CCKD64_NOSIZE && cckd->L1tab[sfx][i] != CCKD64_MAXSIZE)

  00233	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00238	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  0023d	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00242	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  0024a	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  0024f	74 36		 je	 SHORT $LN14@cckd64_rea
  00251	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00256	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  0025b	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00260	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00268	48 83 3c c8 ff	 cmp	 QWORD PTR [rax+rcx*8], -1
  0026d	74 18		 je	 SHORT $LN14@cckd64_rea

; 2010 :             cckd->L2_bounds += CCKD64_L2TAB_SIZE;

  0026f	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00274	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00278	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  0027e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00283	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
$LN14@cckd64_rea:
  00287	eb 82		 jmp	 SHORT $LN2@cckd64_rea
$LN3@cckd64_rea:

; 2011 : 
; 2012 :     /* Check if all l2 tables are within bounds */
; 2013 :     cckd->L2ok = 1;

  00289	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  0028e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00291	0f ba e8 08	 bts	 eax, 8
  00295	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0029a	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 2014 :     for (i = 0; i < cckd->cdevhdr[sfx].num_L1tab && cckd->L2ok; i++)

  0029d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002a5	eb 0a		 jmp	 SHORT $LN7@cckd64_rea
$LN5@cckd64_rea:
  002a7	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  002ab	ff c0		 inc	 eax
  002ad	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN7@cckd64_rea:
  002b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  002b6	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  002bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  002c2	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  002c9	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  002cd	0f 8d 98 00 00
	00		 jge	 $LN6@cckd64_rea
  002d3	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  002d8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002db	c1 e8 08	 shr	 eax, 8
  002de	83 e0 01	 and	 eax, 1
  002e1	85 c0		 test	 eax, eax
  002e3	0f 84 82 00 00
	00		 je	 $LN6@cckd64_rea

; 2015 :         if (cckd->L1tab[sfx][i] != CCKD64_NOSIZE && cckd->L1tab[sfx][i] != CCKD64_MAXSIZE)

  002e9	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  002ee	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  002f3	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  002f8	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  00300	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  00305	74 5f		 je	 SHORT $LN15@cckd64_rea
  00307	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0030c	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  00311	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00316	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  0031e	48 83 3c c8 ff	 cmp	 QWORD PTR [rax+rcx*8], -1
  00323	74 41		 je	 SHORT $LN15@cckd64_rea

; 2016 :             if (cckd->L1tab[sfx][i] > cckd->L2_bounds - CCKD64_L2TAB_SIZE)

  00325	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0032a	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  0032f	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00334	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  0033c	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00341	48 8b 52 58	 mov	 rdx, QWORD PTR [rdx+88]
  00345	48 81 ea 00 10
	00 00		 sub	 rdx, 4096		; 00001000H
  0034c	48 39 14 c8	 cmp	 QWORD PTR [rax+rcx*8], rdx
  00350	76 14		 jbe	 SHORT $LN16@cckd64_rea

; 2017 :                 cckd->L2ok = 0;

  00352	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00357	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0035a	0f ba f0 08	 btr	 eax, 8
  0035e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00363	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN16@cckd64_rea:
$LN15@cckd64_rea:
  00366	e9 3c ff ff ff	 jmp	 $LN5@cckd64_rea
$LN6@cckd64_rea:

; 2018 : 
; 2019 :     return 0;

  0036b	33 c0		 xor	 eax, eax
$LN1@cckd64_rea:

; 2020 : 
; 2021 : } /* end function cckd64_read_l1 */

  0036d	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00371	5f		 pop	 rdi
  00372	c3		 ret	 0
cckd64_read_l1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
sfx$ = 48
cckd$ = 56
dev$ = 80
cckd64_write_chdr PROC

; 1943 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1944 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 1945 : int             sfx;                    /* File index                */
; 1946 : 
; 1947 :     if (!dev->cckd64)

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 0f		 jne	 SHORT $LN2@cckd64_wri

; 1948 :         return cckd_write_chdr( dev );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd_write_chdr
  00028	e9 f9 00 00 00	 jmp	 $LN1@cckd64_wri
$LN2@cckd64_wri:

; 1949 : 
; 1950 :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 38	 mov	 QWORD PTR cckd$[rsp], rax

; 1951 :     sfx = cckd->sfn;

  0003e	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00043	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00046	89 44 24 30	 mov	 DWORD PTR sfx$[rsp], eax

; 1952 : 
; 1953 :     CCKD_TRACE( "file[%d] write_chdr", sfx);

  0004a	8b 44 24 30	 mov	 eax, DWORD PTR sfx$[rsp]
  0004e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00052	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170391
  00059	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  0005e	ba a1 07 00 00	 mov	 edx, 1953		; 000007a1H
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170392
  0006a	e8 00 00 00 00	 call	 cckd_trace

; 1954 : 
; 1955 :     /* Set version.release.modlvl */
; 1956 :     cckd->cdevhdr[sfx].cdh_vrm[0] = CCKD_VERSION;

  0006f	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00074	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0007b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00080	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  00088	b9 01 00 00 00	 mov	 ecx, 1
  0008d	48 6b c9 00	 imul	 rcx, rcx, 0
  00091	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1957 :     cckd->cdevhdr[sfx].cdh_vrm[1] = CCKD_RELEASE;

  00095	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0009a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000a1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000a6	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  000ae	b9 01 00 00 00	 mov	 ecx, 1
  000b3	48 6b c9 01	 imul	 rcx, rcx, 1
  000b7	c6 04 08 03	 mov	 BYTE PTR [rax+rcx], 3

; 1958 :     cckd->cdevhdr[sfx].cdh_vrm[2] = CCKD_MODLVL;

  000bb	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000c0	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000c7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000cc	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  000d4	b9 01 00 00 00	 mov	 ecx, 1
  000d9	48 6b c9 02	 imul	 rcx, rcx, 2
  000dd	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 1959 : 
; 1960 :     if (cckd64_write (dev, sfx, CCKD64_DEVHDR_POS, &cckd->cdevhdr[sfx], CCKD64_DEVHDR_SIZE) < 0)

  000e1	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000e6	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000f2	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  000fa	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  00102	4c 8b c8	 mov	 r9, rax
  00105	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  0010b	8b 54 24 30	 mov	 edx, DWORD PTR sfx$[rsp]
  0010f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00114	e8 00 00 00 00	 call	 cckd64_write
  00119	85 c0		 test	 eax, eax
  0011b	7d 07		 jge	 SHORT $LN3@cckd64_wri

; 1961 :         return -1;

  0011d	b8 ff ff ff ff	 mov	 eax, -1
  00122	eb 02		 jmp	 SHORT $LN1@cckd64_wri
$LN3@cckd64_wri:

; 1962 : 
; 1963 :     return 0;

  00124	33 c0		 xor	 eax, eax
$LN1@cckd64_wri:

; 1964 : 
; 1965 : } /* end function cckd64_write_chdr */

  00126	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0012a	c3		 ret	 0
cckd64_write_chdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
sfx$ = 48
tv138 = 52
cckd$ = 56
dev$ = 80
cckd64_read_chdr PROC

; 1890 : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1891 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 1892 : int             sfx;                    /* File index                */
; 1893 : 
; 1894 :     if (!dev->cckd64)

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0000f	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00016	24 01		 and	 al, 1
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 0f		 jne	 SHORT $LN2@cckd64_rea

; 1895 :         return cckd_read_chdr( dev );

  0001f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00024	e8 00 00 00 00	 call	 cckd_read_chdr
  00029	e9 41 02 00 00	 jmp	 $LN1@cckd64_rea
$LN2@cckd64_rea:

; 1896 : 
; 1897 :     cckd = dev->cckd_ext;

  0002e	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00033	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0003a	48 89 44 24 38	 mov	 QWORD PTR cckd$[rsp], rax

; 1898 :     sfx = cckd->sfn;

  0003f	48 8b 44 24 38	 mov	 rax, QWORD PTR cckd$[rsp]
  00044	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00047	89 44 24 30	 mov	 DWORD PTR sfx$[rsp], eax

; 1899 : 
; 1900 :     CCKD_TRACE( "file[%d] read_chdr", sfx);

  0004b	8b 44 24 30	 mov	 eax, DWORD PTR sfx$[rsp]
  0004f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00053	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170371
  0005a	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  0005f	ba 6c 07 00 00	 mov	 edx, 1900		; 0000076cH
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170372
  0006b	e8 00 00 00 00	 call	 cckd_trace

; 1901 : 
; 1902 :     memset(&cckd->cdevhdr[sfx], 0, CCKD64_DEVHDR_SIZE);

  00070	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00075	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0007c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00081	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  00089	48 8b f8	 mov	 rdi, rax
  0008c	33 c0		 xor	 eax, eax
  0008e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00093	f3 aa		 rep stosb

; 1903 : 
; 1904 :     /* Read the device header */
; 1905 :     if (cckd64_read (dev, sfx, CKD_DEVHDR_SIZE, &cckd->cdevhdr[sfx], CCKD64_DEVHDR_SIZE) < 0)

  00095	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0009a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000a1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000a6	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  000ae	c7 44 24 20 00
	02 00 00	 mov	 DWORD PTR [rsp+32], 512	; 00000200H
  000b6	4c 8b c8	 mov	 r9, rax
  000b9	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  000bf	8b 54 24 30	 mov	 edx, DWORD PTR sfx$[rsp]
  000c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000c8	e8 00 00 00 00	 call	 cckd64_read
  000cd	85 c0		 test	 eax, eax
  000cf	7d 0a		 jge	 SHORT $LN3@cckd64_rea

; 1906 :         return -1;

  000d1	b8 ff ff ff ff	 mov	 eax, -1
  000d6	e9 94 01 00 00	 jmp	 $LN1@cckd64_rea
$LN3@cckd64_rea:

; 1907 : 
; 1908 :     /* Check endian format */
; 1909 :     cckd->swapend[sfx] = 0;

  000db	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000e0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000e5	c6 84 01 14 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+276], 0

; 1910 :     if ((cckd->cdevhdr[sfx].cdh_opts & CCKD_OPT_BIGEND) != cckd_def_opt_bigend())

  000ed	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000f2	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000f9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  000fe	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  00106	83 e0 02	 and	 eax, 2
  00109	89 44 24 34	 mov	 DWORD PTR tv138[rsp], eax
  0010d	e8 00 00 00 00	 call	 cckd_def_opt_bigend
  00112	8b 4c 24 34	 mov	 ecx, DWORD PTR tv138[rsp]
  00116	3b c8		 cmp	 ecx, eax
  00118	0f 84 85 00 00
	00		 je	 $LN4@cckd64_rea

; 1911 :     {
; 1912 :         if (cckd->open[sfx] == CCKD_OPEN_RW)

  0011e	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00123	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00128	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  00130	83 f8 03	 cmp	 eax, 3
  00133	75 3b		 jne	 SHORT $LN5@cckd64_rea

; 1913 :         {
; 1914 :             if (cckd64_swapend (dev) < 0)

  00135	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0013a	e8 00 00 00 00	 call	 cckd64_swapend
  0013f	85 c0		 test	 eax, eax
  00141	7d 0a		 jge	 SHORT $LN7@cckd64_rea

; 1915 :                 return -1;

  00143	b8 ff ff ff ff	 mov	 eax, -1
  00148	e9 22 01 00 00	 jmp	 $LN1@cckd64_rea
$LN7@cckd64_rea:

; 1916 :             cckd64_swapend_chdr (&cckd->cdevhdr[sfx]);

  0014d	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00152	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00159	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0015e	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  00166	48 8b c8	 mov	 rcx, rax
  00169	e8 00 00 00 00	 call	 cckd64_swapend_chdr

; 1917 :         }

  0016e	eb 33		 jmp	 SHORT $LN6@cckd64_rea
$LN5@cckd64_rea:

; 1918 :         else
; 1919 :         {
; 1920 :             cckd->swapend[sfx] = 1;

  00170	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00175	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0017a	c6 84 01 14 01
	00 00 01	 mov	 BYTE PTR [rcx+rax+276], 1

; 1921 :             cckd64_swapend_chdr (&cckd->cdevhdr[sfx]);

  00182	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00187	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0018e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00193	48 8d 84 01 e0
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+480]
  0019b	48 8b c8	 mov	 rcx, rax
  0019e	e8 00 00 00 00	 call	 cckd64_swapend_chdr
$LN6@cckd64_rea:
$LN4@cckd64_rea:

; 1922 :         }
; 1923 :     }
; 1924 : 
; 1925 :     /* Set default null format */
; 1926 :     if (cckd->cdevhdr[sfx].cdh_nullfmt > CKD_NULLTRK_FMTMAX)

  001a3	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001a8	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001af	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  001b4	0f b6 84 01 28
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+552]
  001bc	83 f8 02	 cmp	 eax, 2
  001bf	7e 19		 jle	 SHORT $LN8@cckd64_rea

; 1927 :         cckd->cdevhdr[sfx].cdh_nullfmt = 0;

  001c1	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001c6	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001cd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  001d2	c6 84 01 28 02
	00 00 00	 mov	 BYTE PTR [rcx+rax+552], 0
$LN8@cckd64_rea:

; 1928 : 
; 1929 :     if (cckd->cdevhdr[sfx].cdh_nullfmt == 0 && dev->oslinux && dev->devtype == 0x3390)

  001da	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001df	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  001e6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  001eb	0f b6 84 01 28
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+552]
  001f3	85 c0		 test	 eax, eax
  001f5	75 3e		 jne	 SHORT $LN9@cckd64_rea
  001f7	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001fc	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00202	c1 e8 0d	 shr	 eax, 13
  00205	83 e0 01	 and	 eax, 1
  00208	85 c0		 test	 eax, eax
  0020a	74 29		 je	 SHORT $LN9@cckd64_rea
  0020c	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00211	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00215	3d 90 33 00 00	 cmp	 eax, 13200		; 00003390H
  0021a	75 19		 jne	 SHORT $LN9@cckd64_rea

; 1930 :         cckd->cdevhdr[sfx].cdh_nullfmt = CKD_NULLTRK_FMT2;

  0021c	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00221	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00228	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  0022d	c6 84 01 28 02
	00 00 02	 mov	 BYTE PTR [rcx+rax+552], 2
$LN9@cckd64_rea:

; 1931 : 
; 1932 :     if (cckd->cdevhdr[sfx].cdh_nullfmt == CKD_NULLTRK_FMT2)

  00235	48 63 44 24 30	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0023a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00241	48 8b 4c 24 38	 mov	 rcx, QWORD PTR cckd$[rsp]
  00246	0f b6 84 01 28
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+552]
  0024e	83 f8 02	 cmp	 eax, 2
  00251	75 1a		 jne	 SHORT $LN10@cckd64_rea

; 1933 :         dev->oslinux = 1;

  00253	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00258	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0025e	0f ba e8 0d	 bts	 eax, 13
  00262	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00267	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN10@cckd64_rea:

; 1934 : 
; 1935 :     return 0;

  0026d	33 c0		 xor	 eax, eax
$LN1@cckd64_rea:

; 1936 : 
; 1937 : } /* end function cckd64_read_chdr */

  0026f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00273	5f		 pop	 rdi
  00274	c3		 ret	 0
cckd64_read_chdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
i$ = 64
sfx$ = 68
p$ = 72
n$ = 76
cckd$ = 80
pos$ = 88
ppos$ = 96
dev$ = 128
cckd64_flush_space PROC

; 1768 : {

$LN25:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1769 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 1770 : int             p,i,n;                  /* Free free space indexes   */
; 1771 : int             sfx;                    /* Shadow file index         */
; 1772 : U64             ppos, pos;              /* Free space offsets        */
; 1773 : 
; 1774 :     if (!dev->cckd64)

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00011	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00018	24 01		 and	 al, 1
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	75 12		 jne	 SHORT $LN10@cckd64_flu

; 1775 :     {
; 1776 :         cckd_flush_space( dev );

  00021	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00029	e8 00 00 00 00	 call	 cckd_flush_space

; 1777 :         return;

  0002e	e9 6c 08 00 00	 jmp	 $LN1@cckd64_flu
$LN10@cckd64_flu:

; 1778 :     }
; 1779 : 
; 1780 :     cckd = dev->cckd_ext;

  00033	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00042	48 89 44 24 50	 mov	 QWORD PTR cckd$[rsp], rax

; 1781 :     sfx = cckd->sfn;

  00047	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0004c	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0004f	89 44 24 44	 mov	 DWORD PTR sfx$[rsp], eax

; 1782 : 
; 1783 :     CCKD_TRACE( "flush_space nbr %"PRId64,cckd->cdevhdr[sfx].free_num);

  00053	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00058	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0005f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00064	48 8b 84 01 18
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+536]
  0006c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00071	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170340
  00078	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00080	ba f7 06 00 00	 mov	 edx, 1783		; 000006f7H
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170341
  0008c	e8 00 00 00 00	 call	 cckd_trace

; 1784 : 
; 1785 :     /* Make sure the free space chain is built */
; 1786 :     if (!cckd->ifb) cckd64_read_fsp (dev);

  00091	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00096	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0009b	75 0d		 jne	 SHORT $LN11@cckd64_flu
  0009d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a5	e8 00 00 00 00	 call	 cckd64_read_fsp
$LN11@cckd64_flu:

; 1787 : 
; 1788 :     CCKD_CHK_SPACE(dev);
; 1789 : 
; 1790 :     if (cckd->cdevhdr[sfx].free_num == 0 || cckd->cdevhdr[sfx].free_off == 0)

  000aa	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000af	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000b6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  000bb	48 83 bc 01 18
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax+536], 0
  000c4	74 1c		 je	 SHORT $LN13@cckd64_flu
  000c6	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000cb	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  000d7	48 83 bc 01 00
	02 00 00 00	 cmp	 QWORD PTR [rcx+rax+512], 0
  000e0	75 64		 jne	 SHORT $LN12@cckd64_flu
$LN13@cckd64_flu:

; 1791 :     {
; 1792 :         cckd->cdevhdr[sfx].free_num = 0;

  000e2	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000e7	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000ee	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  000f3	48 c7 84 01 18
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+536], 0

; 1793 :         cckd->cdevhdr[sfx].free_off = 0;

  000ff	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00104	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0010b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00110	48 c7 84 01 00
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+512], 0

; 1794 :         cckd->free_idx1st = cckd->free_idxlast = cckd->free_idxavail = -1;

  0011c	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00121	c7 80 84 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+132], -1
  0012b	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00130	c7 80 80 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+128], -1
  0013a	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0013f	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1
$LN12@cckd64_flu:

; 1795 :     }
; 1796 : 
; 1797 :     pos = cckd->cdevhdr[sfx].free_off;

  00146	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0014b	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00152	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00157	48 8b 84 01 00
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+512]
  0015f	48 89 44 24 58	 mov	 QWORD PTR pos$[rsp], rax

; 1798 :     ppos = p = -1;

  00164	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR p$[rsp], -1
  0016c	48 63 44 24 48	 movsxd	 rax, DWORD PTR p$[rsp]
  00171	48 89 44 24 60	 mov	 QWORD PTR ppos$[rsp], rax

; 1799 :     cckd->cdevhdr[sfx].free_num = 0;

  00176	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0017b	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00182	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00187	48 c7 84 01 18
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+536], 0

; 1800 :     cckd->cdevhdr[sfx].free_largest = 0;

  00193	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00198	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0019f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  001a4	48 c7 84 01 10
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+528], 0

; 1801 :     for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  001b0	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  001b5	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  001b8	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  001bc	eb 1a		 jmp	 SHORT $LN4@cckd64_flu
$LN2@cckd64_flu:
  001be	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001c3	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  001c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  001cc	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  001d0	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  001d4	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd64_flu:
  001d8	83 7c 24 40 00	 cmp	 DWORD PTR i$[rsp], 0
  001dd	0f 8c f4 02 00
	00		 jl	 $LN3@cckd64_flu

; 1802 :     {
; 1803 :         /* Decrement the pending count */
; 1804 :         if (cckd->ifb[i].ifb_pending)

  001e3	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001e8	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  001ec	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  001f1	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  001f5	83 7c 01 18 00	 cmp	 DWORD PTR [rcx+rax+24], 0
  001fa	74 2e		 je	 SHORT $LN14@cckd64_flu

; 1805 :             --cckd->ifb[i].ifb_pending;

  001fc	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00201	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00205	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0020a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0020e	8b 44 01 18	 mov	 eax, DWORD PTR [rcx+rax+24]
  00212	ff c8		 dec	 eax
  00214	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00219	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  0021d	48 8b 54 24 50	 mov	 rdx, QWORD PTR cckd$[rsp]
  00222	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00226	89 44 0a 18	 mov	 DWORD PTR [rdx+rcx+24], eax
$LN14@cckd64_flu:
$LN5@cckd64_flu:

; 1806 : 
; 1807 :         /* Combine adjacent free spaces */
; 1808 :         while (pos + cckd->ifb[i].ifb_len == cckd->ifb[i].ifb_offnxt)

  0022a	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0022f	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00233	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00238	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0023c	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00241	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pos$[rsp]
  00246	48 03 c8	 add	 rcx, rax
  00249	48 8b c1	 mov	 rax, rcx
  0024c	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00251	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00255	48 8b 54 24 50	 mov	 rdx, QWORD PTR cckd$[rsp]
  0025a	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0025e	48 3b 04 0a	 cmp	 rax, QWORD PTR [rdx+rcx]
  00262	0f 85 8d 01 00
	00		 jne	 $LN6@cckd64_flu

; 1809 :         {
; 1810 :             n = cckd->ifb[i].ifb_idxnxt;

  00268	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0026d	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00271	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00276	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0027a	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  0027e	89 44 24 4c	 mov	 DWORD PTR n$[rsp], eax

; 1811 :             if (cckd->ifb[n].ifb_pending > cckd->ifb[i].ifb_pending + 1
; 1812 :              || cckd->ifb[n].ifb_pending < cckd->ifb[i].ifb_pending)

  00282	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  00287	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0028b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00290	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00294	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  00299	48 6b d2 20	 imul	 rdx, rdx, 32		; 00000020H
  0029d	4c 8b 44 24 50	 mov	 r8, QWORD PTR cckd$[rsp]
  002a2	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  002a6	41 8b 54 10 18	 mov	 edx, DWORD PTR [r8+rdx+24]
  002ab	ff c2		 inc	 edx
  002ad	39 54 01 18	 cmp	 DWORD PTR [rcx+rax+24], edx
  002b1	7f 2f		 jg	 SHORT $LN16@cckd64_flu
  002b3	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  002b8	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  002bc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  002c1	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  002c5	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  002ca	48 6b d2 20	 imul	 rdx, rdx, 32		; 00000020H
  002ce	4c 8b 44 24 50	 mov	 r8, QWORD PTR cckd$[rsp]
  002d3	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  002d7	41 8b 54 10 18	 mov	 edx, DWORD PTR [r8+rdx+24]
  002dc	39 54 01 18	 cmp	 DWORD PTR [rcx+rax+24], edx
  002e0	7d 05		 jge	 SHORT $LN15@cckd64_flu
$LN16@cckd64_flu:

; 1813 :                 break;

  002e2	e9 0e 01 00 00	 jmp	 $LN6@cckd64_flu
$LN15@cckd64_flu:

; 1814 :             cckd->ifb[i].ifb_offnxt  = cckd->ifb[n].ifb_offnxt;

  002e7	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  002ec	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  002f0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  002f5	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  002f9	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  002fe	48 6b d2 20	 imul	 rdx, rdx, 32		; 00000020H
  00302	4c 8b 44 24 50	 mov	 r8, QWORD PTR cckd$[rsp]
  00307	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0030b	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0030f	49 89 04 10	 mov	 QWORD PTR [r8+rdx], rax

; 1815 :             cckd->ifb[i].ifb_len += cckd->ifb[n].ifb_len;

  00313	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00318	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0031c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00321	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00325	48 63 54 24 4c	 movsxd	 rdx, DWORD PTR n$[rsp]
  0032a	48 6b d2 20	 imul	 rdx, rdx, 32		; 00000020H
  0032e	4c 8b 44 24 50	 mov	 r8, QWORD PTR cckd$[rsp]
  00333	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00337	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  0033c	49 03 44 10 08	 add	 rax, QWORD PTR [r8+rdx+8]
  00341	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00346	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  0034a	48 8b 54 24 50	 mov	 rdx, QWORD PTR cckd$[rsp]
  0034f	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00353	48 89 44 0a 08	 mov	 QWORD PTR [rdx+rcx+8], rax

; 1816 :             cckd->ifb[i].ifb_idxnxt = cckd->ifb[n].ifb_idxnxt;

  00358	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  0035d	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00361	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00366	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0036a	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  0036f	48 6b d2 20	 imul	 rdx, rdx, 32		; 00000020H
  00373	4c 8b 44 24 50	 mov	 r8, QWORD PTR cckd$[rsp]
  00378	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  0037c	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  00380	41 89 44 10 14	 mov	 DWORD PTR [r8+rdx+20], eax

; 1817 :             cckd->ifb[n].ifb_idxnxt = cckd->free_idxavail;

  00385	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  0038a	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0038e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00393	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00397	48 8b 54 24 50	 mov	 rdx, QWORD PTR cckd$[rsp]
  0039c	8b 92 84 00 00
	00		 mov	 edx, DWORD PTR [rdx+132]
  003a2	89 54 01 14	 mov	 DWORD PTR [rcx+rax+20], edx

; 1818 :             cckd->free_idxavail = n;

  003a6	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  003ab	8b 4c 24 4c	 mov	 ecx, DWORD PTR n$[rsp]
  003af	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx

; 1819 :             n = cckd->ifb[i].ifb_idxnxt;

  003b5	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  003ba	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  003be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  003c3	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003c7	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  003cb	89 44 24 4c	 mov	 DWORD PTR n$[rsp], eax

; 1820 :             if (n >= 0)

  003cf	83 7c 24 4c 00	 cmp	 DWORD PTR n$[rsp], 0
  003d4	7c 1a		 jl	 SHORT $LN17@cckd64_flu

; 1821 :                 cckd->ifb[n].ifb_idxprv = i;

  003d6	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$[rsp]
  003db	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  003df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  003e4	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003e8	8b 54 24 40	 mov	 edx, DWORD PTR i$[rsp]
  003ec	89 54 01 10	 mov	 DWORD PTR [rcx+rax+16], edx
$LN17@cckd64_flu:

; 1822 : 
; 1823 :         }

  003f0	e9 35 fe ff ff	 jmp	 $LN5@cckd64_flu
$LN6@cckd64_flu:

; 1824 :         ppos = pos;

  003f5	48 8b 44 24 58	 mov	 rax, QWORD PTR pos$[rsp]
  003fa	48 89 44 24 60	 mov	 QWORD PTR ppos$[rsp], rax

; 1825 :         pos = cckd->ifb[i].ifb_offnxt;

  003ff	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00404	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00408	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0040d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00411	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00415	48 89 44 24 58	 mov	 QWORD PTR pos$[rsp], rax

; 1826 :         cckd->cdevhdr[sfx].free_num++;

  0041a	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0041f	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00426	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0042b	48 8b 84 01 18
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+536]
  00433	48 ff c0	 inc	 rax
  00436	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0043b	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00442	48 8b 54 24 50	 mov	 rdx, QWORD PTR cckd$[rsp]
  00447	48 89 84 0a 18
	02 00 00	 mov	 QWORD PTR [rdx+rcx+536], rax

; 1827 :         if (cckd->ifb[i].ifb_len > cckd->cdevhdr[sfx].free_largest
; 1828 :          && !cckd->ifb[i].ifb_pending)

  0044f	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00454	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00458	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0045d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00461	48 63 54 24 44	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  00466	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  0046d	4c 8b 44 24 50	 mov	 r8, QWORD PTR cckd$[rsp]
  00472	49 8b 94 10 10
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+528]
  0047a	48 39 54 01 08	 cmp	 QWORD PTR [rcx+rax+8], rdx
  0047f	76 49		 jbe	 SHORT $LN18@cckd64_flu
  00481	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00486	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0048a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0048f	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00493	83 7c 01 18 00	 cmp	 DWORD PTR [rcx+rax+24], 0
  00498	75 30		 jne	 SHORT $LN18@cckd64_flu

; 1829 :             cckd->cdevhdr[sfx].free_largest = cckd->ifb[i].ifb_len;

  0049a	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0049f	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  004a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  004a8	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004ac	48 63 54 24 44	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  004b1	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  004b8	4c 8b 44 24 50	 mov	 r8, QWORD PTR cckd$[rsp]
  004bd	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  004c2	49 89 84 10 10
	02 00 00	 mov	 QWORD PTR [r8+rdx+528], rax
$LN18@cckd64_flu:

; 1830 :         p = i;

  004ca	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  004ce	89 44 24 48	 mov	 DWORD PTR p$[rsp], eax

; 1831 :     }

  004d2	e9 e7 fc ff ff	 jmp	 $LN2@cckd64_flu
$LN3@cckd64_flu:

; 1832 :     cckd->free_idxlast = p;

  004d7	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  004dc	8b 4c 24 48	 mov	 ecx, DWORD PTR p$[rsp]
  004e0	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx

; 1833 : 
; 1834 :     CCKD_TRACE( "rel_flush_space nbr %"PRId64" (after merge)",

  004e6	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  004eb	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004f2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  004f7	48 8b 84 01 18
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+536]
  004ff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00504	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170350
  0050b	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00513	ba 2b 07 00 00	 mov	 edx, 1835		; 0000072bH
  00518	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170351
  0051f	e8 00 00 00 00	 call	 cckd_trace

; 1835 :                 cckd->cdevhdr[sfx].free_num);
; 1836 : 
; 1837 :     /* If the last free space is at the end of the file then release it */
; 1838 :     if (p >= 0 && ppos + cckd->ifb[p].ifb_len == cckd->cdevhdr[sfx].cdh_size
; 1839 :      && !cckd->ifb[p].ifb_pending)

  00524	83 7c 24 48 00	 cmp	 DWORD PTR p$[rsp], 0
  00529	0f 8c 70 03 00
	00		 jl	 $LN19@cckd64_flu
  0052f	48 63 44 24 48	 movsxd	 rax, DWORD PTR p$[rsp]
  00534	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00538	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0053d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00541	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00546	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ppos$[rsp]
  0054b	48 03 c8	 add	 rcx, rax
  0054e	48 8b c1	 mov	 rax, rcx
  00551	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00556	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  0055d	48 8b 54 24 50	 mov	 rdx, QWORD PTR cckd$[rsp]
  00562	48 3b 84 0a f0
	01 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+496]
  0056a	0f 85 2f 03 00
	00		 jne	 $LN19@cckd64_flu
  00570	48 63 44 24 48	 movsxd	 rax, DWORD PTR p$[rsp]
  00575	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00579	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0057e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00582	83 7c 01 18 00	 cmp	 DWORD PTR [rcx+rax+24], 0
  00587	0f 85 12 03 00
	00		 jne	 $LN19@cckd64_flu

; 1840 :     {
; 1841 :         i = p;

  0058d	8b 44 24 48	 mov	 eax, DWORD PTR p$[rsp]
  00591	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 1842 :         p = cckd->ifb[i].ifb_idxprv;

  00595	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0059a	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0059e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  005a3	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  005a7	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  005ab	89 44 24 48	 mov	 DWORD PTR p$[rsp], eax

; 1843 : 
; 1844 :         CCKD_TRACE( "file[%d] rel_flush_space atend 0x%16.16"PRIx64" len %"PRId64,

  005af	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  005b4	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  005b8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  005bd	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  005c1	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  005c6	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  005cb	48 8b 44 24 60	 mov	 rax, QWORD PTR ppos$[rsp]
  005d0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005d5	8b 44 24 44	 mov	 eax, DWORD PTR sfx$[rsp]
  005d9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005dd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170353
  005e4	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  005ec	ba 35 07 00 00	 mov	 edx, 1845		; 00000735H
  005f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170354
  005f8	e8 00 00 00 00	 call	 cckd_trace

; 1845 :                     sfx, ppos, cckd->ifb[i].ifb_len);
; 1846 : 
; 1847 :         /* Remove the entry from the chain */
; 1848 :         if (p >= 0)

  005fd	83 7c 24 48 00	 cmp	 DWORD PTR p$[rsp], 0
  00602	7c 36		 jl	 SHORT $LN20@cckd64_flu

; 1849 :         {
; 1850 :             cckd->ifb[p].ifb_offnxt = 0;

  00604	48 63 44 24 48	 movsxd	 rax, DWORD PTR p$[rsp]
  00609	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0060d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00612	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00616	48 c7 04 01 00
	00 00 00	 mov	 QWORD PTR [rcx+rax], 0

; 1851 :             cckd->ifb[p].ifb_idxnxt = -1;

  0061e	48 63 44 24 48	 movsxd	 rax, DWORD PTR p$[rsp]
  00623	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00627	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0062c	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00630	c7 44 01 14 ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+20], -1

; 1852 :         }

  00638	eb 29		 jmp	 SHORT $LN21@cckd64_flu
$LN20@cckd64_flu:

; 1853 :         else
; 1854 :         {
; 1855 :             cckd->cdevhdr[sfx].free_off = 0;

  0063a	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0063f	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00646	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0064b	48 c7 84 01 00
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+512], 0

; 1856 :             cckd->free_idx1st = -1;

  00657	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0065c	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1
$LN21@cckd64_flu:

; 1857 :         }
; 1858 :         cckd->free_idxlast = p;

  00663	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00668	8b 4c 24 48	 mov	 ecx, DWORD PTR p$[rsp]
  0066c	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx

; 1859 : 
; 1860 :         /* Add the entry to the available chain */
; 1861 :         cckd->ifb[i].ifb_idxnxt = cckd->free_idxavail;

  00672	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00677	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0067b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00680	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00684	48 8b 54 24 50	 mov	 rdx, QWORD PTR cckd$[rsp]
  00689	8b 92 84 00 00
	00		 mov	 edx, DWORD PTR [rdx+132]
  0068f	89 54 01 14	 mov	 DWORD PTR [rcx+rax+20], edx

; 1862 :         cckd->free_idxavail = i;

  00693	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00698	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  0069c	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx

; 1863 : 
; 1864 :         /* Update the device header */
; 1865 :         cckd->cdevhdr[sfx].cdh_size -= cckd->ifb[i].ifb_len;

  006a2	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  006a7	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  006ae	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  006b3	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  006b7	48 8b 54 24 50	 mov	 rdx, QWORD PTR cckd$[rsp]
  006bc	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  006c0	4c 8b 44 24 50	 mov	 r8, QWORD PTR cckd$[rsp]
  006c5	48 8b 4c 0a 08	 mov	 rcx, QWORD PTR [rdx+rcx+8]
  006ca	49 8b 84 00 f0
	01 00 00	 mov	 rax, QWORD PTR [r8+rax+496]
  006d2	48 2b c1	 sub	 rax, rcx
  006d5	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  006da	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  006e1	48 8b 54 24 50	 mov	 rdx, QWORD PTR cckd$[rsp]
  006e6	48 89 84 0a f0
	01 00 00	 mov	 QWORD PTR [rdx+rcx+496], rax

; 1866 :         cckd->cdevhdr[sfx].free_total -= cckd->ifb[i].ifb_len;

  006ee	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  006f3	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  006fa	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  006ff	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00703	48 8b 54 24 50	 mov	 rdx, QWORD PTR cckd$[rsp]
  00708	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0070c	4c 8b 44 24 50	 mov	 r8, QWORD PTR cckd$[rsp]
  00711	48 8b 4c 0a 08	 mov	 rcx, QWORD PTR [rdx+rcx+8]
  00716	49 8b 84 00 08
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+520]
  0071e	48 2b c1	 sub	 rax, rcx
  00721	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00726	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  0072d	48 8b 54 24 50	 mov	 rdx, QWORD PTR cckd$[rsp]
  00732	48 89 84 0a 08
	02 00 00	 mov	 QWORD PTR [rdx+rcx+520], rax

; 1867 :         cckd->cdevhdr[sfx].free_num--;

  0073a	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0073f	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00746	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0074b	48 8b 84 01 18
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+536]
  00753	48 ff c8	 dec	 rax
  00756	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0075b	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00762	48 8b 54 24 50	 mov	 rdx, QWORD PTR cckd$[rsp]
  00767	48 89 84 0a 18
	02 00 00	 mov	 QWORD PTR [rdx+rcx+536], rax

; 1868 :         if (cckd->ifb[i].ifb_len >= cckd->cdevhdr[sfx].free_largest)

  0076f	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00774	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00778	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0077d	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00781	48 63 54 24 44	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  00786	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  0078d	4c 8b 44 24 50	 mov	 r8, QWORD PTR cckd$[rsp]
  00792	49 8b 94 10 10
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+528]
  0079a	48 39 54 01 08	 cmp	 QWORD PTR [rcx+rax+8], rdx
  0079f	0f 82 d0 00 00
	00		 jb	 $LN22@cckd64_flu

; 1869 :         {
; 1870 :             cckd->cdevhdr[sfx].free_largest = 0;

  007a5	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  007aa	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  007b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  007b6	48 c7 84 01 10
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+528], 0

; 1871 :             for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  007c2	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  007c7	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  007ca	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  007ce	eb 1a		 jmp	 SHORT $LN9@cckd64_flu
$LN7@cckd64_flu:
  007d0	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  007d5	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  007d9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  007de	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  007e2	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  007e6	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN9@cckd64_flu:
  007ea	83 7c 24 40 00	 cmp	 DWORD PTR i$[rsp], 0
  007ef	0f 8c 80 00 00
	00		 jl	 $LN8@cckd64_flu

; 1872 :                 if (cckd->ifb[i].ifb_len > cckd->cdevhdr[sfx].free_largest
; 1873 :                  && cckd->ifb[i].ifb_pending == 0)

  007f5	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  007fa	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  007fe	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00803	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00807	48 63 54 24 44	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  0080c	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  00813	4c 8b 44 24 50	 mov	 r8, QWORD PTR cckd$[rsp]
  00818	49 8b 94 10 10
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+528]
  00820	48 39 54 01 08	 cmp	 QWORD PTR [rcx+rax+8], rdx
  00825	76 49		 jbe	 SHORT $LN23@cckd64_flu
  00827	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0082c	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00830	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00835	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00839	83 7c 01 18 00	 cmp	 DWORD PTR [rcx+rax+24], 0
  0083e	75 30		 jne	 SHORT $LN23@cckd64_flu

; 1874 :                     cckd->cdevhdr[sfx].free_largest = cckd->ifb[i].ifb_len;

  00840	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00845	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00849	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0084e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00852	48 63 54 24 44	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  00857	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  0085e	4c 8b 44 24 50	 mov	 r8, QWORD PTR cckd$[rsp]
  00863	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00868	49 89 84 10 10
	02 00 00	 mov	 QWORD PTR [r8+rdx+528], rax
$LN23@cckd64_flu:
  00870	e9 5b ff ff ff	 jmp	 $LN7@cckd64_flu
$LN8@cckd64_flu:
$LN22@cckd64_flu:

; 1875 :         }
; 1876 : 
; 1877 :         /* Truncate the file */
; 1878 :         cckd64_ftruncate (dev, sfx, cckd->cdevhdr[sfx].cdh_size);

  00875	48 63 44 24 44	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0087a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00881	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00886	4c 8b 84 01 f0
	01 00 00	 mov	 r8, QWORD PTR [rcx+rax+496]
  0088e	8b 54 24 44	 mov	 edx, DWORD PTR sfx$[rsp]
  00892	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0089a	e8 00 00 00 00	 call	 cckd64_ftruncate
$LN19@cckd64_flu:
$LN1@cckd64_flu:

; 1879 : 
; 1880 :     } /* Release space at end of the file */
; 1881 : 
; 1882 :     CCKD_CHK_SPACE(dev);
; 1883 : 
; 1884 : } /* end function cckd64_flush_space */

  0089f	48 83 c4 78	 add	 rsp, 120		; 00000078H
  008a3	c3		 ret	 0
cckd64_flush_space ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
cckd$ = 64
i$ = 72
sfx$ = 76
p$ = 80
n$ = 84
pending$ = 88
tv141 = 92
new_free_count$1 = 96
tv213 = 100
npos$ = 104
fsize$ = 112
ppos$ = 120
tv178 = 128
dev$ = 160
pos$ = 168
len$ = 176
size$ = 184
cckd64_rel_space PROC

; 1658 : {

$LN27:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1659 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 1660 : int             sfx;                    /* Shadow file index         */
; 1661 : U64             ppos, npos;             /* Prev/next free offsets    */
; 1662 : int             i, p, n;                /* Free space indexes        */
; 1663 : int             pending;                /* Calculated pending value  */
; 1664 : U64             fsize = size;           /* Free space size           */

  0001b	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR size$[rsp]
  00023	48 89 44 24 70	 mov	 QWORD PTR fsize$[rsp], rax

; 1665 : 
; 1666 :     if (!dev->cckd64)

  00028	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00030	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00037	24 01		 and	 al, 1
  00039	0f b6 c0	 movzx	 eax, al
  0003c	85 c0		 test	 eax, eax
  0003e	75 2a		 jne	 SHORT $LN8@cckd64_rel

; 1667 :     {
; 1668 :         cckd_rel_space( dev, pos, len, size );

  00040	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR size$[rsp]
  00048	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00050	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pos$[rsp]
  00058	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00060	e8 00 00 00 00	 call	 cckd_rel_space

; 1669 :         return;

  00065	e9 2e 06 00 00	 jmp	 $LN1@cckd64_rel
$LN8@cckd64_rel:

; 1670 :     }
; 1671 : 
; 1672 :     if (len <= CKD_NULLTRK_FMTMAX || pos == CCKD64_NOSIZE || pos == CCKD64_MAXSIZE)

  0006a	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR len$[rsp], 2
  00072	7e 16		 jle	 SHORT $LN10@cckd64_rel
  00074	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR pos$[rsp], 0
  0007d	74 0b		 je	 SHORT $LN10@cckd64_rel
  0007f	48 83 bc 24 a8
	00 00 00 ff	 cmp	 QWORD PTR pos$[rsp], -1
  00088	75 05		 jne	 SHORT $LN9@cckd64_rel
$LN10@cckd64_rel:

; 1673 :         return;

  0008a	e9 09 06 00 00	 jmp	 $LN1@cckd64_rel
$LN9@cckd64_rel:

; 1674 : 
; 1675 :     cckd = dev->cckd_ext;

  0008f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00097	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0009e	48 89 44 24 40	 mov	 QWORD PTR cckd$[rsp], rax

; 1676 :     sfx = cckd->sfn;

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  000a8	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  000ab	89 44 24 4c	 mov	 DWORD PTR sfx$[rsp], eax

; 1677 : 
; 1678 :     CCKD_TRACE( "rel_space offset 0x%16.16"PRIx64" len %d size %d",

  000af	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  000b6	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000ba	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  000c1	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000c5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pos$[rsp]
  000cd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170307
  000d9	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000e1	ba 8f 06 00 00	 mov	 edx, 1679		; 0000068fH
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170308
  000ed	e8 00 00 00 00	 call	 cckd_trace

; 1679 :                 pos, len, size);
; 1680 : 
; 1681 :     if (!cckd->ifb) cckd64_read_fsp (dev);

  000f2	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  000f7	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  000fc	75 0d		 jne	 SHORT $LN11@cckd64_rel
  000fe	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00106	e8 00 00 00 00	 call	 cckd64_read_fsp
$LN11@cckd64_rel:

; 1682 : 
; 1683 :     CCKD_CHK_SPACE(dev);
; 1684 : 
; 1685 :     /* Scan free space chain */
; 1686 :     ppos = -1;

  0010b	48 c7 44 24 78
	ff ff ff ff	 mov	 QWORD PTR ppos$[rsp], -1

; 1687 :     npos = cckd->cdevhdr[sfx].free_off;

  00114	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00119	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00120	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00125	48 8b 84 01 00
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+512]
  0012d	48 89 44 24 68	 mov	 QWORD PTR npos$[rsp], rax

; 1688 :     for (p = -1, n = cckd->free_idx1st; n >= 0; n = cckd->ifb[n].ifb_idxnxt)

  00132	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR p$[rsp], -1
  0013a	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  0013f	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00142	89 44 24 54	 mov	 DWORD PTR n$[rsp], eax
  00146	eb 1a		 jmp	 SHORT $LN4@cckd64_rel
$LN2@cckd64_rel:
  00148	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  0014d	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00151	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00156	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0015a	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  0015e	89 44 24 54	 mov	 DWORD PTR n$[rsp], eax
$LN4@cckd64_rel:
  00162	83 7c 24 54 00	 cmp	 DWORD PTR n$[rsp], 0
  00167	7c 40		 jl	 SHORT $LN3@cckd64_rel

; 1689 :     {
; 1690 :         if (pos < npos) break;

  00169	48 8b 44 24 68	 mov	 rax, QWORD PTR npos$[rsp]
  0016e	48 39 84 24 a8
	00 00 00	 cmp	 QWORD PTR pos$[rsp], rax
  00176	73 02		 jae	 SHORT $LN12@cckd64_rel
  00178	eb 2f		 jmp	 SHORT $LN3@cckd64_rel
$LN12@cckd64_rel:

; 1691 :         ppos = npos;

  0017a	48 8b 44 24 68	 mov	 rax, QWORD PTR npos$[rsp]
  0017f	48 89 44 24 78	 mov	 QWORD PTR ppos$[rsp], rax

; 1692 :         npos = cckd->ifb[n].ifb_offnxt;

  00184	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  00189	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0018d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00192	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00196	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0019a	48 89 44 24 68	 mov	 QWORD PTR npos$[rsp], rax

; 1693 :         p = n;

  0019f	8b 44 24 54	 mov	 eax, DWORD PTR n$[rsp]
  001a3	89 44 24 50	 mov	 DWORD PTR p$[rsp], eax

; 1694 :     }

  001a7	eb 9f		 jmp	 SHORT $LN2@cckd64_rel
$LN3@cckd64_rel:

; 1695 : 
; 1696 :     /* Calculate the `pending' value */
; 1697 :     pending = cckdblk.freepend >= 0 ? cckdblk.freepend : 1 + (1 - cckdblk.fsync);

  001a9	83 3d 48 02 00
	00 00		 cmp	 DWORD PTR cckdblk+584, 0
  001b0	7c 0c		 jl	 SHORT $LN23@cckd64_rel
  001b2	8b 05 48 02 00
	00		 mov	 eax, DWORD PTR cckdblk+584
  001b8	89 44 24 5c	 mov	 DWORD PTR tv141[rsp], eax
  001bc	eb 11		 jmp	 SHORT $LN24@cckd64_rel
$LN23@cckd64_rel:
  001be	b8 01 00 00 00	 mov	 eax, 1
  001c3	2b 05 5c 02 00
	00		 sub	 eax, DWORD PTR cckdblk+604
  001c9	ff c0		 inc	 eax
  001cb	89 44 24 5c	 mov	 DWORD PTR tv141[rsp], eax
$LN24@cckd64_rel:
  001cf	8b 44 24 5c	 mov	 eax, DWORD PTR tv141[rsp]
  001d3	89 44 24 58	 mov	 DWORD PTR pending$[rsp], eax

; 1698 : 
; 1699 :     /* If possible use previous adjacent free space otherwise get an available one */
; 1700 :     if (p >= 0 && ppos + cckd->ifb[p].ifb_len == pos && cckd->ifb[p].ifb_pending == pending)

  001d7	83 7c 24 50 00	 cmp	 DWORD PTR p$[rsp], 0
  001dc	0f 8c a2 00 00
	00		 jl	 $LN13@cckd64_rel
  001e2	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  001e7	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  001eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  001f0	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  001f4	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  001f9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ppos$[rsp]
  001fe	48 03 c8	 add	 rcx, rax
  00201	48 8b c1	 mov	 rax, rcx
  00204	48 3b 84 24 a8
	00 00 00	 cmp	 rax, QWORD PTR pos$[rsp]
  0020c	75 76		 jne	 SHORT $LN13@cckd64_rel
  0020e	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  00213	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00217	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0021c	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00220	8b 54 24 58	 mov	 edx, DWORD PTR pending$[rsp]
  00224	39 54 01 18	 cmp	 DWORD PTR [rcx+rax+24], edx
  00228	75 5a		 jne	 SHORT $LN13@cckd64_rel

; 1701 :     {
; 1702 :         cckd->ifb[p].ifb_len += size;

  0022a	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  0022f	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00233	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00238	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0023c	48 63 94 24 b8
	00 00 00	 movsxd	 rdx, DWORD PTR size$[rsp]
  00244	48 03 54 01 08	 add	 rdx, QWORD PTR [rcx+rax+8]
  00249	48 8b c2	 mov	 rax, rdx
  0024c	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR p$[rsp]
  00251	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00255	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  0025a	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0025e	48 89 44 0a 08	 mov	 QWORD PTR [rdx+rcx+8], rax

; 1703 :         fsize = cckd->ifb[p].ifb_len;

  00263	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  00268	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0026c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00271	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00275	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  0027a	48 89 44 24 70	 mov	 QWORD PTR fsize$[rsp], rax

; 1704 :     }

  0027f	e9 0b 03 00 00	 jmp	 $LN14@cckd64_rel
$LN13@cckd64_rel:

; 1705 :     else
; 1706 :     {
; 1707 :         /* Increase the size of the free space array if necessary */
; 1708 :         if (cckd->free_idxavail < 0)

  00284	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00289	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00290	0f 8d 2c 01 00
	00		 jge	 $LN15@cckd64_rel

; 1709 :         {
; 1710 :             int new_free_count = cckd->free_count + CCKD_IFB_ENTS_INCR;

  00296	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  0029b	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  0029e	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  002a3	89 44 24 60	 mov	 DWORD PTR new_free_count$1[rsp], eax

; 1711 :             if (!(cckd->ifb = cckd_realloc( dev, "ifb", cckd->ifb, new_free_count * CCKD64_IFREEBLK_SIZE )))

  002a7	48 63 44 24 60	 movsxd	 rax, DWORD PTR new_free_count$1[rsp]
  002ac	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  002b0	4c 8b c8	 mov	 r9, rax
  002b3	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  002b8	4c 8b 40 70	 mov	 r8, QWORD PTR [rax+112]
  002bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170315
  002c3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002cb	e8 00 00 00 00	 call	 cckd_realloc
  002d0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv178[rsp], rax
  002d8	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  002dd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv178[rsp]
  002e5	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx
  002e9	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tv178[rsp], 0
  002f2	75 05		 jne	 SHORT $LN16@cckd64_rel

; 1712 :                 return;

  002f4	e9 9f 03 00 00	 jmp	 $LN1@cckd64_rel
$LN16@cckd64_rel:

; 1713 :             cckd->free_idxavail = cckd->free_count;

  002f9	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  002fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00303	8b 49 78	 mov	 ecx, DWORD PTR [rcx+120]
  00306	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx

; 1714 :             cckd->free_count = new_free_count;

  0030c	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00311	8b 4c 24 60	 mov	 ecx, DWORD PTR new_free_count$1[rsp]
  00315	89 48 78	 mov	 DWORD PTR [rax+120], ecx

; 1715 :             for (i = cckd->free_idxavail; i < cckd->free_count; i++)

  00318	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  0031d	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00323	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
  00327	eb 0a		 jmp	 SHORT $LN7@cckd64_rel
$LN5@cckd64_rel:
  00329	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  0032d	ff c0		 inc	 eax
  0032f	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN7@cckd64_rel:
  00333	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00338	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  0033b	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  0033f	7d 1e		 jge	 SHORT $LN6@cckd64_rel

; 1716 :                 cckd->ifb[i].ifb_idxnxt = i + 1;

  00341	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00345	ff c0		 inc	 eax
  00347	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR i$[rsp]
  0034c	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00350	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00355	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00359	89 44 0a 14	 mov	 DWORD PTR [rdx+rcx+20], eax
  0035d	eb ca		 jmp	 SHORT $LN5@cckd64_rel
$LN6@cckd64_rel:

; 1717 :             cckd->ifb[i-1].ifb_idxnxt = -1;

  0035f	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  00363	ff c8		 dec	 eax
  00365	48 98		 cdqe
  00367	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0036b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00370	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00374	c7 44 01 14 ff
	ff ff ff	 mov	 DWORD PTR [rcx+rax+20], -1

; 1718 :             cckd->free_minsize = CCKD_MIN_FREESIZE( cckd->free_count );

  0037c	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00381	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  00384	83 c0 60	 add	 eax, 96			; 00000060H
  00387	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  0038c	7d 0a		 jge	 SHORT $LN25@cckd64_rel
  0038e	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv213[rsp], 0
  00396	eb 1b		 jmp	 SHORT $LN26@cckd64_rel
$LN25@cckd64_rel:
  00398	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  0039d	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  003a0	99		 cdq
  003a1	81 e2 ff 03 00
	00		 and	 edx, 1023		; 000003ffH
  003a7	03 c2		 add	 eax, edx
  003a9	c1 f8 0a	 sar	 eax, 10
  003ac	6b c0 20	 imul	 eax, eax, 32		; 00000020H
  003af	89 44 24 64	 mov	 DWORD PTR tv213[rsp], eax
$LN26@cckd64_rel:
  003b3	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  003b8	8b 4c 24 64	 mov	 ecx, DWORD PTR tv213[rsp]
  003bc	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx
$LN15@cckd64_rel:

; 1719 :         }
; 1720 : 
; 1721 :         /* Get an available free space entry */
; 1722 :         i = cckd->free_idxavail;

  003c2	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  003c7	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  003cd	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax

; 1723 :         cckd->free_idxavail = cckd->ifb[i].ifb_idxnxt;

  003d1	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  003d6	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  003da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  003df	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003e3	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  003e8	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  003ec	89 82 84 00 00
	00		 mov	 DWORD PTR [rdx+132], eax

; 1724 :         cckd->cdevhdr[sfx].free_num++;

  003f2	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  003f7	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  003fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00403	48 8b 84 01 18
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+536]
  0040b	48 ff c0	 inc	 rax
  0040e	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00413	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  0041a	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  0041f	48 89 84 0a 18
	02 00 00	 mov	 QWORD PTR [rdx+rcx+536], rax

; 1725 : 
; 1726 :         /* Update the new entry */
; 1727 :         cckd->ifb[i].ifb_idxprv = p;

  00427	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  0042c	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00430	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00435	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00439	8b 54 24 50	 mov	 edx, DWORD PTR p$[rsp]
  0043d	89 54 01 10	 mov	 DWORD PTR [rcx+rax+16], edx

; 1728 :         cckd->ifb[i].ifb_idxnxt = n;

  00441	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  00446	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0044a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0044f	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00453	8b 54 24 54	 mov	 edx, DWORD PTR n$[rsp]
  00457	89 54 01 14	 mov	 DWORD PTR [rcx+rax+20], edx

; 1729 :         cckd->ifb[i].ifb_len = size;

  0045b	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  00460	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00464	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00469	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0046d	48 63 94 24 b8
	00 00 00	 movsxd	 rdx, DWORD PTR size$[rsp]
  00475	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 1730 :         cckd->ifb[i].ifb_pending = pending;

  0047a	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$[rsp]
  0047f	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00483	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00488	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0048c	8b 54 24 58	 mov	 edx, DWORD PTR pending$[rsp]
  00490	89 54 01 18	 mov	 DWORD PTR [rcx+rax+24], edx

; 1731 : 
; 1732 :         /* Update the previous entry */
; 1733 :         if (p >= 0)

  00494	83 7c 24 50 00	 cmp	 DWORD PTR p$[rsp], 0
  00499	7c 66		 jl	 SHORT $LN17@cckd64_rel

; 1734 :         {
; 1735 :             cckd->ifb[i].ifb_offnxt = cckd->ifb[p].ifb_offnxt;

  0049b	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  004a0	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  004a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  004a9	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004ad	48 63 54 24 48	 movsxd	 rdx, DWORD PTR i$[rsp]
  004b2	48 6b d2 20	 imul	 rdx, rdx, 32		; 00000020H
  004b6	4c 8b 44 24 40	 mov	 r8, QWORD PTR cckd$[rsp]
  004bb	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  004bf	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  004c3	49 89 04 10	 mov	 QWORD PTR [r8+rdx], rax

; 1736 :             cckd->ifb[p].ifb_offnxt = pos;

  004c7	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  004cc	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  004d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  004d5	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004d9	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pos$[rsp]
  004e1	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 1737 :             cckd->ifb[p].ifb_idxnxt = i;

  004e5	48 63 44 24 50	 movsxd	 rax, DWORD PTR p$[rsp]
  004ea	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  004ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  004f3	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004f7	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  004fb	89 54 01 14	 mov	 DWORD PTR [rcx+rax+20], edx

; 1738 :         }

  004ff	eb 5c		 jmp	 SHORT $LN18@cckd64_rel
$LN17@cckd64_rel:

; 1739 :         else
; 1740 :         {
; 1741 :             cckd->ifb[i].ifb_offnxt = cckd->cdevhdr[sfx].free_off;

  00501	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00506	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0050d	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR i$[rsp]
  00512	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00516	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  0051b	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0051f	4c 8b 44 24 40	 mov	 r8, QWORD PTR cckd$[rsp]
  00524	49 8b 84 00 00
	02 00 00	 mov	 rax, QWORD PTR [r8+rax+512]
  0052c	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 1742 :             cckd->cdevhdr[sfx].free_off = pos;

  00530	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00535	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0053c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00541	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pos$[rsp]
  00549	48 89 94 01 00
	02 00 00	 mov	 QWORD PTR [rcx+rax+512], rdx

; 1743 :             cckd->free_idx1st = i;

  00551	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00556	8b 4c 24 48	 mov	 ecx, DWORD PTR i$[rsp]
  0055a	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
$LN18@cckd64_rel:

; 1744 :         }
; 1745 : 
; 1746 :         /* Update the next entry */
; 1747 :         if (n >= 0)

  0055d	83 7c 24 54 00	 cmp	 DWORD PTR n$[rsp], 0
  00562	7c 1c		 jl	 SHORT $LN19@cckd64_rel

; 1748 :             cckd->ifb[n].ifb_idxprv = i;

  00564	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  00569	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0056d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00572	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00576	8b 54 24 48	 mov	 edx, DWORD PTR i$[rsp]
  0057a	89 54 01 10	 mov	 DWORD PTR [rcx+rax+16], edx
  0057e	eb 0f		 jmp	 SHORT $LN20@cckd64_rel
$LN19@cckd64_rel:

; 1749 :         else
; 1750 :             cckd->free_idxlast = i;

  00580	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00585	8b 4c 24 48	 mov	 ecx, DWORD PTR i$[rsp]
  00589	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx
$LN20@cckd64_rel:
$LN14@cckd64_rel:

; 1751 :     }
; 1752 : 
; 1753 :     /* Update the free space statistics */
; 1754 :     cckd->cdevhdr[sfx].cdh_used -= len;

  0058f	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00594	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0059b	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR len$[rsp]
  005a3	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  005a8	48 8b 84 02 f8
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax+504]
  005b0	48 2b c1	 sub	 rax, rcx
  005b3	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  005b8	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  005bf	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  005c4	48 89 84 0a f8
	01 00 00	 mov	 QWORD PTR [rdx+rcx+504], rax

; 1755 :     cckd->cdevhdr[sfx].free_total += len;

  005cc	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  005d1	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  005d8	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR len$[rsp]
  005e0	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  005e5	48 03 8c 02 08
	02 00 00	 add	 rcx, QWORD PTR [rdx+rax+520]
  005ed	48 8b c1	 mov	 rax, rcx
  005f0	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  005f5	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  005fc	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  00601	48 89 84 0a 08
	02 00 00	 mov	 QWORD PTR [rdx+rcx+520], rax

; 1756 :     cckd->cdevhdr[sfx].free_imbed -= size - len;

  00609	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0060e	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00615	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  0061c	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR size$[rsp]
  00623	2b d1		 sub	 edx, ecx
  00625	8b ca		 mov	 ecx, edx
  00627	48 63 c9	 movsxd	 rcx, ecx
  0062a	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  0062f	48 8b 84 02 20
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax+544]
  00637	48 2b c1	 sub	 rax, rcx
  0063a	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0063f	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00646	48 8b 54 24 40	 mov	 rdx, QWORD PTR cckd$[rsp]
  0064b	48 89 84 0a 20
	02 00 00	 mov	 QWORD PTR [rdx+rcx+544], rax

; 1757 :     if (!pending && fsize > cckd->cdevhdr[sfx].free_largest)

  00653	83 7c 24 58 00	 cmp	 DWORD PTR pending$[rsp], 0
  00658	75 3e		 jne	 SHORT $LN21@cckd64_rel
  0065a	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0065f	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00666	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0066b	48 8b 84 01 10
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+528]
  00673	48 39 44 24 70	 cmp	 QWORD PTR fsize$[rsp], rax
  00678	76 1e		 jbe	 SHORT $LN21@cckd64_rel

; 1758 :         cckd->cdevhdr[sfx].free_largest = fsize;

  0067a	48 63 44 24 4c	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0067f	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00686	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  0068b	48 8b 54 24 70	 mov	 rdx, QWORD PTR fsize$[rsp]
  00690	48 89 94 01 10
	02 00 00	 mov	 QWORD PTR [rcx+rax+528], rdx
$LN21@cckd64_rel:
$LN1@cckd64_rel:

; 1759 : 
; 1760 :     CCKD_CHK_SPACE(dev);
; 1761 : 
; 1762 : } /* end function cckd64_rel_space */

  00698	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0069f	c3		 ret	 0
cckd64_rel_space ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
cckd$ = 96
sfx$ = 104
i$ = 108
len$ = 112
p$ = 116
i$1 = 120
n$ = 124
fpos$ = 128
tv161 = 136
tv167 = 140
flen$ = 144
len2$ = 152
tv151 = 160
tv153 = 168
dev$ = 192
size$ = 200
flags$ = 208
cckd64_get_space PROC

; 1513 : {

$LN34:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1514 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 1515 : int             i,p,n;                  /* Free space indexes        */
; 1516 : S64             len2;                   /* Other lengths             */
; 1517 : S64             fpos;                   /* Free space offset         */
; 1518 : S64             flen;                   /* Free space size           */
; 1519 : int             sfx;                    /* Shadow file index         */
; 1520 : int             len;                    /* Requested length          */
; 1521 : 
; 1522 :     if (!dev->cckd64)

  00016	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00025	24 01		 and	 al, 1
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	75 22		 jne	 SHORT $LN8@cckd64_get

; 1523 :         return cckd_get_space( dev, size, flags );

  0002e	44 8b 84 24 d0
	00 00 00	 mov	 r8d, DWORD PTR flags$[rsp]
  00036	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR size$[rsp]
  0003e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00046	e8 00 00 00 00	 call	 cckd_get_space
  0004b	e9 c3 08 00 00	 jmp	 $LN1@cckd64_get
$LN8@cckd64_get:

; 1524 : 
; 1525 :     cckd = dev->cckd_ext;

  00050	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00058	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0005f	48 89 44 24 60	 mov	 QWORD PTR cckd$[rsp], rax

; 1526 :     sfx = cckd->sfn;

  00064	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00069	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0006c	89 44 24 68	 mov	 DWORD PTR sfx$[rsp], eax

; 1527 : 
; 1528 :     len = *size;

  00070	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  00078	8b 00		 mov	 eax, DWORD PTR [rax]
  0007a	89 44 24 70	 mov	 DWORD PTR len$[rsp], eax

; 1529 : 
; 1530 :     if (flags & CCKD_L2SPACE)

  0007e	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00085	83 e0 04	 and	 eax, 4
  00088	85 c0		 test	 eax, eax
  0008a	74 27		 je	 SHORT $LN9@cckd64_get

; 1531 :     {
; 1532 :         flags |= CCKD_SIZE_EXACT;

  0008c	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00093	83 c8 01	 or	 eax, 1
  00096	89 84 24 d0 00
	00 00		 mov	 DWORD PTR flags$[rsp], eax

; 1533 :         len = *size = CCKD64_L2TAB_SIZE;

  0009d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  000a5	c7 00 00 10 00
	00		 mov	 DWORD PTR [rax], 4096	; 00001000H
  000ab	c7 44 24 70 00
	10 00 00	 mov	 DWORD PTR len$[rsp], 4096 ; 00001000H
$LN9@cckd64_get:

; 1534 :     }
; 1535 : 
; 1536 :     CCKD_TRACE( "get_space len %d largest %"PRId64" flags 0x%2.2x",

  000b3	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000b8	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  000bf	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR flags$[rsp]
  000c6	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  000ca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  000cf	48 8b 84 01 10
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+528]
  000d7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000dc	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  000e0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000e4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170245
  000eb	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000f3	ba 01 06 00 00	 mov	 edx, 1537		; 00000601H
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170246
  000ff	e8 00 00 00 00	 call	 cckd_trace

; 1537 :                 len, cckd->cdevhdr[sfx].free_largest, flags);
; 1538 : 
; 1539 :     if (len <= CKD_NULLTRK_FMTMAX)

  00104	83 7c 24 70 02	 cmp	 DWORD PTR len$[rsp], 2
  00109	7f 07		 jg	 SHORT $LN10@cckd64_get

; 1540 :         return 0;

  0010b	33 c0		 xor	 eax, eax
  0010d	e9 01 08 00 00	 jmp	 $LN1@cckd64_get
$LN10@cckd64_get:

; 1541 : 
; 1542 :     if (!cckd->ifb)

  00112	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00117	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0011c	75 0d		 jne	 SHORT $LN11@cckd64_get

; 1543 :         cckd64_read_fsp (dev);

  0011e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00126	e8 00 00 00 00	 call	 cckd64_read_fsp
$LN11@cckd64_get:

; 1544 : 
; 1545 :     len2 = (U64) len + CCKD64_FREEBLK_SIZE;

  0012b	48 63 44 24 70	 movsxd	 rax, DWORD PTR len$[rsp]
  00130	48 83 c0 10	 add	 rax, 16
  00134	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR len2$[rsp], rax

; 1546 : 
; 1547 :     /* Get space at the end if no space is large enough */
; 1548 :     if ((U64)len2  >  cckd->cdevhdr[sfx].free_largest
; 1549 :      && (U64)len  !=  cckd->cdevhdr[sfx].free_largest)

  0013c	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00141	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00148	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0014d	48 8b 84 01 10
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+528]
  00155	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR len2$[rsp], rax
  0015d	0f 86 31 02 00
	00		 jbe	 $LN12@cckd64_get
  00163	48 63 44 24 70	 movsxd	 rax, DWORD PTR len$[rsp]
  00168	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0016d	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00174	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00179	48 3b 84 0a 10
	02 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+528]
  00181	0f 84 0d 02 00
	00		 je	 $LN12@cckd64_get
$cckd_get_space_atend$35:

; 1550 :     {
; 1551 : 
; 1552 : cckd_get_space_atend:
; 1553 : 
; 1554 :         fpos = cckd->cdevhdr[sfx].cdh_size;

  00187	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0018c	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00193	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00198	48 8b 84 01 f0
	01 00 00	 mov	 rax, QWORD PTR [rcx+rax+496]
  001a0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 1555 :         if ((U64)fpos > (cckd->cckd_maxsize - len))

  001a8	48 63 44 24 70	 movsxd	 rax, DWORD PTR len$[rsp]
  001ad	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  001b2	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  001b6	48 2b c8	 sub	 rcx, rax
  001b9	48 8b c1	 mov	 rax, rcx
  001bc	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR fpos$[rsp], rax
  001c4	0f 86 14 01 00
	00		 jbe	 $LN13@cckd64_get

; 1556 :         {
; 1557 :             // "%1d:%04X CCKD file[%d] %s: get space error, size exceeds %"PRId64"M"
; 1558 :             WRMSG (HHC00304, "E", LCSS_DEVNUM, sfx, cckd_sf_name (dev, sfx),

  001ca	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001d3	74 15		 je	 SHORT $LN30@cckd64_get
  001d5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001dd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001e1	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv161[rsp], eax
  001e8	eb 0b		 jmp	 SHORT $LN31@cckd64_get
$LN30@cckd64_get:
  001ea	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv161[rsp], 0
$LN31@cckd64_get:
  001f5	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001fe	74 17		 je	 SHORT $LN32@cckd64_get
  00200	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00208	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0020c	d1 f8		 sar	 eax, 1
  0020e	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv167[rsp], eax
  00215	eb 0b		 jmp	 SHORT $LN33@cckd64_get
$LN32@cckd64_get:
  00217	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv167[rsp], 0
$LN33@cckd64_get:
  00222	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00227	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0022b	48 c1 e8 14	 shr	 rax, 20
  0022f	48 ff c0	 inc	 rax
  00232	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv151[rsp], rax
  0023a	8b 54 24 68	 mov	 edx, DWORD PTR sfx$[rsp]
  0023e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00246	e8 00 00 00 00	 call	 cckd_sf_name
  0024b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv153[rsp], rax
  00253	b9 01 00 00 00	 mov	 ecx, 1
  00258	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0025e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv151[rsp]
  00266	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0026b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv153[rsp]
  00273	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00278	8b 4c 24 68	 mov	 ecx, DWORD PTR sfx$[rsp]
  0027c	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00280	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv161[rsp]
  00287	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0028b	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv167[rsp]
  00292	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170251
  0029d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170252
  002a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  002b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170253
  002c0	ba 17 06 00 00	 mov	 edx, 1559		; 00000617H
  002c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170254
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1559 :                 (S64) (cckd->cckd_maxsize >> 20) + 1);
; 1560 :             return -1;

  002d2	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  002d9	e9 35 06 00 00	 jmp	 $LN1@cckd64_get
$LN13@cckd64_get:

; 1561 :         }
; 1562 :         cckd->cdevhdr[sfx].cdh_size += len;

  002de	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  002e3	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  002ea	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR len$[rsp]
  002ef	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  002f4	48 03 8c 02 f0
	01 00 00	 add	 rcx, QWORD PTR [rdx+rax+496]
  002fc	48 8b c1	 mov	 rax, rcx
  002ff	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00304	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  0030b	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00310	48 89 84 0a f0
	01 00 00	 mov	 QWORD PTR [rdx+rcx+496], rax

; 1563 :         cckd->cdevhdr[sfx].cdh_used += len;

  00318	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0031d	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00324	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR len$[rsp]
  00329	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  0032e	48 03 8c 02 f8
	01 00 00	 add	 rcx, QWORD PTR [rdx+rax+504]
  00336	48 8b c1	 mov	 rax, rcx
  00339	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0033e	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00345	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  0034a	48 89 84 0a f8
	01 00 00	 mov	 QWORD PTR [rdx+rcx+504], rax

; 1564 : 
; 1565 :         CCKD_TRACE( "get_space atend 0x%16.16"PRIx64" len %d",fpos, len);

  00352	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  00356	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0035a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR fpos$[rsp]
  00362	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00367	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170255
  0036e	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00376	ba 1d 06 00 00	 mov	 edx, 1565		; 0000061dH
  0037b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170256
  00382	e8 00 00 00 00	 call	 cckd_trace

; 1566 : 
; 1567 :         return fpos;

  00387	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR fpos$[rsp]
  0038f	e9 7f 05 00 00	 jmp	 $LN1@cckd64_get
$LN12@cckd64_get:

; 1568 :     }
; 1569 : 
; 1570 :     /* Scan free space chain */
; 1571 :     fpos = cckd->cdevhdr[sfx].free_off;

  00394	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00399	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  003a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  003a5	48 8b 84 01 00
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+512]
  003ad	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 1572 :     for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  003b5	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  003ba	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  003bd	89 44 24 6c	 mov	 DWORD PTR i$[rsp], eax
  003c1	eb 1a		 jmp	 SHORT $LN4@cckd64_get
$LN2@cckd64_get:
  003c3	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  003c8	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  003cc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  003d1	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003d5	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  003d9	89 44 24 6c	 mov	 DWORD PTR i$[rsp], eax
$LN4@cckd64_get:
  003dd	83 7c 24 6c 00	 cmp	 DWORD PTR i$[rsp], 0
  003e2	0f 8c 9e 00 00
	00		 jl	 $LN3@cckd64_get

; 1573 :     {
; 1574 :         if (cckd->ifb[i].ifb_pending == 0
; 1575 :          && ((U64)len2 <= cckd->ifb[i].ifb_len || (U64)len == cckd->ifb[i].ifb_len)
; 1576 :          && ((flags & CCKD_L2SPACE) || (U64)fpos >= cckd->L2_bounds))

  003e8	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  003ed	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  003f1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  003f6	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  003fa	83 7c 01 18 00	 cmp	 DWORD PTR [rcx+rax+24], 0
  003ff	75 62		 jne	 SHORT $LN14@cckd64_get
  00401	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  00406	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0040a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0040f	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00413	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00418	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR len2$[rsp], rax
  00420	76 1e		 jbe	 SHORT $LN15@cckd64_get
  00422	48 63 44 24 70	 movsxd	 rax, DWORD PTR len$[rsp]
  00427	48 63 4c 24 6c	 movsxd	 rcx, DWORD PTR i$[rsp]
  0042c	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  00430	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00435	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00439	48 3b 44 0a 08	 cmp	 rax, QWORD PTR [rdx+rcx+8]
  0043e	75 23		 jne	 SHORT $LN14@cckd64_get
$LN15@cckd64_get:
  00440	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00447	83 e0 04	 and	 eax, 4
  0044a	85 c0		 test	 eax, eax
  0044c	75 13		 jne	 SHORT $LN16@cckd64_get
  0044e	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00453	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00457	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR fpos$[rsp], rax
  0045f	72 02		 jb	 SHORT $LN14@cckd64_get
$LN16@cckd64_get:

; 1577 :             break;

  00461	eb 23		 jmp	 SHORT $LN3@cckd64_get
$LN14@cckd64_get:

; 1578 :         fpos = cckd->ifb[i].ifb_offnxt;

  00463	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  00468	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0046c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00471	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00475	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00479	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR fpos$[rsp], rax

; 1579 :     }

  00481	e9 3d ff ff ff	 jmp	 $LN2@cckd64_get
$LN3@cckd64_get:

; 1580 : 
; 1581 :     /* This can happen if largest comes before L2_bounds */
; 1582 :     if (i < 0) goto cckd_get_space_atend;

  00486	83 7c 24 6c 00	 cmp	 DWORD PTR i$[rsp], 0
  0048b	7d 05		 jge	 SHORT $LN17@cckd64_get
  0048d	e9 f5 fc ff ff	 jmp	 $cckd_get_space_atend$35
$LN17@cckd64_get:

; 1583 : 
; 1584 :     flen = cckd->ifb[i].ifb_len;

  00492	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  00497	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0049b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  004a0	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004a4	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  004a9	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR flen$[rsp], rax

; 1585 :     p = cckd->ifb[i].ifb_idxprv;

  004b1	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  004b6	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  004ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  004bf	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004c3	8b 44 01 10	 mov	 eax, DWORD PTR [rcx+rax+16]
  004c7	89 44 24 74	 mov	 DWORD PTR p$[rsp], eax

; 1586 :     n = cckd->ifb[i].ifb_idxnxt;

  004cb	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  004d0	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  004d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  004d9	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  004dd	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  004e1	89 44 24 7c	 mov	 DWORD PTR n$[rsp], eax

; 1587 : 
; 1588 :     /*
; 1589 :      * If `CCKD_SIZE_ANY' bit is set and the left over space is small
; 1590 :      * enough, then use the entire free space
; 1591 :      */
; 1592 :     if ((flags & CCKD_SIZE_ANY) && flen <= cckd->free_minsize)

  004e5	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  004ec	83 e0 02	 and	 eax, 2
  004ef	85 c0		 test	 eax, eax
  004f1	74 26		 je	 SHORT $LN18@cckd64_get
  004f3	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  004f8	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  004fe	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR flen$[rsp], rax
  00506	7f 11		 jg	 SHORT $LN18@cckd64_get

; 1593 :         *size = (int)flen;

  00508	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  00510	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR flen$[rsp]
  00517	89 08		 mov	 DWORD PTR [rax], ecx
$LN18@cckd64_get:

; 1594 : 
; 1595 :     /* Remove the new space from free space */
; 1596 :     if (*size < (int)flen)

  00519	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  00521	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR flen$[rsp]
  00528	39 08		 cmp	 DWORD PTR [rax], ecx
  0052a	0f 8d c4 00 00
	00		 jge	 $LN19@cckd64_get

; 1597 :     {
; 1598 :         cckd->ifb[i].ifb_len -= *size;

  00530	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  00535	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00539	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0053e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00542	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR size$[rsp]
  0054a	48 63 12	 movsxd	 rdx, DWORD PTR [rdx]
  0054d	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00552	48 2b c2	 sub	 rax, rdx
  00555	48 63 4c 24 6c	 movsxd	 rcx, DWORD PTR i$[rsp]
  0055a	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  0055e	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00563	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  00567	48 89 44 0a 08	 mov	 QWORD PTR [rdx+rcx+8], rax

; 1599 :         if (p >= 0)

  0056c	83 7c 24 74 00	 cmp	 DWORD PTR p$[rsp], 0
  00571	7c 3c		 jl	 SHORT $LN21@cckd64_get

; 1600 :             cckd->ifb[p].ifb_offnxt += *size;

  00573	48 63 44 24 74	 movsxd	 rax, DWORD PTR p$[rsp]
  00578	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0057c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00581	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00585	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR size$[rsp]
  0058d	48 63 12	 movsxd	 rdx, DWORD PTR [rdx]
  00590	48 03 14 01	 add	 rdx, QWORD PTR [rcx+rax]
  00594	48 8b c2	 mov	 rax, rdx
  00597	48 63 4c 24 74	 movsxd	 rcx, DWORD PTR p$[rsp]
  0059c	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  005a0	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  005a5	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  005a9	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax
  005ad	eb 40		 jmp	 SHORT $LN22@cckd64_get
$LN21@cckd64_get:

; 1601 :         else
; 1602 :             cckd->cdevhdr[sfx].free_off += *size;

  005af	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  005b4	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  005bb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR size$[rsp]
  005c3	48 63 09	 movsxd	 rcx, DWORD PTR [rcx]
  005c6	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  005cb	48 03 8c 02 00
	02 00 00	 add	 rcx, QWORD PTR [rdx+rax+512]
  005d3	48 8b c1	 mov	 rax, rcx
  005d6	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  005db	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  005e2	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  005e7	48 89 84 0a 00
	02 00 00	 mov	 QWORD PTR [rdx+rcx+512], rax
$LN22@cckd64_get:

; 1603 :     }

  005ef	e9 21 01 00 00	 jmp	 $LN20@cckd64_get
$LN19@cckd64_get:

; 1604 :     else
; 1605 :     {
; 1606 :         cckd->cdevhdr[sfx].free_num--;

  005f4	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  005f9	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00600	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00605	48 8b 84 01 18
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+536]
  0060d	48 ff c8	 dec	 rax
  00610	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00615	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  0061c	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00621	48 89 84 0a 18
	02 00 00	 mov	 QWORD PTR [rdx+rcx+536], rax

; 1607 : 
; 1608 :         /* Remove the free space entry from the chain */
; 1609 :         if (p >= 0)

  00629	83 7c 24 74 00	 cmp	 DWORD PTR p$[rsp], 0
  0062e	7c 48		 jl	 SHORT $LN23@cckd64_get

; 1610 :         {
; 1611 :             cckd->ifb[p].ifb_offnxt = cckd->ifb[i].ifb_offnxt;

  00630	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  00635	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00639	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0063e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00642	48 63 54 24 74	 movsxd	 rdx, DWORD PTR p$[rsp]
  00647	48 6b d2 20	 imul	 rdx, rdx, 32		; 00000020H
  0064b	4c 8b 44 24 60	 mov	 r8, QWORD PTR cckd$[rsp]
  00650	4d 8b 40 70	 mov	 r8, QWORD PTR [r8+112]
  00654	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00658	49 89 04 10	 mov	 QWORD PTR [r8+rdx], rax

; 1612 :             cckd->ifb[p].ifb_idxnxt = n;

  0065c	48 63 44 24 74	 movsxd	 rax, DWORD PTR p$[rsp]
  00661	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00665	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0066a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0066e	8b 54 24 7c	 mov	 edx, DWORD PTR n$[rsp]
  00672	89 54 01 14	 mov	 DWORD PTR [rcx+rax+20], edx

; 1613 :         }

  00676	eb 3b		 jmp	 SHORT $LN24@cckd64_get
$LN23@cckd64_get:

; 1614 :         else
; 1615 :         {
; 1616 :             cckd->cdevhdr[sfx].free_off = cckd->ifb[i].ifb_offnxt;

  00678	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  0067d	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00681	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00686	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0068a	48 63 54 24 68	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  0068f	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  00696	4c 8b 44 24 60	 mov	 r8, QWORD PTR cckd$[rsp]
  0069b	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0069f	49 89 84 10 00
	02 00 00	 mov	 QWORD PTR [r8+rdx+512], rax

; 1617 :             cckd->free_idx1st = n;

  006a7	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  006ac	8b 4c 24 7c	 mov	 ecx, DWORD PTR n$[rsp]
  006b0	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
$LN24@cckd64_get:

; 1618 :         }
; 1619 : 
; 1620 :         if (n >= 0)

  006b3	83 7c 24 7c 00	 cmp	 DWORD PTR n$[rsp], 0
  006b8	7c 1c		 jl	 SHORT $LN25@cckd64_get

; 1621 :             cckd->ifb[n].ifb_idxprv = p;

  006ba	48 63 44 24 7c	 movsxd	 rax, DWORD PTR n$[rsp]
  006bf	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  006c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  006c8	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  006cc	8b 54 24 74	 mov	 edx, DWORD PTR p$[rsp]
  006d0	89 54 01 10	 mov	 DWORD PTR [rcx+rax+16], edx
  006d4	eb 0f		 jmp	 SHORT $LN26@cckd64_get
$LN25@cckd64_get:

; 1622 :         else
; 1623 :             cckd->free_idxlast = p;

  006d6	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  006db	8b 4c 24 74	 mov	 ecx, DWORD PTR p$[rsp]
  006df	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx
$LN26@cckd64_get:

; 1624 : 
; 1625 :         /* Add entry to the available queue */
; 1626 :         cckd->ifb[i].ifb_idxnxt = cckd->free_idxavail;

  006e5	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  006ea	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  006ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  006f3	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  006f7	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  006fc	8b 92 84 00 00
	00		 mov	 edx, DWORD PTR [rdx+132]
  00702	89 54 01 14	 mov	 DWORD PTR [rcx+rax+20], edx

; 1627 :         cckd->free_idxavail = i;

  00706	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0070b	8b 4c 24 6c	 mov	 ecx, DWORD PTR i$[rsp]
  0070f	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx
$LN20@cckd64_get:

; 1628 :     }
; 1629 : 
; 1630 :     /* Find the largest free space if we got the largest */
; 1631 :     if ((U64)flen >= cckd->cdevhdr[sfx].free_largest)

  00715	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0071a	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00721	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00726	48 8b 84 01 10
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+528]
  0072e	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR flen$[rsp], rax
  00736	0f 82 d0 00 00
	00		 jb	 $LN27@cckd64_get

; 1632 :     {
; 1633 :         int i;
; 1634 :         cckd->cdevhdr[sfx].free_largest = 0;

  0073c	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00741	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00748	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0074d	48 c7 84 01 10
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+528], 0

; 1635 :         for (i = cckd->free_idx1st; i >= 0; i = cckd->ifb[i].ifb_idxnxt)

  00759	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0075e	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00761	89 44 24 78	 mov	 DWORD PTR i$1[rsp], eax
  00765	eb 1a		 jmp	 SHORT $LN7@cckd64_get
$LN5@cckd64_get:
  00767	48 63 44 24 78	 movsxd	 rax, DWORD PTR i$1[rsp]
  0076c	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00770	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00775	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00779	8b 44 01 14	 mov	 eax, DWORD PTR [rcx+rax+20]
  0077d	89 44 24 78	 mov	 DWORD PTR i$1[rsp], eax
$LN7@cckd64_get:
  00781	83 7c 24 78 00	 cmp	 DWORD PTR i$1[rsp], 0
  00786	0f 8c 80 00 00
	00		 jl	 $LN6@cckd64_get

; 1636 :             if (cckd->ifb[i].ifb_len > cckd->cdevhdr[sfx].free_largest
; 1637 :              && cckd->ifb[i].ifb_pending == 0)

  0078c	48 63 44 24 78	 movsxd	 rax, DWORD PTR i$1[rsp]
  00791	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00795	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0079a	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  0079e	48 63 54 24 68	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  007a3	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  007aa	4c 8b 44 24 60	 mov	 r8, QWORD PTR cckd$[rsp]
  007af	49 8b 94 10 10
	02 00 00	 mov	 rdx, QWORD PTR [r8+rdx+528]
  007b7	48 39 54 01 08	 cmp	 QWORD PTR [rcx+rax+8], rdx
  007bc	76 49		 jbe	 SHORT $LN28@cckd64_get
  007be	48 63 44 24 78	 movsxd	 rax, DWORD PTR i$1[rsp]
  007c3	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  007c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  007cc	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  007d0	83 7c 01 18 00	 cmp	 DWORD PTR [rcx+rax+24], 0
  007d5	75 30		 jne	 SHORT $LN28@cckd64_get

; 1638 :                 cckd->cdevhdr[sfx].free_largest = cckd->ifb[i].ifb_len;

  007d7	48 63 44 24 78	 movsxd	 rax, DWORD PTR i$1[rsp]
  007dc	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  007e0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  007e5	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  007e9	48 63 54 24 68	 movsxd	 rdx, DWORD PTR sfx$[rsp]
  007ee	48 69 d2 00 02
	00 00		 imul	 rdx, rdx, 512		; 00000200H
  007f5	4c 8b 44 24 60	 mov	 r8, QWORD PTR cckd$[rsp]
  007fa	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  007ff	49 89 84 10 10
	02 00 00	 mov	 QWORD PTR [r8+rdx+528], rax
$LN28@cckd64_get:
  00807	e9 5b ff ff ff	 jmp	 $LN5@cckd64_get
$LN6@cckd64_get:
$LN27@cckd64_get:

; 1639 :     }
; 1640 : 
; 1641 :     /* Update free space stats */
; 1642 :     cckd->cdevhdr[sfx].cdh_used += len;

  0080c	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00811	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00818	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR len$[rsp]
  0081d	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00822	48 03 8c 02 f8
	01 00 00	 add	 rcx, QWORD PTR [rdx+rax+504]
  0082a	48 8b c1	 mov	 rax, rcx
  0082d	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00832	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00839	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  0083e	48 89 84 0a f8
	01 00 00	 mov	 QWORD PTR [rdx+rcx+504], rax

; 1643 :     cckd->cdevhdr[sfx].free_total -= len;

  00846	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0084b	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00852	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR len$[rsp]
  00857	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  0085c	48 8b 84 02 08
	02 00 00	 mov	 rax, QWORD PTR [rdx+rax+520]
  00864	48 2b c1	 sub	 rax, rcx
  00867	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0086c	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  00873	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00878	48 89 84 0a 08
	02 00 00	 mov	 QWORD PTR [rdx+rcx+520], rax

; 1644 : 
; 1645 :     cckd->cdevhdr[sfx].free_imbed += *size - len;

  00880	48 63 44 24 68	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00885	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0088c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR size$[rsp]
  00894	8b 54 24 70	 mov	 edx, DWORD PTR len$[rsp]
  00898	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0089a	2b ca		 sub	 ecx, edx
  0089c	48 63 c9	 movsxd	 rcx, ecx
  0089f	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  008a4	48 03 8c 02 20
	02 00 00	 add	 rcx, QWORD PTR [rdx+rax+544]
  008ac	48 8b c1	 mov	 rax, rcx
  008af	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  008b4	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  008bb	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  008c0	48 89 84 0a 20
	02 00 00	 mov	 QWORD PTR [rdx+rcx+544], rax

; 1646 : 
; 1647 :     CCKD_TRACE( "get_space found 0x%16.16"PRIx64" len %d size %d",

  008c8	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  008d0	8b 00		 mov	 eax, DWORD PTR [rax]
  008d2	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  008d6	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  008da	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  008de	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR fpos$[rsp]
  008e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008eb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170272
  008f2	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  008fa	ba 70 06 00 00	 mov	 edx, 1648		; 00000670H
  008ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170273
  00906	e8 00 00 00 00	 call	 cckd_trace

; 1648 :                 fpos, len, *size);
; 1649 : 
; 1650 :     return fpos;

  0090b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR fpos$[rsp]
$LN1@cckd64_get:

; 1651 : 
; 1652 : } /* end function cckd64_get_space */

  00913	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0091a	c3		 ret	 0
cckd64_get_space ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
cckd$ = 112
len$ = 120
trk$ = 124
dev$ = 128
buf$ = 136
devnum$ = 144
parm$ = 148
comp$ = 152
bufl$ = 156
tv135 = 160
tv136 = 164
tv145 = 168
tv192 = 172
tv196 = 176
rc$ = 180
tv330 = 184
flag$ = 188
bufp$ = 192
tid$ = 200
tv326 = 208
buf2$ = 224
__$ArrayPad$ = 65760
writer$ = 65792
o$ = 65800
cckd64_writer_write PROC

; 1275 : {

$LN28:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	b8 f8 00 01 00	 mov	 eax, 65784		; 000100f8H
  0000d	e8 00 00 00 00	 call	 __chkstk
  00012	48 2b e0	 sub	 rsp, rax
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 e0
	00 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@cckd64_wri:

; 1276 : TID             tid;                    /* Writer thead id           */
; 1277 : CCKD64_EXT*     cckd;                   /* -> cckd extension         */
; 1278 : DEVBLK*         dev;                    /* Device block              */
; 1279 : U16             devnum;                 /* Device number             */
; 1280 : int             rc;                     /* (work) return code        */
; 1281 : int             trk;                    /* Track number              */
; 1282 : BYTE*           buf;                    /* Buffer                    */
; 1283 : BYTE*           bufp;                   /* Buffer to be written      */
; 1284 : int             len, bufl;              /* Buffer lengths            */
; 1285 : int             comp;                   /* Compression algorithm     */
; 1286 : int             parm;                   /* Compression parameter     */
; 1287 : U32             flag;                   /* Cache flag                */
; 1288 : BYTE            buf2[ 64*1024 ];        /* 64K Compress buffer       */
; 1289 : 
; 1290 :     /* Prepare to compress */
; 1291 :     CCKD_CACHE_GETKEY( o, devnum, trk );

  00027	8b 94 24 08 01
	01 00		 mov	 edx, DWORD PTR o$[rsp]
  0002e	33 c9		 xor	 ecx, ecx
  00030	e8 00 00 00 00	 call	 cache_getkey
  00035	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00039	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  0003f	66 89 84 24 90
	00 00 00	 mov	 WORD PTR devnum$[rsp], ax
  00047	8b 94 24 08 01
	01 00		 mov	 edx, DWORD PTR o$[rsp]
  0004e	33 c9		 xor	 ecx, ecx
  00050	e8 00 00 00 00	 call	 cache_getkey
  00055	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0005a	48 23 c1	 and	 rax, rcx
  0005d	89 44 24 7c	 mov	 DWORD PTR trk$[rsp], eax
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 c0		 jne	 SHORT $LN4@cckd64_wri

; 1292 :     dev = cckd_find_device_by_devnum( devnum );

  00067	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR devnum$[rsp]
  0006f	e8 00 00 00 00	 call	 cckd_find_device_by_devnum
  00074	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax

; 1293 : 
; 1294 :     if (!dev->cckd64)

  0007c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00084	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0008b	24 01		 and	 al, 1
  0008d	0f b6 c0	 movzx	 eax, al
  00090	85 c0		 test	 eax, eax
  00092	75 18		 jne	 SHORT $LN5@cckd64_wri

; 1295 :     {
; 1296 :         cckd_writer_write( writer, o );

  00094	8b 94 24 08 01
	01 00		 mov	 edx, DWORD PTR o$[rsp]
  0009b	8b 8c 24 00 01
	01 00		 mov	 ecx, DWORD PTR writer$[rsp]
  000a2	e8 00 00 00 00	 call	 cckd_writer_write

; 1297 :         return;

  000a7	e9 e3 07 00 00	 jmp	 $LN1@cckd64_wri
$LN5@cckd64_wri:

; 1298 :     }
; 1299 : 
; 1300 :     cckd = dev->cckd_ext;

  000ac	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b4	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  000bb	48 89 44 24 70	 mov	 QWORD PTR cckd$[rsp], rax

; 1301 :     buf  = cache_getbuf( CACHE_DEVBUF, o, 0 );

  000c0	45 33 c0	 xor	 r8d, r8d
  000c3	8b 94 24 08 01
	01 00		 mov	 edx, DWORD PTR o$[rsp]
  000ca	33 c9		 xor	 ecx, ecx
  000cc	e8 00 00 00 00	 call	 cache_getbuf
  000d1	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1302 :     len  = cckd_trklen( dev, buf );

  000d9	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000e1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000e9	e8 00 00 00 00	 call	 cckd_trklen
  000ee	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax

; 1303 : 
; 1304 :     comp = len < CCKD_COMPRESS_MIN ? CCKD_COMPRESS_NONE :

  000f2	81 7c 24 78 00
	02 00 00	 cmp	 DWORD PTR len$[rsp], 512 ; 00000200H
  000fa	7d 0d		 jge	 SHORT $LN20@cckd64_wri
  000fc	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv136[rsp], 0
  00107	eb 50		 jmp	 SHORT $LN21@cckd64_wri
$LN20@cckd64_wri:
  00109	0f b6 05 1d 00
	00 00		 movzx	 eax, BYTE PTR cckdblk+29
  00110	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00115	75 26		 jne	 SHORT $LN18@cckd64_wri
  00117	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0011c	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00120	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00127	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  0012c	0f b6 84 01 29
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+553]
  00134	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv135[rsp], eax
  0013b	eb 0e		 jmp	 SHORT $LN19@cckd64_wri
$LN18@cckd64_wri:
  0013d	0f b6 05 1d 00
	00 00		 movzx	 eax, BYTE PTR cckdblk+29
  00144	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv135[rsp], eax
$LN19@cckd64_wri:
  0014b	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv135[rsp]
  00152	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv136[rsp], eax
$LN21@cckd64_wri:
  00159	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv136[rsp]
  00160	89 84 24 98 00
	00 00		 mov	 DWORD PTR comp$[rsp], eax

; 1305 :          cckdblk.comp == 0xff ? cckd->cdevhdr[ cckd->sfn ].cmp_algo
; 1306 :                               : cckdblk.comp;
; 1307 : 
; 1308 :     parm = cckdblk.compparm < 0 ? cckd->cdevhdr[ cckd->sfn ].cmp_parm

  00167	83 3d 20 00 00
	00 00		 cmp	 DWORD PTR cckdblk+32, 0
  0016e	7d 26		 jge	 SHORT $LN22@cckd64_wri
  00170	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00175	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00179	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  00180	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00185	0f bf 84 01 2a
	02 00 00	 movsx	 eax, WORD PTR [rcx+rax+554]
  0018d	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv145[rsp], eax
  00194	eb 0d		 jmp	 SHORT $LN23@cckd64_wri
$LN22@cckd64_wri:
  00196	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR cckdblk+32
  0019c	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv145[rsp], eax
$LN23@cckd64_wri:
  001a3	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv145[rsp]
  001aa	89 84 24 94 00
	00 00		 mov	 DWORD PTR parm$[rsp], eax

; 1309 :                                 : cckdblk.compparm;
; 1310 : 
; 1311 :     CCKD_TRACE( "%d wrtrk[%d] %d len %d buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x",

  001b1	b8 01 00 00 00	 mov	 eax, 1
  001b6	48 6b c0 04	 imul	 rax, rax, 4
  001ba	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  001c2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c6	b9 01 00 00 00	 mov	 ecx, 1
  001cb	48 6b c9 03	 imul	 rcx, rcx, 3
  001cf	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  001d7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001db	ba 01 00 00 00	 mov	 edx, 1
  001e0	48 6b d2 02	 imul	 rdx, rdx, 2
  001e4	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  001ec	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  001f1	41 b8 01 00 00
	00		 mov	 r8d, 1
  001f7	4d 6b c0 01	 imul	 r8, r8, 1
  001fb	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  00203	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00208	41 b9 01 00 00
	00		 mov	 r9d, 1
  0020e	4d 6b c9 00	 imul	 r9, r9, 0
  00212	4c 8b 94 24 88
	00 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  0021a	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  0021f	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  00223	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00227	89 54 24 58	 mov	 DWORD PTR [rsp+88], edx
  0022b	44 89 44 24 50	 mov	 DWORD PTR [rsp+80], r8d
  00230	44 89 4c 24 48	 mov	 DWORD PTR [rsp+72], r9d
  00235	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0023d	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00242	8b 44 24 78	 mov	 eax, DWORD PTR len$[rsp]
  00246	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0024a	8b 44 24 7c	 mov	 eax, DWORD PTR trk$[rsp]
  0024e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00252	8b 84 24 08 01
	01 00		 mov	 eax, DWORD PTR o$[rsp]
  00259	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0025d	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR writer$[rsp]
  00264	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00268	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170162
  0026f	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00277	ba 20 05 00 00	 mov	 edx, 1312		; 00000520H
  0027c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170163
  00283	e8 00 00 00 00	 call	 cckd_trace

; 1312 :                 writer, o, trk, len, buf, buf[0], buf[1],buf[2],buf[3],buf[4] );
; 1313 : 
; 1314 :     /* Compress the image if not null */
; 1315 :     if ((len = cckd64_check_null_trk( dev, buf, trk, len )) > CKD_NULLTRK_FMTMAX)

  00288	44 8b 4c 24 78	 mov	 r9d, DWORD PTR len$[rsp]
  0028d	44 8b 44 24 7c	 mov	 r8d, DWORD PTR trk$[rsp]
  00292	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0029a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002a2	e8 00 00 00 00	 call	 cckd64_check_null_trk
  002a7	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax
  002ab	83 7c 24 78 02	 cmp	 DWORD PTR len$[rsp], 2
  002b0	0f 8e a3 01 00
	00		 jle	 $LN6@cckd64_wri

; 1316 :     {
; 1317 :         /* Stress adjustments */
; 1318 :         if (1
; 1319 :             && !cckdblk.nostress
; 1320 :             && (0

  002b6	33 c0		 xor	 eax, eax
  002b8	83 f8 01	 cmp	 eax, 1
  002bb	0f 84 9d 00 00
	00		 je	 $LN8@cckd64_wri
  002c1	83 3d 54 02 00
	00 00		 cmp	 DWORD PTR cckdblk+596, 0
  002c8	0f 85 90 00 00
	00		 jne	 $LN8@cckd64_wri
  002ce	33 c0		 xor	 eax, eax
  002d0	85 c0		 test	 eax, eax
  002d2	75 17		 jne	 SHORT $LN9@cckd64_wri
  002d4	33 c9		 xor	 ecx, ecx
  002d6	e8 00 00 00 00	 call	 cache_waiters
  002db	85 c0		 test	 eax, eax
  002dd	75 0c		 jne	 SHORT $LN9@cckd64_wri
  002df	33 c9		 xor	 ecx, ecx
  002e1	e8 00 00 00 00	 call	 cache_busy
  002e6	83 f8 5a	 cmp	 eax, 90			; 0000005aH
  002e9	7e 73		 jle	 SHORT $LN8@cckd64_wri
$LN9@cckd64_wri:

; 1321 :                 || cache_waiters ( CACHE_DEVBUF )
; 1322 :                 || cache_busy    ( CACHE_DEVBUF ) > 90
; 1323 :                )
; 1324 :         )
; 1325 :         {
; 1326 :             cckdblk.stats_stresswrites++;

  002eb	48 8b 05 a0 02
	00 00		 mov	 rax, QWORD PTR cckdblk+672
  002f2	48 ff c0	 inc	 rax
  002f5	48 89 05 a0 02
	00 00		 mov	 QWORD PTR cckdblk+672, rax

; 1327 : 
; 1328 :             comp = len < CCKD_STRESS_MINLEN ? CCKD_COMPRESS_NONE

  002fc	81 7c 24 78 00
	10 00 00	 cmp	 DWORD PTR len$[rsp], 4096 ; 00001000H
  00304	7d 0d		 jge	 SHORT $LN24@cckd64_wri
  00306	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv192[rsp], 0
  00311	eb 0b		 jmp	 SHORT $LN25@cckd64_wri
$LN24@cckd64_wri:
  00313	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv192[rsp], 0
$LN25@cckd64_wri:
  0031e	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv192[rsp]
  00325	89 84 24 98 00
	00 00		 mov	 DWORD PTR comp$[rsp], eax

; 1329 :                                             : CCKD_STRESS_COMP;
; 1330 : 
; 1331 :             parm = cache_busy(CACHE_DEVBUF) <= 95 ? CCKD_STRESS_PARM1

  0032c	33 c9		 xor	 ecx, ecx
  0032e	e8 00 00 00 00	 call	 cache_busy
  00333	83 f8 5f	 cmp	 eax, 95			; 0000005fH
  00336	7f 0d		 jg	 SHORT $LN26@cckd64_wri
  00338	c7 84 24 b0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv196[rsp], 4
  00343	eb 0b		 jmp	 SHORT $LN27@cckd64_wri
$LN26@cckd64_wri:
  00345	c7 84 24 b0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv196[rsp], 2
$LN27@cckd64_wri:
  00350	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv196[rsp]
  00357	89 84 24 94 00
	00 00		 mov	 DWORD PTR parm$[rsp], eax
$LN8@cckd64_wri:

; 1332 :                                                   : CCKD_STRESS_PARM2;
; 1333 :         }
; 1334 : 
; 1335 :         /* Compress the track image */
; 1336 :         CCKD_TRACE( "%d wrtrk[%d] %d comp %s parm %d",

  0035e	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR comp$[rsp]
  00366	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compname
  0036d	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR parm$[rsp]
  00374	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  00378	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0037c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00381	8b 44 24 7c	 mov	 eax, DWORD PTR trk$[rsp]
  00385	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00389	8b 84 24 08 01
	01 00		 mov	 eax, DWORD PTR o$[rsp]
  00390	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00394	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR writer$[rsp]
  0039b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0039f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170168
  003a6	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  003ae	ba 39 05 00 00	 mov	 edx, 1337		; 00000539H
  003b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170169
  003ba	e8 00 00 00 00	 call	 cckd_trace

; 1337 :                     writer, o, trk, compname[ comp ], parm );
; 1338 : 
; 1339 :         bufp = (BYTE*) &buf2;

  003bf	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR buf2$[rsp]
  003c7	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR bufp$[rsp], rax

; 1340 :         bufl = cckd_compress( dev, &bufp, buf, len, comp, parm );

  003cf	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR parm$[rsp]
  003d6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003da	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR comp$[rsp]
  003e1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003e5	44 8b 4c 24 78	 mov	 r9d, DWORD PTR len$[rsp]
  003ea	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  003f2	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR bufp$[rsp]
  003fa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00402	e8 00 00 00 00	 call	 cckd_compress
  00407	89 84 24 9c 00
	00 00		 mov	 DWORD PTR bufl$[rsp], eax

; 1341 : 
; 1342 :         CCKD_TRACE( "%d wrtrk[%d] %d compressed length %d",

  0040e	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR bufl$[rsp]
  00415	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00419	8b 44 24 7c	 mov	 eax, DWORD PTR trk$[rsp]
  0041d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00421	8b 84 24 08 01
	01 00		 mov	 eax, DWORD PTR o$[rsp]
  00428	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0042c	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR writer$[rsp]
  00433	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00437	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170170
  0043e	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00446	ba 3f 05 00 00	 mov	 edx, 1343		; 0000053fH
  0044b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170171
  00452	e8 00 00 00 00	 call	 cckd_trace

; 1343 :                     writer, o, trk, bufl );
; 1344 :     }

  00457	eb 1b		 jmp	 SHORT $LN7@cckd64_wri
$LN6@cckd64_wri:

; 1345 :     else
; 1346 :     {
; 1347 :         bufp = buf;

  00459	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00461	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR bufp$[rsp], rax

; 1348 :         bufl = len;

  00469	8b 44 24 78	 mov	 eax, DWORD PTR len$[rsp]
  0046d	89 84 24 9c 00
	00 00		 mov	 DWORD PTR bufl$[rsp], eax
$LN7@cckd64_wri:

; 1349 :     }
; 1350 : 
; 1351 :     obtain_lock( &cckd->filelock );

  00474	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00479	48 83 c0 10	 add	 rax, 16
  0047d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170172
  00484	48 8b c8	 mov	 rcx, rax
  00487	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1352 :     {
; 1353 :         /* Turn on read-write header bits if not already on */
; 1354 :         if (!(cckd->cdevhdr[ cckd->sfn ].cdh_opts & CCKD_OPT_OPENED))

  0048d	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00492	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  00496	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0049d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  004a2	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  004aa	25 80 00 00 00	 and	 eax, 128		; 00000080H
  004af	85 c0		 test	 eax, eax
  004b1	75 4b		 jne	 SHORT $LN10@cckd64_wri

; 1355 :         {
; 1356 :             cckd->cdevhdr[ cckd->sfn ].cdh_opts |= (CCKD_OPT_OPENED | CCKD_OPT_OPENRW);

  004b3	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  004b8	48 63 40 3c	 movsxd	 rax, DWORD PTR [rax+60]
  004bc	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  004c3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  004c8	0f b6 84 01 e3
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+483]
  004d0	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  004d5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  004da	48 63 49 3c	 movsxd	 rcx, DWORD PTR [rcx+60]
  004de	48 69 c9 00 02
	00 00		 imul	 rcx, rcx, 512		; 00000200H
  004e5	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  004ea	88 84 0a e3 01
	00 00		 mov	 BYTE PTR [rdx+rcx+483], al

; 1357 :             cckd64_write_chdr( dev );

  004f1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004f9	e8 00 00 00 00	 call	 cckd64_write_chdr
$LN10@cckd64_wri:

; 1358 :         }
; 1359 : 
; 1360 :         /* Write the track image */
; 1361 :         cckd64_write_trkimg( dev, bufp, bufl, trk, CCKD_SIZE_ANY );

  004fe	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00506	44 8b 4c 24 7c	 mov	 r9d, DWORD PTR trk$[rsp]
  0050b	44 8b 84 24 9c
	00 00 00	 mov	 r8d, DWORD PTR bufl$[rsp]
  00513	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR bufp$[rsp]
  0051b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00523	e8 00 00 00 00	 call	 cckd64_write_trkimg

; 1362 :     }
; 1363 :     release_lock( &cckd->filelock );

  00528	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0052d	48 83 c0 10	 add	 rax, 16
  00531	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170174
  00538	48 8b c8	 mov	 rcx, rax
  0053b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1364 : 
; 1365 :     /* Schedule the garbage collector */
; 1366 :     obtain_lock( &cckdblk.gclock );/* ensure read integrity for gc count */

  00541	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170175
  00548	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  0054f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1367 :     {
; 1368 :         if (cckdblk.gcint > 0 && cckdblk.gcs < cckdblk.gcmax)

  00555	83 3d 44 00 00
	00 00		 cmp	 DWORD PTR cckdblk+68, 0
  0055c	0f 8e cb 01 00
	00		 jle	 $LN11@cckd64_wri
  00562	8b 05 40 00 00
	00		 mov	 eax, DWORD PTR cckdblk+64
  00568	39 05 38 00 00
	00		 cmp	 DWORD PTR cckdblk+56, eax
  0056e	0f 8d b9 01 00
	00		 jge	 $LN11@cckd64_wri

; 1369 :         {
; 1370 :             /* Schedule a new garbage collector thread */
; 1371 : 
; 1372 :             if (!cckdblk.batch || cckdblk.batchml > 1)

  00574	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  0057a	83 e0 01	 and	 eax, 1
  0057d	85 c0		 test	 eax, eax
  0057f	74 09		 je	 SHORT $LN13@cckd64_wri
  00581	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  00588	7e 71		 jle	 SHORT $LN12@cckd64_wri
$LN13@cckd64_wri:

; 1373 :                 // "Starting thread %s, active=%d, started=%d, max=%d"
; 1374 :                 WRMSG( HHC00107, "I", CCKD_GC_THREAD_NAME "()",

  0058a	b9 01 00 00 00	 mov	 ecx, 1
  0058f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00595	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+64
  0059b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0059f	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+56
  005a5	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  005a9	8b 0d 3c 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+60
  005af	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170179
  005ba	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170180
  005c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170181
  005d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  005e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170182
  005e9	ba 5f 05 00 00	 mov	 edx, 1375		; 0000055fH
  005ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170183
  005f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@cckd64_wri:

; 1375 :                     cckdblk.gca, cckdblk.gcs, cckdblk.gcmax );
; 1376 : 
; 1377 :             ++cckdblk.gcs;

  005fb	8b 05 38 00 00
	00		 mov	 eax, DWORD PTR cckdblk+56
  00601	ff c0		 inc	 eax
  00603	89 05 38 00 00
	00		 mov	 DWORD PTR cckdblk+56, eax

; 1378 : 
; 1379 :             /* Release lock across thread create to prevent interlock  */
; 1380 :             release_lock( &cckdblk.gclock );

  00609	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170184
  00610	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  00617	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1381 :             {
; 1382 :                 rc = create_thread( &tid, JOINABLE, cckd_gcol, NULL, CCKD_GC_THREAD_NAME );

  0061d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00624	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  0062a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170185
  00631	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00636	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170186
  0063d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00642	45 33 c9	 xor	 r9d, r9d
  00645	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cckd_gcol
  0064c	48 8b d0	 mov	 rdx, rax
  0064f	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR tid$[rsp]
  00657	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  0065d	89 84 24 b4 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1383 :             }
; 1384 :             obtain_lock( &cckdblk.gclock );

  00664	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170187
  0066b	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  00672	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1385 : 
; 1386 :             if (rc)

  00678	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00680	0f 84 a7 00 00
	00		 je	 $LN14@cckd64_wri

; 1387 :             {
; 1388 :                 // "Error in function create_thread() for %s %d of %d: %s"
; 1389 :                 WRMSG( HHC00106, "E", CCKD_GC_THREAD_NAME "()",

  00686	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR rc$[rsp]
  0068d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00693	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv326[rsp], rax
  0069b	8b 0d 38 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+56
  006a1	ff c9		 dec	 ecx
  006a3	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv330[rsp], ecx
  006aa	b9 01 00 00 00	 mov	 ecx, 1
  006af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006b5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv326[rsp]
  006bd	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006c2	8b 0d 40 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+64
  006c8	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  006cc	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv330[rsp]
  006d3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170189
  006de	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170190
  006ea	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170191
  006f6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00700	41 b9 03 00 00
	00		 mov	 r9d, 3
  00706	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170192
  0070d	ba 6e 05 00 00	 mov	 edx, 1390		; 0000056eH
  00712	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170193
  00719	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1390 :                     cckdblk.gcs-1, cckdblk.gcmax, strerror( rc ));
; 1391 : 
; 1392 :                 --cckdblk.gcs;

  0071f	8b 05 38 00 00
	00		 mov	 eax, DWORD PTR cckdblk+56
  00725	ff c8		 dec	 eax
  00727	89 05 38 00 00
	00		 mov	 DWORD PTR cckdblk+56, eax
$LN14@cckd64_wri:
$LN11@cckd64_wri:

; 1393 :             }
; 1394 :         }
; 1395 :     }
; 1396 :     release_lock( &cckdblk.gclock );

  0072d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170194
  00734	48 8d 0d 28 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+40
  0073b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1397 : 
; 1398 :     obtain_lock( &cckd->cckdiolock );

  00741	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00746	48 83 c0 18	 add	 rax, 24
  0074a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170195
  00751	48 8b c8	 mov	 rcx, rax
  00754	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1399 :     {
; 1400 :         cache_lock( CACHE_DEVBUF );

  0075a	33 c9		 xor	 ecx, ecx
  0075c	e8 00 00 00 00	 call	 cache_lock

; 1401 :         {
; 1402 :             flag = cache_setflag( CACHE_DEVBUF, o, ~CCKD_CACHE_WRITING, 0 );

  00761	45 33 c9	 xor	 r9d, r9d
  00764	41 b8 ff ff ff
	df		 mov	 r8d, -536870913		; dfffffffH
  0076a	8b 94 24 08 01
	01 00		 mov	 edx, DWORD PTR o$[rsp]
  00771	33 c9		 xor	 ecx, ecx
  00773	e8 00 00 00 00	 call	 cache_setflag
  00778	89 84 24 bc 00
	00 00		 mov	 DWORD PTR flag$[rsp], eax

; 1403 :         }
; 1404 :         cache_unlock( CACHE_DEVBUF );

  0077f	33 c9		 xor	 ecx, ecx
  00781	e8 00 00 00 00	 call	 cache_unlock

; 1405 : 
; 1406 :         cckd->wrpending--;

  00786	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0078b	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  0078e	ff c8		 dec	 eax
  00790	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00795	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 1407 : 
; 1408 :         if (1
; 1409 :             && cckd->cckdwaiters
; 1410 :             && (0

  00798	33 c0		 xor	 eax, eax
  0079a	83 f8 01	 cmp	 eax, 1
  0079d	0f 84 83 00 00
	00		 je	 $LN15@cckd64_wri
  007a3	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  007a8	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  007ac	74 78		 je	 SHORT $LN15@cckd64_wri
  007ae	33 c0		 xor	 eax, eax
  007b0	85 c0		 test	 eax, eax
  007b2	75 1b		 jne	 SHORT $LN16@cckd64_wri
  007b4	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR flag$[rsp]
  007bb	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  007c0	85 c0		 test	 eax, eax
  007c2	75 0b		 jne	 SHORT $LN16@cckd64_wri
  007c4	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  007c9	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  007cd	75 57		 jne	 SHORT $LN15@cckd64_wri
$LN16@cckd64_wri:

; 1411 :                 || (flag & CCKD_CACHE_IOWAIT)
; 1412 :                 || !cckd->wrpending
; 1413 :                )
; 1414 :         )
; 1415 :         {   CCKD_TRACE( "writer[%d] cache[%2.2d] %d signalling write complete",

  007cf	8b 44 24 7c	 mov	 eax, DWORD PTR trk$[rsp]
  007d3	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  007d7	8b 84 24 08 01
	01 00		 mov	 eax, DWORD PTR o$[rsp]
  007de	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  007e2	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR writer$[rsp]
  007e9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  007ed	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170198
  007f4	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  007fc	ba 88 05 00 00	 mov	 edx, 1416		; 00000588H
  00801	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170199
  00808	e8 00 00 00 00	 call	 cckd_trace

; 1416 :                         writer, o, trk );
; 1417 : 
; 1418 :             broadcast_condition( &cckd->cckdiocond );

  0080d	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00812	48 83 c0 20	 add	 rax, 32			; 00000020H
  00816	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170200
  0081d	48 8b c8	 mov	 rcx, rax
  00820	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN15@cckd64_wri:

; 1419 :         }
; 1420 :     }
; 1421 :     release_lock( &cckd->cckdiolock );

  00826	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  0082b	48 83 c0 18	 add	 rax, 24
  0082f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170201
  00836	48 8b c8	 mov	 rcx, rax
  00839	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1422 : 
; 1423 :     CCKD_TRACE( "%d wrtrk[%2.2d] %d complete flags:%8.8x",

  0083f	8b 94 24 08 01
	01 00		 mov	 edx, DWORD PTR o$[rsp]
  00846	33 c9		 xor	 ecx, ecx
  00848	e8 00 00 00 00	 call	 cache_getflag
  0084d	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00851	8b 44 24 7c	 mov	 eax, DWORD PTR trk$[rsp]
  00855	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00859	8b 84 24 08 01
	01 00		 mov	 eax, DWORD PTR o$[rsp]
  00860	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00864	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR writer$[rsp]
  0086b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0086f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170202
  00876	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0087e	ba 90 05 00 00	 mov	 edx, 1424		; 00000590H
  00883	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170203
  0088a	e8 00 00 00 00	 call	 cckd_trace
$LN1@cckd64_wri:

; 1424 :                 writer, o, trk, cache_getflag( CACHE_DEVBUF, o ));
; 1425 : 
; 1426 : } /* end function cckd64_writer_write */

  0088f	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00897	48 33 cc	 xor	 rcx, rsp
  0089a	e8 00 00 00 00	 call	 __security_check_cookie
  0089f	48 81 c4 f8 00
	01 00		 add	 rsp, 65784		; 000100f8H
  008a6	c3		 ret	 0
cckd64_writer_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
devnum$ = 64
trk$ = 68
dev$ = 72
answer$ = 96
ix$ = 104
i$ = 112
data$ = 120
cckd64_purge_cache_scan PROC

; 1255 : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1256 : U16             devnum;                 /* Cached device number      */
; 1257 : U32             trk;                    /* Cached track              */
; 1258 : DEVBLK         *dev = data;             /* -> device block           */

  00017	48 8b 44 24 78	 mov	 rax, QWORD PTR data$[rsp]
  0001c	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd64_pur:

; 1259 : 
; 1260 :     UNREFERENCED(answer);

  00021	33 c0		 xor	 eax, eax
  00023	85 c0		 test	 eax, eax
  00025	75 fa		 jne	 SHORT $LN4@cckd64_pur
$LN7@cckd64_pur:

; 1261 :     CCKD_CACHE_GETKEY(i, devnum, trk);

  00027	8b 54 24 70	 mov	 edx, DWORD PTR i$[rsp]
  0002b	33 c9		 xor	 ecx, ecx
  0002d	e8 00 00 00 00	 call	 cache_getkey
  00032	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00036	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  0003c	66 89 44 24 40	 mov	 WORD PTR devnum$[rsp], ax
  00041	8b 54 24 70	 mov	 edx, DWORD PTR i$[rsp]
  00045	33 c9		 xor	 ecx, ecx
  00047	e8 00 00 00 00	 call	 cache_getkey
  0004c	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00051	48 23 c1	 and	 rax, rcx
  00054	89 44 24 44	 mov	 DWORD PTR trk$[rsp], eax
  00058	33 c0		 xor	 eax, eax
  0005a	85 c0		 test	 eax, eax
  0005c	75 c9		 jne	 SHORT $LN7@cckd64_pur

; 1262 :     if (dev->devnum == devnum)

  0005e	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00063	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00067	0f b7 4c 24 40	 movzx	 ecx, WORD PTR devnum$[rsp]
  0006c	3b c1		 cmp	 eax, ecx
  0006e	75 46		 jne	 SHORT $LN8@cckd64_pur

; 1263 :     {
; 1264 :         cache_release (ix, i, 0);

  00070	45 33 c0	 xor	 r8d, r8d
  00073	8b 54 24 70	 mov	 edx, DWORD PTR i$[rsp]
  00077	8b 4c 24 68	 mov	 ecx, DWORD PTR ix$[rsp]
  0007b	e8 00 00 00 00	 call	 cache_release

; 1265 :         CCKD_TRACE( "purge cache[%d] %4.4X trk %d purged",

  00080	0f b7 44 24 40	 movzx	 eax, WORD PTR devnum$[rsp]
  00085	8b 4c 24 44	 mov	 ecx, DWORD PTR trk$[rsp]
  00089	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0008d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00091	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  00095	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00099	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170133
  000a0	4c 8b 44 24 48	 mov	 r8, QWORD PTR dev$[rsp]
  000a5	ba f2 04 00 00	 mov	 edx, 1266		; 000004f2H
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170134
  000b1	e8 00 00 00 00	 call	 cckd_trace
$LN8@cckd64_pur:

; 1266 :                     i, devnum, trk);
; 1267 :     }
; 1268 :     return 0;

  000b6	33 c0		 xor	 eax, eax

; 1269 : }

  000b8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000bc	c3		 ret	 0
cckd64_purge_cache_scan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
dev$ = 48
cckd64_purge_cache PROC

; 1242 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1243 :     if (!dev->cckd64)

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 0c		 jne	 SHORT $LN2@cckd64_pur

; 1244 :     {
; 1245 :         cckd_purge_cache( dev );

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd_purge_cache

; 1246 :         return;

  00028	eb 21		 jmp	 SHORT $LN1@cckd64_pur
$LN2@cckd64_pur:

; 1247 :     }
; 1248 : 
; 1249 :     /* Scan cache and purge entries */
; 1250 :     cache_lock (CACHE_DEVBUF);

  0002a	33 c9		 xor	 ecx, ecx
  0002c	e8 00 00 00 00	 call	 cache_lock

; 1251 :     cache_scan (CACHE_DEVBUF, cckd64_purge_cache_scan, dev);

  00031	4c 8b 44 24 30	 mov	 r8, QWORD PTR dev$[rsp]
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cckd64_purge_cache_scan
  0003d	33 c9		 xor	 ecx, ecx
  0003f	e8 00 00 00 00	 call	 cache_scan

; 1252 :     cache_unlock (CACHE_DEVBUF);

  00044	33 c9		 xor	 ecx, ecx
  00046	e8 00 00 00 00	 call	 cache_unlock
$LN1@cckd64_pur:

; 1253 : }

  0004b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004f	c3		 ret	 0
cckd64_purge_cache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
dev$ = 32
cckd$ = 40
cckd64_flush_cache_all PROC

; 1219 : {

$LN7:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1220 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 1221 : DEVBLK         *dev = NULL;             /* -> device block           */

  00004	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR dev$[rsp], 0

; 1222 : 
; 1223 :     cckd_lock_devchain(0);

  0000d	33 c9		 xor	 ecx, ecx
  0000f	e8 00 00 00 00	 call	 cckd_lock_devchain

; 1224 :     for (dev = cckdblk.dev1st; dev; dev = cckd->devnext)

  00014	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  0001b	48 89 44 24 20	 mov	 QWORD PTR dev$[rsp], rax
  00020	eb 0d		 jmp	 SHORT $LN4@cckd64_flu
$LN2@cckd64_flu:
  00022	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	48 89 44 24 20	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd64_flu:
  0002f	48 83 7c 24 20
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00035	74 76		 je	 SHORT $LN3@cckd64_flu

; 1225 :     {
; 1226 :         cckd = dev->cckd_ext;

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00043	48 89 44 24 28	 mov	 QWORD PTR cckd$[rsp], rax

; 1227 :         obtain_lock (&cckd->cckdiolock);

  00048	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  0004d	48 83 c0 18	 add	 rax, 24
  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170105
  00058	48 8b c8	 mov	 rcx, rax
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1228 :         if (!cckd->merging && !cckd->stopping)

  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00066	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00069	c1 e8 05	 shr	 eax, 5
  0006c	83 e0 01	 and	 eax, 1
  0006f	85 c0		 test	 eax, eax
  00071	75 1c		 jne	 SHORT $LN5@cckd64_flu
  00073	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00078	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0007b	c1 e8 06	 shr	 eax, 6
  0007e	83 e0 01	 and	 eax, 1
  00081	85 c0		 test	 eax, eax
  00083	75 0a		 jne	 SHORT $LN5@cckd64_flu

; 1229 :             cckd64_flush_cache(dev);

  00085	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  0008a	e8 00 00 00 00	 call	 cckd64_flush_cache
$LN5@cckd64_flu:

; 1230 :         release_lock (&cckd->cckdiolock);

  0008f	48 8b 44 24 28	 mov	 rax, QWORD PTR cckd$[rsp]
  00094	48 83 c0 18	 add	 rax, 24
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170107
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1231 :     }

  000a8	e9 75 ff ff ff	 jmp	 $LN2@cckd64_flu
$LN3@cckd64_flu:

; 1232 :     cckd_unlock_devchain();

  000ad	e8 00 00 00 00	 call	 cckd_unlock_devchain

; 1233 : }

  000b2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b6	c3		 ret	 0
cckd64_flush_cache_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
devnum$ = 64
trk$ = 68
cckd$ = 72
dev$ = 80
answer$ = 112
ix$ = 120
i$ = 128
data$ = 136
cckd64_flush_cache_scan PROC

; 1197 : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1198 : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 1199 : U16             devnum;                 /* Cached device number      */
; 1200 : U32             trk;                    /* Cached track              */
; 1201 : DEVBLK         *dev = data;             /* -> device block           */

  00017	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0001f	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
$LN4@cckd64_flu:

; 1202 : 
; 1203 :     UNREFERENCED(answer);

  00024	33 c0		 xor	 eax, eax
  00026	85 c0		 test	 eax, eax
  00028	75 fa		 jne	 SHORT $LN4@cckd64_flu

; 1204 :     cckd = dev->cckd_ext;

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00036	48 89 44 24 48	 mov	 QWORD PTR cckd$[rsp], rax
$LN7@cckd64_flu:

; 1205 :     CCKD_CACHE_GETKEY(i, devnum, trk);

  0003b	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00042	33 c9		 xor	 ecx, ecx
  00044	e8 00 00 00 00	 call	 cache_getkey
  00049	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0004d	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00053	66 89 44 24 40	 mov	 WORD PTR devnum$[rsp], ax
  00058	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  0005f	33 c9		 xor	 ecx, ecx
  00061	e8 00 00 00 00	 call	 cache_getkey
  00066	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0006b	48 23 c1	 and	 rax, rcx
  0006e	89 44 24 44	 mov	 DWORD PTR trk$[rsp], eax
  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 c3		 jne	 SHORT $LN7@cckd64_flu

; 1206 :     if ((cache_getflag(ix,i) & CACHE_BUSY) == CCKD_CACHE_UPDATED
; 1207 :      && dev->devnum == devnum)

  00078	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  0007f	8b 4c 24 78	 mov	 ecx, DWORD PTR ix$[rsp]
  00083	e8 00 00 00 00	 call	 cache_getflag
  00088	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  0008d	3d 00 00 00 08	 cmp	 eax, 134217728		; 08000000H
  00092	0f 85 97 00 00
	00		 jne	 $LN8@cckd64_flu
  00098	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0009d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000a1	0f b7 4c 24 40	 movzx	 ecx, WORD PTR devnum$[rsp]
  000a6	3b c1		 cmp	 eax, ecx
  000a8	0f 85 81 00 00
	00		 jne	 $LN8@cckd64_flu

; 1208 :     {
; 1209 :         cache_setflag (ix, i, ~CCKD_CACHE_UPDATED, CCKD_CACHE_WRITE);

  000ae	41 b9 00 00 00
	04		 mov	 r9d, 67108864		; 04000000H
  000b4	41 b8 ff ff ff
	f7		 mov	 r8d, -134217729		; f7ffffffH
  000ba	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  000c1	8b 4c 24 78	 mov	 ecx, DWORD PTR ix$[rsp]
  000c5	e8 00 00 00 00	 call	 cache_setflag

; 1210 :         ++cckd->wrpending;

  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  000cf	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  000d2	ff c0		 inc	 eax
  000d4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cckd$[rsp]
  000d9	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 1211 :         ++cckdblk.wrpending;

  000dc	8b 05 60 00 00
	00		 mov	 eax, DWORD PTR cckdblk+96
  000e2	ff c0		 inc	 eax
  000e4	89 05 60 00 00
	00		 mov	 DWORD PTR cckdblk+96, eax

; 1212 :         CCKD_TRACE( "flush file[%d] cache[%d] %4.4X trk %d",

  000ea	0f b7 44 24 40	 movzx	 eax, WORD PTR devnum$[rsp]
  000ef	8b 4c 24 44	 mov	 ecx, DWORD PTR trk$[rsp]
  000f3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f7	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000fb	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00102	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00106	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  0010b	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0010e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00112	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170096
  00119	4c 8b 44 24 50	 mov	 r8, QWORD PTR dev$[rsp]
  0011e	ba bd 04 00 00	 mov	 edx, 1213		; 000004bdH
  00123	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170097
  0012a	e8 00 00 00 00	 call	 cckd_trace
$LN8@cckd64_flu:

; 1213 :                     cckd->sfn, i, devnum, trk);
; 1214 :     }
; 1215 :     return 0;

  0012f	33 c0		 xor	 eax, eax

; 1216 : }

  00131	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00135	c3		 ret	 0
cckd64_flush_cache_scan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
rc$ = 96
tv147 = 100
tid$ = 104
tv143 = 112
dev$ = 144
cckd64_flush_cache PROC

; 1144 : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1145 : int             rc;                     /* Return code               */
; 1146 : TID             tid;                    /* Writer thread id          */
; 1147 : 
; 1148 :     if (!dev->cckd64)

  0000c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00014	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0001b	24 01		 and	 al, 1
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	75 12		 jne	 SHORT $LN2@cckd64_flu

; 1149 :     {
; 1150 :         cckd_flush_cache( dev );

  00024	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 cckd_flush_cache

; 1151 :         return;

  00031	e9 2e 02 00 00	 jmp	 $LN1@cckd64_flu
$LN2@cckd64_flu:

; 1152 :     }
; 1153 : 
; 1154 :     /* Scan cache for updated cache entries */
; 1155 :     obtain_lock (&cckdblk.wrlock);

  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170050
  0003d	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1156 :     cache_lock (CACHE_DEVBUF);

  0004a	33 c9		 xor	 ecx, ecx
  0004c	e8 00 00 00 00	 call	 cache_lock

; 1157 :     cache_scan (CACHE_DEVBUF, cckd64_flush_cache_scan, dev);

  00051	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cckd64_flush_cache_scan
  00060	33 c9		 xor	 ecx, ecx
  00062	e8 00 00 00 00	 call	 cache_scan

; 1158 :     cache_unlock (CACHE_DEVBUF);

  00067	33 c9		 xor	 ecx, ecx
  00069	e8 00 00 00 00	 call	 cache_unlock

; 1159 : 
; 1160 :     /* Schedule the writer if any writes are pending */
; 1161 :     if (cckdblk.wrpending)

  0006e	83 3d 60 00 00
	00 00		 cmp	 DWORD PTR cckdblk+96, 0
  00075	0f 84 d5 01 00
	00		 je	 $LN3@cckd64_flu

; 1162 :     {
; 1163 :         if (cckdblk.wrwaiting)

  0007b	83 3d 64 00 00
	00 00		 cmp	 DWORD PTR cckdblk+100, 0
  00082	74 19		 je	 SHORT $LN4@cckd64_flu

; 1164 :             signal_condition (&cckdblk.wrcond);

  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170054
  0008b	48 8d 0d 58 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+88
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
  00098	e9 b3 01 00 00	 jmp	 $LN5@cckd64_flu
$LN4@cckd64_flu:

; 1165 :         else if (cckdblk.wrs < cckdblk.wrmax)

  0009d	8b 05 70 00 00
	00		 mov	 eax, DWORD PTR cckdblk+112
  000a3	39 05 68 00 00
	00		 cmp	 DWORD PTR cckdblk+104, eax
  000a9	0f 8d a1 01 00
	00		 jge	 $LN6@cckd64_flu

; 1166 :         {
; 1167 :             /* Schedule a new writer thread  */
; 1168 :             if (!cckdblk.batch || cckdblk.batchml > 1)

  000af	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  000b5	83 e0 01	 and	 eax, 1
  000b8	85 c0		 test	 eax, eax
  000ba	74 09		 je	 SHORT $LN8@cckd64_flu
  000bc	83 3d 18 00 00
	00 01		 cmp	 DWORD PTR cckdblk+24, 1
  000c3	7e 71		 jle	 SHORT $LN7@cckd64_flu
$LN8@cckd64_flu:

; 1169 :                 // "Starting thread %s, active=%d, started=%d, max=%d"
; 1170 :                 WRMSG(HHC00107, "I", CCKD_WR_THREAD_NAME "()",

  000c5	b9 01 00 00 00	 mov	 ecx, 1
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d0	8b 0d 70 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+112
  000d6	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  000da	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+104
  000e0	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000e4	8b 0d 6c 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+108
  000ea	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170058
  000f5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170059
  00101	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170060
  0010d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00112	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00117	41 b9 03 00 00
	00		 mov	 r9d, 3
  0011d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170061
  00124	ba 93 04 00 00	 mov	 edx, 1171		; 00000493H
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170062
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@cckd64_flu:

; 1171 :                     cckdblk.wra, cckdblk.wrs, cckdblk.wrmax);
; 1172 : 
; 1173 :             ++cckdblk.wrs;

  00136	8b 05 68 00 00
	00		 mov	 eax, DWORD PTR cckdblk+104
  0013c	ff c0		 inc	 eax
  0013e	89 05 68 00 00
	00		 mov	 DWORD PTR cckdblk+104, eax

; 1174 : 
; 1175 :             /* Release lock across thread create to prevent interlock  */
; 1176 :             release_lock(&cckdblk.wrlock);

  00144	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170063
  0014b	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1177 :             {
; 1178 :                 rc = create_thread( &tid, JOINABLE, cckd_writer, NULL, CCKD_WR_THREAD_NAME );

  00158	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0015f	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170064
  0016c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170065
  00178	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0017d	45 33 c9	 xor	 r9d, r9d
  00180	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cckd_writer
  00187	48 8b d0	 mov	 rdx, rax
  0018a	48 8d 4c 24 68	 lea	 rcx, QWORD PTR tid$[rsp]
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00195	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 1179 :             }
; 1180 :             obtain_lock(&cckdblk.wrlock);

  00199	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170066
  001a0	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1181 : 
; 1182 :             if (rc)

  001ad	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  001b2	0f 84 98 00 00
	00		 je	 $LN9@cckd64_flu

; 1183 :             {
; 1184 :                 // "Error in function create_thread() for %s %d of %d: %s"
; 1185 :                 WRMSG(HHC00106, "E", CCKD_WR_THREAD_NAME "()",

  001b8	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001c2	48 89 44 24 70	 mov	 QWORD PTR tv143[rsp], rax
  001c7	8b 0d 68 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+104
  001cd	ff c9		 dec	 ecx
  001cf	89 4c 24 64	 mov	 DWORD PTR tv147[rsp], ecx
  001d3	b9 01 00 00 00	 mov	 ecx, 1
  001d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001de	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv143[rsp]
  001e3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001e8	8b 0d 70 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+112
  001ee	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001f2	8b 4c 24 64	 mov	 ecx, DWORD PTR tv147[rsp]
  001f6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170068
  00201	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170069
  0020d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170070
  00219	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00223	41 b9 03 00 00
	00		 mov	 r9d, 3
  00229	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170071
  00230	ba a2 04 00 00	 mov	 edx, 1186		; 000004a2H
  00235	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170072
  0023c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1186 :                     cckdblk.wrs-1, cckdblk.wrmax, strerror(rc));
; 1187 : 
; 1188 :                 --cckdblk.wrs;

  00242	8b 05 68 00 00
	00		 mov	 eax, DWORD PTR cckdblk+104
  00248	ff c8		 dec	 eax
  0024a	89 05 68 00 00
	00		 mov	 DWORD PTR cckdblk+104, eax
$LN9@cckd64_flu:
$LN6@cckd64_flu:
$LN5@cckd64_flu:
$LN3@cckd64_flu:

; 1189 :             }
; 1190 :         }
; 1191 :     }
; 1192 : 
; 1193 :     release_lock (&cckdblk.wrlock);

  00250	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170073
  00257	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+80
  0025e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@cckd64_flu:

; 1194 : }

  00264	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0026b	c3		 ret	 0
cckd64_flush_cache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
lru$ = 112
cckd$ = 120
fnd$ = 128
buf$ = 136
curtrk$ = 144
devnum$ = 148
tv400 = 152
maxlen$ = 156
oldtrk$ = 160
len$ = 164
flag$ = 168
tv85 = 176
tv227 = 184
tv438 = 192
dev$ = 224
trk$ = 232
ra$ = 240
unitstat$ = 248
cckd64_read_trk PROC

; 937  : {

$LN35:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H

; 938  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 939  : int             fnd;                    /* Cache index for hit       */
; 940  : int             lru;                    /* Oldest unused cache index */
; 941  : int             len;                    /* Length of track image     */
; 942  : int             maxlen;                 /* Length for buffer         */
; 943  : int             curtrk = -1;            /* Current track (at entry)  */

  0001b	c7 84 24 90 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR curtrk$[rsp], -1

; 944  : U16             devnum;                 /* Device number             */
; 945  : U32             oldtrk;                 /* Stolen track number       */
; 946  : U32             flag;                   /* Cache flag                */
; 947  : BYTE           *buf;                    /* Read buffer               */
; 948  : 
; 949  :     if (!dev->cckd64)

  00026	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00035	24 01		 and	 al, 1
  00037	0f b6 c0	 movzx	 eax, al
  0003a	85 c0		 test	 eax, eax
  0003c	75 29		 jne	 SHORT $LN7@cckd64_rea

; 950  :         return cckd_read_trk( dev, trk, ra, unitstat );

  0003e	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  00046	44 8b 84 24 f0
	00 00 00	 mov	 r8d, DWORD PTR ra$[rsp]
  0004e	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  00055	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0005d	e8 00 00 00 00	 call	 cckd_read_trk
  00062	e9 89 0b 00 00	 jmp	 $LN1@cckd64_rea
$LN7@cckd64_rea:

; 951  : 
; 952  :     cckd = dev->cckd_ext;

  00067	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006f	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00076	48 89 44 24 78	 mov	 QWORD PTR cckd$[rsp], rax

; 953  : 
; 954  :     CCKD_TRACE( "%d rdtrk     %d", ra, trk);

  0007b	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00082	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00086	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  0008d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00091	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169989
  00098	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000a0	ba ba 03 00 00	 mov	 edx, 954		; 000003baH
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169990
  000ac	e8 00 00 00 00	 call	 cckd_trace

; 955  : 
; 956  :     maxlen = cckd->ckddasd ? dev->ckdtrksz

  000b1	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  000b6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000b9	83 e0 01	 and	 eax, 1
  000bc	85 c0		 test	 eax, eax
  000be	74 19		 je	 SHORT $LN29@cckd64_rea
  000c0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c8	48 63 80 c4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4804]
  000cf	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv85[rsp], rax
  000d7	eb 0c		 jmp	 SHORT $LN30@cckd64_rea
$LN29@cckd64_rea:
  000d9	48 c7 84 24 b0
	00 00 00 05 f0
	00 00		 mov	 QWORD PTR tv85[rsp], 61445 ; 0000f005H
$LN30@cckd64_rea:
  000e5	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv85[rsp]
  000ec	89 84 24 9c 00
	00 00		 mov	 DWORD PTR maxlen$[rsp], eax

; 957  :                            : CKD_TRKHDR_SIZE + CFBA_BLKGRP_SIZE;
; 958  : 
; 959  :     if (!ra) obtain_lock (&cckd->cckdiolock);

  000f3	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  000fb	75 19		 jne	 SHORT $LN8@cckd64_rea
  000fd	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00102	48 83 c0 18	 add	 rax, 24
  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169992
  0010d	48 8b c8	 mov	 rcx, rax
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN8@cckd64_rea:

; 960  : 
; 961  :     cache_lock (CACHE_DEVBUF);

  00116	33 c9		 xor	 ecx, ecx
  00118	e8 00 00 00 00	 call	 cache_lock

; 962  : 
; 963  :     /* Inactivate the old entry */
; 964  :     if (!ra)

  0011d	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  00125	75 68		 jne	 SHORT $LN9@cckd64_rea

; 965  :     {
; 966  :         curtrk = dev->bufcur;

  00127	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0012f	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  00135	89 84 24 90 00
	00 00		 mov	 DWORD PTR curtrk$[rsp], eax

; 967  :         if (dev->cache >= 0)

  0013c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00144	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  0014b	7c 1e		 jl	 SHORT $LN10@cckd64_rea

; 968  :             cache_setflag(CACHE_DEVBUF, dev->cache, ~CCKD_CACHE_ACTIVE, 0);

  0014d	45 33 c9	 xor	 r9d, r9d
  00150	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  00156	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0015e	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00164	33 c9		 xor	 ecx, ecx
  00166	e8 00 00 00 00	 call	 cache_setflag
$LN10@cckd64_rea:

; 969  :         dev->bufcur = dev->cache = -1;

  0016b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00173	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0017d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00185	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1
$LN9@cckd64_rea:
$cckd_read_trk_retry$36:

; 970  :     }
; 971  : 
; 972  : cckd_read_trk_retry:
; 973  : 
; 974  :     /* scan the cache array for the track */
; 975  :     fnd = cache_lookup (CACHE_DEVBUF, CCKD_CACHE_SETKEY(dev->devnum, trk), &lru);

  0018f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00197	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0019b	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  0019f	48 63 8c 24 e8
	00 00 00	 movsxd	 rcx, DWORD PTR trk$[rsp]
  001a7	48 0b c1	 or	 rax, rcx
  001aa	4c 8d 44 24 70	 lea	 r8, QWORD PTR lru$[rsp]
  001af	48 8b d0	 mov	 rdx, rax
  001b2	33 c9		 xor	 ecx, ecx
  001b4	e8 00 00 00 00	 call	 cache_lookup
  001b9	89 84 24 80 00
	00 00		 mov	 DWORD PTR fnd$[rsp], eax

; 976  : 
; 977  :     /* check for cache hit */
; 978  :     if (fnd >= 0)

  001c0	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR fnd$[rsp], 0
  001c8	0f 8c cf 03 00
	00		 jl	 $LN11@cckd64_rea

; 979  :     {
; 980  :         if (ra) /* readahead doesn't care about a cache hit */

  001ce	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  001d6	74 13		 je	 SHORT $LN12@cckd64_rea

; 981  :         {   cache_unlock (CACHE_DEVBUF);

  001d8	33 c9		 xor	 ecx, ecx
  001da	e8 00 00 00 00	 call	 cache_unlock

; 982  :             return fnd;

  001df	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR fnd$[rsp]
  001e6	e9 05 0a 00 00	 jmp	 $LN1@cckd64_rea
$LN12@cckd64_rea:

; 983  :         }
; 984  : 
; 985  :         /* Mark the new entry active */
; 986  :         cache_setflag(CACHE_DEVBUF, fnd, ~0, CCKD_CACHE_ACTIVE | CCKD_CACHE_USED);

  001eb	41 b9 00 00 80
	80		 mov	 r9d, -2139095040	; 80800000H
  001f1	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  001f7	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  001fe	33 c9		 xor	 ecx, ecx
  00200	e8 00 00 00 00	 call	 cache_setflag

; 987  :         cache_setage(CACHE_DEVBUF, fnd);

  00205	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  0020c	33 c9		 xor	 ecx, ecx
  0020e	e8 00 00 00 00	 call	 cache_setage

; 988  : 
; 989  :         /* If the entry is pending write then change it to `updated' */
; 990  :         if (cache_getflag(CACHE_DEVBUF, fnd) & CCKD_CACHE_WRITE)

  00213	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  0021a	33 c9		 xor	 ecx, ecx
  0021c	e8 00 00 00 00	 call	 cache_getflag
  00221	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00226	85 c0		 test	 eax, eax
  00228	74 5b		 je	 SHORT $LN13@cckd64_rea

; 991  :         {
; 992  :             cache_setflag(CACHE_DEVBUF, fnd, ~CCKD_CACHE_WRITE, CCKD_CACHE_UPDATED);

  0022a	41 b9 00 00 00
	08		 mov	 r9d, 134217728		; 08000000H
  00230	41 b8 ff ff ff
	fb		 mov	 r8d, -67108865		; fbffffffH
  00236	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  0023d	33 c9		 xor	 ecx, ecx
  0023f	e8 00 00 00 00	 call	 cache_setflag

; 993  :             cckd->wrpending--;

  00244	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00249	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  0024c	ff c8		 dec	 eax
  0024e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00253	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 994  :             if (cckd->cckdwaiters && !cckd->wrpending)

  00256	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0025b	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0025f	74 24		 je	 SHORT $LN14@cckd64_rea
  00261	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00266	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  0026a	75 19		 jne	 SHORT $LN14@cckd64_rea

; 995  :                 broadcast_condition (&cckd->cckdiocond);

  0026c	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00271	48 83 c0 20	 add	 rax, 32			; 00000020H
  00275	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169999
  0027c	48 8b c8	 mov	 rcx, rax
  0027f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN14@cckd64_rea:
$LN13@cckd64_rea:

; 996  :         }
; 997  :         buf = cache_getbuf(CACHE_DEVBUF, fnd, 0);

  00285	45 33 c0	 xor	 r8d, r8d
  00288	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  0028f	33 c9		 xor	 ecx, ecx
  00291	e8 00 00 00 00	 call	 cache_getbuf
  00296	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 998  : 
; 999  :         cache_unlock (CACHE_DEVBUF);

  0029e	33 c9		 xor	 ecx, ecx
  002a0	e8 00 00 00 00	 call	 cache_unlock

; 1000 : 
; 1001 :         CCKD_TRACE( "%d rdtrk[%d] %d cache hit buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x",

  002a5	b8 01 00 00 00	 mov	 eax, 1
  002aa	48 6b c0 04	 imul	 rax, rax, 4
  002ae	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  002b6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ba	b9 01 00 00 00	 mov	 ecx, 1
  002bf	48 6b c9 03	 imul	 rcx, rcx, 3
  002c3	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  002cb	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002cf	ba 01 00 00 00	 mov	 edx, 1
  002d4	48 6b d2 02	 imul	 rdx, rdx, 2
  002d8	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  002e0	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  002e5	41 b8 01 00 00
	00		 mov	 r8d, 1
  002eb	4d 6b c0 01	 imul	 r8, r8, 1
  002ef	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  002f7	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  002fc	41 b9 01 00 00
	00		 mov	 r9d, 1
  00302	4d 6b c9 00	 imul	 r9, r9, 0
  00306	4c 8b 94 24 88
	00 00 00	 mov	 r10, QWORD PTR buf$[rsp]
  0030e	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  00313	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00317	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0031b	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  0031f	44 89 44 24 48	 mov	 DWORD PTR [rsp+72], r8d
  00324	44 89 4c 24 40	 mov	 DWORD PTR [rsp+64], r9d
  00329	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00331	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00336	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0033d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00341	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR fnd$[rsp]
  00348	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0034c	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  00353	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00357	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170000
  0035e	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00366	ba ea 03 00 00	 mov	 edx, 1002		; 000003eaH
  0036b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170001
  00372	e8 00 00 00 00	 call	 cckd_trace

; 1002 :                     ra, fnd, trk, buf, buf[0], buf[1], buf[2], buf[3], buf[4]);
; 1003 : 
; 1004 :         cckdblk.stats_switches++;  cckd->switches++;

  00377	48 8b 05 68 02
	00 00		 mov	 rax, QWORD PTR cckdblk+616
  0037e	48 ff c0	 inc	 rax
  00381	48 89 05 68 02
	00 00		 mov	 QWORD PTR cckdblk+616, rax
  00388	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0038d	8b 80 e8 00 00
	00		 mov	 eax, DWORD PTR [rax+232]
  00393	ff c0		 inc	 eax
  00395	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0039a	89 81 e8 00 00
	00		 mov	 DWORD PTR [rcx+232], eax

; 1005 :         cckdblk.stats_cachehits++; cckd->cachehits++;

  003a0	48 8b 05 70 02
	00 00		 mov	 rax, QWORD PTR cckdblk+624
  003a7	48 ff c0	 inc	 rax
  003aa	48 89 05 70 02
	00 00		 mov	 QWORD PTR cckdblk+624, rax
  003b1	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  003b6	8b 80 e0 00 00
	00		 mov	 eax, DWORD PTR [rax+224]
  003bc	ff c0		 inc	 eax
  003be	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  003c3	89 81 e0 00 00
	00		 mov	 DWORD PTR [rcx+224], eax
$LN2@cckd64_rea:

; 1006 : 
; 1007 :         /* if read/write is in progress then wait for it to finish */
; 1008 :         while (cache_getflag(CACHE_DEVBUF, fnd) & CCKD_CACHE_IOBUSY)

  003c9	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  003d0	33 c9		 xor	 ecx, ecx
  003d2	e8 00 00 00 00	 call	 cache_getflag
  003d7	25 00 00 00 60	 and	 eax, 1610612736		; 60000000H
  003dc	85 c0		 test	 eax, eax
  003de	0f 84 53 01 00
	00		 je	 $LN3@cckd64_rea

; 1009 :         {
; 1010 :             cckdblk.stats_iowaits++;

  003e4	48 8b 05 90 02
	00 00		 mov	 rax, QWORD PTR cckdblk+656
  003eb	48 ff c0	 inc	 rax
  003ee	48 89 05 90 02
	00 00		 mov	 QWORD PTR cckdblk+656, rax

; 1011 :             CCKD_TRACE( "%d rdtrk[%d] %d waiting for %s", ra, fnd, trk,

  003f5	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  003fc	33 c9		 xor	 ecx, ecx
  003fe	e8 00 00 00 00	 call	 cache_getflag
  00403	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00408	85 c0		 test	 eax, eax
  0040a	74 11		 je	 SHORT $LN31@cckd64_rea
  0040c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170002
  00413	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv227[rsp], rax
  0041b	eb 0f		 jmp	 SHORT $LN32@cckd64_rea
$LN31@cckd64_rea:
  0041d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170003
  00424	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv227[rsp], rax
$LN32@cckd64_rea:
  0042c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv227[rsp]
  00434	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00439	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00440	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00444	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR fnd$[rsp]
  0044b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0044f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  00456	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0045a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170004
  00461	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00469	ba f5 03 00 00	 mov	 edx, 1013		; 000003f5H
  0046e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170005
  00475	e8 00 00 00 00	 call	 cckd_trace

; 1012 :                         cache_getflag(CACHE_DEVBUF, fnd) & CCKD_CACHE_READING ?
; 1013 :                         "read" : "write");
; 1014 :             cache_setflag (CACHE_DEVBUF, fnd, ~0, CCKD_CACHE_IOWAIT);

  0047a	41 b9 00 00 00
	10		 mov	 r9d, 268435456		; 10000000H
  00480	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  00486	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  0048d	33 c9		 xor	 ecx, ecx
  0048f	e8 00 00 00 00	 call	 cache_setflag

; 1015 :             cckd->cckdwaiters++;

  00494	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00499	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0049c	ff c0		 inc	 eax
  0049e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  004a3	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1016 :             wait_condition (&cckd->cckdiocond, &cckd->cckdiolock);

  004a6	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  004ab	48 83 c0 18	 add	 rax, 24
  004af	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  004b4	48 83 c1 20	 add	 rcx, 32			; 00000020H
  004b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170006
  004bf	48 8b d0	 mov	 rdx, rax
  004c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 1017 :             cckd->cckdwaiters--;

  004c8	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  004cd	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  004d0	ff c8		 dec	 eax
  004d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  004d7	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 1018 :             cache_setflag (CACHE_DEVBUF, fnd, ~CCKD_CACHE_IOWAIT, 0);

  004da	45 33 c9	 xor	 r9d, r9d
  004dd	41 b8 ff ff ff
	ef		 mov	 r8d, -268435457		; efffffffH
  004e3	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR fnd$[rsp]
  004ea	33 c9		 xor	 ecx, ecx
  004ec	e8 00 00 00 00	 call	 cache_setflag

; 1019 :             CCKD_TRACE( "%d rdtrk[%d] %d io wait complete",

  004f1	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  004f8	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  004fc	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR fnd$[rsp]
  00503	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00507	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  0050e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00512	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170007
  00519	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00521	ba fc 03 00 00	 mov	 edx, 1020		; 000003fcH
  00526	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170008
  0052d	e8 00 00 00 00	 call	 cckd_trace

; 1020 :                         ra, fnd, trk);
; 1021 :         }

  00532	e9 92 fe ff ff	 jmp	 $LN2@cckd64_rea
$LN3@cckd64_rea:

; 1022 : 
; 1023 :         release_lock (&cckd->cckdiolock);

  00537	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0053c	48 83 c0 18	 add	 rax, 24
  00540	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170009
  00547	48 8b c8	 mov	 rcx, rax
  0054a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1024 : 
; 1025 :         /* Asynchrously schedule readaheads */
; 1026 :         if (curtrk > 0 && trk > curtrk && trk <= curtrk + 2)

  00550	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR curtrk$[rsp], 0
  00558	7e 37		 jle	 SHORT $LN15@cckd64_rea
  0055a	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR curtrk$[rsp]
  00561	39 84 24 e8 00
	00 00		 cmp	 DWORD PTR trk$[rsp], eax
  00568	7e 27		 jle	 SHORT $LN15@cckd64_rea
  0056a	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR curtrk$[rsp]
  00571	83 c0 02	 add	 eax, 2
  00574	39 84 24 e8 00
	00 00		 cmp	 DWORD PTR trk$[rsp], eax
  0057b	7f 14		 jg	 SHORT $LN15@cckd64_rea

; 1027 :             cckd_readahead (dev, trk);

  0057d	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  00584	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0058c	e8 00 00 00 00	 call	 cckd_readahead
$LN15@cckd64_rea:

; 1028 : 
; 1029 :         return fnd;

  00591	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR fnd$[rsp]
  00598	e9 53 06 00 00	 jmp	 $LN1@cckd64_rea
$LN11@cckd64_rea:

; 1030 : 
; 1031 :     } /* cache hit */
; 1032 : 
; 1033 :     CCKD_TRACE( "%d rdtrk[%d] %d cache miss", ra, lru, trk);

  0059d	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  005a4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  005a8	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
  005ac	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005b0	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  005b7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005bb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170011
  005c2	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  005ca	ba 09 04 00 00	 mov	 edx, 1033		; 00000409H
  005cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170012
  005d6	e8 00 00 00 00	 call	 cckd_trace

; 1034 : 
; 1035 :     /* If no cache entry was stolen, then flush all outstanding writes.
; 1036 :        This requires us to release our locks.  cache_wait should be
; 1037 :        called with only the cache_lock held.  Fortunately, cache waits
; 1038 :        occur very rarely. */
; 1039 :     if (lru < 0) /* No available entry to be stolen */

  005db	83 7c 24 70 00	 cmp	 DWORD PTR lru$[rsp], 0
  005e0	0f 8d c2 00 00
	00		 jge	 $LN16@cckd64_rea

; 1040 :     {
; 1041 :         CCKD_TRACE( "%d rdtrk[%d] %d no available cache entry",

  005e6	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  005ed	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  005f1	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
  005f5	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005f9	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  00600	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00604	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170014
  0060b	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00613	ba 12 04 00 00	 mov	 edx, 1042		; 00000412H
  00618	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170015
  0061f	e8 00 00 00 00	 call	 cckd_trace

; 1042 :                     ra, lru, trk);
; 1043 :         cache_unlock (CACHE_DEVBUF);

  00624	33 c9		 xor	 ecx, ecx
  00626	e8 00 00 00 00	 call	 cache_unlock

; 1044 :         if (!ra) release_lock (&cckd->cckdiolock);

  0062b	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  00633	75 19		 jne	 SHORT $LN17@cckd64_rea
  00635	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0063a	48 83 c0 18	 add	 rax, 24
  0063e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170017
  00645	48 8b c8	 mov	 rcx, rax
  00648	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN17@cckd64_rea:

; 1045 :         cckd64_flush_cache_all();

  0064e	e8 00 00 00 00	 call	 cckd64_flush_cache_all

; 1046 :         cache_lock (CACHE_DEVBUF);

  00653	33 c9		 xor	 ecx, ecx
  00655	e8 00 00 00 00	 call	 cache_lock

; 1047 :         cckdblk.stats_cachewaits++;

  0065a	48 8b 05 98 02
	00 00		 mov	 rax, QWORD PTR cckdblk+664
  00661	48 ff c0	 inc	 rax
  00664	48 89 05 98 02
	00 00		 mov	 QWORD PTR cckdblk+664, rax

; 1048 :         cache_wait (CACHE_DEVBUF);

  0066b	33 c9		 xor	 ecx, ecx
  0066d	e8 00 00 00 00	 call	 cache_wait

; 1049 :         if (!ra)

  00672	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  0067a	75 27		 jne	 SHORT $LN18@cckd64_rea

; 1050 :         {
; 1051 :             cache_unlock (CACHE_DEVBUF);

  0067c	33 c9		 xor	 ecx, ecx
  0067e	e8 00 00 00 00	 call	 cache_unlock

; 1052 :             obtain_lock (&cckd->cckdiolock);

  00683	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00688	48 83 c0 18	 add	 rax, 24
  0068c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170019
  00693	48 8b c8	 mov	 rcx, rax
  00696	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1053 :             cache_lock (CACHE_DEVBUF);

  0069c	33 c9		 xor	 ecx, ecx
  0069e	e8 00 00 00 00	 call	 cache_lock
$LN18@cckd64_rea:

; 1054 :         }
; 1055 :         goto cckd_read_trk_retry;

  006a3	e9 e7 fa ff ff	 jmp	 $cckd_read_trk_retry$36
$LN16@cckd64_rea:
$LN6@cckd64_rea:

; 1056 :     }
; 1057 : 
; 1058 :     CCKD_CACHE_GETKEY(lru, devnum, oldtrk);

  006a8	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  006ac	33 c9		 xor	 ecx, ecx
  006ae	e8 00 00 00 00	 call	 cache_getkey
  006b3	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  006b7	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  006bd	66 89 84 24 94
	00 00 00	 mov	 WORD PTR devnum$[rsp], ax
  006c5	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  006c9	33 c9		 xor	 ecx, ecx
  006cb	e8 00 00 00 00	 call	 cache_getkey
  006d0	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  006d5	48 23 c1	 and	 rax, rcx
  006d8	89 84 24 a0 00
	00 00		 mov	 DWORD PTR oldtrk$[rsp], eax
  006df	33 c0		 xor	 eax, eax
  006e1	85 c0		 test	 eax, eax
  006e3	75 c3		 jne	 SHORT $LN6@cckd64_rea

; 1059 :     if (devnum != 0)

  006e5	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  006ed	85 c0		 test	 eax, eax
  006ef	0f 84 92 00 00
	00		 je	 $LN19@cckd64_rea

; 1060 :     {
; 1061 :         CCKD_TRACE( "%d rdtrk[%d] %d dropping %4.4X:%d from cache",

  006f5	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  006fd	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR oldtrk$[rsp]
  00704	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00708	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0070c	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00713	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00717	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
  0071b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0071f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  00726	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0072a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170021
  00731	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00739	ba 26 04 00 00	 mov	 edx, 1062		; 00000426H
  0073e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170022
  00745	e8 00 00 00 00	 call	 cckd_trace

; 1062 :                     ra, lru, trk, devnum, oldtrk);
; 1063 :         if (!(cache_getflag(CACHE_DEVBUF, lru) & CCKD_CACHE_USED))

  0074a	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  0074e	33 c9		 xor	 ecx, ecx
  00750	e8 00 00 00 00	 call	 cache_getflag
  00755	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  0075a	85 c0		 test	 eax, eax
  0075c	75 29		 jne	 SHORT $LN20@cckd64_rea

; 1064 :         {
; 1065 :             cckdblk.stats_readaheadmisses++;  cckd->misses++;

  0075e	48 8b 05 88 02
	00 00		 mov	 rax, QWORD PTR cckdblk+648
  00765	48 ff c0	 inc	 rax
  00768	48 89 05 88 02
	00 00		 mov	 QWORD PTR cckdblk+648, rax
  0076f	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00774	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [rax+236]
  0077a	ff c0		 inc	 eax
  0077c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00781	89 81 ec 00 00
	00		 mov	 DWORD PTR [rcx+236], eax
$LN20@cckd64_rea:
$LN19@cckd64_rea:

; 1066 :         }
; 1067 :     }
; 1068 : 
; 1069 :     /* Initialize the entry */
; 1070 :     cache_setkey(CACHE_DEVBUF, lru, CCKD_CACHE_SETKEY(dev->devnum, trk));

  00787	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0078f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00793	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  00797	48 63 8c 24 e8
	00 00 00	 movsxd	 rcx, DWORD PTR trk$[rsp]
  0079f	48 0b c1	 or	 rax, rcx
  007a2	4c 8b c0	 mov	 r8, rax
  007a5	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  007a9	33 c9		 xor	 ecx, ecx
  007ab	e8 00 00 00 00	 call	 cache_setkey

; 1071 :     cache_setflag(CACHE_DEVBUF, lru, 0, CCKD_CACHE_READING);

  007b0	41 b9 00 00 00
	40		 mov	 r9d, 1073741824		; 40000000H
  007b6	45 33 c0	 xor	 r8d, r8d
  007b9	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  007bd	33 c9		 xor	 ecx, ecx
  007bf	e8 00 00 00 00	 call	 cache_setflag

; 1072 :     cache_setage(CACHE_DEVBUF, lru);

  007c4	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  007c8	33 c9		 xor	 ecx, ecx
  007ca	e8 00 00 00 00	 call	 cache_setage

; 1073 :     cache_setval(CACHE_DEVBUF, lru, 0);

  007cf	45 33 c0	 xor	 r8d, r8d
  007d2	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  007d6	33 c9		 xor	 ecx, ecx
  007d8	e8 00 00 00 00	 call	 cache_setval

; 1074 :     if (!ra)

  007dd	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  007e5	75 51		 jne	 SHORT $LN21@cckd64_rea

; 1075 :     {
; 1076 :         cckdblk.stats_switches++; cckd->switches++;

  007e7	48 8b 05 68 02
	00 00		 mov	 rax, QWORD PTR cckdblk+616
  007ee	48 ff c0	 inc	 rax
  007f1	48 89 05 68 02
	00 00		 mov	 QWORD PTR cckdblk+616, rax
  007f8	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  007fd	8b 80 e8 00 00
	00		 mov	 eax, DWORD PTR [rax+232]
  00803	ff c0		 inc	 eax
  00805	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0080a	89 81 e8 00 00
	00		 mov	 DWORD PTR [rcx+232], eax

; 1077 :         cckdblk.stats_cachemisses++;

  00810	48 8b 05 78 02
	00 00		 mov	 rax, QWORD PTR cckdblk+632
  00817	48 ff c0	 inc	 rax
  0081a	48 89 05 78 02
	00 00		 mov	 QWORD PTR cckdblk+632, rax

; 1078 :         cache_setflag(CACHE_DEVBUF, lru, ~0, CCKD_CACHE_ACTIVE|CCKD_CACHE_USED);

  00821	41 b9 00 00 80
	80		 mov	 r9d, -2139095040	; 80800000H
  00827	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  0082d	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  00831	33 c9		 xor	 ecx, ecx
  00833	e8 00 00 00 00	 call	 cache_setflag
$LN21@cckd64_rea:

; 1079 :     }
; 1080 :     cache_setflag(CACHE_DEVBUF, lru, ~CACHE_TYPE,

  00838	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  0083d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00840	83 e0 01	 and	 eax, 1
  00843	85 c0		 test	 eax, eax
  00845	74 0d		 je	 SHORT $LN33@cckd64_rea
  00847	c7 84 24 98 00
	00 00 42 00 00
	00		 mov	 DWORD PTR tv400[rsp], 66 ; 00000042H
  00852	eb 0b		 jmp	 SHORT $LN34@cckd64_rea
$LN33@cckd64_rea:
  00854	c7 84 24 98 00
	00 00 41 00 00
	00		 mov	 DWORD PTR tv400[rsp], 65 ; 00000041H
$LN34@cckd64_rea:
  0085f	44 8b 8c 24 98
	00 00 00	 mov	 r9d, DWORD PTR tv400[rsp]
  00867	41 b8 00 ff ff
	ff		 mov	 r8d, -256		; ffffff00H
  0086d	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  00871	33 c9		 xor	 ecx, ecx
  00873	e8 00 00 00 00	 call	 cache_setflag

; 1081 :                   cckd->ckddasd ? DEVBUF_TYPE_CCKD : DEVBUF_TYPE_CFBA);
; 1082 :     buf = cache_getbuf(CACHE_DEVBUF, lru, maxlen);

  00878	44 8b 84 24 9c
	00 00 00	 mov	 r8d, DWORD PTR maxlen$[rsp]
  00880	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  00884	33 c9		 xor	 ecx, ecx
  00886	e8 00 00 00 00	 call	 cache_getbuf
  0088b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 1083 : 
; 1084 :     CCKD_TRACE( "%d rdtrk[%d] %d buf %p len %d",

  00893	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  00897	33 c9		 xor	 ecx, ecx
  00899	e8 00 00 00 00	 call	 cache_getlen
  0089e	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  008a2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  008aa	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  008af	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  008b6	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  008ba	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
  008be	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  008c2	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  008c9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  008cd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170025
  008d4	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  008dc	ba 3d 04 00 00	 mov	 edx, 1085		; 0000043dH
  008e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170026
  008e8	e8 00 00 00 00	 call	 cckd_trace

; 1085 :                 ra, lru, trk, buf, cache_getlen(CACHE_DEVBUF, lru));
; 1086 : 
; 1087 :     cache_unlock (CACHE_DEVBUF);

  008ed	33 c9		 xor	 ecx, ecx
  008ef	e8 00 00 00 00	 call	 cache_unlock

; 1088 : 
; 1089 :     if (!ra) release_lock (&cckd->cckdiolock);

  008f4	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  008fc	75 19		 jne	 SHORT $LN22@cckd64_rea
  008fe	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00903	48 83 c0 18	 add	 rax, 24
  00907	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170028
  0090e	48 8b c8	 mov	 rcx, rax
  00911	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN22@cckd64_rea:

; 1090 : 
; 1091 :     /* Asynchronously schedule readaheads */
; 1092 :     if (!ra && curtrk > 0 && trk > curtrk && trk <= curtrk + 2)

  00917	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  0091f	75 41		 jne	 SHORT $LN23@cckd64_rea
  00921	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR curtrk$[rsp], 0
  00929	7e 37		 jle	 SHORT $LN23@cckd64_rea
  0092b	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR curtrk$[rsp]
  00932	39 84 24 e8 00
	00 00		 cmp	 DWORD PTR trk$[rsp], eax
  00939	7e 27		 jle	 SHORT $LN23@cckd64_rea
  0093b	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR curtrk$[rsp]
  00942	83 c0 02	 add	 eax, 2
  00945	39 84 24 e8 00
	00 00		 cmp	 DWORD PTR trk$[rsp], eax
  0094c	7f 14		 jg	 SHORT $LN23@cckd64_rea

; 1093 :         cckd_readahead (dev, trk);

  0094e	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  00955	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0095d	e8 00 00 00 00	 call	 cckd_readahead
$LN23@cckd64_rea:

; 1094 : 
; 1095 :     /* Clear the buffer if batch mode */
; 1096 :     if (dev->batch) memset(buf, 0, maxlen);

  00962	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0096a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00970	c1 e8 0a	 shr	 eax, 10
  00973	83 e0 01	 and	 eax, 1
  00976	85 c0		 test	 eax, eax
  00978	74 24		 je	 SHORT $LN24@cckd64_rea
  0097a	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR maxlen$[rsp]
  00982	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv438[rsp], rax
  0098a	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  00992	33 c0		 xor	 eax, eax
  00994	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv438[rsp]
  0099c	f3 aa		 rep stosb
$LN24@cckd64_rea:

; 1097 : 
; 1098 :     /* Read the track image */
; 1099 :     obtain_lock( &cckd->filelock );

  0099e	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  009a3	48 83 c0 10	 add	 rax, 16
  009a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170031
  009ae	48 8b c8	 mov	 rcx, rax
  009b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1100 :     {
; 1101 :         len = cckd64_read_trkimg (dev, buf, trk, unitstat);

  009b7	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  009bf	44 8b 84 24 e8
	00 00 00	 mov	 r8d, DWORD PTR trk$[rsp]
  009c7	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  009cf	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009d7	e8 00 00 00 00	 call	 cckd64_read_trkimg
  009dc	89 84 24 a4 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 1102 :     }
; 1103 :     release_lock( &cckd->filelock );

  009e3	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  009e8	48 83 c0 10	 add	 rax, 16
  009ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170032
  009f3	48 8b c8	 mov	 rcx, rax
  009f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1104 : 
; 1105 :     cache_setval (CACHE_DEVBUF, lru, len);

  009fc	44 8b 84 24 a4
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00a04	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  00a08	33 c9		 xor	 ecx, ecx
  00a0a	e8 00 00 00 00	 call	 cache_setval

; 1106 : 
; 1107 :     obtain_lock (&cckd->cckdiolock);

  00a0f	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00a14	48 83 c0 18	 add	 rax, 24
  00a18	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170033
  00a1f	48 8b c8	 mov	 rcx, rax
  00a22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1108 : 
; 1109 :     /* Turn off the READING bit */
; 1110 :     cache_lock (CACHE_DEVBUF);

  00a28	33 c9		 xor	 ecx, ecx
  00a2a	e8 00 00 00 00	 call	 cache_lock

; 1111 :     flag = cache_setflag(CACHE_DEVBUF, lru, ~CCKD_CACHE_READING, 0);

  00a2f	45 33 c9	 xor	 r9d, r9d
  00a32	41 b8 ff ff ff
	bf		 mov	 r8d, -1073741825	; bfffffffH
  00a38	8b 54 24 70	 mov	 edx, DWORD PTR lru$[rsp]
  00a3c	33 c9		 xor	 ecx, ecx
  00a3e	e8 00 00 00 00	 call	 cache_setflag
  00a43	89 84 24 a8 00
	00 00		 mov	 DWORD PTR flag$[rsp], eax

; 1112 :     cache_unlock (CACHE_DEVBUF);

  00a4a	33 c9		 xor	 ecx, ecx
  00a4c	e8 00 00 00 00	 call	 cache_unlock

; 1113 : 
; 1114 :     /* Wakeup other thread waiting for this read */
; 1115 :     if (cckd->cckdwaiters && (flag & CCKD_CACHE_IOWAIT))

  00a51	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00a56	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00a5a	74 67		 je	 SHORT $LN25@cckd64_rea
  00a5c	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR flag$[rsp]
  00a63	25 00 00 00 10	 and	 eax, 268435456		; 10000000H
  00a68	85 c0		 test	 eax, eax
  00a6a	74 57		 je	 SHORT $LN25@cckd64_rea

; 1116 :     {   CCKD_TRACE( "%d rdtrk[%d] %d signalling read complete",

  00a6c	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00a73	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00a77	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
  00a7b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00a7f	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  00a86	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00a8a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170035
  00a91	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00a99	ba 5d 04 00 00	 mov	 edx, 1117		; 0000045dH
  00a9e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170036
  00aa5	e8 00 00 00 00	 call	 cckd_trace

; 1117 :                     ra, lru, trk);
; 1118 :         broadcast_condition (&cckd->cckdiocond);

  00aaa	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00aaf	48 83 c0 20	 add	 rax, 32			; 00000020H
  00ab3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170037
  00aba	48 8b c8	 mov	 rcx, rax
  00abd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN25@cckd64_rea:

; 1119 :     }
; 1120 : 
; 1121 :     release_lock (&cckd->cckdiolock);

  00ac3	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00ac8	48 83 c0 18	 add	 rax, 24
  00acc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170038
  00ad3	48 8b c8	 mov	 rcx, rax
  00ad6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1122 : 
; 1123 :     if (ra)

  00adc	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR ra$[rsp], 0
  00ae4	74 29		 je	 SHORT $LN26@cckd64_rea

; 1124 :     {
; 1125 :         cckdblk.stats_readaheads++; cckd->readaheads++;

  00ae6	48 8b 05 80 02
	00 00		 mov	 rax, QWORD PTR cckdblk+640
  00aed	48 ff c0	 inc	 rax
  00af0	48 89 05 80 02
	00 00		 mov	 QWORD PTR cckdblk+640, rax
  00af7	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd$[rsp]
  00afc	8b 80 e4 00 00
	00		 mov	 eax, DWORD PTR [rax+228]
  00b02	ff c0		 inc	 eax
  00b04	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00b09	89 81 e4 00 00
	00		 mov	 DWORD PTR [rcx+228], eax
$LN26@cckd64_rea:

; 1126 :     }
; 1127 : 
; 1128 :     CCKD_TRACE( "%d rdtrk[%d] %d complete buf %p:%2.2x%2.2x%2.2x%2.2x%2.2x",

  00b0f	b8 01 00 00 00	 mov	 eax, 1
  00b14	48 6b c0 04	 imul	 rax, rax, 4
  00b18	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00b20	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b24	b9 01 00 00 00	 mov	 ecx, 1
  00b29	48 6b c9 03	 imul	 rcx, rcx, 3
  00b2d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00b35	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00b39	ba 01 00 00 00	 mov	 edx, 1
  00b3e	48 6b d2 02	 imul	 rdx, rdx, 2
  00b42	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  00b4a	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  00b4e	bf 01 00 00 00	 mov	 edi, 1
  00b53	48 6b ff 01	 imul	 rdi, rdi, 1
  00b57	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR buf$[rsp]
  00b5f	41 0f b6 3c 38	 movzx	 edi, BYTE PTR [r8+rdi]
  00b64	41 b8 01 00 00
	00		 mov	 r8d, 1
  00b6a	4d 6b c0 00	 imul	 r8, r8, 0
  00b6e	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  00b76	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00b7b	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00b7f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00b83	89 54 24 50	 mov	 DWORD PTR [rsp+80], edx
  00b87	89 7c 24 48	 mov	 DWORD PTR [rsp+72], edi
  00b8b	44 89 44 24 40	 mov	 DWORD PTR [rsp+64], r8d
  00b90	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  00b98	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00b9d	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00ba4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00ba8	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
  00bac	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00bb0	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR ra$[rsp]
  00bb7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00bbb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170040
  00bc2	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00bca	ba 69 04 00 00	 mov	 edx, 1129		; 00000469H
  00bcf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170041
  00bd6	e8 00 00 00 00	 call	 cckd_trace

; 1129 :                 ra, lru, trk, buf, buf[0], buf[1], buf[2], buf[3], buf[4]);
; 1130 : 
; 1131 :     if (cache_busy_percent(CACHE_DEVBUF) > 80) cckd64_flush_cache_all();

  00bdb	33 c9		 xor	 ecx, ecx
  00bdd	e8 00 00 00 00	 call	 cache_busy_percent
  00be2	83 f8 50	 cmp	 eax, 80			; 00000050H
  00be5	7e 05		 jle	 SHORT $LN27@cckd64_rea
  00be7	e8 00 00 00 00	 call	 cckd64_flush_cache_all
$LN27@cckd64_rea:

; 1132 : 
; 1133 :     return lru;

  00bec	8b 44 24 70	 mov	 eax, DWORD PTR lru$[rsp]
$LN1@cckd64_rea:

; 1134 : 
; 1135 : } /* end function cckd64_read_trk */

  00bf0	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00bf7	5f		 pop	 rdi
  00bf8	c3		 ret	 0
cckd64_read_trk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
L1idx$ = 32
sfx$ = 36
l2x$ = 40
cckd$ = 48
rc$ = 56
l2$ = 64
__$ArrayPad$ = 80
dev$ = 112
cfba64_used PROC

; 895  : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 896  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 897  : int             rc;                     /* Return code               */
; 898  : int             L1idx, l2x;             /* Lookup table indexes      */
; 899  : int             sfx;                    /* Shadow file suffix        */
; 900  : CCKD64_L2ENT    l2;                     /* Copied level 2 entry      */
; 901  : 
; 902  :     if (!dev->cckd64)

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00024	24 01		 and	 al, 1
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	75 0f		 jne	 SHORT $LN10@cfba64_use

; 903  :         return cfba_used( dev );

  0002d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00032	e8 00 00 00 00	 call	 cfba_used
  00037	e9 38 01 00 00	 jmp	 $LN1@cfba64_use
$LN10@cfba64_use:

; 904  : 
; 905  :     cckd = dev->cckd_ext;

  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00041	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00048	48 89 44 24 30	 mov	 QWORD PTR cckd$[rsp], rax

; 906  : 
; 907  :     obtain_lock( &cckd->filelock );

  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00052	48 83 c0 10	 add	 rax, 16
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169948
  0005d	48 8b c8	 mov	 rcx, rax
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 908  :     {
; 909  :         /* Find the last used level 1 table entry */
; 910  :         for (L1idx = cckd->cdevhdr[0].num_L1tab - 1; L1idx > 0; L1idx--)

  00066	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0006b	48 6b c0 00	 imul	 rax, rax, 0
  0006f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00074	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  0007b	ff c8		 dec	 eax
  0007d	89 44 24 20	 mov	 DWORD PTR L1idx$[rsp], eax
  00081	eb 0a		 jmp	 SHORT $LN4@cfba64_use
$LN2@cfba64_use:
  00083	8b 44 24 20	 mov	 eax, DWORD PTR L1idx$[rsp]
  00087	ff c8		 dec	 eax
  00089	89 44 24 20	 mov	 DWORD PTR L1idx$[rsp], eax
$LN4@cfba64_use:
  0008d	83 7c 24 20 00	 cmp	 DWORD PTR L1idx$[rsp], 0
  00092	7e 5f		 jle	 SHORT $LN3@cfba64_use

; 911  :         {
; 912  :             sfx = cckd->sfn;

  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00099	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0009c	89 44 24 24	 mov	 DWORD PTR sfx$[rsp], eax
$LN5@cfba64_use:

; 913  :             while (cckd->L1tab[sfx][L1idx] == CCKD64_MAXSIZE && sfx > 0) sfx--;

  000a0	48 63 44 24 24	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000a5	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000aa	48 8b 54 24 30	 mov	 rdx, QWORD PTR cckd$[rsp]
  000af	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000b7	48 83 3c c8 ff	 cmp	 QWORD PTR [rax+rcx*8], -1
  000bc	75 13		 jne	 SHORT $LN6@cfba64_use
  000be	83 7c 24 24 00	 cmp	 DWORD PTR sfx$[rsp], 0
  000c3	7e 0c		 jle	 SHORT $LN6@cfba64_use
  000c5	8b 44 24 24	 mov	 eax, DWORD PTR sfx$[rsp]
  000c9	ff c8		 dec	 eax
  000cb	89 44 24 24	 mov	 DWORD PTR sfx$[rsp], eax
  000cf	eb cf		 jmp	 SHORT $LN5@cfba64_use
$LN6@cfba64_use:

; 914  :             if (cckd->L1tab[sfx][L1idx]) break;

  000d1	48 63 44 24 24	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000d6	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000db	48 8b 54 24 30	 mov	 rdx, QWORD PTR cckd$[rsp]
  000e0	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000e8	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  000ed	74 02		 je	 SHORT $LN11@cfba64_use
  000ef	eb 02		 jmp	 SHORT $LN3@cfba64_use
$LN11@cfba64_use:

; 915  :         }

  000f1	eb 90		 jmp	 SHORT $LN2@cfba64_use
$LN3@cfba64_use:

; 916  : 
; 917  :         /* Find the last used level 2 table entry */
; 918  :         for (l2x = 255; l2x >= 0; l2x--)

  000f3	c7 44 24 28 ff
	00 00 00	 mov	 DWORD PTR l2x$[rsp], 255 ; 000000ffH
  000fb	eb 0a		 jmp	 SHORT $LN9@cfba64_use
$LN7@cfba64_use:
  000fd	8b 44 24 28	 mov	 eax, DWORD PTR l2x$[rsp]
  00101	ff c8		 dec	 eax
  00103	89 44 24 28	 mov	 DWORD PTR l2x$[rsp], eax
$LN9@cfba64_use:
  00107	83 7c 24 28 00	 cmp	 DWORD PTR l2x$[rsp], 0
  0010c	7c 35		 jl	 SHORT $LN8@cfba64_use

; 919  :         {
; 920  :             rc = cckd64_read_l2ent (dev, &l2, L1idx * 256 + l2x);

  0010e	69 44 24 20 00
	01 00 00	 imul	 eax, DWORD PTR L1idx$[rsp], 256 ; 00000100H
  00116	03 44 24 28	 add	 eax, DWORD PTR l2x$[rsp]
  0011a	44 8b c0	 mov	 r8d, eax
  0011d	48 8d 54 24 40	 lea	 rdx, QWORD PTR l2$[rsp]
  00122	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00127	e8 00 00 00 00	 call	 cckd64_read_l2ent
  0012c	89 44 24 38	 mov	 DWORD PTR rc$[rsp], eax

; 921  :             if (rc < 0 || l2.L2_trkoff != 0) break;

  00130	83 7c 24 38 00	 cmp	 DWORD PTR rc$[rsp], 0
  00135	7c 08		 jl	 SHORT $LN13@cfba64_use
  00137	48 83 7c 24 40
	00		 cmp	 QWORD PTR l2$[rsp], 0
  0013d	74 02		 je	 SHORT $LN12@cfba64_use
$LN13@cfba64_use:
  0013f	eb 02		 jmp	 SHORT $LN8@cfba64_use
$LN12@cfba64_use:

; 922  :         }

  00141	eb ba		 jmp	 SHORT $LN7@cfba64_use
$LN8@cfba64_use:

; 923  :     }
; 924  :     release_lock( &cckd->filelock );

  00143	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00148	48 83 c0 10	 add	 rax, 16
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169952
  00153	48 8b c8	 mov	 rcx, rax
  00156	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 925  : 
; 926  :     return (L1idx * 256 + l2x + CFBA_BLKS_PER_GRP) / CFBA_BLKS_PER_GRP;

  0015c	69 44 24 20 00
	01 00 00	 imul	 eax, DWORD PTR L1idx$[rsp], 256 ; 00000100H
  00164	8b 4c 24 28	 mov	 ecx, DWORD PTR l2x$[rsp]
  00168	8d 44 08 78	 lea	 eax, DWORD PTR [rax+rcx+120]
  0016c	99		 cdq
  0016d	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00172	f7 f9		 idiv	 ecx
$LN1@cfba64_use:

; 927  : }

  00174	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00179	48 33 cc	 xor	 rcx, rsp
  0017c	e8 00 00 00 00	 call	 __security_check_cookie
  00181	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00185	c3		 ret	 0
cfba64_used ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
L1idx$ = 32
sfx$ = 36
l2x$ = 40
cckd$ = 48
rc$ = 56
l2$ = 64
__$ArrayPad$ = 80
dev$ = 112
cckd64_used PROC

; 724  : {

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 725  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 726  : int             rc;                     /* Return code               */
; 727  : int             L1idx, l2x;             /* Lookup table indexes      */
; 728  : int             sfx;                    /* Shadow file suffix        */
; 729  : CCKD64_L2ENT    l2;                     /* Copied level 2 entry      */
; 730  : 
; 731  :     if (!dev->cckd64)

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00024	24 01		 and	 al, 1
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	75 0f		 jne	 SHORT $LN10@cckd64_use

; 732  :         return cckd_used( dev );

  0002d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00032	e8 00 00 00 00	 call	 cckd_used
  00037	e9 43 01 00 00	 jmp	 $LN1@cckd64_use
$LN10@cckd64_use:

; 733  : 
; 734  :     cckd = dev->cckd_ext;

  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00041	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00048	48 89 44 24 30	 mov	 QWORD PTR cckd$[rsp], rax

; 735  : 
; 736  :     obtain_lock( &cckd->filelock );

  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00052	48 83 c0 10	 add	 rax, 16
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169862
  0005d	48 8b c8	 mov	 rcx, rax
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 737  :     {
; 738  :         /* Find the last used level 1 table entry */
; 739  :         for (L1idx = cckd->cdevhdr[0].num_L1tab - 1; L1idx > 0; L1idx--)

  00066	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  0006b	48 6b c0 00	 imul	 rax, rax, 0
  0006f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00074	8b 84 01 e4 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+484]
  0007b	ff c8		 dec	 eax
  0007d	89 44 24 20	 mov	 DWORD PTR L1idx$[rsp], eax
  00081	eb 0a		 jmp	 SHORT $LN4@cckd64_use
$LN2@cckd64_use:
  00083	8b 44 24 20	 mov	 eax, DWORD PTR L1idx$[rsp]
  00087	ff c8		 dec	 eax
  00089	89 44 24 20	 mov	 DWORD PTR L1idx$[rsp], eax
$LN4@cckd64_use:
  0008d	83 7c 24 20 00	 cmp	 DWORD PTR L1idx$[rsp], 0
  00092	7e 5f		 jle	 SHORT $LN3@cckd64_use

; 740  :         {
; 741  :             sfx = cckd->sfn;

  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00099	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  0009c	89 44 24 24	 mov	 DWORD PTR sfx$[rsp], eax
$LN5@cckd64_use:

; 742  :             while (cckd->L1tab[sfx][L1idx] == CCKD64_MAXSIZE && sfx > 0) sfx--;

  000a0	48 63 44 24 24	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000a5	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000aa	48 8b 54 24 30	 mov	 rdx, QWORD PTR cckd$[rsp]
  000af	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000b7	48 83 3c c8 ff	 cmp	 QWORD PTR [rax+rcx*8], -1
  000bc	75 13		 jne	 SHORT $LN6@cckd64_use
  000be	83 7c 24 24 00	 cmp	 DWORD PTR sfx$[rsp], 0
  000c3	7e 0c		 jle	 SHORT $LN6@cckd64_use
  000c5	8b 44 24 24	 mov	 eax, DWORD PTR sfx$[rsp]
  000c9	ff c8		 dec	 eax
  000cb	89 44 24 24	 mov	 DWORD PTR sfx$[rsp], eax
  000cf	eb cf		 jmp	 SHORT $LN5@cckd64_use
$LN6@cckd64_use:

; 743  :             if (cckd->L1tab[sfx][L1idx]) break;

  000d1	48 63 44 24 24	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000d6	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR L1idx$[rsp]
  000db	48 8b 54 24 30	 mov	 rdx, QWORD PTR cckd$[rsp]
  000e0	48 8b 84 c2 98
	01 00 00	 mov	 rax, QWORD PTR [rdx+rax*8+408]
  000e8	48 83 3c c8 00	 cmp	 QWORD PTR [rax+rcx*8], 0
  000ed	74 02		 je	 SHORT $LN11@cckd64_use
  000ef	eb 02		 jmp	 SHORT $LN3@cckd64_use
$LN11@cckd64_use:

; 744  :         }

  000f1	eb 90		 jmp	 SHORT $LN2@cckd64_use
$LN3@cckd64_use:

; 745  : 
; 746  :         /* Find the last used level 2 table entry */
; 747  :         for (l2x = 255; l2x >= 0; l2x--)

  000f3	c7 44 24 28 ff
	00 00 00	 mov	 DWORD PTR l2x$[rsp], 255 ; 000000ffH
  000fb	eb 0a		 jmp	 SHORT $LN9@cckd64_use
$LN7@cckd64_use:
  000fd	8b 44 24 28	 mov	 eax, DWORD PTR l2x$[rsp]
  00101	ff c8		 dec	 eax
  00103	89 44 24 28	 mov	 DWORD PTR l2x$[rsp], eax
$LN9@cckd64_use:
  00107	83 7c 24 28 00	 cmp	 DWORD PTR l2x$[rsp], 0
  0010c	7c 35		 jl	 SHORT $LN8@cckd64_use

; 748  :         {
; 749  :             rc = cckd64_read_l2ent (dev, &l2, L1idx * 256 + l2x);

  0010e	69 44 24 20 00
	01 00 00	 imul	 eax, DWORD PTR L1idx$[rsp], 256 ; 00000100H
  00116	03 44 24 28	 add	 eax, DWORD PTR l2x$[rsp]
  0011a	44 8b c0	 mov	 r8d, eax
  0011d	48 8d 54 24 40	 lea	 rdx, QWORD PTR l2$[rsp]
  00122	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00127	e8 00 00 00 00	 call	 cckd64_read_l2ent
  0012c	89 44 24 38	 mov	 DWORD PTR rc$[rsp], eax

; 750  :             if (rc < 0 || l2.L2_trkoff != 0) break;

  00130	83 7c 24 38 00	 cmp	 DWORD PTR rc$[rsp], 0
  00135	7c 08		 jl	 SHORT $LN13@cckd64_use
  00137	48 83 7c 24 40
	00		 cmp	 QWORD PTR l2$[rsp], 0
  0013d	74 02		 je	 SHORT $LN12@cckd64_use
$LN13@cckd64_use:
  0013f	eb 02		 jmp	 SHORT $LN8@cckd64_use
$LN12@cckd64_use:

; 751  :         }

  00141	eb ba		 jmp	 SHORT $LN7@cckd64_use
$LN8@cckd64_use:

; 752  :     }
; 753  :     release_lock( &cckd->filelock );

  00143	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  00148	48 83 c0 10	 add	 rax, 16
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169866
  00153	48 8b c8	 mov	 rcx, rax
  00156	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 754  : 
; 755  :     return (L1idx * 256 + l2x + dev->ckdheads) / dev->ckdheads;

  0015c	69 44 24 20 00
	01 00 00	 imul	 eax, DWORD PTR L1idx$[rsp], 256 ; 00000100H
  00164	03 44 24 28	 add	 eax, DWORD PTR l2x$[rsp]
  00168	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0016d	03 81 c0 12 00
	00		 add	 eax, DWORD PTR [rcx+4800]
  00173	99		 cdq
  00174	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00179	f7 b9 c0 12 00
	00		 idiv	 DWORD PTR [rcx+4800]
$LN1@cckd64_use:

; 756  : }

  0017f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00184	48 33 cc	 xor	 rcx, rsp
  00187	e8 00 00 00 00	 call	 __security_check_cookie
  0018c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00190	c3		 ret	 0
cckd64_used ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
tv130 = 112
tv136 = 116
cckd$ = 120
tv84 = 128
tv90 = 136
dev$ = 160
sfx$ = 168
off$ = 176
cckd64_ftruncate PROC

; 548  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 549  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 550  : 
; 551  :     cckd = dev->cckd_ext;

  00015	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00024	48 89 44 24 78	 mov	 QWORD PTR cckd$[rsp], rax

; 552  : 
; 553  :     CCKD_TRACE( "file[%d] fd[%d] ftruncate, off 0x%16.16"PRIx64,

  00029	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00031	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00039	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  00043	8b 84 81 f0 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+240]
  0004a	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0004e	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  00055	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00059	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169779
  00060	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00068	ba 2a 02 00 00	 mov	 edx, 554		; 0000022aH
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169780
  00074	e8 00 00 00 00	 call	 cckd_trace

; 554  :                 sfx, cckd->fd[sfx], off);
; 555  : 
; 556  :     /* Truncate the file */
; 557  :     if (ftruncate (cckd->fd[sfx], off) < 0)

  00079	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00081	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR off$[rsp]
  00089	48 8b 4c 24 78	 mov	 rcx, QWORD PTR cckd$[rsp]
  0008e	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__chsize_s
  0009b	85 c0		 test	 eax, eax
  0009d	0f 8d 1f 01 00
	00		 jge	 $LN2@cckd64_ftr

; 558  :     {
; 559  :         WRMSG (HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name (dev, sfx),

  000a3	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000ac	74 12		 je	 SHORT $LN4@cckd64_ftr
  000ae	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000ba	89 44 24 70	 mov	 DWORD PTR tv130[rsp], eax
  000be	eb 08		 jmp	 SHORT $LN5@cckd64_ftr
$LN4@cckd64_ftr:
  000c0	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN5@cckd64_ftr:
  000c8	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000d1	74 14		 je	 SHORT $LN6@cckd64_ftr
  000d3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000db	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000df	d1 f8		 sar	 eax, 1
  000e1	89 44 24 74	 mov	 DWORD PTR tv136[rsp], eax
  000e5	eb 08		 jmp	 SHORT $LN7@cckd64_ftr
$LN6@cckd64_ftr:
  000e7	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN7@cckd64_ftr:
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000f5	8b 08		 mov	 ecx, DWORD PTR [rax]
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000fd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
  00105	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  0010c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00114	e8 00 00 00 00	 call	 cckd_sf_name
  00119	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  00121	b9 01 00 00 00	 mov	 ecx, 1
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv84[rsp]
  00134	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00139	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00141	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169782
  0014d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00152	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv90[rsp]
  0015a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0015f	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  00166	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0016a	8b 4c 24 70	 mov	 ecx, DWORD PTR tv130[rsp]
  0016e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00172	8b 4c 24 74	 mov	 ecx, DWORD PTR tv136[rsp]
  00176	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169783
  00181	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169784
  0018d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00192	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00197	41 b9 03 00 00
	00		 mov	 r9d, 3
  0019d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169785
  001a4	ba 30 02 00 00	 mov	 edx, 560		; 00000230H
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169786
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 560  :                     "ftruncate()", off, strerror(errno));
; 561  :         cckd_print_itrace ();

  001b6	e8 00 00 00 00	 call	 cckd_print_itrace

; 562  :         return -1;

  001bb	b8 ff ff ff ff	 mov	 eax, -1
  001c0	eb 02		 jmp	 SHORT $LN1@cckd64_ftr
$LN2@cckd64_ftr:

; 563  :     }
; 564  : 
; 565  :     return 0;

  001c2	33 c0		 xor	 eax, eax
$LN1@cckd64_ftr:

; 566  : 
; 567  : } /* end function cckd64_ftruncate */

  001c4	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001cb	c3		 ret	 0
cckd64_ftruncate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
rc$ = 112
tv132 = 116
tv138 = 120
tv173 = 124
tv179 = 128
tv206 = 132
tv212 = 136
cckd$ = 144
tv86 = 152
tv92 = 160
tv159 = 168
tv165 = 176
tv198 = 184
buf$1 = 192
__$ArrayPad$ = 320
dev$ = 352
sfx$ = 360
off$ = 368
buf$ = 376
len$ = 384
cckd64_write PROC

; 501  : {

$LN19:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 502  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 503  : int             rc = 0;                 /* Return code               */

  0002c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 504  : 
; 505  :     cckd = dev->cckd_ext;

  00034	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00043	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 506  : 
; 507  :     CCKD_TRACE( "file[%d] fd[%d] write, off 0x%16.16"PRIx64" len %d",

  0004b	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00053	8b 8c 24 80 01
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  0005a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0005e	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00066	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00073	8b 84 81 f0 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+240]
  0007a	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0007e	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  00085	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00089	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169749
  00090	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00098	ba fc 01 00 00	 mov	 edx, 508		; 000001fcH
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169750
  000a4	e8 00 00 00 00	 call	 cckd_trace

; 508  :                 sfx, cckd->fd[ sfx ], off, len );
; 509  : 
; 510  :     /* Seek to specified offset */
; 511  :     if (lseek( cckd->fd[ sfx ], off, SEEK_SET ) < 0)

  000a9	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000b1	45 33 c0	 xor	 r8d, r8d
  000b4	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR off$[rsp]
  000bc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  000c4	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  000d1	48 85 c0	 test	 rax, rax
  000d4	0f 8d 22 01 00
	00		 jge	 $LN2@cckd64_wri

; 512  :     {
; 513  :         // "%1d:%04X CCKD file[%d] %s: error in function %s at offset 0x%16.16"PRIX64": %s"
; 514  :         WRMSG( HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name( dev, sfx ),

  000da	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000e3	74 12		 je	 SHORT $LN7@cckd64_wri
  000e5	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ed	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000f1	89 44 24 74	 mov	 DWORD PTR tv132[rsp], eax
  000f5	eb 08		 jmp	 SHORT $LN8@cckd64_wri
$LN7@cckd64_wri:
  000f7	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv132[rsp], 0
$LN8@cckd64_wri:
  000ff	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00108	74 14		 je	 SHORT $LN9@cckd64_wri
  0010a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00112	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00116	d1 f8		 sar	 eax, 1
  00118	89 44 24 78	 mov	 DWORD PTR tv138[rsp], eax
  0011c	eb 08		 jmp	 SHORT $LN10@cckd64_wri
$LN9@cckd64_wri:
  0011e	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN10@cckd64_wri:
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0012c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00134	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv86[rsp], rax
  0013c	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  00143	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0014b	e8 00 00 00 00	 call	 cckd_sf_name
  00150	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv92[rsp], rax
  00158	b9 01 00 00 00	 mov	 ecx, 1
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00163	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv86[rsp]
  0016b	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00170	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00178	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0017d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169752
  00184	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00189	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv92[rsp]
  00191	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00196	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  0019d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001a1	8b 4c 24 74	 mov	 ecx, DWORD PTR tv132[rsp]
  001a5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001a9	8b 4c 24 78	 mov	 ecx, DWORD PTR tv138[rsp]
  001ad	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169753
  001b8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169754
  001c4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ce	41 b9 03 00 00
	00		 mov	 r9d, 3
  001d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169755
  001db	ba 03 02 00 00	 mov	 edx, 515		; 00000203H
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169756
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 515  :             "lseek()", off, strerror( errno ));
; 516  :         cckd_print_itrace();

  001ed	e8 00 00 00 00	 call	 cckd_print_itrace

; 517  :         return -1;

  001f2	b8 ff ff ff ff	 mov	 eax, -1
  001f7	e9 b7 02 00 00	 jmp	 $LN1@cckd64_wri
$LN2@cckd64_wri:

; 518  :     }
; 519  : 
; 520  :     /* Write the data */
; 521  :     rc = write( cckd->fd[ sfx ], buf, len );

  001fc	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00204	44 8b 84 24 80
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0020c	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00214	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0021c	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  00223	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00229	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 522  :     if (rc < (int)len)

  0022d	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00234	39 44 24 70	 cmp	 DWORD PTR rc$[rsp], eax
  00238	0f 8d 71 02 00
	00		 jge	 $LN3@cckd64_wri

; 523  :     {
; 524  :         if (rc < 0)

  0023e	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00243	0f 8d 21 01 00
	00		 jge	 $LN4@cckd64_wri

; 525  :             // "%1d:%04X CCKD file[%d] %s: error in function %s at offset 0x%16.16"PRIX64": %s"
; 526  :             WRMSG( HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name( dev, sfx ),

  00249	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00252	74 12		 je	 SHORT $LN11@cckd64_wri
  00254	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0025c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00260	89 44 24 7c	 mov	 DWORD PTR tv173[rsp], eax
  00264	eb 08		 jmp	 SHORT $LN12@cckd64_wri
$LN11@cckd64_wri:
  00266	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv173[rsp], 0
$LN12@cckd64_wri:
  0026e	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00277	74 17		 je	 SHORT $LN13@cckd64_wri
  00279	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00281	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00285	d1 f8		 sar	 eax, 1
  00287	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv179[rsp], eax
  0028e	eb 0b		 jmp	 SHORT $LN14@cckd64_wri
$LN13@cckd64_wri:
  00290	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv179[rsp], 0
$LN14@cckd64_wri:
  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002a1	8b 08		 mov	 ecx, DWORD PTR [rax]
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002a9	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv159[rsp], rax
  002b1	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  002b8	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002c0	e8 00 00 00 00	 call	 cckd_sf_name
  002c5	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv165[rsp], rax
  002cd	b9 01 00 00 00	 mov	 ecx, 1
  002d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002d8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv159[rsp]
  002e0	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  002e5	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  002ed	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  002f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169760
  002f9	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002fe	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv165[rsp]
  00306	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0030b	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  00312	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00316	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv173[rsp]
  0031a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0031e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv179[rsp]
  00325	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00329	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169761
  00330	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00335	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169762
  0033c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00341	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00346	41 b9 03 00 00
	00		 mov	 r9d, 3
  0034c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169763
  00353	ba 0f 02 00 00	 mov	 edx, 527		; 0000020fH
  00358	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169764
  0035f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00365	e9 39 01 00 00	 jmp	 $LN5@cckd64_wri
$LN4@cckd64_wri:

; 527  :                 "write()", off, strerror( errno ));
; 528  :         else
; 529  :         {
; 530  :             char buf[128];
; 531  :             MSGBUF( buf, "write incomplete: write %d, expected %d", rc, len );

  0036a	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00371	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00375	44 8b 4c 24 70	 mov	 r9d, DWORD PTR rc$[rsp]
  0037a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169765
  00381	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00386	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0038e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 532  :             // "%1d:%04X CCKD file[%d] %s: error in function %s at offset 0x%16.16"PRIX64": %s"
; 533  :             WRMSG( HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name( dev, sfx ),

  00394	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0039d	74 15		 je	 SHORT $LN15@cckd64_wri
  0039f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003a7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003ab	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv206[rsp], eax
  003b2	eb 0b		 jmp	 SHORT $LN16@cckd64_wri
$LN15@cckd64_wri:
  003b4	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv206[rsp], 0
$LN16@cckd64_wri:
  003bf	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003c8	74 17		 je	 SHORT $LN17@cckd64_wri
  003ca	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d2	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003d6	d1 f8		 sar	 eax, 1
  003d8	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv212[rsp], eax
  003df	eb 0b		 jmp	 SHORT $LN18@cckd64_wri
$LN17@cckd64_wri:
  003e1	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
$LN18@cckd64_wri:
  003ec	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  003f3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003fb	e8 00 00 00 00	 call	 cckd_sf_name
  00400	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv198[rsp], rax
  00408	b9 01 00 00 00	 mov	 ecx, 1
  0040d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00413	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0041b	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00420	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00428	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0042d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169766
  00434	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00439	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv198[rsp]
  00441	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00446	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  0044d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00451	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv206[rsp]
  00458	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0045c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv212[rsp]
  00463	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00467	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169767
  0046e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00473	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169768
  0047a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0047f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00484	41 b9 03 00 00
	00		 mov	 r9d, 3
  0048a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169769
  00491	ba 16 02 00 00	 mov	 edx, 534		; 00000216H
  00496	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169770
  0049d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@cckd64_wri:

; 534  :                 "write()", off, buf );
; 535  :         }
; 536  :         cckd_print_itrace();

  004a3	e8 00 00 00 00	 call	 cckd_print_itrace

; 537  :         return -1;

  004a8	b8 ff ff ff ff	 mov	 eax, -1
  004ad	eb 04		 jmp	 SHORT $LN1@cckd64_wri
$LN3@cckd64_wri:

; 538  :     }
; 539  : 
; 540  :     return rc;

  004af	8b 44 24 70	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cckd64_wri:

; 541  : 
; 542  : } /* end function cckd64_write */

  004b3	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004bb	48 33 cc	 xor	 rcx, rsp
  004be	e8 00 00 00 00	 call	 __security_check_cookie
  004c3	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  004ca	c3		 ret	 0
cckd64_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
rc$ = 112
tv132 = 116
tv138 = 120
tv173 = 124
tv179 = 128
tv206 = 132
tv212 = 136
cckd$ = 144
tv86 = 152
tv92 = 160
tv159 = 168
tv165 = 176
tv198 = 184
buf$1 = 192
__$ArrayPad$ = 320
dev$ = 352
sfx$ = 360
off$ = 368
buf$ = 376
len$ = 384
cckd64_read PROC

; 454  : {

$LN19:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 455  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 456  : int             rc;                     /* Return code               */
; 457  : 
; 458  :     cckd = dev->cckd_ext;

  0002c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00034	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0003b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 459  : 
; 460  :     CCKD_TRACE( "file[%d] fd[%d] read, off 0x%16.16"PRIx64" len %d",

  00043	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0004b	8b 8c 24 80 01
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00052	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00056	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  0005e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00063	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0006b	8b 84 81 f0 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+240]
  00072	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00076	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  0007d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00081	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169712
  00088	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00090	ba cd 01 00 00	 mov	 edx, 461		; 000001cdH
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169713
  0009c	e8 00 00 00 00	 call	 cckd_trace

; 461  :                 sfx, cckd->fd[ sfx ], off, len );
; 462  : 
; 463  :     /* Seek to specified offset */
; 464  :     if (lseek( cckd->fd[ sfx ], off, SEEK_SET ) < 0)

  000a1	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000a9	45 33 c0	 xor	 r8d, r8d
  000ac	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR off$[rsp]
  000b4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  000bc	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  000c9	48 85 c0	 test	 rax, rax
  000cc	0f 8d 22 01 00
	00		 jge	 $LN2@cckd64_rea

; 465  :     {
; 466  :         // "%1d:%04X CCKD file[%d] %s: error in function %s at offset 0x%16.16"PRIX64": %s"
; 467  :         WRMSG( HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name( dev, sfx ),

  000d2	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000db	74 12		 je	 SHORT $LN7@cckd64_rea
  000dd	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000e9	89 44 24 74	 mov	 DWORD PTR tv132[rsp], eax
  000ed	eb 08		 jmp	 SHORT $LN8@cckd64_rea
$LN7@cckd64_rea:
  000ef	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv132[rsp], 0
$LN8@cckd64_rea:
  000f7	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00100	74 14		 je	 SHORT $LN9@cckd64_rea
  00102	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0010e	d1 f8		 sar	 eax, 1
  00110	89 44 24 78	 mov	 DWORD PTR tv138[rsp], eax
  00114	eb 08		 jmp	 SHORT $LN10@cckd64_rea
$LN9@cckd64_rea:
  00116	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN10@cckd64_rea:
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00124	8b 08		 mov	 ecx, DWORD PTR [rax]
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0012c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv86[rsp], rax
  00134	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  0013b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00143	e8 00 00 00 00	 call	 cckd_sf_name
  00148	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv92[rsp], rax
  00150	b9 01 00 00 00	 mov	 ecx, 1
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0015b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv86[rsp]
  00163	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00168	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00170	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169715
  0017c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00181	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv92[rsp]
  00189	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0018e	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  00195	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00199	8b 4c 24 74	 mov	 ecx, DWORD PTR tv132[rsp]
  0019d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001a1	8b 4c 24 78	 mov	 ecx, DWORD PTR tv138[rsp]
  001a5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169716
  001b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169717
  001bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169718
  001d3	ba d4 01 00 00	 mov	 edx, 468		; 000001d4H
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169719
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 468  :             "lseek()", off, strerror( errno ));
; 469  :         cckd_print_itrace();

  001e5	e8 00 00 00 00	 call	 cckd_print_itrace

; 470  :         return -1;

  001ea	b8 ff ff ff ff	 mov	 eax, -1
  001ef	e9 b7 02 00 00	 jmp	 $LN1@cckd64_rea
$LN2@cckd64_rea:

; 471  :     }
; 472  : 
; 473  :     /* Read the data */
; 474  :     rc = read( cckd->fd[ sfx ], buf, len );

  001f4	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001fc	44 8b 84 24 80
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00204	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0020c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  00214	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00221	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 475  :     if (rc < (int)len)

  00225	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0022c	39 44 24 70	 cmp	 DWORD PTR rc$[rsp], eax
  00230	0f 8d 71 02 00
	00		 jge	 $LN3@cckd64_rea

; 476  :     {
; 477  :         if (rc < 0)

  00236	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  0023b	0f 8d 21 01 00
	00		 jge	 $LN4@cckd64_rea

; 478  :             // "%1d:%04X CCKD file[%d] %s: error in function %s at offset 0x%16.16"PRIX64": %s"
; 479  :             WRMSG( HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name( dev, sfx ),

  00241	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0024a	74 12		 je	 SHORT $LN11@cckd64_rea
  0024c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00254	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00258	89 44 24 7c	 mov	 DWORD PTR tv173[rsp], eax
  0025c	eb 08		 jmp	 SHORT $LN12@cckd64_rea
$LN11@cckd64_rea:
  0025e	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv173[rsp], 0
$LN12@cckd64_rea:
  00266	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0026f	74 17		 je	 SHORT $LN13@cckd64_rea
  00271	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00279	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0027d	d1 f8		 sar	 eax, 1
  0027f	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv179[rsp], eax
  00286	eb 0b		 jmp	 SHORT $LN14@cckd64_rea
$LN13@cckd64_rea:
  00288	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv179[rsp], 0
$LN14@cckd64_rea:
  00293	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00299	8b 08		 mov	 ecx, DWORD PTR [rax]
  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002a1	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv159[rsp], rax
  002a9	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  002b0	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002b8	e8 00 00 00 00	 call	 cckd_sf_name
  002bd	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv165[rsp], rax
  002c5	b9 01 00 00 00	 mov	 ecx, 1
  002ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002d0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv159[rsp]
  002d8	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  002dd	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  002e5	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  002ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169723
  002f1	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002f6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv165[rsp]
  002fe	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00303	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  0030a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0030e	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv173[rsp]
  00312	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00316	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv179[rsp]
  0031d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00321	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169724
  00328	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0032d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169725
  00334	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00339	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0033e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00344	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169726
  0034b	ba e0 01 00 00	 mov	 edx, 480		; 000001e0H
  00350	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169727
  00357	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  0035d	e9 39 01 00 00	 jmp	 $LN5@cckd64_rea
$LN4@cckd64_rea:

; 480  :                 "read()", off, strerror( errno ));
; 481  :         else
; 482  :         {
; 483  :             char buf[128];
; 484  :             MSGBUF( buf, "read incomplete: read %d, expected %d", rc, len );

  00362	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00369	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0036d	44 8b 4c 24 70	 mov	 r9d, DWORD PTR rc$[rsp]
  00372	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169728
  00379	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0037e	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00386	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 485  :             // "%1d:%04X CCKD file[%d] %s: error in function %s at offset 0x%16.16"PRIX64": %s"
; 486  :             WRMSG( HHC00302, "E", LCSS_DEVNUM, sfx, cckd_sf_name( dev, sfx ),

  0038c	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00395	74 15		 je	 SHORT $LN15@cckd64_rea
  00397	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0039f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003a3	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv206[rsp], eax
  003aa	eb 0b		 jmp	 SHORT $LN16@cckd64_rea
$LN15@cckd64_rea:
  003ac	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv206[rsp], 0
$LN16@cckd64_rea:
  003b7	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003c0	74 17		 je	 SHORT $LN17@cckd64_rea
  003c2	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003ca	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003ce	d1 f8		 sar	 eax, 1
  003d0	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv212[rsp], eax
  003d7	eb 0b		 jmp	 SHORT $LN18@cckd64_rea
$LN17@cckd64_rea:
  003d9	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
$LN18@cckd64_rea:
  003e4	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  003eb	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003f3	e8 00 00 00 00	 call	 cckd_sf_name
  003f8	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv198[rsp], rax
  00400	b9 01 00 00 00	 mov	 ecx, 1
  00405	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0040b	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00413	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00418	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR off$[rsp]
  00420	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00425	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169729
  0042c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00431	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv198[rsp]
  00439	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0043e	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  00445	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00449	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv206[rsp]
  00450	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00454	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv212[rsp]
  0045b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0045f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169730
  00466	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0046b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169731
  00472	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00477	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0047c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00482	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169732
  00489	ba e7 01 00 00	 mov	 edx, 487		; 000001e7H
  0048e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169733
  00495	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@cckd64_rea:

; 487  :                 "read()", off, buf );
; 488  :         }
; 489  :         cckd_print_itrace();

  0049b	e8 00 00 00 00	 call	 cckd_print_itrace

; 490  :         return -1;

  004a0	b8 ff ff ff ff	 mov	 eax, -1
  004a5	eb 04		 jmp	 SHORT $LN1@cckd64_rea
$LN3@cckd64_rea:

; 491  :     }
; 492  : 
; 493  :     return rc;

  004a7	8b 44 24 70	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cckd64_rea:

; 494  : 
; 495  : } /* end function cckd64_read */

  004ab	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004b3	48 33 cc	 xor	 rcx, rsp
  004b6	e8 00 00 00 00	 call	 __security_check_cookie
  004bb	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  004c2	c3		 ret	 0
cckd64_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
rc$ = 112
tv136 = 116
tv142 = 120
cckd$ = 128
tv91 = 136
tv128 = 144
dev$ = 176
sfx$ = 184
cckd64_close PROC

; 424  : {

$LN10:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 425  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 426  : int             rc = 0;                 /* Return code               */

  00010	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 427  : 
; 428  :     cckd = dev->cckd_ext;

  00018	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00020	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00027	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR cckd$[rsp], rax

; 429  : 
; 430  :     CCKD_TRACE( "file[%d] fd[%d] close %s",

  0002f	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  00036	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0003e	e8 00 00 00 00	 call	 cckd_sf_name
  00043	48 63 8c 24 b8
	00 00 00	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  0004b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00050	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR cckd$[rsp]
  00058	8b 84 88 f0 00
	00 00		 mov	 eax, DWORD PTR [rax+rcx*4+240]
  0005f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00063	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  0006a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0006e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169687
  00075	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0007d	ba af 01 00 00	 mov	 edx, 431		; 000001afH
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169688
  00089	e8 00 00 00 00	 call	 cckd_trace

; 431  :                 sfx, cckd->fd[sfx], cckd_sf_name(dev, sfx));
; 432  : 
; 433  :     if (cckd->fd[sfx] >= 0)

  0008e	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00096	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  0009e	83 bc 81 f0 00
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+240], 0
  000a6	7c 21		 jl	 SHORT $LN2@cckd64_clo

; 434  :         rc = close (cckd->fd[sfx]);

  000a8	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  000b0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  000b8	8b 8c 81 f0 00
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+240]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
  000c5	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
$LN2@cckd64_clo:

; 435  : 
; 436  :     if (rc < 0)

  000c9	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  000ce	0f 8d 0b 01 00
	00		 jge	 $LN3@cckd64_clo

; 437  :     {
; 438  :         WRMSG (HHC00301, "E", LCSS_DEVNUM, sfx, cckd_sf_name (dev, sfx),

  000d4	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000dd	74 12		 je	 SHORT $LN6@cckd64_clo
  000df	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000eb	89 44 24 74	 mov	 DWORD PTR tv136[rsp], eax
  000ef	eb 08		 jmp	 SHORT $LN7@cckd64_clo
$LN6@cckd64_clo:
  000f1	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN7@cckd64_clo:
  000f9	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00102	74 14		 je	 SHORT $LN8@cckd64_clo
  00104	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00110	d1 f8		 sar	 eax, 1
  00112	89 44 24 78	 mov	 DWORD PTR tv142[rsp], eax
  00116	eb 08		 jmp	 SHORT $LN9@cckd64_clo
$LN8@cckd64_clo:
  00118	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN9@cckd64_clo:
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00126	8b 08		 mov	 ecx, DWORD PTR [rax]
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0012e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv91[rsp], rax
  00136	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  0013d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00145	e8 00 00 00 00	 call	 cckd_sf_name
  0014a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv128[rsp], rax
  00152	b9 01 00 00 00	 mov	 ecx, 1
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0015d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv91[rsp]
  00165	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169691
  00171	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00176	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv128[rsp]
  0017e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00183	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  0018a	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0018e	8b 4c 24 74	 mov	 ecx, DWORD PTR tv136[rsp]
  00192	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00196	8b 4c 24 78	 mov	 ecx, DWORD PTR tv142[rsp]
  0019a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0019e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169692
  001a5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169693
  001b1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bb	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169694
  001c8	ba b7 01 00 00	 mov	 edx, 439		; 000001b7H
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169695
  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 439  :                               "close()", strerror(errno));
; 440  :         cckd_print_itrace ();

  001da	e8 00 00 00 00	 call	 cckd_print_itrace
$LN3@cckd64_clo:

; 441  :     }
; 442  : 
; 443  :     cckd->fd[sfx] = -1;

  001df	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  001e7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ef	c7 84 81 f0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+240], -1

; 444  :     if (sfx == 0) dev->fd = -1;

  001fa	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR sfx$[rsp], 0
  00202	75 12		 jne	 SHORT $LN4@cckd64_clo
  00204	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020c	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1
$LN4@cckd64_clo:

; 445  : 
; 446  :     return rc;

  00216	8b 44 24 70	 mov	 eax, DWORD PTR rc$[rsp]

; 447  : 
; 448  : } /* end function cckd64_close */

  0021a	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00221	c3		 ret	 0
cckd64_close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
cckd$ = 112
tv68 = 120
tv144 = 124
tv146 = 128
tv162 = 132
tv168 = 136
err$ = 140
tv149 = 144
tv154 = 152
pathname$ = 160
__$ArrayPad$ = 432
dev$ = 464
sfx$ = 472
flags$ = 480
mode$ = 488
cckd64_open PROC

; 380  : {

$LN18:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 381  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 382  : int             err;                    /* 1 = issue error message   */
; 383  : char            pathname[MAX_PATH];     /* file path in host format  */
; 384  : 
; 385  :     cckd = dev->cckd_ext;

  0002c	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00034	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0003b	48 89 44 24 70	 mov	 QWORD PTR cckd$[rsp], rax

; 386  : 
; 387  :     err = !((flags & O_CREAT) == 0 && mode != 0);

  00040	8b 84 24 e0 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00047	25 00 01 00 00	 and	 eax, 256		; 00000100H
  0004c	85 c0		 test	 eax, eax
  0004e	75 14		 jne	 SHORT $LN8@cckd64_ope
  00050	83 bc 24 e8 01
	00 00 00	 cmp	 DWORD PTR mode$[rsp], 0
  00058	74 0a		 je	 SHORT $LN8@cckd64_ope
  0005a	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
  00062	eb 08		 jmp	 SHORT $LN9@cckd64_ope
$LN8@cckd64_ope:
  00064	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
$LN9@cckd64_ope:
  0006c	8b 44 24 78	 mov	 eax, DWORD PTR tv68[rsp]
  00070	89 84 24 8c 00
	00 00		 mov	 DWORD PTR err$[rsp], eax

; 388  : 
; 389  :     if (cckd->fd[sfx] >= 0)

  00077	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0007f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00084	83 bc 81 f0 00
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+240], 0
  0008c	7c 14		 jl	 SHORT $LN2@cckd64_ope

; 390  :         cckd64_close (dev, sfx);

  0008e	8b 94 24 d8 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  00095	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0009d	e8 00 00 00 00	 call	 cckd64_close
$LN2@cckd64_ope:

; 391  : 
; 392  :     hostpath(pathname, cckd_sf_name (dev, sfx), sizeof(pathname));

  000a2	8b 94 24 d8 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  000a9	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000b1	e8 00 00 00 00	 call	 cckd_sf_name
  000b6	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000bc	48 8b d0	 mov	 rdx, rax
  000bf	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 393  :     cckd->fd[sfx] = HOPEN (pathname, flags, mode);

  000cd	44 8b 84 24 e8
	01 00 00	 mov	 r8d, DWORD PTR mode$[rsp]
  000d5	8b 94 24 e0 01
	00 00		 mov	 edx, DWORD PTR flags$[rsp]
  000dc	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  000ea	48 63 8c 24 d8
	01 00 00	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  000f2	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  000f7	89 84 8a f0 00
	00 00		 mov	 DWORD PTR [rdx+rcx*4+240], eax

; 394  :     if (sfx == 0) dev->fd = cckd->fd[sfx];

  000fe	83 bc 24 d8 01
	00 00 00	 cmp	 DWORD PTR sfx$[rsp], 0
  00106	75 22		 jne	 SHORT $LN3@cckd64_ope
  00108	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00110	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00118	48 8b 54 24 70	 mov	 rdx, QWORD PTR cckd$[rsp]
  0011d	8b 84 82 f0 00
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+240]
  00124	89 81 ac 01 00
	00		 mov	 DWORD PTR [rcx+428], eax
$LN3@cckd64_ope:

; 395  : 
; 396  :     if (cckd->fd[sfx] >= 0)

  0012a	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00132	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00137	83 bc 81 f0 00
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+240], 0
  0013f	7c 73		 jl	 SHORT $LN4@cckd64_ope

; 397  :         cckd->open[sfx] = flags & O_RDWR ? CCKD_OPEN_RW :

  00141	8b 84 24 e0 01
	00 00		 mov	 eax, DWORD PTR flags$[rsp]
  00148	83 e0 02	 and	 eax, 2
  0014b	85 c0		 test	 eax, eax
  0014d	74 0d		 je	 SHORT $LN12@cckd64_ope
  0014f	c7 84 24 80 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv146[rsp], 3
  0015a	eb 37		 jmp	 SHORT $LN13@cckd64_ope
$LN12@cckd64_ope:
  0015c	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00164	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  00169	0f b6 84 01 1d
	01 00 00	 movzx	 eax, BYTE PTR [rcx+rax+285]
  00171	83 f8 03	 cmp	 eax, 3
  00174	75 0a		 jne	 SHORT $LN10@cckd64_ope
  00176	c7 44 24 7c 02
	00 00 00	 mov	 DWORD PTR tv144[rsp], 2
  0017e	eb 08		 jmp	 SHORT $LN11@cckd64_ope
$LN10@cckd64_ope:
  00180	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv144[rsp], 1
$LN11@cckd64_ope:
  00188	8b 44 24 7c	 mov	 eax, DWORD PTR tv144[rsp]
  0018c	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv146[rsp], eax
$LN13@cckd64_ope:
  00193	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  0019b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  001a0	0f b6 94 24 80
	00 00 00	 movzx	 edx, BYTE PTR tv146[rsp]
  001a8	88 94 01 1d 01
	00 00		 mov	 BYTE PTR [rcx+rax+285], dl
  001af	e9 b2 01 00 00	 jmp	 $LN5@cckd64_ope
$LN4@cckd64_ope:

; 398  :                           cckd->open[sfx] == CCKD_OPEN_RW ?
; 399  :                           CCKD_OPEN_RD : CCKD_OPEN_RO;
; 400  :     else
; 401  :     {
; 402  :         if (err)

  001b4	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR err$[rsp], 0
  001bc	0f 84 8f 01 00
	00		 je	 $LN6@cckd64_ope

; 403  :         {
; 404  :             WRMSG (HHC00301, "E", LCSS_DEVNUM, sfx, cckd_sf_name (dev, sfx),

  001c2	48 83 bc 24 d0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001cb	74 15		 je	 SHORT $LN14@cckd64_ope
  001cd	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001d9	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv162[rsp], eax
  001e0	eb 0b		 jmp	 SHORT $LN15@cckd64_ope
$LN14@cckd64_ope:
  001e2	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv162[rsp], 0
$LN15@cckd64_ope:
  001ed	48 83 bc 24 d0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001f6	74 17		 je	 SHORT $LN16@cckd64_ope
  001f8	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00200	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00204	d1 f8		 sar	 eax, 1
  00206	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv168[rsp], eax
  0020d	eb 0b		 jmp	 SHORT $LN17@cckd64_ope
$LN16@cckd64_ope:
  0020f	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv168[rsp], 0
$LN17@cckd64_ope:
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00220	8b 08		 mov	 ecx, DWORD PTR [rax]
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00228	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv149[rsp], rax
  00230	8b 94 24 d8 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  00237	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0023f	e8 00 00 00 00	 call	 cckd_sf_name
  00244	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv154[rsp], rax
  0024c	b9 01 00 00 00	 mov	 ecx, 1
  00251	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00257	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv149[rsp]
  0025f	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169671
  0026b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00270	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv154[rsp]
  00278	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0027d	8b 8c 24 d8 01
	00 00		 mov	 ecx, DWORD PTR sfx$[rsp]
  00284	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00288	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv162[rsp]
  0028f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00293	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv168[rsp]
  0029a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0029e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169672
  002a5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169673
  002b1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002bb	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169674
  002c8	ba 95 01 00 00	 mov	 edx, 405		; 00000195H
  002cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169675
  002d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 405  :                     "open()", strerror(errno));
; 406  :             CCKD_TRACE( "file[%d] fd[%d] open %s error flags %8.8x mode %8.8x",

  002da	8b 94 24 d8 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  002e1	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e9	e8 00 00 00 00	 call	 cckd_sf_name
  002ee	48 63 8c 24 d8
	01 00 00	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  002f6	8b 94 24 e8 01
	00 00		 mov	 edx, DWORD PTR mode$[rsp]
  002fd	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  00301	8b 94 24 e0 01
	00 00		 mov	 edx, DWORD PTR flags$[rsp]
  00308	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  0030c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00311	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  00316	8b 84 88 f0 00
	00 00		 mov	 eax, DWORD PTR [rax+rcx*4+240]
  0031d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00321	8b 84 24 d8 01
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  00328	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0032c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169676
  00333	4c 8b 84 24 d0
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0033b	ba 97 01 00 00	 mov	 edx, 407		; 00000197H
  00340	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169677
  00347	e8 00 00 00 00	 call	 cckd_trace

; 407  :                         sfx, cckd->fd[sfx], cckd_sf_name (dev, sfx), flags, mode);
; 408  :             cckd_print_itrace ();

  0034c	e8 00 00 00 00	 call	 cckd_print_itrace
$LN6@cckd64_ope:

; 409  :         }
; 410  :         cckd->open[sfx] = CCKD_OPEN_NONE;

  00351	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  00359	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  0035e	c6 84 01 1d 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+285], 0
$LN5@cckd64_ope:

; 411  :     }
; 412  : 
; 413  :     CCKD_TRACE( "file[%d] fd[%d] open %s, flags %8.8x mode %8.8x",

  00366	8b 94 24 d8 01
	00 00		 mov	 edx, DWORD PTR sfx$[rsp]
  0036d	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00375	e8 00 00 00 00	 call	 cckd_sf_name
  0037a	48 63 8c 24 d8
	01 00 00	 movsxd	 rcx, DWORD PTR sfx$[rsp]
  00382	8b 94 24 e8 01
	00 00		 mov	 edx, DWORD PTR mode$[rsp]
  00389	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  0038d	8b 94 24 e0 01
	00 00		 mov	 edx, DWORD PTR flags$[rsp]
  00394	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  00398	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0039d	48 8b 44 24 70	 mov	 rax, QWORD PTR cckd$[rsp]
  003a2	8b 84 88 f0 00
	00 00		 mov	 eax, DWORD PTR [rax+rcx*4+240]
  003a9	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003ad	8b 84 24 d8 01
	00 00		 mov	 eax, DWORD PTR sfx$[rsp]
  003b4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  003b8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169678
  003bf	4c 8b 84 24 d0
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  003c7	ba 9e 01 00 00	 mov	 edx, 414		; 0000019eH
  003cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169679
  003d3	e8 00 00 00 00	 call	 cckd_trace

; 414  :                 sfx, cckd->fd[sfx], cckd_sf_name (dev, sfx), flags, mode);
; 415  : 
; 416  :     return cckd->fd[sfx];

  003d8	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR sfx$[rsp]
  003e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cckd$[rsp]
  003e5	8b 84 81 f0 00
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+240]

; 417  : 
; 418  : } /* end function cckd64_open */

  003ec	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003f4	48 33 cc	 xor	 rcx, rsp
  003f7	e8 00 00 00 00	 call	 __security_check_cookie
  003fc	48 81 c4 c8 01
	00 00		 add	 rsp, 456		; 000001c8H
  00403	c3		 ret	 0
cckd64_open ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
cckd$ = 64
dev$ = 96
cckd64_dasd_end PROC

; 328  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 329  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 330  : 
; 331  :     if (!dev->cckd64)

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00015	24 01		 and	 al, 1
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 0f		 jne	 SHORT $LN2@cckd64_das

; 332  :     {
; 333  :         cckd_dasd_end( dev );

  0001e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00023	e8 00 00 00 00	 call	 cckd_dasd_end

; 334  :         return;

  00028	e9 a2 01 00 00	 jmp	 $LN1@cckd64_das
$LN2@cckd64_das:

; 335  :     }
; 336  : 
; 337  :     cckd = dev->cckd_ext;

  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00039	48 89 44 24 40	 mov	 QWORD PTR cckd$[rsp], rax

; 338  : 
; 339  :     /* Update length if previous image was updated */
; 340  :     if (dev->bufupd && dev->bufcur >= 0 && dev->cache >= 0)

  0003e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00043	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  0004a	74 5b		 je	 SHORT $LN3@cckd64_das
  0004c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00051	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [rax+448], 0
  00058	7c 4d		 jl	 SHORT $LN3@cckd64_das
  0005a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0005f	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  00066	7c 3f		 jl	 SHORT $LN3@cckd64_das

; 341  :     {
; 342  :         dev->buflen = cckd_trklen (dev, dev->buf);

  00068	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0006d	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00074	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00079	e8 00 00 00 00	 call	 cckd_trklen
  0007e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00083	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 343  :         cache_setval (CACHE_DEVBUF, dev->cache, dev->buflen);

  00089	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0008e	44 8b 80 dc 01
	00 00		 mov	 r8d, DWORD PTR [rax+476]
  00095	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0009a	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  000a0	33 c9		 xor	 ecx, ecx
  000a2	e8 00 00 00 00	 call	 cache_setval
$LN3@cckd64_das:

; 344  :     }
; 345  : 
; 346  :     dev->bufupd = 0;

  000a7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000ac	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 347  : 
; 348  :     CCKD_TRACE( "end i/o bufcur %d cache[%d] waiters %d",

  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  000bb	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000be	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000c2	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000c7	8b 80 f8 01 00
	00		 mov	 eax, DWORD PTR [rax+504]
  000cd	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000d1	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000d6	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  000dc	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000e0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169644
  000e7	4c 8b 44 24 60	 mov	 r8, QWORD PTR dev$[rsp]
  000ec	ba 5d 01 00 00	 mov	 edx, 349		; 0000015dH
  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169645
  000f8	e8 00 00 00 00	 call	 cckd_trace

; 349  :                 dev->bufcur, dev->cache, cckd->cckdwaiters);
; 350  : 
; 351  :     obtain_lock (&cckd->cckdiolock);

  000fd	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00102	48 83 c0 18	 add	 rax, 24
  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169646
  0010d	48 8b c8	 mov	 rcx, rax
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 352  : 
; 353  :     cckd->cckdioact = 0;

  00116	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  0011b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0011e	83 e0 fb	 and	 eax, -5			; fffffffbH
  00121	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cckd$[rsp]
  00126	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 354  : 
; 355  :     /* Make the current entry inactive */
; 356  :     if (dev->cache >= 0)

  00129	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0012e	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  00135	7c 29		 jl	 SHORT $LN4@cckd64_das

; 357  :     {
; 358  :         cache_lock (CACHE_DEVBUF);

  00137	33 c9		 xor	 ecx, ecx
  00139	e8 00 00 00 00	 call	 cache_lock

; 359  :         cache_setflag (CACHE_DEVBUF, dev->cache, ~CCKD_CACHE_ACTIVE, 0);

  0013e	45 33 c9	 xor	 r9d, r9d
  00141	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  00147	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0014c	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00152	33 c9		 xor	 ecx, ecx
  00154	e8 00 00 00 00	 call	 cache_setflag

; 360  :         cache_unlock (CACHE_DEVBUF);

  00159	33 c9		 xor	 ecx, ecx
  0015b	e8 00 00 00 00	 call	 cache_unlock
$LN4@cckd64_das:

; 361  :     }
; 362  : 
; 363  :     /* Cause writers to start after first update */
; 364  :     if (cckd->updated && (cckdblk.wrs == 0 || cckd->cckdwaiters != 0))

  00160	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00165	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00168	c1 e8 04	 shr	 eax, 4
  0016b	83 e0 01	 and	 eax, 1
  0016e	85 c0		 test	 eax, eax
  00170	74 20		 je	 SHORT $LN5@cckd64_das
  00172	83 3d 68 00 00
	00 00		 cmp	 DWORD PTR cckdblk+104, 0
  00179	74 0b		 je	 SHORT $LN7@cckd64_das
  0017b	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00180	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00184	74 0c		 je	 SHORT $LN5@cckd64_das
$LN7@cckd64_das:

; 365  :         cckd64_flush_cache (dev);

  00186	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0018b	e8 00 00 00 00	 call	 cckd64_flush_cache
  00190	eb 24		 jmp	 SHORT $LN6@cckd64_das
$LN5@cckd64_das:

; 366  :     else if (cckd->cckdwaiters)

  00192	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  00197	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  0019b	74 19		 je	 SHORT $LN8@cckd64_das

; 367  :         broadcast_condition (&cckd->cckdiocond);

  0019d	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  001a2	48 83 c0 20	 add	 rax, 32			; 00000020H
  001a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169652
  001ad	48 8b c8	 mov	 rcx, rax
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN8@cckd64_das:
$LN6@cckd64_das:

; 368  : 
; 369  :     release_lock (&cckd->cckdiolock);

  001b6	48 8b 44 24 40	 mov	 rax, QWORD PTR cckd$[rsp]
  001bb	48 83 c0 18	 add	 rax, 24
  001bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169653
  001c6	48 8b c8	 mov	 rcx, rax
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@cckd64_das:

; 370  : 
; 371  : } /* end function cckd64_dasd_end */

  001cf	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d3	c3		 ret	 0
cckd64_dasd_end ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
devnum$ = 64
tv86 = 68
trk$ = 72
cckd$ = 80
dev$ = 112
cckd64_dasd_start PROC

; 257  : {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 258  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 259  : U16             devnum = 0;             /* Last active device number */

  00009	33 c0		 xor	 eax, eax
  0000b	66 89 44 24 40	 mov	 WORD PTR devnum$[rsp], ax

; 260  : int             trk = 0;                /* Last active track         */

  00010	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR trk$[rsp], 0

; 261  : 
; 262  :     if (!dev->cckd64)

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00024	24 01		 and	 al, 1
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	75 0f		 jne	 SHORT $LN7@cckd64_das

; 263  :     {
; 264  :         cckd_dasd_start( dev );

  0002d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00032	e8 00 00 00 00	 call	 cckd_dasd_start

; 265  :         return;

  00037	e9 0f 03 00 00	 jmp	 $LN1@cckd64_das
$LN7@cckd64_das:

; 266  :     }
; 267  : 
; 268  :     cckd = dev->cckd_ext;

  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00041	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00048	48 89 44 24 50	 mov	 QWORD PTR cckd$[rsp], rax

; 269  : 
; 270  :     CCKD_TRACE( "start i/o file[%d] bufcur %d cache[%d]",

  0004d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00052	8b 80 f8 01 00
	00		 mov	 eax, DWORD PTR [rax+504]
  00058	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0005c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00061	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  00067	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0006b	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00070	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00073	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00077	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169623
  0007e	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00083	ba 0f 01 00 00	 mov	 edx, 271		; 0000010fH
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169624
  0008f	e8 00 00 00 00	 call	 cckd_trace

; 271  :                 cckd->sfn, dev->bufcur, dev->cache);
; 272  : 
; 273  :     /* Reset buffer offsets */
; 274  :     dev->bufoff = 0;

  00094	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00099	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 275  :     dev->bufoffhi = cckd->ckddasd ? dev->ckdtrksz : CFBA_BLKGRP_SIZE;

  000a3	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  000a8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000ab	83 e0 01	 and	 eax, 1
  000ae	85 c0		 test	 eax, eax
  000b0	74 11		 je	 SHORT $LN15@cckd64_das
  000b2	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000b7	8b 80 c4 12 00
	00		 mov	 eax, DWORD PTR [rax+4804]
  000bd	89 44 24 44	 mov	 DWORD PTR tv86[rsp], eax
  000c1	eb 08		 jmp	 SHORT $LN16@cckd64_das
$LN15@cckd64_das:
  000c3	c7 44 24 44 00
	f0 00 00	 mov	 DWORD PTR tv86[rsp], 61440 ; 0000f000H
$LN16@cckd64_das:
  000cb	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000d0	8b 4c 24 44	 mov	 ecx, DWORD PTR tv86[rsp]
  000d4	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 276  : 
; 277  :     /* Check for merge */
; 278  :     obtain_lock(&cckd->cckdiolock);

  000da	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  000df	48 83 c0 18	 add	 rax, 24
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169625
  000ea	48 8b c8	 mov	 rcx, rax
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 279  :     if (cckd->merging)

  000f3	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  000f8	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000fb	c1 e8 05	 shr	 eax, 5
  000fe	83 e0 01	 and	 eax, 1
  00101	85 c0		 test	 eax, eax
  00103	0f 84 a1 00 00
	00		 je	 $LN8@cckd64_das

; 280  :     {
; 281  :         CCKD_TRACE( "start i/o waiting for merge%s","");

  00109	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169627
  00110	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169628
  0011c	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00121	ba 19 01 00 00	 mov	 edx, 281		; 00000119H
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169629
  0012d	e8 00 00 00 00	 call	 cckd_trace
$LN2@cckd64_das:

; 282  :         while (cckd->merging)

  00132	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00137	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0013a	c1 e8 05	 shr	 eax, 5
  0013d	83 e0 01	 and	 eax, 1
  00140	85 c0		 test	 eax, eax
  00142	74 48		 je	 SHORT $LN3@cckd64_das

; 283  :         {
; 284  :             cckd->cckdwaiters++;

  00144	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00149	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0014c	ff c0		 inc	 eax
  0014e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00153	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 285  :             wait_condition (&cckd->cckdiocond, &cckd->cckdiolock);

  00156	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0015b	48 83 c0 18	 add	 rax, 24
  0015f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00164	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00168	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169630
  0016f	48 8b d0	 mov	 rdx, rax
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 286  :             cckd->cckdwaiters--;

  00178	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0017d	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00180	ff c8		 dec	 eax
  00182	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00187	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 287  :         }

  0018a	eb a6		 jmp	 SHORT $LN2@cckd64_das
$LN3@cckd64_das:

; 288  :         dev->bufcur = dev->cache = -1;

  0018c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00191	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0019b	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001a0	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1
$LN8@cckd64_das:

; 289  :     }
; 290  :     cckd->cckdioact = 1;

  001aa	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  001af	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001b2	83 c8 04	 or	 eax, 4
  001b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  001ba	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 291  : 
; 292  :     cache_lock(CACHE_DEVBUF);

  001bd	33 c9		 xor	 ecx, ecx
  001bf	e8 00 00 00 00	 call	 cache_lock

; 293  : 
; 294  :     if (dev->cache >= 0)

  001c4	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001c9	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  001d0	7c 45		 jl	 SHORT $LN9@cckd64_das
$LN6@cckd64_das:

; 295  :         CCKD_CACHE_GETKEY(dev->cache, devnum, trk);

  001d2	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001d7	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  001dd	33 c9		 xor	 ecx, ecx
  001df	e8 00 00 00 00	 call	 cache_getkey
  001e4	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  001e8	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  001ee	66 89 44 24 40	 mov	 WORD PTR devnum$[rsp], ax
  001f3	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001f8	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  001fe	33 c9		 xor	 ecx, ecx
  00200	e8 00 00 00 00	 call	 cache_getkey
  00205	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0020a	48 23 c1	 and	 rax, rcx
  0020d	89 44 24 48	 mov	 DWORD PTR trk$[rsp], eax
  00211	33 c0		 xor	 eax, eax
  00213	85 c0		 test	 eax, eax
  00215	75 bb		 jne	 SHORT $LN6@cckd64_das
$LN9@cckd64_das:

; 296  : 
; 297  :     /* Check if previous active entry is still valid and not busy */
; 298  :     if (dev->cache >= 0 && dev->devnum == devnum && dev->bufcur == trk
; 299  :      && !(cache_getflag(CACHE_DEVBUF, dev->cache) & CCKD_CACHE_IOBUSY))

  00217	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0021c	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  00223	0f 8c e4 00 00
	00		 jl	 $LN10@cckd64_das
  00229	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0022e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00232	0f b7 4c 24 40	 movzx	 ecx, WORD PTR devnum$[rsp]
  00237	3b c1		 cmp	 eax, ecx
  00239	0f 85 ce 00 00
	00		 jne	 $LN10@cckd64_das
  0023f	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00244	8b 4c 24 48	 mov	 ecx, DWORD PTR trk$[rsp]
  00248	39 88 c0 01 00
	00		 cmp	 DWORD PTR [rax+448], ecx
  0024e	0f 85 b9 00 00
	00		 jne	 $LN10@cckd64_das
  00254	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00259	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0025f	33 c9		 xor	 ecx, ecx
  00261	e8 00 00 00 00	 call	 cache_getflag
  00266	25 00 00 00 60	 and	 eax, 1610612736		; 60000000H
  0026b	85 c0		 test	 eax, eax
  0026d	0f 85 9a 00 00
	00		 jne	 $LN10@cckd64_das

; 300  :     {
; 301  :         /* Make the entry active again */
; 302  :         cache_setflag (CACHE_DEVBUF, dev->cache, ~0, CCKD_CACHE_ACTIVE);

  00273	41 b9 00 00 00
	80		 mov	 r9d, -2147483648	; 80000000H
  00279	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  0027f	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00284	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0028a	33 c9		 xor	 ecx, ecx
  0028c	e8 00 00 00 00	 call	 cache_setflag

; 303  : 
; 304  :         /* If the entry is pending write then change it to `updated' */
; 305  :         if (cache_getflag(CACHE_DEVBUF, dev->cache) & CCKD_CACHE_WRITE)

  00291	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00296	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0029c	33 c9		 xor	 ecx, ecx
  0029e	e8 00 00 00 00	 call	 cache_getflag
  002a3	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  002a8	85 c0		 test	 eax, eax
  002aa	74 5f		 je	 SHORT $LN12@cckd64_das

; 306  :         {
; 307  :             cache_setflag (CACHE_DEVBUF, dev->cache, ~CCKD_CACHE_WRITE, CCKD_CACHE_UPDATED);

  002ac	41 b9 00 00 00
	08		 mov	 r9d, 134217728		; 08000000H
  002b2	41 b8 ff ff ff
	fb		 mov	 r8d, -67108865		; fbffffffH
  002b8	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002bd	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  002c3	33 c9		 xor	 ecx, ecx
  002c5	e8 00 00 00 00	 call	 cache_setflag

; 308  :             cckd->wrpending--;

  002ca	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  002cf	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  002d2	ff c8		 dec	 eax
  002d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  002d9	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 309  :             if (cckd->cckdwaiters && !cckd->wrpending)

  002dc	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  002e1	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  002e5	74 24		 je	 SHORT $LN13@cckd64_das
  002e7	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  002ec	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  002f0	75 19		 jne	 SHORT $LN13@cckd64_das

; 310  :                 broadcast_condition (&cckd->cckdiocond);

  002f2	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  002f7	48 83 c0 20	 add	 rax, 32			; 00000020H
  002fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169636
  00302	48 8b c8	 mov	 rcx, rax
  00305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN13@cckd64_das:
$LN12@cckd64_das:

; 311  :         }
; 312  :     }

  0030b	eb 1e		 jmp	 SHORT $LN11@cckd64_das
$LN10@cckd64_das:

; 313  :     else
; 314  :         dev->bufcur = dev->cache = -1;

  0030d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00312	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0031c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00321	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1
$LN11@cckd64_das:

; 315  : 
; 316  :     cache_unlock (CACHE_DEVBUF);

  0032b	33 c9		 xor	 ecx, ecx
  0032d	e8 00 00 00 00	 call	 cache_unlock

; 317  : 
; 318  :     release_lock (&cckd->cckdiolock);

  00332	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00337	48 83 c0 18	 add	 rax, 24
  0033b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169637
  00342	48 8b c8	 mov	 rcx, rax
  00345	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@cckd64_das:

; 319  : 
; 320  :     return;
; 321  : 
; 322  : } /* end function cckd64_dasd_start */

  0034b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0034f	c3		 ret	 0
cckd64_dasd_start ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
rc$ = 32
cbuf$ = 40
cckd$ = 48
dev$ = 96
blkgrp$ = 104
off$ = 112
buf$ = 120
len$ = 128
unitstat$ = 136
cfba64_write_block PROC

; 847  : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 848  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 849  : int             rc;                     /* Return code               */
; 850  : BYTE           *cbuf;                   /* -> cache buffer           */
; 851  : 
; 852  :     cckd = dev->cckd_ext;

  00019	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00025	48 89 44 24 30	 mov	 QWORD PTR cckd$[rsp], rax

; 853  : 
; 854  :     if (dev->cache >= 0)

  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  00036	7c 1c		 jl	 SHORT $LN2@cfba64_wri

; 855  :         cbuf = cache_getbuf (CACHE_DEVBUF, dev->cache, 0);

  00038	45 33 c0	 xor	 r8d, r8d
  0003b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00040	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00046	33 c9		 xor	 ecx, ecx
  00048	e8 00 00 00 00	 call	 cache_getbuf
  0004d	48 89 44 24 28	 mov	 QWORD PTR cbuf$[rsp], rax
  00052	eb 09		 jmp	 SHORT $LN3@cfba64_wri
$LN2@cfba64_wri:

; 856  :     else
; 857  :         cbuf = NULL;

  00054	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR cbuf$[rsp], 0
$LN3@cfba64_wri:

; 858  : 
; 859  :     /* Read the block group if it's not current or compressed.
; 860  :        `dev->comps' is set to zero forcing the read routine to
; 861  :        uncompress the image.                                   */
; 862  :     if (blkgrp != dev->bufcur || (cbuf[0] & CCKD_COMPRESS_MASK) != 0)

  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00062	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  00068	39 44 24 68	 cmp	 DWORD PTR blkgrp$[rsp], eax
  0006c	75 19		 jne	 SHORT $LN5@cfba64_wri
  0006e	b8 01 00 00 00	 mov	 eax, 1
  00073	48 6b c0 00	 imul	 rax, rax, 0
  00077	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cbuf$[rsp]
  0007c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00080	83 e0 03	 and	 eax, 3
  00083	85 c0		 test	 eax, eax
  00085	74 62		 je	 SHORT $LN4@cfba64_wri
$LN5@cfba64_wri:

; 863  :     {
; 864  :         dev->comps = 0;

  00087	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0008c	c7 80 08 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+520], 0

; 865  :         rc = (dev->hnd->read) (dev, blkgrp, unitstat);

  00096	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0009b	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  000a2	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  000aa	8b 54 24 68	 mov	 edx, DWORD PTR blkgrp$[rsp]
  000ae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000b3	ff 50 50	 call	 QWORD PTR [rax+80]
  000b6	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 866  :         if (rc < 0)

  000ba	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bf	7d 28		 jge	 SHORT $LN6@cfba64_wri

; 867  :         {
; 868  :             dev->bufcur = dev->cache = -1;

  000c1	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000c6	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  000d0	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000d5	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 869  :             return -1;

  000df	b8 ff ff ff ff	 mov	 eax, -1
  000e4	e9 91 00 00 00	 jmp	 $LN1@cfba64_wri
$LN6@cfba64_wri:
$LN4@cfba64_wri:

; 870  :         }
; 871  :     }
; 872  : 
; 873  :     /* Copy the data into the buffer */
; 874  :     if (buf) memcpy (dev->buf + off, buf, len);

  000e9	48 83 7c 24 78
	00		 cmp	 QWORD PTR buf$[rsp], 0
  000ef	74 26		 je	 SHORT $LN7@cfba64_wri
  000f1	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000f9	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR off$[rsp]
  000fe	48 8b 54 24 60	 mov	 rdx, QWORD PTR dev$[rsp]
  00103	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  0010a	48 8b f9	 mov	 rdi, rcx
  0010d	48 8b 74 24 78	 mov	 rsi, QWORD PTR buf$[rsp]
  00112	48 8b c8	 mov	 rcx, rax
  00115	f3 a4		 rep movsb
$LN7@cfba64_wri:

; 875  : 
; 876  :     /* Update the cache entry */
; 877  :     cache_setflag (CACHE_DEVBUF, dev->cache, ~0, CCKD_CACHE_UPDATED|CCKD_CACHE_USED);

  00117	41 b9 00 00 80
	08		 mov	 r9d, 142606336		; 08800000H
  0011d	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  00123	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00128	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0012e	33 c9		 xor	 ecx, ecx
  00130	e8 00 00 00 00	 call	 cache_setflag

; 878  :     cckd->updated = 1;

  00135	48 8b 44 24 30	 mov	 rax, QWORD PTR cckd$[rsp]
  0013a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0013d	83 c8 10	 or	 eax, 16
  00140	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cckd$[rsp]
  00145	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 879  : 
; 880  :     /* Notify the shared server of the update */
; 881  :     if (!dev->bufupd)

  00148	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0014d	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  00154	75 1d		 jne	 SHORT $LN8@cfba64_wri

; 882  :     {
; 883  :         dev->bufupd = 1;

  00156	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0015b	c7 80 f4 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+500], 1

; 884  :         shared_update_notify (dev, blkgrp);

  00165	8b 54 24 68	 mov	 edx, DWORD PTR blkgrp$[rsp]
  00169	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0016e	e8 00 00 00 00	 call	 shared_update_notify
$LN8@cfba64_wri:

; 885  :     }
; 886  : 
; 887  :     return len;

  00173	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
$LN1@cfba64_wri:

; 888  : 
; 889  : } /* end function cfba64_write_block */

  0017a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017e	5f		 pop	 rdi
  0017f	5e		 pop	 rsi
  00180	c3		 ret	 0
cfba64_write_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
maxlen$ = 48
cache$ = 52
rc$ = 56
len$ = 60
cbuf$ = 64
newbuf$ = 72
cckd$ = 80
dev$ = 112
blkgrp$ = 120
unitstat$ = 128
cfba64_read_block PROC

; 762  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 763  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 764  : int             rc;                     /* Return code               */
; 765  : int             cache;                  /* New active cache entry    */
; 766  : BYTE           *cbuf;                   /* -> cache buffer           */
; 767  : BYTE           *newbuf;                 /* Uncompressed buffer       */
; 768  : int             len;                    /* Compressed length         */
; 769  : int             maxlen;                 /* Size for cache entry      */
; 770  : 
; 771  :     cckd = dev->cckd_ext;

  00012	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00017	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0001e	48 89 44 24 50	 mov	 QWORD PTR cckd$[rsp], rax

; 772  : 
; 773  :     if (dev->cache >= 0)

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00028	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  0002f	7c 1c		 jl	 SHORT $LN2@cfba64_rea

; 774  :         cbuf = cache_getbuf (CACHE_DEVBUF, dev->cache, 0);

  00031	45 33 c0	 xor	 r8d, r8d
  00034	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00039	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0003f	33 c9		 xor	 ecx, ecx
  00041	e8 00 00 00 00	 call	 cache_getbuf
  00046	48 89 44 24 40	 mov	 QWORD PTR cbuf$[rsp], rax
  0004b	eb 09		 jmp	 SHORT $LN3@cfba64_rea
$LN2@cfba64_rea:

; 775  :     else
; 776  :         cbuf = NULL;

  0004d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR cbuf$[rsp], 0
$LN3@cfba64_rea:

; 777  :     maxlen = CFBA_BLKGRP_SIZE + CKD_TRKHDR_SIZE;

  00056	c7 44 24 30 05
	f0 00 00	 mov	 DWORD PTR maxlen$[rsp], 61445 ; 0000f005H

; 778  : 
; 779  :     /* Return if reading the same track image */
; 780  :     if (blkgrp == dev->bufcur && dev->cache >= 0)

  0005e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00063	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  00069	39 44 24 78	 cmp	 DWORD PTR blkgrp$[rsp], eax
  0006d	0f 85 d6 01 00
	00		 jne	 $LN4@cfba64_rea
  00073	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00078	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  0007f	0f 8c c4 01 00
	00		 jl	 $LN4@cfba64_rea

; 781  :     {
; 782  :         /* Block group image may be compressed */
; 783  :         if ((cbuf[0] & CCKD_COMPRESS_MASK) != 0
; 784  :          && (cbuf[0] & dev->comps) == 0)

  00085	b8 01 00 00 00	 mov	 eax, 1
  0008a	48 6b c0 00	 imul	 rax, rax, 0
  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cbuf$[rsp]
  00093	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00097	83 e0 03	 and	 eax, 3
  0009a	85 c0		 test	 eax, eax
  0009c	0f 84 80 01 00
	00		 je	 $LN5@cfba64_rea
  000a2	b8 01 00 00 00	 mov	 eax, 1
  000a7	48 6b c0 00	 imul	 rax, rax, 0
  000ab	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cbuf$[rsp]
  000b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000b9	23 81 08 02 00
	00		 and	 eax, DWORD PTR [rcx+520]
  000bf	85 c0		 test	 eax, eax
  000c1	0f 85 5b 01 00
	00		 jne	 $LN5@cfba64_rea

; 785  :         {
; 786  :             len = cache_getval(CACHE_DEVBUF, dev->cache) + CKD_TRKHDR_SIZE;

  000c7	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000cc	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  000d2	33 c9		 xor	 ecx, ecx
  000d4	e8 00 00 00 00	 call	 cache_getval
  000d9	48 98		 cdqe
  000db	48 83 c0 05	 add	 rax, 5
  000df	89 44 24 3c	 mov	 DWORD PTR len$[rsp], eax

; 787  :             newbuf = cckd64_uncompress (dev, cbuf, len, maxlen, blkgrp);

  000e3	8b 44 24 78	 mov	 eax, DWORD PTR blkgrp$[rsp]
  000e7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000eb	44 8b 4c 24 30	 mov	 r9d, DWORD PTR maxlen$[rsp]
  000f0	44 8b 44 24 3c	 mov	 r8d, DWORD PTR len$[rsp]
  000f5	48 8b 54 24 40	 mov	 rdx, QWORD PTR cbuf$[rsp]
  000fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000ff	e8 00 00 00 00	 call	 cckd64_uncompress
  00104	48 89 44 24 48	 mov	 QWORD PTR newbuf$[rsp], rax

; 788  :             if (newbuf == NULL) {

  00109	48 83 7c 24 48
	00		 cmp	 QWORD PTR newbuf$[rsp], 0
  0010f	75 49		 jne	 SHORT $LN6@cfba64_rea

; 789  :                 dev->sense[0] = SENSE_EC;

  00111	b8 01 00 00 00	 mov	 eax, 1
  00116	48 6b c0 00	 imul	 rax, rax, 0
  0011a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0011f	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 790  :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00127	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0012f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 791  :                 dev->bufcur = dev->cache = -1;

  00132	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00137	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00141	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00146	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 792  :                 return -1;

  00150	b8 ff ff ff ff	 mov	 eax, -1
  00155	e9 a2 02 00 00	 jmp	 $LN1@cfba64_rea
$LN6@cfba64_rea:

; 793  :             }
; 794  :             cache_setbuf (CACHE_DEVBUF, dev->cache, newbuf, maxlen);

  0015a	44 8b 4c 24 30	 mov	 r9d, DWORD PTR maxlen$[rsp]
  0015f	4c 8b 44 24 48	 mov	 r8, QWORD PTR newbuf$[rsp]
  00164	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00169	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0016f	33 c9		 xor	 ecx, ecx
  00171	e8 00 00 00 00	 call	 cache_setbuf

; 795  :             cbuf = newbuf;

  00176	48 8b 44 24 48	 mov	 rax, QWORD PTR newbuf$[rsp]
  0017b	48 89 44 24 40	 mov	 QWORD PTR cbuf$[rsp], rax

; 796  :             dev->buf     = newbuf + CKD_TRKHDR_SIZE;

  00180	48 8b 44 24 48	 mov	 rax, QWORD PTR newbuf$[rsp]
  00185	48 83 c0 05	 add	 rax, 5
  00189	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0018e	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 797  :             dev->buflen  = CFBA_BLKGRP_SIZE;

  00195	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0019a	c7 80 dc 01 00
	00 00 f0 00 00	 mov	 DWORD PTR [rax+476], 61440 ; 0000f000H

; 798  :             cache_setval (CACHE_DEVBUF, dev->cache, dev->buflen);

  001a4	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001a9	44 8b 80 dc 01
	00 00		 mov	 r8d, DWORD PTR [rax+476]
  001b0	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001b5	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  001bb	33 c9		 xor	 ecx, ecx
  001bd	e8 00 00 00 00	 call	 cache_setval

; 799  :             dev->bufsize = cache_getlen (CACHE_DEVBUF, dev->cache);

  001c2	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001c7	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  001cd	33 c9		 xor	 ecx, ecx
  001cf	e8 00 00 00 00	 call	 cache_getlen
  001d4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001d9	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 800  :             dev->bufupd  = 0;

  001df	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001e4	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 801  :             CCKD_TRACE( "read bkgrp  %d uncompressed len %d",

  001ee	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  001f3	8b 80 dc 01 00
	00		 mov	 eax, DWORD PTR [rax+476]
  001f9	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001fd	8b 44 24 78	 mov	 eax, DWORD PTR blkgrp$[rsp]
  00201	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00205	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169896
  0020c	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00211	ba 22 03 00 00	 mov	 edx, 802		; 00000322H
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169897
  0021d	e8 00 00 00 00	 call	 cckd_trace
$LN5@cfba64_rea:

; 802  :                         blkgrp, dev->buflen);
; 803  :         }
; 804  : 
; 805  :         dev->comp = cbuf[0] & CCKD_COMPRESS_MASK;

  00222	b8 01 00 00 00	 mov	 eax, 1
  00227	48 6b c0 00	 imul	 rax, rax, 0
  0022b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cbuf$[rsp]
  00230	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00234	83 e0 03	 and	 eax, 3
  00237	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0023c	89 81 0c 02 00
	00		 mov	 DWORD PTR [rcx+524], eax

; 806  : 
; 807  :         return 0;

  00242	33 c0		 xor	 eax, eax
  00244	e9 b3 01 00 00	 jmp	 $LN1@cfba64_rea
$LN4@cfba64_rea:

; 808  :     }
; 809  : 
; 810  :     CCKD_TRACE( "read blkgrp  %d (%s)", blkgrp, "asynchronous");

  00249	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169898
  00250	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00255	8b 44 24 78	 mov	 eax, DWORD PTR blkgrp$[rsp]
  00259	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0025d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169899
  00264	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00269	ba 2a 03 00 00	 mov	 edx, 810		; 0000032aH
  0026e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169900
  00275	e8 00 00 00 00	 call	 cckd_trace

; 811  : 
; 812  :     /* Read the new blkgrp */
; 813  :     dev->bufupd = 0;

  0027a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0027f	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 814  :     cache = cckd64_read_trk (dev, blkgrp, 0, unitstat);

  00289	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  00291	45 33 c0	 xor	 r8d, r8d
  00294	8b 54 24 78	 mov	 edx, DWORD PTR blkgrp$[rsp]
  00298	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0029d	e8 00 00 00 00	 call	 cckd64_read_trk
  002a2	89 44 24 34	 mov	 DWORD PTR cache$[rsp], eax

; 815  :     if (cache < 0)

  002a6	83 7c 24 34 00	 cmp	 DWORD PTR cache$[rsp], 0
  002ab	7d 28		 jge	 SHORT $LN7@cfba64_rea

; 816  :     {
; 817  :         dev->bufcur = dev->cache = -1;

  002ad	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002b2	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  002bc	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002c1	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 818  :         return -1;

  002cb	b8 ff ff ff ff	 mov	 eax, -1
  002d0	e9 27 01 00 00	 jmp	 $LN1@cfba64_rea
$LN7@cfba64_rea:

; 819  :     }
; 820  :     dev->cache    = cache;

  002d5	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002da	8b 4c 24 34	 mov	 ecx, DWORD PTR cache$[rsp]
  002de	89 88 f8 01 00
	00		 mov	 DWORD PTR [rax+504], ecx

; 821  :     cbuf          = cache_getbuf (CACHE_DEVBUF, dev->cache, 0);

  002e4	45 33 c0	 xor	 r8d, r8d
  002e7	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002ec	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  002f2	33 c9		 xor	 ecx, ecx
  002f4	e8 00 00 00 00	 call	 cache_getbuf
  002f9	48 89 44 24 40	 mov	 QWORD PTR cbuf$[rsp], rax

; 822  :     dev->buf      = cbuf + CKD_TRKHDR_SIZE;

  002fe	48 8b 44 24 40	 mov	 rax, QWORD PTR cbuf$[rsp]
  00303	48 83 c0 05	 add	 rax, 5
  00307	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0030c	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 823  :     dev->bufcur   = blkgrp;

  00313	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00318	8b 4c 24 78	 mov	 ecx, DWORD PTR blkgrp$[rsp]
  0031c	89 88 c0 01 00
	00		 mov	 DWORD PTR [rax+448], ecx

; 824  :     dev->bufoff   = 0;

  00322	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00327	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 825  :     dev->bufoffhi = CFBA_BLKGRP_SIZE;

  00331	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00336	c7 80 e8 01 00
	00 00 f0 00 00	 mov	 DWORD PTR [rax+488], 61440 ; 0000f000H

; 826  :     dev->buflen   = CFBA_BLKGRP_SIZE;

  00340	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00345	c7 80 dc 01 00
	00 00 f0 00 00	 mov	 DWORD PTR [rax+476], 61440 ; 0000f000H

; 827  :     cache_setval  (CACHE_DEVBUF, dev->cache, dev->buflen);

  0034f	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00354	44 8b 80 dc 01
	00 00		 mov	 r8d, DWORD PTR [rax+476]
  0035b	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00360	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00366	33 c9		 xor	 ecx, ecx
  00368	e8 00 00 00 00	 call	 cache_setval

; 828  :     dev->bufsize  = cache_getlen (CACHE_DEVBUF, dev->cache);

  0036d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00372	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00378	33 c9		 xor	 ecx, ecx
  0037a	e8 00 00 00 00	 call	 cache_getlen
  0037f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00384	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 829  :     dev->comp     = cbuf[0] & CCKD_COMPRESS_MASK;

  0038a	b8 01 00 00 00	 mov	 eax, 1
  0038f	48 6b c0 00	 imul	 rax, rax, 0
  00393	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cbuf$[rsp]
  00398	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0039c	83 e0 03	 and	 eax, 3
  0039f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  003a4	89 81 0c 02 00
	00		 mov	 DWORD PTR [rcx+524], eax

; 830  : 
; 831  :     /* If the image is compressed then call ourself recursively
; 832  :        to cause the image to get uncompressed.  This is because
; 833  :       `bufcur' will match blkgrp and `comps' won't match `comp' */
; 834  :     if (dev->comp != 0 && (dev->comp & dev->comps) == 0)

  003aa	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  003af	83 b8 0c 02 00
	00 00		 cmp	 DWORD PTR [rax+524], 0
  003b6	74 38		 je	 SHORT $LN8@cfba64_rea
  003b8	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  003bd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  003c2	8b 89 08 02 00
	00		 mov	 ecx, DWORD PTR [rcx+520]
  003c8	8b 80 0c 02 00
	00		 mov	 eax, DWORD PTR [rax+524]
  003ce	23 c1		 and	 eax, ecx
  003d0	85 c0		 test	 eax, eax
  003d2	75 1c		 jne	 SHORT $LN8@cfba64_rea

; 835  :         rc = cfba64_read_block (dev, blkgrp, unitstat);

  003d4	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  003dc	8b 54 24 78	 mov	 edx, DWORD PTR blkgrp$[rsp]
  003e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  003e5	e8 00 00 00 00	 call	 cfba64_read_block
  003ea	89 44 24 38	 mov	 DWORD PTR rc$[rsp], eax
  003ee	eb 08		 jmp	 SHORT $LN9@cfba64_rea
$LN8@cfba64_rea:

; 836  :     else
; 837  :         rc = 0;

  003f0	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN9@cfba64_rea:

; 838  : 
; 839  :     return rc;

  003f8	8b 44 24 38	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cfba64_rea:

; 840  : } /* end function cfba64_read_block */

  003fc	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00400	c3		 ret	 0
cfba64_read_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
rc$ = 64
cckd$ = 72
dev$ = 112
trk$ = 120
off$ = 128
buf$ = 136
len$ = 144
unitstat$ = 152
cckd64_update_track PROC

; 661  : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 662  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 663  : int             rc;                     /* Return code               */
; 664  : 
; 665  :     cckd = dev->cckd_ext;

  00019	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00025	48 89 44 24 48	 mov	 QWORD PTR cckd$[rsp], rax

; 666  : 
; 667  :     /* Error if opened read-only */
; 668  :     if (dev->ckdrdonly && cckd->sfn == 0)

  0002a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00035	c1 e8 12	 shr	 eax, 18
  00038	83 e0 01	 and	 eax, 1
  0003b	85 c0		 test	 eax, eax
  0003d	74 5a		 je	 SHORT $LN2@cckd64_upd
  0003f	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  00044	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00048	75 4f		 jne	 SHORT $LN2@cckd64_upd

; 669  :     {
; 670  :         ckd_build_sense (dev, SENSE_EC, SENSE1_WRI, 0,FORMAT_1, MESSAGE_0);

  0004a	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0004f	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00054	45 33 c9	 xor	 r9d, r9d
  00057	41 b0 02	 mov	 r8b, 2
  0005a	b2 10		 mov	 dl, 16
  0005c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00061	e8 00 00 00 00	 call	 ckd_build_sense

; 671  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00066	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0006e	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 672  :         dev->bufcur = dev->cache = -1;

  00071	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00076	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00080	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00085	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 673  :         return -1;

  0008f	b8 ff ff ff ff	 mov	 eax, -1
  00094	e9 e0 01 00 00	 jmp	 $LN1@cckd64_upd
$LN2@cckd64_upd:

; 674  :     }
; 675  : 
; 676  :     /* If the track is not current or compressed then read it.
; 677  :        `dev->comps' is set to zero forcing the read routine to
; 678  :        uncompress the image.                                     */
; 679  :     if (trk != dev->bufcur || (dev->buf[0] & CCKD_COMPRESS_MASK) != 0)

  00099	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0009e	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  000a4	39 44 24 78	 cmp	 DWORD PTR trk$[rsp], eax
  000a8	75 20		 jne	 SHORT $LN4@cckd64_upd
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	48 6b c0 00	 imul	 rax, rax, 0
  000b3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000b8	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  000bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c3	83 e0 03	 and	 eax, 3
  000c6	85 c0		 test	 eax, eax
  000c8	74 62		 je	 SHORT $LN3@cckd64_upd
$LN4@cckd64_upd:

; 680  :     {
; 681  :         dev->comps = 0;

  000ca	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000cf	c7 80 08 02 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+520], 0

; 682  :         rc = (dev->hnd->read) (dev, trk, unitstat);

  000d9	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000de	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  000e5	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  000ed	8b 54 24 78	 mov	 edx, DWORD PTR trk$[rsp]
  000f1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000f6	ff 50 50	 call	 QWORD PTR [rax+80]
  000f9	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 683  :         if (rc < 0)

  000fd	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00102	7d 28		 jge	 SHORT $LN5@cckd64_upd

; 684  :         {
; 685  :             dev->bufcur = dev->cache = -1;

  00104	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00109	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00113	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00118	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 686  :             return -1;

  00122	b8 ff ff ff ff	 mov	 eax, -1
  00127	e9 4d 01 00 00	 jmp	 $LN1@cckd64_upd
$LN5@cckd64_upd:
$LN3@cckd64_upd:

; 687  :         }
; 688  :     }
; 689  : 
; 690  :     /* Invalid track format if going past buffer end */
; 691  :     if (off + len > dev->ckdtrksz)

  0012c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00133	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR off$[rsp]
  0013a	03 c8		 add	 ecx, eax
  0013c	8b c1		 mov	 eax, ecx
  0013e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00143	3b 81 c4 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4804]
  00149	7e 4f		 jle	 SHORT $LN6@cckd64_upd

; 692  :     {
; 693  :         ckd_build_sense (dev, 0, SENSE1_ITF, 0, 0, 0);

  0014b	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00150	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00155	45 33 c9	 xor	 r9d, r9d
  00158	41 b0 40	 mov	 r8b, 64			; 00000040H
  0015b	33 d2		 xor	 edx, edx
  0015d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00162	e8 00 00 00 00	 call	 ckd_build_sense

; 694  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00167	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0016f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 695  :         dev->bufcur = dev->cache = -1;

  00172	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00177	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00181	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00186	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 696  :         return -1;

  00190	b8 ff ff ff ff	 mov	 eax, -1
  00195	e9 df 00 00 00	 jmp	 $LN1@cckd64_upd
$LN6@cckd64_upd:

; 697  :     }
; 698  : 
; 699  :     /* Copy the data into the buffer */
; 700  :     if (buf && len > 0) memcpy (dev->buf + off, buf, len);

  0019a	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR buf$[rsp], 0
  001a3	74 36		 je	 SHORT $LN7@cckd64_upd
  001a5	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR len$[rsp], 0
  001ad	7e 2c		 jle	 SHORT $LN7@cckd64_upd
  001af	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  001b7	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR off$[rsp]
  001bf	48 8b 54 24 70	 mov	 rdx, QWORD PTR dev$[rsp]
  001c4	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  001cb	48 8b f9	 mov	 rdi, rcx
  001ce	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR buf$[rsp]
  001d6	48 8b c8	 mov	 rcx, rax
  001d9	f3 a4		 rep movsb
$LN7@cckd64_upd:

; 701  : 
; 702  :     CCKD_TRACE( "updt  trk   %d offset %"PRId64" length %d",

  001db	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001e2	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001e6	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR off$[rsp]
  001ed	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001f1	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  001f5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001f9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169839
  00200	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00205	ba bf 02 00 00	 mov	 edx, 703		; 000002bfH
  0020a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169840
  00211	e8 00 00 00 00	 call	 cckd_trace

; 703  :                 trk, off, len);
; 704  : 
; 705  :     /* Update the cache entry */
; 706  :     cache_setflag (CACHE_DEVBUF, dev->cache, ~0, CCKD_CACHE_UPDATED | CCKD_CACHE_USED);

  00216	41 b9 00 00 80
	08		 mov	 r9d, 142606336		; 08800000H
  0021c	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  00222	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00227	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0022d	33 c9		 xor	 ecx, ecx
  0022f	e8 00 00 00 00	 call	 cache_setflag

; 707  :     cckd->updated = 1;

  00234	48 8b 44 24 48	 mov	 rax, QWORD PTR cckd$[rsp]
  00239	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0023c	83 c8 10	 or	 eax, 16
  0023f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cckd$[rsp]
  00244	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 708  : 
; 709  :     /* Notify the shared server of the update */
; 710  :     if (!dev->bufupd)

  00247	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0024c	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  00253	75 1d		 jne	 SHORT $LN8@cckd64_upd

; 711  :     {
; 712  :         dev->bufupd = 1;

  00255	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0025a	c7 80 f4 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+500], 1

; 713  :         shared_update_notify (dev, trk);

  00264	8b 54 24 78	 mov	 edx, DWORD PTR trk$[rsp]
  00268	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0026d	e8 00 00 00 00	 call	 shared_update_notify
$LN8@cckd64_upd:

; 714  :     }
; 715  : 
; 716  :     return len;

  00272	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
$LN1@cckd64_upd:

; 717  : 
; 718  : } /* end function cckd64_update_track */

  00279	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0027d	5f		 pop	 rdi
  0027e	5e		 pop	 rsi
  0027f	c3		 ret	 0
cckd64_update_track ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
cache$ = 48
rc$ = 52
len$ = 56
newbuf$ = 64
cckd$ = 72
dev$ = 96
trk$ = 104
unitstat$ = 112
cckd64_read_track PROC

; 573  : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 574  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 575  : int             rc;                     /* Return code               */
; 576  : int             len;                    /* Compressed length         */
; 577  : BYTE           *newbuf;                 /* Uncompressed buffer       */
; 578  : int             cache;                  /* New active cache entry    */
; 579  : 
; 580  :     cckd = dev->cckd_ext;

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00017	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0001e	48 89 44 24 48	 mov	 QWORD PTR cckd$[rsp], rax

; 581  : 
; 582  :     /* Update length if previous image was updated */
; 583  :     if (dev->bufupd && dev->bufcur >= 0 && dev->cache >= 0)

  00023	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00028	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  0002f	74 5b		 je	 SHORT $LN2@cckd64_rea
  00031	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00036	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [rax+448], 0
  0003d	7c 4d		 jl	 SHORT $LN2@cckd64_rea
  0003f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00044	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  0004b	7c 3f		 jl	 SHORT $LN2@cckd64_rea

; 584  :     {
; 585  :         dev->buflen = cckd_trklen (dev, dev->buf);

  0004d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00059	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0005e	e8 00 00 00 00	 call	 cckd_trklen
  00063	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00068	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 586  :         cache_setval (CACHE_DEVBUF, dev->cache, dev->buflen);

  0006e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00073	44 8b 80 dc 01
	00 00		 mov	 r8d, DWORD PTR [rax+476]
  0007a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0007f	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00085	33 c9		 xor	 ecx, ecx
  00087	e8 00 00 00 00	 call	 cache_setval
$LN2@cckd64_rea:

; 587  :     }
; 588  : 
; 589  :     /* Reset buffer offsets */
; 590  :     dev->bufoff = 0;

  0008c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00091	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 591  :     dev->bufoffhi = dev->ckdtrksz;

  0009b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000a5	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  000ab	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 592  : 
; 593  :     /* Check if reading the same track image */
; 594  :     if (trk == dev->bufcur && dev->cache >= 0)

  000b1	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000b6	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  000bc	39 44 24 68	 cmp	 DWORD PTR trk$[rsp], eax
  000c0	0f 85 17 02 00
	00		 jne	 $LN3@cckd64_rea
  000c6	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000cb	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  000d2	0f 8c 05 02 00
	00		 jl	 $LN3@cckd64_rea

; 595  :     {
; 596  :         /* Track image may be compressed */
; 597  :         if ((dev->buf[0] & CCKD_COMPRESS_MASK) != 0
; 598  :          && (dev->buf[0] & dev->comps) == 0)

  000d8	b8 01 00 00 00	 mov	 eax, 1
  000dd	48 6b c0 00	 imul	 rax, rax, 0
  000e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000e6	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  000ed	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f1	83 e0 03	 and	 eax, 3
  000f4	85 c0		 test	 eax, eax
  000f6	0f 84 96 01 00
	00		 je	 $LN4@cckd64_rea
  000fc	b8 01 00 00 00	 mov	 eax, 1
  00101	48 6b c0 00	 imul	 rax, rax, 0
  00105	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0010a	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  00111	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00115	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0011a	23 81 08 02 00
	00		 and	 eax, DWORD PTR [rcx+520]
  00120	85 c0		 test	 eax, eax
  00122	0f 85 6a 01 00
	00		 jne	 $LN4@cckd64_rea

; 599  :         {
; 600  :             len = cache_getval(CACHE_DEVBUF, dev->cache);

  00128	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0012d	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00133	33 c9		 xor	 ecx, ecx
  00135	e8 00 00 00 00	 call	 cache_getval
  0013a	89 44 24 38	 mov	 DWORD PTR len$[rsp], eax

; 601  :             newbuf = cckd64_uncompress (dev, dev->buf, len, dev->ckdtrksz, trk);

  0013e	8b 44 24 68	 mov	 eax, DWORD PTR trk$[rsp]
  00142	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00146	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0014b	44 8b 88 c4 12
	00 00		 mov	 r9d, DWORD PTR [rax+4804]
  00152	44 8b 44 24 38	 mov	 r8d, DWORD PTR len$[rsp]
  00157	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0015c	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00163	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00168	e8 00 00 00 00	 call	 cckd64_uncompress
  0016d	48 89 44 24 40	 mov	 QWORD PTR newbuf$[rsp], rax

; 602  :             if (newbuf == NULL) {

  00172	48 83 7c 24 40
	00		 cmp	 QWORD PTR newbuf$[rsp], 0
  00178	75 4c		 jne	 SHORT $LN5@cckd64_rea

; 603  :                 ckd_build_sense (dev, SENSE_EC, 0, 0, FORMAT_1, MESSAGE_0);

  0017a	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0017f	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00184	45 33 c9	 xor	 r9d, r9d
  00187	45 33 c0	 xor	 r8d, r8d
  0018a	b2 10		 mov	 dl, 16
  0018c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00191	e8 00 00 00 00	 call	 ckd_build_sense

; 604  :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00196	48 8b 44 24 70	 mov	 rax, QWORD PTR unitstat$[rsp]
  0019b	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 605  :                 dev->bufcur = dev->cache = -1;

  0019e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001a3	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  001ad	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001b2	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 606  :                 return -1;

  001bc	b8 ff ff ff ff	 mov	 eax, -1
  001c1	e9 d1 02 00 00	 jmp	 $LN1@cckd64_rea
$LN5@cckd64_rea:

; 607  :             }
; 608  :             cache_setbuf (CACHE_DEVBUF, dev->cache, newbuf, dev->ckdtrksz);

  001c6	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001cb	44 8b 88 c4 12
	00 00		 mov	 r9d, DWORD PTR [rax+4804]
  001d2	4c 8b 44 24 40	 mov	 r8, QWORD PTR newbuf$[rsp]
  001d7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001dc	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  001e2	33 c9		 xor	 ecx, ecx
  001e4	e8 00 00 00 00	 call	 cache_setbuf

; 609  :             dev->buf     = newbuf;

  001e9	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR newbuf$[rsp]
  001f3	48 89 88 c8 01
	00 00		 mov	 QWORD PTR [rax+456], rcx

; 610  :             dev->buflen  = cckd_trklen (dev, newbuf);

  001fa	48 8b 54 24 40	 mov	 rdx, QWORD PTR newbuf$[rsp]
  001ff	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00204	e8 00 00 00 00	 call	 cckd_trklen
  00209	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0020e	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 611  :             cache_setval (CACHE_DEVBUF, dev->cache, dev->buflen);

  00214	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00219	44 8b 80 dc 01
	00 00		 mov	 r8d, DWORD PTR [rax+476]
  00220	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00225	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0022b	33 c9		 xor	 ecx, ecx
  0022d	e8 00 00 00 00	 call	 cache_setval

; 612  :             dev->bufsize = cache_getlen (CACHE_DEVBUF, dev->cache);

  00232	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00237	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0023d	33 c9		 xor	 ecx, ecx
  0023f	e8 00 00 00 00	 call	 cache_getlen
  00244	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00249	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 613  :             dev->bufupd  = 0;

  0024f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00254	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 614  :             CCKD_TRACE( "read  trk   %d uncompressed len %d",

  0025e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00263	8b 80 dc 01 00
	00		 mov	 eax, DWORD PTR [rax+476]
  00269	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0026d	8b 44 24 68	 mov	 eax, DWORD PTR trk$[rsp]
  00271	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00275	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169808
  0027c	4c 8b 44 24 60	 mov	 r8, QWORD PTR dev$[rsp]
  00281	ba 67 02 00 00	 mov	 edx, 615		; 00000267H
  00286	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169809
  0028d	e8 00 00 00 00	 call	 cckd_trace
$LN4@cckd64_rea:

; 615  :                         trk, dev->buflen);
; 616  :         }
; 617  : 
; 618  :         dev->comp = dev->buf[0] & CCKD_COMPRESS_MASK;

  00292	b8 01 00 00 00	 mov	 eax, 1
  00297	48 6b c0 00	 imul	 rax, rax, 0
  0029b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002a0	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  002a7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ab	83 e0 03	 and	 eax, 3
  002ae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002b3	89 81 0c 02 00
	00		 mov	 DWORD PTR [rcx+524], eax

; 619  :         if (dev->comp != 0) dev->compoff = CKD_TRKHDR_SIZE;

  002b9	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002be	83 b8 0c 02 00
	00 00		 cmp	 DWORD PTR [rax+524], 0
  002c5	74 0f		 je	 SHORT $LN6@cckd64_rea
  002c7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002cc	c7 80 10 02 00
	00 05 00 00 00	 mov	 DWORD PTR [rax+528], 5
$LN6@cckd64_rea:

; 620  : 
; 621  :         return 0;

  002d6	33 c0		 xor	 eax, eax
  002d8	e9 ba 01 00 00	 jmp	 $LN1@cckd64_rea
$LN3@cckd64_rea:

; 622  :     }
; 623  : 
; 624  :     CCKD_TRACE( "read  trk   %d (%s)", trk, "asynchronous");

  002dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169811
  002e4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002e9	8b 44 24 68	 mov	 eax, DWORD PTR trk$[rsp]
  002ed	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002f1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169812
  002f8	4c 8b 44 24 60	 mov	 r8, QWORD PTR dev$[rsp]
  002fd	ba 70 02 00 00	 mov	 edx, 624		; 00000270H
  00302	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169813
  00309	e8 00 00 00 00	 call	 cckd_trace

; 625  : 
; 626  :     /* read the new track */
; 627  :     dev->bufupd = 0;

  0030e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00313	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 628  :     cache = cckd64_read_trk (dev, trk, 0, unitstat);

  0031d	4c 8b 4c 24 70	 mov	 r9, QWORD PTR unitstat$[rsp]
  00322	45 33 c0	 xor	 r8d, r8d
  00325	8b 54 24 68	 mov	 edx, DWORD PTR trk$[rsp]
  00329	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0032e	e8 00 00 00 00	 call	 cckd64_read_trk
  00333	89 44 24 30	 mov	 DWORD PTR cache$[rsp], eax

; 629  :     if (cache < 0)

  00337	83 7c 24 30 00	 cmp	 DWORD PTR cache$[rsp], 0
  0033c	7d 28		 jge	 SHORT $LN7@cckd64_rea

; 630  :     {
; 631  :         dev->bufcur = dev->cache = -1;

  0033e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00343	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0034d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00352	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 632  :         return -1;

  0035c	b8 ff ff ff ff	 mov	 eax, -1
  00361	e9 31 01 00 00	 jmp	 $LN1@cckd64_rea
$LN7@cckd64_rea:

; 633  :     }
; 634  : 
; 635  :     dev->cache    = cache;

  00366	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0036b	8b 4c 24 30	 mov	 ecx, DWORD PTR cache$[rsp]
  0036f	89 88 f8 01 00
	00		 mov	 DWORD PTR [rax+504], ecx

; 636  :     dev->buf      = cache_getbuf (CACHE_DEVBUF, dev->cache, 0);

  00375	45 33 c0	 xor	 r8d, r8d
  00378	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0037d	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00383	33 c9		 xor	 ecx, ecx
  00385	e8 00 00 00 00	 call	 cache_getbuf
  0038a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0038f	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 637  :     dev->bufcur   = trk;

  00396	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0039b	8b 4c 24 68	 mov	 ecx, DWORD PTR trk$[rsp]
  0039f	89 88 c0 01 00
	00		 mov	 DWORD PTR [rax+448], ecx

; 638  :     dev->bufoff   = 0;

  003a5	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003aa	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 639  :     dev->bufoffhi = dev->ckdtrksz;

  003b4	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003be	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  003c4	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 640  :     dev->buflen   = cache_getval (CACHE_DEVBUF, dev->cache);

  003ca	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003cf	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  003d5	33 c9		 xor	 ecx, ecx
  003d7	e8 00 00 00 00	 call	 cache_getval
  003dc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003e1	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 641  :     dev->bufsize  = cache_getlen (CACHE_DEVBUF, dev->cache);

  003e7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003ec	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  003f2	33 c9		 xor	 ecx, ecx
  003f4	e8 00 00 00 00	 call	 cache_getlen
  003f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003fe	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 642  : 
; 643  :     dev->comp = dev->buf[0] & CCKD_COMPRESS_MASK;

  00404	b8 01 00 00 00	 mov	 eax, 1
  00409	48 6b c0 00	 imul	 rax, rax, 0
  0040d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00412	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  00419	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0041d	83 e0 03	 and	 eax, 3
  00420	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00425	89 81 0c 02 00
	00		 mov	 DWORD PTR [rcx+524], eax

; 644  :     if (dev->comp != 0) dev->compoff = CKD_TRKHDR_SIZE;

  0042b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00430	83 b8 0c 02 00
	00 00		 cmp	 DWORD PTR [rax+524], 0
  00437	74 0f		 je	 SHORT $LN8@cckd64_rea
  00439	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0043e	c7 80 10 02 00
	00 05 00 00 00	 mov	 DWORD PTR [rax+528], 5
$LN8@cckd64_rea:

; 645  : 
; 646  :     /* If the image is compressed then call ourself recursively
; 647  :        to cause the image to get uncompressed */
; 648  :     if (dev->comp != 0 && (dev->comp & dev->comps) == 0)

  00448	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0044d	83 b8 0c 02 00
	00 00		 cmp	 DWORD PTR [rax+524], 0
  00454	74 35		 je	 SHORT $LN9@cckd64_rea
  00456	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0045b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00460	8b 89 08 02 00
	00		 mov	 ecx, DWORD PTR [rcx+520]
  00466	8b 80 0c 02 00
	00		 mov	 eax, DWORD PTR [rax+524]
  0046c	23 c1		 and	 eax, ecx
  0046e	85 c0		 test	 eax, eax
  00470	75 19		 jne	 SHORT $LN9@cckd64_rea

; 649  :         rc = cckd64_read_track (dev, trk, unitstat);

  00472	4c 8b 44 24 70	 mov	 r8, QWORD PTR unitstat$[rsp]
  00477	8b 54 24 68	 mov	 edx, DWORD PTR trk$[rsp]
  0047b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00480	e8 00 00 00 00	 call	 cckd64_read_track
  00485	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
  00489	eb 08		 jmp	 SHORT $LN10@cckd64_rea
$LN9@cckd64_rea:

; 650  :     else
; 651  :         rc = 0;

  0048b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN10@cckd64_rea:

; 652  : 
; 653  :     return rc;

  00493	8b 44 24 34	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@cckd64_rea:

; 654  : } /* end function cckd64_read_track */

  00497	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0049b	c3		 ret	 0
cckd64_read_track ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
cckd$ = 96
i$ = 104
rc$ = 108
tv181 = 112
tv187 = 116
cckd2$1 = 120
tv172 = 128
dev2$2 = 136
tv176 = 144
dev$ = 176
cckd64_dasd_close_device PROC

; 128  : {

$LN32:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 129  : CCKD64_EXT     *cckd;                   /* -> cckd extension         */
; 130  : int             rc, i;                  /* Return code, Loop index   */
; 131  : 
; 132  :     if (!dev->cckd64)

  0000c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00014	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0001b	24 01		 and	 al, 1
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	75 12		 jne	 SHORT $LN14@cckd64_das

; 133  :         return cckd_dasd_close_device( dev );

  00024	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 cckd_dasd_close_device
  00031	e9 61 06 00 00	 jmp	 $LN1@cckd64_das
$LN14@cckd64_das:

; 134  : 
; 135  :     cckd = dev->cckd_ext;

  00036	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003e	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00045	48 89 44 24 60	 mov	 QWORD PTR cckd$[rsp], rax

; 136  : 
; 137  :     /* Wait for readaheads to finish */
; 138  :     obtain_lock(&cckdblk.ralock);

  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169577
  00051	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 139  :     cckd->stopping = 1;

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00063	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00066	83 c8 40	 or	 eax, 64			; 00000040H
  00069	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0006e	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN2@cckd64_das:

; 140  :     while (cckd->ras)

  00071	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00076	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  0007a	74 35		 je	 SHORT $LN3@cckd64_das

; 141  :     {
; 142  :         release_lock(&cckdblk.ralock);

  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169578
  00083	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 143  :         usleep(1);

  00090	b9 01 00 00 00	 mov	 ecx, 1
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 144  :         obtain_lock(&cckdblk.ralock);

  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169579
  000a2	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 145  :     }

  000af	eb c0		 jmp	 SHORT $LN2@cckd64_das
$LN3@cckd64_das:

; 146  :     release_lock(&cckdblk.ralock);

  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169580
  000b8	48 8d 0d 78 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk+120
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 147  : 
; 148  :     /* Flush the cache and wait for the writes to complete */
; 149  :     obtain_lock( &cckd->cckdiolock );

  000c5	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  000ca	48 83 c0 18	 add	 rax, 24
  000ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169581
  000d5	48 8b c8	 mov	 rcx, rax
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 150  :     {
; 151  :         cckd->stopping = 1;

  000de	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  000e3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000e6	83 c8 40	 or	 eax, 64			; 00000040H
  000e9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  000ee	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 152  :         cckd64_flush_cache( dev );

  000f1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000f9	e8 00 00 00 00	 call	 cckd64_flush_cache
$LN31@cckd64_das:
$LN4@cckd64_das:

; 153  :         while (cckd->wrpending || cckd->cckdioact)

  000fe	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00103	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  00107	75 16		 jne	 SHORT $LN15@cckd64_das
  00109	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0010e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00111	c1 e8 02	 shr	 eax, 2
  00114	83 e0 01	 and	 eax, 1
  00117	85 c0		 test	 eax, eax
  00119	0f 84 fe 01 00
	00		 je	 $LN5@cckd64_das
$LN15@cckd64_das:

; 154  :         {
; 155  :             cckd->cckdwaiters++;

  0011f	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00124	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00127	ff c0		 inc	 eax
  00129	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0012e	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 156  :             rc = timed_wait_condition_relative_usecs(

  00131	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00136	48 83 c0 18	 add	 rax, 24
  0013a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  0013f	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169583
  0014a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0014f	45 33 c9	 xor	 r9d, r9d
  00152	41 b8 40 42 0f
	00		 mov	 r8d, 1000000		; 000f4240H
  00158	48 8b d0	 mov	 rdx, rax
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timed_wait_condition_relative_usecs_impl
  00161	89 44 24 6c	 mov	 DWORD PTR rc$[rsp], eax

; 157  :                 &cckd->cckdiocond, &cckd->cckdiolock, 1000000, NULL );
; 158  :             cckd->cckdwaiters--;

  00165	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0016a	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0016d	ff c8		 dec	 eax
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00174	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 159  :             cckd64_flush_cache( dev );

  00177	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0017f	e8 00 00 00 00	 call	 cckd64_flush_cache

; 160  :             if (EINTR == rc)

  00184	83 7c 24 6c 04	 cmp	 DWORD PTR rc$[rsp], 4
  00189	75 05		 jne	 SHORT $LN16@cckd64_das

; 161  :                 continue;

  0018b	e9 6e ff ff ff	 jmp	 $LN4@cckd64_das
$LN16@cckd64_das:

; 162  :             /* Prevent rare but possible hang at shutdown */
; 163  :             if (1
; 164  :                 && ETIMEDOUT == rc
; 165  :                 && (cckd->wrpending || cckd->cckdioact)
; 166  :                 && sysblk.shutdown

  00190	33 c0		 xor	 eax, eax
  00192	83 f8 01	 cmp	 eax, 1
  00195	0f 84 7d 01 00
	00		 je	 $LN17@cckd64_das
  0019b	81 7c 24 6c 8a
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 138	; 0000008aH
  001a3	0f 85 6f 01 00
	00		 jne	 $LN17@cckd64_das
  001a9	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  001ae	83 78 34 00	 cmp	 DWORD PTR [rax+52], 0
  001b2	75 16		 jne	 SHORT $LN18@cckd64_das
  001b4	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  001b9	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001bc	c1 e8 02	 shr	 eax, 2
  001bf	83 e0 01	 and	 eax, 1
  001c2	85 c0		 test	 eax, eax
  001c4	0f 84 4e 01 00
	00		 je	 $LN17@cckd64_das
$LN18@cckd64_das:
  001ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001d1	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  001d7	c1 e8 0b	 shr	 eax, 11
  001da	83 e0 01	 and	 eax, 1
  001dd	85 c0		 test	 eax, eax
  001df	0f 84 33 01 00
	00		 je	 $LN17@cckd64_das

; 167  :             )
; 168  :             {
; 169  :                 CCKD_TRACE( "closing device while wrpending=%d cckdioact=%d",

  001e5	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  001ea	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001ed	c1 e8 02	 shr	 eax, 2
  001f0	83 e0 01	 and	 eax, 1
  001f3	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001f7	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  001fc	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  001ff	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00203	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169587
  0020a	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00212	ba aa 00 00 00	 mov	 edx, 170		; 000000aaH
  00217	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169588
  0021e	e8 00 00 00 00	 call	 cckd_trace

; 170  :                     cckd->wrpending, cckd->cckdioact );
; 171  :                 // "%1d:%04X CCKD file %s: closing device while wrpending=%d cckdioact=%d"
; 172  :                 WRMSG( HHC00381, "W", LCSS_DEVNUM, dev->filename,

  00223	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0022c	74 12		 je	 SHORT $LN27@cckd64_das
  0022e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00236	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0023a	89 44 24 70	 mov	 DWORD PTR tv181[rsp], eax
  0023e	eb 08		 jmp	 SHORT $LN28@cckd64_das
$LN27@cckd64_das:
  00240	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
$LN28@cckd64_das:
  00248	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00251	74 14		 je	 SHORT $LN29@cckd64_das
  00253	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0025b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0025f	d1 f8		 sar	 eax, 1
  00261	89 44 24 74	 mov	 DWORD PTR tv187[rsp], eax
  00265	eb 08		 jmp	 SHORT $LN30@cckd64_das
$LN29@cckd64_das:
  00267	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN30@cckd64_das:
  0026f	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00274	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00277	c1 e8 02	 shr	 eax, 2
  0027a	83 e0 01	 and	 eax, 1
  0027d	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv172[rsp], eax
  00284	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0028c	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00293	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv176[rsp], rcx
  0029b	b9 01 00 00 00	 mov	 ecx, 1
  002a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002a6	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv172[rsp]
  002ad	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  002b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  002b6	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  002b9	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002bd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv176[rsp]
  002c5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002ca	8b 4c 24 70	 mov	 ecx, DWORD PTR tv181[rsp]
  002ce	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002d2	8b 4c 24 74	 mov	 ecx, DWORD PTR tv187[rsp]
  002d6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169589
  002e1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169590
  002ed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f7	41 b9 03 00 00
	00		 mov	 r9d, 3
  002fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169591
  00304	ba ad 00 00 00	 mov	 edx, 173		; 000000adH
  00309	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169592
  00310	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 173  :                     cckd->wrpending, cckd->cckdioact );
; 174  :                 break;

  00316	eb 05		 jmp	 SHORT $LN5@cckd64_das
$LN17@cckd64_das:

; 175  :             }
; 176  :         }

  00318	e9 e1 fd ff ff	 jmp	 $LN31@cckd64_das
$LN5@cckd64_das:

; 177  :         broadcast_condition( &cckd->cckdiocond );

  0031d	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00322	48 83 c0 20	 add	 rax, 32			; 00000020H
  00326	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169593
  0032d	48 8b c8	 mov	 rcx, rax
  00330	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition

; 178  :         cckd64_purge_cache( dev );

  00336	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0033e	e8 00 00 00 00	 call	 cckd64_purge_cache

; 179  :         cckd64_purge_l2( dev );

  00343	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0034b	e8 00 00 00 00	 call	 cckd64_purge_l2

; 180  :         dev->bufcur = -1;

  00350	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00358	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 181  :         dev->cache  = -1;

  00362	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0036a	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1

; 182  :         if (cckd->newbuf)

  00374	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00379	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0037e	74 1d		 je	 SHORT $LN19@cckd64_das

; 183  :             cckd_free( dev, "newbuf", cckd->newbuf );

  00380	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00385	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00389	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169595
  00390	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00398	e8 00 00 00 00	 call	 cckd_free
$LN19@cckd64_das:

; 184  :     }
; 185  :     release_lock( &cckd->cckdiolock );

  0039d	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  003a2	48 83 c0 18	 add	 rax, 24
  003a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169596
  003ad	48 8b c8	 mov	 rcx, rax
  003b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 186  : 
; 187  :     /* Remove the device from the cckd queue */
; 188  :     cckd_lock_devchain(1);

  003b6	b9 01 00 00 00	 mov	 ecx, 1
  003bb	e8 00 00 00 00	 call	 cckd_lock_devchain

; 189  :     if (dev == cckdblk.dev1st) cckdblk.dev1st = cckd->devnext;

  003c0	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  003c7	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR dev$[rsp], rax
  003cf	75 11		 jne	 SHORT $LN20@cckd64_das
  003d1	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  003d6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003d9	48 89 05 08 00
	00 00		 mov	 QWORD PTR cckdblk+8, rax
  003e0	eb 6b		 jmp	 SHORT $LN21@cckd64_das
$LN20@cckd64_das:

; 190  :     else
; 191  :     {
; 192  :         DEVBLK *dev2 = cckdblk.dev1st;

  003e2	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  003e9	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dev2$2[rsp], rax

; 193  :         CCKD64_EXT *cckd2 = dev2->cckd_ext;

  003f1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev2$2[rsp]
  003f9	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00400	48 89 44 24 78	 mov	 QWORD PTR cckd2$1[rsp], rax
$LN6@cckd64_das:

; 194  :         while (cckd2->devnext != dev)

  00405	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd2$1[rsp]
  0040a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00412	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00415	74 26		 je	 SHORT $LN7@cckd64_das

; 195  :         {
; 196  :            dev2 = cckd2->devnext; cckd2 = dev2->cckd_ext;

  00417	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd2$1[rsp]
  0041c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0041f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dev2$2[rsp], rax
  00427	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev2$2[rsp]
  0042f	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  00436	48 89 44 24 78	 mov	 QWORD PTR cckd2$1[rsp], rax

; 197  :         }

  0043b	eb c8		 jmp	 SHORT $LN6@cckd64_das
$LN7@cckd64_das:

; 198  :         cckd2->devnext = cckd->devnext;

  0043d	48 8b 44 24 78	 mov	 rax, QWORD PTR cckd2$1[rsp]
  00442	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00447	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0044a	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN21@cckd64_das:

; 199  :     }
; 200  :     cckd_unlock_devchain();

  0044d	e8 00 00 00 00	 call	 cckd_unlock_devchain

; 201  : 
; 202  :     /* harden the file */
; 203  :     obtain_lock( &cckd->filelock );

  00452	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00457	48 83 c0 10	 add	 rax, 16
  0045b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169599
  00462	48 8b c8	 mov	 rcx, rax
  00465	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 204  :     {
; 205  :         cckd64_harden (dev);

  0046b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00473	e8 00 00 00 00	 call	 cckd64_harden

; 206  : 
; 207  :         /* close the shadow files */
; 208  :         for (i = 1; i <= cckd->sfn; i++)

  00478	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00480	eb 0a		 jmp	 SHORT $LN10@cckd64_das
$LN8@cckd64_das:
  00482	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00486	ff c0		 inc	 eax
  00488	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN10@cckd64_das:
  0048c	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00491	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  00494	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  00498	7f 25		 jg	 SHORT $LN9@cckd64_das

; 209  :         {
; 210  :             cckd64_close (dev, i);

  0049a	8b 54 24 68	 mov	 edx, DWORD PTR i$[rsp]
  0049e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004a6	e8 00 00 00 00	 call	 cckd64_close

; 211  :             cckd->open[i] = 0;

  004ab	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  004b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  004b5	c6 84 01 1d 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+285], 0

; 212  :         }

  004bd	eb c3		 jmp	 SHORT $LN8@cckd64_das
$LN9@cckd64_das:

; 213  : 
; 214  :         /* free the level 1 tables */
; 215  :         for (i = 0; i <= cckd->sfn; i++)

  004bf	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004c7	eb 0a		 jmp	 SHORT $LN13@cckd64_das
$LN11@cckd64_das:
  004c9	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  004cd	ff c0		 inc	 eax
  004cf	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN13@cckd64_das:
  004d3	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  004d8	8b 40 3c	 mov	 eax, DWORD PTR [rax+60]
  004db	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  004df	7f 3a		 jg	 SHORT $LN12@cckd64_das

; 216  :             cckd->L1tab[i] = cckd_free (dev, "l1", cckd->L1tab[i]);

  004e1	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  004e6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  004eb	4c 8b 84 c1 98
	01 00 00	 mov	 r8, QWORD PTR [rcx+rax*8+408]
  004f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169600
  004fa	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00502	e8 00 00 00 00	 call	 cckd_free
  00507	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR i$[rsp]
  0050c	48 8b 54 24 60	 mov	 rdx, QWORD PTR cckd$[rsp]
  00511	48 89 84 ca 98
	01 00 00	 mov	 QWORD PTR [rdx+rcx*8+408], rax
  00519	eb ae		 jmp	 SHORT $LN11@cckd64_das
$LN12@cckd64_das:

; 217  : 
; 218  :         /* reset the device handler */
; 219  :         if (cckd->ckddasd)

  0051b	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  00520	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00523	83 e0 01	 and	 eax, 1
  00526	85 c0		 test	 eax, eax
  00528	74 18		 je	 SHORT $LN22@cckd64_das

; 220  :             dev->hnd = &ckd_dasd_device_hndinfo;

  0052a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00532	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ckd_dasd_device_hndinfo
  00539	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx
  00540	eb 16		 jmp	 SHORT $LN23@cckd64_das
$LN22@cckd64_das:

; 221  :         else
; 222  :             dev->hnd = &fba_dasd_device_hndinfo;

  00542	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0054a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:fba_dasd_device_hndinfo
  00551	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx
$LN23@cckd64_das:

; 223  : 
; 224  :         /* write some statistics */
; 225  :         if (!dev->batch && !cckdblk.nosfd)

  00558	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00560	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00566	c1 e8 0a	 shr	 eax, 10
  00569	83 e0 01	 and	 eax, 1
  0056c	85 c0		 test	 eax, eax
  0056e	75 16		 jne	 SHORT $LN24@cckd64_das
  00570	83 3d 50 02 00
	00 00		 cmp	 DWORD PTR cckdblk+592, 0
  00577	75 0d		 jne	 SHORT $LN24@cckd64_das

; 226  :             cckd64_sf_stats (dev);

  00579	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00581	e8 00 00 00 00	 call	 cckd64_sf_stats
$LN24@cckd64_das:

; 227  :     }
; 228  :     release_lock( &cckd->filelock );

  00586	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  0058b	48 83 c0 10	 add	 rax, 16
  0058f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169604
  00596	48 8b c8	 mov	 rcx, rax
  00599	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 229  : 
; 230  :     /* Destroy the cckd extension's locks and conditions */
; 231  :     destroy_lock( &cckd->cckdiolock );

  0059f	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  005a4	48 83 c0 18	 add	 rax, 24
  005a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169605
  005af	48 8b c8	 mov	 rcx, rax
  005b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_lock

; 232  :     destroy_lock( &cckd->filelock );

  005b8	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  005bd	48 83 c0 10	 add	 rax, 16
  005c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169606
  005c8	48 8b c8	 mov	 rcx, rax
  005cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_lock

; 233  :     destroy_condition( &cckd->cckdiocond );

  005d1	48 8b 44 24 60	 mov	 rax, QWORD PTR cckd$[rsp]
  005d6	48 83 c0 20	 add	 rax, 32			; 00000020H
  005da	48 8b c8	 mov	 rcx, rax
  005dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_condition

; 234  : 
; 235  :     /* free the cckd extension itself */
; 236  :     dev->cckd_ext= cckd_free (dev, "ext", cckd);

  005e3	4c 8b 44 24 60	 mov	 r8, QWORD PTR cckd$[rsp]
  005e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169607
  005ef	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005f7	e8 00 00 00 00	 call	 cckd_free
  005fc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00604	48 89 81 08 13
	00 00		 mov	 QWORD PTR [rcx+4872], rax

; 237  : 
; 238  :     if (dev->dasdsfn) free (dev->dasdsfn);

  0060b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00613	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  0061b	74 15		 je	 SHORT $LN25@cckd64_das
  0061d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00625	48 8b 88 70 11
	00 00		 mov	 rcx, QWORD PTR [rax+4464]
  0062c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN25@cckd64_das:

; 239  :     dev->dasdsfn = NULL;

  00632	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0063a	48 c7 80 70 11
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4464], 0

; 240  : 
; 241  :     close (dev->fd);

  00645	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0064d	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00653	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 242  :     dev->fd = -1;

  00659	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00661	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 243  : 
; 244  :     /* If no more devices then perform global termination */
; 245  :     cckd_dasd_term_if_appropriate();

  0066b	e8 00 00 00 00	 call	 cckd_dasd_term_if_appropriate

; 246  : 
; 247  :     dev->buf = NULL;

  00670	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00678	48 c7 80 c8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+456], 0

; 248  :     dev->bufsize = 0;

  00683	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0068b	c7 80 d8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+472], 0

; 249  : 
; 250  :     return 0;

  00695	33 c0		 xor	 eax, eax
$LN1@cckd64_das:

; 251  : } /* end function cckd64_dasd_close_device */

  00697	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0069e	c3		 ret	 0
cckd64_dasd_close_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddasd64.c
_TEXT	SEGMENT
cckd$ = 80
i$ = 88
tv90 = 92
tv128 = 96
tv143 = 100
tv149 = 104
tv179 = 108
tv210 = 112
tv216 = 116
fdflags$ = 120
dev2$ = 128
buf$ = 136
__$ArrayPad$ = 168
dev$ = 192
argc$ = 200
argv$ = 208
cckd64_dasd_init_handler PROC

; 34   : {

$LN40:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@cckd64_das:

; 35   : CCKD64_EXT  *cckd;                      /* -> cckd extension         */
; 36   : DEVBLK      *dev2;                      /* -> device in cckd queue   */
; 37   : int          i;                         /* Counter                   */
; 38   : int          fdflags;                   /* File flags                */
; 39   : char         buf[32];                   /* Work buffer                      */
; 40   : 
; 41   :     UNREFERENCED( argc );

  00027	33 c0		 xor	 eax, eax
  00029	85 c0		 test	 eax, eax
  0002b	75 fa		 jne	 SHORT $LN4@cckd64_das
$LN7@cckd64_das:

; 42   :     UNREFERENCED( argv );

  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 fa		 jne	 SHORT $LN7@cckd64_das

; 43   : 
; 44   :     /* Initialize the global cckd block if necessary */
; 45   :     if (memcmp( &cckdblk.id, CCKDBLK_ID, sizeof( cckdblk.id )))

  00033	41 b8 08 00 00
	00		 mov	 r8d, 8
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169527
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cckdblk
  00047	e8 00 00 00 00	 call	 memcmp
  0004c	85 c0		 test	 eax, eax
  0004e	74 09		 je	 SHORT $LN14@cckd64_das

; 46   :         cckd_dasd_init( 0, NULL );

  00050	33 d2		 xor	 edx, edx
  00052	33 c9		 xor	 ecx, ecx
  00054	e8 00 00 00 00	 call	 cckd_dasd_init
$LN14@cckd64_das:

; 47   : 
; 48   :     /* Obtain area for cckd extension */
; 49   :     dev->cckd_ext = cckd = cckd_calloc( dev, "ext", 1, sizeof( CCKD64_EXT ));

  00059	41 b9 e0 13 00
	00		 mov	 r9d, 5088		; 000013e0H
  0005f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169528
  0006c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00074	e8 00 00 00 00	 call	 cckd_calloc
  00079	48 89 44 24 50	 mov	 QWORD PTR cckd$[rsp], rax
  0007e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00086	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0008b	48 89 88 08 13
	00 00		 mov	 QWORD PTR [rax+4872], rcx

; 50   :     if (cckd == NULL)

  00092	48 83 7c 24 50
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  00098	75 0a		 jne	 SHORT $LN15@cckd64_das

; 51   :         return -1;

  0009a	b8 ff ff ff ff	 mov	 eax, -1
  0009f	e9 de 04 00 00	 jmp	 $LN1@cckd64_das
$LN15@cckd64_das:

; 52   : 
; 53   :     /* Initialize locks and conditions */
; 54   : 
; 55   :     initialize_lock( &cckd->cckdiolock );

  000a4	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  000a9	48 83 c0 18	 add	 rax, 24
  000ad	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169530
  000b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169531
  000bb	48 8b c8	 mov	 rcx, rax
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 56   :     MSGBUF( buf,    "&cckd->cckdiolock %1d:%04X", LCSS_DEVNUM );

  000c4	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000cd	74 12		 je	 SHORT $LN26@cckd64_das
  000cf	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000db	89 44 24 5c	 mov	 DWORD PTR tv90[rsp], eax
  000df	eb 08		 jmp	 SHORT $LN27@cckd64_das
$LN26@cckd64_das:
  000e1	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN27@cckd64_das:
  000e9	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000f2	74 14		 je	 SHORT $LN28@cckd64_das
  000f4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000fc	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00100	d1 f8		 sar	 eax, 1
  00102	89 44 24 60	 mov	 DWORD PTR tv128[rsp], eax
  00106	eb 08		 jmp	 SHORT $LN29@cckd64_das
$LN28@cckd64_das:
  00108	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN29@cckd64_das:
  00110	8b 44 24 5c	 mov	 eax, DWORD PTR tv90[rsp]
  00114	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00118	44 8b 4c 24 60	 mov	 r9d, DWORD PTR tv128[rsp]
  0011d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169532
  00124	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00129	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 57   :     set_lock_name(   &cckd->cckdiolock, buf );

  00137	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0013c	48 83 c0 18	 add	 rax, 24
  00140	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00148	48 8b c8	 mov	 rcx, rax
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_lock_name

; 58   : 
; 59   :     initialize_lock( &cckd->filelock );

  00151	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00156	48 83 c0 10	 add	 rax, 16
  0015a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169533
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169534
  00168	48 8b c8	 mov	 rcx, rax
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 60   :     MSGBUF( buf,    "&cckd->filelock %1d:%04X", LCSS_DEVNUM );

  00171	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0017a	74 12		 je	 SHORT $LN30@cckd64_das
  0017c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00184	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00188	89 44 24 64	 mov	 DWORD PTR tv143[rsp], eax
  0018c	eb 08		 jmp	 SHORT $LN31@cckd64_das
$LN30@cckd64_das:
  0018e	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN31@cckd64_das:
  00196	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0019f	74 14		 je	 SHORT $LN32@cckd64_das
  001a1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a9	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001ad	d1 f8		 sar	 eax, 1
  001af	89 44 24 68	 mov	 DWORD PTR tv149[rsp], eax
  001b3	eb 08		 jmp	 SHORT $LN33@cckd64_das
$LN32@cckd64_das:
  001b5	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN33@cckd64_das:
  001bd	8b 44 24 64	 mov	 eax, DWORD PTR tv143[rsp]
  001c1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001c5	44 8b 4c 24 68	 mov	 r9d, DWORD PTR tv149[rsp]
  001ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169535
  001d1	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001d6	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  001de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 61   :     set_lock_name(   &cckd->filelock, buf );

  001e4	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  001e9	48 83 c0 10	 add	 rax, 16
  001ed	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  001f5	48 8b c8	 mov	 rcx, rax
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_lock_name

; 62   : 
; 63   :     initialize_condition( &cckd->cckdiocond );

  001fe	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00203	48 83 c0 20	 add	 rax, 32			; 00000020H
  00207	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169536
  0020e	48 8b c8	 mov	 rcx, rax
  00211	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 64   : 
; 65   :     /* Initialize some variables */
; 66   :     obtain_lock( &cckd->filelock );

  00217	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0021c	48 83 c0 10	 add	 rax, 16
  00220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169537
  00227	48 8b c8	 mov	 rcx, rax
  0022a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 67   :     {
; 68   :         cckd->L1idx = cckd->sfx = cckd->L2_active = -1;

  00230	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00235	c7 40 50 ff ff
	ff ff		 mov	 DWORD PTR [rax+80], -1
  0023c	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00241	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
  00248	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0024d	c7 40 44 ff ff
	ff ff		 mov	 DWORD PTR [rax+68], -1

; 69   :         dev->cache = cckd->free_idx1st = -1;

  00254	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00259	c7 40 7c ff ff
	ff ff		 mov	 DWORD PTR [rax+124], -1
  00260	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00268	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1

; 70   :         cckd->fd[0] = dev->fd;

  00272	b8 04 00 00 00	 mov	 eax, 4
  00277	48 6b c0 00	 imul	 rax, rax, 0
  0027b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00280	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00288	8b 92 ac 01 00
	00		 mov	 edx, DWORD PTR [rdx+428]
  0028e	89 94 01 f0 00
	00 00		 mov	 DWORD PTR [rcx+rax+240], edx

; 71   :         fdflags = get_file_accmode_flags( dev->fd );

  00295	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0029d	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_get_file_accmode_flags
  002a9	89 44 24 78	 mov	 DWORD PTR fdflags$[rsp], eax

; 72   :         cckd->open[0] = (fdflags & O_RDWR) ? CCKD_OPEN_RW : CCKD_OPEN_RO;

  002ad	8b 44 24 78	 mov	 eax, DWORD PTR fdflags$[rsp]
  002b1	83 e0 02	 and	 eax, 2
  002b4	85 c0		 test	 eax, eax
  002b6	74 0a		 je	 SHORT $LN34@cckd64_das
  002b8	c7 44 24 6c 03
	00 00 00	 mov	 DWORD PTR tv179[rsp], 3
  002c0	eb 08		 jmp	 SHORT $LN35@cckd64_das
$LN34@cckd64_das:
  002c2	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
$LN35@cckd64_das:
  002ca	b8 01 00 00 00	 mov	 eax, 1
  002cf	48 6b c0 00	 imul	 rax, rax, 0
  002d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  002d8	0f b6 54 24 6c	 movzx	 edx, BYTE PTR tv179[rsp]
  002dd	88 94 01 1d 01
	00 00		 mov	 BYTE PTR [rcx+rax+285], dl

; 73   :         for (i = 1; i <= CCKD_MAX_SF; i++)

  002e4	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  002ec	eb 0a		 jmp	 SHORT $LN10@cckd64_das
$LN8@cckd64_das:
  002ee	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  002f2	ff c0		 inc	 eax
  002f4	89 44 24 58	 mov	 DWORD PTR i$[rsp], eax
$LN10@cckd64_das:
  002f8	83 7c 24 58 08	 cmp	 DWORD PTR i$[rsp], 8
  002fd	7f 29		 jg	 SHORT $LN9@cckd64_das

; 74   :         {
; 75   :             cckd->fd[i] = -1;

  002ff	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  00304	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  00309	c7 84 81 f0 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+240], -1

; 76   :             cckd->open[i] = CCKD_OPEN_NONE;

  00314	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$[rsp]
  00319	48 8b 4c 24 50	 mov	 rcx, QWORD PTR cckd$[rsp]
  0031e	c6 84 01 1d 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+285], 0

; 77   :         }

  00326	eb c6		 jmp	 SHORT $LN8@cckd64_das
$LN9@cckd64_das:

; 78   :         cckd->cckd_maxsize = CCKD64_MAXSIZE;

  00328	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0032d	48 c7 40 28 ff
	ff ff ff	 mov	 QWORD PTR [rax+40], -1

; 79   : 
; 80   :         /* call the chkdsk function */
; 81   :         if (cckd64_chkdsk (dev, 0) < 0)

  00335	33 d2		 xor	 edx, edx
  00337	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0033f	e8 00 00 00 00	 call	 cckd64_chkdsk
  00344	85 c0		 test	 eax, eax
  00346	7d 0a		 jge	 SHORT $LN16@cckd64_das

; 82   :             return -1;

  00348	b8 ff ff ff ff	 mov	 eax, -1
  0034d	e9 30 02 00 00	 jmp	 $LN1@cckd64_das
$LN16@cckd64_das:

; 83   : 
; 84   :         /* Perform initial read */
; 85   :         if (cckd64_read_init (dev) < 0)

  00352	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0035a	e8 00 00 00 00	 call	 cckd64_read_init
  0035f	85 c0		 test	 eax, eax
  00361	7d 0a		 jge	 SHORT $LN17@cckd64_das

; 86   :             return -1;

  00363	b8 ff ff ff ff	 mov	 eax, -1
  00368	e9 15 02 00 00	 jmp	 $LN1@cckd64_das
$LN17@cckd64_das:

; 87   :         if (cckd->fbadasd) dev->ckdtrksz = CFBA_BLKGRP_SIZE;

  0036d	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00372	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00375	d1 e8		 shr	 eax, 1
  00377	83 e0 01	 and	 eax, 1
  0037a	85 c0		 test	 eax, eax
  0037c	74 12		 je	 SHORT $LN18@cckd64_das
  0037e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00386	c7 80 c4 12 00
	00 00 f0 00 00	 mov	 DWORD PTR [rax+4804], 61440 ; 0000f000H
$LN18@cckd64_das:

; 88   : 
; 89   :         /* open the shadow files */
; 90   :         if (cckd64_sf_init (dev) < 0)

  00390	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00398	e8 00 00 00 00	 call	 cckd64_sf_init
  0039d	85 c0		 test	 eax, eax
  0039f	0f 8d ad 00 00
	00		 jge	 $LN19@cckd64_das

; 91   :         {
; 92   :             WRMSG (HHC00300, "E", LCSS_DEVNUM);

  003a5	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003ae	74 12		 je	 SHORT $LN36@cckd64_das
  003b0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003bc	89 44 24 70	 mov	 DWORD PTR tv210[rsp], eax
  003c0	eb 08		 jmp	 SHORT $LN37@cckd64_das
$LN36@cckd64_das:
  003c2	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN37@cckd64_das:
  003ca	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003d3	74 14		 je	 SHORT $LN38@cckd64_das
  003d5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003dd	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003e1	d1 f8		 sar	 eax, 1
  003e3	89 44 24 74	 mov	 DWORD PTR tv216[rsp], eax
  003e7	eb 08		 jmp	 SHORT $LN39@cckd64_das
$LN38@cckd64_das:
  003e9	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv216[rsp], 0
$LN39@cckd64_das:
  003f1	b9 01 00 00 00	 mov	 ecx, 1
  003f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003fc	8b 4c 24 70	 mov	 ecx, DWORD PTR tv210[rsp]
  00400	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00404	8b 4c 24 74	 mov	 ecx, DWORD PTR tv216[rsp]
  00408	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0040c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169542
  00413	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00418	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169543
  0041f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00424	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00429	41 b9 03 00 00
	00		 mov	 r9d, 3
  0042f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169544
  00436	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  0043b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169545
  00442	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 93   :             return -1;

  00448	b8 ff ff ff ff	 mov	 eax, -1
  0044d	e9 30 01 00 00	 jmp	 $LN1@cckd64_das
$LN19@cckd64_das:

; 94   :         }
; 95   : 
; 96   :         /* Update the device handler routines */
; 97   :         if (cckd->ckddasd)

  00452	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00457	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0045a	83 e0 01	 and	 eax, 1
  0045d	85 c0		 test	 eax, eax
  0045f	74 18		 je	 SHORT $LN20@cckd64_das

; 98   :             dev->hnd = &cckd_dasd_device_hndinfo;

  00461	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00469	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cckd_dasd_device_hndinfo
  00470	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx
  00477	eb 16		 jmp	 SHORT $LN21@cckd64_das
$LN20@cckd64_das:

; 99   :         else
; 100  :             dev->hnd = &cfba_dasd_device_hndinfo;

  00479	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00481	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cfba_dasd_device_hndinfo
  00488	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx
$LN21@cckd64_das:

; 101  :     }
; 102  :     release_lock( &cckd->filelock );

  0048f	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  00494	48 83 c0 10	 add	 rax, 16
  00498	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169548
  0049f	48 8b c8	 mov	 rcx, rax
  004a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 103  : 
; 104  :     /* Insert the device into the cckd device queue */
; 105  :     cckd_lock_devchain(1);

  004a8	b9 01 00 00 00	 mov	 ecx, 1
  004ad	e8 00 00 00 00	 call	 cckd_lock_devchain

; 106  :     for (cckd = NULL, dev2 = cckdblk.dev1st; dev2; dev2 = cckd->devnext)

  004b2	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR cckd$[rsp], 0
  004bb	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR cckdblk+8
  004c2	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dev2$[rsp], rax
  004ca	eb 10		 jmp	 SHORT $LN13@cckd64_das
$LN11@cckd64_das:
  004cc	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  004d1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004d4	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dev2$[rsp], rax
$LN13@cckd64_das:
  004dc	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev2$[rsp], 0
  004e5	74 16		 je	 SHORT $LN12@cckd64_das

; 107  :         cckd = dev2->cckd_ext;

  004e7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev2$[rsp]
  004ef	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  004f6	48 89 44 24 50	 mov	 QWORD PTR cckd$[rsp], rax
  004fb	eb cf		 jmp	 SHORT $LN11@cckd64_das
$LN12@cckd64_das:

; 108  :     if (cckd) cckd->devnext = dev;

  004fd	48 83 7c 24 50
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  00503	74 12		 je	 SHORT $LN22@cckd64_das
  00505	48 8b 44 24 50	 mov	 rax, QWORD PTR cckd$[rsp]
  0050a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00512	48 89 08	 mov	 QWORD PTR [rax], rcx
  00515	eb 0f		 jmp	 SHORT $LN23@cckd64_das
$LN22@cckd64_das:

; 109  :     else cckdblk.dev1st = dev;

  00517	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0051f	48 89 05 08 00
	00 00		 mov	 QWORD PTR cckdblk+8, rax
$LN23@cckd64_das:

; 110  :     cckd_unlock_devchain();

  00526	e8 00 00 00 00	 call	 cckd_unlock_devchain

; 111  : 
; 112  :     cckdblk.batch = dev->batch;

  0052b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00533	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00539	c1 e8 0a	 shr	 eax, 10
  0053c	83 e0 01	 and	 eax, 1
  0053f	83 e0 01	 and	 eax, 1
  00542	8b 0d 10 00 00
	00		 mov	 ecx, DWORD PTR cckdblk+16
  00548	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0054b	0b c8		 or	 ecx, eax
  0054d	8b c1		 mov	 eax, ecx
  0054f	89 05 10 00 00
	00		 mov	 DWORD PTR cckdblk+16, eax

; 113  : 
; 114  :     if (cckdblk.batch)

  00555	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR cckdblk+16
  0055b	83 e0 01	 and	 eax, 1
  0055e	85 c0		 test	 eax, eax
  00560	74 1e		 je	 SHORT $LN24@cckd64_das

; 115  :     {
; 116  :         cckdblk.nostress = 1;

  00562	c7 05 54 02 00
	00 01 00 00 00	 mov	 DWORD PTR cckdblk+596, 1

; 117  :         cckdblk.freepend = 0;

  0056c	c7 05 48 02 00
	00 00 00 00 00	 mov	 DWORD PTR cckdblk+584, 0

; 118  :         cckdblk.linuxnull = 1;

  00576	c7 05 58 02 00
	00 01 00 00 00	 mov	 DWORD PTR cckdblk+600, 1
$LN24@cckd64_das:

; 119  :     }
; 120  : 
; 121  :     return 0;

  00580	33 c0		 xor	 eax, eax
$LN1@cckd64_das:

; 122  : } /* end function cckd64_dasd_init_handler */

  00582	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0058a	48 33 cc	 xor	 rcx, rsp
  0058d	e8 00 00 00 00	 call	 __security_check_cookie
  00592	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00599	c3		 ret	 0
cckd64_dasd_init_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
END
